diff --git a/.github/stale.yml b/.github/stale.yml
new file mode 100644
index 000000000..d20444829
--- /dev/null
+++ b/.github/stale.yml
@@ -0,0 +1,21 @@
+# Number of days of inactivity before an issue becomes stale
+daysUntilStale: 7
+# Number of days of inactivity before a stale issue is closed
+daysUntilClose: 7
+# Issues with these labels will never be considered stale
+exemptLabels:
+  - bug
+  - enhancement
+  - feature
+  - documentation
+  - build stability
+# Label to use when marking an issue as stale
+staleLabel: stale
+# Comment to post when marking an issue as stale. Set to `false` to disable
+markComment: >
+  This issue has been automatically marked as stale because it has not had
+  activity in the last seven days. It will be closed if no further activity
+  occurs within the next seven days. Thank you for your contributions.
+# Comment to post when closing a stale issue. Set to `false` to disable
+closeComment: false
+unmarkComment: false
diff --git a/.gitignore b/.gitignore
index 6a64b1779..0fdd65869 100644
--- a/.gitignore
+++ b/.gitignore
@@ -2,12 +2,11 @@
 local.properties
 *.keystore
 *.DS_Store
-proguard-project.txt
 
 # Gradle
-**/.gradle
-**/.settings
-**/build
+.gradle
+build
+jacoco.exec
 
 # gh-pages
 doc/**
@@ -19,24 +18,15 @@ docs/**/*
 *.swp
 *.swo
 
-# Intellij 
-*.ipr
+# sed
+*.bak
+
+# Intellij
 *.iml
+*.ipr
 *.iws
-**/.idea/.name
-**/.idea/compiler.xml
-**/.idea/copyright/profiles_settings.xml
-**/.idea/encodings.xml
-**/.idea/misc.xml
-**/.idea/modules.xml
-**/.idea/scopes/scope_settings.xml
-**/.idea/vcs.xml
-**/.idea/libraries
-**/.idea/workspace.xml
-**/.idea/tasks.xml
-**/.idea/gradle.xml
-**/.idea/dictionaries
-**/.idea/dataSources.ids
-**/.idea/datasources.xml
-**/.idea/uiDesigner.xml
-**/.idea/runConfigurations.xml
+.idea/**
+!.idea/codeStyleSettings.xml
+!.idea/inspectionProfiles
+!.idea/inspectionProfiles/Project_Default.xml
+
diff --git a/.gitmodules b/.gitmodules
index 525eef67a..d9d405d51 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,12 +1,6 @@
-[submodule "third_party/volley/volley"]
-	path = third_party/volley/volley
-	url = https://android.googlesource.com/platform/frameworks/volley
 [submodule "third_party/disklrucache"]
 	path = third_party/disklrucache
 	url = https://github.com/sjudd/DiskLruCache.git
-[submodule "library/src/androidTest/resources/exif-orientation-examples"]
-	path = library/src/androidTest/resources/exif-orientation-examples
+[submodule "library/test/src/test/resources/exif-orientation-examples"]
+	path = library/test/src/test/resources/exif-orientation-examples
 	url = https://github.com/recurser/exif-orientation-examples.git
-[submodule "library/src/test/resources/exif-orientation-examples"]
-	path = library/src/test/resources/exif-orientation-examples
-	url = https://github.com/recurser/exif-orientation-examples
diff --git a/.idea/codeStyleSettings.xml b/.idea/codeStyleSettings.xml
index fe060621a..ebd90ff05 100644
--- a/.idea/codeStyleSettings.xml
+++ b/.idea/codeStyleSettings.xml
@@ -15,245 +15,17 @@
             <option name="USE_RELATIVE_INDENTS" value="false" />
           </value>
         </option>
-        <option name="CLASS_COUNT_TO_USE_IMPORT_ON_DEMAND" value="99" />
-        <option name="NAMES_COUNT_TO_USE_IMPORT_ON_DEMAND" value="99" />
+        <option name="INSERT_INNER_CLASS_IMPORTS" value="true" />
+        <option name="CLASS_COUNT_TO_USE_IMPORT_ON_DEMAND" value="999" />
+        <option name="NAMES_COUNT_TO_USE_IMPORT_ON_DEMAND" value="999" />
+        <option name="PACKAGES_TO_USE_IMPORT_ON_DEMAND">
+          <value />
+        </option>
         <option name="IMPORT_LAYOUT_TABLE">
           <value>
             <package name="" withSubpackages="true" static="true" />
             <emptyLine />
-            <package name="com.google" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="android" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="antenna" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="antlr" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="ar" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="asposewobfuscated" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="asquare" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="atg" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="au" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="beaver" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="bibtex" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="bmsi" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="bsh" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="ccl" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="cern" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="ChartDirector" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="checkers" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="com" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="COM" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="common" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="contribs" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="corejava" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="cryptix" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="cybervillains" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="dalvik" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="danbikel" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="de" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="EDU" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="eg" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="eu" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="examples" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="fat" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="fit" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="fitlibrary" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="fmpp" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="freemarker" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="gnu" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="groovy" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="groovyjarjarantlr" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="groovyjarjarasm" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="hak" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="hep" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="ie" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="imageinfo" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="info" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="it" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jal" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="Jama" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="japa" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="japacheckers" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jas" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jasmin" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="javancss" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="javanet" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="javassist" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="javazoom" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="java_cup" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jcifs" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jetty" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="JFlex" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jj2000" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jline" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jp" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="JSci" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jsr166y" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="junit" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jxl" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jxxload_help" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="kawa" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="kea" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="libcore" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="libsvm" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="lti" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="memetic" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="mt" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="mx4j" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="net" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="netscape" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="nl" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="nu" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="oauth" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="ognl" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="opennlp" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="oracle" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="org" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="penn2dg" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="pennconverter" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="pl" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="prefuse" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="proguard" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="repackage" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="scm" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="se" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="serp" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="simple" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="soot" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="sqlj" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="src" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="ssa" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="sun" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="sunlabs" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="tcl" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="testdata" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="testshell" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="testsuite" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="twitter4j" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="uk" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="ViolinStrings" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="weka" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="wet" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="winstone" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="woolfel" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="wowza" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="java" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="javax" withSubpackages="true" static="false" />
-            <emptyLine />
             <package name="" withSubpackages="true" static="false" />
-            <emptyLine />
-            <emptyLine />
           </value>
         </option>
         <option name="RIGHT_MARGIN" value="100" />
@@ -263,20 +35,13 @@
         <option name="JD_KEEP_EMPTY_RETURN" value="false" />
         <option name="KEEP_CONTROL_STATEMENT_IN_ONE_LINE" value="false" />
         <option name="KEEP_BLANK_LINES_IN_CODE" value="1" />
-        <option name="BLANK_LINES_AFTER_CLASS_HEADER" value="1" />
-        <option name="ALIGN_MULTILINE_PARAMETERS_IN_CALLS" value="true" />
-        <option name="ALIGN_MULTILINE_BINARY_OPERATION" value="true" />
-        <option name="ALIGN_MULTILINE_ASSIGNMENT" value="true" />
-        <option name="ALIGN_MULTILINE_TERNARY_OPERATION" value="true" />
-        <option name="ALIGN_MULTILINE_THROWS_LIST" value="true" />
-        <option name="ALIGN_MULTILINE_EXTENDS_LIST" value="true" />
-        <option name="ALIGN_MULTILINE_PARENTHESIZED_EXPRESSION" value="true" />
-        <option name="ALIGN_MULTILINE_ARRAY_INITIALIZER_EXPRESSION" value="true" />
+        <option name="KEEP_BLANK_LINES_BEFORE_RBRACE" value="0" />
+        <option name="ALIGN_MULTILINE_PARAMETERS" value="false" />
+        <option name="ALIGN_MULTILINE_FOR" value="false" />
+        <option name="SPACE_BEFORE_ARRAY_INITIALIZER_LBRACE" value="true" />
         <option name="CALL_PARAMETERS_WRAP" value="1" />
         <option name="METHOD_PARAMETERS_WRAP" value="1" />
         <option name="EXTENDS_LIST_WRAP" value="1" />
-        <option name="THROWS_LIST_WRAP" value="1" />
-        <option name="EXTENDS_KEYWORD_WRAP" value="1" />
         <option name="THROWS_KEYWORD_WRAP" value="1" />
         <option name="METHOD_CALL_CHAIN_WRAP" value="1" />
         <option name="BINARY_OPERATION_WRAP" value="1" />
@@ -285,70 +50,515 @@
         <option name="TERNARY_OPERATION_SIGNS_ON_NEXT_LINE" value="true" />
         <option name="FOR_STATEMENT_WRAP" value="1" />
         <option name="ARRAY_INITIALIZER_WRAP" value="1" />
-        <option name="ASSIGNMENT_WRAP" value="5" />
         <option name="WRAP_COMMENTS" value="true" />
         <option name="IF_BRACE_FORCE" value="3" />
         <option name="DOWHILE_BRACE_FORCE" value="3" />
         <option name="WHILE_BRACE_FORCE" value="3" />
         <option name="FOR_BRACE_FORCE" value="3" />
-        <Objective-C-extensions>
-          <option name="GENERATE_INSTANCE_VARIABLES_FOR_PROPERTIES" value="ASK" />
-          <option name="RELEASE_STYLE" value="IVAR" />
-          <option name="TYPE_QUALIFIERS_PLACEMENT" value="BEFORE" />
-          <file>
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Import" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Macro" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Typedef" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Enum" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Constant" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Global" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Struct" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="FunctionPredecl" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Function" />
-          </file>
-          <class>
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Property" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Synthesize" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="InitMethod" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="StaticMethod" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="InstanceMethod" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="DeallocMethod" />
-          </class>
-          <extensions>
-            <pair source="cpp" header="h" />
-            <pair source="c" header="h" />
-          </extensions>
-        </Objective-C-extensions>
+        <AndroidXmlCodeStyleSettings>
+          <option name="USE_CUSTOM_SETTINGS" value="true" />
+          <option name="LAYOUT_SETTINGS">
+            <value>
+              <option name="INSERT_BLANK_LINE_BEFORE_TAG" value="false" />
+            </value>
+          </option>
+        </AndroidXmlCodeStyleSettings>
+        <JSCodeStyleSettings>
+          <option name="INDENT_CHAINED_CALLS" value="false" />
+        </JSCodeStyleSettings>
+        <JavaCodeStyleSettings>
+          <option name="DO_NOT_WRAP_AFTER_SINGLE_ANNOTATION" value="true" />
+        </JavaCodeStyleSettings>
+        <Python>
+          <option name="USE_CONTINUATION_INDENT_FOR_ARGUMENTS" value="true" />
+        </Python>
+        <TypeScriptCodeStyleSettings>
+          <option name="INDENT_CHAINED_CALLS" value="false" />
+        </TypeScriptCodeStyleSettings>
         <XML>
+          <option name="XML_ALIGN_ATTRIBUTES" value="false" />
           <option name="XML_LEGACY_SETTINGS_IMPORTED" value="true" />
         </XML>
-        <ADDITIONAL_INDENT_OPTIONS fileType="haml">
-          <option name="INDENT_SIZE" value="2" />
-        </ADDITIONAL_INDENT_OPTIONS>
-        <ADDITIONAL_INDENT_OPTIONS fileType="java">
-          <option name="INDENT_SIZE" value="2" />
-          <option name="CONTINUATION_INDENT_SIZE" value="4" />
-          <option name="TAB_SIZE" value="8" />
-        </ADDITIONAL_INDENT_OPTIONS>
-        <ADDITIONAL_INDENT_OPTIONS fileType="js">
-          <option name="CONTINUATION_INDENT_SIZE" value="4" />
-        </ADDITIONAL_INDENT_OPTIONS>
-        <ADDITIONAL_INDENT_OPTIONS fileType="sass">
-          <option name="INDENT_SIZE" value="2" />
-        </ADDITIONAL_INDENT_OPTIONS>
-        <ADDITIONAL_INDENT_OPTIONS fileType="yml">
-          <option name="INDENT_SIZE" value="2" />
-        </ADDITIONAL_INDENT_OPTIONS>
+        <codeStyleSettings language="CSS">
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="CONTINUATION_INDENT_SIZE" value="4" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="ECMA Script Level 4">
+          <option name="KEEP_BLANK_LINES_IN_CODE" value="1" />
+          <option name="ALIGN_MULTILINE_PARAMETERS" value="false" />
+          <option name="ALIGN_MULTILINE_FOR" value="false" />
+          <option name="CALL_PARAMETERS_WRAP" value="1" />
+          <option name="METHOD_PARAMETERS_WRAP" value="1" />
+          <option name="EXTENDS_LIST_WRAP" value="1" />
+          <option name="BINARY_OPERATION_WRAP" value="1" />
+          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />
+          <option name="TERNARY_OPERATION_WRAP" value="1" />
+          <option name="TERNARY_OPERATION_SIGNS_ON_NEXT_LINE" value="true" />
+          <option name="FOR_STATEMENT_WRAP" value="1" />
+          <option name="ARRAY_INITIALIZER_WRAP" value="1" />
+          <option name="IF_BRACE_FORCE" value="3" />
+          <option name="DOWHILE_BRACE_FORCE" value="3" />
+          <option name="WHILE_BRACE_FORCE" value="3" />
+          <option name="FOR_BRACE_FORCE" value="3" />
+          <option name="PARENT_SETTINGS_INSTALLED" value="true" />
+        </codeStyleSettings>
+        <codeStyleSettings language="HTML">
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="CONTINUATION_INDENT_SIZE" value="4" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
         <codeStyleSettings language="JAVA">
+          <option name="KEEP_CONTROL_STATEMENT_IN_ONE_LINE" value="false" />
+          <option name="KEEP_BLANK_LINES_IN_CODE" value="1" />
+          <option name="ALIGN_MULTILINE_PARAMETERS" value="false" />
+          <option name="ALIGN_MULTILINE_RESOURCES" value="false" />
+          <option name="ALIGN_MULTILINE_FOR" value="false" />
+          <option name="CALL_PARAMETERS_WRAP" value="1" />
+          <option name="METHOD_PARAMETERS_WRAP" value="1" />
+          <option name="EXTENDS_LIST_WRAP" value="1" />
+          <option name="THROWS_KEYWORD_WRAP" value="1" />
+          <option name="METHOD_CALL_CHAIN_WRAP" value="1" />
+          <option name="BINARY_OPERATION_WRAP" value="1" />
+          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />
+          <option name="TERNARY_OPERATION_WRAP" value="1" />
+          <option name="TERNARY_OPERATION_SIGNS_ON_NEXT_LINE" value="true" />
+          <option name="KEEP_SIMPLE_BLOCKS_IN_ONE_LINE" value="true" />
+          <option name="KEEP_SIMPLE_METHODS_IN_ONE_LINE" value="true" />
+          <option name="KEEP_SIMPLE_LAMBDAS_IN_ONE_LINE" value="true" />
+          <option name="KEEP_SIMPLE_CLASSES_IN_ONE_LINE" value="true" />
+          <option name="FOR_STATEMENT_WRAP" value="1" />
+          <option name="ARRAY_INITIALIZER_WRAP" value="1" />
+          <option name="IF_BRACE_FORCE" value="3" />
+          <option name="DOWHILE_BRACE_FORCE" value="3" />
+          <option name="WHILE_BRACE_FORCE" value="3" />
+          <option name="FOR_BRACE_FORCE" value="3" />
+          <option name="PARENT_SETTINGS_INSTALLED" value="true" />
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="CONTINUATION_INDENT_SIZE" value="4" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="JSON">
+          <indentOptions>
+            <option name="CONTINUATION_INDENT_SIZE" value="4" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="JavaScript">
+          <option name="RIGHT_MARGIN" value="80" />
+          <option name="KEEP_BLANK_LINES_IN_CODE" value="1" />
           <option name="ALIGN_MULTILINE_PARAMETERS" value="false" />
+          <option name="ALIGN_MULTILINE_FOR" value="false" />
+          <option name="CALL_PARAMETERS_WRAP" value="1" />
+          <option name="METHOD_PARAMETERS_WRAP" value="1" />
+          <option name="BINARY_OPERATION_WRAP" value="1" />
+          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />
+          <option name="TERNARY_OPERATION_WRAP" value="1" />
+          <option name="TERNARY_OPERATION_SIGNS_ON_NEXT_LINE" value="true" />
+          <option name="FOR_STATEMENT_WRAP" value="1" />
+          <option name="ARRAY_INITIALIZER_WRAP" value="1" />
+          <option name="IF_BRACE_FORCE" value="3" />
+          <option name="DOWHILE_BRACE_FORCE" value="3" />
+          <option name="WHILE_BRACE_FORCE" value="3" />
+          <option name="FOR_BRACE_FORCE" value="3" />
+          <option name="PARENT_SETTINGS_INSTALLED" value="true" />
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="ObjectiveC">
+          <option name="KEEP_BLANK_LINES_BEFORE_RBRACE" value="1" />
+          <option name="BLANK_LINES_BEFORE_IMPORTS" value="0" />
+          <option name="BLANK_LINES_AFTER_IMPORTS" value="0" />
+          <option name="BLANK_LINES_AROUND_CLASS" value="0" />
+          <option name="BLANK_LINES_AROUND_METHOD" value="0" />
+          <option name="BLANK_LINES_AROUND_METHOD_IN_INTERFACE" value="0" />
+          <option name="ALIGN_MULTILINE_BINARY_OPERATION" value="false" />
+          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />
+          <option name="FOR_STATEMENT_WRAP" value="1" />
+          <option name="ASSIGNMENT_WRAP" value="1" />
           <indentOptions>
             <option name="INDENT_SIZE" value="2" />
             <option name="CONTINUATION_INDENT_SIZE" value="4" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="PROTO">
+          <option name="RIGHT_MARGIN" value="80" />
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="CONTINUATION_INDENT_SIZE" value="2" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="Python">
+          <option name="KEEP_BLANK_LINES_IN_CODE" value="1" />
+          <option name="RIGHT_MARGIN" value="80" />
+          <option name="ALIGN_MULTILINE_PARAMETERS" value="false" />
+          <option name="PARENT_SETTINGS_INSTALLED" value="true" />
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="CONTINUATION_INDENT_SIZE" value="4" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="SASS">
+          <indentOptions>
+            <option name="CONTINUATION_INDENT_SIZE" value="4" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="SCSS">
+          <indentOptions>
+            <option name="CONTINUATION_INDENT_SIZE" value="4" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="TypeScript">
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="XML">
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="CONTINUATION_INDENT_SIZE" value="2" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+          <arrangement>
+            <rules>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>xmlns:android</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>^$</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>xmlns:.*</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>^$</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:id</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>style</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>^$</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>^$</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:.*Style</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_width</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_height</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_weight</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_margin</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_marginTop</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_marginBottom</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_marginStart</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_marginEnd</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_marginLeft</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_marginRight</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_.*</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:padding</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:paddingTop</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:paddingBottom</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:paddingStart</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:paddingEnd</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:paddingLeft</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:paddingRight</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*</NAME>
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*</NAME>
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res-auto</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*</NAME>
+                      <XML_NAMESPACE>http://schemas.android.com/tools</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*</NAME>
+                      <XML_NAMESPACE>.*</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+            </rules>
+          </arrangement>
+        </codeStyleSettings>
+        <codeStyleSettings language="protobuf">
+          <option name="RIGHT_MARGIN" value="80" />
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="CONTINUATION_INDENT_SIZE" value="2" />
             <option name="TAB_SIZE" value="2" />
           </indentOptions>
         </codeStyleSettings>
       </value>
     </option>
-    <option name="PREFERRED_PROJECT_CODE_STYLE" value="GoogleStyle" />
+    <option name="USE_PER_PROJECT_SETTINGS" value="true" />
   </component>
-</project>
\ No newline at end of file
+</project>
diff --git a/.idea/inspectionProfiles/Project_Default.xml b/.idea/inspectionProfiles/Project_Default.xml
new file mode 100644
index 000000000..1c2b4c84f
--- /dev/null
+++ b/.idea/inspectionProfiles/Project_Default.xml
@@ -0,0 +1,9 @@
+<component name="InspectionProjectProfileManager">
+  <profile version="1.0">
+    <option name="myName" value="Project Default" />
+    <inspection_tool class="SerializableHasSerialVersionUIDField" enabled="true" level="WARNING" enabled_by_default="true">
+      <option name="ignoreAnonymousInnerClasses" value="false" />
+      <option name="superClassString" value="" />
+    </inspection_tool>
+  </profile>
+</component>
\ No newline at end of file
diff --git a/.travis.yml b/.travis.yml
index e3dc14645..cb517689d 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,30 +1,46 @@
 language: android
+sudo: false
+dist: trusty
+
+before_install:
+  - mkdir "$ANDROID_HOME/licenses" || true
+  - echo -e "\n8933bad161af4178b1185d1a37fbf41ea5269c55\nd56f5187479451eabf01fb78af6dfcb131a6481e" > "$ANDROID_HOME/licenses/android-sdk-license"
+  - echo -e "\n84831b9409646a918e30573bab4c9c91346d8abd\n504667f4c0de7af1a06de9f4b1727b84351f2910" > "$ANDROID_HOME/licenses/android-sdk-preview-license"
+
 android:
   components:
-  - tools
-  - platform-tools
-  - build-tools-25.0.2
-  - android-25
-  - extra-android-m2repository
-  - extra-android-support
-
-  licenses:
-  - 'android-sdk-license.*'
+    # https://github.com/travis-ci/travis-ci/issues/6040#issuecomment-219367943
+    - tools
+    - tools
 
 jdk:
   - oraclejdk8
 
-sudo: false
+env:
+  matrix:
+    - COMPONENT=unit
+    - COMPONENT=firebase
+    - COMPONENT=instrumentation ANDROID_TARGET=16
+    - COMPONENT=instrumentation ANDROID_TARGET=17
+    - COMPONENT=instrumentation ANDROID_TARGET=18
+    - COMPONENT=instrumentation ANDROID_TARGET=19
+    - COMPONENT=samples
+
+before_script:
+  - ./scripts/travis_before_script.sh
 
-script: 'travis_retry ./gradlew build'
+script:
+  - ./scripts/travis_script.sh
 
 after_success:
-- scripts/travis-sonatype-publish.sh
-- ./gradlew jacocoTestReport coveralls
+  - ./scripts/travis_after_success.sh
 
 before_cache:
   - rm -f $HOME/.gradle/caches/modules-2/modules-2.lock
+  - rm -fr $HOME/.gradle/caches/*/plugin-resolution/
 cache:
   directories:
     - $HOME/.gradle/caches/
     - $HOME/.gradle/wrapper/
+    - $HOME/.android/build-cache
+
diff --git a/README.md b/README.md
index 9a1eeb979..3ab88b264 100644
--- a/README.md
+++ b/README.md
@@ -2,7 +2,7 @@ Glide
 =====
 
 [![Maven Central](https://maven-badges.herokuapp.com/maven-central/com.github.bumptech.glide/glide/badge.svg)](https://maven-badges.herokuapp.com/maven-central/com.github.bumptech.glide/glide) [![Build Status](https://travis-ci.org/bumptech/glide.svg?branch=master)](https://travis-ci.org/bumptech/glide)
-| [View Glide's documentation][20] | [Report an issue with Glide][5]
+| [View Glide's documentation][20] | [简体中文文档][22] | [Report an issue with Glide][5]
 
 Glide is a fast and efficient open source media management and image loading framework for Android that wraps media
 decoding, memory and disk caching, and resource pooling into a simple and easy to use interface.
@@ -18,19 +18,21 @@ also effective for almost any case where you need to fetch, resize, and display
 
 Download
 --------
+For detailed instructions and requirements, see Glide's [download and setup docs page][28].
+
 You can download a jar from GitHub's [releases page][1].
 
 Or use Gradle:
 
 ```gradle
 repositories {
-  mavenCentral() // jcenter() works as well because it pulls from Maven Central
+  mavenCentral()
+  google()
 }
 
 dependencies {
-  compile 'com.github.bumptech.glide:glide:4.0.0'
-  compile 'com.android.support:support-v4:25.3.1'
-  annotationProcessor 'com.github.bumptech.glide:compiler:4.0.0'
+  implementation 'com.github.bumptech.glide:glide:4.8.0'
+  annotationProcessor 'com.github.bumptech.glide:compiler:4.8.0'
 }
 ```
 
@@ -40,31 +42,26 @@ Or Maven:
 <dependency>
   <groupId>com.github.bumptech.glide</groupId>
   <artifactId>glide</artifactId>
-  <version>4.0.0</version>
-</dependency>
-<dependency>
-  <groupId>com.google.android</groupId>
-  <artifactId>support-v4</artifactId>
-  <version>r7</version>
+  <version>4.8.0</version>
 </dependency>
 <dependency>
   <groupId>com.github.bumptech.glide</groupId>
   <artifactId>compiler</artifactId>
-  <version>4.0.0</version>
+  <version>4.8.0</version>
   <optional>true</optional>
 </dependency>
 ```
 
-For info on using the bleeding edge, see the [Snapshots][17] wiki page.
+For info on using the bleeding edge, see the [Snapshots][17] docs page.
 
 ProGuard
 --------
-Depending on your ProGuard (DexGuard) config and usage, you may need to include the following lines in your proguard.cfg (see [Configuration wiki](https://github.com/bumptech/glide/wiki/Configuration#keeping-a-glidemodule) for more details):
+Depending on your ProGuard (DexGuard) config and usage, you may need to include the following lines in your proguard.cfg (see the [Download and Setup docs page][25] for more details):
 
 ```pro
 -keep public class * implements com.bumptech.glide.module.GlideModule
--keep public class * extends com.bumptech.glide.AppGlideModule
--keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {
+-keep public class * extends com.bumptech.glide.module.AppGlideModule
+-keep public enum com.bumptech.glide.load.ImageHeaderParser$** {
   **[] $VALUES;
   public *;
 }
@@ -121,10 +118,13 @@ Comments/bugs/questions/pull requests are always welcome! Please read [CONTRIBUT
 Compatibility
 -------------
 
- * **Android SDK**: Glide requires a minimum API level of 10.
- * **OkHttp 2.x**: there are optional dependencies available called `okhttp-integration`, see [Integration Libraries][12] wiki page.
- * **OkHttp 3.x**: there are optional dependencies available called `okhttp3-integration`, see [Integration Libraries][12] wiki page.
- * **Volley**: there are optional dependencies available called `volley-integration`, see [Integration Libraries][12] wiki page.
+ * **Minimum Android SDK**: Glide v4 requires a minimum API level of 14.
+ * **Compile Android SDK**: Glide v4 requires you to compile against API 26 or later.
+
+ If you need to support older versions of Android, consider staying on [Glide v3][14], which works on API 10, but is not actively maintained.
+
+ * **OkHttp 3.x**: There is an optional dependency available called `okhttp3-integration`, see the [docs page][23].
+ * **Volley**: There is an optional dependency available called `volley-integration`, see the [docs page][24].
  * **Round Pictures**: `CircleImageView`/`CircularImageView`/`RoundedImageView` are known to have [issues][18] with `TransitionDrawable` (`.crossFade()` with `.thumbnail()` or `.placeholder()`) and animated GIFs, use a [`BitmapTransformation`][19] (`.circleCrop()` will be available in v4) or `.dontAnimate()` to fix the issue.
  * **Huge Images** (maps, comic strips): Glide can load huge images by downsampling them, but does not support zooming and panning `ImageView`s as they require special resource optimizations (such as tiling) to work without `OutOfMemoryError`s.
 
@@ -133,9 +133,8 @@ Build
 Building Glide with gradle is fairly straight forward:
 
 ```shell
-git clone git@github.com:bumptech/glide.git # use https://github.com/bumptech/glide.git if "Permission Denied"
+git clone https://github.com/bumptech/glide.git 
 cd glide
-git submodule init && git submodule update
 ./gradlew jar
 ```
 
@@ -157,14 +156,16 @@ You may also find precompiled APKs on the [releases page][1].
 Development
 -----------
 Follow the steps in the [Build](#build) section to setup the project and then edit the files however you wish.
-[Intellij IDEA 14][4] cleanly imports both Glide's source and tests and is the recommended way to work with Glide.
+[Android Studio][26] cleanly imports both Glide's source and tests and is the recommended way to work with Glide.
 
-To open the project in IntelliJ IDEA:
+To open the project in Android Studio:
 
 1. Go to *File* menu or the *Welcome Screen*
 2. Click on *Open...*
 3. Navigate to Glide's root directory.
-4. Select `build.gradle`
+4. Select `setting.gradle`
+
+For more details, see the [Contributing docs page][27].
 
 Getting Help
 ------------
@@ -197,7 +198,7 @@ This is not an official Google product.
 
 [1]: https://github.com/bumptech/glide/releases
 [2]: https://github.com/bumptech/glide/wiki
-[3]: http://bumptech.github.io/glide/ref/javadocs.html
+[3]: https://bumptech.github.io/glide/ref/javadocs.html
 [4]: https://www.jetbrains.com/idea/download/
 [5]: https://github.com/bumptech/glide/blob/master/CONTRIBUTING.md
 [6]: https://groups.google.com/forum/#!forum/glidelibrary
@@ -211,8 +212,15 @@ This is not an official Google product.
 [14]: https://github.com/bumptech/glide/tree/3.0
 [15]: https://github.com/bumptech/glide/tree/master
 [16]: https://github.com/bumptech/glide/blob/master/LICENSE
-[17]: https://github.com/bumptech/glide/wiki/Snapshots
+[17]: http://bumptech.github.io/glide/dev/snapshots.html
 [18]: https://github.com/bumptech/glide/issues?q=is%3Aissue+CircleImageView+OR+CircularImageView+OR+RoundedImageView
 [19]: https://github.com/wasabeef/glide-transformations
-[20]: http://bumptech.github.io/glide/
-[21]: http://bumptech.github.io/glide/doc/generatedapi.html
+[20]: https://bumptech.github.io/glide/
+[21]: https://bumptech.github.io/glide/doc/generatedapi.html
+[22]: https://muyangmin.github.io/glide-docs-cn/
+[23]: http://bumptech.github.io/glide/int/okhttp3.html
+[24]: http://bumptech.github.io/glide/int/volley.html
+[25]: http://bumptech.github.io/glide/doc/download-setup.html#proguard
+[26]: https://developer.android.com/studio/index.html
+[27]: http://bumptech.github.io/glide/dev/contributing.html
+[28]: http://bumptech.github.io/glide/doc/download-setup.html
diff --git a/annotation/compiler/build.gradle b/annotation/compiler/build.gradle
index adff4ea2e..4be6596a0 100644
--- a/annotation/compiler/build.gradle
+++ b/annotation/compiler/build.gradle
@@ -1,17 +1,92 @@
 import org.gradle.internal.jvm.Jvm
+import proguard.gradle.ProGuardTask
 
 apply plugin: 'java'
 
+configurations {
+    // adapted from https://android.googlesource.com/platform/frameworks/testing/+/976c423/espresso/espresso-lib/build.gradle
+    // compileOnly dependencies will be repackaged, see rules in jarjar ant task below
+    jarjar 
+}
+
 dependencies {
-    compile 'com.squareup:javapoet:1.9.0'
-    compile 'com.google.auto.service:auto-service:1.0-rc3'
-    compile 'com.google.code.findbugs:jsr305:3.0.1'
+    // from https://code.google.com/archive/p/jarjar/downloads
+    jarjar files('libs/jarjar-1.4.jar')
+
+    compileOnly "com.squareup:javapoet:${JAVAPOET_VERSION}"
+    compileOnly "com.google.auto.service:auto-service:${AUTO_SERVICE_VERSION}"
+    compileOnly "com.google.code.findbugs:jsr305:${JSR_305_VERSION}"
     compile project(':annotation')
-    // This is to support com.sun.tootls.javac.util.List, currently used in RootModuleGenerator.
+    // This is to support com.sun.tools.javac.util.List, currently used in RootModuleGenerator.
     compile files(Jvm.current().getToolsJar())
+}
+
+// Make sure running `gradlew :annotation:compiler:check` actually does full quality control.
+test.dependsOn ':annotation:compiler:test:test'
+
+def packagingFolder = file("${buildDir}/intermediates")
+def repackagedJar = file("${packagingFolder}/repackaged.jar")
+def proguardedJar = file("${packagingFolder}/proguarded.jar")
+
+task compiledJar(type: Jar, dependsOn: classes) {
+    destinationDir = packagingFolder
+    archiveName = 'compiled.jar'
+    from sourceSets.main.output
+}
+
+// Repackage compileOnly dependencies to avoid namespace collisions.
+task jarjar(dependsOn: [tasks.compiledJar, configurations.compileOnly]) {
+    // Set up inputs and outputs to only rebuild when necessary (code change, dependency change).
+    inputs.files compiledJar
+    inputs.files configurations.compileOnly
+    outputs.file repackagedJar
+
+    doFirst {
+        ant {
+            taskdef name: 'jarjar',
+                    classname: 'com.tonicsystems.jarjar.JarJarTask',
+                    classpath: configurations.jarjar.asPath
+
+            jarjar(jarfile: repackagedJar) {
+                configurations.compileOnly.resolve().each {
+                    zipfileset(src: it.absolutePath, excludes: [
+                        'META-INF/maven/**',
+                        'META-INF/services/javax.annotation.processing.Processor'
+                    ].join(','))
+                }
+                zipfileset(src: tasks.compiledJar.archivePath)
+                def repackageIntoGlide = 'com.bumptech.glide.repackaged.@0'
+                rule result: repackageIntoGlide, pattern: 'com.squareup.javapoet.**'
+                rule result: repackageIntoGlide, pattern: 'com.google.auto.**'
+                rule result: repackageIntoGlide, pattern: 'com.google.common.**'
+                rule result: repackageIntoGlide, pattern: 'com.google.thirdparty.publicsuffix.**'
+            }
+        }
+    }
+}
+
+// Proguard repackaged dependencies to reduce the binary size.
+task proguard(type: ProGuardTask, dependsOn: tasks.jarjar) {
+    configuration 'proguard.pro'
+
+    injars repackagedJar
+    outjars proguardedJar
+
+    libraryjars files(configurations.compile.collect())
+    libraryjars "${System.getProperty('java.home')}/lib/rt.jar"
+}
 
-    testCompile "junit:junit:${JUNIT_VERSION}"
-    testCompile 'com.google.testing.compile:compile-testing:0.10'
+// Replace the contents of the standard jar task with those from our our compiled, repackaged and
+// proguarded jar. Replacing the task itself is possible and looks simpler, but requires
+// reconstructing the task dependency chain and is more complex in practice.
+jar {
+    dependsOn proguard
+    from zipTree(proguardedJar)
+    exclude { entry ->
+        sourceSets.main.output.files*.absolutePath.any {
+            entry.file.absolutePath.startsWith it
+        }
+    }
 }
 
 apply from: "${rootProject.projectDir}/scripts/upload.gradle"
diff --git a/annotation/compiler/libs/jarjar-1.4.jar b/annotation/compiler/libs/jarjar-1.4.jar
new file mode 100644
index 000000000..68b9db9aa
Binary files /dev/null and b/annotation/compiler/libs/jarjar-1.4.jar differ
diff --git a/annotation/compiler/proguard.pro b/annotation/compiler/proguard.pro
new file mode 100644
index 000000000..d40c8f599
--- /dev/null
+++ b/annotation/compiler/proguard.pro
@@ -0,0 +1,22 @@
+-verbose
+# Use ProGuard only to get rid of unused classes
+-dontobfuscate
+-dontoptimize
+-keepattributes *
+-keep class !com.bumptech.glide.repackaged.**,com.bumptech.glide.**
+
+# Keep the entry point to this library, see META-INF\services\javax.annotation.processing.Processor
+-keep class com.bumptech.glide.annotation.compiler.GlideAnnotationProcessor
+
+
+# "duplicate definition of library class"
+-dontnote sun.applet.**
+# "duplicate definition of library class"
+-dontnote sun.tools.jar.**
+# Reflective accesses in com.google.common.util.concurrent.* and some others
+-dontnote com.bumptech.glide.repackaged.com.google.common.**
+# com.google.common.collect.* and some others (….common.*.*)
+-dontwarn com.google.j2objc.annotations.Weak
+# com.google.common.util.concurrent.FuturesGetChecked$GetCheckedTypeValidatorHolder$ClassValueValidator
+-dontwarn org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement
+#-dontwarn **
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java
index 3e62fb816..5c5475f08 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java
@@ -1,16 +1,22 @@
 package com.bumptech.glide.annotation.compiler;
 
+import static com.bumptech.glide.annotation.compiler.ProcessorUtil.nonNull;
+
 import com.bumptech.glide.annotation.Excludes;
 import com.squareup.javapoet.AnnotationSpec;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
 import com.squareup.javapoet.ParameterizedTypeName;
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
 import com.squareup.javapoet.TypeSpec.Builder;
 import com.squareup.javapoet.WildcardTypeName;
+import java.util.ArrayList;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.HashSet;
+import java.util.List;
 import java.util.Set;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
@@ -61,7 +67,8 @@
  *    }
  *
  *    {@literal @java.lang.Override}
- *    public java.util.Set<java.lang.Class<?>> getExcludedModuleClasses() {
+ *    {@literal @android.support.annotation.NonNull}
+ *    public java.util.Set&lt;java.lang.Class&lt;?>> getExcludedModuleClasses() {
  *      return appGlideModule.getExcludedModuleClasses();
  *    }
  *  }
@@ -74,6 +81,7 @@
   private static final String GENERATED_APP_MODULE_IMPL_SIMPLE_NAME =
       "GeneratedAppGlideModuleImpl";
   private static final String GENERATED_ROOT_MODULE_SIMPLE_NAME = "GeneratedAppGlideModule";
+
   private final ProcessorUtil processorUtil;
 
   AppModuleGenerator(ProcessorUtil processorUtil) {
@@ -82,15 +90,22 @@
 
   TypeSpec generate(TypeElement appGlideModule, Set<String> libraryGlideModuleClassNames) {
     ClassName appGlideModuleClassName = ClassName.get(appGlideModule);
-    Set<String> excludedGlideModuleClassNames =
+    List<String> excludedGlideModuleClassNames =
         getExcludedGlideModuleClassNames(appGlideModule);
 
+    List<String> orderedLibraryGlideModuleClassNames =
+        new ArrayList<>(libraryGlideModuleClassNames);
+    Collections.sort(orderedLibraryGlideModuleClassNames);
+
     MethodSpec constructor =
         generateConstructor(
-            appGlideModuleClassName, libraryGlideModuleClassNames, excludedGlideModuleClassNames);
+            appGlideModuleClassName,
+            orderedLibraryGlideModuleClassNames,
+            excludedGlideModuleClassNames);
 
     MethodSpec registerComponents =
-        generateRegisterComponents(libraryGlideModuleClassNames, excludedGlideModuleClassNames);
+        generateRegisterComponents(
+            orderedLibraryGlideModuleClassNames, excludedGlideModuleClassNames);
 
     MethodSpec getExcludedModuleClasses =
         generateGetExcludedModuleClasses(excludedGlideModuleClassNames);
@@ -99,8 +114,16 @@ TypeSpec generate(TypeElement appGlideModule, Set<String> libraryGlideModuleClas
         MethodSpec.methodBuilder("applyOptions")
             .addModifiers(Modifier.PUBLIC)
             .addAnnotation(Override.class)
-            .addParameter(ClassName.get("android.content", "Context"), "context")
-            .addParameter(ClassName.get("com.bumptech.glide", "GlideBuilder"), "builder")
+            .addParameter(ParameterSpec.builder(
+                ClassName.get("android.content", "Context"), "context")
+                .addAnnotation(nonNull())
+                .build()
+            )
+            .addParameter(ParameterSpec.builder(
+                ClassName.get("com.bumptech.glide", "GlideBuilder"), "builder")
+                .addAnnotation(nonNull())
+                .build()
+            )
             .addStatement("appGlideModule.applyOptions(context, builder)", appGlideModule)
             .build();
 
@@ -136,6 +159,7 @@ TypeSpec generate(TypeElement appGlideModule, Set<String> libraryGlideModuleClas
     builder.addMethod(
         MethodSpec.methodBuilder("getRequestManagerFactory")
             .addAnnotation(Override.class)
+            .addAnnotation(nonNull())
             .returns(generatedRequestManagerFactoryClassName)
             .addStatement("return new $T()", generatedRequestManagerFactoryClassName)
             .build());
@@ -143,7 +167,7 @@ TypeSpec generate(TypeElement appGlideModule, Set<String> libraryGlideModuleClas
   }
 
   // TODO: When we drop support for parsing GlideModules from AndroidManifests, remove this method.
-  private MethodSpec generateGetExcludedModuleClasses(Set<String> excludedClassNames) {
+  private MethodSpec generateGetExcludedModuleClasses(Collection<String> excludedClassNames) {
     TypeName wildCardOfObject = WildcardTypeName.subtypeOf(Object.class);
     ParameterizedTypeName classOfWildcardOfObjet =
         ParameterizedTypeName.get(ClassName.get(Class.class), wildCardOfObject);
@@ -154,6 +178,7 @@ private MethodSpec generateGetExcludedModuleClasses(Set<String> excludedClassNam
     MethodSpec.Builder builder = MethodSpec.methodBuilder("getExcludedModuleClasses")
         .addModifiers(Modifier.PUBLIC)
         .addAnnotation(Override.class)
+        .addAnnotation(nonNull())
         .returns(setOfClassOfWildcardOfObject);
 
     if (excludedClassNames.isEmpty()) {
@@ -174,15 +199,28 @@ private MethodSpec generateGetExcludedModuleClasses(Set<String> excludedClassNam
     return builder.build();
   }
 
-  private MethodSpec generateRegisterComponents(Set<String> libraryGlideModuleClassNames,
-      Set<String> excludedGlideModuleClassNames) {
+  private MethodSpec generateRegisterComponents(
+      Collection<String> libraryGlideModuleClassNames,
+      Collection<String> excludedGlideModuleClassNames) {
     MethodSpec.Builder registerComponents =
         MethodSpec.methodBuilder("registerComponents")
             .addModifiers(Modifier.PUBLIC)
             .addAnnotation(Override.class)
-            .addParameter(ClassName.get("android.content", "Context"), "context")
-            .addParameter(ClassName.get("com.bumptech.glide", "Glide"), "glide")
-            .addParameter(ClassName.get("com.bumptech.glide", "Registry"), "registry");
+            .addParameter(ParameterSpec.builder(
+                ClassName.get("android.content", "Context"), "context")
+                .addAnnotation(nonNull())
+                .build()
+            )
+            .addParameter(ParameterSpec.builder(
+                ClassName.get("com.bumptech.glide", "Glide"), "glide")
+                .addAnnotation(nonNull())
+                .build()
+            )
+            .addParameter(ParameterSpec.builder(
+                ClassName.get("com.bumptech.glide", "Registry"), "registry")
+                .addAnnotation(nonNull())
+                .build()
+            );
 
     for (String glideModule : libraryGlideModuleClassNames) {
       if (excludedGlideModuleClassNames.contains(glideModule)) {
@@ -198,7 +236,8 @@ private MethodSpec generateRegisterComponents(Set<String> libraryGlideModuleClas
   }
 
   private MethodSpec generateConstructor(ClassName appGlideModule,
-      Set<String> libraryGlideModuleClassNames, Set<String> excludedGlideModuleClassNames) {
+      Collection<String> libraryGlideModuleClassNames,
+      Collection<String> excludedGlideModuleClassNames) {
     MethodSpec.Builder constructorBuilder = MethodSpec.constructorBuilder();
     constructorBuilder.addStatement("appGlideModule = new $T()", appGlideModule);
 
@@ -211,21 +250,23 @@ private MethodSpec generateConstructor(ClassName appGlideModule,
         "Discovered AppGlideModule from annotation: " + appGlideModule);
     // Excluded GlideModule classes from the manifest are logged in Glide's singleton.
     for (String glideModule : libraryGlideModuleClassNames) {
-      ClassName moduleClassName = ClassName.bestGuess(glideModule);
       if (excludedGlideModuleClassNames.contains(glideModule)) {
         constructorBuilder.addStatement("$T.d($S, $S)", androidLogName, GLIDE_LOG_TAG,
-            "AppGlideModule excludes LibraryGlideModule from annotation: " + moduleClassName);
+            "AppGlideModule excludes LibraryGlideModule from annotation: " + glideModule);
       } else {
         constructorBuilder.addStatement("$T.d($S, $S)", androidLogName, GLIDE_LOG_TAG,
-            "Discovered LibraryGlideModule from annotation: " + moduleClassName);
+            "Discovered LibraryGlideModule from annotation: " + glideModule);
       }
     }
     constructorBuilder.endControlFlow();
     return constructorBuilder.build();
   }
 
-  private Set<String> getExcludedGlideModuleClassNames(TypeElement appGlideModule) {
-    return processorUtil.findClassValuesFromAnnotationOnClassAsNames(
+  private List<String> getExcludedGlideModuleClassNames(TypeElement appGlideModule) {
+    Set<String> names = processorUtil.findClassValuesFromAnnotationOnClassAsNames(
         appGlideModule, Excludes.class);
+    List<String> result = new ArrayList<>(names);
+    Collections.sort(result);
+    return result;
   }
 }
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java
index 17f64f327..3469eff24 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java
@@ -15,9 +15,9 @@
 
 /**
  * Runs the final steps of Glide's annotation process and generates the combined
- * {@link AppGlideModule}, {@link com.bumptech.glide.Glide},
- * {@link com.bumptech.glide.RequestManager}, and
- * {@link com.bumptech.glide.request.RequestOptions} classes.
+ * {@code AppGlideModule}, {@code com.bumptech.glide.Glide},
+ * {@code com.bumptech.glide.RequestManager}, and
+ * {@code com.bumptech.glide.request.RequestOptions} classes.
  */
 final class AppModuleProcessor {
   private static final String COMPILER_PACKAGE_NAME =
@@ -88,7 +88,8 @@ boolean maybeWriteAppModule() {
       writeRequestOptions(generatedCodePackageName, generatedRequestOptions);
 
     TypeSpec generatedRequestBuilder =
-        requestBuilderGenerator.generate(generatedCodePackageName, generatedRequestOptions);
+        requestBuilderGenerator.generate(
+            generatedCodePackageName, indexedClassNames.extensions, generatedRequestOptions);
     writeRequestBuilder(generatedCodePackageName, generatedRequestBuilder);
 
     TypeSpec requestManager =
@@ -166,8 +167,8 @@ private void writeRequestBuilder(String packageName, TypeSpec requestBuilder) {
   }
 
   private static final class FoundIndexedClassNames {
-    final Set<String> glideModules;
-    final Set<String> extensions;
+    private final Set<String> glideModules;
+    private final Set<String> extensions;
 
     private FoundIndexedClassNames(Set<String> glideModules, Set<String> extensions) {
       this.glideModules = glideModules;
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java
index 4d6ac80c8..eed0f1243 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java
@@ -5,6 +5,7 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Set;
+import javax.annotation.processing.ProcessingEnvironment;
 import javax.annotation.processing.RoundEnvironment;
 import javax.lang.model.element.TypeElement;
 
@@ -15,17 +16,22 @@
 final class ExtensionProcessor {
   private final ProcessorUtil processorUtil;
   private final IndexerGenerator indexerGenerator;
+  private final GlideExtensionValidator extensionValidator;
 
-  ExtensionProcessor(ProcessorUtil processorUtil, IndexerGenerator indexerGenerator) {
+  ExtensionProcessor(
+      ProcessingEnvironment processingEnvironment,
+      ProcessorUtil processorUtil,
+      IndexerGenerator indexerGenerator) {
     this.processorUtil = processorUtil;
     this.indexerGenerator = indexerGenerator;
+    extensionValidator = new GlideExtensionValidator(processingEnvironment, processorUtil);
   }
 
-  boolean processExtensions(Set<? extends TypeElement> set, RoundEnvironment env) {
+  boolean processExtensions(RoundEnvironment env) {
     List<TypeElement> elements = processorUtil.getElementsFor(GlideExtension.class, env);
     processorUtil.debugLog("Processing types : " + elements);
     for (TypeElement typeElement : elements) {
-      GlideExtensionValidator.validateExtension(typeElement);
+      extensionValidator.validateExtension(typeElement);
       processorUtil.debugLog("Processing elements: " + typeElement.getEnclosedElements());
     }
 
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java
index 9046219e2..32a8575d9 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java
@@ -16,8 +16,8 @@
  * Generates classes based on Glide's annotations that configure Glide, add support for additional
  * resource types, and/or extend Glide's API.
  *
- * <p>This processor discovers all {@link AppGlideModule} and
- * {@link LibraryGlideModule} implementations that are
+ * <p>This processor discovers all {@code AppGlideModule} and
+ * {@code LibraryGlideModule} implementations that are
  * annotated with {@link com.bumptech.glide.annotation.GlideModule}. Any implementations missing the
  * annotation will be ignored.
  *
@@ -26,42 +26,42 @@
  *
  * <p>Multiple classes are generated by this processor:
  * <ul>
- *   <li>For {@link LibraryGlideModule}s - A GlideIndexer class in a
+ *   <li>For {@code LibraryGlideModule}s - A GlideIndexer class in a
  *      specific package that will later be used by the processor to discover all
- *      {@link LibraryGlideModule} classes.
- *   <li>For {@link AppGlideModule}s - A single
- *      {@link AppGlideModule} implementation
- *     ({@link com.bumptech.glide.GeneratedAppGlideModule}) that calls all
- *     {@link LibraryGlideModule}s and the
- *     original {@link AppGlideModule} in the correct order when Glide is
+ *      {@code LibraryGlideModule} classes.
+ *   <li>For {@code AppGlideModule}s - A single
+ *      {@code AppGlideModule} implementation
+ *     ({@code com.bumptech.glide.GeneratedAppGlideModule}) that calls all
+ *     {@code LibraryGlideModule}s and the
+ *     original {@code AppGlideModule} in the correct order when Glide is
  *     initialized.
  *   <li>{@link com.bumptech.glide.annotation.GlideExtension}s -
  *   <ul>
- *     <li>A {@link com.bumptech.glide.request.RequestOptions} implementation that contains
+ *     <li>A {@code com.bumptech.glide.request.RequestOptions} implementation that contains
  *     static versions of all builder methods in the base class and both static and instance
  *     versions of methods in all {@link com.bumptech.glide.annotation.GlideExtension}s.
  *     <li>If one or more methods in one or more
  *     {@link com.bumptech.glide.annotation.GlideExtension} annotated classes are annotated with
  *     {@link GlideType}:
  *     <ul>
- *       <li>A {@link com.bumptech.glide.RequestManager} implementation containing a generated
+ *       <li>A {@code com.bumptech.glide.RequestManager} implementation containing a generated
  *       method for each method annotated with
  *       {@link GlideType}.
- *       <li>A {@link com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory}
- *       implementation that produces the generated {@link com.bumptech.glide.RequestManager}s.
- *       <li>A {@link com.bumptech.glide.Glide} look-alike that implements all static methods in
- *       the {@link com.bumptech.glide.Glide} singleton and returns the generated
- *       {@link com.bumptech.glide.RequestManager} implementation when appropriate.
+ *       <li>A {@code com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory}
+ *       implementation that produces the generated {@code com.bumptech.glide.RequestManager}s.
+ *       <li>A {@code com.bumptech.glide.Glide} look-alike that implements all static methods in
+ *       the {@code com.bumptech.glide.Glide} singleton and returns the generated
+ *       {@code com.bumptech.glide.RequestManager} implementation when appropriate.
  *     </ul>
  *   </ul>
  * </ul>
  *
- * <p>{@link AppGlideModule} implementations must only be included in
+ * <p>{@code AppGlideModule} implementations must only be included in
  * applications, not in libraries. There must be exactly one
- * {@link AppGlideModule} implementation per
- * Application. The {@link AppGlideModule} class is
+ * {@code AppGlideModule} implementation per
+ * Application. The {@code AppGlideModule} class is
  * used as a signal that all modules have been found and that the final merged
- * {@link com.bumptech.glide.GeneratedAppGlideModule} impl can be created.
+ * {@code com.bumptech.glide.GeneratedAppGlideModule} impl can be created.
  */
 @AutoService(Processor.class)
 public final class GlideAnnotationProcessor extends AbstractProcessor {
@@ -79,7 +79,8 @@ public synchronized void init(ProcessingEnvironment processingEnvironment) {
     IndexerGenerator indexerGenerator = new IndexerGenerator(processorUtil);
     libraryModuleProcessor = new LibraryModuleProcessor(processorUtil, indexerGenerator);
     appModuleProcessor = new AppModuleProcessor(processingEnvironment, processorUtil);
-    extensionProcessor = new ExtensionProcessor(processorUtil, indexerGenerator);
+    extensionProcessor =
+        new ExtensionProcessor(processingEnvironment, processorUtil, indexerGenerator);
   }
 
   @Override
@@ -96,22 +97,27 @@ public SourceVersion getSupportedSourceVersion() {
   }
 
    /**
-   * Each round we do the following:
-   * <ol>
-   *   <li>Find all AppGlideModules and save them to an instance variable (throw if > 1).
-   *   <li>Find all LibraryGlideModules
-   *   <li>For each LibraryGlideModule, write an Indexer with an Annotation with the class name.
-   *   <li>If we wrote any Indexers, return and wait for the next round.
-   *   <li>If we didn't write any Indexers and there is a AppGlideModule, write the
-   *   GeneratedAppGlideModule. Once the GeneratedAppGlideModule is written, we expect to be
-   *   finished. Any further generation of related classes will result in errors.
-   * </ol>
-   */
+    * Each round we do the following:
+    * <ol>
+    *   <li>Find all {@code AppGlideModule}s and save them to an instance variable (throw if > 1).
+    *   <li>Find all {@code LibraryGlideModule}s
+    *   <li>For each {@code LibraryGlideModule},
+    *       write an {@code Indexer} with an Annotation with the class name.
+    *   <li>If we wrote any {@code Indexer}s, return and wait for the next round.
+    *   <li>If we didn't write any {@code Indexer}s and there is a {@code AppGlideModule},
+    *       write the {@code GeneratedAppGlideModule}.
+    *       Once the {@code GeneratedAppGlideModule} is written, we expect to be finished.
+    *       Any further generation of related classes will result in errors.
+    * </ol>
+    */
   @Override
   public boolean process(Set<? extends TypeElement> set, RoundEnvironment env) {
+//    if (set.isEmpty() && !isGeneratedAppGlideModulePending) {
+//      return false;
+//    }
     processorUtil.process();
-    boolean newModulesWritten = libraryModuleProcessor.processModules(set, env);
-    boolean newExtensionWritten = extensionProcessor.processExtensions(set, env);
+    boolean newModulesWritten = libraryModuleProcessor.processModules(env);
+    boolean newExtensionWritten = extensionProcessor.processExtensions(env);
     appModuleProcessor.processModules(set, env);
 
     if (newExtensionWritten || newModulesWritten) {
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java
index 488c5578f..77c496d8b 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java
@@ -1,15 +1,27 @@
 package com.bumptech.glide.annotation.compiler;
 
+import static com.bumptech.glide.annotation.compiler.ProcessorUtil.nonNull;
+import static com.bumptech.glide.annotation.compiler.ProcessorUtil.nonNulls;
+
 import com.bumptech.glide.annotation.GlideOption;
 import com.bumptech.glide.annotation.GlideType;
+import com.google.common.base.Function;
+import com.google.common.collect.FluentIterable;
+import com.squareup.javapoet.ClassName;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
+import javax.tools.Diagnostic.Kind;
 
 /**
  * Validates that classes annotated with {@link com.bumptech.glide.annotation.GlideExtension}
@@ -20,75 +32,236 @@
  * for an Application.
  */
 final class GlideExtensionValidator {
+  private final ProcessingEnvironment processingEnvironment;
+  private final ProcessorUtil processorUtil;
 
-  private GlideExtensionValidator() { }
+  GlideExtensionValidator(
+      ProcessingEnvironment processingEnvironment, ProcessorUtil processorUtil) {
+    this.processingEnvironment = processingEnvironment;
+    this.processorUtil = processorUtil;
+  }
 
-  static void validateExtension(TypeElement typeElement) {
+  void validateExtension(TypeElement typeElement) {
     if (!typeElement.getModifiers().contains(Modifier.PUBLIC)) {
-      throw new IllegalArgumentException("RequestOptionsExtensions must be public");
+      throw new IllegalArgumentException(
+          "RequestOptionsExtensions must be public, including: " + getName(typeElement));
     }
     for (Element element : typeElement.getEnclosedElements()) {
       if (element.getKind() == ElementKind.CONSTRUCTOR) {
-        if (!element.getModifiers().contains(Modifier.PRIVATE)) {
-          throw new IllegalArgumentException("RequestOptionsExtensions must be public, with private"
-              + " constructors and only static methods. Found a non-private constructor");
-        }
-        ExecutableElement executableElement = (ExecutableElement) element;
-        if (!executableElement.getParameters().isEmpty()) {
-          throw new IllegalArgumentException("RequestOptionsExtensions must be public, with private"
-              + " constructors and only static methods. Found parameters in the constructor");
-        }
-        continue;
-      }
-      if (element.getKind() == ElementKind.METHOD) {
+        validateExtensionConstructor(element);
+      } else if (element.getKind() == ElementKind.METHOD) {
         ExecutableElement executableElement = (ExecutableElement) element;
         if (executableElement.getAnnotation(GlideOption.class) != null) {
-          validateExtendsRequestOptions(executableElement);
+          validateGlideOption(executableElement);
         } else if (executableElement.getAnnotation(GlideType.class) != null) {
-          validateExtendsRequestManager(executableElement);
+          validateGlideType(executableElement);
         }
       }
     }
   }
 
-  private static void validateExtendsRequestOptions(ExecutableElement executableElement) {
-    validateStaticVoid(executableElement, GlideOption.class);
+  private static String getQualifiedMethodName(ExecutableElement executableElement) {
+    return getEnclosingClassName(executableElement) + "#" + getName(executableElement);
+  }
+
+  private static String getEnclosingClassName(Element element) {
+    return element.getEnclosingElement().toString();
+  }
+
+  private static String getName(Element element) {
+    return element.toString();
+  }
+
+  private static void validateExtensionConstructor(Element element) {
+    if (!element.getModifiers().contains(Modifier.PRIVATE)) {
+      throw new IllegalArgumentException(
+          "RequestOptionsExtensions must be public, with private constructors and only static"
+              + " methods. Found a non-private constructor in: " + getEnclosingClassName(element));
+    }
+    ExecutableElement executableElement = (ExecutableElement) element;
+    if (!executableElement.getParameters().isEmpty()) {
+      throw new IllegalArgumentException(
+          "RequestOptionsExtensions must be public, with private constructors and only static"
+              + " methods. Found parameters in the constructor of: "
+              + getEnclosingClassName(element));
+    }
+  }
+
+  private void validateGlideOption(ExecutableElement executableElement) {
+    validateGlideOptionAnnotations(executableElement);
+    validateGlideOptionParameters(executableElement);
+    TypeMirror returnType = executableElement.getReturnType();
+    if (!isBaseRequestOptions(returnType)) {
+      throw new IllegalArgumentException("@GlideOption methods should return a"
+          + " BaseRequestOptions<?> object, but " + getQualifiedMethodName(executableElement)
+          + " returns " + returnType + ". If you're using old style @GlideOption methods, your"
+          + " method may have a void return type, but doing so is deprecated and support will be"
+          + " removed in a future version");
+    }
+    validateGlideOptionOverride(executableElement);
+  }
+
+  private void validateGlideOptionAnnotations(ExecutableElement executableElement) {
+    validateAnnotatedNonNull(executableElement);
+  }
+
+  private static void validateGlideOptionParameters(ExecutableElement executableElement) {
     if (executableElement.getParameters().isEmpty()) {
       throw new IllegalArgumentException("@GlideOption methods must take a "
-          + "RequestOptions object as their first parameter, but given none");
+          + "BaseRequestOptions<?> object as their first parameter, but "
+          + getQualifiedMethodName(executableElement) + " has none");
     }
     VariableElement first = executableElement.getParameters().get(0);
     TypeMirror expected = first.asType();
-    if (!expected.toString().equals(
-        "com.bumptech.glide.request.RequestOptions")) {
+    if (!isBaseRequestOptions(expected)) {
       throw new IllegalArgumentException("@GlideOption methods must take a"
-          + " RequestOptions object as their first parameter, but given: " + expected);
+          + " BaseRequestOptions<?> object as their first parameter, but the first parameter in "
+          + getQualifiedMethodName(executableElement) + " is " + expected);
+    }
+  }
+
+  private static boolean isBaseRequestOptions(TypeMirror typeMirror) {
+    return typeMirror.toString().equals("com.bumptech.glide.request.BaseRequestOptions<?>");
+  }
+
+  private void validateGlideOptionOverride(ExecutableElement element) {
+    int overrideType = processorUtil.getOverrideType(element);
+    boolean isOverridingBaseRequestOptionsMethod = isMethodInBaseRequestOptions(element);
+    if (isOverridingBaseRequestOptionsMethod && overrideType == GlideOption.OVERRIDE_NONE) {
+      throw new IllegalArgumentException("Accidentally attempting to override a method in"
+          + " BaseRequestOptions. Add an 'override' value in the @GlideOption annotation"
+          + " if this is intentional. Offending method: "
+          + getQualifiedMethodName(element));
+    } else if (!isOverridingBaseRequestOptionsMethod && overrideType != GlideOption.OVERRIDE_NONE) {
+      throw new IllegalArgumentException("Requested to override an existing method in"
+          + " BaseRequestOptions, but no such method was found. Offending method: "
+          + getQualifiedMethodName(element));
     }
   }
 
-  private static void validateExtendsRequestManager(ExecutableElement executableElement) {
-    validateStaticVoid(executableElement, GlideType.class);
+  private boolean isMethodInBaseRequestOptions(ExecutableElement toFind) {
+    // toFind is a method in a GlideExtension whose first argument is a BaseRequestOptions<?> type.
+    // Since we're comparing against methods in BaseRequestOptions itself, we need to drop that
+    // first type.
+    TypeElement requestOptionsType =
+        processingEnvironment
+            .getElementUtils()
+            .getTypeElement(RequestOptionsGenerator.BASE_REQUEST_OPTIONS_QUALIFIED_NAME);
+    List<String> toFindParameterNames = getComparableParameterNames(toFind, true /*skipFirst*/);
+    String toFindSimpleName = toFind.getSimpleName().toString();
+    for (Element element : requestOptionsType.getEnclosedElements()) {
+      if (element.getKind() != ElementKind.METHOD) {
+        continue;
+      }
+      ExecutableElement inBase = (ExecutableElement) element;
+      if (toFindSimpleName.equals(inBase.getSimpleName().toString())) {
+        List<String> parameterNamesInBase =
+            getComparableParameterNames(inBase, false /*skipFirst*/);
+        if (parameterNamesInBase.equals(toFindParameterNames)) {
+          return true;
+        }
+      }
+    }
+    return false;
+  }
+
+  private static List<String> getComparableParameterNames(
+      ExecutableElement element, boolean skipFirst) {
+    List<? extends VariableElement> parameters = element.getParameters();
+    if (skipFirst) {
+      parameters = parameters.subList(1, parameters.size());
+    }
+    List<String> result = new ArrayList<>(parameters.size());
+    for (VariableElement parameter : parameters) {
+      result.add(parameter.asType().toString());
+    }
+    return result;
+  }
+
+  private void validateGlideType(ExecutableElement executableElement) {
+    TypeMirror returnType = executableElement.getReturnType();
+    validateGlideTypeAnnotations(executableElement);
+    if (!isRequestBuilder(returnType) || !typeMatchesExpected(returnType, executableElement)) {
+      String expectedClassName = getGlideTypeValue(executableElement);
+      throw new IllegalArgumentException("@GlideType methods should return a RequestBuilder<"
+          + expectedClassName + "> object, but " + getQualifiedMethodName(executableElement)
+          + " returns: " + returnType + ". If you're using old style @GlideType methods, your"
+          + " method may have a void return type, but doing so is deprecated and support will be"
+          + " removed in a future version");
+    }
+    validateGlideTypeParameters(executableElement);
+  }
+
+  private String getGlideTypeValue(ExecutableElement executableElement) {
+    return
+        processorUtil
+            .findClassValuesFromAnnotationOnClassAsNames(
+                executableElement, GlideType.class).iterator().next();
+  }
+
+  private boolean typeMatchesExpected(
+      TypeMirror returnType, ExecutableElement executableElement) {
+    if (!(returnType instanceof DeclaredType)) {
+      return false;
+    }
+    List<? extends TypeMirror> typeArguments = ((DeclaredType) returnType).getTypeArguments();
+    if (typeArguments.size() != 1) {
+      return false;
+    }
+    TypeMirror argument = typeArguments.get(0);
+    String expected = getGlideTypeValue(executableElement);
+    return argument.toString().equals(expected);
+  }
+
+  private boolean isRequestBuilder(TypeMirror typeMirror) {
+    TypeMirror toCompare = processingEnvironment.getTypeUtils().erasure(typeMirror);
+    return toCompare.toString().equals("com.bumptech.glide.RequestBuilder");
+  }
+
+  private static void validateGlideTypeParameters(ExecutableElement executableElement) {
     if (executableElement.getParameters().size() != 1) {
       throw new IllegalArgumentException("@GlideType methods must take a"
-          + " RequestOptions object as their first and only parameter, found multiple for: "
-      + executableElement.getEnclosingElement() + "#" + executableElement);
+          + " RequestBuilder object as their first and only parameter, but given multiple for: "
+          + getQualifiedMethodName(executableElement));
     }
 
     VariableElement first = executableElement.getParameters().get(0);
-    TypeMirror expected = first.asType();
-    if (!expected.toString().startsWith("com.bumptech.glide.RequestBuilder")) {
+    TypeMirror argumentType = first.asType();
+    if (!argumentType.toString().startsWith("com.bumptech.glide.RequestBuilder")) {
       throw new IllegalArgumentException("@GlideType methods must take a"
-          + " RequestBuilder object as their first parameter, but given: " + expected);
+          + " RequestBuilder object as their first and only parameter, but given: " + argumentType
+          + " for: " + getQualifiedMethodName(executableElement));
     }
   }
 
-  private static void validateStaticVoid(ExecutableElement executableElement, Class<?> clazz) {
-    if (!executableElement.getModifiers().contains(Modifier.STATIC)) {
-      throw new IllegalArgumentException("@" + clazz.getSimpleName() + " methods must be static");
+  private void validateGlideTypeAnnotations(ExecutableElement executableElement) {
+    validateAnnotatedNonNull(executableElement);
+  }
+
+  private void validateAnnotatedNonNull(ExecutableElement executableElement) {
+    Set<String> annotationNames =
+        FluentIterable.from(executableElement.getAnnotationMirrors())
+            .transform(new Function<AnnotationMirror, String>() {
+              @Override
+              public String apply(AnnotationMirror input) {
+                return input.getAnnotationType().asElement().toString();
+              }
+            })
+            .toSet();
+    boolean noNonNull = true;
+    for (ClassName nonNull : nonNulls()) {
+      if (annotationNames.contains(nonNull.reflectionName())) {
+        noNonNull = false;
+        break;
+      }
     }
-    TypeMirror returnType = executableElement.getReturnType();
-    if (returnType.getKind() != TypeKind.VOID) {
-      throw new IllegalArgumentException("@" + clazz.getSimpleName() + " methods must return void");
+    if (noNonNull) {
+      processingEnvironment.getMessager().printMessage(
+          Kind.WARNING,
+          getQualifiedMethodName(executableElement)
+              + " is missing the " + nonNull().reflectionName() + " annotation,"
+              + " please add it to ensure that your extension methods are always returning non-null"
+              + " values");
     }
   }
 }
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java
index 99805e9b0..d4da883b5 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java
@@ -7,6 +7,7 @@
 import com.squareup.javapoet.AnnotationSpec;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.MethodSpec.Builder;
 import com.squareup.javapoet.ParameterSpec;
 import com.squareup.javapoet.TypeSpec;
 import java.util.ArrayList;
@@ -16,14 +17,13 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
 import javax.lang.model.util.Elements;
 
 /**
  * Generates a Glide look-alike that acts as the entry point to the generated API
  * (GlideApp.with(...)).
  *
- * <p>>Generated {@link com.bumptech.glide.Glide} look-alikes look like this (note that the name
+ * <p>>Generated {@code com.bumptech.glide.Glide} look-alikes look like this (note that the name
  * is configurable in {@link com.bumptech.glide.annotation.GlideModule}):
  * <pre>
  * <code>
@@ -79,6 +79,9 @@
   private static final String VISIBLE_FOR_TESTING_QUALIFIED_NAME =
       "android.support.annotation.VisibleForTesting";
 
+  private static final String VISIBLE_FOR_TESTING_QUALIFIED_NAME_ANDROIDX =
+      "androidx.annotation.VisibleForTesting";
+
   private static final String SUPPRESS_LINT_PACKAGE_NAME =
       "android.annotation";
   private static final String SUPPRESS_LINT_CLASS_NAME =
@@ -138,7 +141,7 @@ public MethodSpec apply(ExecutableElement input) {
   }
 
   private MethodSpec overrideGlideStaticMethod(ExecutableElement methodToOverride) {
-    List<? extends VariableElement> parameters = methodToOverride.getParameters();
+    List<ParameterSpec> parameters = ProcessorUtil.getParameters(methodToOverride);
 
     TypeElement element =
         (TypeElement) processingEnv.getTypeUtils().asElement(methodToOverride.getReturnType());
@@ -147,54 +150,60 @@ private MethodSpec overrideGlideStaticMethod(ExecutableElement methodToOverride)
         MethodSpec.methodBuilder(methodToOverride.getSimpleName().toString())
             .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
             .addJavadoc(processorUtil.generateSeeMethodJavadoc(methodToOverride))
-            .addParameters(Lists.transform(parameters,
-                new Function<VariableElement, ParameterSpec>() {
-                  @Override
-                  public ParameterSpec apply(VariableElement input) {
-                    return ParameterSpec.get(input);
-                  }
-            }));
-
-    TypeElement visibleForTestingType =
-        processingEnv
-            .getElementUtils()
-            .getTypeElement(VISIBLE_FOR_TESTING_QUALIFIED_NAME);
-    for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {
-      builder.addAnnotation(AnnotationSpec.get(mirror));
+            .addParameters(parameters);
 
-      // Suppress a lint warning if we're overriding a VisibleForTesting method.
-      // See #1977.
-      if (mirror.getAnnotationType().asElement().equals(visibleForTestingType)) {
-        builder.addAnnotation(
-            AnnotationSpec.builder(
-                ClassName.get(SUPPRESS_LINT_PACKAGE_NAME, SUPPRESS_LINT_CLASS_NAME))
-                .addMember("value", "$S", "VisibleForTests")
-                .build());
-      }
-    }
+    addReturnAnnotations(builder, methodToOverride);
 
     boolean returnsValue = element != null;
     if (returnsValue) {
       builder.returns(ClassName.get(element));
     }
 
-    String code = returnsValue ? "return " : "";
-    code += "$T.$N(";
+    StringBuilder code = new StringBuilder(returnsValue ? "return " : "");
+    code.append("$T.$N(");
     List<Object> args = new ArrayList<>();
     args.add(ClassName.get(glideType));
     args.add(methodToOverride.getSimpleName());
     if (!parameters.isEmpty()) {
-      for (VariableElement param : parameters) {
-        code += "$L, ";
-        args.add(param.getSimpleName());
+      for (ParameterSpec param : parameters) {
+        code.append("$L, ");
+        args.add(param.name);
       }
-      code = code.substring(0, code.length() - 2);
+      code = new StringBuilder(code.substring(0, code.length() - 2));
     }
-    code += ")";
-    builder.addStatement(code, args.toArray(new Object[0]));
+    code.append(")");
+    builder.addStatement(code.toString(), args.toArray(new Object[0]));
     return builder.build();
   }
 
+  private Builder addReturnAnnotations(Builder builder, ExecutableElement methodToOverride) {
+    Elements elements = processingEnv.getElementUtils();
+    TypeElement visibleForTestingTypeElement = elements
+        .getTypeElement(VISIBLE_FOR_TESTING_QUALIFIED_NAME_ANDROIDX);
+    if (visibleForTestingTypeElement == null) {
+      // Fall back to looking for the Support library version.
+      visibleForTestingTypeElement = elements.getTypeElement(VISIBLE_FOR_TESTING_QUALIFIED_NAME);
+    }
+    String visibleForTestingTypeQualifiedName = visibleForTestingTypeElement.toString();
+
+    for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {
+      builder.addAnnotation(AnnotationSpec.get(mirror));
+
+      // Suppress a lint warning if we're overriding a VisibleForTesting method.
+      // See #1977.
+      String annotationQualifiedName = mirror.getAnnotationType().toString();
+      if (annotationQualifiedName.equals(visibleForTestingTypeQualifiedName)) {
+        builder.addAnnotation(
+            AnnotationSpec.builder(
+                ClassName.get(SUPPRESS_LINT_PACKAGE_NAME, SUPPRESS_LINT_CLASS_NAME))
+                .addMember("value", "$S", "VisibleForTests")
+                .build());
+      }
+    }
+
+    return builder;
+  }
+
   private List<ExecutableElement> discoverGlideMethodsToOverride() {
     return processorUtil.findStaticMethods(glideType);
   }
@@ -207,19 +216,21 @@ private MethodSpec overrideGlideWithMethod(
       String packageName, TypeSpec generatedRequestManager, ExecutableElement methodToOverride) {
     ClassName generatedRequestManagerClassName =
         ClassName.get(packageName, generatedRequestManager.name);
-    List<? extends VariableElement> parameters = methodToOverride.getParameters();
+    List<ParameterSpec> parameters = ProcessorUtil.getParameters(methodToOverride);
     Preconditions.checkArgument(
         parameters.size() == 1, "Expected size of 1, but got %s", methodToOverride);
-    VariableElement parameter = parameters.iterator().next();
-    return MethodSpec.methodBuilder(methodToOverride.getSimpleName().toString())
+    ParameterSpec parameter = parameters.iterator().next();
+
+    Builder builder = MethodSpec.methodBuilder(methodToOverride.getSimpleName().toString())
         .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
         .addJavadoc(processorUtil.generateSeeMethodJavadoc(methodToOverride))
+        .addParameters(parameters)
         .returns(generatedRequestManagerClassName)
-        .addParameter(ClassName.get(parameter.asType()), parameter.getSimpleName().toString())
         .addStatement("return ($T) $T.$N($L)",
             generatedRequestManagerClassName, glideType,
             methodToOverride.getSimpleName().toString(),
-            parameter.getSimpleName())
-        .build();
+            parameter.name);
+
+    return addReturnAnnotations(builder, methodToOverride).build();
   }
 }
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/IndexerGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/IndexerGenerator.java
index afae52f38..7ff49feea 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/IndexerGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/IndexerGenerator.java
@@ -84,14 +84,15 @@ private static TypeSpec generate(List<TypeElement> libraryModules,
       annotationBuilder.addMember(value, "$S", ClassName.get(childModule).toString());
     }
 
-    String indexerName = INDEXER_NAME_PREFIX + annotation.getSimpleName() + "_";
+    StringBuilder indexerName = new StringBuilder(
+        INDEXER_NAME_PREFIX + annotation.getSimpleName() + "_");
     for (TypeElement element : libraryModules) {
-      indexerName += element.getQualifiedName().toString().replace(".", "_");
-      indexerName += "_";
+      indexerName.append(element.getQualifiedName().toString().replace(".", "_"));
+      indexerName.append("_");
     }
-    indexerName = indexerName.substring(0, indexerName.length() - 1);
+    indexerName = new StringBuilder(indexerName.substring(0, indexerName.length() - 1));
 
-    return TypeSpec.classBuilder(indexerName)
+    return TypeSpec.classBuilder(indexerName.toString())
         .addAnnotation(annotationBuilder.build())
         .addModifiers(Modifier.PUBLIC)
         .build();
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/LibraryModuleProcessor.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/LibraryModuleProcessor.java
index 8f79cb7e2..d6e6329a7 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/LibraryModuleProcessor.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/LibraryModuleProcessor.java
@@ -11,18 +11,18 @@
 
 /**
  * Generates Indexer classes annotated with {@link Index} for all
- * {@link LibraryGlideModule}s.
+ * {@code LibraryGlideModule}s.
  */
 final class LibraryModuleProcessor {
-  private ProcessorUtil processorUtil;
-  private IndexerGenerator indexerGenerator;
+  private final ProcessorUtil processorUtil;
+  private final IndexerGenerator indexerGenerator;
 
   LibraryModuleProcessor(ProcessorUtil processorUtil, IndexerGenerator indexerGenerator) {
     this.processorUtil = processorUtil;
     this.indexerGenerator = indexerGenerator;
   }
 
-  boolean processModules(Set<? extends TypeElement> set, RoundEnvironment env) {
+  boolean processModules(RoundEnvironment env) {
      // Order matters here, if we find an Indexer below, we return before writing the root module.
     // If we fail to add to appModules before then, we might accidentally skip a valid RootModule.
     List<TypeElement> libraryGlideModules = new ArrayList<>();
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java
index 5229afc21..b9832f365 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java
@@ -3,10 +3,13 @@
 import static com.bumptech.glide.annotation.compiler.GlideAnnotationProcessor.DEBUG;
 
 import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
 import com.google.common.base.Function;
+import com.google.common.base.Joiner;
 import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.Lists;
+import com.squareup.javapoet.AnnotationSpec;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.JavaFile;
@@ -14,13 +17,18 @@
 import com.squareup.javapoet.ParameterSpec;
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
+import com.squareup.javapoet.TypeVariableName;
 import com.sun.tools.javac.code.Attribute;
 import com.sun.tools.javac.code.Type.ClassType;
 import java.lang.annotation.Annotation;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashSet;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -35,8 +43,10 @@
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.TypeParameterElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.TypeVariable;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
@@ -54,6 +64,16 @@
       GLIDE_MODULE_PACKAGE_NAME + "." + LIBRARY_GLIDE_MODULE_SIMPLE_NAME;
   private static final String COMPILER_PACKAGE_NAME =
       GlideAnnotationProcessor.class.getPackage().getName();
+  private static final ClassName NONNULL_ANNOTATION =
+      ClassName.get("android.support.annotation", "NonNull");
+  private static final ClassName JETBRAINS_NOTNULL_ANNOTATION =
+      ClassName.get("org.jetbrains.annotations", "NotNull");
+  private static final ClassName ANDROIDX_NONNULL_ANNOTATION =
+      ClassName.get("androidx.annotation", "NonNull");
+  private static final ClassName CHECK_RESULT_ANNOTATION =
+      ClassName.get("android.support.annotation", "CheckResult");
+  private static final ClassName ANDROIDX_CHECK_RESULT_ANNOTATION =
+      ClassName.get("androidx.annotation", "CheckResult");
 
   private final ProcessingEnvironment processingEnv;
   private final TypeElement appGlideModuleType;
@@ -87,6 +107,12 @@ boolean isExtension(TypeElement element) {
     return element.getAnnotation(GlideExtension.class) != null;
   }
 
+  int getOverrideType(ExecutableElement element) {
+    GlideOption glideOption =
+        element.getAnnotation(GlideOption.class);
+    return glideOption.override();
+  }
+
   void writeIndexer(TypeSpec indexer) {
     writeClass(COMPILER_PACKAGE_NAME, indexer);
   }
@@ -189,24 +215,23 @@ public Object apply(ParameterSpec input) {
   private CodeBlock generateSeeMethodJavadocInternal(
       TypeName nameOfClassContainingMethod, String methodName,
       List<Object> safeParameterNames) {
-     String javadocString = "@see $T#$L(";
+    StringBuilder javadocString = new StringBuilder("@see $T#$L(");
     List<Object> javadocArgs = new ArrayList<>();
     javadocArgs.add(nameOfClassContainingMethod);
     javadocArgs.add(methodName);
 
     for (Object param : safeParameterNames) {
-      javadocString += "$T, ";
+      javadocString.append("$T, ");
       javadocArgs.add(param);
     }
     if (javadocArgs.size() > 2) {
-      javadocString = javadocString.substring(0, javadocString.length() - 2);
+      javadocString = new StringBuilder(javadocString.substring(0, javadocString.length() - 2));
     }
-    javadocString += ")\n";
-    return CodeBlock.of(javadocString, javadocArgs.toArray(new Object[0]));
+    javadocString.append(")\n");
+    return CodeBlock.of(javadocString.toString(), javadocArgs.toArray(new Object[0]));
   }
 
-
-   /**
+  /**
    * Returns a safe String to use in a Javadoc that will function in a link.
    *
    * <p>This method exists because by Javadoc doesn't handle type parameters({@literal <T>}
@@ -233,6 +258,211 @@ void infoLog(String toLog) {
     processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, "[" + round + "] " + toLog);
   }
 
+  static CodeBlock generateCastingSuperCall(TypeName toReturn, MethodSpec method) {
+    return CodeBlock.builder()
+        .add("return ($T) super.$N(", toReturn, method.name)
+        .add(
+            FluentIterable.from(method.parameters)
+                .transform(new Function<ParameterSpec, String>() {
+                  @Override
+                  public String apply(ParameterSpec input) {
+                    return input.name;
+                  }
+                })
+                .join(Joiner.on(",")))
+        .add(");\n")
+        .build();
+  }
+
+  static MethodSpec.Builder overriding(ExecutableElement method) {
+    String methodName = method.getSimpleName().toString();
+
+    MethodSpec.Builder builder = MethodSpec.methodBuilder(methodName)
+        .addAnnotation(Override.class);
+
+    Set<Modifier> modifiers = method.getModifiers();
+    modifiers = new LinkedHashSet<>(modifiers);
+    modifiers.remove(Modifier.ABSTRACT);
+    Modifier defaultModifier = null;
+    // Modifier.DEFAULT doesn't exist until Java 8.
+    try {
+      defaultModifier = Modifier.valueOf("DEFAULT");
+    } catch (IllegalArgumentException e) {
+      // Ignored.
+    }
+    modifiers.remove(defaultModifier);
+
+    builder = builder.addModifiers(modifiers);
+
+    for (TypeParameterElement typeParameterElement : method.getTypeParameters()) {
+      TypeVariable var = (TypeVariable) typeParameterElement.asType();
+      builder = builder.addTypeVariable(TypeVariableName.get(var));
+    }
+
+    builder = builder.returns(TypeName.get(method.getReturnType()))
+        .addParameters(getParameters(method))
+        .varargs(method.isVarArgs());
+
+    for (TypeMirror thrownType : method.getThrownTypes()) {
+      builder = builder.addException(TypeName.get(thrownType));
+    }
+
+    return builder;
+  }
+
+  static List<ParameterSpec> getParameters(ExecutableElement method) {
+    return getParameters(method.getParameters());
+  }
+
+  static List<ParameterSpec> getParameters(List<? extends VariableElement> parameters) {
+    List<ParameterSpec> result = new ArrayList<>();
+    for (VariableElement parameter : parameters) {
+      result.add(getParameter(parameter));
+    }
+    return dedupedParameters(result);
+  }
+
+  private static List<ParameterSpec> dedupedParameters(List<ParameterSpec> parameters) {
+    boolean hasDupes = false;
+    Set<String> names = new HashSet<>();
+    for (ParameterSpec parameter : parameters) {
+      String name = parameter.name;
+      if (names.contains(name)) {
+        hasDupes = true;
+      } else {
+        names.add(name);
+      }
+    }
+
+    if (hasDupes) {
+      List<ParameterSpec> copy = parameters;
+      parameters = new ArrayList<>();
+      for (int i = 0; i < copy.size(); i++) {
+        ParameterSpec parameter = copy.get(i);
+        parameters.add(ParameterSpec.builder(parameter.type, parameter.name + i)
+            .addModifiers(parameter.modifiers)
+            .addAnnotations(parameter.annotations)
+            .build());
+      }
+    }
+
+    return parameters;
+  }
+
+  private static ParameterSpec getParameter(VariableElement parameter) {
+    TypeName type = TypeName.get(parameter.asType());
+    return ParameterSpec.builder(type, computeParameterName(parameter, type))
+        .addModifiers(parameter.getModifiers())
+        .addAnnotations(getAnnotations(parameter))
+        .build();
+  }
+
+  private static String computeParameterName(VariableElement parameter, TypeName type) {
+    String rawClassName = type.withoutAnnotations().toString();
+
+    String name;
+
+    if (type.isPrimitive() || type.isBoxedPrimitive()) {
+      name = getSmartPrimitiveParameterName(parameter);
+    } else {
+      if (rawClassName.contains("<") && rawClassName.contains(">")) {
+        String[] preGenericSplit = rawClassName.split("<");
+        String preGeneric = preGenericSplit[0];
+        String[] postGenericSplit = rawClassName.split(">");
+        String postGeneric = postGenericSplit[postGenericSplit.length - 1];
+        if (postGenericSplit.length > 1) {
+          rawClassName = preGeneric + postGeneric;
+        } else {
+          rawClassName = preGeneric;
+        }
+      }
+
+      String[] qualifiers = rawClassName.split("\\.");
+      rawClassName = qualifiers[qualifiers.length - 1];
+
+      rawClassName = applySmartParameterNameReplacements(rawClassName);
+
+      boolean allCaps = true;
+      for (char c : rawClassName.toCharArray()) {
+        if (Character.isLowerCase(c)) {
+          allCaps = false;
+          break;
+        }
+      }
+      if (allCaps) {
+        name = rawClassName.toLowerCase();
+      } else {
+        int indexOfLastWordStart = 0;
+        char[] chars = rawClassName.toCharArray();
+        for (int i = 0, charArrayLength = chars.length; i < charArrayLength; i++) {
+          char c = chars[i];
+          if (Character.isUpperCase(c)) {
+            indexOfLastWordStart = i;
+          }
+        }
+        rawClassName = rawClassName.substring(indexOfLastWordStart, rawClassName.length());
+
+        name = Character.toLowerCase(rawClassName.charAt(0))
+            + rawClassName.substring(1, rawClassName.length());
+      }
+    }
+
+    return name;
+  }
+
+  private static String getSmartPrimitiveParameterName(VariableElement parameter) {
+    for (AnnotationMirror annotation : parameter.getAnnotationMirrors()) {
+      String annotationName = annotation.getAnnotationType().toString().toUpperCase();
+      if (annotationName.endsWith("RES")) {
+        // Catch annotations like StringRes
+        return "id";
+      } else if (annotationName.endsWith("RANGE")) {
+        // Catch annotations like IntRange
+        return "value";
+      }
+    }
+
+    return parameter.getSimpleName().toString();
+  }
+
+  private static String applySmartParameterNameReplacements(String name) {
+    name = name.replace("[]", "s");
+    name = name.replace(Class.class.getSimpleName(), "clazz");
+    name = name.replace(Object.class.getSimpleName(), "o");
+    return name;
+  }
+
+  private static List<AnnotationSpec> getAnnotations(VariableElement element) {
+    List<AnnotationSpec> result = new ArrayList<>();
+    for (AnnotationMirror mirror : element.getAnnotationMirrors()) {
+      result.add(AnnotationSpec.get(mirror));
+    }
+    return result;
+  }
+
+  static ClassName nonNull() {
+    try {
+      Class.forName(ANDROIDX_NONNULL_ANNOTATION.reflectionName());
+      return ANDROIDX_NONNULL_ANNOTATION;
+    } catch (ClassNotFoundException e) {
+      return NONNULL_ANNOTATION;
+    }
+  }
+
+  static ClassName checkResult() {
+    try {
+      Class.forName(ANDROIDX_CHECK_RESULT_ANNOTATION.reflectionName());
+      return ANDROIDX_CHECK_RESULT_ANNOTATION;
+    } catch (ClassNotFoundException e) {
+      return CHECK_RESULT_ANNOTATION;
+    }
+  }
+
+  static List<ClassName> nonNulls() {
+    return Arrays.asList(NONNULL_ANNOTATION, JETBRAINS_NOTNULL_ANNOTATION,
+        ANDROIDX_NONNULL_ANNOTATION);
+  }
+
   List<ExecutableElement> findInstanceMethodsReturning(TypeElement clazz, TypeMirror returnType) {
     return FluentIterable.from(clazz.getEnclosedElements())
         .filter(new FilterPublicMethods(returnType, MethodType.INSTANCE))
@@ -280,8 +510,11 @@ void infoLog(String toLog) {
         throw new IllegalArgumentException("Expected single value, but found: " + values);
       }
       excludedModuleAnnotationValue = values.iterator().next().getValue();
-      if (excludedModuleAnnotationValue == null) {
-        throw new NullPointerException("Failed to find Excludes#value");
+      if (excludedModuleAnnotationValue == null
+          || excludedModuleAnnotationValue instanceof Attribute.UnresolvedClass) {
+        throw new IllegalArgumentException(
+            "Failed to find value for: " + annotationClass + " from mirrors: "
+                + clazz.getAnnotationMirrors());
       }
     }
     if (excludedModuleAnnotationValue == null) {
@@ -289,11 +522,10 @@ void infoLog(String toLog) {
     }
     Object value = excludedModuleAnnotationValue.getValue();
     if (value instanceof List) {
-      List values = (List) value;
+      List<?> values = (List<?>) value;
       Set<String> result = new HashSet<>(values.size());
       for (Object current : values) {
-        Attribute.Class currentClass = (Attribute.Class) current;
-        result.add(currentClass.getValue().toString());
+        result.add(getExcludedModuleClassFromAnnotationAttribute(clazz, current));
       }
       return result;
     } else {
@@ -302,6 +534,32 @@ void infoLog(String toLog) {
     }
   }
 
+  // We should be able to cast to Attribute.Class rather than use reflection, but there are some
+  // compilers that seem to break when we do so. See #2673 for an example.
+  private static String getExcludedModuleClassFromAnnotationAttribute(
+      Element clazz, Object attribute) {
+    if (attribute.getClass().getSimpleName().equals("UnresolvedClass")) {
+      throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz
+          + ", one or more excluded Modules could not be found at compile time. Ensure that all"
+          + "excluded Modules are included in your classpath.");
+    }
+    Method[] methods = attribute.getClass().getDeclaredMethods();
+    if (methods == null || methods.length == 0) {
+      throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz
+          + ", invalid exclude: " + attribute);
+    }
+    for (Method method : methods) {
+      if (method.getName().equals("getValue")) {
+        try {
+          return method.invoke(attribute).toString();
+        } catch (IllegalAccessException | InvocationTargetException e) {
+          throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz, e);
+        }
+      }
+    }
+    throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz);
+  }
+
   private enum MethodType {
     STATIC,
     INSTANCE
@@ -312,12 +570,12 @@ void infoLog(String toLog) {
     private final TypeMirror returnType;
     private final MethodType methodType;
 
-    FilterPublicMethods(@Nullable TypeMirror returnType, MethodType methodType)  {
+    FilterPublicMethods(@Nullable TypeMirror returnType, MethodType methodType) {
       this.returnType = returnType;
       this.methodType = methodType;
     }
 
-    FilterPublicMethods(@Nullable TypeElement returnType, MethodType methodType)  {
+    FilterPublicMethods(@Nullable TypeElement returnType, MethodType methodType) {
       this(returnType != null ? returnType.asType() : null, methodType);
     }
 
@@ -335,10 +593,7 @@ public boolean apply(@Nullable Element input) {
         return false;
       }
       ExecutableElement method = (ExecutableElement) input;
-      if (returnType == null) {
-        return true;
-      }
-      return isReturnValueTypeMatching(method, returnType);
+      return returnType == null || isReturnValueTypeMatching(method, returnType);
     }
   }
 
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java
index aa2618b83..b45ea1779 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java
@@ -1,5 +1,8 @@
 package com.bumptech.glide.annotation.compiler;
 
+import static com.bumptech.glide.annotation.compiler.ProcessorUtil.checkResult;
+import static com.bumptech.glide.annotation.compiler.ProcessorUtil.nonNull;
+
 import com.bumptech.glide.annotation.GlideExtension;
 import com.bumptech.glide.annotation.GlideOption;
 import com.google.common.base.Function;
@@ -20,20 +23,23 @@
 import com.squareup.javapoet.TypeVariableName;
 import com.squareup.javapoet.WildcardTypeName;
 import java.io.File;
+import java.util.ArrayList;
 import java.util.Collections;
+import java.util.HashSet;
 import java.util.List;
+import java.util.Set;
 import javax.annotation.Nullable;
 import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 
 /**
- * Generates a {@link com.bumptech.glide.RequestBuilder} subclass containing all methods from
- * the base class, all methods from {@link com.bumptech.glide.request.RequestOptions} and all
+ * Generates a {@code com.bumptech.glide.RequestBuilder} subclass containing all methods from
+ * the base class, all methods from {@code com.bumptech.glide.request.RequestOptions} and all
  * non-override {@link GlideOption} annotated methods in {@link GlideExtension} annotated
  * classes.
  *
@@ -102,15 +108,17 @@
   /** A set of method names to avoid overriding from RequestOptions. */
   private static final ImmutableSet<String> EXCLUDED_METHODS_FROM_BASE_REQUEST_OPTIONS =
       ImmutableSet.of("clone", "apply", "autoLock", "lock", "autoClone");
+  private static final AnnotationSpec NON_NULL = AnnotationSpec.builder(nonNull()).build();
+  private static final AnnotationSpec CHECK_RESULT = AnnotationSpec.builder(checkResult()).build();
 
   private final ProcessingEnvironment processingEnv;
   private final ProcessorUtil processorUtil;
-  private ClassName generatedRequestBuilderClassName;
   private final TypeVariableName transcodeTypeName;
-  private ParameterizedTypeName generatedRequestBuilderOfTranscodeType;
   private final TypeElement requestOptionsType;
   private final TypeElement requestBuilderType;
+  private ClassName generatedRequestBuilderClassName;
   private ClassName requestOptionsClassName;
+  private ParameterizedTypeName generatedRequestBuilderOfTranscodeType;
 
   RequestBuilderGenerator(ProcessingEnvironment processingEnv, ProcessorUtil processorUtil) {
     this.processingEnv = processingEnv;
@@ -125,12 +133,10 @@
         REQUEST_OPTIONS_QUALIFIED_NAME);
   }
 
-  TypeSpec generate(String generatedCodePackageName, @Nullable TypeSpec generatedOptions) {
-    generatedRequestBuilderClassName =
-        ClassName.get(generatedCodePackageName, GENERATED_REQUEST_BUILDER_SIMPLE_NAME);
-    generatedRequestBuilderOfTranscodeType =
-        ParameterizedTypeName.get(generatedRequestBuilderClassName, transcodeTypeName);
-
+  TypeSpec generate(
+      String generatedCodePackageName,
+      Set<String> glideExtensionClassNames,
+      @Nullable TypeSpec generatedOptions) {
     if (generatedOptions != null) {
       requestOptionsClassName =
           ClassName.get(generatedCodePackageName, generatedOptions.name);
@@ -138,14 +144,25 @@ TypeSpec generate(String generatedCodePackageName, @Nullable TypeSpec generatedO
       requestOptionsClassName =
           ClassName.get(
               RequestOptionsGenerator.REQUEST_OPTIONS_PACKAGE_NAME,
-              RequestBuilderGenerator.REQUEST_OPTIONS_SIMPLE_NAME);
+              RequestOptionsGenerator.BASE_REQUEST_OPTIONS_SIMPLE_NAME);
     }
 
+    generatedRequestBuilderClassName =
+        ClassName.get(generatedCodePackageName, GENERATED_REQUEST_BUILDER_SIMPLE_NAME);
+    generatedRequestBuilderOfTranscodeType =
+        ParameterizedTypeName.get(generatedRequestBuilderClassName, transcodeTypeName);
+    RequestOptionsExtensionGenerator requestOptionsExtensionGenerator =
+        new RequestOptionsExtensionGenerator(generatedRequestBuilderOfTranscodeType, processorUtil);
+
     ParameterizedTypeName requestBuilderOfTranscodeType =
         ParameterizedTypeName.get(
             ClassName.get(REQUEST_BUILDER_PACKAGE_NAME, REQUEST_BUILDER_SIMPLE_NAME),
             transcodeTypeName);
 
+    List<MethodSpec> requestOptionsExtensionMethods =
+        requestOptionsExtensionGenerator.generateInstanceMethodsForExtensions(
+            glideExtensionClassNames);
+
     return TypeSpec.classBuilder(GENERATED_REQUEST_BUILDER_SIMPLE_NAME)
         .addJavadoc("Contains all public methods from {@link $T}, all options from\n",
             requestBuilderType)
@@ -165,69 +182,24 @@ TypeSpec generate(String generatedCodePackageName, @Nullable TypeSpec generatedO
         .addModifiers(Modifier.PUBLIC)
         .addTypeVariable(transcodeTypeName)
         .superclass(requestBuilderOfTranscodeType)
+        .addSuperinterface(Cloneable.class)
         .addMethods(generateConstructors())
         .addMethod(generateDownloadOnlyRequestMethod())
-        .addMethods(generateGeneratedRequestOptionsEquivalents(generatedOptions))
+        .addMethods(
+            generateGeneratedRequestOptionsEquivalents(
+                requestOptionsExtensionMethods, generatedOptions))
         .addMethods(generateRequestBuilderOverrides())
+        .addMethods(requestOptionsExtensionMethods)
         .build();
   }
-
-  /**
-   * Generates overrides of all methods in {@link com.bumptech.glide.RequestBuilder} that return
-   * {@link com.bumptech.glide.RequestBuilder} so that they return our generated subclass instead.
-   */
-  private List<MethodSpec> generateRequestBuilderOverrides() {
-    TypeMirror rawRequestBuilderType =
-        processingEnv.getTypeUtils().erasure(requestBuilderType.asType());
-    return Lists.transform(
-        processorUtil.findInstanceMethodsReturning(requestBuilderType, rawRequestBuilderType),
-        new Function<ExecutableElement, MethodSpec>() {
-          @Override
-          public MethodSpec apply(ExecutableElement input) {
-            return generateRequestBuilderOverride(input);
-          }
-        });
-  }
-
-  /**
-   * Generates an override of a particular method in {@link com.bumptech.glide.RequestBuilder} that
-   * returns {@link com.bumptech.glide.RequestBuilder} so that it returns our generated subclass
-   * instead.
-   */
-  private MethodSpec generateRequestBuilderOverride(ExecutableElement methodToOverride) {
-    // We've already verified that this method returns a RequestBuilder and RequestBuilders have
-    // exactly one type argument, so this is safe unless those assumptions change.
-    TypeMirror typeArgument =
-        ((DeclaredType) methodToOverride.getReturnType()).getTypeArguments().get(0);
-
-    ParameterizedTypeName generatedRequestBuilderOfType =
-        ParameterizedTypeName.get(generatedRequestBuilderClassName, ClassName.get(typeArgument));
-
-    return MethodSpec.overriding(methodToOverride)
-        .returns(generatedRequestBuilderOfType)
-        .addCode(CodeBlock.builder()
-            .add("return ($T) super.$N(",
-                generatedRequestBuilderOfType, methodToOverride.getSimpleName())
-            .add(FluentIterable.from(methodToOverride.getParameters())
-                .transform(new Function<VariableElement, String>() {
-                  @Override
-                  public String apply(VariableElement input) {
-                    return input.getSimpleName().toString();
-                  }
-                })
-                .join(Joiner.on(", ")))
-            .add(");\n")
-            .build())
-        .build();
-  }
-
   /**
    * Generates methods with equivalent names and arguments to methods annotated with
    * {@link GlideOption} in
    * {@link com.bumptech.glide.annotation.GlideExtension}s that return our generated
-   * {@link com.bumptech.glide.RequestBuilder} subclass.
+   * {@code com.bumptech.glide.RequestBuilder} subclass.
    */
   private List<MethodSpec> generateGeneratedRequestOptionsEquivalents(
+      final List<MethodSpec> requestOptionsExtensionMethods,
       @Nullable final TypeSpec generatedOptions) {
     if (generatedOptions == null) {
       return Collections.emptyList();
@@ -237,7 +209,7 @@ public String apply(VariableElement input) {
         .filter(new Predicate<MethodSpec>() {
           @Override
           public boolean apply(MethodSpec input) {
-            return isUsefulGeneratedRequestOption(input);
+            return isUsefulGeneratedRequestOption(requestOptionsExtensionMethods, input);
           }
         })
         .transform(new Function<MethodSpec, MethodSpec>() {
@@ -249,26 +221,41 @@ public MethodSpec apply(MethodSpec input) {
         .toList();
   }
 
+
   /**
    * Returns {@code true} if the given {@link MethodSpec} is a useful method to have in our
-   * {@link com.bumptech.glide.RequestBuilder} subclass.
+   * {@code com.bumptech.glide.RequestBuilder} subclass.
    *
    * <p>Only newly generated methods will be included in the generated
-   * {@link com.bumptech.glide.request.BaseRequestBuilder} subclass, so we only have to filter out
+   * {@code com.bumptech.glide.request.BaseRequestBuilder} subclass, so we only have to filter out
    * methods that override other methods to avoid duplicates.
    */
-  private boolean isUsefulGeneratedRequestOption(MethodSpec requestOptionMethod) {
+  private boolean isUsefulGeneratedRequestOption(
+      List<MethodSpec> requestOptionsExtensionMethods,
+      final MethodSpec requestOptionsMethod) {
     return
-        !EXCLUDED_METHODS_FROM_BASE_REQUEST_OPTIONS.contains(requestOptionMethod.name)
-        && requestOptionMethod.hasModifier(Modifier.PUBLIC)
-        && !requestOptionMethod.hasModifier(Modifier.STATIC)
-        && requestOptionMethod.returnType.toString()
-            .equals(requestOptionsClassName.toString());
+        !EXCLUDED_METHODS_FROM_BASE_REQUEST_OPTIONS.contains(requestOptionsMethod.name)
+            && requestOptionsMethod.hasModifier(Modifier.PUBLIC)
+            && !requestOptionsMethod.hasModifier(Modifier.STATIC)
+            && requestOptionsMethod.returnType.toString().equals(requestOptionsClassName.toString())
+            && !isExtensionMethod(requestOptionsExtensionMethods, requestOptionsMethod);
   }
 
-   /**
+  private boolean isExtensionMethod(
+      List<MethodSpec> requestOptionsExtensionMethods, final MethodSpec requestOptionsMethod) {
+     return
+         FluentIterable.from(requestOptionsExtensionMethods).anyMatch(new Predicate<MethodSpec>() {
+           @Override
+           public boolean apply(MethodSpec input) {
+             return input.name.equals(requestOptionsMethod.name)
+                 && input.parameters.equals(requestOptionsMethod.parameters);
+           }
+         });
+  }
+
+  /**
    * Generates a particular method with  an equivalent name and arguments to the given method
-   * from the generated {@link com.bumptech.glide.request.BaseRequestBuilder} subclass.
+   * from the generated {@code com.bumptech.glide.request.BaseRequestBuilder} subclass.
    */
   private MethodSpec generateGeneratedRequestOptionEquivalent(MethodSpec requestOptionMethod) {
     CodeBlock callRequestOptionsMethod = CodeBlock.builder()
@@ -284,25 +271,145 @@ public String apply(ParameterSpec input) {
         .add(");\n")
         .build();
 
-    return MethodSpec.methodBuilder(requestOptionMethod.name)
+    MethodSpec.Builder result = MethodSpec.methodBuilder(requestOptionMethod.name)
         .addJavadoc(
             processorUtil.generateSeeMethodJavadoc(requestOptionsClassName, requestOptionMethod))
         .addModifiers(Modifier.PUBLIC)
+        .varargs(requestOptionMethod.varargs)
+        .addAnnotations(
+            FluentIterable.from(requestOptionMethod.annotations)
+                .filter(new Predicate<AnnotationSpec>() {
+                  @Override
+                  public boolean apply(AnnotationSpec input) {
+                    return !input.type.equals(TypeName.get(Override.class))
+                        // SafeVarargs can only be applied to final methods. GlideRequest is
+                        // non-final to allow for mocking.
+                        && !input.type.equals(TypeName.get(SafeVarargs.class))
+                        // We need to combine warnings below.
+                        && !input.type.equals(TypeName.get(SuppressWarnings.class));
+                  }
+                })
+                .toList()
+        )
         .addTypeVariables(requestOptionMethod.typeVariables)
         .addParameters(requestOptionMethod.parameters)
         .returns(generatedRequestBuilderOfTranscodeType)
-        .beginControlFlow(
-            "if (getMutableOptions() instanceof $T)", requestOptionsClassName)
-        .addCode("this.requestOptions = (($T) getMutableOptions())",
-            requestOptionsClassName)
-        .addCode(callRequestOptionsMethod)
-        .nextControlFlow("else")
-        .addCode(CodeBlock.of("this.requestOptions = new $T().apply(this.requestOptions)",
-            requestOptionsClassName))
-        .addCode(callRequestOptionsMethod)
-        .endControlFlow()
-        .addStatement("return this")
-        .build();
+        .addCode("return ($T) super", generatedRequestBuilderOfTranscodeType)
+        .addCode(callRequestOptionsMethod);
+
+    AnnotationSpec suppressWarnings = buildSuppressWarnings(requestOptionMethod);
+    if (suppressWarnings != null) {
+      result.addAnnotation(suppressWarnings);
+    }
+    return result.build();
+  }
+
+
+  @Nullable
+  private AnnotationSpec buildSuppressWarnings(MethodSpec requestOptionMethod) {
+    Set<String> suppressions = new HashSet<>();
+    if (requestOptionMethod.annotations.contains(
+        AnnotationSpec.builder(SuppressWarnings.class).build())) {
+      for (AnnotationSpec annotation : requestOptionMethod.annotations) {
+        if (annotation.type.equals(TypeName.get(SuppressWarnings.class))) {
+          List<CodeBlock> codeBlocks = annotation.members.get("value");
+          suppressions.addAll(FluentIterable.from(codeBlocks).transform(
+              new Function<CodeBlock, String>() {
+                @Override
+                public String apply(CodeBlock input) {
+                  return input.toString();
+                }
+              }).toSet());
+        }
+      }
+    }
+
+    if (requestOptionMethod.annotations.contains(
+        AnnotationSpec.builder(SafeVarargs.class).build())) {
+      suppressions.add("unchecked");
+      suppressions.add("varargs");
+    }
+
+    if (suppressions.isEmpty()) {
+      return null;
+    }
+    // Enforce ordering across compilers (Internal and External compilers end up disagreeing on the
+    // order produced by the Set additions above.)
+    ArrayList<String> suppressionsList = new ArrayList<>(suppressions);
+    Collections.sort(suppressionsList);
+
+    AnnotationSpec.Builder builder = AnnotationSpec.builder(SuppressWarnings.class);
+    for (String suppression : suppressionsList) {
+      builder.addMember("value", "$S", suppression);
+    }
+
+    return builder.build();
+  }
+
+
+  /**
+   * Generates overrides of all methods in {@code com.bumptech.glide.RequestBuilder} that return
+   * {@code com.bumptech.glide.RequestBuilder} so that they return our generated subclass instead.
+   */
+  private List<MethodSpec> generateRequestBuilderOverrides() {
+    TypeMirror rawRequestBuilderType =
+        processingEnv.getTypeUtils().erasure(requestBuilderType.asType());
+    return Lists.transform(
+        processorUtil.findInstanceMethodsReturning(requestBuilderType, rawRequestBuilderType),
+        new Function<ExecutableElement, MethodSpec>() {
+          @Override
+          public MethodSpec apply(ExecutableElement input) {
+            return generateRequestBuilderOverride(input);
+          }
+        });
+  }
+
+
+  /**
+   * Generates an override of a particular method in {@code com.bumptech.glide.RequestBuilder} that
+   * returns {@code com.bumptech.glide.RequestBuilder} so that it returns our generated subclass
+   * instead.
+   */
+  private MethodSpec generateRequestBuilderOverride(ExecutableElement methodToOverride) {
+    // We've already verified that this method returns a RequestBuilder and RequestBuilders have
+    // exactly one type argument, so this is safe unless those assumptions change.
+    TypeMirror typeArgument =
+        ((DeclaredType) methodToOverride.getReturnType()).getTypeArguments().get(0);
+
+    ParameterizedTypeName generatedRequestBuilderOfType =
+        ParameterizedTypeName.get(generatedRequestBuilderClassName, ClassName.get(typeArgument));
+
+    MethodSpec.Builder builder = ProcessorUtil.overriding(methodToOverride)
+        .returns(generatedRequestBuilderOfType);
+    builder.addCode(CodeBlock.builder()
+        .add("return ($T) super.$N(",
+            generatedRequestBuilderOfType, methodToOverride.getSimpleName())
+        .add(FluentIterable.from(builder.build().parameters)
+            .transform(new Function<ParameterSpec, String>() {
+              @Override
+              public String apply(ParameterSpec input) {
+                return input.name;
+              }
+            })
+            .join(Joiner.on(", ")))
+        .add(");\n")
+        .build());
+
+    for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {
+      builder = builder.addAnnotation(AnnotationSpec.get(mirror));
+    }
+
+    if (methodToOverride.isVarArgs()) {
+      builder = builder
+          .addModifiers(Modifier.FINAL)
+          .addAnnotation(SafeVarargs.class)
+          .addAnnotation(
+              AnnotationSpec.builder(SuppressWarnings.class)
+                  .addMember("value", "$S", "varargs")
+                  .build());
+    }
+
+    return builder.build();
   }
 
   private List<MethodSpec> generateConstructors() {
@@ -315,25 +422,46 @@ public String apply(ParameterSpec input) {
 
     MethodSpec firstConstructor =
         MethodSpec.constructorBuilder()
-            .addParameter(classOfTranscodeType, "transcodeClass")
-            .addParameter(requestBuilderOfWildcardOfObject, "other")
+            .addParameter(ParameterSpec.builder(classOfTranscodeType, "transcodeClass")
+                .addAnnotation(nonNull())
+                .build()
+            )
+            .addParameter(ParameterSpec.builder(requestBuilderOfWildcardOfObject, "other")
+                .addAnnotation(nonNull())
+                .build()
+            )
         .addStatement("super($N, $N)", "transcodeClass", "other")
         .build();
 
+    ClassName context = ClassName.get("android.content", "Context");
     ClassName glide = ClassName.get("com.bumptech.glide", "Glide");
     ClassName requestManager = ClassName.get("com.bumptech.glide", "RequestManager");
     MethodSpec secondConstructor =
         MethodSpec.constructorBuilder()
-            .addParameter(glide, "glide")
-            .addParameter(requestManager, "requestManager")
-            .addParameter(classOfTranscodeType, "transcodeClass")
-            .addStatement("super($N, $N ,$N)", "glide", "requestManager", "transcodeClass")
+            .addParameter(ParameterSpec.builder(glide, "glide")
+                .addAnnotation(nonNull())
+                .build()
+            )
+            .addParameter(ParameterSpec.builder(requestManager, "requestManager")
+                .addAnnotation(nonNull())
+                .build()
+            )
+            .addParameter(ParameterSpec.builder(classOfTranscodeType, "transcodeClass")
+                .addAnnotation(nonNull())
+                .build()
+            )
+            .addParameter(ParameterSpec.builder(context, "context")
+                .addAnnotation(nonNull())
+                .build()
+            )
+            .addStatement(
+                "super($N, $N ,$N, $N)", "glide", "requestManager", "transcodeClass", "context")
             .build();
     return ImmutableList.of(firstConstructor, secondConstructor);
   }
 
   /**
-   * Overrides the protected downloadOnly method in {@link com.bumptech.glide.RequestBuilder} to
+   * Overrides the protected downloadOnly method in {@code com.bumptech.glide.RequestBuilder} to
    * return our generated subclass instead.
    */
   private MethodSpec generateDownloadOnlyRequestMethod() {
@@ -341,6 +469,8 @@ private MethodSpec generateDownloadOnlyRequestMethod() {
         = ParameterizedTypeName.get(generatedRequestBuilderClassName, ClassName.get(File.class));
     return MethodSpec.methodBuilder("getDownloadOnlyRequest")
         .addAnnotation(Override.class)
+        .addAnnotation(CHECK_RESULT)
+        .addAnnotation(NON_NULL)
         .returns(generatedRequestBuilderOfFile)
         .addModifiers(Modifier.PROTECTED)
         .addStatement("return new $T<>($T.class, $N).apply($N)",
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerFactoryGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerFactoryGenerator.java
index a86bb1a37..d20a7fd2a 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerFactoryGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerFactoryGenerator.java
@@ -1,7 +1,10 @@
 package com.bumptech.glide.annotation.compiler;
 
+import static com.bumptech.glide.annotation.compiler.ProcessorUtil.nonNull;
+
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
 import com.squareup.javapoet.TypeSpec;
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.Modifier;
@@ -10,10 +13,10 @@
 
 /**
  * Generates an implementation of
- * {@link com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory} that returns a
- * generated {@link com.bumptech.glide.RequestManager} implementation.
+ * {@code com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory} that returns a
+ * generated {@code com.bumptech.glide.RequestManager} implementation.
  *
- * <p>Generated {@link com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory}
+ * <p>Generated {@code com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory}
  * classes look like this:
  * <pre>
  * <code>
@@ -39,6 +42,8 @@
       "com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory";
   private static final String REQUEST_MANAGER_QUALIFIED_NAME =
       "com.bumptech.glide.RequestManager";
+  private static final ClassName CONTEXT_CLASS_NAME =
+      ClassName.get("android.content", "Context");
 
   static final String GENERATED_REQUEST_MANAGER_FACTORY_PACKAGE_NAME =
       "com.bumptech.glide";
@@ -63,7 +68,6 @@
 
     TypeElement requestManagerType = elementUtils.getTypeElement(REQUEST_MANAGER_QUALIFIED_NAME);
     requestManagerClassName = ClassName.get(requestManagerType);
-
   }
 
   TypeSpec generate(String generatedCodePackageName, TypeSpec generatedRequestManagerSpec) {
@@ -75,12 +79,27 @@ TypeSpec generate(String generatedCodePackageName, TypeSpec generatedRequestMana
             MethodSpec.methodBuilder("build")
                 .addModifiers(Modifier.PUBLIC)
                 .addAnnotation(Override.class)
+                .addAnnotation(nonNull())
                 .returns(requestManagerClassName)
-                .addParameter(ClassName.get(glideType), "glide")
-                .addParameter(ClassName.get(lifecycleType), "lifecycle")
-                .addParameter(ClassName.get(requestManagerTreeNodeType), "treeNode")
+                .addParameter(ParameterSpec.builder(ClassName.get(glideType), "glide")
+                    .addAnnotation(nonNull())
+                    .build()
+                )
+                .addParameter(ParameterSpec.builder(ClassName.get(lifecycleType), "lifecycle")
+                    .addAnnotation(nonNull())
+                    .build()
+                )
+                .addParameter(
+                    ParameterSpec.builder(ClassName.get(requestManagerTreeNodeType), "treeNode")
+                        .addAnnotation(nonNull())
+                        .build()
+                )
+                .addParameter(ParameterSpec.builder(CONTEXT_CLASS_NAME, "context")
+                    .addAnnotation(nonNull())
+                    .build()
+                )
                 .addStatement(
-                    "return new $T(glide, lifecycle, treeNode)",
+                    "return new $T(glide, lifecycle, treeNode, context)",
                     ClassName.get(generatedCodePackageName, generatedRequestManagerSpec.name))
                 .build()
         )
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java
index 1c20fe858..d66257e87 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java
@@ -1,17 +1,19 @@
 package com.bumptech.glide.annotation.compiler;
 
+import static com.bumptech.glide.annotation.compiler.ProcessorUtil.checkResult;
+import static com.bumptech.glide.annotation.compiler.ProcessorUtil.nonNull;
+
 import com.bumptech.glide.annotation.GlideExtension;
 import com.bumptech.glide.annotation.GlideType;
 import com.google.common.base.Function;
-import com.google.common.base.Joiner;
 import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.Lists;
 import com.squareup.javapoet.AnnotationSpec;
 import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.MethodSpec.Builder;
 import com.squareup.javapoet.ParameterSpec;
 import com.squareup.javapoet.ParameterizedTypeName;
 import com.squareup.javapoet.TypeSpec;
@@ -21,19 +23,20 @@
 import java.util.Set;
 import javax.annotation.Nullable;
 import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 
 /**
- * Generates an implementation of {@link com.bumptech.glide.RequestManager} that contains generated
+ * Generates an implementation of {@code com.bumptech.glide.RequestManager} that contains generated
  * methods from {@link GlideExtension}s and {@link GlideType}.
  *
- * <p>Generated {@link com.bumptech.glide.RequestManager} implementations look like this:
+ * <p>Generated {@code com.bumptech.glide.RequestManager} implementations look like this:
  * <pre>
  * <code>
  * public final class GeneratedRequestManager extends RequestManager {
@@ -59,6 +62,8 @@
       "com.bumptech.glide.manager.Lifecycle";
   private static final String REQUEST_MANAGER_TREE_NODE_QUALIFIED_NAME =
       "com.bumptech.glide.manager.RequestManagerTreeNode";
+  private static final ClassName CONTEXT_CLASS_NAME =
+      ClassName.get("android.content", "Context");
 
   private static final String GENERATED_REQUEST_MANAGER_SIMPLE_NAME =
       "GlideRequests";
@@ -92,42 +97,55 @@
     glideType = elementUtils.getTypeElement(GLIDE_QUALIFIED_NAME);
   }
 
-  @Nullable
   TypeSpec generate(
       String generatedCodePackageName, @Nullable TypeSpec requestOptions, TypeSpec requestBuilder,
       Set<String> glideExtensions) {
     generatedRequestBuilderClassName = ClassName.get(generatedCodePackageName, requestBuilder.name);
     return TypeSpec.classBuilder(GENERATED_REQUEST_MANAGER_SIMPLE_NAME)
-         .superclass(requestManagerClassName)
-         .addJavadoc("Includes all additions from methods in {@link $T}s\n"
-                 + "annotated with {@link $T}\n"
-                 + "\n"
-                 + "<p>Generated code, do not modify\n",
-             GlideExtension.class, GlideType.class)
+        .superclass(requestManagerClassName)
+        .addJavadoc("Includes all additions from methods in {@link $T}s\n"
+                + "annotated with {@link $T}\n"
+                + "\n"
+                + "<p>Generated code, do not modify\n",
+            GlideExtension.class, GlideType.class)
         .addAnnotation(
             AnnotationSpec.builder(SuppressWarnings.class)
                 .addMember("value", "$S", "deprecation")
                 .build())
-         .addModifiers(Modifier.PUBLIC)
-         .addMethod(generateAsMethod(generatedCodePackageName, requestBuilder))
-         .addMethod(generateCallSuperConstructor())
-         .addMethods(generateAdditionalRequestManagerMethods(glideExtensions))
-         .addMethods(generateRequestManagerMethodOverrides())
-         .addMethods(
-             FluentIterable.from(
-                 Collections.singletonList(
-                     generateOverrideSetRequestOptions(generatedCodePackageName, requestOptions)))
-                 .filter(Predicates.<MethodSpec>notNull()))
-         .build();
+        .addModifiers(Modifier.PUBLIC)
+        .addMethod(generateAsMethod(generatedCodePackageName, requestBuilder))
+        .addMethod(generateCallSuperConstructor())
+        .addMethods(generateExtensionRequestManagerMethods(glideExtensions))
+        .addMethods(generateRequestManagerRequestManagerMethodOverrides(generatedCodePackageName))
+        .addMethods(generateRequestManagerRequestBuilderMethodOverrides())
+        .addMethods(
+            FluentIterable.from(
+                Collections.singletonList(
+                    generateOverrideSetRequestOptions(generatedCodePackageName, requestOptions)))
+                .filter(Predicates.<MethodSpec>notNull()))
+        .build();
   }
 
   private MethodSpec generateCallSuperConstructor() {
     return MethodSpec.constructorBuilder()
         .addModifiers(Modifier.PUBLIC)
-        .addParameter(ClassName.get(glideType), "glide")
-        .addParameter(ClassName.get(lifecycleType), "lifecycle")
-        .addParameter(ClassName.get(requestManagerTreeNodeType), "treeNode")
-        .addStatement("super(glide, lifecycle, treeNode)")
+        .addParameter(ParameterSpec.builder(ClassName.get(glideType), "glide")
+            .addAnnotation(nonNull())
+            .build()
+        )
+        .addParameter(ParameterSpec.builder(ClassName.get(lifecycleType), "lifecycle")
+            .addAnnotation(nonNull())
+            .build()
+        )
+        .addParameter(ParameterSpec.builder(ClassName.get(requestManagerTreeNodeType), "treeNode")
+            .addAnnotation(nonNull())
+            .build()
+        )
+        .addParameter(ParameterSpec.builder(CONTEXT_CLASS_NAME, "context")
+            .addAnnotation(nonNull())
+            .build()
+        )
+        .addStatement("super(glide, lifecycle, treeNode, context)")
         .build();
   }
 
@@ -145,25 +163,52 @@ private MethodSpec generateAsMethod(String generatedCodePackageName, TypeSpec re
     return MethodSpec.methodBuilder("as")
         .addModifiers(Modifier.PUBLIC)
         .addAnnotation(Override.class)
+        .addAnnotation(checkResult())
+        .addAnnotation(nonNull())
         .addTypeVariable(TypeVariableName.get("ResourceType"))
-        .addParameter(classOfResouceType, "resourceClass")
         .returns(requestBuilderOfResourceType)
-        .addStatement("return new $T<>(glide, this, resourceClass)",
+        .addParameter(classOfResouceType.annotated(AnnotationSpec.builder(nonNull()).build()),
+            "resourceClass")
+        .addStatement("return new $T<>(glide, this, resourceClass, context)",
             this.generatedRequestBuilderClassName)
         .build();
   }
 
-  private List<MethodSpec> generateRequestManagerMethodOverrides() {
+  /** Generates the list of overrides of methods that return {@code RequestManager}. */
+  private List<MethodSpec> generateRequestManagerRequestManagerMethodOverrides(
+      final String generatedPackageName) {
+    return FluentIterable.from(
+        processorUtil.findInstanceMethodsReturning(requestManagerType, requestManagerType))
+        .transform(new Function<ExecutableElement, MethodSpec>() {
+          @Override
+          public MethodSpec apply(@Nullable ExecutableElement input) {
+            return generateRequestManagerRequestManagerMethodOverride(generatedPackageName, input);
+          }
+        })
+        .toList();
+  }
+
+  private MethodSpec generateRequestManagerRequestManagerMethodOverride(
+      String generatedPackageName, ExecutableElement method) {
+    ClassName generatedRequestManagerName =
+        ClassName.get(generatedPackageName, GENERATED_REQUEST_MANAGER_SIMPLE_NAME);
+    Builder returns = ProcessorUtil.overriding(method)
+        .addAnnotation(nonNull())
+        .returns(generatedRequestManagerName);
+    return returns
+        .addCode(ProcessorUtil.generateCastingSuperCall(
+            generatedRequestManagerName, returns.build()))
+        .build();
+  }
+
+  /** Generates the list of overrides of methods that return {@code RequestBuilder}. */
+  private List<MethodSpec> generateRequestManagerRequestBuilderMethodOverrides() {
     // Without the erasure, this is a RequestBuilder<Y>. A RequestBuilder<X> is not assignable to a
     // RequestBuilder<Y>. After type erasure this is a RequestBuilder. A RequestBuilder<X> is
     // assignable to the raw RequestBuilder.
     TypeMirror rawRequestBuilder = processingEnv.getTypeUtils()
         .erasure(requestBuilderType.asType());
 
-    final TypeElement classType =
-        processingEnv.getElementUtils().getTypeElement(Class.class.getCanonicalName());
-    final TypeMirror rawClassType = processingEnv.getTypeUtils().erasure(classType.asType());
-
     return FluentIterable.from(
         processorUtil.findInstanceMethodsReturning(requestManagerType, rawRequestBuilder))
         .filter(new Predicate<ExecutableElement>() {
@@ -176,7 +221,7 @@ public boolean apply(ExecutableElement input) {
         .transform(new Function<ExecutableElement, MethodSpec>() {
           @Override
           public MethodSpec apply(ExecutableElement input) {
-            return generateRequestManagerMethodOverride(input);
+            return generateRequestManagerRequestBuilderMethodOverride(input);
           }
         })
         .toList();
@@ -186,8 +231,9 @@ public MethodSpec apply(ExecutableElement input) {
    * Generates overrides of existing RequestManager methods so that they return our generated
    * RequestBuilder subtype.
    */
-  private MethodSpec generateRequestManagerMethodOverride(ExecutableElement methodToOverride) {
-     // We've already verified that this method returns a RequestBuilder and RequestBuilders have
+  private MethodSpec generateRequestManagerRequestBuilderMethodOverride(
+      ExecutableElement methodToOverride) {
+    // We've already verified that this method returns a RequestBuilder and RequestBuilders have
     // exactly one type argument, so this is safe unless those assumptions change.
     TypeMirror typeArgument =
         ((DeclaredType) methodToOverride.getReturnType()).getTypeArguments().get(0);
@@ -195,25 +241,18 @@ private MethodSpec generateRequestManagerMethodOverride(ExecutableElement method
     ParameterizedTypeName generatedRequestBuilderOfType =
         ParameterizedTypeName.get(generatedRequestBuilderClassName, ClassName.get(typeArgument));
 
-    return MethodSpec.overriding(methodToOverride)
-        .returns(generatedRequestBuilderOfType)
-        .addCode(CodeBlock.builder()
-            .add("return ($T) super.$N(",
-                generatedRequestBuilderOfType, methodToOverride.getSimpleName())
-            .add(FluentIterable.from(methodToOverride.getParameters())
-                .transform(new Function<VariableElement, String>() {
-                  @Override
-                  public String apply(VariableElement input) {
-                    return input.getSimpleName().toString();
-                  }
-                })
-                .join(Joiner.on(", ")))
-            .add(");\n")
-            .build())
-        .build();
+    MethodSpec.Builder builder = ProcessorUtil.overriding(methodToOverride)
+        .returns(generatedRequestBuilderOfType);
+    builder.addCode(
+        ProcessorUtil.generateCastingSuperCall(generatedRequestBuilderOfType, builder.build()));
+
+    for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {
+      builder.addAnnotation(AnnotationSpec.get(mirror));
+    }
+    return builder.build();
   }
 
-  private List<MethodSpec> generateAdditionalRequestManagerMethods(
+  private List<MethodSpec> generateExtensionRequestManagerMethods(
       Set<String> glideExtensions) {
     List<ExecutableElement> requestManagerExtensionMethods =
         processorUtil.findAnnotatedElementsInClasses(glideExtensions, GlideType.class);
@@ -229,6 +268,15 @@ public MethodSpec apply(ExecutableElement input) {
 
   // Generates methods added to RequestManager via GlideExtensions.
   private MethodSpec generateAdditionalRequestManagerMethod(ExecutableElement extensionMethod) {
+    if (extensionMethod.getReturnType().getKind() == TypeKind.VOID) {
+      return generateAdditionalRequestManagerMethodLegacy(extensionMethod);
+    } else {
+      return generateAdditionalRequestManagerMethodNew(extensionMethod);
+    }
+  }
+
+  private MethodSpec generateAdditionalRequestManagerMethodLegacy(
+      ExecutableElement extensionMethod) {
     String returnType = processorUtil.findClassValuesFromAnnotationOnClassAsNames(extensionMethod,
         GlideType.class).iterator().next();
     ClassName returnTypeClassName = ClassName.bestGuess(returnType);
@@ -239,6 +287,8 @@ private MethodSpec generateAdditionalRequestManagerMethod(ExecutableElement exte
         .addModifiers(Modifier.PUBLIC)
         .returns(parameterizedTypeName)
         .addJavadoc(processorUtil.generateSeeMethodJavadoc(extensionMethod))
+        .addAnnotation(nonNull())
+        .addAnnotation(checkResult())
         .addStatement(
             "$T requestBuilder = this.as($T.class)", parameterizedTypeName, returnTypeClassName)
         .addStatement("$T.$N(requestBuilder)",
@@ -247,8 +297,31 @@ private MethodSpec generateAdditionalRequestManagerMethod(ExecutableElement exte
         .build();
   }
 
+  private MethodSpec generateAdditionalRequestManagerMethodNew(
+      ExecutableElement extensionMethod) {
+    String returnType = processorUtil.findClassValuesFromAnnotationOnClassAsNames(extensionMethod,
+        GlideType.class).iterator().next();
+    ClassName returnTypeClassName = ClassName.bestGuess(returnType);
+    ParameterizedTypeName parameterizedTypeName =
+        ParameterizedTypeName.get(generatedRequestBuilderClassName, returnTypeClassName);
+
+    return MethodSpec.methodBuilder(extensionMethod.getSimpleName().toString())
+        .addModifiers(Modifier.PUBLIC)
+        .returns(parameterizedTypeName)
+        .addJavadoc(processorUtil.generateSeeMethodJavadoc(extensionMethod))
+        .addAnnotation(nonNull())
+        .addAnnotation(checkResult())
+        .addStatement(
+            "return ($T) $T.$N(this.as($T.class))",
+            parameterizedTypeName,
+            extensionMethod.getEnclosingElement(),
+            extensionMethod.getSimpleName(),
+            returnTypeClassName)
+        .build();
+  }
+
   /**
-   * The {@link com.bumptech.glide.request.RequestOptions} subclass should always be our
+   * The {@code RequestOptions} subclass should always be our
    * generated subclass type to avoid inadvertent errors where a different subclass is applied that
    * accidentally wipes out some logic in overidden methods in our generated subclass.
    */
@@ -261,10 +334,8 @@ private MethodSpec generateOverrideSetRequestOptions(
 
     Elements elementUtils = processingEnv.getElementUtils();
     TypeElement requestOptionsType =
-            elementUtils.getTypeElement(
-                RequestOptionsGenerator.REQUEST_OPTIONS_QUALIFIED_NAME);
-    TypeElement androidNonNullType =
-            elementUtils.getTypeElement("android.support.annotation.NonNull");
+        elementUtils.getTypeElement(
+            RequestOptionsGenerator.REQUEST_OPTIONS_QUALIFIED_NAME);
 
     // This class may have just been generated and therefore may not be found if we try to obtain
     // it via Elements, so use just the String version instead.
@@ -279,7 +350,7 @@ private MethodSpec generateOverrideSetRequestOptions(
         .addModifiers(Modifier.PROTECTED)
         .addParameter(
             ParameterSpec.builder(ClassName.get(requestOptionsType), parameterName)
-                .addAnnotation(ClassName.get(androidNonNullType))
+                .addAnnotation(nonNull())
                 .build())
         .beginControlFlow("if ($N instanceof $L)",
             parameterName, generatedRequestOptionsQualifiedName)
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsExtensionGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsExtensionGenerator.java
new file mode 100644
index 000000000..450ab8326
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsExtensionGenerator.java
@@ -0,0 +1,139 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.GlideOption.OVERRIDE_EXTEND;
+import static com.bumptech.glide.annotation.compiler.ProcessorUtil.checkResult;
+import static com.bumptech.glide.annotation.compiler.ProcessorUtil.nonNull;
+
+import com.bumptech.glide.annotation.GlideOption;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.TypeName;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeKind;
+
+/**
+ * Generates method overrides for classes that want to mix in {@link GlideOption} annotated methods
+ * in Glide extensions.
+ */
+final class RequestOptionsExtensionGenerator {
+  private TypeName containingClassName;
+  private ProcessorUtil processorUtil;
+
+  RequestOptionsExtensionGenerator(TypeName containingClassName, ProcessorUtil processorUtil) {
+    this.containingClassName = containingClassName;
+    this.processorUtil = processorUtil;
+  }
+
+  /**
+   * Returns the set of {@link GlideOption} annotated methods in the classes that correspond to the
+   * given extension class names.
+   */
+  List<ExecutableElement> getRequestOptionExtensionMethods(Set<String> glideExtensionClassNames) {
+   return processorUtil.findAnnotatedElementsInClasses(glideExtensionClassNames, GlideOption.class);
+  }
+
+  /**
+   * Returns a list containing an override {@link MethodSpec} for all {@link GlideOption} annotated
+   * methods in the classes that correspond to the given extension class names.
+   */
+  List<MethodSpec> generateInstanceMethodsForExtensions(Set<String> glideExtensionClassNames) {
+    List<ExecutableElement> requestOptionExtensionMethods =
+        getRequestOptionExtensionMethods(glideExtensionClassNames);
+
+    List<MethodSpec> result = new ArrayList<>(requestOptionExtensionMethods.size());
+    for (ExecutableElement requestOptionsExtensionMethod : requestOptionExtensionMethods) {
+      result.add(generateMethodsForRequestOptionsExtension(requestOptionsExtensionMethod));
+    }
+
+    return result;
+  }
+
+  private MethodSpec generateMethodsForRequestOptionsExtension(
+      ExecutableElement element) {
+    // Assert for legacy versions
+    if (element.getReturnType().getKind() == TypeKind.VOID) {
+      throw new IllegalArgumentException(
+          "The " + element.getSimpleName() + " method annotated with @GlideOption in the "
+              + element.getEnclosingElement().getSimpleName() + " @GlideExtension is using a legacy"
+              + " format that is no longer supported. Please change your method definition so that"
+              + " your @GlideModule annotated methods return BaseRequestOptions<?> objects instead"
+              + " of null.");
+    }
+
+    int overrideType = processorUtil.getOverrideType(element);
+
+    String methodName = element.getSimpleName().toString();
+    MethodSpec.Builder builder = MethodSpec.methodBuilder(methodName)
+        .addModifiers(Modifier.PUBLIC)
+        .addJavadoc(processorUtil.generateSeeMethodJavadoc(element))
+        .varargs(element.isVarArgs())
+        .returns(containingClassName)
+        .addAnnotation(
+            AnnotationSpec.builder(SuppressWarnings.class)
+                .addMember("value", "$S", "unchecked")
+                .build());
+
+    // The 0th element is expected to be a RequestOptions object.
+    List<? extends VariableElement> paramElements =
+        element.getParameters().subList(1, element.getParameters().size());
+    List<ParameterSpec> parameters = ProcessorUtil.getParameters(paramElements);
+    builder.addParameters(parameters);
+
+    String extensionRequestOptionsArgument;
+    if (overrideType == OVERRIDE_EXTEND) {
+      builder
+          .addJavadoc(
+              processorUtil.generateSeeMethodJavadoc(
+                  containingClassName, methodName, paramElements))
+          .addAnnotation(Override.class);
+
+      List<Object> methodArgs = new ArrayList<>();
+      methodArgs.add(element.getSimpleName().toString());
+      StringBuilder methodLiterals = new StringBuilder();
+      if (!parameters.isEmpty()) {
+        for (ParameterSpec parameter : parameters) {
+          methodLiterals.append("$L, ");
+          methodArgs.add(parameter.name);
+        }
+        methodLiterals = new StringBuilder(
+            methodLiterals.substring(0, methodLiterals.length() - 2));
+      }
+      extensionRequestOptionsArgument = CodeBlock.builder()
+          .add("super.$N(" + methodLiterals + ")", methodArgs.toArray(new Object[0]))
+          .build()
+          .toString();
+    } else {
+      extensionRequestOptionsArgument = "this";
+    }
+
+    List<Object> args = new ArrayList<>();
+    StringBuilder code = new StringBuilder("return ($T) $T.$L($L, ");
+    args.add(containingClassName);
+    args.add(ClassName.get(element.getEnclosingElement().asType()));
+    args.add(element.getSimpleName().toString());
+    args.add(extensionRequestOptionsArgument);
+    if (!parameters.isEmpty()) {
+      for (ParameterSpec parameter : parameters) {
+        code.append("$L, ");
+        args.add(parameter.name);
+      }
+    }
+    code = new StringBuilder(code.substring(0, code.length() - 2));
+    code.append(")");
+    builder.addStatement(code.toString(), args.toArray(new Object[0]));
+
+    builder
+        .addAnnotation(checkResult())
+        .addAnnotation(nonNull());
+
+    return builder.build();
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java
index b9d7e913d..f68cde6e8 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java
@@ -1,13 +1,14 @@
 package com.bumptech.glide.annotation.compiler;
 
-import static com.bumptech.glide.annotation.GlideOption.OVERRIDE_EXTEND;
-import static com.bumptech.glide.annotation.GlideOption.OVERRIDE_NONE;
+import static com.bumptech.glide.annotation.compiler.ProcessorUtil.checkResult;
+import static com.bumptech.glide.annotation.compiler.ProcessorUtil.nonNull;
 
 import com.bumptech.glide.annotation.GlideExtension;
 import com.bumptech.glide.annotation.GlideOption;
 import com.google.common.base.Function;
-import com.google.common.base.Joiner;
 import com.google.common.base.Objects;
+import com.google.common.base.Preconditions;
+import com.google.common.base.Predicate;
 import com.google.common.base.Strings;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
@@ -28,8 +29,6 @@
 import java.util.Set;
 import javax.annotation.Nullable;
 import javax.annotation.processing.ProcessingEnvironment;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
@@ -37,7 +36,7 @@
 import javax.lang.model.element.VariableElement;
 
 /**
- * Generates a new implementation of {@link com.bumptech.glide.request.RequestOptions}
+ * Generates a new implementation of {@code com.bumptech.glide.request.RequestOptions}
  * containing static versions of methods included in the base class and static and instance versions
  * of all methods annotated with {@link GlideOption} in classes annotated with
  * {@link GlideExtension}.
@@ -76,16 +75,21 @@
   static final String REQUEST_OPTIONS_QUALIFIED_NAME =
       REQUEST_OPTIONS_PACKAGE_NAME + "." + REQUEST_OPTIONS_SIMPLE_NAME;
 
-  private final ProcessingEnvironment processingEnvironment;
+  static final String BASE_REQUEST_OPTIONS_SIMPLE_NAME = "BaseRequestOptions";
+  static final String BASE_REQUEST_OPTIONS_QUALIFIED_NAME =
+      REQUEST_OPTIONS_PACKAGE_NAME + "." + BASE_REQUEST_OPTIONS_SIMPLE_NAME;
+
+  private int nextFieldId;
+
   private final ClassName requestOptionsName;
   private final TypeElement requestOptionsType;
   private final ProcessorUtil processorUtil;
+  private final RequestOptionsOverrideGenerator requestOptionsOverrideGenerator;
+
   private ClassName glideOptionsName;
-  private int nextStaticFieldUniqueId;
 
   RequestOptionsGenerator(
       ProcessingEnvironment processingEnvironment, ProcessorUtil processorUtil) {
-    this.processingEnvironment = processingEnvironment;
     this.processorUtil = processorUtil;
 
     requestOptionsName = ClassName.get(REQUEST_OPTIONS_PACKAGE_NAME,
@@ -93,19 +97,55 @@
 
     requestOptionsType = processingEnvironment.getElementUtils().getTypeElement(
         REQUEST_OPTIONS_QUALIFIED_NAME);
+
+    requestOptionsOverrideGenerator =
+        new RequestOptionsOverrideGenerator(processingEnvironment, processorUtil);
   }
 
   TypeSpec generate(String generatedCodePackageName, Set<String> glideExtensionClassNames) {
     glideOptionsName =
         ClassName.get(generatedCodePackageName, GENERATED_REQUEST_OPTIONS_SIMPLE_NAME);
 
-    List<MethodAndStaticVar> methodsForExtensions =
-        generateMethodsForExtensions(glideExtensionClassNames);
+    RequestOptionsExtensionGenerator requestOptionsExtensionGenerator =
+        new RequestOptionsExtensionGenerator(glideOptionsName, processorUtil);
+    List<MethodAndStaticVar> instanceMethodsForExtensions =
+        FluentIterable.from(
+            requestOptionsExtensionGenerator
+                .generateInstanceMethodsForExtensions(glideExtensionClassNames))
+            .transform(new Function<MethodSpec, MethodAndStaticVar>() {
+              @Override
+              public MethodAndStaticVar apply(MethodSpec input) {
+                return new MethodAndStaticVar(input);
+              }
+            })
+            .toList();
+
+    List<MethodAndStaticVar> staticMethodsForExtensions =
+        FluentIterable.from(
+            requestOptionsExtensionGenerator.getRequestOptionExtensionMethods(
+                glideExtensionClassNames))
+            .filter(new Predicate<ExecutableElement>() {
+              @Override
+              public boolean apply(ExecutableElement input) {
+                return !skipStaticMethod(input);
+              }
+            })
+        .transform(new Function<ExecutableElement, MethodAndStaticVar>() {
+          @Override
+          public MethodAndStaticVar apply(ExecutableElement input) {
+            return generateStaticMethodEquivalentForExtensionMethod(input);
+          }
+        })
+        .toList();
+
+    List<MethodAndStaticVar> methodsForExtensions = new ArrayList<>();
+    methodsForExtensions.addAll(instanceMethodsForExtensions);
+    methodsForExtensions.addAll(staticMethodsForExtensions);
 
-    Set<MethodSignature> extensionMethodSignatures = ImmutableSet.copyOf(
-        Iterables.transform(methodsForExtensions,
-            new Function<MethodAndStaticVar, MethodSignature>() {
-              @Nullable
+    Set<MethodSignature> extensionMethodSignatures =
+        ImmutableSet.copyOf(
+            Iterables.transform(methodsForExtensions,
+                new Function<MethodAndStaticVar, MethodSignature>() {
               @Override
               public MethodSignature apply(MethodAndStaticVar f) {
                 return new MethodSignature(f.method);
@@ -113,7 +153,9 @@ public MethodSignature apply(MethodAndStaticVar f) {
             }));
 
     List<MethodAndStaticVar> staticOverrides = generateStaticMethodOverridesForRequestOptions();
-    List<MethodSpec> instanceOverrides = generateInstanceMethodOverridesForRequestOptions();
+    List<MethodSpec> instanceOverrides =
+        requestOptionsOverrideGenerator.generateInstanceMethodOverridesForRequestOptions(
+            glideOptionsName);
 
     List<MethodAndStaticVar> allMethodsAndStaticVars = new ArrayList<>();
     for (MethodAndStaticVar item : staticOverrides) {
@@ -138,6 +180,7 @@ public MethodSignature apply(MethodAndStaticVar f) {
         .addJavadoc(generateClassJavadoc(glideExtensionClassNames))
         .addModifiers(Modifier.FINAL)
         .addModifiers(Modifier.PUBLIC)
+        .addSuperinterface(Cloneable.class)
         .superclass(requestOptionsName);
 
     for (MethodAndStaticVar methodAndStaticVar : allMethodsAndStaticVars) {
@@ -164,123 +207,6 @@ private CodeBlock generateClassJavadoc(Set<String> glideExtensionClassNames) {
     return builder.build();
   }
 
-  private List<MethodAndStaticVar> generateMethodsForExtensions(
-      Set<String> glideExtensionClassNames) {
-    List<ExecutableElement> requestOptionExtensionMethods =
-        processorUtil.findAnnotatedElementsInClasses(
-            glideExtensionClassNames, GlideOption.class);
-
-    List<MethodAndStaticVar> result = new ArrayList<>(requestOptionExtensionMethods.size());
-    for (ExecutableElement requestOptionsExtensionMethod : requestOptionExtensionMethods) {
-      result.addAll(generateMethodsForRequestOptionsExtension(requestOptionsExtensionMethod));
-    }
-
-    return result;
-  }
-
-  private List<MethodSpec> generateInstanceMethodOverridesForRequestOptions() {
-    return Lists.transform(
-        processorUtil.findInstanceMethodsReturning(requestOptionsType, requestOptionsType),
-        new Function<ExecutableElement, MethodSpec>() {
-          @Override
-          public MethodSpec apply(ExecutableElement input) {
-            return generateRequestOptionOverride(input);
-          }
-        });
-  }
-
-  private MethodSpec generateRequestOptionOverride(ExecutableElement methodToOverride) {
-    return MethodSpec.overriding(methodToOverride)
-        .returns(glideOptionsName)
-        .addCode(CodeBlock.builder()
-            .add("return ($T) super.$N(", glideOptionsName, methodToOverride.getSimpleName())
-            .add(FluentIterable.from(methodToOverride.getParameters())
-                .transform(new Function<VariableElement, String>() {
-                  @Override
-                  public String apply(VariableElement input) {
-                    return input.getSimpleName().toString();
-                  }
-                })
-                .join(Joiner.on(", ")))
-            .add(");\n")
-            .build())
-        .build();
-  }
-
-  private List<MethodAndStaticVar> generateMethodsForRequestOptionsExtension(
-      ExecutableElement element) {
-    boolean isOverridingRequestOptionsMethod = isMethodInRequestOptions(element);
-    int overrideType = getOverrideType(element);
-    if (isOverridingRequestOptionsMethod && overrideType == OVERRIDE_NONE) {
-      throw new IllegalArgumentException("Accidentally attempting to override a method in"
-          + " RequestOptions. Add an 'override' value in the @GlideOption annotation"
-          + " if this is intentional. Offending method: "
-          + element.getEnclosingElement() + "#" + element);
-    } else if (!isOverridingRequestOptionsMethod && overrideType != OVERRIDE_NONE) {
-      throw new IllegalArgumentException("Requested to override an existing method in"
-          + " RequestOptions, but no such method was found. Offending method: "
-          + element.getEnclosingElement() + "#" + element);
-    }
-    String methodName = element.getSimpleName().toString();
-    MethodSpec.Builder builder = MethodSpec.methodBuilder(methodName)
-        .addModifiers(Modifier.PUBLIC)
-        .addJavadoc(processorUtil.generateSeeMethodJavadoc(element))
-        .returns(glideOptionsName);
-
-    // The 0th element is expected to be a RequestOptions object.
-    List<? extends VariableElement> parameters =
-        element.getParameters().subList(1, element.getParameters().size());
-
-    // Add the correct super() call.
-    if (overrideType == OVERRIDE_EXTEND) {
-      String callSuper = "super.$L(";
-      List<Object> args = new ArrayList<>();
-      args.add(element.getSimpleName().toString());
-      if (!parameters.isEmpty()) {
-        for (VariableElement variable : parameters) {
-          callSuper += "$L, ";
-          args.add(variable.getSimpleName().toString());
-        }
-        callSuper = callSuper.substring(0, callSuper.length() - 2);
-      }
-      callSuper += ")";
-
-      builder.addStatement(callSuper, args.toArray(new Object[0]))
-          .addJavadoc(processorUtil.generateSeeMethodJavadoc(
-              requestOptionsName, methodName, parameters))
-          .addAnnotation(Override.class);
-    }
-
-    for (VariableElement variable : parameters) {
-      builder.addParameter(getParameterSpec(variable));
-    }
-
-    // Adds: <AnnotatedClass>.<thisMethodName>(RequestOptions<?>, <arg1>, <arg2>, <argN>);
-    List<Object> args = new ArrayList<>();
-    String code = "$T.$L($L, ";
-    args.add(ClassName.get(element.getEnclosingElement().asType()));
-    args.add(element.getSimpleName().toString());
-    args.add("this");
-    if (!parameters.isEmpty()) {
-      for (VariableElement variable : parameters) {
-        code += "$L, ";
-        args.add(variable.getSimpleName().toString());
-      }
-    }
-    code = code.substring(0, code.length() - 2);
-    code += ")";
-    builder.addStatement(code, args.toArray(new Object[0]));
-
-    builder.addStatement("return this");
-
-    List<MethodAndStaticVar> result = new ArrayList<>();
-
-    result.add(new MethodAndStaticVar(builder.build()));
-    result.add(generateStaticMethodEquivalentForExtensionMethod(element));
-
-    return result;
-  }
-
   private List<MethodAndStaticVar> generateStaticMethodOverridesForRequestOptions() {
     List<ExecutableElement> staticMethodsThatReturnRequestOptions =
         processorUtil.findStaticMethodsReturning(requestOptionsType, requestOptionsType);
@@ -302,7 +228,7 @@ public String apply(VariableElement input) {
    * an existing method in RequestOptions.
    *
    * <p>The string names here just map between the static methods in
-   * {@link com.bumptech.glide.request.RequestOptions} and the instance methods they call.
+   * {@code com.bumptech.glide.request.RequestOptions} and the instance methods they call.
    */
   private static String getInstanceMethodNameFromStaticMethodName(String staticMethodName) {
     String equivalentInstanceMethodName;
@@ -337,25 +263,11 @@ private MethodAndStaticVar generateStaticMethodEquivalentForRequestOptionsStatic
     MethodSpec.Builder methodSpecBuilder =
         MethodSpec.methodBuilder(staticMethodName)
             .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
-        .addJavadoc(processorUtil.generateSeeMethodJavadoc(staticMethod))
-        .returns(glideOptionsName);
+            .addJavadoc(processorUtil.generateSeeMethodJavadoc(staticMethod))
+            .returns(glideOptionsName);
 
-    List<? extends VariableElement> parameters = staticMethod.getParameters();
-    String createNewOptionAndCall = "new $T().$N(";
-    if (!parameters.isEmpty()) {
-      for (VariableElement parameter : parameters) {
-        methodSpecBuilder.addParameter(getParameterSpec(parameter));
-        createNewOptionAndCall += parameter.getSimpleName().toString();
-        // use the Application Context to avoid memory leaks.
-        if (memoize && isAndroidContext(parameter)) {
-          createNewOptionAndCall += ".getApplicationContext()";
-        }
-        createNewOptionAndCall += ", ";
-      }
-      createNewOptionAndCall =
-          createNewOptionAndCall.substring(0, createNewOptionAndCall.length() - 2);
-    }
-    createNewOptionAndCall += ")";
+    StringBuilder createNewOptionAndCall = createNewOptionAndCall(memoize, methodSpecBuilder,
+        "new $T().$N(", ProcessorUtil.getParameters(staticMethod));
 
     FieldSpec requiredStaticField = null;
     if (memoize) {
@@ -365,7 +277,7 @@ private MethodAndStaticVar generateStaticMethodEquivalentForRequestOptionsStatic
       // }
 
       // Mix in an incrementing unique id to handle method overloading.
-      String staticVariableName = staticMethodName + nextStaticFieldUniqueId++;
+      String staticVariableName = staticMethodName + nextFieldId++;
       requiredStaticField = FieldSpec.builder(glideOptionsName, staticVariableName)
           .addModifiers(Modifier.PRIVATE, Modifier.STATIC)
           .build();
@@ -389,6 +301,10 @@ private MethodAndStaticVar generateStaticMethodEquivalentForRequestOptionsStatic
           TypeVariableName.get(typeParameterElement.getSimpleName().toString()));
     }
 
+    methodSpecBuilder
+        .addAnnotation(checkResult())
+        .addAnnotation(nonNull());
+
     return new MethodAndStaticVar(methodSpecBuilder.build(), requiredStaticField);
   }
 
@@ -399,12 +315,33 @@ private static boolean memoizeStaticMethodFromArguments(ExecutableElement static
         .equals("android.content.Context"));
   }
 
+  private StringBuilder createNewOptionAndCall(boolean memoize,
+      MethodSpec.Builder methodSpecBuilder,
+      String start, List<ParameterSpec> specs) {
+    StringBuilder createNewOptionAndCall = new StringBuilder(start);
+    if (!specs.isEmpty()) {
+      methodSpecBuilder.addParameters(specs);
+      for (ParameterSpec parameter : specs) {
+        createNewOptionAndCall.append(parameter.name);
+        // use the Application Context to avoid memory leaks.
+        if (memoize && isAndroidContext(parameter)) {
+          createNewOptionAndCall.append(".getApplicationContext()");
+        }
+        createNewOptionAndCall.append(", ");
+      }
+      createNewOptionAndCall = new StringBuilder(
+          createNewOptionAndCall.substring(0, createNewOptionAndCall.length() - 2));
+    }
+    createNewOptionAndCall.append(")");
+    return createNewOptionAndCall;
+  }
+
+  private boolean isAndroidContext(ParameterSpec parameter) {
+    return parameter.type.toString().equals("android.content.Context");
+  }
+
   private MethodAndStaticVar generateStaticMethodEquivalentForExtensionMethod(
       ExecutableElement instanceMethod) {
-    boolean skipStaticMethod = skipStaticMethod(instanceMethod);
-    if (skipStaticMethod) {
-      return new MethodAndStaticVar();
-    }
     String staticMethodName = getStaticMethodName(instanceMethod);
     String instanceMethodName = instanceMethod.getSimpleName().toString();
     if (Strings.isNullOrEmpty(staticMethodName)) {
@@ -416,9 +353,12 @@ private MethodAndStaticVar generateStaticMethodEquivalentForExtensionMethod(
     }
     boolean memoize = memoizeStaticMethodFromAnnotation(instanceMethod);
 
+    //noinspection ResultOfMethodCallIgnored
+    Preconditions.checkNotNull(staticMethodName);
     MethodSpec.Builder methodSpecBuilder = MethodSpec.methodBuilder(staticMethodName)
         .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
         .addJavadoc(processorUtil.generateSeeMethodJavadoc(instanceMethod))
+        .varargs(instanceMethod.isVarArgs())
         .returns(glideOptionsName);
 
     List<? extends VariableElement> parameters = instanceMethod.getParameters();
@@ -433,30 +373,18 @@ private MethodAndStaticVar generateStaticMethodEquivalentForExtensionMethod(
     // Remove is not supported.
     parameters = parameters.subList(1, parameters.size());
 
-    String createNewOptionAndCall = "new $T().$L(";
-    if (!parameters.isEmpty()) {
-      for (VariableElement parameter : parameters) {
-        methodSpecBuilder.addParameter(getParameterSpec(parameter));
-        createNewOptionAndCall += parameter.getSimpleName().toString();
-        // use the Application Context to avoid memory leaks.
-        if (memoize && isAndroidContext(parameter)) {
-          createNewOptionAndCall += ".getApplicationContext()";
-        }
-        createNewOptionAndCall += ", ";
-      }
-      createNewOptionAndCall =
-          createNewOptionAndCall.substring(0, createNewOptionAndCall.length() - 2);
-    }
-    createNewOptionAndCall += ")";
+    StringBuilder createNewOptionAndCall = createNewOptionAndCall(memoize, methodSpecBuilder,
+        "new $T().$L(", ProcessorUtil.getParameters(parameters));
 
     FieldSpec requiredStaticField = null;
     if (memoize) {
+      // Generates code that looks like:
       // if (GlideOptions.<methodName> == null) {
       //   GlideOptions.<methodName> = new GlideOptions().<methodName>().autoClone()
       // }
 
       // Mix in an incrementing unique id to handle method overloading.
-      String staticVariableName = staticMethodName + nextStaticFieldUniqueId++;
+      String staticVariableName = staticMethodName + nextFieldId++;
       requiredStaticField = FieldSpec.builder(glideOptionsName, staticVariableName)
           .addModifiers(Modifier.PRIVATE, Modifier.STATIC)
           .build();
@@ -468,6 +396,7 @@ private MethodAndStaticVar generateStaticMethodEquivalentForExtensionMethod(
           .endControlFlow()
           .addStatement("return $T.$N", glideOptionsName, staticVariableName);
     } else {
+      // Generates code that looks like:
       // return new GlideOptions().<methodName>()
       methodSpecBuilder.addStatement(
           "return " + createNewOptionAndCall, glideOptionsName, instanceMethodName);
@@ -479,58 +408,9 @@ private MethodAndStaticVar generateStaticMethodEquivalentForExtensionMethod(
           TypeVariableName.get(typeParameterElement.getSimpleName().toString()));
     }
 
-    return new MethodAndStaticVar(methodSpecBuilder.build(), requiredStaticField);
-  }
-
-  private boolean isAndroidContext(VariableElement variableElement) {
-    Element element = processingEnvironment.getTypeUtils().asElement(variableElement.asType());
-    return element.toString().equals("android.content.Context");
-  }
-
-  private boolean isMethodInRequestOptions(ExecutableElement toFind) {
-    // toFind is a method in a GlideExtension whose first argument is a BaseRequestOptions<?> type.
-    // Since we're comparing against methods in BaseRequestOptions itself, we need to drop that
-    // first type.
-    List<String> toFindParameterNames = getComparableParameterNames(toFind, true /*skipFirst*/);
-    String toFindSimpleName = toFind.getSimpleName().toString();
-    for (Element element : requestOptionsType.getEnclosedElements()) {
-      if (element.getKind() != ElementKind.METHOD) {
-        continue;
-      }
-      ExecutableElement inBase = (ExecutableElement) element;
-      if (toFindSimpleName.equals(inBase.getSimpleName().toString())) {
-        List<String> parameterNamesInBase =
-            getComparableParameterNames(inBase, false /*skipFirst*/);
-        if (parameterNamesInBase.equals(toFindParameterNames)) {
-          return true;
-        }
-      }
-    }
-    return false;
-  }
-
-  private static ParameterSpec getParameterSpec(VariableElement variable) {
-    return ParameterSpec.builder(
-        TypeName.get(variable.asType()), variable.getSimpleName().toString()).build();
-  }
-
-  private static List<String> getComparableParameterNames(
-      ExecutableElement element, boolean skipFirst) {
-    List<? extends VariableElement> parameters = element.getParameters();
-    if (skipFirst) {
-      parameters = parameters.subList(1, parameters.size());
-    }
-    List<String> result = new ArrayList<>(parameters.size());
-    for (VariableElement parameter : parameters) {
-      result.add(parameter.asType().toString());
-    }
-    return result;
-  }
+    methodSpecBuilder.addAnnotation(checkResult());
 
-  private static int getOverrideType(ExecutableElement element) {
-    GlideOption glideOption =
-        element.getAnnotation(GlideOption.class);
-    return glideOption.override();
+    return new MethodAndStaticVar(methodSpecBuilder.build(), requiredStaticField);
   }
 
   @Nullable
@@ -554,14 +434,8 @@ private static boolean skipStaticMethod(ExecutableElement element) {
   }
 
   private static final class MethodAndStaticVar {
-    @Nullable
-    final MethodSpec method;
-    @Nullable
-    final FieldSpec staticField;
-
-    MethodAndStaticVar() {
-      this(null /*method*/);
-    }
+    @Nullable final MethodSpec method;
+    @Nullable final FieldSpec staticField;
 
     MethodAndStaticVar(@Nullable MethodSpec method) {
       this(method, null /*staticField*/);
@@ -576,12 +450,12 @@ private static boolean skipStaticMethod(ExecutableElement element) {
   private static final class MethodSignature {
     private final TypeName returnType;
     private final List<TypeName> parameterTypes;
-    private final Set<Modifier> modifiers;
+    private final boolean isStatic;
     private final String name;
 
     MethodSignature(MethodSpec spec) {
       name = spec.name;
-      modifiers = spec.modifiers;
+      isStatic = spec.modifiers.contains(Modifier.STATIC);
       returnType = spec.returnType;
       parameterTypes =
           Lists.transform(spec.parameters, new Function<ParameterSpec, TypeName>() {
@@ -589,7 +463,6 @@ private static boolean skipStaticMethod(ExecutableElement element) {
             @Override
             public TypeName apply(ParameterSpec parameterSpec) {
               return parameterSpec.type;
-
             }
           });
     }
@@ -601,14 +474,14 @@ public boolean equals(Object o) {
         return name.equals(other.name)
             && returnType.equals(other.returnType)
             && parameterTypes.equals(other.parameterTypes)
-            && modifiers.equals(other.modifiers);
+            && isStatic == other.isStatic;
       }
       return false;
     }
 
     @Override
     public int hashCode() {
-      return Objects.hashCode(name, returnType, parameterTypes, modifiers);
+      return Objects.hashCode(name, returnType, parameterTypes, isStatic);
     }
   }
 }
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsOverrideGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsOverrideGenerator.java
new file mode 100644
index 000000000..065ac564f
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsOverrideGenerator.java
@@ -0,0 +1,105 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.RequestOptionsGenerator.BASE_REQUEST_OPTIONS_QUALIFIED_NAME;
+
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.TypeName;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Generates overrides for BaseRequestOptions methods so that subclasses' methods return the
+ * subclass type, not just BaseRequestOptions.
+ */
+final class RequestOptionsOverrideGenerator {
+
+  private final TypeElement baseRequestOptionsType;
+  private ProcessorUtil processorUtil;
+
+  RequestOptionsOverrideGenerator(
+      ProcessingEnvironment processingEnv, ProcessorUtil processorUtil) {
+
+    this.processorUtil = processorUtil;
+    baseRequestOptionsType = processingEnv.getElementUtils().getTypeElement(
+        BASE_REQUEST_OPTIONS_QUALIFIED_NAME);
+  }
+
+  List<MethodSpec> generateInstanceMethodOverridesForRequestOptions(TypeName typeToOverrideIn) {
+    return generateInstanceMethodOverridesForRequestOptions(
+        typeToOverrideIn, Collections.<String>emptySet());
+  }
+
+  List<MethodSpec> generateInstanceMethodOverridesForRequestOptions(
+      final TypeName typeToOverrideIn, final Set<String> excludedMethods) {
+    return
+        FluentIterable.from(
+            processorUtil.findInstanceMethodsReturning(
+                baseRequestOptionsType, baseRequestOptionsType))
+            .filter(new Predicate<ExecutableElement>() {
+              @Override
+              public boolean apply(ExecutableElement input) {
+                return !excludedMethods.contains(input.getSimpleName().toString());
+              }
+            })
+            .transform(
+        new Function<ExecutableElement, MethodSpec>() {
+          @Override
+          public MethodSpec apply(ExecutableElement input) {
+            return generateRequestOptionOverride(typeToOverrideIn, input);
+          }
+        })
+        .toList();
+  }
+
+  private MethodSpec generateRequestOptionOverride(
+      TypeName typeToOverrideIn, ExecutableElement methodToOverride) {
+    MethodSpec.Builder result =
+        ProcessorUtil.overriding(methodToOverride)
+            .returns(typeToOverrideIn);
+    result.addCode(
+        CodeBlock.builder()
+            .add(
+                "return ($T) super.$N(",
+                typeToOverrideIn,
+                methodToOverride.getSimpleName())
+            .add(FluentIterable.from(result.build().parameters)
+                .transform(new Function<ParameterSpec, String>() {
+                  @Override
+                  public String apply(ParameterSpec input) {
+                    return input.name;
+                  }
+                })
+                .join(Joiner.on(", ")))
+            .add(");\n")
+            .build());
+
+    if (methodToOverride.getSimpleName().toString().equals("transforms")) {
+      result
+          .addModifiers(Modifier.FINAL)
+          .addAnnotation(SafeVarargs.class)
+          .addAnnotation(
+              AnnotationSpec.builder(SuppressWarnings.class)
+                  .addMember("value", "$S", "varargs")
+                  .build());
+    }
+
+    for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {
+      result.addAnnotation(AnnotationSpec.get(mirror));
+    }
+
+    return result.build();
+  }
+}
diff --git a/annotation/compiler/test/.gitignore b/annotation/compiler/test/.gitignore
new file mode 100644
index 000000000..796b96d1c
--- /dev/null
+++ b/annotation/compiler/test/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/annotation/compiler/test/build.gradle b/annotation/compiler/test/build.gradle
new file mode 100644
index 000000000..e4573f90a
--- /dev/null
+++ b/annotation/compiler/test/build.gradle
@@ -0,0 +1,52 @@
+apply plugin: 'java'
+
+sourceSets {
+    test {
+        output.resourcesDir = "build/classes/java/test"
+    }
+}
+
+// This special test only submodule exists because adding the :glide dependency seems to break
+// the annotation processor dependency chain for the internal sample apps. It's also somewhat
+// easier to parse as a separate module given the existing complexity here and in the compiler
+dependencies {
+    // build.gradle file.
+    testImplementation project(':glide')
+    testImplementation project(':annotation:compiler')
+    testImplementation "junit:junit:${JUNIT_VERSION}"
+    testImplementation "com.squareup:javapoet:${JAVAPOET_VERSION}"
+    testImplementation "com.google.auto.service:auto-service:${AUTO_SERVICE_VERSION}"
+    testImplementation "com.google.code.findbugs:jsr305:${JSR_305_VERSION}"
+    // Using 0.10 of compile-testing is required for Android Studio to function, but not for the
+    // gradle build. Not yet clear why, but it looks like some kind of version conflict between
+    // javapoet, guava and/or truth.
+    //noinspection GradleDependency
+    testImplementation 'com.google.testing.compile:compile-testing:0.10'
+    // Use a stupidly old version of the Android classes jar. This works because we just need to get
+    // our generated classes to compile and our generated classes tend to use simple and stable
+    // Android APIs. If that changes, we'll need to find an alternative.
+    testImplementation 'com.google.android:android:4.1.1.4'
+    // Use a stupidly old version of v4 because it's a jar. The newer support v4 packages are aars,
+    // which we can't depend on in a standard Java test. Since our usage of v4 is pretty simple,
+    // hopefully this will continue to work going forward.
+    testImplementation 'com.google.android:support-v4:r6'
+    testImplementation "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}"
+}
+
+task regenerateTestResources {
+    group 'Verification'
+    description 'Regenerates all test resource files under annotation/compiler/test/src/test/resources that are compared against the current output to detect regressions'
+    tasks.withType(Test) {
+        systemProperties.put("com.bumptech.glide.annotation.compiler.test.regenerate.path", projectDir)
+    }
+    doFirst {
+        println("Regenerating test resources....")
+    }
+    doLast {
+        println("Finished regenerating test resources")
+    }
+}
+regenerateTestResources.finalizedBy(test)
+
+test.maxParallelForks = 2
+
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithExcludesTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithExcludesTest.java
new file mode 100644
index 000000000..323a4b151
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithExcludesTest.java
@@ -0,0 +1,101 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.appResource;
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyLibraryModule;
+import static com.bumptech.glide.annotation.compiler.test.Util.glide;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.ReferencedResource;
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests AppGlideModules that use the @Excludes annotation with a single excluded Module class.
+ */
+@RunWith(JUnit4.class)
+public class AppGlideModuleWithExcludesTest {
+  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
+      new RegenerateResourcesRule(getClass());
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                forResource("AppModuleWithExcludes.java"),
+                emptyLibraryModule());
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideOptions"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideOptions.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequest"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideRequest.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequests"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideRequests.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilationGeneratesExpectedGlideAppClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideApp"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideApp.java").getCharContent(true)));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedAppGlideModuleImpl"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(forResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedRequestManagerFactory"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(appResource("GeneratedRequestManagerFactory.java").getCharContent(true)));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithLibraryInPackageTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithLibraryInPackageTest.java
new file mode 100644
index 000000000..d8090cf2c
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithLibraryInPackageTest.java
@@ -0,0 +1,101 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.appResource;
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+import static com.bumptech.glide.annotation.compiler.test.Util.glide;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.ReferencedResource;
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests AppGlideModules that use the @Excludes annotation
+ * with a single excluded Module class in a strangely named subpackage.
+ */
+@RunWith(JUnit4.class)
+public class AppGlideModuleWithLibraryInPackageTest {
+  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
+      new RegenerateResourcesRule(getClass());
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                forResource("AppModuleWithLibraryInPackage.java"),
+                forResource("LibraryModuleInPackage.java"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideOptions"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideOptions.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequest"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideRequest.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequests"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideRequests.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilationGeneratesExpectedGlideAppClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideApp"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideApp.java").getCharContent(true)));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedAppGlideModuleImpl"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(forResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedRequestManagerFactory"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(appResource("GeneratedRequestManagerFactory.java").getCharContent(true)));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithMultipleExcludesTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithMultipleExcludesTest.java
new file mode 100644
index 000000000..86fb5b02b
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithMultipleExcludesTest.java
@@ -0,0 +1,101 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.appResource;
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+import static com.bumptech.glide.annotation.compiler.test.Util.glide;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.ReferencedResource;
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests AppGlideModules that use the @Excludes annotation with multiple excluded Module classes.
+ */
+@RunWith(JUnit4.class)
+public class AppGlideModuleWithMultipleExcludesTest {
+  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
+      new RegenerateResourcesRule(getClass());
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                forResource("AppModuleWithMultipleExcludes.java"),
+                forResource("EmptyLibraryModule1.java"),
+                forResource("EmptyLibraryModule2.java"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideOptions"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideOptions.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequest"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideRequest.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequests"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideRequests.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilationGeneratesExpectedGlideAppClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideApp"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideApp.java").getCharContent(true)));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedAppGlideModuleImpl"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(forResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedRequestManagerFactory"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(appResource("GeneratedRequestManagerFactory.java").getCharContent(true)));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppAndLibraryGlideModulesTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppAndLibraryGlideModulesTest.java
new file mode 100644
index 000000000..d9c18209d
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppAndLibraryGlideModulesTest.java
@@ -0,0 +1,122 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.annotation;
+import static com.bumptech.glide.annotation.compiler.test.Util.appResource;
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyLibraryModule;
+import static com.bumptech.glide.annotation.compiler.test.Util.glide;
+import static com.bumptech.glide.annotation.compiler.test.Util.libraryResource;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.ReferencedResource;
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests adding both an empty {@link com.bumptech.glide.module.AppGlideModule} and an empty
+ * {@link com.bumptech.glide.module.LibraryGlideModule} in a single project.
+ */
+@RunWith(JUnit4.class)
+public class EmptyAppAndLibraryGlideModulesTest {
+  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
+      new RegenerateResourcesRule(getClass());
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                emptyLibraryModule());
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_generatesAllExpectedFiles() {
+    Truth.assertThat(compilation.generatedSourceFiles()).hasSize(7);
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideOptions"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideOptions.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequest"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideRequest.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequests"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideRequests.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilationGeneratesExpectedGlideAppClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideApp"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideApp.java").getCharContent(true)));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedAppGlideModuleImpl"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(forResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedRequestManagerFactory"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(appResource("GeneratedRequestManagerFactory.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedIndexer() throws IOException {
+    String expectedClassName =
+        "GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule";
+    assertThat(compilation)
+        .generatedSourceFile(annotation(expectedClassName))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(libraryResource(expectedClassName + ".java").getCharContent(true)));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppGlideModuleTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppGlideModuleTest.java
new file mode 100644
index 000000000..8af5e23d9
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppGlideModuleTest.java
@@ -0,0 +1,99 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+import static com.bumptech.glide.annotation.compiler.test.Util.glide;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests adding a single {@link com.bumptech.glide.test.EmptyAppModule} in a project.
+ */
+@RunWith(JUnit4.class)
+public class EmptyAppGlideModuleTest {
+  private static final String MODULE_NAME = "EmptyAppModule.java";
+  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
+      new RegenerateResourcesRule(getClass());
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(forResource(MODULE_NAME));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_generatesAllExpectedFiles() {
+    Truth.assertThat(compilation.generatedSourceFiles()).hasSize(6);
+  }
+
+  @Test
+  public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideOptions"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource("GlideOptions.java").getCharContent(true)));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGlideRequestClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequest"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource("GlideRequest.java").getCharContent(true)));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequests"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource("GlideRequests.java").getCharContent(true)));
+  }
+
+  @Test
+  public void compilationGeneratesExpectedGlideAppClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideApp"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource("GlideApp.java").getCharContent(true)));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedAppGlideModuleImpl"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(forResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedRequestManagerFactory"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(forResource("GeneratedRequestManagerFactory.java").getCharContent(true)));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+}
+
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyLibraryGlideModuleTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyLibraryGlideModuleTest.java
new file mode 100644
index 000000000..f4776d227
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyLibraryGlideModuleTest.java
@@ -0,0 +1,57 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.annotation;
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests adding a single {@link com.bumptech.glide.module.LibraryGlideModule} in a project.
+ */
+@RunWith(JUnit4.class)
+public class EmptyLibraryGlideModuleTest {
+  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
+      new RegenerateResourcesRule(getClass());
+  private static final String MODULE_NAME = "EmptyLibraryModule.java";
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(forResource(MODULE_NAME));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_generatesAllExpectedFiles() {
+    Truth.assertThat(compilation.generatedSourceFiles()).hasSize(1);
+  }
+
+  @Test
+  public void compilation_generatesExpectedIndexer() throws IOException {
+    String expectedClassName =
+        "GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule";
+    assertThat(compilation)
+        .generatedSourceFile(annotation(expectedClassName))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource(expectedClassName + ".java").getCharContent(true)));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionOptionsTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionOptionsTest.java
new file mode 100644
index 000000000..a3c64b275
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionOptionsTest.java
@@ -0,0 +1,144 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.SubDirectory;
+import com.bumptech.glide.annotation.compiler.test.TestDescription;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Verifies only the output we expect to change based on the various configurations of GlideOptions.
+ */
+@RunWith(JUnit4.class)
+public class GlideExtensionOptionsTest {
+  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
+      new RegenerateResourcesRule(getClass());
+  @Rule public final TestDescription testDescription = new TestDescription();
+  private static final String EXTENSION_NAME = "Extension.java";
+
+  @Test
+  @SubDirectory("OverrideExtend")
+  public void compilation_withOverrideExtend_validOptions() throws IOException {
+    runTest(Subject.GlideOptions);
+  }
+
+  @Test
+  @SubDirectory("OverrideExtend")
+  public void compilation_withOverrideExtend_validRequest() throws IOException {
+    runTest(Subject.GlideRequest);
+  }
+
+  @Test
+  @SubDirectory("OverrideExtendMultipleArguments")
+  public void compilation_withOverrideReplace_andMultipleArguments_validOptions()
+      throws IOException {
+    runTest(Subject.GlideOptions);
+  }
+
+  @Test
+  @SubDirectory("OverrideExtendMultipleArguments")
+  public void compilation_withOverrideReplace_andMultipleArguments_validRequest()
+      throws IOException {
+    runTest(Subject.GlideRequest);
+  }
+
+  @Test
+  @SubDirectory("OverrideReplace")
+  public void compilation_withOverrideReplace_validOptions() throws IOException {
+    runTest(Subject.GlideOptions);
+  }
+
+  @Test
+  @SubDirectory("OverrideReplace")
+  public void compilation_withOverrideReplace_validRequest() throws IOException {
+    runTest(Subject.GlideRequest);
+  }
+
+  @Test
+  @SubDirectory("StaticMethodName")
+  public void compilation_withStaticMethodName_validOptions() throws IOException {
+    runTest(Subject.GlideOptions);
+  }
+
+  @Test
+  @SubDirectory("StaticMethodName")
+  public void compilation_withStaticMethodName_validRequest() throws IOException {
+    runTest(Subject.GlideRequest);
+  }
+
+  @Test
+  @SubDirectory("MemoizeStaticMethod")
+  public void compilation_withMemoizeStaticMethod_validOptions() throws IOException {
+    runTest(Subject.GlideOptions);
+  }
+
+  @Test
+  @SubDirectory("MemoizeStaticMethod")
+  public void compilation_withMemoizeStaticMethod_validRequest() throws IOException {
+    runTest(Subject.GlideRequest);
+  }
+
+  @Test
+  @SubDirectory("SkipStaticMethod")
+  public void compilation_withSkipStaticMethod_validOptions() throws IOException {
+    runTest(Subject.GlideOptions);
+  }
+
+  @Test
+  @SubDirectory("SkipStaticMethod")
+  public void compilation_withSkipStaticMethod_validRequest() throws IOException {
+    runTest(Subject.GlideRequest);
+  }
+
+  private enum Subject {
+    GlideOptions,
+    GlideRequest;
+
+    String file() {
+      return name() + ".java";
+    }
+  }
+
+  private void runTest(Subject subject) throws IOException {
+    String subDir = getSubDirectoryName();
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                extension(subDir));
+    assertThat(compilation).succeededWithoutWarnings();
+
+    assertThat(compilation)
+        .generatedSourceFile(subpackage(subject.name()))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource(subDir, subject.file()).getCharContent(true)));
+  }
+
+  private String getSubDirectoryName() {
+    return testDescription
+        .getDescription()
+        .getAnnotation(SubDirectory.class)
+        .value();
+  }
+
+  private JavaFileObject extension(String subdir) {
+    return forResource(subdir, EXTENSION_NAME);
+  }
+
+  private JavaFileObject forResource(String subdir, String name) {
+    return Util.forResource(getClass().getSimpleName(), subdir + "/" + name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionWithOptionTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionWithOptionTest.java
new file mode 100644
index 000000000..a67555ea8
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionWithOptionTest.java
@@ -0,0 +1,107 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.appResource;
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
+import static com.bumptech.glide.annotation.compiler.test.Util.glide;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.ReferencedResource;
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Verifies the output of the processor with a simple single extension option in the new
+ * option style where extension methods always return values.
+ */
+@RunWith(JUnit4.class)
+public class GlideExtensionWithOptionTest {
+  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
+      new RegenerateResourcesRule(getClass());
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                forResource("ExtensionWithOption.java"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_generatesAllExpectedFiles() {
+    Truth.assertThat(compilation.generatedSourceFiles()).hasSize(7);
+  }
+
+  @Test
+  public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideOptions"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource("GlideOptions.java").getCharContent(true)));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGlideRequestClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequest"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource("GlideRequest.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequests"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideRequests.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilationGeneratesExpectedGlideAppClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideApp"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideApp.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedAppGlideModuleImpl"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(appResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedRequestManagerFactory"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(appResource("GeneratedRequestManagerFactory.java").getCharContent(true)));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionWithTypeTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionWithTypeTest.java
new file mode 100644
index 000000000..af4a4b747
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionWithTypeTest.java
@@ -0,0 +1,106 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.appResource;
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
+import static com.bumptech.glide.annotation.compiler.test.Util.glide;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.ReferencedResource;
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Verifies the output of the processor with a simple single extension type.
+ */
+@RunWith(JUnit4.class)
+public class GlideExtensionWithTypeTest {
+  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
+      new RegenerateResourcesRule(getClass());
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                forResource("ExtensionWithType.java"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_generatesAllExpectedFiles() {
+    Truth.assertThat(compilation.generatedSourceFiles()).hasSize(7);
+  }
+
+  @Test
+  public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideOptions"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource("GlideOptions.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequest"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideRequest.java").getCharContent(true)));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequests"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource("GlideRequests.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilationGeneratesExpectedGlideAppClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideApp"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideApp.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedAppGlideModuleImpl"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(appResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedRequestManagerFactory"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(appResource("GeneratedRequestManagerFactory.java").getCharContent(true)));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidAppGlideModuleWithExcludesTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidAppGlideModuleWithExcludesTest.java
new file mode 100644
index 000000000..a54f7565e
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidAppGlideModuleWithExcludesTest.java
@@ -0,0 +1,82 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+import static org.junit.Assert.assertThrows;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import org.junit.Test;
+import org.junit.function.ThrowingRunnable;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests AppGlideModules with invalid usages of the @Excludes annotation.
+ */
+// Ignore warnings since most methods use assertThrows
+@SuppressWarnings("ResultOfMethodCallIgnored")
+@RunWith(JUnit4.class)
+public class InvalidAppGlideModuleWithExcludesTest {
+  @Test
+  public void compilation_withMissingExcludedModuleClass_throws() {
+    assertThrows(
+        RuntimeException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() throws Throwable {
+            javac()
+                .withProcessors(new GlideAnnotationProcessor())
+                .compile(
+                    JavaFileObjects.forSourceLines(
+                        "AppModuleWithExcludes",
+                        "package com.bumptech.glide.test;",
+                        "import com.bumptech.glide.annotation.Excludes;",
+                        "import com.bumptech.glide.annotation.GlideModule;",
+                        "import com.bumptech.glide.module.AppGlideModule;",
+                        "import com.bumptech.glide.test.EmptyLibraryModule;",
+                        "@GlideModule",
+                        "@Excludes(EmptyLibraryModule.class)",
+                        "public final class AppModuleWithExcludes extends AppGlideModule {}"));
+          }
+        });
+  }
+
+  @Test
+  public void compilation_withEmptyExcludes_fails() {
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                JavaFileObjects.forSourceLines(
+                    "AppModuleWithExcludes",
+                    "package com.bumptech.glide.test;",
+                    "import com.bumptech.glide.annotation.Excludes;",
+                    "import com.bumptech.glide.annotation.GlideModule;",
+                    "import com.bumptech.glide.module.AppGlideModule;",
+                    "import com.bumptech.glide.test.EmptyLibraryModule;",
+                    "@GlideModule",
+                    "@Excludes",
+                    "public final class AppModuleWithExcludes extends AppGlideModule {}"));
+    assertThat(compilation).failed();
+  }
+
+  @Test
+  public void compilation_withNonGlideModule_throws() {
+     Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                JavaFileObjects.forSourceLines(
+                    "AppModuleWithExcludes",
+                    "package com.bumptech.glide.test;",
+                    "import com.bumptech.glide.annotation.Excludes;",
+                    "import com.bumptech.glide.annotation.GlideModule;",
+                    "import com.bumptech.glide.module.AppGlideModule;",
+                    "import com.bumptech.glide.test.EmptyLibraryModule;",
+                    "@GlideModule",
+                    "@Excludes(Object.class)",
+                    "public final class AppModuleWithExcludes extends AppGlideModule {}"));
+    assertThat(compilation).failed();
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideExtensionTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideExtensionTest.java
new file mode 100644
index 000000000..2641be120
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideExtensionTest.java
@@ -0,0 +1,128 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+import static org.junit.Assert.fail;
+
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Checks assertions on {@link com.bumptech.glide.annotation.GlideExtension}s themselves.
+ */
+// Avoid warnings when asserting on exceptions.
+@SuppressWarnings("ResultOfMethodCallIgnored")
+@RunWith(JUnit4.class)
+public class InvalidGlideExtensionTest {
+  @Test
+  public void compilation_withPublicConstructor_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "PublicConstructor",
+                  "package com.bumptech.glide.test;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "@GlideExtension",
+                  "public class PublicConstructor { }"));
+      fail("Failed to throw expected exception");
+    } catch (RuntimeException e) {
+      Throwable cause = e.getCause();
+      Truth.assertThat(cause.getMessage()).contains("non-private constructor");
+      Truth.assertThat(cause.getMessage()).contains("PublicConstructor");
+
+    }
+  }
+
+  @Test
+  public void compilation_withPackagePrivateExtension_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "PackagePrivateExtension",
+                  "package com.bumptech.glide.test;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "@GlideExtension",
+                  "class PackagePrivateExtension {",
+                  "  private PackagePrivateExtension() {}",
+                  "}"));
+      fail("Failed to throw expected exception");
+    } catch (RuntimeException e) {
+      Throwable cause = e.getCause();
+      Truth.assertThat(cause.getMessage()).contains("must be public");
+      Truth.assertThat(cause.getMessage()).contains("PackagePrivateExtension");
+    }
+  }
+
+  @Test
+  public void compilation_withConstructorWithParameters_throws() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "ConstructorParametersExtension",
+                  "package com.bumptech.glide.test;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "@GlideExtension",
+                  "public class ConstructorParametersExtension {",
+                  "  private ConstructorParametersExtension(int failParam) {}",
+                  "  public void doSomething() {}",
+                  "}"));
+      fail("Failed to get expected exception");
+    } catch (RuntimeException e) {
+      Throwable cause = e.getCause();
+      Truth.assertThat(cause.getMessage()).contains("parameters in the constructor");
+      Truth.assertThat(cause.getMessage()).contains("ConstructorParametersExtension");
+    }
+  }
+
+  @Test
+  public void compilation_withNonStaticMethod_succeeds() {
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                JavaFileObjects.forSourceLines(
+                    "Extension",
+                    "package com.bumptech.glide.test;",
+                    "import com.bumptech.glide.annotation.GlideExtension;",
+                    "@GlideExtension",
+                    "public class Extension {",
+                    "  private Extension() {}",
+                    "  public void doSomething() {}",
+                    "}"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_withStaticMethod_succeeds() {
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                JavaFileObjects.forSourceLines(
+                    "Extension",
+                    "package com.bumptech.glide.test;",
+                    "import com.bumptech.glide.annotation.GlideExtension;",
+                    "@GlideExtension",
+                    "public class Extension {",
+                    "  private Extension() {}",
+                    "  public static void doSomething() {}",
+                    "}"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideOptionsExtensionTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideOptionsExtensionTest.java
new file mode 100644
index 000000000..e1516bdcb
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideOptionsExtensionTest.java
@@ -0,0 +1,386 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+import static org.junit.Assert.assertThrows;
+import static org.junit.Assert.fail;
+
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import org.junit.Test;
+import org.junit.function.ThrowingRunnable;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Checks assertions on {@link com.bumptech.glide.annotation.GlideExtension}s for methods annotated
+ * with {@link com.bumptech.glide.annotation.GlideOption}.
+ */
+// Ignore warnings since most methods use assertThrows.
+@SuppressWarnings("ResultOfMethodCallIgnored")
+@RunWith(JUnit4.class)
+public class InvalidGlideOptionsExtensionTest {
+  @Test
+  public void compilation_withAnnotatedNonStaticMethod_fails() {
+    assertThrows(
+        RuntimeException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() {
+            javac()
+                .withProcessors(new GlideAnnotationProcessor())
+                .compile(
+                    emptyAppModule(),
+                    JavaFileObjects.forSourceLines(
+                        "Extension",
+                        "package com.bumptech.glide.test;",
+                        "import com.bumptech.glide.annotation.GlideExtension;",
+                        "import com.bumptech.glide.annotation.GlideOption;",
+                        "@GlideExtension",
+                        "public class Extension {",
+                        "  private Extension() {}",
+                        "  @GlideOption",
+                        "  public void doSomething() {}",
+                        "}"));
+          }
+        });
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_withRequestOptionsArgInWrongOrder_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "NonRequestOptionsFirstArgExtension",
+                  "package com.bumptech.glide.test;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "import com.bumptech.glide.annotation.GlideOption;",
+                  "import com.bumptech.glide.request.BaseRequestOptions;",
+                  "@GlideExtension",
+                  "public class NonRequestOptionsFirstArgExtension{",
+                  "  private NonRequestOptionsFirstArgExtension() {}",
+                  "  @GlideOption",
+                  "  public static BaseRequestOptions<?> doSomething(",
+                  "      Object arg1, BaseRequestOptions<?> options) {",
+                  "    return options;",
+                  "  }",
+                  "}"));
+      fail();
+    } catch (RuntimeException e) {
+      String message = e.getCause().getMessage();
+      Truth.assertThat(message).contains("BaseRequestOptions<?> object as their first parameter");
+      Truth.assertThat(message).contains("Object");
+      Truth.assertThat(message).contains("NonRequestOptionsFirstArgExtension");
+    }
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_withRequestOptionsArg_succeeds() {
+    Compilation compilation = javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideOption;",
+                "import com.bumptech.glide.request.BaseRequestOptions;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @GlideOption",
+                "  public static BaseRequestOptions<?> doSomething(",
+                "      BaseRequestOptions<?> options) {",
+                "    return options;",
+                "  }",
+                "}"));
+    assertThat(compilation).succeeded();
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_withRequestOptionsArgAndOtherArg_succeeds() {
+    Compilation compilation = javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideOption;",
+                "import com.bumptech.glide.request.BaseRequestOptions;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @GlideOption",
+                "  public static BaseRequestOptions<?> doSomething(",
+                "      BaseRequestOptions<?> options, Object arg2) {",
+                "    return options;",
+                "  }",
+                "}"));
+    assertThat(compilation).succeeded();
+  }
+
+  @Test
+  public void compilation_overridingOptionWithoutAnnotationType_fails() {
+    assertThrows(
+        RuntimeException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() {
+            javac()
+                .withProcessors(new GlideAnnotationProcessor())
+                .compile(
+                emptyAppModule(),
+                JavaFileObjects.forSourceLines(
+                    "Extension",
+                    "package com.bumptech.glide.test;",
+                    "import com.bumptech.glide.annotation.GlideExtension;",
+                    "import com.bumptech.glide.annotation.GlideOption;",
+                    "import com.bumptech.glide.request.BaseRequestOptions;",
+                    "@GlideExtension",
+                    "public class Extension {",
+                    "  private Extension() {}",
+                    "  @GlideOption",
+                    "  public static BaseRequestOptions<?> centerCrop(",
+                    "      BaseRequestOptions<?> options) {",
+                    "    return options;",
+                    "  }",
+                    "}"));
+
+          }
+        });
+  }
+
+  @Test
+  public void compilation_withOverrideExtend_butNotOverridingMethod_fails() {
+    assertThrows(
+        RuntimeException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() {
+            javac()
+                .withProcessors(new GlideAnnotationProcessor())
+                .compile(
+                    emptyAppModule(),
+                    JavaFileObjects.forSourceLines(
+                        "Extension",
+                        "package com.bumptech.glide.test;",
+                        "import com.bumptech.glide.annotation.GlideExtension;",
+                        "import com.bumptech.glide.annotation.GlideOption;",
+                        "import com.bumptech.glide.request.BaseRequestOptions;",
+                        "@GlideExtension",
+                        "public class Extension {",
+                        "  private Extension() {}",
+                        "  @GlideOption(override = GlideOption.OVERRIDE_EXTEND)",
+                        "  public static BaseRequestOptions<?> something(",
+                        "      BaseRequestOptions<?> options) {",
+                        "    return options;",
+                        "  }",
+                        "}"));
+          }
+        });
+  }
+
+  @Test
+  public void compilation_withOverrideExtend_andOverridingMethod_succeeds() {
+    Compilation compilation = javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideOption;",
+                "import com.bumptech.glide.request.BaseRequestOptions;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @GlideOption(override = GlideOption.OVERRIDE_EXTEND)",
+                "  public static BaseRequestOptions<?> centerCrop(",
+                "      BaseRequestOptions<?> options) {",
+                "    return options;",
+                "  }",
+                "}"));
+    assertThat(compilation).succeeded();
+  }
+
+  @Test
+  public void compilation_withOverrideReplace_butNotOverridingMethod_fails() {
+    assertThrows(
+        RuntimeException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() {
+            javac()
+                .withProcessors(new GlideAnnotationProcessor())
+                .compile(
+                    emptyAppModule(),
+                    JavaFileObjects.forSourceLines(
+                        "Extension",
+                        "package com.bumptech.glide.test;",
+                        "import com.bumptech.glide.annotation.GlideExtension;",
+                        "import com.bumptech.glide.annotation.GlideOption;",
+                        "import com.bumptech.glide.request.BaseRequestOptions;",
+                        "@GlideExtension",
+                        "public class Extension {",
+                        "  private Extension() {}",
+                        "  @GlideOption(override = GlideOption.OVERRIDE_REPLACE)",
+                        "  public static BaseRequestOptions<?> something(",
+                        "      BaseRequestOptions<?> options) {",
+                        "    return options;",
+                        "  }",
+                        "}"));
+          }
+        });
+  }
+
+  @Test
+  public void compilation_withOverrideReplace_andOverridingMethod_succeeds() {
+    Compilation compilation = javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideOption;",
+                "import com.bumptech.glide.request.BaseRequestOptions;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @GlideOption(override = GlideOption.OVERRIDE_REPLACE)",
+                "  public static BaseRequestOptions<?> centerCrop(",
+                "      BaseRequestOptions<?> options) {",
+                "    return options;",
+                "  }",
+                "}"));
+    assertThat(compilation).succeeded();
+  }
+
+  @Test
+  public void compilation_withRequestOptionsReturnValue_succeeds() {
+     Compilation compilation = javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import android.support.annotation.NonNull;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideOption;",
+                "import com.bumptech.glide.request.BaseRequestOptions;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @NonNull",
+                "  @GlideOption",
+                "  public static BaseRequestOptions<?> doSomething(",
+                "      BaseRequestOptions<?> options) {",
+                "    return options;",
+                "  }",
+                "}"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_withNonRequestOptionsReturnValue_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "WrongReturnTypeExtension",
+                  "package com.bumptech.glide.test;",
+                  "import android.support.annotation.NonNull;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "import com.bumptech.glide.annotation.GlideOption;",
+                  "import com.bumptech.glide.request.BaseRequestOptions;",
+                  "@GlideExtension",
+                  "public class WrongReturnTypeExtension {",
+                  "  private WrongReturnTypeExtension() {}",
+                  "  @NonNull",
+                  "  @GlideOption",
+                  "  public static Object doSomething(BaseRequestOptions<?> options) {",
+                  "    return options;",
+                  "  }",
+                  "}"));
+      fail();
+    } catch (RuntimeException e) {
+      String message = e.getCause().getMessage();
+      Truth.assertThat(message)
+          .contains("@GlideOption methods should return a BaseRequestOptions<?> object");
+      Truth.assertThat(message).contains("Object");
+      Truth.assertThat(message).contains("WrongReturnTypeExtension");
+    }
+  }
+
+  @Test
+  public void compilation_withMissingNonNullAnnotation_warns() {
+    Compilation compilation = javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideOption;",
+                "import com.bumptech.glide.request.BaseRequestOptions;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @GlideOption",
+                "  public static BaseRequestOptions<?> doSomething(",
+                "      BaseRequestOptions<?> options) {",
+                "    return options;",
+                "  }",
+                "}"));
+    assertThat(compilation).succeeded();
+    assertThat(compilation).hadWarningCount(1);
+    assertThat(compilation).hadWarningContaining("android.support.annotation.NonNull");
+    assertThat(compilation).hadWarningContaining("com.bumptech.glide.test.Extension#doSomething");
+  }
+
+  @Test
+  public void compilation_withNoOptionParameters_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "MissingRequestOptionsExtension",
+                  "package com.bumptech.glide.test;",
+                  "import android.support.annotation.NonNull;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "import com.bumptech.glide.annotation.GlideOption;",
+                  "import com.bumptech.glide.request.BaseRequestOptions;",
+                  "@GlideExtension",
+                  "public class MissingRequestOptionsExtension {",
+                  "  private MissingRequestOptionsExtension() {}",
+                  "  @NonNull",
+                  "  @GlideOption",
+                  "  public static BaseRequestOptions<?> doSomething() {",
+                  "    return options;",
+                  "  }",
+                  "}"));
+      fail();
+    } catch (RuntimeException e) {
+      String message = e.getCause().getMessage();
+      Truth.assertThat(message).contains("BaseRequestOptions<?> object as their first parameter");
+      Truth.assertThat(message).contains("doSomething");
+      Truth.assertThat(message).contains("MissingRequestOptionsExtension");
+    }
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideTypeExtensionTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideTypeExtensionTest.java
new file mode 100644
index 000000000..0a4c91c82
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideTypeExtensionTest.java
@@ -0,0 +1,412 @@
+package com.bumptech.glide.annotation.compiler;
+
+
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+import static org.junit.Assert.assertThrows;
+import static org.junit.Assert.fail;
+
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import org.junit.Test;
+import org.junit.function.ThrowingRunnable;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Checks assertions on {@link com.bumptech.glide.annotation.GlideExtension}s for methods annotated
+ * with {@link com.bumptech.glide.annotation.GlideType}.
+ */
+// Ignore warnings since most methods use assertThrows.
+@SuppressWarnings("ResultOfMethodCallIgnored")
+@RunWith(JUnit4.class)
+public class InvalidGlideTypeExtensionTest {
+  @Test
+  public void compilation_withAnnotatedNonStaticMethod_fails() {
+    assertThrows(
+        "@GlideType methods must be static",
+        RuntimeException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() {
+            javac()
+                .withProcessors(new GlideAnnotationProcessor())
+                .compile(
+                    emptyAppModule(),
+                    JavaFileObjects.forSourceLines(
+                        "Extension",
+                        "package com.bumptech.glide.test;",
+                        "import android.support.annotation.NonNull;",
+                        "import com.bumptech.glide.annotation.GlideExtension;",
+                        "import com.bumptech.glide.annotation.GlideType;",
+                        "@GlideExtension",
+                        "public class Extension {",
+                        "  private Extension() {}",
+                        "  @NonNull",
+                        "  @GlideType(Number.class)",
+                        "  public RequestBuilder<Number> doSomething(",
+                        "      RequestBuilder<Number> builder) {",
+                        "    return builder;",
+                        "  }",
+                        "}"));
+          }
+        });
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_withoutRequestBuilderArg_fails() {
+    assertThrows(
+        "@GlideType methods must take a RequestBuilder object as their first and only"
+            + " parameter, but given multiple for:"
+            + " com.bumptech.glide.test.Extension#doSomething()",
+        RuntimeException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() {
+            javac()
+                .withProcessors(new GlideAnnotationProcessor())
+                .compile(
+                    emptyAppModule(),
+                    JavaFileObjects.forSourceLines(
+                        "Extension",
+                        "package com.bumptech.glide.test;",
+                        "import com.bumptech.glide.annotation.GlideExtension;",
+                        "import com.bumptech.glide.annotation.GlideType;",
+                        "@GlideExtension",
+                        "public class Extension {",
+                        "  private Extension() {}",
+                        "  @GlideType(Number.class)",
+                        "  public static RequestBuilder<Number> doSomething() {",
+                        "    return null;",
+                        "  }",
+                        "}"));
+          }
+        });
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_withRequestBuilderArg_succeeds() {
+    Compilation compilation = javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import android.support.annotation.NonNull;",
+                "import com.bumptech.glide.RequestBuilder;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideType;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @NonNull",
+                "  @GlideType(Number.class)",
+                "  public static RequestBuilder<Number> type(RequestBuilder<Number> builder) {",
+                "    return builder;",
+                "  }",
+                "}"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_withNonRequestBuilderArg_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "WrongParameterTypeExtension",
+                  "package com.bumptech.glide.test;",
+                  "import android.support.annotation.NonNull;",
+                  "import com.bumptech.glide.RequestBuilder;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "import com.bumptech.glide.annotation.GlideType;",
+                  "@GlideExtension",
+                  "public class WrongParameterTypeExtension {",
+                  "  private WrongParameterTypeExtension() {}",
+                  "  @NonNull",
+                  "  @GlideType(Number.class)",
+                  "  public static RequestBuilder<Number> type(Object arg) {",
+                  "    return null;",
+                  "  }",
+                  "}"));
+    } catch (RuntimeException e) {
+      String message = e.getCause().getMessage();
+      Truth.assertThat(message).contains("RequestBuilder object as their first and only parameter");
+      Truth.assertThat(message).contains("Object");
+      Truth.assertThat(message).contains("WrongParameterTypeExtension");
+    }
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_withRequestBuilderArgAndOtherArg_fails() {
+    assertThrows(
+        "@GlideType methods must take a RequestBuilder object as their first and only"
+            + " parameter, but given multiple for:"
+            + " com.bumptech.glide.test.Extension#type("
+            + "com.bumptech.glide.RequestBuilder<java.lang.Number>,"
+            + "java.lang.Object)",
+        RuntimeException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() {
+            javac()
+                .withProcessors(new GlideAnnotationProcessor())
+                .compile(
+                    emptyAppModule(),
+                    JavaFileObjects.forSourceLines(
+                        "Extension",
+                        "package com.bumptech.glide.test;",
+                        "import android.support.annotation.NonNull;",
+                        "import com.bumptech.glide.RequestBuilder;",
+                        "import com.bumptech.glide.annotation.GlideExtension;",
+                        "import com.bumptech.glide.annotation.GlideType;",
+                        "@GlideExtension",
+                        "public class Extension {",
+                        "  private Extension() {}",
+                        "  @NonNull",
+                        "  @GlideType(Number.class)",
+                        "  public static RequestBuilder<Number> type(",
+                        "      RequestBuilder<Number> builder, Object arg2) {",
+                        "    return builder;",
+                        "  }",
+                        "}"));
+          }
+        });
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_overridingExistingType_fails() {
+    final Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                JavaFileObjects.forSourceLines(
+                    "Extension",
+                    "package com.bumptech.glide.test;",
+                    "import android.graphics.drawable.Drawable;",
+                    "import android.support.annotation.NonNull;",
+                    "import com.bumptech.glide.RequestBuilder;",
+                    "import com.bumptech.glide.annotation.GlideExtension;",
+                    "import com.bumptech.glide.annotation.GlideType;",
+                    "@GlideExtension",
+                    "public class Extension {",
+                    "  private Extension() {}",
+                    "  @NonNull",
+                    "  @GlideType(Drawable.class)",
+                    "  public static RequestBuilder<Drawable> asDrawable(",
+                    "      RequestBuilder<Drawable> builder) {",
+                    "    return builder;",
+                    "  }",
+                    "}"));
+
+    assertThrows(
+        "error: method asDrawable() is already defined in class"
+            + " com.bumptech.glide.test.GlideRequests",
+        RuntimeException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() {
+            compilation.generatedSourceFile(subpackage("GlideRequests"));
+          }
+        });
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_returningRequestBuilder_succeeds() {
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                JavaFileObjects.forSourceLines(
+                    "Extension",
+                    "package com.bumptech.glide.test;",
+                    "import android.support.annotation.NonNull;",
+                    "import com.bumptech.glide.RequestBuilder;",
+                    "import com.bumptech.glide.annotation.GlideExtension;",
+                    "import com.bumptech.glide.annotation.GlideType;",
+                    "@GlideExtension",
+                    "public class Extension {",
+                    "  private Extension() {}",
+                    "  @NonNull",
+                    "  @GlideType(Number.class)",
+                    "  public static RequestBuilder<Number> asNumber(",
+                    "      RequestBuilder<Number> builder) {",
+                    "    return builder;",
+                    "  }",
+                    "}"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_returningNonRequestBuilder_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "WrongReturnTypeExtension",
+                  "package com.bumptech.glide.test;",
+                  "import android.support.annotation.NonNull;",
+                  "import com.bumptech.glide.RequestBuilder;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "import com.bumptech.glide.annotation.GlideType;",
+                  "@GlideExtension",
+                  "public class WrongReturnTypeExtension {",
+                  "  private WrongReturnTypeExtension() {}",
+                  "  @NonNull",
+                  "  @GlideType(Number.class)",
+                  "  public static Object asNumber(",
+                  "      RequestBuilder<Number> builder) {",
+                  "    return new Object();",
+                  "  }",
+                  "}"));
+      fail();
+    } catch (RuntimeException e) {
+      String message = e.getCause().getMessage();
+      Truth.assertThat(message).contains("@GlideType methods should return a RequestBuilder");
+      Truth.assertThat(message).contains("Number");
+      Truth.assertThat(message).contains("WrongReturnTypeExtension");
+    }
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_returningBuilderWithIncorrectType_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "WrongBuilderTypeExtension",
+                  "package com.bumptech.glide.test;",
+                  "import android.support.annotation.NonNull;",
+                  "import com.bumptech.glide.RequestBuilder;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "import com.bumptech.glide.annotation.GlideType;",
+                  "@GlideExtension",
+                  "public class WrongBuilderTypeExtension {",
+                  "  private WrongBuilderTypeExtension() {}",
+                  "  @NonNull",
+                  "  @GlideType(Number.class)",
+                  "  public static RequestBuilder<Object> asNumber(",
+                  "      RequestBuilder<Object> builder) {",
+                  "    return builder;",
+                  "  }",
+                  "}"));
+      fail();
+    } catch (RuntimeException e) {
+      String message = e.getCause().getMessage();
+      Truth.assertThat(message)
+          .contains("@GlideType methods should return a RequestBuilder<java.lang.Number>");
+      Truth.assertThat(message)
+          .contains("WrongBuilderTypeExtension");
+    }
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_returningBuilder_andMultipleParams_fails() {
+    assertThrows(
+        "@GlideType methods must take a RequestBuilder object as their first and only parameter,"
+            + " but given multiple for:"
+            + " com.bumptech.glide.test.Extension#asNumber("
+            + "com.bumptech.glide.RequestBuilder<java.lang.Number>,java.lang.Object)",
+        RuntimeException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() {
+            javac()
+                .withProcessors(new GlideAnnotationProcessor())
+                .compile(
+                    emptyAppModule(),
+                    JavaFileObjects.forSourceLines(
+                        "Extension",
+                        "package com.bumptech.glide.test;",
+                        "import android.support.annotation.NonNull;",
+                        "import com.bumptech.glide.RequestBuilder;",
+                        "import com.bumptech.glide.annotation.GlideExtension;",
+                        "import com.bumptech.glide.annotation.GlideType;",
+                        "@GlideExtension",
+                        "public class Extension {",
+                        "  private Extension() {}",
+                        "  @NonNull",
+                        "  @GlideType(Number.class)",
+                        "  public static RequestBuilder<Number> asNumber(",
+                        "      RequestBuilder<Number> builder, Object arg1) {",
+                        "    return builder;",
+                        "  }",
+                        "}"));
+          }
+        });
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_returningBuilder_nonBuilderParam_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "IncorrectParameterExtension",
+                  "package com.bumptech.glide.test;",
+                  "import android.support.annotation.NonNull;",
+                  "import com.bumptech.glide.RequestBuilder;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "import com.bumptech.glide.annotation.GlideType;",
+                  "@GlideExtension",
+                  "public class IncorrectParameterExtension {",
+                  "  private IncorrectParameterExtension() {}",
+                  "  @NonNull",
+                  "  @GlideType(Number.class)",
+                  "  public static RequestBuilder<Number> asNumber(",
+                  "      Object arg) {",
+                  "    return null;",
+                  "  }",
+                  "}"));
+      fail();
+    } catch (RuntimeException e) {
+      String message = e.getCause().getMessage();
+      Truth.assertThat(message).contains("@GlideType methods must take a RequestBuilder object"
+          + " as their first and only parameter");
+      Truth.assertThat(message).contains("Object");
+      Truth.assertThat(message).contains("IncorrectParameterExtension");
+    }
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_returningRequestBuilder_missingNonNull_warns() {
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                JavaFileObjects.forSourceLines(
+                    "Extension",
+                    "package com.bumptech.glide.test;",
+                    "import com.bumptech.glide.RequestBuilder;",
+                    "import com.bumptech.glide.annotation.GlideExtension;",
+                    "import com.bumptech.glide.annotation.GlideType;",
+                    "@GlideExtension",
+                    "public class Extension {",
+                    "  private Extension() {}",
+                    "  @GlideType(Number.class)",
+                    "  public static RequestBuilder<Number> asNumber(",
+                    "      RequestBuilder<Number> builder) {",
+                    "    return builder;",
+                    "  }",
+                    "}"));
+    assertThat(compilation).succeeded();
+    assertThat(compilation).hadWarningCount(1);
+    assertThat(compilation).hadWarningContaining("android.support.annotation.NonNull");
+    assertThat(compilation).hadWarningContaining("com.bumptech.glide.test.Extension#asNumber");
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/MultipleAppGlideModuleTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/MultipleAppGlideModuleTest.java
new file mode 100644
index 000000000..a80590d83
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/MultipleAppGlideModuleTest.java
@@ -0,0 +1,63 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+import static org.junit.Assert.assertThrows;
+
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.testing.compile.Compilation;
+import javax.tools.JavaFileObject;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.function.ThrowingRunnable;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Ensures that adding more than one {@link com.bumptech.glide.module.AppGlideModule} to a project
+ * will fail.
+ */
+@RunWith(JUnit4.class)
+public class MultipleAppGlideModuleTest {
+  private static final String FIRST_MODULE = "EmptyAppModule1.java";
+  private static final String SECOND_MODULE = "EmptyAppModule2.java";
+  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
+      new RegenerateResourcesRule(getClass());
+
+  // Throws.
+  @SuppressWarnings("ResultOfMethodCallIgnored")
+  @Test
+  public void compilation_withTwoAppModules_fails() {
+    assertThrows(
+        RuntimeException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() throws Throwable {
+            javac()
+                .withProcessors(new GlideAnnotationProcessor())
+                .compile(forResource(FIRST_MODULE), forResource(SECOND_MODULE));
+          }
+        });
+  }
+
+  @Test
+  public void compilation_withFirstModuleOnly_succeeds() {
+    Compilation compilation = javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(forResource(FIRST_MODULE));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_withSecondModuleOnly_succeeds() {
+    Compilation compilation = javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(forResource(SECOND_MODULE));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/MultipleEmptyLibraryGlideModuleTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/MultipleEmptyLibraryGlideModuleTest.java
new file mode 100644
index 000000000..b576c08a7
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/MultipleEmptyLibraryGlideModuleTest.java
@@ -0,0 +1,59 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.annotation;
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests adding multiple {@link com.bumptech.glide.module.LibraryGlideModule}s in a project.
+ */
+@RunWith(JUnit4.class)
+public class MultipleEmptyLibraryGlideModuleTest {
+  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
+      new RegenerateResourcesRule(getClass());
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                forResource("EmptyLibraryModule1.java"),
+                forResource("EmptyLibraryModule2.java"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_generatesAllExpectedFiles() {
+    Truth.assertThat(compilation.generatedSourceFiles()).hasSize(1);
+  }
+
+  @Test
+  public void compilation_generatesExpectedIndexerForModules() throws IOException {
+    String expectedClassName =
+        "GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule1_com_bumptech_glide"
+            + "_test_EmptyLibraryModule2";
+    assertThat(compilation)
+        .generatedSourceFile(annotation(expectedClassName))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource(expectedClassName + ".java").getCharContent(true)));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/ReferencedResource.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/ReferencedResource.java
new file mode 100644
index 000000000..b7194411d
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/ReferencedResource.java
@@ -0,0 +1,24 @@
+package com.bumptech.glide.annotation.compiler.test;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Indicates that the method in question is referencing a test resource that it doesn't "own" and
+ * should not attempt to regenerate.
+ *
+ * <p>Used by {@link RegenerateResourcesRule} to ensure that if we are regenerating resources,
+ * we're only regenerating them for a single class and only for the single class that has the
+ * correct name and directory sequence so that we update the correct file.
+ *
+ * <p>Ideally this wouldn't be necessary. It would be great if we could find a way to go from the
+ * test failure more directly to the actual path of the resource used. Right now we're basically
+ * guessing based on this annotation, the class name of the test class, and any values from
+ * {@link SubDirectory}. Without this annotation, we'd end up writing files that were never used.
+ */
+@Target(ElementType.METHOD)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface ReferencedResource {
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/RegenerateResourcesRule.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/RegenerateResourcesRule.java
new file mode 100644
index 000000000..66f48c767
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/RegenerateResourcesRule.java
@@ -0,0 +1,101 @@
+package com.bumptech.glide.annotation.compiler.test;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+
+import android.support.annotation.NonNull;
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.Writer;
+import org.junit.ComparisonFailure;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+/**
+ * Regenerates test resources for annotation compiler tests when the
+ * {@link Util#REGENERATE_TEST_RESOURCES_PROPERTY_NAME} property is set to the directory containing
+ * the project.
+ *
+ * <p>This can easily be used via gradle by running:
+ * {@code
+ *  ./gradlew :annotation:compiler:test:regenerateTestResources
+ * }
+ *
+ * <p>Our regenerate task will set the appropriate environment variables that will allow the logic
+ * here to succeed. When running the tests normally, this class will do nothing.
+ */
+public final class RegenerateResourcesRule implements TestRule {
+
+  private final Class<?> testClass;
+
+  public RegenerateResourcesRule(Class<?> testClass) {
+    this.testClass = testClass;
+  }
+
+  @Override
+  public Statement apply(final Statement base, final Description description) {
+    return new Statement() {
+      @Override
+      public void evaluate() throws Throwable {
+        try {
+          base.evaluate();
+        } catch (ComparisonFailure e) {
+          String projectRoot = Util.getProjectRootIfRegeneratingTestResources();
+          if (projectRoot == null || description.getAnnotation(ReferencedResource.class) != null) {
+            throw e;
+          }
+          updateResourceFile(e, projectRoot, description);
+        }
+      }
+    };
+  }
+
+  private void updateResourceFile(
+      ComparisonFailure e, @NonNull String projectDirectory, Description description) {
+    String testClassName = testClass.getSimpleName();
+    String testFileName = parseFileNameFromMessage(e);
+    String testDirectory = projectDirectory + "/src/test/resources/" + testClassName;
+    String subDirectorySegment =
+        description.getAnnotation(SubDirectory.class) != null
+            ? description.getAnnotation(SubDirectory.class).value() + "/"
+            : "";
+
+    File expectedDirectory = new File(testDirectory + "/" + subDirectorySegment);
+    if (!expectedDirectory.exists() && !expectedDirectory.mkdirs()) {
+      throw new IllegalStateException(
+          "Failed to generate expected directory: " + expectedDirectory);
+    }
+    if (!expectedDirectory.isDirectory()) {
+      throw new IllegalStateException(
+          "Expected a directory, but found a file: " + expectedDirectory);
+    }
+
+    File expectedFile = new File(expectedDirectory, testFileName);
+    Writer writer = null;
+    try {
+      writer = new FileWriter(expectedFile);
+      writer.write(asUnixChars(e.getActual()).toString());
+      writer.close();
+    } catch (IOException e1) {
+      throw new RuntimeException("Failed to regenerate test file", e1);
+    } finally {
+      if (writer != null) {
+        try {
+          writer.close();
+        } catch (IOException exception) {
+          // Ignore.
+        }
+      }
+    }
+  }
+
+  // Parses </SOURCE_OUTPUT/com/bumptech/glide/test/GlideOptions.java> to GlideOptions.java.
+  private static String parseFileNameFromMessage(ComparisonFailure e) {
+    String message = e.getMessage();
+    int firstGreaterThanIndex = message.indexOf('>');
+    String substring = message.substring(0, firstGreaterThanIndex);
+    int lastForwardSlashIndex = substring.lastIndexOf('/');
+    return substring.substring(lastForwardSlashIndex + 1, substring.length());
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/SubDirectory.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/SubDirectory.java
new file mode 100644
index 000000000..c0023498a
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/SubDirectory.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.annotation.compiler.test;
+
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Indicates the subdirectory for a particular test that contains the test resource(s) used for the
+ * method.
+ *
+ * <p>Used both by tests to extract the correct subdirectory and by the
+ * {@link RegenerateResourcesRule} for the same purpose.
+ */
+@Target(ElementType.METHOD)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface SubDirectory {
+  String value();
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/TestDescription.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/TestDescription.java
new file mode 100644
index 000000000..2b4c7c72c
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/TestDescription.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.annotation.compiler.test;
+
+import org.junit.rules.TestWatcher;
+import org.junit.runner.Description;
+
+/**
+ * Exposes the {@link Description} for the current test, similar to
+ * {@link org.junit.rules.TestName}.
+ */
+public final class TestDescription extends TestWatcher {
+  private Description description;
+  @Override
+  protected void starting(Description description) {
+    this.description = description;
+  }
+
+  public Description getDescription() {
+    return description;
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/Util.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/Util.java
new file mode 100644
index 000000000..64c4f9f08
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/Util.java
@@ -0,0 +1,87 @@
+package com.bumptech.glide.annotation.compiler.test;
+
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+
+/** Test utilities. */
+public final class Util {
+  private static final String REGENERATE_TEST_RESOURCES_PROPERTY_NAME =
+      "com.bumptech.glide.annotation.compiler.test.regenerate.path";
+  private static final String GLIDE_PACKAGE_NAME = "com.bumptech.glide";
+  private static final String SUB_PACKAGE_NAME = qualified(GLIDE_PACKAGE_NAME, "test");
+  private static final String ANNOTATION_PACKAGE_NAME = "com.bumptech.glide.annotation.compiler";
+  private static final String DEFAULT_APP_DIR_NAME = "EmptyAppGlideModuleTest";
+  private static final String DEFAULT_LIBRARY_DIR_NAME = "EmptyLibraryGlideModuleTest";
+  /**
+   * Hardcoded file separator to workaround {@code JavaFileObjects.forResource(...)} defaulting to
+   * the unix one.
+   */
+  private static final String FILE_SEPARATOR = "/";
+  private static final String LINE_SEPARATOR = "\n";
+
+  private Util() {
+    // Utility class.
+  }
+
+  /**
+   * Returns the {@code String} from a system property that is expected to contain the project
+   * directory for the module containing these tests or {@code null} if we're not currently
+   * attempting to regenerate test resources.
+   */
+  static String getProjectRootIfRegeneratingTestResources() {
+    return System.getProperty(REGENERATE_TEST_RESOURCES_PROPERTY_NAME);
+  }
+
+  public static JavaFileObject emptyAppModule() {
+    return appResource("EmptyAppModule.java");
+  }
+
+  public static JavaFileObject emptyLibraryModule() {
+    return libraryResource("EmptyLibraryModule.java");
+  }
+
+  public static JavaFileObject appResource(String className) {
+    return forResource(DEFAULT_APP_DIR_NAME, className);
+  }
+
+  public static JavaFileObject libraryResource(String className) {
+    return forResource(DEFAULT_LIBRARY_DIR_NAME, className);
+  }
+
+  public static JavaFileObject forResource(String directoryName, String name) {
+    try {
+      return JavaFileObjects.forResource(directoryName + FILE_SEPARATOR + name);
+    } catch (IllegalArgumentException e) {
+      // IllegalArgumentException will be thrown if the resource is missing. If we're trying to
+      // generate test resources for a new test, we want to avoid this exception because it does not
+      // contain any expected output that we can write to a file. By returning an empty file, we
+      // avoid the exception and get the output from our comparison tests that we can then write
+      // out.
+      // If we're not regenerating test resources, we should throw the normal exception.
+      if (getProjectRootIfRegeneratingTestResources() != null) {
+        return JavaFileObjects.forSourceString("com.bumptech.test.empty", "");
+      }
+      throw e;
+    }
+  }
+
+  public static String annotation(String className) {
+    return qualified(ANNOTATION_PACKAGE_NAME, className);
+  }
+
+  public static String subpackage(String className) {
+    return qualified(SUB_PACKAGE_NAME, className);
+  }
+
+  public static String glide(String className) {
+    return qualified(GLIDE_PACKAGE_NAME, className);
+  }
+
+  public static CharSequence asUnixChars(CharSequence chars) {
+    return chars.toString().replace(System.lineSeparator(), LINE_SEPARATOR);
+  }
+
+  private static String qualified(String packageName, String className) {
+    return packageName + '.' + className;
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/AppModuleWithExcludes.java b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/AppModuleWithExcludes.java
new file mode 100644
index 000000000..f935829d6
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/AppModuleWithExcludes.java
@@ -0,0 +1,9 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.Excludes;
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
+
+@GlideModule
+@Excludes(EmptyLibraryModule.class)
+public final class AppModuleWithExcludes extends AppGlideModule {}
\ No newline at end of file
diff --git a/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java
new file mode 100644
index 000000000..ecb3b4b05
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java
@@ -0,0 +1,54 @@
+package com.bumptech.glide;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.util.Log;
+import com.bumptech.glide.test.AppModuleWithExcludes;
+import java.lang.Class;
+import java.lang.Override;
+import java.lang.SuppressWarnings;
+import java.util.HashSet;
+import java.util.Set;
+
+@SuppressWarnings("deprecation")
+final class GeneratedAppGlideModuleImpl extends GeneratedAppGlideModule {
+  private final AppModuleWithExcludes appGlideModule;
+
+  GeneratedAppGlideModuleImpl() {
+    appGlideModule = new AppModuleWithExcludes();
+    if (Log.isLoggable("Glide", Log.DEBUG)) {
+      Log.d("Glide", "Discovered AppGlideModule from annotation: com.bumptech.glide.test.AppModuleWithExcludes");
+      Log.d("Glide", "AppGlideModule excludes LibraryGlideModule from annotation: com.bumptech.glide.test.EmptyLibraryModule");
+    }
+  }
+
+  @Override
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
+    appGlideModule.applyOptions(context, builder);
+  }
+
+  @Override
+  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry) {
+    appGlideModule.registerComponents(context, glide, registry);
+  }
+
+  @Override
+  public boolean isManifestParsingEnabled() {
+    return appGlideModule.isManifestParsingEnabled();
+  }
+
+  @Override
+  @NonNull
+  public Set<Class<?>> getExcludedModuleClasses() {
+    Set<Class<?>> excludedClasses = new HashSet<Class<?>>();
+    excludedClasses.add(com.bumptech.glide.test.EmptyLibraryModule.class);
+    return excludedClasses;
+  }
+
+  @Override
+  @NonNull
+  GeneratedRequestManagerFactory getRequestManagerFactory() {
+    return new GeneratedRequestManagerFactory();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/AppModuleWithLibraryInPackage.java b/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/AppModuleWithLibraryInPackage.java
new file mode 100644
index 000000000..78dd983d2
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/AppModuleWithLibraryInPackage.java
@@ -0,0 +1,10 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.Excludes;
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
+import com.bumptech.glide.test._package.LibraryModuleInPackage;
+
+@GlideModule
+@Excludes(LibraryModuleInPackage.class)
+public final class AppModuleWithLibraryInPackage extends AppGlideModule {}
diff --git a/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/GeneratedAppGlideModuleImpl.java b/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/GeneratedAppGlideModuleImpl.java
new file mode 100644
index 000000000..7ab08a74a
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/GeneratedAppGlideModuleImpl.java
@@ -0,0 +1,54 @@
+package com.bumptech.glide;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.util.Log;
+import com.bumptech.glide.test.AppModuleWithLibraryInPackage;
+import java.lang.Class;
+import java.lang.Override;
+import java.lang.SuppressWarnings;
+import java.util.HashSet;
+import java.util.Set;
+
+@SuppressWarnings("deprecation")
+final class GeneratedAppGlideModuleImpl extends GeneratedAppGlideModule {
+  private final AppModuleWithLibraryInPackage appGlideModule;
+
+  GeneratedAppGlideModuleImpl() {
+    appGlideModule = new AppModuleWithLibraryInPackage();
+    if (Log.isLoggable("Glide", Log.DEBUG)) {
+      Log.d("Glide", "Discovered AppGlideModule from annotation: com.bumptech.glide.test.AppModuleWithLibraryInPackage");
+      Log.d("Glide", "AppGlideModule excludes LibraryGlideModule from annotation: com.bumptech.glide.test._package.LibraryModuleInPackage");
+    }
+  }
+
+  @Override
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
+    appGlideModule.applyOptions(context, builder);
+  }
+
+  @Override
+  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry) {
+    appGlideModule.registerComponents(context, glide, registry);
+  }
+
+  @Override
+  public boolean isManifestParsingEnabled() {
+    return appGlideModule.isManifestParsingEnabled();
+  }
+
+  @Override
+  @NonNull
+  public Set<Class<?>> getExcludedModuleClasses() {
+    Set<Class<?>> excludedClasses = new HashSet<Class<?>>();
+    excludedClasses.add(com.bumptech.glide.test._package.LibraryModuleInPackage.class);
+    return excludedClasses;
+  }
+
+  @Override
+  @NonNull
+  GeneratedRequestManagerFactory getRequestManagerFactory() {
+    return new GeneratedRequestManagerFactory();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/LibraryModuleInPackage.java b/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/LibraryModuleInPackage.java
new file mode 100644
index 000000000..88f305b24
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/LibraryModuleInPackage.java
@@ -0,0 +1,8 @@
+// _ in the name is important otherwise everything would work
+package com.bumptech.glide.test._package;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.LibraryGlideModule;
+
+@GlideModule
+public final class LibraryModuleInPackage extends LibraryGlideModule {}
diff --git a/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/AppModuleWithMultipleExcludes.java b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/AppModuleWithMultipleExcludes.java
new file mode 100644
index 000000000..94600d8e4
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/AppModuleWithMultipleExcludes.java
@@ -0,0 +1,9 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.Excludes;
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
+
+@GlideModule
+@Excludes({EmptyLibraryModule1.class, EmptyLibraryModule2.class})
+public final class AppModuleWithMultipleExcludes extends AppGlideModule {}
\ No newline at end of file
diff --git a/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/EmptyLibraryModule1.java b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/EmptyLibraryModule1.java
new file mode 100644
index 000000000..236008a91
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/EmptyLibraryModule1.java
@@ -0,0 +1,7 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.LibraryGlideModule;
+
+@GlideModule
+public final class EmptyLibraryModule1 extends LibraryGlideModule {}
diff --git a/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/EmptyLibraryModule2.java b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/EmptyLibraryModule2.java
new file mode 100644
index 000000000..8a43eb292
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/EmptyLibraryModule2.java
@@ -0,0 +1,7 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.LibraryGlideModule;
+
+@GlideModule
+public final class EmptyLibraryModule2 extends LibraryGlideModule {}
diff --git a/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/GeneratedAppGlideModuleImpl.java b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/GeneratedAppGlideModuleImpl.java
new file mode 100644
index 000000000..af059c6b1
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/GeneratedAppGlideModuleImpl.java
@@ -0,0 +1,56 @@
+package com.bumptech.glide;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.util.Log;
+import com.bumptech.glide.test.AppModuleWithMultipleExcludes;
+import java.lang.Class;
+import java.lang.Override;
+import java.lang.SuppressWarnings;
+import java.util.HashSet;
+import java.util.Set;
+
+@SuppressWarnings("deprecation")
+final class GeneratedAppGlideModuleImpl extends GeneratedAppGlideModule {
+  private final AppModuleWithMultipleExcludes appGlideModule;
+
+  GeneratedAppGlideModuleImpl() {
+    appGlideModule = new AppModuleWithMultipleExcludes();
+    if (Log.isLoggable("Glide", Log.DEBUG)) {
+      Log.d("Glide", "Discovered AppGlideModule from annotation: com.bumptech.glide.test.AppModuleWithMultipleExcludes");
+      Log.d("Glide", "AppGlideModule excludes LibraryGlideModule from annotation: com.bumptech.glide.test.EmptyLibraryModule1");
+      Log.d("Glide", "AppGlideModule excludes LibraryGlideModule from annotation: com.bumptech.glide.test.EmptyLibraryModule2");
+    }
+  }
+
+  @Override
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
+    appGlideModule.applyOptions(context, builder);
+  }
+
+  @Override
+  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry) {
+    appGlideModule.registerComponents(context, glide, registry);
+  }
+
+  @Override
+  public boolean isManifestParsingEnabled() {
+    return appGlideModule.isManifestParsingEnabled();
+  }
+
+  @Override
+  @NonNull
+  public Set<Class<?>> getExcludedModuleClasses() {
+    Set<Class<?>> excludedClasses = new HashSet<Class<?>>();
+    excludedClasses.add(com.bumptech.glide.test.EmptyLibraryModule1.class);
+    excludedClasses.add(com.bumptech.glide.test.EmptyLibraryModule2.class);
+    return excludedClasses;
+  }
+
+  @Override
+  @NonNull
+  GeneratedRequestManagerFactory getRequestManagerFactory() {
+    return new GeneratedRequestManagerFactory();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppAndLibraryGlideModulesTest/GeneratedAppGlideModuleImpl.java b/annotation/compiler/test/src/test/resources/EmptyAppAndLibraryGlideModulesTest/GeneratedAppGlideModuleImpl.java
new file mode 100644
index 000000000..6e307e0ff
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyAppAndLibraryGlideModulesTest/GeneratedAppGlideModuleImpl.java
@@ -0,0 +1,54 @@
+package com.bumptech.glide;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.util.Log;
+import com.bumptech.glide.test.EmptyAppModule;
+import com.bumptech.glide.test.EmptyLibraryModule;
+import java.lang.Class;
+import java.lang.Override;
+import java.lang.SuppressWarnings;
+import java.util.Collections;
+import java.util.Set;
+
+@SuppressWarnings("deprecation")
+final class GeneratedAppGlideModuleImpl extends GeneratedAppGlideModule {
+  private final EmptyAppModule appGlideModule;
+
+  GeneratedAppGlideModuleImpl() {
+    appGlideModule = new EmptyAppModule();
+    if (Log.isLoggable("Glide", Log.DEBUG)) {
+      Log.d("Glide", "Discovered AppGlideModule from annotation: com.bumptech.glide.test.EmptyAppModule");
+      Log.d("Glide", "Discovered LibraryGlideModule from annotation: com.bumptech.glide.test.EmptyLibraryModule");
+    }
+  }
+
+  @Override
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
+    appGlideModule.applyOptions(context, builder);
+  }
+
+  @Override
+  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry) {
+    new EmptyLibraryModule().registerComponents(context, glide, registry);
+    appGlideModule.registerComponents(context, glide, registry);
+  }
+
+  @Override
+  public boolean isManifestParsingEnabled() {
+    return appGlideModule.isManifestParsingEnabled();
+  }
+
+  @Override
+  @NonNull
+  public Set<Class<?>> getExcludedModuleClasses() {
+    return Collections.emptySet();
+  }
+
+  @Override
+  @NonNull
+  GeneratedRequestManagerFactory getRequestManagerFactory() {
+    return new GeneratedRequestManagerFactory();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/EmptyAppModule.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/EmptyAppModule.java
new file mode 100644
index 000000000..203f9df63
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/EmptyAppModule.java
@@ -0,0 +1,7 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
+
+@GlideModule
+public final class EmptyAppModule extends AppGlideModule {}
\ No newline at end of file
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedAppGlideModuleImpl.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedAppGlideModuleImpl.java
new file mode 100644
index 000000000..f960738d9
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedAppGlideModuleImpl.java
@@ -0,0 +1,51 @@
+package com.bumptech.glide;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.util.Log;
+import com.bumptech.glide.test.EmptyAppModule;
+import java.lang.Class;
+import java.lang.Override;
+import java.lang.SuppressWarnings;
+import java.util.Collections;
+import java.util.Set;
+
+@SuppressWarnings("deprecation")
+final class GeneratedAppGlideModuleImpl extends GeneratedAppGlideModule {
+  private final EmptyAppModule appGlideModule;
+
+  GeneratedAppGlideModuleImpl() {
+    appGlideModule = new EmptyAppModule();
+    if (Log.isLoggable("Glide", Log.DEBUG)) {
+      Log.d("Glide", "Discovered AppGlideModule from annotation: com.bumptech.glide.test.EmptyAppModule");
+    }
+  }
+
+  @Override
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
+    appGlideModule.applyOptions(context, builder);
+  }
+
+  @Override
+  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry) {
+    appGlideModule.registerComponents(context, glide, registry);
+  }
+
+  @Override
+  public boolean isManifestParsingEnabled() {
+    return appGlideModule.isManifestParsingEnabled();
+  }
+
+  @Override
+  @NonNull
+  public Set<Class<?>> getExcludedModuleClasses() {
+    return Collections.emptySet();
+  }
+
+  @Override
+  @NonNull
+  GeneratedRequestManagerFactory getRequestManagerFactory() {
+    return new GeneratedRequestManagerFactory();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedRequestManagerFactory.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedRequestManagerFactory.java
new file mode 100644
index 000000000..2a442b0a5
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedRequestManagerFactory.java
@@ -0,0 +1,21 @@
+package com.bumptech.glide;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import com.bumptech.glide.manager.Lifecycle;
+import com.bumptech.glide.manager.RequestManagerRetriever;
+import com.bumptech.glide.manager.RequestManagerTreeNode;
+import com.bumptech.glide.test.GlideRequests;
+import java.lang.Override;
+
+/**
+ * Generated code, do not modify
+ */
+final class GeneratedRequestManagerFactory implements RequestManagerRetriever.RequestManagerFactory {
+  @Override
+  @NonNull
+  public RequestManager build(@NonNull Glide glide, @NonNull Lifecycle lifecycle,
+      @NonNull RequestManagerTreeNode treeNode, @NonNull Context context) {
+    return new GlideRequests(glide, lifecycle, treeNode, context);
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideApp.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideApp.java
new file mode 100644
index 000000000..881e98c1b
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideApp.java
@@ -0,0 +1,131 @@
+package com.bumptech.glide.test;
+
+import android.annotation.SuppressLint;
+import android.app.Activity;
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.FragmentActivity;
+import android.view.View;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
+import java.io.File;
+import java.lang.Deprecated;
+import java.lang.String;
+
+/**
+ * The entry point for interacting with Glide for Applications
+ *
+ * <p>Includes all generated APIs from all
+ * {@link com.bumptech.glide.annotation.GlideExtension}s in source and dependent libraries.
+ *
+ * <p>This class is generated and should not be modified
+ * @see Glide
+ */
+public final class GlideApp {
+  private GlideApp() {
+  }
+
+  /**
+   * @see Glide#getPhotoCacheDir(Context)
+   */
+  @Nullable
+  public static File getPhotoCacheDir(@NonNull Context context) {
+    return Glide.getPhotoCacheDir(context);
+  }
+
+  /**
+   * @see Glide#getPhotoCacheDir(Context, String)
+   */
+  @Nullable
+  public static File getPhotoCacheDir(@NonNull Context context, @NonNull String string) {
+    return Glide.getPhotoCacheDir(context, string);
+  }
+
+  /**
+   * @see Glide#get(Context)
+   */
+  @NonNull
+  public static Glide get(@NonNull Context context) {
+    return Glide.get(context);
+  }
+
+  /**
+   * @see Glide#init(Glide)
+   */
+  @Deprecated
+  @VisibleForTesting
+  @SuppressLint("VisibleForTests")
+  public static void init(Glide glide) {
+    Glide.init(glide);
+  }
+
+  /**
+   * @see Glide#init(Context, GlideBuilder)
+   */
+  @VisibleForTesting
+  @SuppressLint("VisibleForTests")
+  public static void init(@NonNull Context context, @NonNull GlideBuilder builder) {
+    Glide.init(context, builder);
+  }
+
+  /**
+   * @see Glide#tearDown()
+   */
+  @VisibleForTesting
+  @SuppressLint("VisibleForTests")
+  public static void tearDown() {
+    Glide.tearDown();
+  }
+
+  /**
+   * @see Glide#with(Context)
+   */
+  @NonNull
+  public static GlideRequests with(@NonNull Context context) {
+    return (GlideRequests) Glide.with(context);
+  }
+
+  /**
+   * @see Glide#with(Activity)
+   */
+  @NonNull
+  public static GlideRequests with(@NonNull Activity activity) {
+    return (GlideRequests) Glide.with(activity);
+  }
+
+  /**
+   * @see Glide#with(FragmentActivity)
+   */
+  @NonNull
+  public static GlideRequests with(@NonNull FragmentActivity activity) {
+    return (GlideRequests) Glide.with(activity);
+  }
+
+  /**
+   * @see Glide#with(Fragment)
+   */
+  @NonNull
+  public static GlideRequests with(@NonNull Fragment fragment) {
+    return (GlideRequests) Glide.with(fragment);
+  }
+
+  /**
+   * @see Glide#with(Fragment)
+   */
+  @Deprecated
+  @NonNull
+  public static GlideRequests with(@NonNull android.app.Fragment fragment) {
+    return (GlideRequests) Glide.with(fragment);
+  }
+
+  /**
+   * @see Glide#with(View)
+   */
+  @NonNull
+  public static GlideRequests with(@NonNull View view) {
+    return (GlideRequests) Glide.with(view);
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideOptions.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideOptions.java
new file mode 100644
index 000000000..b2cb067dc
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideOptions.java
@@ -0,0 +1,620 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return new GlideOptions().sizeMultiplier(value);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy strategy) {
+    return new GlideOptions().diskCacheStrategy(strategy);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority priority) {
+    return new GlideOptions().priority(priority);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable drawable) {
+    return new GlideOptions().placeholder(drawable);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int id) {
+    return new GlideOptions().placeholder(id);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable drawable) {
+    return new GlideOptions().error(drawable);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int id) {
+    return new GlideOptions().error(id);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int value0,
+      @IntRange(from = 0) int value1) {
+    return new GlideOptions().override(value0, value1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int value) {
+    return new GlideOptions().override(value);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key key) {
+    return new GlideOptions().signature(key);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> transformation) {
+    return new GlideOptions().transform(transformation);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> option, @NonNull T t) {
+    return new GlideOptions().set(option, t);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> clazz) {
+    return new GlideOptions().decode(clazz);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat format) {
+    return new GlideOptions().format(format);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long value) {
+    return new GlideOptions().frame(value);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy strategy) {
+    return new GlideOptions().downsample(strategy);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int value) {
+    return new GlideOptions().timeout(value);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int value) {
+    return new GlideOptions().encodeQuality(value);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat format) {
+    return new GlideOptions().encodeFormat(format);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return (GlideOptions) super.sizeMultiplier(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    return (GlideOptions) super.diskCacheStrategy(strategy);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions priority(@NonNull Priority priority) {
+    return (GlideOptions) super.priority(priority);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions placeholder(@Nullable Drawable drawable) {
+    return (GlideOptions) super.placeholder(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions placeholder(@DrawableRes int id) {
+    return (GlideOptions) super.placeholder(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fallback(@Nullable Drawable drawable) {
+    return (GlideOptions) super.fallback(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fallback(@DrawableRes int id) {
+    return (GlideOptions) super.fallback(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions error(@Nullable Drawable drawable) {
+    return (GlideOptions) super.error(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions error(@DrawableRes int id) {
+    return (GlideOptions) super.error(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions theme(@Nullable Resources.Theme theme) {
+    return (GlideOptions) super.theme(theme);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions signature(@NonNull Key key) {
+    return (GlideOptions) super.signature(key);
+  }
+
+  @Override
+  @CheckResult
+  public GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions set(@NonNull Option<Y> option, @NonNull Y y) {
+    return (GlideOptions) super.set(option, y);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions decode(@NonNull Class<?> clazz) {
+    return (GlideOptions) super.decode(clazz);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return (GlideOptions) super.encodeFormat(format);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int value) {
+    return (GlideOptions) super.encodeQuality(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions frame(@IntRange(from = 0) long value) {
+    return (GlideOptions) super.frame(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions format(@NonNull DecodeFormat format) {
+    return (GlideOptions) super.format(format);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions downsample(@NonNull DownsampleStrategy strategy) {
+    return (GlideOptions) super.downsample(strategy);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions timeout(@IntRange(from = 0) int value) {
+    return (GlideOptions) super.timeout(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions transform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideOptions) super.transform(transformation);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideOptions) super.transforms(transformations);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideOptions) super.optionalTransform(transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions optionalTransform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideOptions) super.optionalTransform(clazz, transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions transform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideOptions) super.transform(clazz, transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions apply(@NonNull BaseRequestOptions<?> options) {
+    return (GlideOptions) super.apply(options);
+  }
+
+  @Override
+  @NonNull
+  public GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequest.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequest.java
new file mode 100644
index 000000000..440c153b7
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequest.java
@@ -0,0 +1,572 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.RequestListener;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link com.bumptech.glide.request.RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see com.bumptech.glide.request.RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return (GlideRequest<TranscodeType>) super.sizeMultiplier(value);
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.useAnimationPool(flag);
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.onlyRetrieveFromCache(flag);
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    return (GlideRequest<TranscodeType>) super.diskCacheStrategy(strategy);
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority priority) {
+    return (GlideRequest<TranscodeType>) super.priority(priority);
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.placeholder(drawable);
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.placeholder(id);
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.fallback(drawable);
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.fallback(id);
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.error(drawable);
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.error(id);
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme theme) {
+    return (GlideRequest<TranscodeType>) super.theme(theme);
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    return (GlideRequest<TranscodeType>) super.skipMemoryCache(skip);
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    return (GlideRequest<TranscodeType>) super.override(width, height);
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    return (GlideRequest<TranscodeType>) super.override(size);
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key key) {
+    return (GlideRequest<TranscodeType>) super.signature(key);
+  }
+
+  /**
+   * @see GlideOptions#set(Option<Y>, Y)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> set(@NonNull Option<Y> option, @NonNull Y y) {
+    return (GlideRequest<TranscodeType>) super.set(option, y);
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> clazz) {
+    return (GlideRequest<TranscodeType>) super.decode(clazz);
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return (GlideRequest<TranscodeType>) super.encodeFormat(format);
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int value) {
+    return (GlideRequest<TranscodeType>) super.encodeQuality(value);
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long value) {
+    return (GlideRequest<TranscodeType>) super.frame(value);
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat format) {
+    return (GlideRequest<TranscodeType>) super.format(format);
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    return (GlideRequest<TranscodeType>) super.disallowHardwareConfig();
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy strategy) {
+    return (GlideRequest<TranscodeType>) super.downsample(strategy);
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int value) {
+    return (GlideRequest<TranscodeType>) super.timeout(value);
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    return (GlideRequest<TranscodeType>) super.optionalCenterCrop();
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerCrop() {
+    return (GlideRequest<TranscodeType>) super.centerCrop();
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    return (GlideRequest<TranscodeType>) super.optionalFitCenter();
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    return (GlideRequest<TranscodeType>) super.fitCenter();
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    return (GlideRequest<TranscodeType>) super.optionalCenterInside();
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    return (GlideRequest<TranscodeType>) super.centerInside();
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    return (GlideRequest<TranscodeType>) super.optionalCircleCrop();
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    return (GlideRequest<TranscodeType>) super.circleCrop();
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideRequest<TranscodeType>) super.transform(transformation);
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideRequest<TranscodeType>) super.transforms(transformations);
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideRequest<TranscodeType>) super.optionalTransform(transformation);
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<Y>, Transformation<Y>)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideRequest<TranscodeType>) super.optionalTransform(clazz, transformation);
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<Y>, Transformation<Y>)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> transform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideRequest<TranscodeType>) super.transform(clazz, transformation);
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    return (GlideRequest<TranscodeType>) super.dontTransform();
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    return (GlideRequest<TranscodeType>) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull BaseRequestOptions<?> options) {
+    return (GlideRequest<TranscodeType>) super.apply(options);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> options) {
+    return (GlideRequest<TranscodeType>) super.transition(options);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> listener) {
+    return (GlideRequest<TranscodeType>) super.listener(listener);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> addListener(@Nullable RequestListener<TranscodeType> listener) {
+    return (GlideRequest<TranscodeType>) super.addListener(listener);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> builder) {
+    return (GlideRequest<TranscodeType>) super.error(builder);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> builder) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(builder);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... builders) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(builders);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object o) {
+    return (GlideRequest<TranscodeType>) super.load(o);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap bitmap) {
+    return (GlideRequest<TranscodeType>) super.load(bitmap);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.load(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String string) {
+    return (GlideRequest<TranscodeType>) super.load(string);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri uri) {
+    return (GlideRequest<TranscodeType>) super.load(uri);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File file) {
+    return (GlideRequest<TranscodeType>) super.load(file);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer id) {
+    return (GlideRequest<TranscodeType>) super.load(id);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL url) {
+    return (GlideRequest<TranscodeType>) super.load(url);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] bytes) {
+    return (GlideRequest<TranscodeType>) super.load(bytes);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java
new file mode 100644
index 000000000..7344fe291
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java
@@ -0,0 +1,180 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
+import com.bumptech.glide.manager.Lifecycle;
+import com.bumptech.glide.manager.RequestManagerTreeNode;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Includes all additions from methods in {@link com.bumptech.glide.annotation.GlideExtension}s
+ * annotated with {@link com.bumptech.glide.annotation.GlideType}
+ *
+ * <p>Generated code, do not modify
+ */
+@SuppressWarnings("deprecation")
+public class GlideRequests extends RequestManager {
+  public GlideRequests(@NonNull Glide glide, @NonNull Lifecycle lifecycle,
+      @NonNull RequestManagerTreeNode treeNode, @NonNull Context context) {
+    super(glide, lifecycle, treeNode, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  public <ResourceType> GlideRequest<ResourceType> as(@NonNull Class<ResourceType> resourceClass) {
+    return new GlideRequest<>(glide, this, resourceClass, context);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequests applyDefaultRequestOptions(@NonNull RequestOptions options) {
+    return (GlideRequests) super.applyDefaultRequestOptions(options);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequests setDefaultRequestOptions(@NonNull RequestOptions options) {
+    return (GlideRequests) super.setDefaultRequestOptions(options);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {
+    return (GlideRequests) super.addDefaultRequestListener(listener);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Bitmap> asBitmap() {
+    return (GlideRequest<Bitmap>) super.asBitmap();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<GifDrawable> asGif() {
+    return (GlideRequest<GifDrawable>) super.asGif();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> asDrawable() {
+    return (GlideRequest<Drawable>) super.asDrawable();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Bitmap bitmap) {
+    return (GlideRequest<Drawable>) super.load(bitmap);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Drawable drawable) {
+    return (GlideRequest<Drawable>) super.load(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable String string) {
+    return (GlideRequest<Drawable>) super.load(string);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Uri uri) {
+    return (GlideRequest<Drawable>) super.load(uri);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable File file) {
+    return (GlideRequest<Drawable>) super.load(file);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@RawRes @DrawableRes @Nullable Integer id) {
+    return (GlideRequest<Drawable>) super.load(id);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable URL url) {
+    return (GlideRequest<Drawable>) super.load(url);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable byte[] bytes) {
+    return (GlideRequest<Drawable>) super.load(bytes);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Object o) {
+    return (GlideRequest<Drawable>) super.load(o);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<File> downloadOnly() {
+    return (GlideRequest<File>) super.downloadOnly();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<File> download(@Nullable Object o) {
+    return (GlideRequest<File>) super.download(o);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<File> asFile() {
+    return (GlideRequest<File>) super.asFile();
+  }
+
+  @Override
+  protected void setRequestOptions(@NonNull RequestOptions toSet) {
+    if (toSet instanceof com.bumptech.glide.test.GlideOptions) {
+      super.setRequestOptions(toSet);
+    } else {
+      super.setRequestOptions(new com.bumptech.glide.test.GlideOptions().apply(toSet));
+    }
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/EmptyLibraryGlideModuleTest/EmptyLibraryModule.java b/annotation/compiler/test/src/test/resources/EmptyLibraryGlideModuleTest/EmptyLibraryModule.java
new file mode 100644
index 000000000..60ad52260
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyLibraryGlideModuleTest/EmptyLibraryModule.java
@@ -0,0 +1,7 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.LibraryGlideModule;
+
+@GlideModule
+public final class EmptyLibraryModule extends LibraryGlideModule {}
diff --git a/annotation/compiler/test/src/test/resources/EmptyLibraryGlideModuleTest/GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule.java b/annotation/compiler/test/src/test/resources/EmptyLibraryGlideModuleTest/GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule.java
new file mode 100644
index 000000000..b18a61cd1
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyLibraryGlideModuleTest/GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule.java
@@ -0,0 +1,7 @@
+package com.bumptech.glide.annotation.compiler;
+
+@Index(
+    modules = "com.bumptech.glide.test.EmptyLibraryModule"
+)
+public class GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule {
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/Extension.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/Extension.java
new file mode 100644
index 000000000..01453f331
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/Extension.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.test;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.BaseRequestOptions;
+
+@GlideExtension
+public final class Extension {
+
+  private Extension() {
+    // Utility class.
+  }
+
+  @NonNull
+  @GlideOption(memoizeStaticMethod = true)
+  public static BaseRequestOptions<?> test(BaseRequestOptions<?> requestOptions) {
+    return requestOptions.centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java
new file mode 100644
index 000000000..4da6ef1ba
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java
@@ -0,0 +1,645 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see Extension
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform1;
+
+  private static GlideOptions centerInsideTransform2;
+
+  private static GlideOptions centerCropTransform3;
+
+  private static GlideOptions circleCropTransform4;
+
+  private static GlideOptions noTransformation5;
+
+  private static GlideOptions noAnimation6;
+
+  private static GlideOptions testOf0;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return new GlideOptions().sizeMultiplier(value);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy strategy) {
+    return new GlideOptions().diskCacheStrategy(strategy);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority priority) {
+    return new GlideOptions().priority(priority);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable drawable) {
+    return new GlideOptions().placeholder(drawable);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int id) {
+    return new GlideOptions().placeholder(id);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable drawable) {
+    return new GlideOptions().error(drawable);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int id) {
+    return new GlideOptions().error(id);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int value0,
+      @IntRange(from = 0) int value1) {
+    return new GlideOptions().override(value0, value1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int value) {
+    return new GlideOptions().override(value);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key key) {
+    return new GlideOptions().signature(key);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform1 == null) {
+      GlideOptions.fitCenterTransform1 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform2 == null) {
+      GlideOptions.centerInsideTransform2 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform2;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform3 == null) {
+      GlideOptions.centerCropTransform3 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform4 == null) {
+      GlideOptions.circleCropTransform4 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform4;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> transformation) {
+    return new GlideOptions().transform(transformation);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation5 == null) {
+      GlideOptions.noTransformation5 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation5;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> option, @NonNull T t) {
+    return new GlideOptions().set(option, t);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> clazz) {
+    return new GlideOptions().decode(clazz);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat format) {
+    return new GlideOptions().format(format);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long value) {
+    return new GlideOptions().frame(value);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy strategy) {
+    return new GlideOptions().downsample(strategy);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int value) {
+    return new GlideOptions().timeout(value);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int value) {
+    return new GlideOptions().encodeQuality(value);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat format) {
+    return new GlideOptions().encodeFormat(format);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation6 == null) {
+      GlideOptions.noAnimation6 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation6;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return (GlideOptions) super.sizeMultiplier(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    return (GlideOptions) super.diskCacheStrategy(strategy);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions priority(@NonNull Priority priority) {
+    return (GlideOptions) super.priority(priority);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions placeholder(@Nullable Drawable drawable) {
+    return (GlideOptions) super.placeholder(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions placeholder(@DrawableRes int id) {
+    return (GlideOptions) super.placeholder(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fallback(@Nullable Drawable drawable) {
+    return (GlideOptions) super.fallback(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fallback(@DrawableRes int id) {
+    return (GlideOptions) super.fallback(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions error(@Nullable Drawable drawable) {
+    return (GlideOptions) super.error(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions error(@DrawableRes int id) {
+    return (GlideOptions) super.error(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions theme(@Nullable Resources.Theme theme) {
+    return (GlideOptions) super.theme(theme);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions signature(@NonNull Key key) {
+    return (GlideOptions) super.signature(key);
+  }
+
+  @Override
+  @CheckResult
+  public GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions set(@NonNull Option<Y> option, @NonNull Y y) {
+    return (GlideOptions) super.set(option, y);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions decode(@NonNull Class<?> clazz) {
+    return (GlideOptions) super.decode(clazz);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return (GlideOptions) super.encodeFormat(format);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int value) {
+    return (GlideOptions) super.encodeQuality(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions frame(@IntRange(from = 0) long value) {
+    return (GlideOptions) super.frame(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions format(@NonNull DecodeFormat format) {
+    return (GlideOptions) super.format(format);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions downsample(@NonNull DownsampleStrategy strategy) {
+    return (GlideOptions) super.downsample(strategy);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions timeout(@IntRange(from = 0) int value) {
+    return (GlideOptions) super.timeout(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions transform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideOptions) super.transform(transformation);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideOptions) super.transforms(transformations);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideOptions) super.optionalTransform(transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions optionalTransform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideOptions) super.optionalTransform(clazz, transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions transform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideOptions) super.transform(clazz, transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions apply(@NonNull BaseRequestOptions<?> options) {
+    return (GlideOptions) super.apply(options);
+  }
+
+  @Override
+  @NonNull
+  public GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see Extension#test(BaseRequestOptions)
+   */
+  @SuppressWarnings("unchecked")
+  @CheckResult
+  @NonNull
+  public GlideOptions test() {
+    return (GlideOptions) Extension.test(this);
+  }
+
+  /**
+   * @see Extension#test(BaseRequestOptions)
+   */
+  @CheckResult
+  public static GlideOptions testOf() {
+    if (GlideOptions.testOf0 == null) {
+      GlideOptions.testOf0 =
+          new GlideOptions().test().autoClone();
+    }
+    return GlideOptions.testOf0;
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java
new file mode 100644
index 000000000..18fb054fb
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java
@@ -0,0 +1,582 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.RequestListener;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link com.bumptech.glide.request.RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see com.bumptech.glide.request.RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return (GlideRequest<TranscodeType>) super.sizeMultiplier(value);
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.useAnimationPool(flag);
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.onlyRetrieveFromCache(flag);
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    return (GlideRequest<TranscodeType>) super.diskCacheStrategy(strategy);
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority priority) {
+    return (GlideRequest<TranscodeType>) super.priority(priority);
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.placeholder(drawable);
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.placeholder(id);
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.fallback(drawable);
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.fallback(id);
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.error(drawable);
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.error(id);
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme theme) {
+    return (GlideRequest<TranscodeType>) super.theme(theme);
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    return (GlideRequest<TranscodeType>) super.skipMemoryCache(skip);
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    return (GlideRequest<TranscodeType>) super.override(width, height);
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    return (GlideRequest<TranscodeType>) super.override(size);
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key key) {
+    return (GlideRequest<TranscodeType>) super.signature(key);
+  }
+
+  /**
+   * @see GlideOptions#set(Option<Y>, Y)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> set(@NonNull Option<Y> option, @NonNull Y y) {
+    return (GlideRequest<TranscodeType>) super.set(option, y);
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> clazz) {
+    return (GlideRequest<TranscodeType>) super.decode(clazz);
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return (GlideRequest<TranscodeType>) super.encodeFormat(format);
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int value) {
+    return (GlideRequest<TranscodeType>) super.encodeQuality(value);
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long value) {
+    return (GlideRequest<TranscodeType>) super.frame(value);
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat format) {
+    return (GlideRequest<TranscodeType>) super.format(format);
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    return (GlideRequest<TranscodeType>) super.disallowHardwareConfig();
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy strategy) {
+    return (GlideRequest<TranscodeType>) super.downsample(strategy);
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int value) {
+    return (GlideRequest<TranscodeType>) super.timeout(value);
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    return (GlideRequest<TranscodeType>) super.optionalCenterCrop();
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerCrop() {
+    return (GlideRequest<TranscodeType>) super.centerCrop();
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    return (GlideRequest<TranscodeType>) super.optionalFitCenter();
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    return (GlideRequest<TranscodeType>) super.fitCenter();
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    return (GlideRequest<TranscodeType>) super.optionalCenterInside();
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    return (GlideRequest<TranscodeType>) super.centerInside();
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    return (GlideRequest<TranscodeType>) super.optionalCircleCrop();
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    return (GlideRequest<TranscodeType>) super.circleCrop();
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideRequest<TranscodeType>) super.transform(transformation);
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideRequest<TranscodeType>) super.transforms(transformations);
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideRequest<TranscodeType>) super.optionalTransform(transformation);
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<Y>, Transformation<Y>)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideRequest<TranscodeType>) super.optionalTransform(clazz, transformation);
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<Y>, Transformation<Y>)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> transform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideRequest<TranscodeType>) super.transform(clazz, transformation);
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    return (GlideRequest<TranscodeType>) super.dontTransform();
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    return (GlideRequest<TranscodeType>) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull BaseRequestOptions<?> options) {
+    return (GlideRequest<TranscodeType>) super.apply(options);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> options) {
+    return (GlideRequest<TranscodeType>) super.transition(options);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> listener) {
+    return (GlideRequest<TranscodeType>) super.listener(listener);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> addListener(@Nullable RequestListener<TranscodeType> listener) {
+    return (GlideRequest<TranscodeType>) super.addListener(listener);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> builder) {
+    return (GlideRequest<TranscodeType>) super.error(builder);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> builder) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(builder);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... builders) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(builders);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object o) {
+    return (GlideRequest<TranscodeType>) super.load(o);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap bitmap) {
+    return (GlideRequest<TranscodeType>) super.load(bitmap);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.load(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String string) {
+    return (GlideRequest<TranscodeType>) super.load(string);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri uri) {
+    return (GlideRequest<TranscodeType>) super.load(uri);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File file) {
+    return (GlideRequest<TranscodeType>) super.load(file);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer id) {
+    return (GlideRequest<TranscodeType>) super.load(id);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL url) {
+    return (GlideRequest<TranscodeType>) super.load(url);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] bytes) {
+    return (GlideRequest<TranscodeType>) super.load(bytes);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+
+  /**
+   * @see Extension#test(BaseRequestOptions)
+   */
+  @SuppressWarnings("unchecked")
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> test() {
+    return (GlideRequest<TranscodeType>) Extension.test(this);
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/Extension.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/Extension.java
new file mode 100644
index 000000000..0104eaa9b
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/Extension.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.test;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.BaseRequestOptions;
+
+@GlideExtension
+public final class Extension {
+
+  private Extension() {
+    // Utility class.
+  }
+
+  @NonNull
+  @GlideOption(override = GlideOption.OVERRIDE_EXTEND)
+  public static BaseRequestOptions<?> centerCrop(BaseRequestOptions<?> requestOptions) {
+    return requestOptions.centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideOptions.java
new file mode 100644
index 000000000..089b752ef
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideOptions.java
@@ -0,0 +1,634 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see Extension
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return new GlideOptions().sizeMultiplier(value);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy strategy) {
+    return new GlideOptions().diskCacheStrategy(strategy);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority priority) {
+    return new GlideOptions().priority(priority);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable drawable) {
+    return new GlideOptions().placeholder(drawable);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int id) {
+    return new GlideOptions().placeholder(id);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable drawable) {
+    return new GlideOptions().error(drawable);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int id) {
+    return new GlideOptions().error(id);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int value0,
+      @IntRange(from = 0) int value1) {
+    return new GlideOptions().override(value0, value1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int value) {
+    return new GlideOptions().override(value);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key key) {
+    return new GlideOptions().signature(key);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> transformation) {
+    return new GlideOptions().transform(transformation);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> option, @NonNull T t) {
+    return new GlideOptions().set(option, t);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> clazz) {
+    return new GlideOptions().decode(clazz);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat format) {
+    return new GlideOptions().format(format);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long value) {
+    return new GlideOptions().frame(value);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy strategy) {
+    return new GlideOptions().downsample(strategy);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int value) {
+    return new GlideOptions().timeout(value);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int value) {
+    return new GlideOptions().encodeQuality(value);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat format) {
+    return new GlideOptions().encodeFormat(format);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return (GlideOptions) super.sizeMultiplier(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    return (GlideOptions) super.diskCacheStrategy(strategy);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions priority(@NonNull Priority priority) {
+    return (GlideOptions) super.priority(priority);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions placeholder(@Nullable Drawable drawable) {
+    return (GlideOptions) super.placeholder(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions placeholder(@DrawableRes int id) {
+    return (GlideOptions) super.placeholder(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fallback(@Nullable Drawable drawable) {
+    return (GlideOptions) super.fallback(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fallback(@DrawableRes int id) {
+    return (GlideOptions) super.fallback(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions error(@Nullable Drawable drawable) {
+    return (GlideOptions) super.error(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions error(@DrawableRes int id) {
+    return (GlideOptions) super.error(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions theme(@Nullable Resources.Theme theme) {
+    return (GlideOptions) super.theme(theme);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions signature(@NonNull Key key) {
+    return (GlideOptions) super.signature(key);
+  }
+
+  @Override
+  @CheckResult
+  public GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions set(@NonNull Option<Y> option, @NonNull Y y) {
+    return (GlideOptions) super.set(option, y);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions decode(@NonNull Class<?> clazz) {
+    return (GlideOptions) super.decode(clazz);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return (GlideOptions) super.encodeFormat(format);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int value) {
+    return (GlideOptions) super.encodeQuality(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions frame(@IntRange(from = 0) long value) {
+    return (GlideOptions) super.frame(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions format(@NonNull DecodeFormat format) {
+    return (GlideOptions) super.format(format);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions downsample(@NonNull DownsampleStrategy strategy) {
+    return (GlideOptions) super.downsample(strategy);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions timeout(@IntRange(from = 0) int value) {
+    return (GlideOptions) super.timeout(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions transform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideOptions) super.transform(transformation);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideOptions) super.transforms(transformations);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideOptions) super.optionalTransform(transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions optionalTransform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideOptions) super.optionalTransform(clazz, transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions transform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideOptions) super.transform(clazz, transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions apply(@NonNull BaseRequestOptions<?> options) {
+    return (GlideOptions) super.apply(options);
+  }
+
+  @Override
+  @NonNull
+  public GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see Extension#centerCrop(BaseRequestOptions)
+   * @see GlideOptions#centerCrop()
+   */
+  @SuppressWarnings("unchecked")
+  @Override
+  @CheckResult
+  @NonNull
+  public GlideOptions centerCrop() {
+    return (GlideOptions) Extension.centerCrop(super.centerCrop());
+  }
+
+  /**
+   * @see Extension#centerCrop(BaseRequestOptions)
+   */
+  @CheckResult
+  public static GlideOptions centerCropOf() {
+    return new GlideOptions().centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideRequest.java
new file mode 100644
index 000000000..860faf1ac
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideRequest.java
@@ -0,0 +1,575 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.RequestListener;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link com.bumptech.glide.request.RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see com.bumptech.glide.request.RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return (GlideRequest<TranscodeType>) super.sizeMultiplier(value);
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.useAnimationPool(flag);
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.onlyRetrieveFromCache(flag);
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    return (GlideRequest<TranscodeType>) super.diskCacheStrategy(strategy);
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority priority) {
+    return (GlideRequest<TranscodeType>) super.priority(priority);
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.placeholder(drawable);
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.placeholder(id);
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.fallback(drawable);
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.fallback(id);
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.error(drawable);
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.error(id);
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme theme) {
+    return (GlideRequest<TranscodeType>) super.theme(theme);
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    return (GlideRequest<TranscodeType>) super.skipMemoryCache(skip);
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    return (GlideRequest<TranscodeType>) super.override(width, height);
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    return (GlideRequest<TranscodeType>) super.override(size);
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key key) {
+    return (GlideRequest<TranscodeType>) super.signature(key);
+  }
+
+  /**
+   * @see GlideOptions#set(Option<Y>, Y)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> set(@NonNull Option<Y> option, @NonNull Y y) {
+    return (GlideRequest<TranscodeType>) super.set(option, y);
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> clazz) {
+    return (GlideRequest<TranscodeType>) super.decode(clazz);
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return (GlideRequest<TranscodeType>) super.encodeFormat(format);
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int value) {
+    return (GlideRequest<TranscodeType>) super.encodeQuality(value);
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long value) {
+    return (GlideRequest<TranscodeType>) super.frame(value);
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat format) {
+    return (GlideRequest<TranscodeType>) super.format(format);
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    return (GlideRequest<TranscodeType>) super.disallowHardwareConfig();
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy strategy) {
+    return (GlideRequest<TranscodeType>) super.downsample(strategy);
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int value) {
+    return (GlideRequest<TranscodeType>) super.timeout(value);
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    return (GlideRequest<TranscodeType>) super.optionalCenterCrop();
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    return (GlideRequest<TranscodeType>) super.optionalFitCenter();
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    return (GlideRequest<TranscodeType>) super.fitCenter();
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    return (GlideRequest<TranscodeType>) super.optionalCenterInside();
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    return (GlideRequest<TranscodeType>) super.centerInside();
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    return (GlideRequest<TranscodeType>) super.optionalCircleCrop();
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    return (GlideRequest<TranscodeType>) super.circleCrop();
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideRequest<TranscodeType>) super.transform(transformation);
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideRequest<TranscodeType>) super.transforms(transformations);
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideRequest<TranscodeType>) super.optionalTransform(transformation);
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<Y>, Transformation<Y>)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideRequest<TranscodeType>) super.optionalTransform(clazz, transformation);
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<Y>, Transformation<Y>)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> transform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideRequest<TranscodeType>) super.transform(clazz, transformation);
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    return (GlideRequest<TranscodeType>) super.dontTransform();
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    return (GlideRequest<TranscodeType>) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull BaseRequestOptions<?> options) {
+    return (GlideRequest<TranscodeType>) super.apply(options);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> options) {
+    return (GlideRequest<TranscodeType>) super.transition(options);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> listener) {
+    return (GlideRequest<TranscodeType>) super.listener(listener);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> addListener(@Nullable RequestListener<TranscodeType> listener) {
+    return (GlideRequest<TranscodeType>) super.addListener(listener);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> builder) {
+    return (GlideRequest<TranscodeType>) super.error(builder);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> builder) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(builder);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... builders) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(builders);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object o) {
+    return (GlideRequest<TranscodeType>) super.load(o);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap bitmap) {
+    return (GlideRequest<TranscodeType>) super.load(bitmap);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.load(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String string) {
+    return (GlideRequest<TranscodeType>) super.load(string);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri uri) {
+    return (GlideRequest<TranscodeType>) super.load(uri);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File file) {
+    return (GlideRequest<TranscodeType>) super.load(file);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer id) {
+    return (GlideRequest<TranscodeType>) super.load(id);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL url) {
+    return (GlideRequest<TranscodeType>) super.load(url);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] bytes) {
+    return (GlideRequest<TranscodeType>) super.load(bytes);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+
+  /**
+   * @see Extension#centerCrop(BaseRequestOptions)
+   * @see GlideRequest<TranscodeType>#centerCrop()
+   */
+  @SuppressWarnings("unchecked")
+  @Override
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> centerCrop() {
+    return (GlideRequest<TranscodeType>) Extension.centerCrop(super.centerCrop());
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/Extension.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/Extension.java
new file mode 100644
index 000000000..e92ece857
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/Extension.java
@@ -0,0 +1,22 @@
+package com.bumptech.glide.test;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.BaseRequestOptions;
+
+@GlideExtension
+public final class Extension {
+
+  private Extension() {
+    // Utility class.
+  }
+
+  @NonNull
+  @GlideOption(override = GlideOption.OVERRIDE_EXTEND)
+  public static BaseRequestOptions<?> override(BaseRequestOptions<?> requestOptions, int width, int height) {
+    return requestOptions
+        .override(width, height)
+        .centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideOptions.java
new file mode 100644
index 000000000..89850adc8
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideOptions.java
@@ -0,0 +1,624 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see Extension
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return new GlideOptions().sizeMultiplier(value);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy strategy) {
+    return new GlideOptions().diskCacheStrategy(strategy);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority priority) {
+    return new GlideOptions().priority(priority);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable drawable) {
+    return new GlideOptions().placeholder(drawable);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int id) {
+    return new GlideOptions().placeholder(id);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable drawable) {
+    return new GlideOptions().error(drawable);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int id) {
+    return new GlideOptions().error(id);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int value) {
+    return new GlideOptions().override(value);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key key) {
+    return new GlideOptions().signature(key);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> transformation) {
+    return new GlideOptions().transform(transformation);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> option, @NonNull T t) {
+    return new GlideOptions().set(option, t);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> clazz) {
+    return new GlideOptions().decode(clazz);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat format) {
+    return new GlideOptions().format(format);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long value) {
+    return new GlideOptions().frame(value);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy strategy) {
+    return new GlideOptions().downsample(strategy);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int value) {
+    return new GlideOptions().timeout(value);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int value) {
+    return new GlideOptions().encodeQuality(value);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat format) {
+    return new GlideOptions().encodeFormat(format);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return (GlideOptions) super.sizeMultiplier(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    return (GlideOptions) super.diskCacheStrategy(strategy);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions priority(@NonNull Priority priority) {
+    return (GlideOptions) super.priority(priority);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions placeholder(@Nullable Drawable drawable) {
+    return (GlideOptions) super.placeholder(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions placeholder(@DrawableRes int id) {
+    return (GlideOptions) super.placeholder(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fallback(@Nullable Drawable drawable) {
+    return (GlideOptions) super.fallback(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fallback(@DrawableRes int id) {
+    return (GlideOptions) super.fallback(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions error(@Nullable Drawable drawable) {
+    return (GlideOptions) super.error(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions error(@DrawableRes int id) {
+    return (GlideOptions) super.error(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions theme(@Nullable Resources.Theme theme) {
+    return (GlideOptions) super.theme(theme);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions signature(@NonNull Key key) {
+    return (GlideOptions) super.signature(key);
+  }
+
+  @Override
+  @CheckResult
+  public GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions set(@NonNull Option<Y> option, @NonNull Y y) {
+    return (GlideOptions) super.set(option, y);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions decode(@NonNull Class<?> clazz) {
+    return (GlideOptions) super.decode(clazz);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return (GlideOptions) super.encodeFormat(format);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int value) {
+    return (GlideOptions) super.encodeQuality(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions frame(@IntRange(from = 0) long value) {
+    return (GlideOptions) super.frame(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions format(@NonNull DecodeFormat format) {
+    return (GlideOptions) super.format(format);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions downsample(@NonNull DownsampleStrategy strategy) {
+    return (GlideOptions) super.downsample(strategy);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions timeout(@IntRange(from = 0) int value) {
+    return (GlideOptions) super.timeout(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions transform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideOptions) super.transform(transformation);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideOptions) super.transforms(transformations);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideOptions) super.optionalTransform(transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions optionalTransform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideOptions) super.optionalTransform(clazz, transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions transform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideOptions) super.transform(clazz, transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions apply(@NonNull BaseRequestOptions<?> options) {
+    return (GlideOptions) super.apply(options);
+  }
+
+  @Override
+  @NonNull
+  public GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see Extension#override(BaseRequestOptions, int, int)
+   * @see GlideOptions#override(int, int)
+   */
+  @SuppressWarnings("unchecked")
+  @Override
+  @CheckResult
+  @NonNull
+  public GlideOptions override(int width, int height) {
+    return (GlideOptions) Extension.override(super.override(width, height), width, height);
+  }
+
+  /**
+   * @see Extension#override(BaseRequestOptions, int, int)
+   */
+  @CheckResult
+  public static GlideOptions overrideOf(int width, int height) {
+    return new GlideOptions().override(width, height);
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideRequest.java
new file mode 100644
index 000000000..0b3f59384
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideRequest.java
@@ -0,0 +1,575 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.RequestListener;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link com.bumptech.glide.request.RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see com.bumptech.glide.request.RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return (GlideRequest<TranscodeType>) super.sizeMultiplier(value);
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.useAnimationPool(flag);
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.onlyRetrieveFromCache(flag);
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    return (GlideRequest<TranscodeType>) super.diskCacheStrategy(strategy);
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority priority) {
+    return (GlideRequest<TranscodeType>) super.priority(priority);
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.placeholder(drawable);
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.placeholder(id);
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.fallback(drawable);
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.fallback(id);
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.error(drawable);
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.error(id);
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme theme) {
+    return (GlideRequest<TranscodeType>) super.theme(theme);
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    return (GlideRequest<TranscodeType>) super.skipMemoryCache(skip);
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    return (GlideRequest<TranscodeType>) super.override(size);
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key key) {
+    return (GlideRequest<TranscodeType>) super.signature(key);
+  }
+
+  /**
+   * @see GlideOptions#set(Option<Y>, Y)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> set(@NonNull Option<Y> option, @NonNull Y y) {
+    return (GlideRequest<TranscodeType>) super.set(option, y);
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> clazz) {
+    return (GlideRequest<TranscodeType>) super.decode(clazz);
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return (GlideRequest<TranscodeType>) super.encodeFormat(format);
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int value) {
+    return (GlideRequest<TranscodeType>) super.encodeQuality(value);
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long value) {
+    return (GlideRequest<TranscodeType>) super.frame(value);
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat format) {
+    return (GlideRequest<TranscodeType>) super.format(format);
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    return (GlideRequest<TranscodeType>) super.disallowHardwareConfig();
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy strategy) {
+    return (GlideRequest<TranscodeType>) super.downsample(strategy);
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int value) {
+    return (GlideRequest<TranscodeType>) super.timeout(value);
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    return (GlideRequest<TranscodeType>) super.optionalCenterCrop();
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerCrop() {
+    return (GlideRequest<TranscodeType>) super.centerCrop();
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    return (GlideRequest<TranscodeType>) super.optionalFitCenter();
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    return (GlideRequest<TranscodeType>) super.fitCenter();
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    return (GlideRequest<TranscodeType>) super.optionalCenterInside();
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    return (GlideRequest<TranscodeType>) super.centerInside();
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    return (GlideRequest<TranscodeType>) super.optionalCircleCrop();
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    return (GlideRequest<TranscodeType>) super.circleCrop();
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideRequest<TranscodeType>) super.transform(transformation);
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideRequest<TranscodeType>) super.transforms(transformations);
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideRequest<TranscodeType>) super.optionalTransform(transformation);
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<Y>, Transformation<Y>)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideRequest<TranscodeType>) super.optionalTransform(clazz, transformation);
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<Y>, Transformation<Y>)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> transform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideRequest<TranscodeType>) super.transform(clazz, transformation);
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    return (GlideRequest<TranscodeType>) super.dontTransform();
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    return (GlideRequest<TranscodeType>) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull BaseRequestOptions<?> options) {
+    return (GlideRequest<TranscodeType>) super.apply(options);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> options) {
+    return (GlideRequest<TranscodeType>) super.transition(options);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> listener) {
+    return (GlideRequest<TranscodeType>) super.listener(listener);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> addListener(@Nullable RequestListener<TranscodeType> listener) {
+    return (GlideRequest<TranscodeType>) super.addListener(listener);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> builder) {
+    return (GlideRequest<TranscodeType>) super.error(builder);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> builder) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(builder);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... builders) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(builders);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object o) {
+    return (GlideRequest<TranscodeType>) super.load(o);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap bitmap) {
+    return (GlideRequest<TranscodeType>) super.load(bitmap);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.load(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String string) {
+    return (GlideRequest<TranscodeType>) super.load(string);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri uri) {
+    return (GlideRequest<TranscodeType>) super.load(uri);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File file) {
+    return (GlideRequest<TranscodeType>) super.load(file);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer id) {
+    return (GlideRequest<TranscodeType>) super.load(id);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL url) {
+    return (GlideRequest<TranscodeType>) super.load(url);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] bytes) {
+    return (GlideRequest<TranscodeType>) super.load(bytes);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+
+  /**
+   * @see Extension#override(BaseRequestOptions, int, int)
+   * @see GlideRequest<TranscodeType>#override(int, int)
+   */
+  @SuppressWarnings("unchecked")
+  @Override
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    return (GlideRequest<TranscodeType>) Extension.override(super.override(width, height), width, height);
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/Extension.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/Extension.java
new file mode 100644
index 000000000..4467cf21f
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/Extension.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.test;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.BaseRequestOptions;
+
+@GlideExtension
+public final class Extension {
+
+  private Extension() {
+    // Utility class.
+  }
+
+  @NonNull
+  @GlideOption(override = GlideOption.OVERRIDE_REPLACE)
+  public static BaseRequestOptions<?> centerCrop(BaseRequestOptions<?> requestOptions) {
+    return requestOptions.centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideOptions.java
new file mode 100644
index 000000000..124b80a27
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideOptions.java
@@ -0,0 +1,632 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see Extension
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return new GlideOptions().sizeMultiplier(value);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy strategy) {
+    return new GlideOptions().diskCacheStrategy(strategy);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority priority) {
+    return new GlideOptions().priority(priority);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable drawable) {
+    return new GlideOptions().placeholder(drawable);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int id) {
+    return new GlideOptions().placeholder(id);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable drawable) {
+    return new GlideOptions().error(drawable);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int id) {
+    return new GlideOptions().error(id);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int value0,
+      @IntRange(from = 0) int value1) {
+    return new GlideOptions().override(value0, value1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int value) {
+    return new GlideOptions().override(value);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key key) {
+    return new GlideOptions().signature(key);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> transformation) {
+    return new GlideOptions().transform(transformation);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> option, @NonNull T t) {
+    return new GlideOptions().set(option, t);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> clazz) {
+    return new GlideOptions().decode(clazz);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat format) {
+    return new GlideOptions().format(format);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long value) {
+    return new GlideOptions().frame(value);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy strategy) {
+    return new GlideOptions().downsample(strategy);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int value) {
+    return new GlideOptions().timeout(value);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int value) {
+    return new GlideOptions().encodeQuality(value);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat format) {
+    return new GlideOptions().encodeFormat(format);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return (GlideOptions) super.sizeMultiplier(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    return (GlideOptions) super.diskCacheStrategy(strategy);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions priority(@NonNull Priority priority) {
+    return (GlideOptions) super.priority(priority);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions placeholder(@Nullable Drawable drawable) {
+    return (GlideOptions) super.placeholder(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions placeholder(@DrawableRes int id) {
+    return (GlideOptions) super.placeholder(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fallback(@Nullable Drawable drawable) {
+    return (GlideOptions) super.fallback(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fallback(@DrawableRes int id) {
+    return (GlideOptions) super.fallback(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions error(@Nullable Drawable drawable) {
+    return (GlideOptions) super.error(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions error(@DrawableRes int id) {
+    return (GlideOptions) super.error(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions theme(@Nullable Resources.Theme theme) {
+    return (GlideOptions) super.theme(theme);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions signature(@NonNull Key key) {
+    return (GlideOptions) super.signature(key);
+  }
+
+  @Override
+  @CheckResult
+  public GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions set(@NonNull Option<Y> option, @NonNull Y y) {
+    return (GlideOptions) super.set(option, y);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions decode(@NonNull Class<?> clazz) {
+    return (GlideOptions) super.decode(clazz);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return (GlideOptions) super.encodeFormat(format);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int value) {
+    return (GlideOptions) super.encodeQuality(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions frame(@IntRange(from = 0) long value) {
+    return (GlideOptions) super.frame(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions format(@NonNull DecodeFormat format) {
+    return (GlideOptions) super.format(format);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions downsample(@NonNull DownsampleStrategy strategy) {
+    return (GlideOptions) super.downsample(strategy);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions timeout(@IntRange(from = 0) int value) {
+    return (GlideOptions) super.timeout(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions transform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideOptions) super.transform(transformation);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideOptions) super.transforms(transformations);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideOptions) super.optionalTransform(transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions optionalTransform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideOptions) super.optionalTransform(clazz, transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions transform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideOptions) super.transform(clazz, transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions apply(@NonNull BaseRequestOptions<?> options) {
+    return (GlideOptions) super.apply(options);
+  }
+
+  @Override
+  @NonNull
+  public GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see Extension#centerCrop(BaseRequestOptions)
+   */
+  @SuppressWarnings("unchecked")
+  @CheckResult
+  @NonNull
+  public GlideOptions centerCrop() {
+    return (GlideOptions) Extension.centerCrop(this);
+  }
+
+  /**
+   * @see Extension#centerCrop(BaseRequestOptions)
+   */
+  @CheckResult
+  public static GlideOptions centerCropOf() {
+    return new GlideOptions().centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideRequest.java
new file mode 100644
index 000000000..0c4f8ba9b
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideRequest.java
@@ -0,0 +1,573 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.RequestListener;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link com.bumptech.glide.request.RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see com.bumptech.glide.request.RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return (GlideRequest<TranscodeType>) super.sizeMultiplier(value);
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.useAnimationPool(flag);
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.onlyRetrieveFromCache(flag);
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    return (GlideRequest<TranscodeType>) super.diskCacheStrategy(strategy);
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority priority) {
+    return (GlideRequest<TranscodeType>) super.priority(priority);
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.placeholder(drawable);
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.placeholder(id);
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.fallback(drawable);
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.fallback(id);
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.error(drawable);
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.error(id);
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme theme) {
+    return (GlideRequest<TranscodeType>) super.theme(theme);
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    return (GlideRequest<TranscodeType>) super.skipMemoryCache(skip);
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    return (GlideRequest<TranscodeType>) super.override(width, height);
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    return (GlideRequest<TranscodeType>) super.override(size);
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key key) {
+    return (GlideRequest<TranscodeType>) super.signature(key);
+  }
+
+  /**
+   * @see GlideOptions#set(Option<Y>, Y)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> set(@NonNull Option<Y> option, @NonNull Y y) {
+    return (GlideRequest<TranscodeType>) super.set(option, y);
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> clazz) {
+    return (GlideRequest<TranscodeType>) super.decode(clazz);
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return (GlideRequest<TranscodeType>) super.encodeFormat(format);
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int value) {
+    return (GlideRequest<TranscodeType>) super.encodeQuality(value);
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long value) {
+    return (GlideRequest<TranscodeType>) super.frame(value);
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat format) {
+    return (GlideRequest<TranscodeType>) super.format(format);
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    return (GlideRequest<TranscodeType>) super.disallowHardwareConfig();
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy strategy) {
+    return (GlideRequest<TranscodeType>) super.downsample(strategy);
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int value) {
+    return (GlideRequest<TranscodeType>) super.timeout(value);
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    return (GlideRequest<TranscodeType>) super.optionalCenterCrop();
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    return (GlideRequest<TranscodeType>) super.optionalFitCenter();
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    return (GlideRequest<TranscodeType>) super.fitCenter();
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    return (GlideRequest<TranscodeType>) super.optionalCenterInside();
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    return (GlideRequest<TranscodeType>) super.centerInside();
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    return (GlideRequest<TranscodeType>) super.optionalCircleCrop();
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    return (GlideRequest<TranscodeType>) super.circleCrop();
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideRequest<TranscodeType>) super.transform(transformation);
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideRequest<TranscodeType>) super.transforms(transformations);
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideRequest<TranscodeType>) super.optionalTransform(transformation);
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<Y>, Transformation<Y>)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideRequest<TranscodeType>) super.optionalTransform(clazz, transformation);
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<Y>, Transformation<Y>)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> transform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideRequest<TranscodeType>) super.transform(clazz, transformation);
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    return (GlideRequest<TranscodeType>) super.dontTransform();
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    return (GlideRequest<TranscodeType>) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull BaseRequestOptions<?> options) {
+    return (GlideRequest<TranscodeType>) super.apply(options);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> options) {
+    return (GlideRequest<TranscodeType>) super.transition(options);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> listener) {
+    return (GlideRequest<TranscodeType>) super.listener(listener);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> addListener(@Nullable RequestListener<TranscodeType> listener) {
+    return (GlideRequest<TranscodeType>) super.addListener(listener);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> builder) {
+    return (GlideRequest<TranscodeType>) super.error(builder);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> builder) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(builder);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... builders) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(builders);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object o) {
+    return (GlideRequest<TranscodeType>) super.load(o);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap bitmap) {
+    return (GlideRequest<TranscodeType>) super.load(bitmap);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.load(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String string) {
+    return (GlideRequest<TranscodeType>) super.load(string);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri uri) {
+    return (GlideRequest<TranscodeType>) super.load(uri);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File file) {
+    return (GlideRequest<TranscodeType>) super.load(file);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer id) {
+    return (GlideRequest<TranscodeType>) super.load(id);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL url) {
+    return (GlideRequest<TranscodeType>) super.load(url);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] bytes) {
+    return (GlideRequest<TranscodeType>) super.load(bytes);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+
+  /**
+   * @see Extension#centerCrop(BaseRequestOptions)
+   */
+  @SuppressWarnings("unchecked")
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> centerCrop() {
+    return (GlideRequest<TranscodeType>) Extension.centerCrop(this);
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/Extension.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/Extension.java
new file mode 100644
index 000000000..f36597873
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/Extension.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.test;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.BaseRequestOptions;
+
+@GlideExtension
+public final class Extension {
+
+  private Extension() {
+    // Utility class.
+  }
+
+  @NonNull
+  @GlideOption(skipStaticMethod = true)
+  public static BaseRequestOptions<?> test(BaseRequestOptions<?> requestOptions) {
+    return requestOptions.centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideOptions.java
new file mode 100644
index 000000000..a98146108
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideOptions.java
@@ -0,0 +1,631 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see Extension
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return new GlideOptions().sizeMultiplier(value);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy strategy) {
+    return new GlideOptions().diskCacheStrategy(strategy);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority priority) {
+    return new GlideOptions().priority(priority);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable drawable) {
+    return new GlideOptions().placeholder(drawable);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int id) {
+    return new GlideOptions().placeholder(id);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable drawable) {
+    return new GlideOptions().error(drawable);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int id) {
+    return new GlideOptions().error(id);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int value0,
+      @IntRange(from = 0) int value1) {
+    return new GlideOptions().override(value0, value1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int value) {
+    return new GlideOptions().override(value);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key key) {
+    return new GlideOptions().signature(key);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> transformation) {
+    return new GlideOptions().transform(transformation);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> option, @NonNull T t) {
+    return new GlideOptions().set(option, t);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> clazz) {
+    return new GlideOptions().decode(clazz);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat format) {
+    return new GlideOptions().format(format);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long value) {
+    return new GlideOptions().frame(value);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy strategy) {
+    return new GlideOptions().downsample(strategy);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int value) {
+    return new GlideOptions().timeout(value);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int value) {
+    return new GlideOptions().encodeQuality(value);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat format) {
+    return new GlideOptions().encodeFormat(format);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return (GlideOptions) super.sizeMultiplier(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    return (GlideOptions) super.diskCacheStrategy(strategy);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions priority(@NonNull Priority priority) {
+    return (GlideOptions) super.priority(priority);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions placeholder(@Nullable Drawable drawable) {
+    return (GlideOptions) super.placeholder(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions placeholder(@DrawableRes int id) {
+    return (GlideOptions) super.placeholder(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fallback(@Nullable Drawable drawable) {
+    return (GlideOptions) super.fallback(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fallback(@DrawableRes int id) {
+    return (GlideOptions) super.fallback(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions error(@Nullable Drawable drawable) {
+    return (GlideOptions) super.error(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions error(@DrawableRes int id) {
+    return (GlideOptions) super.error(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions theme(@Nullable Resources.Theme theme) {
+    return (GlideOptions) super.theme(theme);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions signature(@NonNull Key key) {
+    return (GlideOptions) super.signature(key);
+  }
+
+  @Override
+  @CheckResult
+  public GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions set(@NonNull Option<Y> option, @NonNull Y y) {
+    return (GlideOptions) super.set(option, y);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions decode(@NonNull Class<?> clazz) {
+    return (GlideOptions) super.decode(clazz);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return (GlideOptions) super.encodeFormat(format);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int value) {
+    return (GlideOptions) super.encodeQuality(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions frame(@IntRange(from = 0) long value) {
+    return (GlideOptions) super.frame(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions format(@NonNull DecodeFormat format) {
+    return (GlideOptions) super.format(format);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions downsample(@NonNull DownsampleStrategy strategy) {
+    return (GlideOptions) super.downsample(strategy);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions timeout(@IntRange(from = 0) int value) {
+    return (GlideOptions) super.timeout(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions transform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideOptions) super.transform(transformation);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideOptions) super.transforms(transformations);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideOptions) super.optionalTransform(transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions optionalTransform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideOptions) super.optionalTransform(clazz, transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions transform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideOptions) super.transform(clazz, transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions apply(@NonNull BaseRequestOptions<?> options) {
+    return (GlideOptions) super.apply(options);
+  }
+
+  @Override
+  @NonNull
+  public GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see Extension#test(BaseRequestOptions)
+   */
+  @SuppressWarnings("unchecked")
+  @CheckResult
+  @NonNull
+  public GlideOptions test() {
+    return (GlideOptions) Extension.test(this);
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideRequest.java
new file mode 100644
index 000000000..18fb054fb
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideRequest.java
@@ -0,0 +1,582 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.RequestListener;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link com.bumptech.glide.request.RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see com.bumptech.glide.request.RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return (GlideRequest<TranscodeType>) super.sizeMultiplier(value);
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.useAnimationPool(flag);
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.onlyRetrieveFromCache(flag);
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    return (GlideRequest<TranscodeType>) super.diskCacheStrategy(strategy);
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority priority) {
+    return (GlideRequest<TranscodeType>) super.priority(priority);
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.placeholder(drawable);
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.placeholder(id);
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.fallback(drawable);
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.fallback(id);
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.error(drawable);
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.error(id);
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme theme) {
+    return (GlideRequest<TranscodeType>) super.theme(theme);
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    return (GlideRequest<TranscodeType>) super.skipMemoryCache(skip);
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    return (GlideRequest<TranscodeType>) super.override(width, height);
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    return (GlideRequest<TranscodeType>) super.override(size);
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key key) {
+    return (GlideRequest<TranscodeType>) super.signature(key);
+  }
+
+  /**
+   * @see GlideOptions#set(Option<Y>, Y)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> set(@NonNull Option<Y> option, @NonNull Y y) {
+    return (GlideRequest<TranscodeType>) super.set(option, y);
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> clazz) {
+    return (GlideRequest<TranscodeType>) super.decode(clazz);
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return (GlideRequest<TranscodeType>) super.encodeFormat(format);
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int value) {
+    return (GlideRequest<TranscodeType>) super.encodeQuality(value);
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long value) {
+    return (GlideRequest<TranscodeType>) super.frame(value);
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat format) {
+    return (GlideRequest<TranscodeType>) super.format(format);
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    return (GlideRequest<TranscodeType>) super.disallowHardwareConfig();
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy strategy) {
+    return (GlideRequest<TranscodeType>) super.downsample(strategy);
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int value) {
+    return (GlideRequest<TranscodeType>) super.timeout(value);
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    return (GlideRequest<TranscodeType>) super.optionalCenterCrop();
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerCrop() {
+    return (GlideRequest<TranscodeType>) super.centerCrop();
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    return (GlideRequest<TranscodeType>) super.optionalFitCenter();
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    return (GlideRequest<TranscodeType>) super.fitCenter();
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    return (GlideRequest<TranscodeType>) super.optionalCenterInside();
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    return (GlideRequest<TranscodeType>) super.centerInside();
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    return (GlideRequest<TranscodeType>) super.optionalCircleCrop();
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    return (GlideRequest<TranscodeType>) super.circleCrop();
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideRequest<TranscodeType>) super.transform(transformation);
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideRequest<TranscodeType>) super.transforms(transformations);
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideRequest<TranscodeType>) super.optionalTransform(transformation);
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<Y>, Transformation<Y>)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideRequest<TranscodeType>) super.optionalTransform(clazz, transformation);
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<Y>, Transformation<Y>)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> transform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideRequest<TranscodeType>) super.transform(clazz, transformation);
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    return (GlideRequest<TranscodeType>) super.dontTransform();
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    return (GlideRequest<TranscodeType>) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull BaseRequestOptions<?> options) {
+    return (GlideRequest<TranscodeType>) super.apply(options);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> options) {
+    return (GlideRequest<TranscodeType>) super.transition(options);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> listener) {
+    return (GlideRequest<TranscodeType>) super.listener(listener);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> addListener(@Nullable RequestListener<TranscodeType> listener) {
+    return (GlideRequest<TranscodeType>) super.addListener(listener);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> builder) {
+    return (GlideRequest<TranscodeType>) super.error(builder);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> builder) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(builder);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... builders) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(builders);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object o) {
+    return (GlideRequest<TranscodeType>) super.load(o);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap bitmap) {
+    return (GlideRequest<TranscodeType>) super.load(bitmap);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.load(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String string) {
+    return (GlideRequest<TranscodeType>) super.load(string);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri uri) {
+    return (GlideRequest<TranscodeType>) super.load(uri);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File file) {
+    return (GlideRequest<TranscodeType>) super.load(file);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer id) {
+    return (GlideRequest<TranscodeType>) super.load(id);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL url) {
+    return (GlideRequest<TranscodeType>) super.load(url);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] bytes) {
+    return (GlideRequest<TranscodeType>) super.load(bytes);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+
+  /**
+   * @see Extension#test(BaseRequestOptions)
+   */
+  @SuppressWarnings("unchecked")
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> test() {
+    return (GlideRequest<TranscodeType>) Extension.test(this);
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/Extension.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/Extension.java
new file mode 100644
index 000000000..45ccc3954
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/Extension.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.test;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.BaseRequestOptions;
+
+@GlideExtension
+public final class Extension {
+
+  private Extension() {
+    // Utility class.
+  }
+
+  @NonNull
+  @GlideOption(staticMethodName = "testSomething")
+  public static BaseRequestOptions<?> test(BaseRequestOptions<?> requestOptions) {
+    return requestOptions.centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideOptions.java
new file mode 100644
index 000000000..6c20113cb
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideOptions.java
@@ -0,0 +1,639 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see Extension
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return new GlideOptions().sizeMultiplier(value);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy strategy) {
+    return new GlideOptions().diskCacheStrategy(strategy);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority priority) {
+    return new GlideOptions().priority(priority);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable drawable) {
+    return new GlideOptions().placeholder(drawable);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int id) {
+    return new GlideOptions().placeholder(id);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable drawable) {
+    return new GlideOptions().error(drawable);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int id) {
+    return new GlideOptions().error(id);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int value0,
+      @IntRange(from = 0) int value1) {
+    return new GlideOptions().override(value0, value1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int value) {
+    return new GlideOptions().override(value);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key key) {
+    return new GlideOptions().signature(key);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> transformation) {
+    return new GlideOptions().transform(transformation);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> option, @NonNull T t) {
+    return new GlideOptions().set(option, t);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> clazz) {
+    return new GlideOptions().decode(clazz);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat format) {
+    return new GlideOptions().format(format);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long value) {
+    return new GlideOptions().frame(value);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy strategy) {
+    return new GlideOptions().downsample(strategy);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int value) {
+    return new GlideOptions().timeout(value);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int value) {
+    return new GlideOptions().encodeQuality(value);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat format) {
+    return new GlideOptions().encodeFormat(format);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return (GlideOptions) super.sizeMultiplier(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    return (GlideOptions) super.diskCacheStrategy(strategy);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions priority(@NonNull Priority priority) {
+    return (GlideOptions) super.priority(priority);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions placeholder(@Nullable Drawable drawable) {
+    return (GlideOptions) super.placeholder(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions placeholder(@DrawableRes int id) {
+    return (GlideOptions) super.placeholder(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fallback(@Nullable Drawable drawable) {
+    return (GlideOptions) super.fallback(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fallback(@DrawableRes int id) {
+    return (GlideOptions) super.fallback(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions error(@Nullable Drawable drawable) {
+    return (GlideOptions) super.error(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions error(@DrawableRes int id) {
+    return (GlideOptions) super.error(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions theme(@Nullable Resources.Theme theme) {
+    return (GlideOptions) super.theme(theme);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions signature(@NonNull Key key) {
+    return (GlideOptions) super.signature(key);
+  }
+
+  @Override
+  @CheckResult
+  public GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions set(@NonNull Option<Y> option, @NonNull Y y) {
+    return (GlideOptions) super.set(option, y);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions decode(@NonNull Class<?> clazz) {
+    return (GlideOptions) super.decode(clazz);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return (GlideOptions) super.encodeFormat(format);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int value) {
+    return (GlideOptions) super.encodeQuality(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions frame(@IntRange(from = 0) long value) {
+    return (GlideOptions) super.frame(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions format(@NonNull DecodeFormat format) {
+    return (GlideOptions) super.format(format);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions downsample(@NonNull DownsampleStrategy strategy) {
+    return (GlideOptions) super.downsample(strategy);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions timeout(@IntRange(from = 0) int value) {
+    return (GlideOptions) super.timeout(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions transform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideOptions) super.transform(transformation);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideOptions) super.transforms(transformations);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideOptions) super.optionalTransform(transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions optionalTransform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideOptions) super.optionalTransform(clazz, transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions transform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideOptions) super.transform(clazz, transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions apply(@NonNull BaseRequestOptions<?> options) {
+    return (GlideOptions) super.apply(options);
+  }
+
+  @Override
+  @NonNull
+  public GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see Extension#test(BaseRequestOptions)
+   */
+  @SuppressWarnings("unchecked")
+  @CheckResult
+  @NonNull
+  public GlideOptions test() {
+    return (GlideOptions) Extension.test(this);
+  }
+
+  /**
+   * @see Extension#test(BaseRequestOptions)
+   */
+  @CheckResult
+  public static GlideOptions testSomething() {
+    return new GlideOptions().test();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideRequest.java
new file mode 100644
index 000000000..18fb054fb
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideRequest.java
@@ -0,0 +1,582 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.RequestListener;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link com.bumptech.glide.request.RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see com.bumptech.glide.request.RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return (GlideRequest<TranscodeType>) super.sizeMultiplier(value);
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.useAnimationPool(flag);
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.onlyRetrieveFromCache(flag);
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    return (GlideRequest<TranscodeType>) super.diskCacheStrategy(strategy);
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority priority) {
+    return (GlideRequest<TranscodeType>) super.priority(priority);
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.placeholder(drawable);
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.placeholder(id);
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.fallback(drawable);
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.fallback(id);
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.error(drawable);
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.error(id);
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme theme) {
+    return (GlideRequest<TranscodeType>) super.theme(theme);
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    return (GlideRequest<TranscodeType>) super.skipMemoryCache(skip);
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    return (GlideRequest<TranscodeType>) super.override(width, height);
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    return (GlideRequest<TranscodeType>) super.override(size);
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key key) {
+    return (GlideRequest<TranscodeType>) super.signature(key);
+  }
+
+  /**
+   * @see GlideOptions#set(Option<Y>, Y)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> set(@NonNull Option<Y> option, @NonNull Y y) {
+    return (GlideRequest<TranscodeType>) super.set(option, y);
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> clazz) {
+    return (GlideRequest<TranscodeType>) super.decode(clazz);
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return (GlideRequest<TranscodeType>) super.encodeFormat(format);
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int value) {
+    return (GlideRequest<TranscodeType>) super.encodeQuality(value);
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long value) {
+    return (GlideRequest<TranscodeType>) super.frame(value);
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat format) {
+    return (GlideRequest<TranscodeType>) super.format(format);
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    return (GlideRequest<TranscodeType>) super.disallowHardwareConfig();
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy strategy) {
+    return (GlideRequest<TranscodeType>) super.downsample(strategy);
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int value) {
+    return (GlideRequest<TranscodeType>) super.timeout(value);
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    return (GlideRequest<TranscodeType>) super.optionalCenterCrop();
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerCrop() {
+    return (GlideRequest<TranscodeType>) super.centerCrop();
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    return (GlideRequest<TranscodeType>) super.optionalFitCenter();
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    return (GlideRequest<TranscodeType>) super.fitCenter();
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    return (GlideRequest<TranscodeType>) super.optionalCenterInside();
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    return (GlideRequest<TranscodeType>) super.centerInside();
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    return (GlideRequest<TranscodeType>) super.optionalCircleCrop();
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    return (GlideRequest<TranscodeType>) super.circleCrop();
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideRequest<TranscodeType>) super.transform(transformation);
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideRequest<TranscodeType>) super.transforms(transformations);
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideRequest<TranscodeType>) super.optionalTransform(transformation);
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<Y>, Transformation<Y>)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideRequest<TranscodeType>) super.optionalTransform(clazz, transformation);
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<Y>, Transformation<Y>)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> transform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideRequest<TranscodeType>) super.transform(clazz, transformation);
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    return (GlideRequest<TranscodeType>) super.dontTransform();
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    return (GlideRequest<TranscodeType>) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull BaseRequestOptions<?> options) {
+    return (GlideRequest<TranscodeType>) super.apply(options);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> options) {
+    return (GlideRequest<TranscodeType>) super.transition(options);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> listener) {
+    return (GlideRequest<TranscodeType>) super.listener(listener);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> addListener(@Nullable RequestListener<TranscodeType> listener) {
+    return (GlideRequest<TranscodeType>) super.addListener(listener);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> builder) {
+    return (GlideRequest<TranscodeType>) super.error(builder);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> builder) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(builder);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... builders) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(builders);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object o) {
+    return (GlideRequest<TranscodeType>) super.load(o);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap bitmap) {
+    return (GlideRequest<TranscodeType>) super.load(bitmap);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.load(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String string) {
+    return (GlideRequest<TranscodeType>) super.load(string);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri uri) {
+    return (GlideRequest<TranscodeType>) super.load(uri);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File file) {
+    return (GlideRequest<TranscodeType>) super.load(file);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer id) {
+    return (GlideRequest<TranscodeType>) super.load(id);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL url) {
+    return (GlideRequest<TranscodeType>) super.load(url);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] bytes) {
+    return (GlideRequest<TranscodeType>) super.load(bytes);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+
+  /**
+   * @see Extension#test(BaseRequestOptions)
+   */
+  @SuppressWarnings("unchecked")
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> test() {
+    return (GlideRequest<TranscodeType>) Extension.test(this);
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/ExtensionWithOption.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/ExtensionWithOption.java
new file mode 100644
index 000000000..a82329934
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/ExtensionWithOption.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.test;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.BaseRequestOptions;
+
+@GlideExtension
+public final class ExtensionWithOption {
+
+  private ExtensionWithOption() {
+    // Utility class.
+  }
+
+  @NonNull
+  @GlideOption
+  public static BaseRequestOptions<?> squareThumb(BaseRequestOptions<?> requestOptions) {
+    return requestOptions.centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideOptions.java
new file mode 100644
index 000000000..ce0df8dd7
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideOptions.java
@@ -0,0 +1,639 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see ExtensionWithOption
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return new GlideOptions().sizeMultiplier(value);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy strategy) {
+    return new GlideOptions().diskCacheStrategy(strategy);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority priority) {
+    return new GlideOptions().priority(priority);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable drawable) {
+    return new GlideOptions().placeholder(drawable);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int id) {
+    return new GlideOptions().placeholder(id);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable drawable) {
+    return new GlideOptions().error(drawable);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int id) {
+    return new GlideOptions().error(id);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int value0,
+      @IntRange(from = 0) int value1) {
+    return new GlideOptions().override(value0, value1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int value) {
+    return new GlideOptions().override(value);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key key) {
+    return new GlideOptions().signature(key);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> transformation) {
+    return new GlideOptions().transform(transformation);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> option, @NonNull T t) {
+    return new GlideOptions().set(option, t);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> clazz) {
+    return new GlideOptions().decode(clazz);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat format) {
+    return new GlideOptions().format(format);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long value) {
+    return new GlideOptions().frame(value);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy strategy) {
+    return new GlideOptions().downsample(strategy);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int value) {
+    return new GlideOptions().timeout(value);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int value) {
+    return new GlideOptions().encodeQuality(value);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat format) {
+    return new GlideOptions().encodeFormat(format);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return (GlideOptions) super.sizeMultiplier(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    return (GlideOptions) super.diskCacheStrategy(strategy);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions priority(@NonNull Priority priority) {
+    return (GlideOptions) super.priority(priority);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions placeholder(@Nullable Drawable drawable) {
+    return (GlideOptions) super.placeholder(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions placeholder(@DrawableRes int id) {
+    return (GlideOptions) super.placeholder(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fallback(@Nullable Drawable drawable) {
+    return (GlideOptions) super.fallback(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fallback(@DrawableRes int id) {
+    return (GlideOptions) super.fallback(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions error(@Nullable Drawable drawable) {
+    return (GlideOptions) super.error(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions error(@DrawableRes int id) {
+    return (GlideOptions) super.error(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions theme(@Nullable Resources.Theme theme) {
+    return (GlideOptions) super.theme(theme);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions signature(@NonNull Key key) {
+    return (GlideOptions) super.signature(key);
+  }
+
+  @Override
+  @CheckResult
+  public GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions set(@NonNull Option<Y> option, @NonNull Y y) {
+    return (GlideOptions) super.set(option, y);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions decode(@NonNull Class<?> clazz) {
+    return (GlideOptions) super.decode(clazz);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return (GlideOptions) super.encodeFormat(format);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int value) {
+    return (GlideOptions) super.encodeQuality(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions frame(@IntRange(from = 0) long value) {
+    return (GlideOptions) super.frame(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions format(@NonNull DecodeFormat format) {
+    return (GlideOptions) super.format(format);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions downsample(@NonNull DownsampleStrategy strategy) {
+    return (GlideOptions) super.downsample(strategy);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions timeout(@IntRange(from = 0) int value) {
+    return (GlideOptions) super.timeout(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions transform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideOptions) super.transform(transformation);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideOptions) super.transforms(transformations);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideOptions) super.optionalTransform(transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions optionalTransform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideOptions) super.optionalTransform(clazz, transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions transform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideOptions) super.transform(clazz, transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions apply(@NonNull BaseRequestOptions<?> options) {
+    return (GlideOptions) super.apply(options);
+  }
+
+  @Override
+  @NonNull
+  public GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see ExtensionWithOption#squareThumb(BaseRequestOptions)
+   */
+  @SuppressWarnings("unchecked")
+  @CheckResult
+  @NonNull
+  public GlideOptions squareThumb() {
+    return (GlideOptions) ExtensionWithOption.squareThumb(this);
+  }
+
+  /**
+   * @see ExtensionWithOption#squareThumb(BaseRequestOptions)
+   */
+  @CheckResult
+  public static GlideOptions squareThumbOf() {
+    return new GlideOptions().squareThumb();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideRequest.java
new file mode 100644
index 000000000..51f731b2b
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideRequest.java
@@ -0,0 +1,582 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.RequestListener;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link com.bumptech.glide.request.RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see com.bumptech.glide.request.RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return (GlideRequest<TranscodeType>) super.sizeMultiplier(value);
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.useAnimationPool(flag);
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.onlyRetrieveFromCache(flag);
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    return (GlideRequest<TranscodeType>) super.diskCacheStrategy(strategy);
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority priority) {
+    return (GlideRequest<TranscodeType>) super.priority(priority);
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.placeholder(drawable);
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.placeholder(id);
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.fallback(drawable);
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.fallback(id);
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.error(drawable);
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.error(id);
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme theme) {
+    return (GlideRequest<TranscodeType>) super.theme(theme);
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    return (GlideRequest<TranscodeType>) super.skipMemoryCache(skip);
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    return (GlideRequest<TranscodeType>) super.override(width, height);
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    return (GlideRequest<TranscodeType>) super.override(size);
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key key) {
+    return (GlideRequest<TranscodeType>) super.signature(key);
+  }
+
+  /**
+   * @see GlideOptions#set(Option<Y>, Y)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> set(@NonNull Option<Y> option, @NonNull Y y) {
+    return (GlideRequest<TranscodeType>) super.set(option, y);
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> clazz) {
+    return (GlideRequest<TranscodeType>) super.decode(clazz);
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return (GlideRequest<TranscodeType>) super.encodeFormat(format);
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int value) {
+    return (GlideRequest<TranscodeType>) super.encodeQuality(value);
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long value) {
+    return (GlideRequest<TranscodeType>) super.frame(value);
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat format) {
+    return (GlideRequest<TranscodeType>) super.format(format);
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    return (GlideRequest<TranscodeType>) super.disallowHardwareConfig();
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy strategy) {
+    return (GlideRequest<TranscodeType>) super.downsample(strategy);
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int value) {
+    return (GlideRequest<TranscodeType>) super.timeout(value);
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    return (GlideRequest<TranscodeType>) super.optionalCenterCrop();
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerCrop() {
+    return (GlideRequest<TranscodeType>) super.centerCrop();
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    return (GlideRequest<TranscodeType>) super.optionalFitCenter();
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    return (GlideRequest<TranscodeType>) super.fitCenter();
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    return (GlideRequest<TranscodeType>) super.optionalCenterInside();
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    return (GlideRequest<TranscodeType>) super.centerInside();
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    return (GlideRequest<TranscodeType>) super.optionalCircleCrop();
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    return (GlideRequest<TranscodeType>) super.circleCrop();
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideRequest<TranscodeType>) super.transform(transformation);
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideRequest<TranscodeType>) super.transforms(transformations);
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideRequest<TranscodeType>) super.optionalTransform(transformation);
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<Y>, Transformation<Y>)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideRequest<TranscodeType>) super.optionalTransform(clazz, transformation);
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<Y>, Transformation<Y>)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> transform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideRequest<TranscodeType>) super.transform(clazz, transformation);
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    return (GlideRequest<TranscodeType>) super.dontTransform();
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    return (GlideRequest<TranscodeType>) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull BaseRequestOptions<?> options) {
+    return (GlideRequest<TranscodeType>) super.apply(options);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> options) {
+    return (GlideRequest<TranscodeType>) super.transition(options);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> listener) {
+    return (GlideRequest<TranscodeType>) super.listener(listener);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> addListener(@Nullable RequestListener<TranscodeType> listener) {
+    return (GlideRequest<TranscodeType>) super.addListener(listener);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> builder) {
+    return (GlideRequest<TranscodeType>) super.error(builder);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> builder) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(builder);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... builders) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(builders);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object o) {
+    return (GlideRequest<TranscodeType>) super.load(o);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap bitmap) {
+    return (GlideRequest<TranscodeType>) super.load(bitmap);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.load(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String string) {
+    return (GlideRequest<TranscodeType>) super.load(string);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri uri) {
+    return (GlideRequest<TranscodeType>) super.load(uri);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File file) {
+    return (GlideRequest<TranscodeType>) super.load(file);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer id) {
+    return (GlideRequest<TranscodeType>) super.load(id);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL url) {
+    return (GlideRequest<TranscodeType>) super.load(url);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] bytes) {
+    return (GlideRequest<TranscodeType>) super.load(bytes);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+
+  /**
+   * @see ExtensionWithOption#squareThumb(BaseRequestOptions)
+   */
+  @SuppressWarnings("unchecked")
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> squareThumb() {
+    return (GlideRequest<TranscodeType>) ExtensionWithOption.squareThumb(this);
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/ExtensionWithType.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/ExtensionWithType.java
new file mode 100644
index 000000000..1d58e6ff0
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/ExtensionWithType.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.test;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideType;
+
+@GlideExtension
+public final class ExtensionWithType {
+
+  private ExtensionWithType() {
+    // Utility class.
+  }
+
+  @NonNull
+  @GlideType(Number.class)
+  public static RequestBuilder<Number> asNumber(RequestBuilder<Number> builder) {
+    return builder;
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideOptions.java
new file mode 100644
index 000000000..435ea9275
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideOptions.java
@@ -0,0 +1,621 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see ExtensionWithType
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return new GlideOptions().sizeMultiplier(value);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy strategy) {
+    return new GlideOptions().diskCacheStrategy(strategy);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority priority) {
+    return new GlideOptions().priority(priority);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable drawable) {
+    return new GlideOptions().placeholder(drawable);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int id) {
+    return new GlideOptions().placeholder(id);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable drawable) {
+    return new GlideOptions().error(drawable);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int id) {
+    return new GlideOptions().error(id);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int value0,
+      @IntRange(from = 0) int value1) {
+    return new GlideOptions().override(value0, value1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int value) {
+    return new GlideOptions().override(value);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key key) {
+    return new GlideOptions().signature(key);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> transformation) {
+    return new GlideOptions().transform(transformation);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> option, @NonNull T t) {
+    return new GlideOptions().set(option, t);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> clazz) {
+    return new GlideOptions().decode(clazz);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat format) {
+    return new GlideOptions().format(format);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long value) {
+    return new GlideOptions().frame(value);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy strategy) {
+    return new GlideOptions().downsample(strategy);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int value) {
+    return new GlideOptions().timeout(value);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int value) {
+    return new GlideOptions().encodeQuality(value);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat format) {
+    return new GlideOptions().encodeFormat(format);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return (GlideOptions) super.sizeMultiplier(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    return (GlideOptions) super.diskCacheStrategy(strategy);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions priority(@NonNull Priority priority) {
+    return (GlideOptions) super.priority(priority);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions placeholder(@Nullable Drawable drawable) {
+    return (GlideOptions) super.placeholder(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions placeholder(@DrawableRes int id) {
+    return (GlideOptions) super.placeholder(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fallback(@Nullable Drawable drawable) {
+    return (GlideOptions) super.fallback(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fallback(@DrawableRes int id) {
+    return (GlideOptions) super.fallback(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions error(@Nullable Drawable drawable) {
+    return (GlideOptions) super.error(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions error(@DrawableRes int id) {
+    return (GlideOptions) super.error(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions theme(@Nullable Resources.Theme theme) {
+    return (GlideOptions) super.theme(theme);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions signature(@NonNull Key key) {
+    return (GlideOptions) super.signature(key);
+  }
+
+  @Override
+  @CheckResult
+  public GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions set(@NonNull Option<Y> option, @NonNull Y y) {
+    return (GlideOptions) super.set(option, y);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions decode(@NonNull Class<?> clazz) {
+    return (GlideOptions) super.decode(clazz);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return (GlideOptions) super.encodeFormat(format);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int value) {
+    return (GlideOptions) super.encodeQuality(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions frame(@IntRange(from = 0) long value) {
+    return (GlideOptions) super.frame(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions format(@NonNull DecodeFormat format) {
+    return (GlideOptions) super.format(format);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions downsample(@NonNull DownsampleStrategy strategy) {
+    return (GlideOptions) super.downsample(strategy);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions timeout(@IntRange(from = 0) int value) {
+    return (GlideOptions) super.timeout(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions transform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideOptions) super.transform(transformation);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideOptions) super.transforms(transformations);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideOptions) super.optionalTransform(transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions optionalTransform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideOptions) super.optionalTransform(clazz, transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions transform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideOptions) super.transform(clazz, transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions apply(@NonNull BaseRequestOptions<?> options) {
+    return (GlideOptions) super.apply(options);
+  }
+
+  @Override
+  @NonNull
+  public GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java
new file mode 100644
index 000000000..e0d0ad1d9
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java
@@ -0,0 +1,190 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
+import com.bumptech.glide.manager.Lifecycle;
+import com.bumptech.glide.manager.RequestManagerTreeNode;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Number;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Includes all additions from methods in {@link com.bumptech.glide.annotation.GlideExtension}s
+ * annotated with {@link com.bumptech.glide.annotation.GlideType}
+ *
+ * <p>Generated code, do not modify
+ */
+@SuppressWarnings("deprecation")
+public class GlideRequests extends RequestManager {
+  public GlideRequests(@NonNull Glide glide, @NonNull Lifecycle lifecycle,
+      @NonNull RequestManagerTreeNode treeNode, @NonNull Context context) {
+    super(glide, lifecycle, treeNode, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  public <ResourceType> GlideRequest<ResourceType> as(@NonNull Class<ResourceType> resourceClass) {
+    return new GlideRequest<>(glide, this, resourceClass, context);
+  }
+
+  /**
+   * @see ExtensionWithType#asNumber(RequestBuilder)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<Number> asNumber() {
+    return (GlideRequest<Number>) ExtensionWithType.asNumber(this.as(Number.class));
+  }
+
+  @Override
+  @NonNull
+  public GlideRequests applyDefaultRequestOptions(@NonNull RequestOptions options) {
+    return (GlideRequests) super.applyDefaultRequestOptions(options);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequests setDefaultRequestOptions(@NonNull RequestOptions options) {
+    return (GlideRequests) super.setDefaultRequestOptions(options);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {
+    return (GlideRequests) super.addDefaultRequestListener(listener);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Bitmap> asBitmap() {
+    return (GlideRequest<Bitmap>) super.asBitmap();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<GifDrawable> asGif() {
+    return (GlideRequest<GifDrawable>) super.asGif();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> asDrawable() {
+    return (GlideRequest<Drawable>) super.asDrawable();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Bitmap bitmap) {
+    return (GlideRequest<Drawable>) super.load(bitmap);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Drawable drawable) {
+    return (GlideRequest<Drawable>) super.load(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable String string) {
+    return (GlideRequest<Drawable>) super.load(string);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Uri uri) {
+    return (GlideRequest<Drawable>) super.load(uri);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable File file) {
+    return (GlideRequest<Drawable>) super.load(file);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@RawRes @DrawableRes @Nullable Integer id) {
+    return (GlideRequest<Drawable>) super.load(id);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable URL url) {
+    return (GlideRequest<Drawable>) super.load(url);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable byte[] bytes) {
+    return (GlideRequest<Drawable>) super.load(bytes);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Object o) {
+    return (GlideRequest<Drawable>) super.load(o);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<File> downloadOnly() {
+    return (GlideRequest<File>) super.downloadOnly();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<File> download(@Nullable Object o) {
+    return (GlideRequest<File>) super.download(o);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<File> asFile() {
+    return (GlideRequest<File>) super.asFile();
+  }
+
+  @Override
+  protected void setRequestOptions(@NonNull RequestOptions toSet) {
+    if (toSet instanceof com.bumptech.glide.test.GlideOptions) {
+      super.setRequestOptions(toSet);
+    } else {
+      super.setRequestOptions(new com.bumptech.glide.test.GlideOptions().apply(toSet));
+    }
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/MultipleAppGlideModuleTest/EmptyAppModule1.java b/annotation/compiler/test/src/test/resources/MultipleAppGlideModuleTest/EmptyAppModule1.java
new file mode 100644
index 000000000..a05259d66
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/MultipleAppGlideModuleTest/EmptyAppModule1.java
@@ -0,0 +1,7 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
+
+@GlideModule
+public final class EmptyAppModule1 extends AppGlideModule {}
\ No newline at end of file
diff --git a/annotation/compiler/test/src/test/resources/MultipleAppGlideModuleTest/EmptyAppModule2.java b/annotation/compiler/test/src/test/resources/MultipleAppGlideModuleTest/EmptyAppModule2.java
new file mode 100644
index 000000000..fb46c0c13
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/MultipleAppGlideModuleTest/EmptyAppModule2.java
@@ -0,0 +1,7 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
+
+@GlideModule
+public final class EmptyAppModule2 extends AppGlideModule {}
\ No newline at end of file
diff --git a/annotation/compiler/test/src/test/resources/MultipleEmptyLibraryGlideModuleTest/EmptyLibraryModule1.java b/annotation/compiler/test/src/test/resources/MultipleEmptyLibraryGlideModuleTest/EmptyLibraryModule1.java
new file mode 100644
index 000000000..236008a91
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/MultipleEmptyLibraryGlideModuleTest/EmptyLibraryModule1.java
@@ -0,0 +1,7 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.LibraryGlideModule;
+
+@GlideModule
+public final class EmptyLibraryModule1 extends LibraryGlideModule {}
diff --git a/annotation/compiler/test/src/test/resources/MultipleEmptyLibraryGlideModuleTest/EmptyLibraryModule2.java b/annotation/compiler/test/src/test/resources/MultipleEmptyLibraryGlideModuleTest/EmptyLibraryModule2.java
new file mode 100644
index 000000000..8a43eb292
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/MultipleEmptyLibraryGlideModuleTest/EmptyLibraryModule2.java
@@ -0,0 +1,7 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.LibraryGlideModule;
+
+@GlideModule
+public final class EmptyLibraryModule2 extends LibraryGlideModule {}
diff --git a/annotation/compiler/test/src/test/resources/MultipleEmptyLibraryGlideModuleTest/GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule1_com_bumptech_glide_test_EmptyLibraryModule2.java b/annotation/compiler/test/src/test/resources/MultipleEmptyLibraryGlideModuleTest/GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule1_com_bumptech_glide_test_EmptyLibraryModule2.java
new file mode 100644
index 000000000..d4284aa69
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/MultipleEmptyLibraryGlideModuleTest/GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule1_com_bumptech_glide_test_EmptyLibraryModule2.java
@@ -0,0 +1,10 @@
+package com.bumptech.glide.annotation.compiler;
+
+@Index(
+    modules = {
+        "com.bumptech.glide.test.EmptyLibraryModule1",
+        "com.bumptech.glide.test.EmptyLibraryModule2"
+    }
+)
+public class GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule1_com_bumptech_glide_test_EmptyLibraryModule2 {
+}
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/Excludes.java b/annotation/src/main/java/com/bumptech/glide/annotation/Excludes.java
index 0a15f5a0d..13de814b2 100644
--- a/annotation/src/main/java/com/bumptech/glide/annotation/Excludes.java
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/Excludes.java
@@ -16,5 +16,5 @@
 @Target(ElementType.TYPE)
 @Retention(RetentionPolicy.RUNTIME)
 public @interface Excludes {
-  Class[] value();
+  Class<?>[] value();
 }
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/GlideModule.java b/annotation/src/main/java/com/bumptech/glide/annotation/GlideModule.java
index 679eb8bce..dc91418e2 100644
--- a/annotation/src/main/java/com/bumptech/glide/annotation/GlideModule.java
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideModule.java
@@ -16,7 +16,7 @@
 public @interface GlideModule {
   /**
    * Returns the name of the class that will be used as a replacement for
-   * {@link com.bumptech.glide.Glide} in Applications that depend on Glide's generated code.
+   * {@code com.bumptech.glide.Glide} in Applications that depend on Glide's generated code.
    */
   String glideName() default "GlideApp";
 }
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java b/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java
index 50bfbecb0..58197a802 100644
--- a/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java
@@ -7,16 +7,64 @@
 
 /**
  * Identifies methods in {@link GlideExtension} annotated classes that extend
- * {@link com.bumptech.glide.request.RequestOptions}.
+ * {@code com.bumptech.glide.request.RequestOptions}.
  *
  * <p>All annotated methods will be added to a single
- * {@link com.bumptech.glide.request.RequestOptions} implementation generated per application.
+ * {@code com.bumptech.glide.request.RequestOptions} implementation generated per application.
  * Overlapping method names in different extensions may cause errors at compile time.
  *
  * <p>Static equivalents of annotated methods will also be generated.
  *
  * <p>Methods with this annotation will only be found if they belong to classes annotated with
  * {@link GlideExtension}.
+ *
+ * <p>The preferred way of writing extension methods returns the provided
+ * {@code com.bumptech.glide.request.RequestOptions} object with one or more methods called on it.
+ * You must not return a newly instantiated {@code com.bumptech.glide.request.RequestOptions} object
+ * as doing so my cause a {@code ClassCastException} at runtime. Calling either
+ * {@code com.bumptech.glide.request.RequestOptions#autoClone()} or
+ * {@code com.bumptech.glide.request.RequestOptions#lock()} is safe, but unnecessary and should
+ * typically be avoided. The preferred style looks like:
+ *
+ * <pre>
+ * {@code
+ * {@link @}GlideExtension
+ * public class MyExtension {
+ *   private MyExtension() {}
+ *
+ *   {@literal @}GlideOption
+ *   public static RequestOptions myOption(RequestOptions options) {
+ *     return options
+ *         .optionOne()
+ *         .optionTwo();
+ *   }
+ * }
+ * }
+ * </pre>
+ *
+ * <p>The deprecated way of writing extension methods is simply a static void method. The
+ * {@code com.bumptech.glide.request.RequestOptions} object is cloned before it is passed to this
+ * method to avoid an option method returning a new instance, but using methods like
+ * {@code com.bumptech.glide.request.RequestOptions#clone()} or
+ * {@code com.bumptech.glide.request.RequestOptions#autoClone()} can result in options applied in
+ * the method being silently ignored. Prefer the new style whenever possible.
+ *
+ * <pre>
+ * {@code
+ * {@literal @}GlideExtension
+ * public class MyExtension {
+ *   private MyExtension() {}
+ *
+ *   // Deprecated! Use the new style of GlideOption extensions instead.
+ *   {@literal @}GlideOption
+ *   public static void myOption(RequestOptions options) {
+ *     options
+ *         .optionOne()
+ *         .optionTwo();
+ *   }
+ * }
+ * }
+ * </pre>
  */
 @Target(ElementType.METHOD)
 // Needs to be parsed from class files in JAR.
@@ -51,7 +99,7 @@
 
   /**
    * {@code true} to indicate that it's safe to statically memoize the result of this method using
-   * {@link com.bumptech.glide.request.RequestOptions#autoClone()}.
+   * {@code com.bumptech.glide.request.RequestOptions#autoClone()}.
    *
    * <p>This method should only be used for no-arg methods where there's only a single possible
    * value.
@@ -65,8 +113,8 @@
    *
    * <p>By default static methods are generated for all methods annotated with
    * {@link GlideOption}. These static factory methods allow for a cleaner API when used
-   * with {@link com.bumptech.glide.RequestBuilder#apply}. The static factory method by default
-   * simply creates a new {@link com.bumptech.glide.request.RequestOptions} object, calls the
+   * with {@code com.bumptech.glide.RequestBuilder#apply}. The static factory method by default
+   * simply creates a new {@code com.bumptech.glide.request.RequestOptions} object, calls the
    * instance version of the method on it and returns it. For example:
    * <pre>
    * <code>
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/GlideType.java b/annotation/src/main/java/com/bumptech/glide/annotation/GlideType.java
index f0c19a599..d3538d99b 100644
--- a/annotation/src/main/java/com/bumptech/glide/annotation/GlideType.java
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideType.java
@@ -7,10 +7,10 @@
 
 /**
  * Identifies methods in {@link GlideExtension} annotated classes that extend
- * {@link com.bumptech.glide.RequestManager}.
+ * {@code com.bumptech.glide.RequestManager}.
  *
  * <p>If one or more method is found with this annotation, an additional API entry point that
- * exposes a generated {@link com.bumptech.glide.RequestManager} subclass will be created. The
+ * exposes a generated {@code com.bumptech.glide.RequestManager} subclass will be created. The
  * generated API entry point acts as a drop in replacement for Glide. Glide.with(fragment) becomes
  * GlideApp.with(fragment). Although the Glide.with variant will still be available, only the new
  * API entry point will provide access to these additional methods.
@@ -22,8 +22,11 @@
  * with {@link GlideExtension}.
  *
  * <p>Methods annotated with GlideType must have a single parameter. The type of the
- * single parameter must be {@link com.bumptech.glide.request.RequestOptions}, with a type
+ * single parameter must be {@code com.bumptech.glide.RequestBuilder}, with a type
  * matching the value of {@link #value()}.
+ *
+ * <p>Compilation will fail if a method annotated with this method is identical to a method in
+ * {@code com.bumptech.glide.RequestManager}
  */
 @Target(ElementType.METHOD)
 // Needs to be parsed from class files in JAR.
@@ -33,7 +36,8 @@
   /**
    * A Resource class name, like GifDrawable.class, Bitmap.class etc.
    *
-   * <p>Must match the type of the {@link com.bumptech.glide.request.RequestOptions} parameter.
+   * <p>Must match the type of the {@code com.bumptech.glide.RequestBuilder} parameter in the
+   * annotated method.
    */
   Class<?> value();
 }
diff --git a/build.gradle b/build.gradle
index 878aab49f..c689d6105 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,14 +1,24 @@
+import se.bjurr.violations.gradle.plugin.ViolationsTask
+import org.gradle.api.tasks.testing.logging.TestExceptionFormat
+
 buildscript {
     repositories {
+        google()
         jcenter()
         maven {
             url "https://oss.sonatype.org/content/repositories/snapshots"
         }
+        maven {
+            url "https://plugins.gradle.org/m2/"
+        }
     }
 
     dependencies {
         classpath "com.android.tools.build:gradle:${ANDROID_GRADLE_VERSION}"
-        classpath "org.kt3k.gradle.plugin:coveralls-gradle-plugin:${COVERALLS_GRADLE_VERSION}"
+        if (!hasProperty('DISABLE_ERROR_PRONE')) {
+            classpath "net.ltgt.gradle:gradle-errorprone-plugin:${ERROR_PRONE_PLUGIN_VERSION}"
+        }
+        classpath "se.bjurr.violations:violations-gradle-plugin:${VIOLATIONS_PLUGIN_VERSION}"
     }
 }
 
@@ -21,25 +31,70 @@ if (JavaVersion.current().isJava8Compatible()) {
     }
 }
 
-subprojects {
-    tasks.withType(JavaCompile) {
-        sourceCompatibility = 1.7
-        targetCompatibility = 1.7
-    }
-}
-
 subprojects { project ->
+
     repositories {
+        google()
         jcenter()
         maven {
             url "https://oss.sonatype.org/content/repositories/snapshots"
         }
     }
 
+    tasks.withType(JavaCompile) {
+        sourceCompatibility = 1.7
+        targetCompatibility = 1.7
+
+        options.setBootstrapClasspath(files("${System.getProperty('java.home')}/lib/rt.jar"))
+        // gifencoder is a legacy project that has a ton of warnings and is basically never
+        // modified, so we're not going to worry about cleaning it up.
+        if ("gifencoder" != project.getName()) {
+          options.compilerArgs \
+                /*
+                 * Treat all warnings as errors.
+                 */ \
+                << "-Werror" \
+                /*
+                 * Enable all warnings.
+                 */ \
+                << "-Xlint:all" \
+                /*
+                 * Java expects every annotation to have a processor, but we use
+                 * javax.annotation.Nullable, which doesn't have one.
+                 */ \
+                << "-Xlint:-processing" \
+                /*
+                 * See https://github.com/google/dagger/issues/945
+                 * and https://bugs.openjdk.java.net/browse/JDK-8190452
+                 */ \
+                << "-Xlint:-classfile" \
+                /*
+                 * Disable deprecation warnings for ViewTarget/BaseTarget for now.
+                 */ \
+                << "-Xlint:-deprecation"
+
+            if (project.plugins.hasPlugin('net.ltgt.errorprone')) {
+                // It's often useful to track individual objects when debugging object pooling.
+                options.compilerArgs << "-Xep:ObjectToString:OFF"
+            }
+        }
+    }
+
+    tasks.withType(Test) {
+        testLogging {
+            exceptionFormat = TestExceptionFormat.FULL
+        }
+    }
+
+    // Avoid issues like #2452.
+    tasks.withType(Jar) {
+        duplicatesStrategy = DuplicatesStrategy.FAIL
+    }
+
     apply plugin: 'checkstyle'
 
     checkstyle {
-        toolVersion = '6.12.1'
+        toolVersion = '8.5'
     }
 
     checkstyle {
@@ -51,25 +106,54 @@ subprojects { project ->
         source 'src'
         include '**/*.java'
         exclude '**/gen/**'
+        // Caught by the violations plugin.
+        ignoreFailures = true
 
         // empty classpath
         classpath = files()
     }
 
+    apply plugin: "se.bjurr.violations.violations-gradle-plugin"
+
+    task violations(type: ViolationsTask) {
+        minSeverity 'INFO'
+        detailLevel 'VERBOSE'
+        maxViolations = 0
+        diffMaxViolations = 0
+
+        // Formats are listed here: https://github.com/tomasbjerre/violations-lib
+        def dir = projectDir.absolutePath
+        violations = [
+                ["FINDBUGS",    dir, ".*/findbugs/.*\\.xml\$",   "Findbugs"],
+                ["PMD",         dir, ".*/pmd/.*\\.xml\$",        "PMD"],
+                ["ANDROIDLINT", dir, ".*/lint-results\\.xml\$",  "AndroidLint"],
+                ["CHECKSTYLE",  dir, ".*/checkstyle/.*\\.xml\$", "Checkstyle"],
+        ]
+    }
+
     afterEvaluate {
         if (project.tasks.findByName('check')) {
             check.dependsOn('checkstyle')
+            check.finalizedBy violations
         }
-    }
 
-    gradle.projectsEvaluated {
-        tasks.withType(JavaCompile) {
-            options.compilerArgs << '-Xlint:unchecked' << '-Xlint:deprecation'
+        if (project.hasProperty("android")
+                && project.name != 'pmd'
+                && project.name != 'findbugs') {
+            android {
+                lintOptions {
+                    warningsAsErrors true
+                    quiet true
+                    // Caught by the violations plugin.
+                    abortOnError false
+                }
+            }
+
+            android.variantFilter { variant ->
+                if(variant.buildType.name == 'release') {
+                    variant.setIgnore(true)
+                }
+            }
         }
     }
 }
-
-task wrapper(type: Wrapper) {
-    gradleVersion = '2.9'
-    distributionUrl = "https://services.gradle.org/distributions/gradle-${gradleVersion}-all.zip"
-}
diff --git a/checkstyle.xml b/checkstyle.xml
index 55273de62..52a2c2e5d 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -15,7 +15,9 @@
     </module>
 
     <!-- Ensure trailling newline for compatibility -->
-    <module name="NewlineAtEndOfFile" />
+    <module name="NewlineAtEndOfFile">
+        <property name="lineSeparator" value="lf"/>
+    </module>
 
     <!-- Space after 'for' and 'if' -->
     <module name="RegexpSingleline">
@@ -71,7 +73,7 @@
 
         <!-- Allow common trailing comments used to describe suppressions -->
         <module name="TrailingComment">
-          <property name="legalComment" value="Public API" />
+          <property name="legalComment" value="^Public API.?$|^NOPMD.*$" />
         </module>
 
         <!-- Checks for imports. -->
@@ -92,8 +94,16 @@
         <!-- Prevent importing Mockito matchers directly -->
         <module name="IllegalImport">
             <property name="illegalPkgs" value="org.mockito.internal" />
-            <message key="import.illegal" value="Import from illegal package - {0}. Use org.mockito.Matchers to instantiate argument matchers; or org.hamcrest.Matchers for assertThat." />
+            <message key="import.illegal" value="Import from illegal package - {0}. Use org.mockito.Matchers to instantiate argument matchers." />
+        </module>
+
+        <!-- ArgumentMatchers isn't available internally, the same methods are available on org.mockito.Mockito. -->
+        <module name="IllegalImport">
+            <property name="illegalClasses" value="org\.mockito\.ArgumentMatchers.*" />
+            <property name="regexp" value="true" />
+            <message key="import.illegal" value="Import from illegal class - {0}. Use org.mockito.Mockito to statically import matcher methods." />
         </module>
+
         <module name="ImportOrder">
           <!-- Checks for out of order import statements. -->
 
@@ -103,6 +113,7 @@
            <!-- This ensures that static imports go first. -->
            <property name="option" value="top"/>
            <property name="tokens" value="STATIC_IMPORT, IMPORT"/>
+           <property name="separated" value="true" />
          </module>
 
         <!-- Checks for whitespace. -->
@@ -127,7 +138,9 @@
 
         <!-- Checks for blocks. -->
         <!-- See http://checkstyle.sourceforge.net/config_blocks.html -->
-        <module name="AvoidNestedBlocks" />
+        <module name="AvoidNestedBlocks">
+          <property name="allowInSwitchCase" value="true" />
+        </module>
         <module name="EmptyBlock" >
             <property name="option" value="text"/>
         </module>
diff --git a/checkstyle_suppressions.xml b/checkstyle_suppressions.xml
index 9faf18dc8..1bfebbe01 100644
--- a/checkstyle_suppressions.xml
+++ b/checkstyle_suppressions.xml
@@ -5,7 +5,12 @@
     "http://www.puppycrawl.com/dtds/suppressions_1_1.dtd">
 
 <suppressions>
-    <suppress files=".*[/\\]library[/\\]src[/\\]test[/\\].*" checks="Javadoc.*"/>
+    <suppress files=".*[/\\]library[/\\]src[/\\]main[/\\]java[/\\]com[/\\]bumptech[/\\]glide[/\\]util[/\\]CachedHashCodeArrayMap.java" checks="EqualsHashCodeCheck"/>
+    <suppress files=".*[/\\]library[/\\]test[/\\]src[/\\]test[/\\].*" checks="Javadoc.*"/>
+    <suppress files=".*[/\\]annotation[/\\]compiler[/\\]test[/\\]src[/\\]test[/\\]resources[/\\].*" checks=".*"/>
+    <suppress files=".*[/\\]instrumentation[/\\]src[/\\].*" checks="Javadoc.*"/>
+    <suppress files=".*[/\\]instrumentation[/\\]src[/\\]androidTest[/\\].*" checks="Javadoc.*"/>
+    <suppress files=".*[/\\]instrumentation[/\\]src[/\\]androidTest[/\\].*[/\\]ResourceIds" checks=".*"/>
     <suppress files=".*[/\\]gif_encoder[/\\].*" checks=".*"/>
     <suppress files=".*RequestBuilder.java|ChildLoadProvider.java|TransitionOptions.java|BaseDecodeOptions.java|RequestOptions.java" checks="NoClone" />
 </suppressions>
diff --git a/debug.keystore b/debug.keystore
new file mode 100644
index 000000000..425f3d6a1
Binary files /dev/null and b/debug.keystore differ
diff --git a/gcloud-bumptech.json.enc b/gcloud-bumptech.json.enc
new file mode 100644
index 000000000..32dff8de0
Binary files /dev/null and b/gcloud-bumptech.json.enc differ
diff --git a/gcloud-sjudd.json.enc b/gcloud-sjudd.json.enc
new file mode 100644
index 000000000..1c9b64237
Binary files /dev/null and b/gcloud-sjudd.json.enc differ
diff --git a/glide/build.gradle b/glide/build.gradle
index 4e8216ad8..ac0ec536a 100644
--- a/glide/build.gradle
+++ b/glide/build.gradle
@@ -1,3 +1,5 @@
+import com.android.build.gradle.api.LibraryVariant
+
 apply plugin: 'java'
 
 // The paths of Android projects that should be included in the jar and javadoc.
@@ -16,22 +18,23 @@ static def getAndroidPathsForJavadoc() {
             ':integration:okhttp',
             ':integration:okhttp3',
             ':integration:volley',
-            ':integration:gifencoder'
+            ':integration:gifencoder',
+            ':integration:recyclerview'
     ]
 }
 
 // The paths of Java projects that should be included only in Javadoc, not in the jar.
 static def getJavaPathsForJavadoc() {
-    [':annotation', ':annotation:compiler']
+    [':annotation']
 }
 
 (getAndroidPathsForJavadoc() + getAndroidPathsForJar() +
-        getJavaPathsForJar() + getJavaPathsForJavadoc()).forEach {
+        getJavaPathsForJar() + getJavaPathsForJavadoc()).each {
     evaluationDependsOn(it)
 }
 
 def asProjects(paths) {
-    paths.collect { project(it) }
+    paths.collect { String path -> project(path) }
 }
 
 def getAndroidSdkDirectory() {
@@ -58,8 +61,8 @@ def getInternalJavaProjectsForJavadoc() {
     asProjects(getJavaPathsForJavadoc())
 }
 
-def getReleaseVariantAndroidProjectsForJar() {
-    getAndroidLibraryVariantsForJar('release')
+def getAndroidProjectsForJar() {
+    getAndroidLibraryVariantsForJar('debug')
 }
 
 def getAndroidLibraryVariantsForJar(variantName) {
@@ -79,12 +82,15 @@ static def getAndroidLibraryVariants(projects, variantName) {
 }
 
 def getSourceFilesForVariantJar(variantName) {
-    getAndroidLibraryVariantsForJar(variantName).collect { it.javaCompile.source } +
-            getInternalJavaProjectsForJar().collect { it.sourceSets.main.allJava }
+    getAndroidLibraryVariantsForJar(variantName).collect {
+        it.getJavaCompiler().source.findAll {
+            return !it.getName().equals("R.java") && !it.getName().equals("BuildConfig.java")
+        }
+    } + getInternalJavaProjectsForJar().collect { it.sourceSets.main.allJava }
 }
 
 def getSourceFilesForVariantJavadoc(variantName) {
-    getAndroidLibraryVariantsForJavadoc(variantName).collect { it.javaCompile.source } +
+    getAndroidLibraryVariantsForJavadoc(variantName).collect { it.getJavaCompiler().source } +
             getInternalJavaProjectsForJavadoc().collect { it.sourceSets.main.allJava }
 }
 
@@ -92,56 +98,55 @@ def getAndroidJar() {
     "${getAndroidSdkDirectory()}/platforms/${getAndroidCompileSdkVersion()}/android.jar"
 }
 
-def getSupportJar() {
-    "${getAndroidSdkDirectory()}/extras/android/support/v4/android-support-v4.jar"
-}
-
 project.archivesBaseName = "${POM_ARTIFACT_ID}-${VERSION_NAME}"
 
 // Generate javadocs and sources containing batched documentation and sources for all internal
 // projects.
-['release', 'debug'].each { variantName ->
+['debug'].each { variantName ->
 
     task("${variantName}SourceJar", type: Jar) {
-      from getSourceFilesForVariantJar(variantName)
+        from getSourceFilesForVariantJar(variantName)
     }
 
-    def javadocTask = task("${variantName}Javadoc", type: Javadoc) {
+    def javadocTask = tasks.create("${variantName}Javadoc", Javadoc) {
         source = getSourceFilesForVariantJar(variantName)
         source += getSourceFilesForVariantJavadoc(variantName)
 
-        def classpathFiles = files(getAndroidLibraryVariantsForJar(variantName).collect {
-            files(it.javaCompile.classpath.files, getAndroidJar(), getSupportJar())
-        })
-        classpathFiles += files(getAndroidLibraryVariantsForJavadoc(variantName).collect {
-            files(it.javaCompile.classpath.files, getAndroidJar(), getSupportJar())
-        })
-        classpathFiles += (getInternalJavaProjectsForJavadoc().collect {
-            it.sourceSets.main.compileClasspath.files
-        }.flatten())
-        classpathFiles += (getInternalJavaProjectsForJar().collect {
-            it.sourceSets.main.compileClasspath.files
-        }.flatten())
-        // Finds dependencies of Android packages that would otherwise be ignored (Volley in
-        // particular)
-        classpathFiles += getInternalAndroidProjectsForJavadoc().collect {
-            files("${it.projectDir}/build/intermediates/classes/release")
+        doFirst {
+            it.classpath =
+                    project.files(
+                            getAndroidJar(),
+                            getAndroidLibraryVariantsForJar(variantName).collect {
+                                LibraryVariant lib -> lib.getJavaCompiler().classpath.files
+                            },
+                            getAndroidLibraryVariantsForJavadoc(variantName).collect {
+                                LibraryVariant lib -> lib.getJavaCompiler().classpath.files
+                            },
+                            getInternalJavaProjectsForJavadoc().collect { Project project ->
+                                project.sourceSets.main.compileClasspath.files
+                            },
+                            getInternalJavaProjectsForJar().collect { Project project ->
+                                project.sourceSets.main.compileClasspath.files
+                            },
+                            // Finds dependencies of Android packages that would otherwise be
+                            // ignored (Volley in particular)
+                            getInternalAndroidProjectsForJavadoc().collect { Project project ->
+                                project.file('build/intermediates/classes/debug')
+                            }
+            )
         }
-        classpath = files(classpathFiles)
 
         options {
             links("http://docs.oracle.com/javase/7/docs/api/")
             links("https://square.github.io/okhttp/3.x/okhttp/")
             links("https://square.github.io/okhttp/2.x/okhttp/")
-            // TODO: Ideally this would point to something hosted by Android.
-            links("http://afzaln.com/volley/")
             linksOffline("http://d.android.com/reference",
                     "${getAndroidSdkDirectory()}/docs/reference")
         }
 
         exclude '**/BuildConfig.java'
         exclude '**/R.java'
-    } as Javadoc
+    }
 
     def cleanJavadocTask = task("clean${variantName.capitalize()}Javadoc", type: Delete) {
         delete javadocTask.destinationDir
@@ -156,31 +161,34 @@ project.archivesBaseName = "${POM_ARTIFACT_ID}-${VERSION_NAME}"
 
 jar {
     from files(
-            getReleaseVariantAndroidProjectsForJar().collect { variant ->
-                variant.javaCompile.destinationDir
+            getAndroidProjectsForJar().collect { LibraryVariant variant ->
+                variant.getJavaCompiler().destinationDir
             }
     )
+    from files(getInternalJavaProjectsForJar().collect { it.sourceSets.main.output })
     exclude "**/R.class"
     exclude "**/BuildConfig.class"
-    from files(getInternalJavaProjectsForJar().collect { it.sourceSets.main.output })
+    exclude "**/R\$*.class"
+    exclude "android/**"
 }
 
-def getAllInternalProjectBuildDeps() {
-    getInternalAndroidProjectsForJar() + getInternalJavaProjectsForJar() +
-            getInternalJavaProjectsForJavadoc() + getInternalAndroidProjectsForJavadoc()
+(getInternalAndroidProjectsForJar() + getInternalAndroidProjectsForJavadoc()).each {
+    project ->
+        debugJavadoc.dependsOn(project.tasks.compileDebugSources)
+        jar.dependsOn(project.tasks.compileDebugSources)
 }
 
-getAllInternalProjectBuildDeps().each { project ->
-    releaseJavadoc.dependsOn(project.tasks.assemble)
-    debugJavadoc.dependsOn(project.tasks.assemble)
-    jar.dependsOn(project.tasks.build)
+(getInternalJavaProjectsForJar() + getInternalJavaProjectsForJavadoc()).each {
+    project ->
+        debugJavadoc.dependsOn(project.tasks.compileJava)
+        jar.dependsOn(project.tasks.compileJava)
 }
 
 artifacts {
-    archives releaseJavadocJar {
+    archives debugJavadocJar {
         classifier 'javadoc'
     }
-    archives releaseSourceJar {
+    archives debugSourceJar {
         classifier 'sources'
     }
 }
diff --git a/gradle.properties b/gradle.properties
index d3d3049b1..0af4d3a62 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,9 +1,9 @@
 org.gradle.daemon=true
-org.gradle.configureondemand=true
+org.gradle.configureondemand=false
 
-VERSION_NAME=4.1.0-SNAPSHOT
+VERSION_NAME=4.9.0-SNAPSHOT
 VERSION_MAJOR=4
-VERSION_MINOR=1
+VERSION_MINOR=9
 VERSION_PATCH=0
 GROUP=com.github.bumptech.glide
 
@@ -15,25 +15,33 @@ POM_SCM_DEV_CONNECTION=scm:git@github.com:bumptech/glide.git
 POM_DEVELOPER_ID=sjudd
 POM_DEVELOPER_NAME=Sam Judd
 POM_DEVELOPER_EMAIL=judds@google.com
-SUPPORT_V4_VERSION=25.3.1
-SUPPORT_V7_VERSION=25.3.1
+ANDROID_SUPPORT_VERSION=27.1.1
+ANDROIDX_TEST_VERSION=1.1.0-alpha4
 VOLLEY_VERSION=1.0.0
-OK_HTTP_VERSION=3.0.1
-ANDROID_GRADLE_VERSION=2.3.0
+OK_HTTP_VERSION=3.9.1
+ANDROID_GRADLE_VERSION=3.1.3
+DAGGER_VERSION=2.11
 
-COVERALLS_GRADLE_VERSION=2.4.0
-JUNIT_VERSION=4.12
-MOCKITO_VERSION=1.10.19
-ROBOLECTRIC_VERSION=3.3.2
+JUNIT_VERSION=4.13-SNAPSHOT
+# Matches the version in Google.
+MOCKITO_VERSION=1.9.5
+MOCKITO_ANDROID_VERSION=2.21.0
+ROBOLECTRIC_VERSION=3.6.1
 MOCKWEBSERVER_VERSION=3.0.0-RC1
-TRUTH_VERSION=0.26
+TRUTH_VERSION=0.36
+JSR_305_VERSION=3.0.2
+AUTO_SERVICE_VERSION=1.0-rc3
+JAVAPOET_VERSION=1.9.0
 
+PMD_VERSION=6.0.0
 FINDBUGS_VERSION=3.0.0
-JACOCO_VERSION=0.7.1.201405082137
+ERROR_PRONE_VERSION=2.3.1
+ERROR_PRONE_PLUGIN_VERSION=0.0.13
+VIOLATIONS_PLUGIN_VERSION=1.8
 
-COMPILE_SDK_VERSION=25
-BUILD_TOOLS_VERSION=25.0.2
-TARGET_SDK_VERSION=25
+COMPILE_SDK_VERSION=27
+TARGET_SDK_VERSION=27
 MIN_SDK_VERSION=14
 
-org.gradle.jvmargs=-Xmx2048M
+org.gradle.jvmargs=-Xmx4096M
+TEST_JVM_MEMORY_SIZE=4096M
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index 941144813..f6b961fd5 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 06cc66097..9a4163a4f 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,5 @@
-#Fri Mar 31 22:27:21 PDT 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.6-all.zip
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip
diff --git a/gradlew b/gradlew
index 9d82f7891..cccdd3d51 100755
--- a/gradlew
+++ b/gradlew
@@ -1,4 +1,4 @@
-#!/usr/bin/env bash
+#!/usr/bin/env sh
 
 ##############################################################################
 ##
@@ -6,20 +6,38 @@
 ##
 ##############################################################################
 
-# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-DEFAULT_JVM_OPTS=""
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
 
 APP_NAME="Gradle"
 APP_BASE_NAME=`basename "$0"`
 
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
 # Use the maximum available, or set MAX_FD != -1 to use that value.
 MAX_FD="maximum"
 
-warn ( ) {
+warn () {
     echo "$*"
 }
 
-die ( ) {
+die () {
     echo
     echo "$*"
     echo
@@ -30,6 +48,7 @@ die ( ) {
 cygwin=false
 msys=false
 darwin=false
+nonstop=false
 case "`uname`" in
   CYGWIN* )
     cygwin=true
@@ -40,26 +59,11 @@ case "`uname`" in
   MINGW* )
     msys=true
     ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
 esac
 
-# Attempt to set APP_HOME
-# Resolve links: $0 may be a link
-PRG="$0"
-# Need this for relative symlinks.
-while [ -h "$PRG" ] ; do
-    ls=`ls -ld "$PRG"`
-    link=`expr "$ls" : '.*-> \(.*\)$'`
-    if expr "$link" : '/.*' > /dev/null; then
-        PRG="$link"
-    else
-        PRG=`dirname "$PRG"`"/$link"
-    fi
-done
-SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >/dev/null
-APP_HOME="`pwd -P`"
-cd "$SAVED" >/dev/null
-
 CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
 
 # Determine the Java command to use to start the JVM.
@@ -85,7 +89,7 @@ location of your Java installation."
 fi
 
 # Increase the maximum file descriptors if we can.
-if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
     MAX_FD_LIMIT=`ulimit -H -n`
     if [ $? -eq 0 ] ; then
         if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
@@ -150,11 +154,19 @@ if $cygwin ; then
     esac
 fi
 
-# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
-function splitJvmOpts() {
-    JVM_OPTS=("$@")
+# Escape application args
+save () {
+    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
+    echo " "
 }
-eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
-JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+APP_ARGS=$(save "$@")
+
+# Collect all arguments for the java command, following the shell quoting and substitution rules
+eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
+
+# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
+if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
+  cd "$(dirname "$0")"
+fi
 
-exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
+exec "$JAVACMD" "$@"
diff --git a/gradlew.bat b/gradlew.bat
index aec99730b..e95643d6a 100644
--- a/gradlew.bat
+++ b/gradlew.bat
@@ -8,14 +8,14 @@
 @rem Set local scope for the variables with windows NT shell
 if "%OS%"=="Windows_NT" setlocal
 
-@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-set DEFAULT_JVM_OPTS=
-
 set DIRNAME=%~dp0
 if "%DIRNAME%" == "" set DIRNAME=.
 set APP_BASE_NAME=%~n0
 set APP_HOME=%DIRNAME%
 
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
 @rem Find java.exe
 if defined JAVA_HOME goto findJavaFromJavaHome
 
@@ -46,10 +46,9 @@ echo location of your Java installation.
 goto fail
 
 :init
-@rem Get command-line arguments, handling Windowz variants
+@rem Get command-line arguments, handling Windows variants
 
 if not "%OS%" == "Windows_NT" goto win9xME_args
-if "%@eval[2+2]" == "4" goto 4NT_args
 
 :win9xME_args
 @rem Slurp the command line arguments.
@@ -60,11 +59,6 @@ set _SKIP=2
 if "x%~1" == "x" goto execute
 
 set CMD_LINE_ARGS=%*
-goto execute
-
-:4NT_args
-@rem Get arguments from the 4NT Shell from JP Software
-set CMD_LINE_ARGS=%$
 
 :execute
 @rem Setup the command line
diff --git a/instrumentation/build.gradle b/instrumentation/build.gradle
new file mode 100644
index 000000000..84c4dc6f2
--- /dev/null
+++ b/instrumentation/build.gradle
@@ -0,0 +1,48 @@
+tasks.whenTaskAdded { task ->
+    if (task.name == "lint") {
+        task.enabled = false
+    }
+}
+apply plugin: 'com.android.application'
+
+dependencies {
+    // Appcompat is required to ensure that Glide's runtime detection the v7 support Drawable
+    // loading classes functions. It's not clear why androidTestImplementation isn't sufficient, but for
+    // whatever reason, compile is the only dependency that seems to work.
+    implementation ("com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}") {
+        exclude group: 'android.arch.core'
+    }
+    annotationProcessor project(":annotation:compiler")
+    implementation project(":library")
+
+    androidTestImplementation project(':library')
+    androidTestImplementation "org.mockito:mockito-android:${MOCKITO_ANDROID_VERSION}"
+    androidTestImplementation "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
+    androidTestImplementation "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}"
+    androidTestImplementation "androidx.test:runner:${ANDROIDX_TEST_VERSION}"
+    androidTestImplementation "androidx.test:rules:${ANDROIDX_TEST_VERSION}"
+    androidTestImplementation "com.google.truth:truth:${TRUTH_VERSION}"
+    androidTestImplementation "junit:junit:${JUNIT_VERSION}"
+    // Not totally clear why this is required, but it seems to be missing when tests are run on
+    // 4.1.2 and 4.2.0 emulators.
+    androidTestImplementation 'com.google.code.findbugs:jsr305:3.0.2'
+}
+
+android {
+    compileSdkVersion COMPILE_SDK_VERSION as int
+
+    defaultConfig {
+        applicationId 'com.bumptech.glide.instrumentation'
+        minSdkVersion MIN_SDK_VERSION as int
+        targetSdkVersion TARGET_SDK_VERSION as int
+        versionCode 1
+        versionName '1.0'
+        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
+    }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
+}
+
diff --git a/instrumentation/src/androidTest/AndroidManifest.xml b/instrumentation/src/androidTest/AndroidManifest.xml
new file mode 100644
index 000000000..f12090f37
--- /dev/null
+++ b/instrumentation/src/androidTest/AndroidManifest.xml
@@ -0,0 +1,11 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+  package="com.bumptech.glide.instrumentation.test">
+  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
+  <application android:label="GlideTest">
+    <uses-library android:name="android.test.runner" />
+  </application>
+
+  <instrumentation android:targetPackage="com.bumptech.glide.instrumentation"
+                   android:name="com.google.android.apps.common.testing.testrunner.Google3InstrumentationTestRunner"
+                   android:label="Glide Emulator Tests" />
+</manifest>
diff --git a/instrumentation/src/androidTest/java/android/support/test/InstrumentationRegistry.java b/instrumentation/src/androidTest/java/android/support/test/InstrumentationRegistry.java
new file mode 100644
index 000000000..0b988917e
--- /dev/null
+++ b/instrumentation/src/androidTest/java/android/support/test/InstrumentationRegistry.java
@@ -0,0 +1,10 @@
+package android.support.test;
+
+import android.content.Context;
+
+// Workaround for https://github.com/mockito/mockito/issues/1472.
+public final class InstrumentationRegistry {
+  public static Context getTargetContext() {
+    return androidx.test.InstrumentationRegistry.getTargetContext();
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/AsBytesTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/AsBytesTest.java
new file mode 100644
index 000000000..fdc9d34cd
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/AsBytesTest.java
@@ -0,0 +1,221 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.drawable.BitmapDrawable;
+import android.net.Uri;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import com.google.common.io.ByteStreams;
+import java.io.BufferedOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.concurrent.TimeUnit;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(AndroidJUnit4.class)
+public class AsBytesTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+
+  private Context context;
+
+  @Before
+  public void setUp() throws IOException {
+    MockitoAnnotations.initMocks(this);
+    context = InstrumentationRegistry.getTargetContext();
+  }
+
+  @Test
+  public void loadImageResourceId_asBytes_providesBytesOfBitmap() {
+    byte[] data =
+        concurrency.get(
+            Glide.with(context)
+                .as(byte[].class)
+                .load(ResourceIds.raw.canonical)
+                .submit());
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadBitmap_asBytes_providesBytesOfBitmap() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    byte[] data =
+        concurrency.get(
+            Glide.with(context)
+                .as(byte[].class)
+                .load(bitmap)
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadBitmapDrawable_asBytes_providesBytesOfBitmap() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    byte[] data =
+        concurrency.get(
+            Glide.with(context)
+                .as(byte[].class)
+                .load(new BitmapDrawable(context.getResources(), bitmap))
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceId_asBytes_providesBytesOfFrame() {
+    byte[] data =
+        concurrency.get(
+            Glide.with(context)
+                .as(byte[].class)
+                .load(ResourceIds.raw.video)
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceId_asBytes_withFrameTime_providesBytesOfFrame() {
+    byte[] data =
+        concurrency.get(
+            GlideApp.with(context)
+                .as(byte[].class)
+                .load(ResourceIds.raw.video)
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoFile_asBytes_providesByteOfFrame() throws IOException {
+    byte[] data =
+        concurrency.get(
+            Glide.with(context)
+                .as(byte[].class)
+                .load(writeVideoToFile())
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoFile_asBytes_withFrameTime_providesByteOfFrame() throws IOException {
+    byte[] data =
+        concurrency.get(
+            GlideApp.with(context)
+                .as(byte[].class)
+                .load(writeVideoToFile())
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoFilePath_asBytes_providesByteOfFrame() throws IOException {
+    byte[] data =
+        concurrency.get(
+            Glide.with(context)
+                .as(byte[].class)
+                .load(writeVideoToFile().getAbsolutePath())
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoFilePath_asBytes_withFrameTime_providesByteOfFrame() throws IOException {
+    byte[] data =
+        concurrency.get(
+            GlideApp.with(context)
+                .as(byte[].class)
+                .load(writeVideoToFile().getAbsolutePath())
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoFileUri_asBytes_providesByteOfFrame() throws IOException {
+    byte[] data =
+        concurrency.get(
+            Glide.with(context)
+                .as(byte[].class)
+                .load(Uri.fromFile(writeVideoToFile()))
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoFileUri_asBytes_withFrameTime_providesByteOfFrame() throws IOException {
+    byte[] data =
+        concurrency.get(
+            GlideApp.with(context)
+                .as(byte[].class)
+                .load(Uri.fromFile(writeVideoToFile()))
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  private File writeVideoToFile() throws IOException {
+    byte[] videoData = loadVideoBytes();
+    File parent = context.getCacheDir();
+    if (!parent.mkdirs() && (!parent.exists() || !parent.isDirectory())) {
+      throw new IllegalStateException("Failed to mkdirs for: " + parent);
+    }
+    File toWrite = new File(parent, "temp.jpeg");
+    if (toWrite.exists() && !toWrite.delete()) {
+      throw new IllegalStateException("Failed to delete existing temp file: " + toWrite);
+    }
+
+    OutputStream os = null;
+    try {
+      os = new BufferedOutputStream(new FileOutputStream(toWrite));
+      os.write(videoData);
+      os.close();
+    } finally {
+      if (os != null) {
+        os.close();
+      }
+    }
+    return toWrite;
+  }
+
+  private byte[] loadVideoBytes() throws IOException {
+    Resources resources = context.getResources();
+    InputStream is = resources.openRawResource(ResourceIds.raw.video);
+    return ByteStreams.toByteArray(is);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/AsFileTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/AsFileTest.java
new file mode 100644
index 000000000..364ef5150
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/AsFileTest.java
@@ -0,0 +1,115 @@
+package com.bumptech.glide;
+
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import android.content.Context;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.MockModelLoader;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+public class AsFileTest {
+  private static final String URL = "https://imgs.xkcd.com/comics/mc_hammer_age.png";
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private final Context context = InstrumentationRegistry.getTargetContext();
+
+  @Before
+  public void setUp() {
+    MockModelLoader.mock(URL, getData());
+  }
+
+  @Test
+  public void asFile_withUrl_succeeds() {
+    File file =
+        concurrency.get(
+            GlideApp.with(context)
+                .asFile()
+                .load(URL)
+                .submit());
+    assertThat(file).isNotNull();
+  }
+
+  @Test
+  public void asFile_withUrlAndDiskCacheStrategyData_succeeds() {
+    File file =
+        concurrency.get(
+            GlideApp.with(context)
+                .asFile()
+                .diskCacheStrategy(DiskCacheStrategy.DATA)
+                .load(URL)
+                .submit());
+    assertThat(file).isNotNull();
+  }
+
+  @Test
+  public void asFile_withUrlAndDiskCacheStrategyResource_fails() {
+    try {
+      concurrency.get(
+          GlideApp.with(context)
+              .asFile()
+              .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+              .load(URL)
+              .submit());
+      fail();
+    } catch (RuntimeException e) {
+      // expected.
+    }
+  }
+
+  @Test
+  public void asFile_withUrlAndDiskCacheStrategyAll_fails() {
+    try {
+      concurrency.get(
+          GlideApp.with(context)
+              .asFile()
+              .diskCacheStrategy(DiskCacheStrategy.ALL)
+              .load(URL)
+              .submit());
+      fail();
+    } catch (RuntimeException e) {
+      // Expected.
+    }
+  }
+
+  private InputStream getData() {
+    InputStream is = null;
+    try {
+      is = context.getResources().openRawResource(ResourceIds.raw.canonical);
+      byte[] buffer = new byte[1024 * 1024];
+      ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+      int read;
+      while ((read = is.read(buffer)) != -1) {
+        outputStream.write(buffer, 0, read);
+      }
+      byte[] data = outputStream.toByteArray();
+      return new ByteArrayInputStream(data);
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    } finally {
+      if (is != null) {
+        try {
+          is.close();
+        } catch (IOException e) {
+          // Ignored.
+        }
+      }
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java
new file mode 100644
index 000000000..cd2ef820f
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java
@@ -0,0 +1,493 @@
+package com.bumptech.glide;
+
+import static com.bumptech.glide.test.Matchers.anyDrawable;
+import static com.bumptech.glide.test.Matchers.anyDrawableTarget;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertThrows;
+import static org.junit.Assert.fail;
+import static org.mockito.AdditionalMatchers.not;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.anyBoolean;
+import static org.mockito.Mockito.eq;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.verify;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.os.Handler;
+import android.os.Looper;
+import android.view.ViewGroup.LayoutParams;
+import android.widget.ImageView;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.engine.cache.LruResourceCache;
+import com.bumptech.glide.load.engine.cache.MemoryCacheAdapter;
+import com.bumptech.glide.request.FutureTarget;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.test.BitmapSubject;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.ResourceIds.raw;
+import com.bumptech.glide.test.TearDownGlide;
+import com.bumptech.glide.test.WaitModelLoader;
+import com.bumptech.glide.test.WaitModelLoader.WaitModel;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.function.ThrowingRunnable;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+/**
+ * Tests various aspects of memory and disk caching to verify resources can be retrieved as we
+ * expect.
+ */
+@RunWith(AndroidJUnit4.class)
+public class CachingTest {
+  private static final int IMAGE_SIZE_PIXELS = 500;
+  // Store at least 10 500x500 pixel Bitmaps with the ARGB_8888 config to be safe.
+  private static final long CACHE_SIZE_BYTES =
+      IMAGE_SIZE_PIXELS * IMAGE_SIZE_PIXELS * 4 * 10;
+
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+  @Mock private RequestListener<Drawable> requestListener;
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+
+  private Context context;
+
+  @Before
+  public void setUp() throws InterruptedException {
+    MockitoAnnotations.initMocks(this);
+    context = InstrumentationRegistry.getTargetContext();
+
+    Glide.init(
+        context, new GlideBuilder().setMemoryCache(new LruResourceCache(CACHE_SIZE_BYTES)));
+  }
+
+  @Test
+  public void submit_withDisabledMemoryCache_andResourceInActiveResources_loadsFromMemory() {
+    Glide.init(
+        context, new GlideBuilder().setMemoryCache(new MemoryCacheAdapter()));
+
+    FutureTarget<Drawable> first =
+        GlideApp.with(context)
+            .load(raw.canonical)
+            .submit();
+    concurrency.get(first);
+
+    concurrency.get(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.MEMORY_CACHE),
+            anyBoolean());
+  }
+
+  @Test
+  public void submit_withRequestClearedFromMemory_doesNotLoadFromMemory() {
+    Glide.init(
+        context, new GlideBuilder().setMemoryCache(new MemoryCacheAdapter()));
+
+    // Allow the request to be run and GCed without being cleared.
+    concurrency.loadOnOtherThread(new Runnable() {
+      @Override
+      public void run() {
+        FutureTarget<Drawable> first =
+            GlideApp.with(context)
+                .load(raw.canonical)
+                .submit();
+        concurrency.get(first);
+      }
+    });
+
+    // Wait for the weak reference to be cleared and the request to be removed from active
+    // resources.
+    // De-flake by allowing multiple tries
+    boolean isWeakRefCleared = false;
+    for (int j = 0; j < 100; j++) {
+      Runtime.getRuntime().gc();
+      concurrency.pokeMainThread();
+      try {
+        // Loading again here won't shuffle our resource around because it only changes our
+        // reference count from 1 to 2 and back. The reference we're waiting for will only be
+        // decremented when the target is GCed.
+        Target<Drawable> target =
+            concurrency.wait(
+                GlideApp.with(context)
+                    .load(ResourceIds.raw.canonical)
+                    .onlyRetrieveFromCache(true)
+                    .diskCacheStrategy(DiskCacheStrategy.NONE)
+                    .submit());
+        GlideApp.with(context).clear(target);
+      } catch (RuntimeException e) {
+        // The item has been cleared from active resources.
+        isWeakRefCleared = true;
+        break;
+      }
+    }
+
+    if (!isWeakRefCleared) {
+      fail("Failed to clear weak ref.");
+    }
+
+    concurrency.get(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            not(eq(DataSource.MEMORY_CACHE)),
+            anyBoolean());
+  }
+
+  @Test
+  public void submit_withPreviousRequestClearedFromMemory_completesFromDataDiskCache()
+      throws InterruptedException, ExecutionException, TimeoutException {
+    FutureTarget<Drawable> future = GlideApp.with(context)
+        .load(ResourceIds.raw.canonical)
+        .diskCacheStrategy(DiskCacheStrategy.DATA)
+        .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS);
+    concurrency.get(future);
+    GlideApp.with(context).clear(future);
+
+    clearMemoryCacheOnMainThread();
+
+    concurrency.get(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .diskCacheStrategy(DiskCacheStrategy.DATA)
+            .listener(requestListener)
+            .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.DATA_DISK_CACHE),
+            anyBoolean());
+  }
+
+  @Test
+  public void submit_withPreviousButNoLongerReferencedIdenticalRequest_completesFromMemoryCache()
+      throws InterruptedException, TimeoutException, ExecutionException {
+    // We can't allow any mocks (RequestListner, Target etc) to reference this request or the test
+    // will fail due to the transient strong reference to the request.
+    concurrency.get(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));
+
+    // Force the collection of weak references now that the listener/request in the first load is no
+    // longer referenced.
+    Runtime.getRuntime().gc();
+    concurrency.pokeMainThread();
+
+    concurrency.get(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .listener(requestListener)
+            .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.MEMORY_CACHE),
+            anyBoolean());
+  }
+
+  @Test
+  public void submit_withPreviousButNoLongerReferencedIdenticalRequest_doesNotRecycleBitmap()
+      throws InterruptedException, TimeoutException, ExecutionException {
+    // We can't allow any mocks (RequestListener, Target etc) to reference this request or the test
+    // will fail due to the transient strong reference to the request.
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(ResourceIds.raw.canonical)
+                .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+                .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));
+
+    // Force the collection of weak references now that the listener/request in the first load is no
+    // longer referenced.
+    Runtime.getRuntime().gc();
+    concurrency.pokeMainThread();
+
+    FutureTarget<Bitmap> future = GlideApp.with(context)
+        .asBitmap()
+        .load(ResourceIds.raw.canonical)
+        .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+        .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS);
+    concurrency.get(future);
+    Glide.with(context).clear(future);
+
+    clearMemoryCacheOnMainThread();
+
+    BitmapSubject.assertThat(bitmap).isNotRecycled();
+  }
+
+  @Test
+  public void clearDiskCache_doesNotPreventFutureLoads()
+      throws ExecutionException, InterruptedException, TimeoutException {
+    FutureTarget<Drawable> future = GlideApp.with(context)
+        .load(ResourceIds.raw.canonical)
+        .diskCacheStrategy(DiskCacheStrategy.DATA)
+        .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS);
+    concurrency.get(future);
+    GlideApp.with(context).clear(future);
+
+    clearMemoryCacheOnMainThread();
+    GlideApp.get(context).clearDiskCache();
+
+    future = GlideApp.with(context)
+        .load(ResourceIds.raw.canonical)
+        .diskCacheStrategy(DiskCacheStrategy.DATA)
+        .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS);
+    concurrency.get(future);
+
+    GlideApp.with(context).clear(future);
+    clearMemoryCacheOnMainThread();
+
+    concurrency.get(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+            .diskCacheStrategy(DiskCacheStrategy.DATA)
+            .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.DATA_DISK_CACHE),
+            anyBoolean());
+  }
+
+  // Tests #2428.
+  @Test
+  public void onlyRetrieveFromCache_withPreviousRequestLoadingFromSource_doesNotBlock() {
+    final WaitModel<Integer> waitModel = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);
+
+    FutureTarget<Drawable> loadFromSourceFuture = GlideApp.with(context)
+        .load(waitModel)
+        .submit();
+
+    FutureTarget<Drawable> onlyFromCacheFuture = GlideApp.with(context)
+        .load(waitModel)
+        .onlyRetrieveFromCache(true)
+        .submit();
+    try {
+      onlyFromCacheFuture.get(1000, TimeUnit.MILLISECONDS);
+      fail("Expected only from cache Future to time out");
+    } catch (InterruptedException | TimeoutException e) {
+      throw new RuntimeException(e);
+    } catch (ExecutionException e) {
+      // Expected.
+    }
+    waitModel.countDown();
+
+    assertThat(concurrency.get(loadFromSourceFuture)).isNotNull();
+  }
+
+  // Tests #2428.
+  @Test
+  public void submit_withRequestLoadingWithOnlyRetrieveFromCache_andNotInCache_doesNotFail() {
+    // Block the main thread so that we know that both requests will be queued but not started at
+    // the same time.
+    final CountDownLatch blockMainThread = new CountDownLatch(1);
+    new Handler(Looper.getMainLooper()).post(new Runnable() {
+      @Override
+      public void run() {
+         try {
+          blockMainThread.await();
+        } catch (InterruptedException e) {
+          throw new RuntimeException(e);
+        }
+      }
+    });
+
+    // Queue the retrieve from cache request first.
+    final Future<Drawable> firstQueuedFuture = GlideApp.with(context)
+        .load(ResourceIds.raw.canonical)
+        .onlyRetrieveFromCache(true)
+        .submit();
+
+    // Then queue the normal request.
+    FutureTarget<Drawable> expectedFuture =
+        GlideApp.with(context).load(ResourceIds.raw.canonical).submit();
+
+    // Run the requests.
+    blockMainThread.countDown();
+
+    // Verify that the request that didn't have retrieve from cache succeeds
+    assertThat(concurrency.get(expectedFuture)).isNotNull();
+    // The first request only from cache should fail because the item is not in cache.
+    assertThrows(RuntimeException.class, new ThrowingRunnable() {
+      @Override
+      public void run() throws Throwable {
+        concurrency.get(firstQueuedFuture);
+      }
+    });
+  }
+
+  @Test
+  public void loadIntoView_withoutSkipMemoryCache_loadsFromMemoryCacheIfPresent() {
+    final ImageView imageView = new ImageView(context);
+    imageView.setLayoutParams(new LayoutParams(100, 100));
+
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+            .dontTransform(),
+        imageView);
+
+    // Casting avoids a varags array warning.
+    //noinspection rawtypes
+    reset((RequestListener) requestListener);
+
+    // Run on the main thread, since this is already cached, we shouldn't need to try to wait. If we
+    // do end up re-using the old Target, our wait will always timeout anyway if we use
+    // loadOnMainThread. If the load doesn't complete in time, it will be caught by the listener
+    // below, which expects to be called synchronously.
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.with(context)
+                .load(ResourceIds.raw.canonical)
+                .listener(requestListener)
+                .dontTransform()
+                .into(imageView);
+          }
+        });
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.MEMORY_CACHE),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadIntoView_withSkipMemoryCacheFalse_loadsFromMemoryCacheIfPresent() {
+    final ImageView imageView = new ImageView(context);
+    imageView.setLayoutParams(new LayoutParams(100, 100));
+
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+            .skipMemoryCache(false)
+            .dontTransform(),
+        imageView);
+
+    // Casting avoids a varags array warning.
+    //noinspection rawtypes
+    reset((RequestListener) requestListener);
+
+    // Run on the main thread, since this is already cached, we shouldn't need to try to wait. If we
+    // do end up re-using the old Target, our wait will always timeout anyway if we use
+    // loadOnMainThread. If the load doesn't complete in time, it will be caught by the listener
+    // below, which expects to be called synchronously.
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.with(context)
+                .load(ResourceIds.raw.canonical)
+                .listener(requestListener)
+                .skipMemoryCache(false)
+                .dontTransform()
+                .into(imageView);
+          }
+        });
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.MEMORY_CACHE),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadIntoView_withSkipMemoryCache_doesNotLoadFromMemoryCacheIfPresent() {
+    final ImageView imageView = new ImageView(context);
+    imageView.setLayoutParams(new LayoutParams(100, 100));
+
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+            .dontTransform()
+            .skipMemoryCache(true),
+        imageView);
+
+    // Casting avoids a varags array warning.
+    //noinspection rawtypes
+    reset((RequestListener) requestListener);
+
+    // If this test fails due to a timeout, it's because we re-used the Target from the previous
+    // request, which breaks the logic in loadOnMainThread that expects a new Target's
+    // onResourceReady callback to be called. This can be confirmed by changing this to
+    // runOnMainThread and verifying that the RequestListener assertion below fails because
+    // the DataSource was from the memory cache.
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+            .dontTransform()
+            .skipMemoryCache(true),
+        imageView);
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            not(eq(DataSource.MEMORY_CACHE)),
+            anyBoolean());
+  }
+
+  private void clearMemoryCacheOnMainThread() throws InterruptedException {
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.get(context).clearMemory();
+      }
+    });
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/CenterCropRegressionTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/CenterCropRegressionTest.java
new file mode 100644
index 000000000..b98962c90
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CenterCropRegressionTest.java
@@ -0,0 +1,96 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
+import com.bumptech.glide.test.BitmapRegressionTester;
+import com.bumptech.glide.test.CanonicalBitmap;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.RegressionTest;
+import com.bumptech.glide.test.SplitByCpu;
+import com.bumptech.glide.test.SplitBySdk;
+import com.bumptech.glide.test.TearDownGlide;
+import java.util.concurrent.ExecutionException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestName;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+@RegressionTest
+@SplitByCpu
+@SplitBySdk({24, 21, 16})
+public class CenterCropRegressionTest {
+  @Rule public final TestName testName = new TestName();
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private BitmapRegressionTester bitmapRegressionTester;
+  private Context context;
+  private CanonicalBitmap canonical;
+
+  @Before
+  public void setUp() {
+    context = InstrumentationRegistry.getTargetContext();
+    bitmapRegressionTester = new BitmapRegressionTester(getClass(), testName);
+    canonical = new CanonicalBitmap();
+  }
+
+  @Test
+  public void centerCrop_withSquareSmallerThanImage_returnsSquareImage()
+      throws ExecutionException, InterruptedException {
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .centerCrop()
+                .override(50));
+    assertThat(result.getWidth()).isEqualTo(50);
+    assertThat(result.getHeight()).isEqualTo(50);
+  }
+
+  @Test
+  public void centerCrop_withRectangleSmallerThanImage_returnsRectangularImage()
+      throws ExecutionException, InterruptedException {
+     Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .centerCrop()
+                .override(60, 70));
+    assertThat(result.getWidth()).isEqualTo(60);
+    assertThat(result.getHeight()).isEqualTo(70);
+  }
+
+  @Test
+  public void centerCrop_withSquareLargerThanImage_returnsUpscaledRectangularImage()
+      throws ExecutionException, InterruptedException {
+    Bitmap result =
+          bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .centerCrop()
+                .override(canonical.getWidth() * 2));
+    assertThat(result.getWidth()).isEqualTo(canonical.getWidth() * 2);
+    assertThat(result.getHeight()).isEqualTo(canonical.getWidth() * 2);
+  }
+
+  @Test
+  public void centerCrop_withRectangleLargerThanImage_returnsUpscaledRectangularImage()
+      throws ExecutionException, InterruptedException {
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .centerCrop()
+                .override(canonical.getWidth() * 2, canonical.getHeight() * 2));
+    assertThat(result.getWidth()).isEqualTo(canonical.getWidth() * 2);
+    assertThat(result.getHeight()).isEqualTo(canonical.getHeight() * 2);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/CenterInsideRegressionTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/CenterInsideRegressionTest.java
new file mode 100644
index 000000000..0f9d5727f
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CenterInsideRegressionTest.java
@@ -0,0 +1,103 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
+import com.bumptech.glide.test.BitmapRegressionTester;
+import com.bumptech.glide.test.CanonicalBitmap;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.RegressionTest;
+import com.bumptech.glide.test.SplitByCpu;
+import com.bumptech.glide.test.SplitBySdk;
+import com.bumptech.glide.test.TearDownGlide;
+import java.util.concurrent.ExecutionException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestName;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+@SplitByCpu
+@SplitBySdk({24, 21, 16})
+@RegressionTest
+public class CenterInsideRegressionTest {
+  @Rule public final TestName testName = new TestName();
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private BitmapRegressionTester bitmapRegressionTester;
+  private Context context;
+  private CanonicalBitmap canonical;
+
+  @Before
+  public void setUp() {
+    context = InstrumentationRegistry.getTargetContext();
+    bitmapRegressionTester = new BitmapRegressionTester(getClass(), testName);
+    canonical = new CanonicalBitmap();
+  }
+
+  @Test
+  public void centerInside_withSquareSmallerThanImage_returnsImageFitWithinSquare()
+      throws ExecutionException, InterruptedException {
+
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .centerInside()
+                .override(50));
+
+    assertThat(result.getWidth()).isEqualTo(50);
+    assertThat(result.getHeight()).isEqualTo(37);
+  }
+
+  @Test
+  public void centerInside_withSquareLargerThanImage_returnsOriginalImage()
+      throws ExecutionException, InterruptedException {
+    float multiplier = 1.1f;
+    int multipliedWidth = (int) (canonical.getWidth() * multiplier);
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+              .asBitmap()
+              .load(canonical.getBitmap())
+              .centerInside()
+              .override(multipliedWidth));
+
+    assertThat(result.getWidth()).isEqualTo(canonical.getWidth());
+    assertThat(result.getHeight()).isEqualTo(canonical.getHeight());
+  }
+
+  @Test
+  public void centerInside_withNarrowRectangle_fitsWithinMaintainingAspectRatio()
+      throws ExecutionException, InterruptedException {
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+              .asBitmap()
+              .load(canonical.getBitmap())
+              .centerInside()
+              .override(canonical.getWidth() / 10, canonical.getHeight()));
+
+    assertThat(result.getWidth()).isEqualTo(canonical.getWidth() / 10);
+    assertThat(result.getHeight()).isEqualTo(canonical.getHeight() / 10);
+  }
+
+  @Test
+  public void centerInside_withShortRectangle_fitsWithinMaintainingAspectRatio()
+      throws ExecutionException, InterruptedException {
+     Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+              .asBitmap()
+              .load(canonical.getBitmap())
+              .centerInside()
+              .override(canonical.getWidth(), canonical.getHeight() / 2));
+
+    assertThat(result.getWidth()).isEqualTo(canonical.getWidth() / 2);
+    assertThat(result.getHeight()).isEqualTo(canonical.getHeight() / 2);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/CircleCropRegressionTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/CircleCropRegressionTest.java
new file mode 100644
index 000000000..a2df666d1
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CircleCropRegressionTest.java
@@ -0,0 +1,102 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
+import com.bumptech.glide.test.BitmapRegressionTester;
+import com.bumptech.glide.test.CanonicalBitmap;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.RegressionTest;
+import com.bumptech.glide.test.SplitByCpu;
+import com.bumptech.glide.test.SplitBySdk;
+import com.bumptech.glide.test.TearDownGlide;
+import java.util.concurrent.ExecutionException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestName;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+@SplitByCpu
+@SplitBySdk({26, 24, 23, 21, 18, 16})
+@RegressionTest
+public class CircleCropRegressionTest {
+  @Rule public final TestName testName = new TestName();
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private BitmapRegressionTester bitmapRegressionTester;
+  private Context context;
+  private CanonicalBitmap canonical;
+
+  @Before
+  public void setUp() {
+    context = InstrumentationRegistry.getTargetContext();
+    bitmapRegressionTester = new BitmapRegressionTester(getClass(), testName);
+    canonical = new CanonicalBitmap();
+  }
+
+  @Test
+  public void circleCrop_withSquareSmallerThanImage_returnsSquaredImage()
+      throws ExecutionException, InterruptedException {
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .circleCrop()
+                .override(50));
+
+    assertThat(result.getWidth()).isEqualTo(50);
+    assertThat(result.getHeight()).isEqualTo(50);
+  }
+
+  @Test
+  public void circleCrop_withSquareLargerThanImage_returnsUpscaledFitImage()
+      throws ExecutionException, InterruptedException {
+    float multiplier = 1.1f;
+    int multipliedWidth = (int) (canonical.getWidth() * multiplier);
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+              .asBitmap()
+              .load(canonical.getBitmap())
+              .circleCrop()
+              .override(multipliedWidth));
+
+    assertThat(result.getWidth()).isEqualTo(multipliedWidth);
+    assertThat(result.getHeight()).isEqualTo(multipliedWidth);
+  }
+
+  @Test
+  public void circleCrop_withNarrowRectangle_cropsWithin()
+      throws ExecutionException, InterruptedException {
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+              .asBitmap()
+              .load(canonical.getBitmap())
+              .circleCrop()
+              .override(canonical.getWidth() / 10, canonical.getHeight()));
+
+    assertThat(result.getWidth()).isEqualTo(canonical.getWidth() / 10);
+    assertThat(result.getHeight()).isEqualTo(canonical.getWidth() / 10);
+  }
+
+  @Test
+  public void circleCrop_withShortRectangle_fitsWithinMaintainingAspectRatio()
+      throws ExecutionException, InterruptedException {
+     Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+              .asBitmap()
+              .load(canonical.getBitmap())
+              .circleCrop()
+              .override(canonical.getWidth(), canonical.getHeight() / 2));
+
+    assertThat(result.getWidth()).isEqualTo(canonical.getHeight() / 2);
+    assertThat(result.getHeight()).isEqualTo(canonical.getHeight() / 2);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/DataUriTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/DataUriTest.java
new file mode 100644
index 000000000..014d0942b
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/DataUriTest.java
@@ -0,0 +1,109 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.CompressFormat;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.v4.content.ContextCompat;
+import android.util.Base64;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import com.bumptech.glide.util.Preconditions;
+import java.io.ByteArrayOutputStream;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+public class DataUriTest {
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private final Context context = InstrumentationRegistry.getTargetContext();
+
+  @Test
+  public void load_withJpegAsDataUriString_returnsBitmap() {
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(getDataUriString(CompressFormat.JPEG))
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withPngDataUriString_returnsBitmap() {
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(getDataUriString(CompressFormat.PNG))
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withJpegAsDataUri_returnsBitmap() {
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(getDataUri(CompressFormat.JPEG))
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withPngAsDataUri_returnsBitmap() {
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(getDataUri(CompressFormat.PNG))
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  private Uri getDataUri(CompressFormat format) {
+    return Uri.parse(getDataUriString(format));
+  }
+
+  private String getDataUriString(CompressFormat format) {
+    String bytes = getBase64BitmapBytes(format);
+    String imageType;
+    switch (format) {
+      case PNG:
+        imageType = "png";
+        break;
+      case JPEG:
+        imageType = "jpeg";
+        break;
+      case WEBP:
+        imageType = "webp";
+        break;
+      default:
+        throw new IllegalArgumentException("Unrecognized format: " + format);
+    }
+
+    String mimeType = "image/" + imageType;
+    return "data:" + mimeType + ";base64," + bytes;
+  }
+
+  @SuppressWarnings("deprecation")
+  private String getBase64BitmapBytes(CompressFormat format) {
+    ByteArrayOutputStream bos = new ByteArrayOutputStream();
+    Drawable drawable =
+        Preconditions.checkNotNull(ContextCompat.getDrawable(context, ResourceIds.raw.canonical));
+    Bitmap bitmap = ((BitmapDrawable) drawable).getBitmap();
+    bitmap.compress(format, 100, bos);
+    byte[] data = bos.toByteArray();
+    return Base64.encodeToString(data, /*flags=*/ 0);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/DownsampleVideoTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/DownsampleVideoTest.java
new file mode 100644
index 000000000..d84b55ac8
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/DownsampleVideoTest.java
@@ -0,0 +1,207 @@
+package com.bumptech.glide;
+
+import static com.bumptech.glide.test.BitmapSubject.assertThat;
+import static org.junit.Assume.assumeTrue;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.os.Build;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+public class DownsampleVideoTest {
+  // The dimensions of the test video.
+  private static final int WIDTH = 1080;
+  private static final int HEIGHT = 1920;
+
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private final Context context = InstrumentationRegistry.getTargetContext();
+
+  @Before
+  public void setUp() {
+    assumeTrue(Build.VERSION.SDK_INT >= Build.VERSION_CODES.O_MR1);
+  }
+
+  @Test
+  public void loadVideo_downsampleStrategyNone_returnsOriginalVideoDimensions() {
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(ResourceIds.raw.video)
+                .downsample(DownsampleStrategy.NONE)
+                .submit(10, 10));
+
+    assertThat(bitmap).hasDimensions(WIDTH, HEIGHT);
+  }
+
+  @Test
+  public void loadVideo_downsampleStrategyNone_doesNotUpscale() {
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(ResourceIds.raw.video)
+                .downsample(DownsampleStrategy.NONE)
+                .submit(WIDTH * 2, HEIGHT * 2));
+
+    assertThat(bitmap).hasDimensions(WIDTH, HEIGHT);
+  }
+
+  @Test
+  public void loadVideo_downsampleDefault_downsamplesVideo() {
+     Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(ResourceIds.raw.video)
+                .submit(10, 10));
+
+    assertThat(bitmap).hasDimensions(10, 18);
+  }
+
+  @Test
+  public void loadVideo_downsampleAtMost_downsamplesToSmallerSize() {
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .downsample(DownsampleStrategy.AT_MOST)
+                .load(ResourceIds.raw.video)
+                .submit(540, 959));
+    assertThat(bitmap).hasDimensions(270, 480);
+  }
+
+  @Test
+  public void loadVideo_downsampleAtMost_doesNotUpscale() {
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .downsample(DownsampleStrategy.AT_MOST)
+                .load(ResourceIds.raw.video)
+                .submit(WIDTH * 2, HEIGHT * 2));
+    assertThat(bitmap).hasDimensions(WIDTH, HEIGHT);
+  }
+
+  @Test
+  public void loadVideo_downsampleAtLeast_downsamplesToLargerSize() {
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .downsample(DownsampleStrategy.AT_LEAST)
+                .load(ResourceIds.raw.video)
+                .submit(270, 481));
+    assertThat(bitmap).hasDimensions(540, 960);
+  }
+
+    @Test
+  public void loadVideo_downsampleAtLeast_doesNotUpscale() {
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .downsample(DownsampleStrategy.AT_LEAST)
+                .load(ResourceIds.raw.video)
+                .submit(WIDTH * 2, HEIGHT * 2));
+    assertThat(bitmap).hasDimensions(WIDTH, HEIGHT);
+  }
+
+  @Test
+  public void loadVideo_downsampleCenterInside_downsamplesWithinBox() {
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .downsample(DownsampleStrategy.CENTER_INSIDE)
+                .load(ResourceIds.raw.video)
+                .submit(270, 481));
+    assertThat(bitmap).hasDimensions(270, 480);
+  }
+
+  @Test
+  public void loadVideo_downsampleCenterInside_doesNotUpscale() {
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .downsample(DownsampleStrategy.CENTER_INSIDE)
+                .load(ResourceIds.raw.video)
+                .submit(WIDTH * 2, HEIGHT * 2));
+    assertThat(bitmap).hasDimensions(WIDTH, HEIGHT);
+  }
+
+  @Test
+  public void loadVideo_downsampleCenterOutside_downsamplesOutsideBox() {
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .downsample(DownsampleStrategy.CENTER_OUTSIDE)
+                .load(ResourceIds.raw.video)
+                .submit(270, 481));
+    assertThat(bitmap).hasDimensions(271, 481);
+  }
+
+  @Test
+  public void loadVideo_downsampleCenterOutside_upsacles() {
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .downsample(DownsampleStrategy.CENTER_OUTSIDE)
+                .load(ResourceIds.raw.video)
+                .submit(WIDTH * 2, HEIGHT * 2));
+    assertThat(bitmap).hasDimensions(WIDTH * 2, HEIGHT * 2);
+  }
+
+  @Test
+  public void loadVideo_downsampleFitCenter_downsamplesInsideBox() {
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .downsample(DownsampleStrategy.FIT_CENTER)
+                .load(ResourceIds.raw.video)
+                .submit(270, 481));
+    assertThat(bitmap).hasDimensions(270, 480);
+  }
+
+  @Test
+  public void loadVideo_downsampleFitCenter_upscales() {
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .downsample(DownsampleStrategy.FIT_CENTER)
+                .load(ResourceIds.raw.video)
+                .submit(WIDTH * 2, HEIGHT * 2));
+    assertThat(bitmap).hasDimensions(WIDTH * 2, HEIGHT * 2);
+  }
+
+  @Test
+  public void loadVideo_withSizeOriginal_ignoresDownsampleStrategy() {
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .downsample(DownsampleStrategy.AT_MOST)
+                .load(ResourceIds.raw.video)
+                .submit(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL));
+
+    assertThat(bitmap).hasDimensions(WIDTH, HEIGHT);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/DrawableTransformationTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/DrawableTransformationTest.java
new file mode 100644
index 000000000..033aecfec
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/DrawableTransformationTest.java
@@ -0,0 +1,213 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertThrows;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.ColorDrawable;
+import android.graphics.drawable.Drawable;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.resource.bitmap.TransformationUtils;
+import com.bumptech.glide.request.RequestOptions;
+import com.bumptech.glide.test.BitmapSubject;
+import com.bumptech.glide.test.GlideApp;
+import java.util.concurrent.ExecutionException;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.function.ThrowingRunnable;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+public class DrawableTransformationTest {
+  private Context context;
+
+  @Before
+  public void setUp() {
+    context = InstrumentationRegistry.getTargetContext();
+  }
+
+  @After
+  public void tearDown() {
+    Glide.get(context).clearDiskCache();
+    Glide.tearDown();
+  }
+
+  @Test
+  public void load_withColorDrawable_sizeOriginal_optionalTransform_returnsColorDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable colorDrawable = new ColorDrawable(Color.RED);
+    Drawable result = Glide.with(context)
+        .load(colorDrawable)
+        .apply(new RequestOptions()
+            .optionalCenterCrop())
+        .submit()
+        .get();
+
+    assertThat(result).isInstanceOf(ColorDrawable.class);
+    assertThat(((ColorDrawable) result).getColor()).isEqualTo(Color.RED);
+  }
+
+  /**
+   * Transformations that do nothing can simply return the original Bitmap.
+   */
+  @Test
+  public void load_withColorDrawable_fixedSize_requiredUnitTransform_returnsOriginalDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable colorDrawable = new ColorDrawable(Color.RED);
+
+    Drawable result = Glide.with(context)
+        .load(colorDrawable)
+        .apply(new RequestOptions()
+            .centerCrop())
+        .submit(100, 100)
+        .get();
+
+    assertThat(result).isInstanceOf(ColorDrawable.class);
+    assertThat(((ColorDrawable) result).getColor()).isEqualTo(Color.RED);
+  }
+
+  /**
+   * Transformations that produce a different output color/shape/image etc will end up returning
+   * a {@link Bitmap} based on the original {@link Drawable} but with the transformation applied.
+   */
+  @Test
+  public void load_withColorDrawable_fixedSize_nonUnitRequiredTransform_returnsBitmapDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable colorDrawable = new ColorDrawable(Color.RED);
+
+    Drawable result = Glide.with(context)
+        .load(colorDrawable)
+        .apply(new RequestOptions()
+            .circleCrop())
+        .submit(100, 100)
+        .get();
+
+    Bitmap redSquare = Bitmap.createBitmap(100, 100, Config.ARGB_8888);
+    Canvas canvas = new Canvas(redSquare);
+    canvas.drawColor(Color.RED);
+
+    BitmapPool bitmapPool = mock(BitmapPool.class);
+    when(bitmapPool.get(100, 100, Bitmap.Config.ARGB_8888))
+        .thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    Bitmap expected = TransformationUtils.circleCrop(bitmapPool, redSquare, 100, 100);
+
+    assertThat(result).isInstanceOf(BitmapDrawable.class);
+    Bitmap bitmap = ((BitmapDrawable) result).getBitmap();
+    assertThat(bitmap.getWidth()).isEqualTo(100);
+    assertThat(bitmap.getHeight()).isEqualTo(100);
+    for (int x = 0; x < bitmap.getWidth(); x++) {
+      for (int y = 0; y < bitmap.getHeight(); y++) {
+        assertThat(bitmap.getPixel(x, y)).isEqualTo(expected.getPixel(x, y));
+      }
+    }
+  }
+
+  @Test
+  public void load_withColorDrawable_sizeOriginal_requiredTransform_fails()
+      throws ExecutionException, InterruptedException {
+    final Drawable colorDrawable = new ColorDrawable(Color.RED);
+
+    assertThrows(
+        ExecutionException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() throws Throwable {
+            Glide.with(context)
+                .load(colorDrawable)
+                .apply(new RequestOptions()
+                    .centerCrop())
+                .submit()
+                .get();
+          }
+        });
+  }
+
+  @Test
+  public void load_withBitmapDrawable_andDoNothingTransformation_doesNotRecycleBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Bitmap.createBitmap(100, 200, Config.ARGB_8888);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+
+    Drawable result = GlideApp.with(context)
+        .load(drawable)
+        .fitCenter()
+        .override(bitmap.getWidth(), bitmap.getHeight())
+        .submit()
+        .get();
+
+    BitmapSubject.assertThat(result).isNotRecycled();
+  }
+
+  @Test
+  public void load_withBitmapDrawable_andFunctionalTransformation_doesNotRecycleBitmap()
+      throws ExecutionException, InterruptedException {
+      Bitmap bitmap = Bitmap.createBitmap(100, 200, Config.ARGB_8888);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+
+    Drawable result = GlideApp.with(context)
+        .load(drawable)
+        .fitCenter()
+        .override(bitmap.getWidth() / 2, bitmap.getHeight() / 2)
+        .submit()
+        .get();
+
+    BitmapSubject.assertThat(result).isNotRecycled();
+  }
+
+  @Test
+  public void load_withColorDrawable_fixedSize_unitBitmapTransform_recyclesIntermediates()
+      throws ExecutionException, InterruptedException {
+    Drawable colorDrawable = new ColorDrawable(Color.RED);
+
+    int width = 100;
+    int height = 200;
+
+    GlideApp.with(context)
+        .load(colorDrawable)
+        .fitCenter()
+        .override(width, height)
+        .submit()
+        .get();
+
+    BitmapPool bitmapPool = Glide.get(context).getBitmapPool();
+    // Make sure we didn't put the same Bitmap twice.
+    Bitmap first = bitmapPool.get(width, height, Config.ARGB_8888);
+    Bitmap second = bitmapPool.get(width, height, Config.ARGB_8888);
+
+    assertThat(first).isNotSameAs(second);
+  }
+   @Test
+  public void load_withColorDrawable_fixedSize_functionalBitmapTransform_doesNotRecycleOutput()
+      throws ExecutionException, InterruptedException {
+    Drawable colorDrawable = new ColorDrawable(Color.RED);
+
+    int width = 100;
+    int height = 200;
+
+    Drawable result = GlideApp.with(context)
+        .load(colorDrawable)
+        .circleCrop()
+        .override(width, height)
+        .submit()
+        .get();
+
+     BitmapSubject.assertThat(result).isNotRecycled();
+
+    BitmapPool bitmapPool = Glide.get(context).getBitmapPool();
+    // Make sure we didn't put the same Bitmap twice.
+    Bitmap first = bitmapPool.get(width, height, Config.ARGB_8888);
+    Bitmap second = bitmapPool.get(width, height, Config.ARGB_8888);
+
+    assertThat(first).isNotSameAs(second);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/ErrorHandlingTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/ErrorHandlingTest.java
new file mode 100644
index 000000000..2e6dcbb74
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/ErrorHandlingTest.java
@@ -0,0 +1,164 @@
+package com.bumptech.glide;
+
+import static com.bumptech.glide.test.Matchers.anyDrawable;
+import static com.bumptech.glide.test.Matchers.anyDrawableTarget;
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.anyBoolean;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.EncodeStrategy;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceEncoder;
+import com.bumptech.glide.load.engine.GlideException;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy;
+import com.bumptech.glide.request.FutureTarget;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import com.bumptech.glide.test.WaitModelLoader;
+import com.bumptech.glide.test.WaitModelLoader.WaitModel;
+import java.io.File;
+import java.util.concurrent.CountDownLatch;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(AndroidJUnit4.class)
+public class ErrorHandlingTest {
+
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+  @Mock private RequestListener<Drawable> requestListener;
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+
+  private Context context;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    context = InstrumentationRegistry.getTargetContext();
+  }
+
+  // ResourceEncoders are expected not to throw and to return true or false. If they do throw, it's
+  // a developer error, so we expect UncaughtThrowableStrategy to be called.
+  @Test
+  public void load_whenEncoderFails_callsUncaughtThrowableStrategy() {
+    WaitForErrorStrategy strategy = new WaitForErrorStrategy();
+    Glide.init(context,
+        new GlideBuilder()
+            .setAnimationExecutor(GlideExecutor.newAnimationExecutor(/*threadCount=*/ 1, strategy))
+            .setSourceExecutor(GlideExecutor.newSourceExecutor(strategy))
+            .setDiskCacheExecutor(GlideExecutor.newDiskCacheExecutor(strategy)));
+    Glide.get(context).getRegistry().prepend(Bitmap.class, new FailEncoder());
+
+    concurrency.get(
+        Glide.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+            .submit());
+
+    // Writing to the disk cache and therefore the exception caused by our FailEncoder may happen
+    // after the request completes, so we should wait for the expected error explicitly.
+    ConcurrencyHelper.waitOnLatch(strategy.latch);
+    assertThat(strategy.error).isEqualTo(FailEncoder.TO_THROW);
+
+    verify(requestListener, never())
+        .onLoadFailed(any(GlideException.class), any(), anyDrawableTarget(), anyBoolean());
+  }
+
+  @Test
+  public void load_whenLoadSucceeds_butEncoderFails_doesNotCallOnLoadFailed() {
+    WaitForErrorStrategy strategy = new WaitForErrorStrategy();
+    Glide.init(context,
+        new GlideBuilder()
+            .setAnimationExecutor(GlideExecutor.newAnimationExecutor(/*threadCount=*/ 1, strategy))
+            .setSourceExecutor(GlideExecutor.newSourceExecutor(strategy))
+            .setDiskCacheExecutor(GlideExecutor.newDiskCacheExecutor(strategy)));
+    Glide.get(context).getRegistry().prepend(Bitmap.class, new FailEncoder());
+
+    concurrency.get(
+        Glide.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            any(DataSource.class),
+            anyBoolean());
+    verify(requestListener, never())
+        .onLoadFailed(any(GlideException.class), any(), anyDrawableTarget(), anyBoolean());
+  }
+
+  @Test
+  public void clearRequest_withError_afterPrimaryFails_clearsErrorRequest() {
+    WaitModel<Integer> errorModel = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);
+
+    FutureTarget<Drawable> target =
+        Glide.with(context)
+            .load((Object) null)
+            .error(
+                Glide.with(context)
+                    .load(errorModel)
+                    .listener(requestListener))
+            .submit();
+
+    Glide.with(context).clear(target);
+    errorModel.countDown();
+
+    // Make sure any pending requests run.
+    concurrency.pokeMainThread();
+    Glide.tearDown();
+    // Make sure that any callbacks posted back to the main thread run.
+    concurrency.pokeMainThread();
+  }
+
+  private static final class WaitForErrorStrategy implements UncaughtThrowableStrategy {
+    final CountDownLatch latch = new CountDownLatch(1);
+    @Nullable Throwable error = null;
+
+    @Override
+    public void handle(Throwable t) {
+      if (error != null) {
+        throw new IllegalArgumentException("Received second error", t);
+      }
+      error = t;
+      latch.countDown();
+    }
+  }
+
+  private static final class FailEncoder implements ResourceEncoder<Bitmap> {
+
+    static final RuntimeException TO_THROW = new RuntimeException();
+
+    @NonNull
+    @Override
+    public EncodeStrategy getEncodeStrategy(@NonNull Options options) {
+      return EncodeStrategy.TRANSFORMED;
+    }
+
+    @Override
+    public boolean encode(
+        @NonNull Resource<Bitmap> data, @NonNull File file, @NonNull Options options) {
+      throw TO_THROW;
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/ExternallyClearedDiskCacheTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/ExternallyClearedDiskCacheTest.java
new file mode 100644
index 000000000..5945ef428
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/ExternallyClearedDiskCacheTest.java
@@ -0,0 +1,125 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.mock;
+
+import android.content.Context;
+import android.graphics.drawable.Drawable;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.engine.cache.DiskCache;
+import com.bumptech.glide.load.engine.cache.DiskCache.Factory;
+import com.bumptech.glide.load.engine.cache.DiskLruCacheWrapper;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.ResourceIds.raw;
+import com.bumptech.glide.test.TearDownGlide;
+import java.io.File;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+// Tests #2465.
+@RunWith(AndroidJUnit4.class)
+public class ExternallyClearedDiskCacheTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private Context context;
+  private File cacheDir;
+
+  @Before
+  public void setUp() {
+    context = InstrumentationRegistry.getTargetContext();
+    cacheDir = context.getCacheDir();
+  }
+
+  @After
+  public void tearDown() {
+    // Force us to wait until Glide's threads shut down.
+    Glide.tearDown();
+    deleteRecursively(cacheDir);
+  }
+
+  @Test
+  public void clearDiskCache_afterOpeningDiskCache_andDeleteDirectoryOutsideGlide_doesNotThrow() {
+    DiskCache cache = DiskLruCacheWrapper.create(cacheDir, 1024 * 1024);
+    cache.get(mock(Key.class));
+    deleteRecursively(cacheDir);
+    cache.clear();
+  }
+
+  @Test
+  public void get_afterDeleteDirectoryOutsideGlideAndClose_doesNotThrow() {
+    DiskCache cache = DiskLruCacheWrapper.create(cacheDir, 1024 * 1024);
+    cache.get(mock(Key.class));
+    deleteRecursively(cacheDir);
+    cache.clear();
+
+    cache.get(mock(Key.class));
+  }
+
+  @Test
+  public void loadFromCache_afterDiskCacheDeletedAndCleared_doesNotFail() {
+    final DiskCache cache = DiskLruCacheWrapper.create(cacheDir, 1024 * 1024);
+    cache.get(mock(Key.class));
+    deleteRecursively(cacheDir);
+    cache.clear();
+
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setDiskCache(new Factory() {
+              @Override
+              public DiskCache build() {
+                return cache;
+              }
+            }));
+
+    Drawable drawable =
+        concurrency.get(
+            Glide.with(context)
+                .load(ResourceIds.raw.canonical)
+                .submit());
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void loadFromCache_afterDiskCacheDeleted_doesNotFail() {
+    final DiskCache cache = DiskLruCacheWrapper.create(cacheDir, 1024 * 1024);
+    cache.get(mock(Key.class));
+    deleteRecursively(cacheDir);
+
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setDiskCache(new Factory() {
+              @Override
+              public DiskCache build() {
+                return cache;
+              }
+            }));
+
+    Drawable drawable =
+        concurrency.get(Glide.with(context)
+            .load(raw.canonical)
+            .submit());
+    assertThat(drawable).isNotNull();
+  }
+
+  private static void deleteRecursively(File file) {
+    if (file.isDirectory()) {
+      File[] files = file.listFiles();
+      if (files != null) {
+        for (File f : files) {
+          deleteRecursively(f);
+        }
+      }
+    }
+    if (!file.delete() && file.exists()) {
+      throw new RuntimeException("Failed to delete: " + file);
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/FitCenterRegressionTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/FitCenterRegressionTest.java
new file mode 100644
index 000000000..b2f7a4aa4
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/FitCenterRegressionTest.java
@@ -0,0 +1,130 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertThrows;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
+import com.bumptech.glide.test.BitmapRegressionTester;
+import com.bumptech.glide.test.CanonicalBitmap;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.RegressionTest;
+import com.bumptech.glide.test.SplitByCpu;
+import com.bumptech.glide.test.SplitBySdk;
+import com.bumptech.glide.test.TearDownGlide;
+import java.util.concurrent.ExecutionException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.function.ThrowingRunnable;
+import org.junit.rules.TestName;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+@SplitByCpu
+@SplitBySdk({24, 23, 21, 19, 18, 16})
+@RegressionTest
+public class FitCenterRegressionTest {
+  @Rule public final TestName testName = new TestName();
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private BitmapRegressionTester bitmapRegressionTester;
+  private Context context;
+  private CanonicalBitmap canonical;
+
+  @Before
+  public void setUp() {
+    context = InstrumentationRegistry.getTargetContext();
+    bitmapRegressionTester = new BitmapRegressionTester(getClass(), testName);
+    canonical = new CanonicalBitmap();
+  }
+
+  @Test
+  public void fitCenter_withSquareSmallerThanImage_returnsImageFitWithinSquare()
+      throws ExecutionException, InterruptedException {
+
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .fitCenter()
+                .override(50));
+
+    assertThat(result.getWidth()).isEqualTo(50);
+    assertThat(result.getHeight()).isEqualTo(37);
+  }
+
+  @Test
+  public void fitCenter_withSquareLargerThanImage_returnsUpscaledSquare()
+      throws ExecutionException, InterruptedException {
+    float multiplier = 1.1f;
+    int multipliedWidth = (int) (canonical.getWidth() * multiplier);
+    int multipliedHeight = (int) (canonical.getHeight() * multiplier);
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+              .asBitmap()
+              .load(canonical.getBitmap())
+              .fitCenter()
+              .override(multipliedWidth));
+
+    assertThat(result.getWidth()).isEqualTo(multipliedWidth);
+    assertThat(result.getHeight()).isEqualTo(multipliedHeight);
+  }
+
+  @Test
+  public void fitCenter_withNarrowRectangle_fitsWithinMaintainingAspectRatio()
+      throws ExecutionException, InterruptedException {
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+              .asBitmap()
+              .load(canonical.getBitmap())
+              .fitCenter()
+              .override(canonical.getWidth() / 10, canonical.getHeight()));
+
+    assertThat(result.getWidth()).isEqualTo(canonical.getWidth() / 10);
+    assertThat(result.getHeight()).isEqualTo(canonical.getHeight() / 10);
+  }
+
+  @Test
+  public void fitCenter_withShortRectangle_fitsWithinMaintainingAspectRatio()
+      throws ExecutionException, InterruptedException {
+     Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+              .asBitmap()
+              .load(canonical.getBitmap())
+              .fitCenter()
+              .override(canonical.getWidth(), canonical.getHeight() / 2));
+
+    assertThat(result.getWidth()).isEqualTo(canonical.getWidth() / 2);
+    assertThat(result.getHeight()).isEqualTo(canonical.getHeight() / 2);
+  }
+
+  @Test
+  public void fitCenter_withHugeRectangle_throwsOOM()
+      throws ExecutionException, InterruptedException {
+    float multiplier = Integer.MAX_VALUE / (canonical.getWidth() * canonical.getHeight() * 2);
+    final int overrideWidth = (int) multiplier * canonical.getWidth();
+    final int overrideHeight = (int) multiplier * canonical.getHeight();
+
+    assertThrows(
+        ExecutionException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() throws Throwable {
+            GlideApp
+                .with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .fitCenter()
+                .override(overrideWidth, overrideHeight)
+                .submit()
+                .get();
+          }
+        });
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBitmapTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBitmapTest.java
new file mode 100644
index 000000000..7365aa0c5
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBitmapTest.java
@@ -0,0 +1,363 @@
+package com.bumptech.glide;
+
+
+import static com.bumptech.glide.test.Matchers.anyBitmap;
+import static com.bumptech.glide.test.Matchers.anyBitmapTarget;
+import static com.bumptech.glide.test.Matchers.anyDrawable;
+import static com.bumptech.glide.test.Matchers.anyDrawableTarget;
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.anyBoolean;
+import static org.mockito.Mockito.eq;
+import static org.mockito.Mockito.verify;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.drawable.Drawable;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruBitmapPool;
+import com.bumptech.glide.load.engine.cache.LruResourceCache;
+import com.bumptech.glide.load.engine.cache.MemoryCacheAdapter;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import com.bumptech.glide.util.Util;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(AndroidJUnit4.class)
+public class LoadBitmapTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  @Mock private RequestListener<Bitmap> bitmapListener;
+  @Mock private RequestListener<Drawable> drawableListener;
+
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private Context context;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    context = InstrumentationRegistry.getTargetContext();
+  }
+
+  @Test
+  public void clearFromRequestBuilder_asDrawable_withLoadedBitmap_doesNotRecycleBitmap() {
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new MemoryCacheAdapter())
+        .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    Target<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .asDrawable()
+                .load(bitmap)
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    // Allow Glide's resource recycler to run on the main thread.
+    concurrency.pokeMainThread();
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void transformFromRequestBuilder_asDrawable_withLoadedBitmap_doesNotRecycleBitmap() {
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new MemoryCacheAdapter())
+        .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(bitmap)
+            .centerCrop()
+            .submit(100, 100));
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void clearFromRequestManager_withLoadedBitmap_doesNotRecycleBitmap() {
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new MemoryCacheAdapter())
+        .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    Target<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .load(bitmap)
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    // Allow Glide's resource recycler to run on the main thread.
+    concurrency.pokeMainThread();
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void transformFromRequestManager_withLoadedBitmap_doesNotRecycleBitmap() {
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new MemoryCacheAdapter())
+        .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(bitmap)
+            .centerCrop()
+            .submit(100, 100));
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void clearFromRequestBuilder_withLoadedBitmap_asBitmap_doesNotRecycleBitmap() {
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new MemoryCacheAdapter())
+        .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    Target<Bitmap> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(bitmap)
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    // Allow Glide's resource recycler to run on the main thread.
+    concurrency.pokeMainThread();
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void transformFromRequestBuilder_withLoadedBitmap_asBitmap_doesNotRecycleBitmap() {
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new MemoryCacheAdapter())
+        .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    concurrency.wait(
+        GlideApp.with(context)
+            .asBitmap()
+            .load(bitmap)
+            .centerCrop()
+            .submit(100, 100));
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void loadFromRequestManager_withBitmap_doesNotLoadFromDiskCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Target<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .load(bitmap)
+                .centerCrop()
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(bitmap)
+            .centerCrop()
+            .listener(drawableListener)
+            .submit(100, 100));
+
+    verify(drawableListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.LOCAL),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_asDrawable_withBitmap_doesNotLoadFromDiskCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Target<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .asDrawable()
+                .load(bitmap)
+                .centerCrop()
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(bitmap)
+            .centerCrop()
+            .listener(drawableListener)
+            .submit(100, 100));
+
+    verify(drawableListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.LOCAL),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_asDrawable_withBitmapAndStrategyBeforeLoad_notFromCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Target<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .asDrawable()
+                .diskCacheStrategy(DiskCacheStrategy.ALL)
+                .load(bitmap)
+                .centerCrop()
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(bitmap)
+            .centerCrop()
+            .listener(drawableListener)
+            .submit(100, 100));
+
+    verify(drawableListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.LOCAL),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_asBitmap_withBitmap_doesNotLoadFromDiskCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Target<Bitmap> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(bitmap)
+                .centerCrop()
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asBitmap()
+            .load(bitmap)
+            .centerCrop()
+            .listener(bitmapListener)
+            .submit(100, 100));
+
+    verify(bitmapListener)
+        .onResourceReady(
+            anyBitmap(),
+            any(),
+            anyBitmapTarget(),
+            eq(DataSource.LOCAL),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_asBitmap_withBitmapAndStrategyBeforeLoad_notFromCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Target<Bitmap> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .asBitmap()
+                .diskCacheStrategy(DiskCacheStrategy.ALL)
+                .load(bitmap)
+                .centerCrop()
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asBitmap()
+            .load(bitmap)
+            .centerCrop()
+            .listener(bitmapListener)
+            .submit(100, 100));
+
+    verify(bitmapListener)
+        .onResourceReady(
+            anyBitmap(),
+            any(),
+            anyBitmapTarget(),
+            eq(DataSource.LOCAL),
+            anyBoolean());
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBytesTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBytesTest.java
new file mode 100644
index 000000000..db3802c31
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBytesTest.java
@@ -0,0 +1,525 @@
+package com.bumptech.glide;
+
+import static com.bumptech.glide.test.GlideOptions.skipMemoryCacheOf;
+import static com.bumptech.glide.test.Matchers.anyDrawable;
+import static com.bumptech.glide.test.Matchers.anyDrawableTarget;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.anyBoolean;
+import static org.mockito.Mockito.eq;
+import static org.mockito.Mockito.verify;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.CompressFormat;
+import android.graphics.Bitmap.Config;
+import android.graphics.BitmapFactory;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.widget.AbsListView.LayoutParams;
+import android.widget.ImageView;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.load.engine.executor.MockGlideExecutor;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.test.BitmapSubject;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import com.google.common.io.ByteStreams;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(AndroidJUnit4.class)
+public class LoadBytesTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+
+  @Mock private RequestListener<Drawable> requestListener;
+
+  private Context context;
+  private ImageView imageView;
+
+  @Before
+  public void setUp() throws IOException {
+    MockitoAnnotations.initMocks(this);
+    context = InstrumentationRegistry.getTargetContext();
+
+    imageView = new ImageView(context);
+    int[] dimensions = getCanonicalDimensions();
+    imageView.setLayoutParams(new LayoutParams(/*w=*/ dimensions[0], /*h=*/ dimensions[1]));
+
+    // Writes to the resource disk cache run in a non-blocking manner after the Target is notified.
+    // Unless we enforce a single threaded executor, the encode task races with our second decode
+    // task, causing the test to sometimes fail (when the second resource is started after the
+    // encode and loaded from the disk cache) and sometimes succeed (when the second resource is
+    // started before the encode and loads from source).
+    ExecutorService executor = Executors.newSingleThreadExecutor();
+    GlideExecutor glideExecutor = MockGlideExecutor.newTestExecutor(executor);
+    Glide.init(context, new GlideBuilder()
+        .setAnimationExecutor(glideExecutor)
+        .setDiskCacheExecutor(glideExecutor)
+        .setSourceExecutor(glideExecutor));
+  }
+
+  @Test
+  public void loadFromRequestManager_intoImageView_withDifferentByteArrays_loadsDifferentImages()
+      throws IOException, ExecutionException, InterruptedException {
+    final byte[] canonicalBytes = getCanonicalBytes();
+    final byte[] modifiedBytes = getModifiedBytes();
+
+    concurrency.loadOnMainThread(
+        Glide.with(context).load(canonicalBytes), imageView);
+    Bitmap firstBitmap = copyFromImageViewDrawable(imageView);
+
+    concurrency.loadOnMainThread(
+        Glide.with(context).load(modifiedBytes), imageView);
+    Bitmap secondBitmap = copyFromImageViewDrawable(imageView);
+
+    // This assertion alone doesn't catch the case where the second Bitmap is loaded from the result
+    // cache of the data from the first Bitmap.
+    BitmapSubject.assertThat(firstBitmap).isNotSameAs(secondBitmap);
+
+    Bitmap expectedCanonicalBitmap =
+        BitmapFactory.decodeByteArray(canonicalBytes, /*offset=*/ 0, canonicalBytes.length);
+    BitmapSubject.assertThat(firstBitmap).sameAs(expectedCanonicalBitmap);
+
+    Bitmap expectedModifiedBitmap =
+        BitmapFactory.decodeByteArray(modifiedBytes, /*offset=*/ 0, modifiedBytes.length);
+    BitmapSubject.assertThat(secondBitmap).sameAs(expectedModifiedBitmap);
+  }
+
+  @Test
+  public void loadFromRequestBuilder_intoImageView_withDifferentByteArrays_loadsDifferentImages()
+      throws IOException, ExecutionException, InterruptedException {
+    final byte[] canonicalBytes = getCanonicalBytes();
+    final byte[] modifiedBytes = getModifiedBytes();
+
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(canonicalBytes),
+        imageView);
+    Bitmap firstBitmap = copyFromImageViewDrawable(imageView);
+
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(modifiedBytes),
+        imageView);
+    Bitmap secondBitmap = copyFromImageViewDrawable(imageView);
+
+    // This assertion alone doesn't catch the case where the second Bitmap is loaded from the result
+    // cache of the data from the first Bitmap.
+    BitmapSubject.assertThat(firstBitmap).isNotSameAs(secondBitmap);
+
+    Bitmap expectedCanonicalBitmap =
+        BitmapFactory.decodeByteArray(canonicalBytes, /*offset=*/ 0, canonicalBytes.length);
+    BitmapSubject.assertThat(firstBitmap).sameAs(expectedCanonicalBitmap);
+
+    Bitmap expectedModifiedBitmap =
+        BitmapFactory.decodeByteArray(modifiedBytes, /*offset=*/ 0, modifiedBytes.length);
+    BitmapSubject.assertThat(secondBitmap).sameAs(expectedModifiedBitmap);
+  }
+
+  @Test
+  public void requestManager_intoImageView_withSameByteArrayAndMemoryCacheEnabled_loadsFromMemory()
+      throws IOException {
+    final byte[] canonicalBytes = getCanonicalBytes();
+    concurrency.loadOnMainThread(
+        Glide.with(context)
+            .load(canonicalBytes)
+            .apply(skipMemoryCacheOf(false)),
+        imageView);
+
+    Glide.with(context).clear(imageView);
+
+    concurrency.loadOnMainThread(
+        Glide.with(context)
+            .load(canonicalBytes)
+            .listener(requestListener)
+            .apply(skipMemoryCacheOf(false)),
+        imageView);
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
+  }
+
+  @Test
+  public void requestBuilder_intoImageView_withSameByteArrayAndMemoryCacheEnabled_loadsFromMemory()
+      throws IOException {
+    final byte[] canonicalBytes = getCanonicalBytes();
+    concurrency.loadOnMainThread(
+        Glide.with(context)
+            .asDrawable()
+            .load(canonicalBytes)
+            .apply(skipMemoryCacheOf(false)),
+        imageView);
+
+    Glide.with(context).clear(imageView);
+
+    concurrency.loadOnMainThread(
+        Glide.with(context)
+            .asDrawable()
+            .load(canonicalBytes)
+            .listener(requestListener)
+            .apply(skipMemoryCacheOf(false)),
+        imageView);
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestManager_withSameByteArray_validDiskCacheStrategy_returnsFromDiskCache()
+      throws IOException {
+    byte[] data = getCanonicalBytes();
+    Target<Drawable> target = concurrency.wait(
+        GlideApp.with(context)
+            .load(data)
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(data)
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.RESOURCE_DISK_CACHE),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_withSameByteArray_validDiskCacheStrategy_returnsFromDiskCache()
+      throws IOException {
+    byte[] data = getCanonicalBytes();
+    Target<Drawable> target = concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(data)
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(data)
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.RESOURCE_DISK_CACHE),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestManager_withSameByteArray_memoryCacheEnabled_returnsFromCache()
+      throws IOException {
+    byte[] data = getCanonicalBytes();
+    Target<Drawable> target = concurrency.wait(
+        GlideApp.with(context)
+            .load(data)
+            .skipMemoryCache(false)
+            .submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(data)
+            .skipMemoryCache(false)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_withSameByteArray_memoryCacheEnabled_returnsFromCache()
+      throws IOException {
+    byte[] data = getCanonicalBytes();
+    Target<Drawable> target = concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(data)
+            .skipMemoryCache(false)
+            .submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(data)
+            .skipMemoryCache(false)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestManager_withSameByteArray_returnsFromLocal() throws IOException {
+    byte[] data = getCanonicalBytes();
+    Target<Drawable> target = concurrency.wait(
+        GlideApp.with(context)
+            .load(data)
+            .submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(data)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_withSameByteArray_returnsFromLocal() throws IOException {
+    byte[] data = getCanonicalBytes();
+    Target<Drawable> target = concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(data)
+            .submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(data)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestManager_withSameByteArrayAndMissingFromMemory_returnsFromLocal()
+       throws IOException {
+    byte[] data = getCanonicalBytes();
+    Target<Drawable> target = concurrency.wait(
+        GlideApp.with(context)
+            .load(data)
+            .submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(data)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_withSameByteArrayAndMissingFromMemory_returnsFromLocal()
+       throws IOException {
+    byte[] data = getCanonicalBytes();
+    Target<Drawable> target = concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(data)
+            .submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(data)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
+  }
+
+  @Test
+  public void loadFromBuilder_withDiskCacheStrategySetBeforeLoad_doesNotOverrideDiskCacheStrategy()
+      throws IOException {
+    byte[] data = getCanonicalBytes();
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .load(data)
+            .submit());
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .listener(requestListener)
+            .load(data)
+            .submit());
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.RESOURCE_DISK_CACHE),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromBuilder_withSkipMemoryCacheSetBeforeLoad_doesNotOverrideSkipMemoryCache()
+      throws IOException {
+    byte[] data = getCanonicalBytes();
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .skipMemoryCache(false)
+            .load(data)
+            .submit());
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .skipMemoryCache(false)
+            .listener(requestListener)
+            .load(data)
+            .submit());
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
+  }
+
+  @Test
+  public void loadFromBuilder_withDataDiskCacheStrategy_returnsFromSource() throws IOException {
+    byte[] data = getCanonicalBytes();
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .diskCacheStrategy(DiskCacheStrategy.DATA)
+            .load(data)
+            .submit());
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .diskCacheStrategy(DiskCacheStrategy.DATA)
+            .skipMemoryCache(true)
+            .load(data)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(),
+        any(),
+        anyDrawableTarget(),
+        eq(DataSource.DATA_DISK_CACHE),
+        anyBoolean());
+  }
+
+  private Bitmap copyFromImageViewDrawable(ImageView imageView) {
+    if (imageView.getDrawable() == null) {
+      fail("Drawable unexpectedly null");
+    }
+
+    // Glide mutates Bitmaps, so it's possible that a Bitmap loaded into a View in one place may
+    // be re-used to load a different image later. Create a defensive copy just in case.
+    return Bitmap.createBitmap(((BitmapDrawable) imageView.getDrawable()).getBitmap());
+  }
+
+  private int[] getCanonicalDimensions() throws IOException {
+    byte[] canonicalBytes = getCanonicalBytes();
+    Bitmap bitmap =
+        BitmapFactory.decodeByteArray(canonicalBytes, /*offset=*/ 0, canonicalBytes.length);
+    return new int[] { bitmap.getWidth(), bitmap.getHeight() };
+  }
+
+  private byte[] getModifiedBytes() throws IOException {
+    int[] dimensions = getCanonicalDimensions();
+    Bitmap bitmap = Bitmap.createBitmap(dimensions[0], dimensions[1], Config.ARGB_8888);
+    ByteArrayOutputStream os = new ByteArrayOutputStream();
+    bitmap.compress(CompressFormat.PNG, /*quality=*/ 100, os);
+    return os.toByteArray();
+  }
+
+  private byte[] getCanonicalBytes() throws IOException {
+    int resourceId = ResourceIds.raw.canonical;
+    Resources resources = context.getResources();
+    InputStream is = resources.openRawResource(resourceId);
+    return ByteStreams.toByteArray(is);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadDrawableTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadDrawableTest.java
new file mode 100644
index 000000000..f1290ef9e
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadDrawableTest.java
@@ -0,0 +1,212 @@
+package com.bumptech.glide;
+
+import static com.bumptech.glide.test.Matchers.anyDrawable;
+import static com.bumptech.glide.test.Matchers.anyDrawableTarget;
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.anyBoolean;
+import static org.mockito.Mockito.eq;
+import static org.mockito.Mockito.verify;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruBitmapPool;
+import com.bumptech.glide.load.engine.cache.LruResourceCache;
+import com.bumptech.glide.load.engine.cache.MemoryCacheAdapter;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import com.bumptech.glide.util.Util;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(AndroidJUnit4.class)
+public class LoadDrawableTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+
+  @Mock private RequestListener<Drawable> listener;
+
+  private Context context;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
+    context = InstrumentationRegistry.getTargetContext();
+  }
+
+  @Test
+  public void clear_withLoadedBitmapDrawable_doesNotRecycleBitmap() {
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new MemoryCacheAdapter())
+        .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+    Target<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .load(drawable)
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    // Allow Glide's resource recycler to run on the main thread.
+    concurrency.pokeMainThread();
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void transform_withLoadedBitmapDrawable_doesNotRecycleBitmap() {
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new MemoryCacheAdapter())
+        .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(drawable)
+            .centerCrop()
+            .submit(100, 100));
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void loadFromRequestManager_withBitmap_doesNotLoadFromDiskCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Target<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .load(drawable)
+                .centerCrop()
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(drawable)
+            .centerCrop()
+            .listener(listener)
+            .submit(100, 100));
+
+    verify(listener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.LOCAL),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_asDrawable_withBitmap_doesNotLoadFromDiskCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Target<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .asDrawable()
+                .load(drawable)
+                .centerCrop()
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(drawable)
+            .centerCrop()
+            .listener(listener)
+            .submit(100, 100));
+
+    verify(listener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.LOCAL),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_asDrawable_withBitmapAndStrategyBeforeLoad_notFromCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Target<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .asDrawable()
+                .diskCacheStrategy(DiskCacheStrategy.ALL)
+                .load(drawable)
+                .centerCrop()
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(drawable)
+            .centerCrop()
+            .listener(listener)
+            .submit(100, 100));
+
+    verify(listener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.LOCAL),
+            anyBoolean());
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadResourcesWithDownsamplerTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadResourcesWithDownsamplerTest.java
new file mode 100644
index 000000000..38ef87b5c
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadResourcesWithDownsamplerTest.java
@@ -0,0 +1,350 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assume.assumeTrue;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.ColorSpace;
+import android.net.Uri;
+import android.os.Build;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.NonNull;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.model.ModelLoader;
+import com.bumptech.glide.load.model.ModelLoaderFactory;
+import com.bumptech.glide.load.model.MultiModelLoaderFactory;
+import com.bumptech.glide.load.resource.bitmap.Downsampler;
+import com.bumptech.glide.signature.ObjectKey;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import java.io.ByteArrayOutputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Locale;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/**
+ * On API 26, decoding a variety of different images can cause {@link BitmapFactory} with
+ * {@link BitmapFactory.Options#inJustDecodeBounds} set to {@code true} to set
+ * {@link BitmapFactory.Options#outConfig} to null instead of a valid value, even though the image
+ * can be decoded successfully. Glide can mask these failures by decoding some image sources
+ * (notably including resource ids) using other data types and decoders.
+ *
+ * <p>This test ensures that we've worked around the framework issue by loading a variety of images
+ * and image types without the normal fallback behavior.
+ */
+@RunWith(AndroidJUnit4.class)
+public class LoadResourcesWithDownsamplerTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private final Context context = InstrumentationRegistry.getTargetContext();
+
+  @Test
+  public void loadJpegResource_withNoOtherLoaders_decodesResource() {
+    Glide.get(context).getRegistry()
+        .prepend(
+            Object.class,
+            InputStream.class,
+            new FakeModelLoader<>(ResourceIds.raw.canonical));
+
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(new Object())
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void loadWideGamutJpegResource_withNoOtherLoaders_decodesWideGamutBitmap() {
+    assumeTrue(
+        "Wide gamut is only available on O+", Build.VERSION.SDK_INT >= Build.VERSION_CODES.O);
+    Glide.get(context).getRegistry()
+        .prepend(
+            Object.class,
+            InputStream.class,
+            new FakeModelLoader<>(ResourceIds.raw.webkit_logo_p3));
+
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(new Object())
+                .submit());
+    assertThat(bitmap).isNotNull();
+    assertThat(bitmap.getConfig()).isEqualTo(Bitmap.Config.RGBA_F16);
+    assertThat(bitmap.getColorSpace())
+        .isEqualTo(ColorSpace.get(ColorSpace.Named.LINEAR_EXTENDED_SRGB));
+  }
+
+  @Test
+  public void loadOpaquePngResource_withNoOtherLoaders_decodesResource() {
+    Glide.get(context).getRegistry()
+        .prepend(
+            Object.class,
+            InputStream.class,
+            new FakeModelLoader<>(ResourceIds.raw.canonical_png));
+
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(new Object())
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void loadTransparentPngResource_withNoOtherLoaders_decodesResource() {
+    Glide.get(context).getRegistry()
+        .prepend(
+            Object.class,
+            InputStream.class,
+            new FakeModelLoader<>(ResourceIds.raw.canonical_transparent_png));
+
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(new Object())
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void loadTransparentGifResource_withNoOtherLoaders_decodesResource() {
+    Glide.get(context).getRegistry()
+        .prepend(
+            Object.class,
+            InputStream.class,
+            new FakeModelLoader<>(ResourceIds.raw.transparent_gif));
+
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(new Object())
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void loadTransparentGifResource_asHardware_withNoOtherLoaders_decodesResource() {
+    assumeTrue(
+        "Hardware Bitmaps are only supported on O+",
+        Build.VERSION.SDK_INT >= Build.VERSION_CODES.O);
+
+    Glide.get(context).getRegistry()
+        .prepend(
+            Object.class,
+            InputStream.class,
+            new FakeModelLoader<>(ResourceIds.raw.transparent_gif));
+
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .set(Downsampler.ALLOW_HARDWARE_CONFIG, true)
+                .format(DecodeFormat.PREFER_ARGB_8888)
+                .load(new Object())
+                .submit());
+    assertThat(bitmap).isNotNull();
+    assertThat(bitmap.getConfig()).isEqualTo(Bitmap.Config.HARDWARE);
+  }
+
+  @Test
+  public void loadTransparentGifResource_withNoOtherLoaders_fromBytes_decodesResource() {
+    byte[] data = getBytes(ResourceIds.raw.transparent_gif);
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(data)
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void loadOpaqueGifResource_withNoOtherLoaders_decodesResource() {
+    Glide.get(context).getRegistry()
+        .prepend(
+            Object.class,
+            InputStream.class,
+            new FakeModelLoader<>(ResourceIds.raw.opaque_gif));
+
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(new Object())
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void loadOpaqueGifResource_asBytes_decodesResource() {
+    byte[] data = getBytes(ResourceIds.raw.opaque_gif);
+     Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(data)
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void loadOpaqueGifResource_asHardware_withNoOtherLoaders_decodesResource() {
+    assumeTrue(
+        "Hardware Bitmaps are only supported on O+",
+        Build.VERSION.SDK_INT >= Build.VERSION_CODES.O);
+
+    Glide.get(context).getRegistry()
+        .prepend(
+            Object.class,
+            InputStream.class,
+            new FakeModelLoader<>(ResourceIds.raw.opaque_gif));
+
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                // Allow HARDWARE Bitmaps.
+                .format(DecodeFormat.PREFER_ARGB_8888)
+                .load(new Object())
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+
+  private byte[] getBytes(int resourceId) {
+    ByteArrayOutputStream os = new ByteArrayOutputStream();
+    InputStream is = null;
+    try {
+      is = context.getResources().openRawResource(resourceId);
+      byte[] buffer = new byte[1024 * 1024];
+      int read;
+      while ((read = is.read(buffer)) != -1) {
+        os.write(buffer, 0, read);
+      }
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    } finally {
+      if (is != null) {
+        try {
+          is.close();
+        } catch (IOException e) {
+          // Ignored;
+        }
+      }
+    }
+
+    return os.toByteArray();
+  }
+
+  private class FakeModelLoader<T> implements
+      ModelLoader<T, InputStream>,
+      ModelLoaderFactory<T, InputStream> {
+
+    private final int resourceId;
+
+    FakeModelLoader(int resourceId) {
+      this.resourceId = resourceId;
+    }
+
+    @android.support.annotation.Nullable
+    @Override
+    public LoadData<InputStream> buildLoadData(@NonNull Object o, int width, int height,
+        @NonNull Options options) {
+      return new LoadData<>(new ObjectKey(o), new Fetcher());
+    }
+
+    @Override
+    public boolean handles(@NonNull Object o) {
+      return true;
+    }
+
+    @NonNull
+    @Override
+    public ModelLoader<T, InputStream> build(@NonNull MultiModelLoaderFactory multiFactory) {
+      return this;
+    }
+
+    @Override
+    public void teardown() { }
+
+    private final class Fetcher implements DataFetcher<InputStream> {
+      private InputStream inputStream;
+
+      @Override
+      public void loadData(@NonNull Priority priority,
+          @NonNull DataCallback<? super InputStream> callback) {
+        inputStream = getInputStreamForResource(context, resourceId);
+        callback.onDataReady(inputStream);
+      }
+
+      private InputStream getInputStreamForResource(
+          Context context, @DrawableRes int resourceId) {
+        Resources resources = context.getResources();
+        try {
+          Uri parse =
+              Uri.parse(
+                  String.format(
+                      Locale.US,
+                      "%s://%s/%s/%s",
+                      ContentResolver.SCHEME_ANDROID_RESOURCE,
+                      resources.getResourcePackageName(resourceId),
+                      resources.getResourceTypeName(resourceId),
+                      resources.getResourceEntryName(resourceId)));
+          return context.getContentResolver().openInputStream(parse);
+        } catch (Resources.NotFoundException | FileNotFoundException e) {
+          throw new IllegalArgumentException("Resource ID " + resourceId + " not found", e);
+        }
+      }
+
+      @Override
+      public void cleanup() {
+        InputStream local = inputStream;
+        if (local != null) {
+          try {
+            local.close();
+          } catch (IOException e) {
+            // Ignored.
+          }
+        }
+      }
+
+      @Override
+      public void cancel() {
+        // Do nothing.
+      }
+
+      @NonNull
+      @Override
+      public Class<InputStream> getDataClass() {
+        return InputStream.class;
+      }
+
+      @NonNull
+      @Override
+      public DataSource getDataSource() {
+        return DataSource.LOCAL;
+      }
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadVideoResourceTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadVideoResourceTest.java
new file mode 100644
index 000000000..6a559af37
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadVideoResourceTest.java
@@ -0,0 +1,323 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import java.io.IOException;
+import java.util.concurrent.TimeUnit;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.MockitoAnnotations;
+
+/**
+ * Tests that Glide is able to load videos stored in resources and loaded as
+ * {@link android.content.res.AssetFileDescriptor}s.
+ */
+@RunWith(AndroidJUnit4.class)
+public class LoadVideoResourceTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+
+  private Context context;
+
+  @Before
+  public void setUp() throws IOException {
+    MockitoAnnotations.initMocks(this);
+    context = InstrumentationRegistry.getTargetContext();
+  }
+
+  @Test
+  public void loadVideoResourceId_fromInt_decodesFrame() {
+    Drawable frame =
+        concurrency.get(
+            Glide.with(context)
+                .load(ResourceIds.raw.video)
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceId_fromInt_withFrameTime_decodesFrame() {
+    Drawable frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .load(ResourceIds.raw.video)
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  // Testing boxed integer.
+  @SuppressWarnings("UnnecessaryBoxing")
+  @Test
+  public void loadVideoResourceId_fromInteger_decodesFrame() {
+    Drawable frame =
+        concurrency.get(
+            Glide.with(context)
+                .load(new Integer(ResourceIds.raw.video))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  // Testing boxed integer.
+  @SuppressWarnings("UnnecessaryBoxing")
+  @Test
+  public void loadVideoResourceId_fromInteger_withFrameTime_decodesFrame() {
+    Drawable frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .load(new Integer(ResourceIds.raw.video))
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceId_asBitmap_decodesFrame() {
+    Bitmap frame =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(ResourceIds.raw.video)
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceId_asBitmap_withFrameTime_decodesFrame() {
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(ResourceIds.raw.video)
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUri_fromId_decodesFrame() {
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(context.getPackageName())
+            .path(String.valueOf(ResourceIds.raw.video))
+            .build();
+
+    Drawable frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .load(uri)
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUri_asBitmap_fromId_decodesFrame() {
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(context.getPackageName())
+            .path(String.valueOf(ResourceIds.raw.video))
+            .build();
+
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(uri)
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUri_fromId_withFrame_decodesFrame() {
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(context.getPackageName())
+            .path(String.valueOf(ResourceIds.raw.video))
+            .build();
+
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(uri)
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUriString_fromId_decodesFrame() {
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(context.getPackageName())
+            .path(String.valueOf(ResourceIds.raw.video))
+            .build();
+
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(uri.toString())
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUriString_fromId_withFrame_decodesFrame() {
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(context.getPackageName())
+            .path(String.valueOf(ResourceIds.raw.video))
+            .build();
+
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(uri.toString())
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUri_fromName_decodesFrame() {
+    Resources resources = context.getResources();
+    int resourceId = ResourceIds.raw.video;
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(resources.getResourcePackageName(resourceId))
+            .appendPath(resources.getResourceTypeName(resourceId))
+            .appendPath(resources.getResourceEntryName(resourceId))
+            .build();
+
+    Drawable frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .load(uri)
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUri_asBitmap_fromName_decodesFrame() {
+    Resources resources = context.getResources();
+    int resourceId = ResourceIds.raw.video;
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(resources.getResourcePackageName(resourceId))
+            .appendPath(resources.getResourceTypeName(resourceId))
+            .appendPath(resources.getResourceEntryName(resourceId))
+            .build();
+
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(uri)
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUri_fromName_withFrame_decodesFrame() {
+    Resources resources = context.getResources();
+    int resourceId = ResourceIds.raw.video;
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(resources.getResourcePackageName(resourceId))
+            .appendPath(resources.getResourceTypeName(resourceId))
+            .appendPath(resources.getResourceEntryName(resourceId))
+            .build();
+
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(uri)
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUriString_fromName_decodesFrame() {
+    Resources resources = context.getResources();
+    int resourceId = ResourceIds.raw.video;
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(resources.getResourcePackageName(resourceId))
+            .appendPath(resources.getResourceTypeName(resourceId))
+            .appendPath(resources.getResourceEntryName(resourceId))
+            .build();
+
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(uri.toString())
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUriString_fromName_withFrame_decodesFrame() {
+    Resources resources = context.getResources();
+    int resourceId = ResourceIds.raw.video;
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(resources.getResourcePackageName(resourceId))
+            .appendPath(resources.getResourceTypeName(resourceId))
+            .appendPath(resources.getResourceEntryName(resourceId))
+            .build();
+
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(uri.toString())
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java
new file mode 100644
index 000000000..3a57f5293
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java
@@ -0,0 +1,544 @@
+package com.bumptech.glide;
+
+import static com.bumptech.glide.request.RequestOptions.bitmapTransform;
+import static com.bumptech.glide.request.RequestOptions.centerCropTransform;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertThrows;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.content.pm.ResolveInfo;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.resource.bitmap.RoundedCorners;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.ExecutionException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.function.ThrowingRunnable;
+import org.junit.rules.TestName;
+import org.junit.runner.RunWith;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(AndroidJUnit4.class)
+public class NonBitmapDrawableResourcesTest {
+  @Rule public final TestName testName = new TestName();
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+
+  private Context context;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    context = InstrumentationRegistry.getTargetContext();
+  }
+
+  @Test
+  public void load_withBitmapResourceId_asDrawable_producesNonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(android.R.drawable.star_big_off)
+        .submit()
+        .get();
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withBitmapResourceId_asDrawable_withTransformation_producesNonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(android.R.drawable.star_big_off)
+        .apply(centerCropTransform())
+        .submit()
+        .get();
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withBitmapResourceId_asBitmap_producesNonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(android.R.drawable.star_big_off)
+        .submit()
+        .get();
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withBitmapAliasResourceId_asDrawable_producesNonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.bitmap_alias)
+        .submit()
+        .get();
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withBitmapAliasResourceId_asDrawable_withTransformation_producesNonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.bitmap_alias)
+        .apply(centerCropTransform())
+        .submit()
+        .get();
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withBitmapAliasResourceId_asBitmap_producesNonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.bitmap_alias)
+        .submit()
+        .get();
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withShapeDrawableResourceId_asDrawable_producesNonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.shape_drawable)
+        .submit()
+        .get();
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withShapeDrawableResourceId_asDrawable_withTransformation_sizeOriginal_fails()
+      throws ExecutionException, InterruptedException {
+    assertThrows(
+        ExecutionException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() throws Throwable {
+            Glide.with(context)
+                .load(ResourceIds.drawable.shape_drawable)
+                .apply(centerCropTransform())
+                .submit()
+                .get();
+
+          }
+        });
+  }
+
+  @Test
+  public void load_withShapeDrawableResourceId_asDrawable_withTransformation_validSize_succeeds()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.shape_drawable)
+        .apply(bitmapTransform(new RoundedCorners(10)))
+        .submit(100, 200)
+        .get();
+    assertThat(drawable).isNotNull();
+    assertThat(drawable.getIntrinsicWidth()).isEqualTo(100);
+    assertThat(drawable.getIntrinsicHeight()).isEqualTo(200);
+  }
+
+  @Test
+  public void load_withShapeDrawableResourceId_asBitmap_withSizeOriginal_fails()
+      throws ExecutionException, InterruptedException {
+    assertThrows(
+        ExecutionException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() throws Throwable {
+            Glide.with(context)
+                .asBitmap()
+                .load(ResourceIds.drawable.shape_drawable)
+                .submit()
+                .get();
+          }
+        });
+  }
+
+  @Test
+  public void load_withShapeDrawableResourceId_asBitmap_withValidSize_returnsNonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.shape_drawable)
+        .submit(100, 200)
+        .get();
+    assertThat(bitmap).isNotNull();
+    assertThat(bitmap.getWidth()).isEqualTo(100);
+    assertThat(bitmap.getHeight()).isEqualTo(200);
+  }
+
+  @Test
+  public void load_withShapeDrawableResourceId_asBitmap_withValidSizeAndTransform_nonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.shape_drawable)
+        .apply(centerCropTransform())
+        .submit(100, 200)
+        .get();
+    assertThat(bitmap).isNotNull();
+    assertThat(bitmap.getWidth()).isEqualTo(100);
+    assertThat(bitmap.getHeight()).isEqualTo(200);
+  }
+
+  @Test
+  public void load_withStateListDrawableResourceId_asDrawable_producesNonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.state_list_drawable)
+        .submit()
+        .get();
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withStateListDrawableResourceId_asDrawable_withTransformation_nonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.state_list_drawable)
+        .apply(centerCropTransform())
+        .submit()
+        .get();
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withStateListDrawableResourceId_asBitmap_producesNonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.state_list_drawable)
+        .submit()
+        .get();
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withStateListDrawableResourceId_asBitmap_withTransformation_nonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.state_list_drawable)
+        .apply(centerCropTransform())
+        .submit()
+        .get();
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withVectorDrawableResourceId_asDrawable_producesNonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.vector_drawable)
+        .submit()
+        .get();
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withVectorDrawableResourceId_asDrawable_withTransformation_nonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.vector_drawable)
+        .apply(centerCropTransform())
+        .submit()
+        .get();
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withVectorDrawableResourceId_asBitmap_producesNonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.vector_drawable)
+        .submit()
+        .get();
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withVectorDrawableResourceId_asBitmap_withTransformation_producesNonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.vector_drawable)
+        .apply(centerCropTransform())
+        .submit()
+        .get();
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withNinePatchResourceId_asDrawable_producesNonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.googlelogo_color_120x44dp)
+        .submit()
+        .get();
+
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withNinePatchResourceId_asDrawable_withTransformation_producesNonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.googlelogo_color_120x44dp)
+        .apply(centerCropTransform())
+        .submit()
+        .get();
+
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withNinePatchResourceId_asBitmap_producesNonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.googlelogo_color_120x44dp)
+        .submit()
+        .get();
+
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withNinePatchResourceId_asBitmap_withTransformation_producesNonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.googlelogo_color_120x44dp)
+        .apply(centerCropTransform())
+        .submit()
+        .get();
+
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withApplicationIconResourceIdUri_asDrawable_producesNonNullDrawable()
+      throws NameNotFoundException, ExecutionException, InterruptedException {
+    for (String packageName : getInstalledPackages()) {
+      int iconResourceId = getResourceId(packageName);
+
+      Uri uri = new Uri.Builder()
+          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+          .authority(packageName)
+          .path(String.valueOf(iconResourceId))
+          .build();
+
+      Drawable drawable = Glide.with(context)
+          .load(uri)
+          .submit()
+          .get();
+      assertThat(drawable).isNotNull();
+    }
+  }
+
+  @Test
+  public void load_withApplicationIconResourceIdUri_asDrawable_withTransformation_nonNullDrawable()
+      throws NameNotFoundException, ExecutionException, InterruptedException {
+    for (String packageName : getInstalledPackages()) {
+      int iconResourceId = getResourceId(packageName);
+
+      Uri uri = new Uri.Builder()
+          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+          .authority(packageName)
+          .path(String.valueOf(iconResourceId))
+          .build();
+
+      Drawable drawable = Glide.with(context)
+          .load(uri)
+          .apply(centerCropTransform())
+          .submit()
+          .get();
+      assertThat(drawable).isNotNull();
+    }
+  }
+
+  @Test
+  public void load_withApplicationIconResourceIdUri_asBitmap_producesNonNullBitmap()
+      throws NameNotFoundException, ExecutionException, InterruptedException {
+    for (String packageName : getInstalledPackages()) {
+      int iconResourceId = getResourceId(packageName);
+
+      Uri uri = new Uri.Builder()
+          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+          .authority(packageName)
+          .path(String.valueOf(iconResourceId))
+          .build();
+
+      Bitmap bitmap = Glide.with(context)
+          .asBitmap()
+          .load(uri)
+          .submit()
+          .get();
+      assertThat(bitmap).isNotNull();
+    }
+  }
+
+  @Test
+  public void load_withApplicationIconResourceIdUri_asBitmap_withTransformation_nonNullBitmap()
+      throws NameNotFoundException, ExecutionException, InterruptedException {
+    for (String packageName : getInstalledPackages()) {
+      int iconResourceId = getResourceId(packageName);
+
+      Uri uri = new Uri.Builder()
+          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+          .authority(packageName)
+          .path(String.valueOf(iconResourceId))
+          .build();
+
+      Bitmap bitmap = Glide.with(context)
+          .asBitmap()
+          .apply(centerCropTransform())
+          .load(uri)
+          .submit()
+          .get();
+      assertThat(bitmap).isNotNull();
+    }
+  }
+
+  @Test
+  public void load_withApplicationIconResourceNameUri_asDrawable_producesNonNullDrawable()
+      throws ExecutionException, InterruptedException, NameNotFoundException {
+    for (String packageName : getInstalledPackages()) {
+      int iconResourceId = getResourceId(packageName);
+
+      Context toUse = context.createPackageContext(packageName, /*flags=*/ 0);
+      Resources resources = toUse.getResources();
+      Uri uri = new Uri.Builder()
+          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+          .authority(packageName)
+          .path(resources.getResourceTypeName(iconResourceId))
+          .path(resources.getResourceEntryName(iconResourceId))
+          .path(String.valueOf(iconResourceId))
+          .build();
+
+      Drawable drawable = Glide.with(context)
+          .load(uri)
+          .submit()
+          .get();
+      assertThat(drawable).isNotNull();
+    }
+  }
+
+
+  @Test
+  public void load_withApplicationIconResourceNameUri_asDrawable_withTransform_nonNullDrawable()
+      throws ExecutionException, InterruptedException, NameNotFoundException {
+    for (String packageName : getInstalledPackages()) {
+      int iconResourceId = getResourceId(packageName);
+
+      Context toUse = context.createPackageContext(packageName, /*flags=*/ 0);
+      Resources resources = toUse.getResources();
+      Uri uri = new Uri.Builder()
+          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+          .authority(packageName)
+          .path(resources.getResourceTypeName(iconResourceId))
+          .path(resources.getResourceEntryName(iconResourceId))
+          .path(String.valueOf(iconResourceId))
+          .build();
+
+      Drawable drawable = Glide.with(context)
+          .load(uri)
+          .apply(centerCropTransform())
+          .submit()
+          .get();
+      assertThat(drawable).isNotNull();
+    }
+  }
+
+  @Test
+  public void load_withApplicationIconResourceNameUri_asBitmap_producesNonNullBitmap()
+      throws ExecutionException, InterruptedException, NameNotFoundException {
+    for (String packageName : getInstalledPackages()) {
+      int iconResourceId = getResourceId(packageName);
+
+      Context toUse = context.createPackageContext(packageName, /*flags=*/ 0);
+      Resources resources = toUse.getResources();
+      Uri uri = new Uri.Builder()
+          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+          .authority(packageName)
+          .path(resources.getResourceTypeName(iconResourceId))
+          .path(resources.getResourceEntryName(iconResourceId))
+          .path(String.valueOf(iconResourceId))
+          .build();
+
+      Bitmap bitmap = Glide.with(context)
+          .asBitmap()
+          .load(uri)
+          .submit()
+          .get();
+      assertThat(bitmap).isNotNull();
+    }
+  }
+
+  @Test
+  public void load_withApplicationIconResourceNameUri_asBitmap_withTransform_nonNullBitmap()
+      throws ExecutionException, InterruptedException, NameNotFoundException {
+    for (String packageName : getInstalledPackages()) {
+      int iconResourceId = getResourceId(packageName);
+
+      Context toUse = context.createPackageContext(packageName, /*flags=*/ 0);
+      Resources resources = toUse.getResources();
+      Uri uri = new Uri.Builder()
+          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+          .authority(packageName)
+          .path(resources.getResourceTypeName(iconResourceId))
+          .path(resources.getResourceEntryName(iconResourceId))
+          .path(String.valueOf(iconResourceId))
+          .build();
+
+      Bitmap bitmap = Glide.with(context)
+          .asBitmap()
+          .apply(centerCropTransform())
+          .load(uri)
+          .submit()
+          .get();
+      assertThat(bitmap).isNotNull();
+    }
+  }
+
+  private Set<String> getInstalledPackages() {
+    Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
+    mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
+    PackageManager packageManager = context.getPackageManager();
+    List<ResolveInfo> pkgAppsList =
+        packageManager.queryIntentActivities(mainIntent, /*flags=*/ 0);
+    Set<String> result = new HashSet<>();
+    for (ResolveInfo info : pkgAppsList) {
+      int iconResourceId = getResourceId(info.activityInfo.packageName);
+      if (iconResourceId != 0) {
+        result.add(info.activityInfo.packageName);
+      }
+    }
+    return result;
+  }
+
+  private int getResourceId(String packageName) {
+    PackageInfo packageInfo;
+    try {
+      packageInfo = context.getPackageManager().getPackageInfo(packageName, /*flags=*/ 0);
+    } catch (NameNotFoundException e) {
+      return 0;
+    }
+    return packageInfo.applicationInfo.icon;
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/PausedRequestsTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/PausedRequestsTest.java
new file mode 100644
index 000000000..a87d44a81
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/PausedRequestsTest.java
@@ -0,0 +1,54 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.graphics.Color;
+import android.graphics.drawable.ColorDrawable;
+import android.widget.ImageView;
+import androidx.test.InstrumentationRegistry;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.GlideRequests;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import org.junit.Rule;
+import org.junit.Test;
+
+/**
+ * Tests how {@link com.bumptech.glide.request.Request}s behave when the corresponding
+ * {@link RequestManager} is paused.
+ */
+public final class PausedRequestsTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private final Context context = InstrumentationRegistry.getTargetContext();
+
+  @SuppressWarnings("unchecked")
+  @Test
+  public void load_withPlaceHolderSet_requestsPaused_displaysPlaceholder() {
+    final ImageView imageView = new ImageView(context);
+
+    final GlideRequests requests = GlideApp.with(context);
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        requests.pauseAllRequests();
+      }
+    });
+
+    final ColorDrawable expected = new ColorDrawable(Color.RED);
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            requests
+                .load(ResourceIds.drawable.bitmap_alias)
+                .placeholder(expected)
+                .into(imageView);
+          }
+        });
+
+    assertThat(imageView.getDrawable()).isEqualTo(expected);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java
new file mode 100644
index 000000000..5a9167a85
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java
@@ -0,0 +1,96 @@
+package com.bumptech.glide;
+
+import android.content.Context;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+import android.widget.ImageView;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
+import com.bumptech.glide.manager.Lifecycle;
+import com.bumptech.glide.manager.LifecycleListener;
+import com.bumptech.glide.manager.RequestManagerTreeNode;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.ResourceIds.raw;
+import com.bumptech.glide.test.TearDownGlide;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(AndroidJUnit4.class)
+public class RequestManagerTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  @Mock private RequestManagerTreeNode treeNode;
+
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private RequestManager requestManager;
+  private Context context;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    context = InstrumentationRegistry.getTargetContext();
+    Glide glide = Glide.get(context);
+    requestManager = new RequestManager(glide, new Lifecycle() {
+      @Override
+      public void addListener(@NonNull LifecycleListener listener) {
+        listener.onStart();
+      }
+
+      @Override
+      public void removeListener(@NonNull LifecycleListener listener) {
+        // Do nothing.
+      }
+    }, treeNode, context);
+  }
+
+  /**
+   * Tests #2262.
+   */
+  @Test
+  public void clear_withNonOwningRequestManager_afterOwningManagerIsDestroyed_doesNotThrow() {
+    // First destroy our Fragment/Activity RequestManager.
+    requestManager.onDestroy();
+
+    final ImageView imageView = new ImageView(context);
+    imageView.measure(100, 100);
+    imageView.layout(0, 0, 100, 100);
+    // Then start a new load with our now destroyed RequestManager.
+    concurrency.loadOnMainThread(requestManager.load(ResourceIds.raw.canonical), imageView);
+
+    // Finally clear our new load with any RequestManager other than the one we used to start it.
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.with(context).clear(imageView);
+      }
+    });
+  }
+
+  /**
+   * Tests b/69361054.
+   */
+  @Test
+  public void clear_withNonOwningRequestManager_onBackgroundTHread_doesNotThrow() {
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        requestManager.onDestroy();
+      }
+    });
+
+    final Target<Drawable> target =
+        concurrency.wait(requestManager.load(raw.canonical).submit());
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.with(context).clear(target);
+      }
+    });
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java
new file mode 100644
index 000000000..91e1c14b2
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java
@@ -0,0 +1,254 @@
+package com.bumptech.glide;
+
+import static com.bumptech.glide.test.Matchers.anyDrawable;
+import static com.bumptech.glide.test.Matchers.anyDrawableTarget;
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.anyBoolean;
+import static org.mockito.Mockito.eq;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
+import android.content.Context;
+import android.graphics.drawable.Drawable;
+import android.widget.ImageView;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import com.bumptech.glide.test.WaitModelLoader;
+import com.bumptech.glide.test.WaitModelLoader.WaitModel;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+/**
+ * Tests the behaviors of Requests of all types.
+ */
+@RunWith(AndroidJUnit4.class)
+public class RequestTest {
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+  @Mock private RequestListener<Drawable> requestListener;
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private Context context;
+  private ImageView imageView;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    context = InstrumentationRegistry.getTargetContext();
+    imageView = new ImageView(context);
+    imageView.measure(100, 100);
+    imageView.layout(0, 0, 100, 100);
+
+    // Some emulators only have a single resize thread, so waiting on a latch will block them
+    // forever.
+    Glide.init(context,
+        new GlideBuilder().setSourceExecutor(GlideExecutor.newUnlimitedSourceExecutor()));
+  }
+
+  @Test
+  public void clear_withSingleRequest_nullsOutDrawableInView() {
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical),
+        imageView);
+    assertThat(imageView.getDrawable()).isNotNull();
+
+    concurrency.clearOnMainThread(imageView);
+    assertThat(imageView.getDrawable()).isNull();
+  }
+
+  @Test
+  public void clear_withRequestWithThumbnail_nullsOutDrawableInView() {
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .thumbnail(
+                GlideApp.with(context)
+                    .load(ResourceIds.raw.canonical)
+                    .override(100, 100)),
+        imageView);
+    assertThat(imageView.getDrawable()).isNotNull();
+
+    concurrency.clearOnMainThread(imageView);
+    assertThat(imageView.getDrawable()).isNull();
+  }
+
+  @Test
+  public void onStop_withSingleRequest_doesNotNullOutDrawableInView() {
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical),
+        imageView);
+    assertThat(imageView.getDrawable()).isNotNull();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.with(context).onStop();
+      }
+    });
+    assertThat(imageView.getDrawable()).isNotNull();
+  }
+
+  @Test
+  public void onStop_withRequestWithThumbnail_doesNotNullOutDrawableInView() {
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .thumbnail(
+                GlideApp.with(context)
+                  .load(ResourceIds.raw.canonical)
+                  .override(100, 100)),
+        imageView);
+    assertThat(imageView.getDrawable()).isNotNull();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.with(context).onStop();
+      }
+    });
+    assertThat(imageView.getDrawable()).isNotNull();
+  }
+
+  @Test
+  public void onStop_withSingleRequestInProgress_nullsOutDrawableInView() {
+    final WaitModel<Integer> model = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.with(context)
+                .load(ResourceIds.raw.canonical)
+                .into(imageView);
+          }
+        });
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.with(context).onStop();
+      }
+    });
+    assertThat(imageView.getDrawable()).isNull();
+    model.countDown();
+  }
+
+  @Test
+  public void onStop_withRequestWithThumbnailBothInProgress_nullsOutDrawableInView() {
+    final WaitModel<Integer> model = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.with(context)
+                .load(model)
+                .thumbnail(
+                    GlideApp.with(context)
+                    .load(model)
+                    .override(100, 100))
+                .into(imageView);
+
+          }
+        });
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.with(context).onStop();
+      }
+    });
+    assertThat(imageView.getDrawable()).isNull();
+    model.countDown();
+  }
+
+  /** Tests #2555. */
+  @Test
+  public void onStop_withRequestWithOnlyFullInProgress_nullsOutDrawableInView() {
+    final WaitModel<Integer> mainModel = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);
+    concurrency.loadUntilFirstFinish(
+        GlideApp.with(context)
+            .load(mainModel)
+            .listener(requestListener)
+                .thumbnail(GlideApp.with(context)
+                    .load(ResourceIds.raw.canonical)
+                    .listener(requestListener)
+                    .override(100, 100)),
+        imageView);
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.with(context).onStop();
+      }
+    });
+
+    verify(requestListener, never())
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.DATA_DISK_CACHE),
+            anyBoolean());
+    verify(requestListener, never())
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.RESOURCE_DISK_CACHE),
+            anyBoolean());
+    assertThat(imageView.getDrawable()).isNull();
+    mainModel.countDown();
+  }
+
+  @Test
+  public void onStop_withRequestWithOnlyThumbnailInProgress_doesNotNullOutDrawableInView() {
+    final WaitModel<Integer> thumbModel = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);
+    concurrency.loadUntilFirstFinish(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+                .thumbnail(GlideApp.with(context)
+                    .load(thumbModel)
+                    .listener(requestListener)
+                    .override(100, 100)),
+        imageView);
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.with(context).onStop();
+      }
+    });
+
+    verify(requestListener, never())
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.DATA_DISK_CACHE),
+            anyBoolean());
+    verify(requestListener, never())
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.RESOURCE_DISK_CACHE),
+            anyBoolean());
+
+    // Only requests that are running are paused in onStop. The full request should take priority
+    // over the thumbnail request. Therefore, if the full request is finished in onStop, it should
+    // not be cleared, even if the thumbnail request is still running.
+    assertThat(imageView.getDrawable()).isNotNull();
+    thumbModel.countDown();
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/RoundedCornersRegressionTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/RoundedCornersRegressionTest.java
new file mode 100644
index 000000000..3e59c4b22
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RoundedCornersRegressionTest.java
@@ -0,0 +1,97 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.resource.bitmap.RoundedCorners;
+import com.bumptech.glide.test.BitmapRegressionTester;
+import com.bumptech.glide.test.CanonicalBitmap;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.RegressionTest;
+import com.bumptech.glide.test.SplitByCpu;
+import com.bumptech.glide.test.SplitBySdk;
+import com.bumptech.glide.test.TearDownGlide;
+import java.util.concurrent.ExecutionException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestName;
+import org.junit.rules.TestRule;
+import org.junit.runner.RunWith;
+
+/**
+ * Compares the output of RoundedCorners with canonical resource files for all SDKs Glide supports
+ * and fails on deltas.
+ */
+@RunWith(AndroidJUnit4.class)
+@SplitByCpu
+@SplitBySdk({26, 24, 23, 21, 19, 18, 16})
+@RegressionTest
+public class RoundedCornersRegressionTest {
+  @Rule public final TestRule tearDownGlide = new TearDownGlide();
+  @Rule public final TestName testName = new TestName();
+
+  private Context context;
+  private BitmapRegressionTester bitmapRegressionTester;
+  private CanonicalBitmap canonicalBitmap;
+
+  @Before
+  public void setUp() throws Exception {
+    context = InstrumentationRegistry.getTargetContext();
+    bitmapRegressionTester = new BitmapRegressionTester(getClass(), testName);
+    canonicalBitmap = new CanonicalBitmap();
+  }
+
+  @Test
+  public void testRoundedCorners() throws ExecutionException, InterruptedException {
+    bitmapRegressionTester.test(
+        GlideApp.with(context)
+            .asBitmap()
+            .load(canonicalBitmap.getBitmap())
+            .transform(new RoundedCorners(5)));
+  }
+
+  @Test
+  public void testRoundedCorners_usePool() throws ExecutionException, InterruptedException {
+    canonicalBitmap = canonicalBitmap.scale(0.1f);
+
+    Bitmap redRect =
+        createRect(
+            Color.RED,
+            canonicalBitmap.getWidth(),
+            canonicalBitmap.getHeight(),
+            Bitmap.Config.ARGB_8888);
+
+    Glide.get(context).getBitmapPool().put(redRect);
+
+    Bitmap roundedRect = bitmapRegressionTester.test(
+        GlideApp.with(context)
+            .asBitmap()
+            .load(canonicalBitmap.getBitmap())
+            .override(canonicalBitmap.getWidth(), canonicalBitmap.getHeight())
+            .transform(new RoundedCorners(5)));
+
+    assertThat(roundedRect).isEqualTo(redRect);
+  }
+
+  @Test
+  public void testRoundedCorners_overRounded() throws ExecutionException, InterruptedException {
+    bitmapRegressionTester.test(
+        GlideApp.with(context)
+            .asBitmap()
+            .load(canonicalBitmap.getBitmap())
+            .transform(new RoundedCorners(20)));
+  }
+
+  private Bitmap createRect(int color, int width, int height, Bitmap.Config config) {
+    final Bitmap result = Bitmap.createBitmap(width, height, config);
+    Canvas canvas = new Canvas(result);
+    canvas.drawColor(color);
+    return result;
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/WideGamutTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/WideGamutTest.java
new file mode 100644
index 000000000..c1b532f3a
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/WideGamutTest.java
@@ -0,0 +1,231 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assume.assumeTrue;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.CompressFormat;
+import android.graphics.Bitmap.Config;
+import android.graphics.ColorSpace;
+import android.graphics.ColorSpace.Named;
+import android.os.Build;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruBitmapPool;
+import com.bumptech.glide.load.resource.bitmap.Downsampler;
+import com.bumptech.glide.load.resource.bitmap.RoundedCorners;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import java.io.ByteArrayOutputStream;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+public class WideGamutTest {
+  @Rule public final TestRule tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private final Context context = InstrumentationRegistry.getTargetContext();
+
+  @Before
+  public void setUp() {
+    assumeTrue(Build.VERSION.SDK_INT >= Build.VERSION_CODES.O);
+  }
+
+  @Test
+  public void load_withWideGamutImage_returnsWideGamutBitmap() {
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(ResourceIds.raw.webkit_logo_p3)
+                .submit());
+    assertThat(bitmap.getConfig()).isEqualTo(Bitmap.Config.RGBA_F16);
+  }
+
+  @Test
+  public void load_withWideGamutImage_bitmapInPoolWithSizeAndConfig_usesBitmapFromPool() {
+    int bitmapDimension = 1000;
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setBitmapPool(new LruBitmapPool(bitmapDimension * bitmapDimension * 8 * 4)));
+    Bitmap expected = Bitmap.createBitmap(bitmapDimension, bitmapDimension, Bitmap.Config.RGBA_F16);
+
+    Glide.get(context)
+        .getBitmapPool()
+        .put(expected);
+
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(ResourceIds.raw.webkit_logo_p3)
+                .submit());
+    assertThat(bitmap).isSameAs(expected);
+  }
+
+  // TODO: Even with hardware allowed, we get a wide F16. Attempting to decode the resource with
+  // preferred config set to hardware fails with:
+  // "D/skia    (10312): --- Failed to allocate a hardware bitmap"
+  @Test
+  public void load_withWideGamutImage_hardwareAllowed_returnsDecodedBitmap() {
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(ResourceIds.raw.webkit_logo_p3)
+                .set(Downsampler.ALLOW_HARDWARE_CONFIG, true)
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withEncodedPngWideGamutImage_decodesWideGamut() {
+    Bitmap toCompress =
+        Bitmap.createBitmap(
+            100, 100, Bitmap.Config.RGBA_F16, /*hasAlpha=*/ true, ColorSpace.get(Named.DCI_P3));
+
+    byte[] data = asPng(toCompress);
+
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(data)
+                .submit());
+    assertThat(bitmap.getConfig()).isEqualTo(Bitmap.Config.RGBA_F16);
+  }
+
+  @Test
+  public void load_withEncodedJpegWideGamutImage_decodesArgb8888() {
+    // TODO(b/71430152): Figure out whether or not this is supposed to pass in API 26 and fail in
+    // API 27.
+    assumeTrue(Build.VERSION.SDK_INT != Build.VERSION_CODES.O_MR1);
+    Bitmap toCompress =
+        Bitmap.createBitmap(
+            100, 100, Bitmap.Config.RGBA_F16, /*hasAlpha=*/ true, ColorSpace.get(Named.DCI_P3));
+
+    byte[] data = asJpeg(toCompress);
+
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(data)
+                .submit());
+    assertThat(bitmap.getConfig()).isEqualTo(Bitmap.Config.ARGB_8888);
+  }
+
+  @Test
+  public void load_withEncodedWebpWideGamutImage_decodesArgb8888() {
+    Bitmap toCompress =
+        Bitmap.createBitmap(
+            100, 100, Bitmap.Config.RGBA_F16, /*hasAlpha=*/ true, ColorSpace.get(Named.DCI_P3));
+
+    byte[] data = asWebp(toCompress);
+
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(data)
+                .submit());
+    assertThat(bitmap.getConfig()).isEqualTo(Bitmap.Config.ARGB_8888);
+  }
+
+  @Test
+  public void load_withSmallerWideGamutInPool_decodesBitmap() {
+    BitmapPool bitmapPool = Glide.get(context).getBitmapPool();
+    Bitmap toPut = Bitmap.createBitmap(300, 298, Config.RGBA_F16);
+    bitmapPool.put(toPut);
+    // Add a second Bitmap to account for the InputStream decode.
+    bitmapPool.put(Bitmap.createBitmap(toPut));
+
+    Bitmap wideGamut = Bitmap.createBitmap(300, 300, Config.RGBA_F16);
+    byte[] data = asPng(wideGamut);
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(data)
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void circleCrop_withWideGamutBitmap_producesWideGamutBitmap() {
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Config.RGBA_F16);
+    byte[] data = asPng(bitmap);
+
+    Bitmap result =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(data)
+                .circleCrop()
+                .submit());
+    assertThat(result).isNotNull();
+    assertThat(result.getConfig()).isEqualTo(Config.RGBA_F16);
+  }
+
+  @Test
+  public void roundedCorners_withWideGamutBitmap_producesWideGamutBitmap() {
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Config.RGBA_F16);
+    byte[] data = asPng(bitmap);
+
+    Bitmap result =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(data)
+                .transform(new RoundedCorners(/*roundingRadius=*/ 10))
+                .submit());
+    assertThat(result).isNotNull();
+    assertThat(result.getConfig()).isEqualTo(Config.RGBA_F16);
+  }
+
+  @Test
+  public void loadWideGamutImage_withArgb888OfSufficientSizeInPool_usesArgb8888Bitmap() {
+    Bitmap wideGamut = Bitmap.createBitmap(100, 50, Bitmap.Config.RGBA_F16);
+    byte[] data = asPng(wideGamut);
+
+    Bitmap argb8888 = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    Glide.init(context, new GlideBuilder()
+        .setBitmapPool(new LruBitmapPool(wideGamut.getAllocationByteCount() * 5)));
+    Glide.get(context).getBitmapPool().put(argb8888);
+
+    Bitmap result =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(data)
+                .submit());
+
+    assertThat(result).isSameAs(argb8888);
+  }
+
+  private static byte[] asJpeg(Bitmap bitmap) {
+    return toByteArray(bitmap, CompressFormat.JPEG);
+  }
+
+  private static byte[] asPng(Bitmap bitmap) {
+    return toByteArray(bitmap, CompressFormat.PNG);
+  }
+
+  private static byte[] asWebp(Bitmap bitmap) {
+    return toByteArray(bitmap, CompressFormat.WEBP);
+  }
+
+  private static byte[] toByteArray(Bitmap bitmap, CompressFormat format) {
+    ByteArrayOutputStream os = new ByteArrayOutputStream();
+    assertThat(bitmap.compress(format, 100, os)).isTrue();
+    return os.toByteArray();
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java b/instrumentation/src/androidTest/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
new file mode 100644
index 000000000..94ef1782c
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
@@ -0,0 +1,116 @@
+package com.bumptech.glide.load.engine.executor;
+
+import android.os.StrictMode;
+import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
+import com.google.common.util.concurrent.ForwardingExecutorService;
+import com.google.common.util.concurrent.MoreExecutors;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Future;
+
+/**
+ * Creates mock {@link GlideExecutor}s.
+ */
+@VisibleForTesting
+public final class MockGlideExecutor {
+  private MockGlideExecutor() {
+    // Utility class.
+  }
+
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public static GlideExecutor newTestExecutor(ExecutorService executorService) {
+    return new GlideExecutor(executorService);
+  }
+
+  public static GlideExecutor newMainThreadExecutor() {
+    return newTestExecutor(new DirectExecutorService());
+  }
+
+  /**
+   * @deprecated Use {@link #newMainThreadExecutor} instead.
+   */
+  @Deprecated
+  public static GlideExecutor newMainThreadUnlimitedExecutor() {
+    return newMainThreadExecutor();
+  }
+
+  /**
+   * DirectExecutorService that enforces StrictMode and converts ExecutionExceptions into
+   * RuntimeExceptions.
+   */
+  private static final class DirectExecutorService extends ForwardingExecutorService {
+    private static final StrictMode.ThreadPolicy THREAD_POLICY =
+        new StrictMode.ThreadPolicy.Builder()
+            .detectNetwork()
+            .penaltyDeath()
+            .build();
+
+    private final ExecutorService delegate;
+
+    DirectExecutorService() {
+      delegate = MoreExecutors.newDirectExecutorService();
+    }
+
+    @Override
+    protected ExecutorService delegate() {
+      return delegate;
+    }
+
+    @NonNull
+    @Override
+    public <T> Future<T> submit(@NonNull Runnable task, @NonNull T result) {
+      return getUninterruptibly(super.submit(task, result));
+    }
+
+    @NonNull
+    @Override
+    public <T> Future<T> submit(@NonNull Callable<T> task) {
+      return getUninterruptibly(super.submit(task));
+    }
+
+    @NonNull
+    @Override
+    public Future<?> submit(@NonNull Runnable task) {
+      return getUninterruptibly(super.submit(task));
+    }
+
+    @Override
+    public void execute(@NonNull final Runnable command) {
+      delegate.execute(new Runnable() {
+        @Override
+        public void run() {
+          StrictMode.ThreadPolicy oldPolicy = StrictMode.getThreadPolicy();
+          StrictMode.setThreadPolicy(THREAD_POLICY);
+          try {
+            command.run();
+          } finally {
+            StrictMode.setThreadPolicy(oldPolicy);
+          }
+        }
+      });
+    }
+
+    private <T> Future<T> getUninterruptibly(Future<T> future) {
+      boolean interrupted = false;
+      try {
+        while (!future.isDone()) {
+          try {
+            future.get();
+          } catch (ExecutionException e) {
+            throw new RuntimeException(e);
+          } catch (InterruptedException e) {
+            interrupted = true;
+          }
+        }
+      } finally {
+        if (interrupted) {
+          Thread.currentThread().interrupt();
+        }
+      }
+      return future;
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerEmulatorTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerEmulatorTest.java
new file mode 100644
index 000000000..bdc7fa0fd
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerEmulatorTest.java
@@ -0,0 +1,618 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static android.graphics.Bitmap.CompressFormat.JPEG;
+import static android.graphics.Bitmap.CompressFormat.PNG;
+import static android.graphics.Bitmap.CompressFormat.WEBP;
+import static android.os.Build.VERSION_CODES.KITKAT;
+import static com.bumptech.glide.load.resource.bitmap.DownsamplerEmulatorTest.Api.apis;
+import static com.bumptech.glide.load.resource.bitmap.DownsamplerEmulatorTest.Api.atAndAbove;
+import static com.bumptech.glide.load.resource.bitmap.DownsamplerEmulatorTest.Api.below;
+import static com.bumptech.glide.load.resource.bitmap.DownsamplerEmulatorTest.Api.onAllApisAndAllFormatsExpect;
+import static com.bumptech.glide.load.resource.bitmap.DownsamplerEmulatorTest.Formats.Builder.allFormats;
+import static com.bumptech.glide.load.resource.bitmap.DownsamplerEmulatorTest.Formats.Builder.formats;
+import static org.junit.Assert.fail;
+
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.CompressFormat;
+import android.graphics.Bitmap.Config;
+import android.os.Build;
+import android.os.Build.VERSION_CODES;
+import android.support.annotation.Nullable;
+import android.util.DisplayMetrics;
+import androidx.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/**
+ * Runs tests to make sure that DownsampleStrategy provides the output we expect.
+ *
+ * WEBP at and above N rounds. Webp below N floors. PNG always floors. JPEG always rounds.
+ */
+@RunWith(AndroidJUnit4.class)
+@SuppressWarnings("VisibleForTests")
+public class DownsamplerEmulatorTest {
+
+  @Test
+  public void calculateScaling_withAtMost() throws IOException {
+    new Tester(DownsampleStrategy.AT_MOST)
+        .setTargetDimensions(100, 100)
+        .givenSquareImageWithDimensionOf(100, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(400, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(300, onAllApisAndAllFormatsExpect(75, 75))
+        .givenImageWithDimensionsOf(799, 100,
+            atAndAbove(VERSION_CODES.N)
+                .with(
+                    formats(JPEG, WEBP)
+                        .expect(100, 13),
+                    formats(PNG)
+                        .expect(99, 12)),
+            below(VERSION_CODES.N)
+                .with(
+                    formats(JPEG)
+                        .expect(100, 13),
+                    formats(PNG, WEBP)
+                        .expect(99, 12)))
+        .givenImageWithDimensionsOf(800, 100,
+            atAndAbove(VERSION_CODES.N)
+                .with(
+                    formats(JPEG, WEBP)
+                        .expect(100, 13),
+                    formats(PNG)
+                        .expect(100, 12)),
+            below(VERSION_CODES.N)
+                .with(
+                    formats(JPEG)
+                        .expect(100, 13),
+                    formats(PNG, WEBP)
+                        .expect(100, 12)))
+        .givenImageWithDimensionsOf(801, 100, onAllApisAndAllFormatsExpect(50, 6))
+        .givenImageWithDimensionsOf(100, 800,
+            atAndAbove(VERSION_CODES.N)
+                .with(
+                    formats(JPEG, WEBP)
+                        .expect(13, 100),
+                    formats(PNG)
+                        .expect(12, 100)),
+            below(VERSION_CODES.N)
+                .with(
+                    formats(JPEG)
+                        .expect(13, 100),
+                    formats(PNG, WEBP)
+                        .expect(12, 100)))
+        .givenImageWithDimensionsOf(87, 78, onAllApisAndAllFormatsExpect(87, 78))
+        // This set of examples demonstrate that webp uses round on N+ and floor < N.
+        .setTargetDimensions(13, 13)
+        .givenSquareImageWithDimensionOf(99,
+            atAndAbove(KITKAT)
+                .with(
+                    // 99 / 8.0 = 12.375. ceil(12.375) = 13. round(12.375) = 12. floor(12.375) = 12.
+                    formats(JPEG)
+                        .expect(13, 13),
+                    formats(PNG, WEBP)
+                        .expect(12, 12)),
+            below(KITKAT)
+                .with(
+                    formats(JPEG)
+                        .expect(13, 13),
+                    formats(PNG, WEBP)
+                        .expect(12, 12)))
+        .givenSquareImageWithDimensionOf(100,
+            atAndAbove(VERSION_CODES.N)
+                .with(
+                    // 100 / 8.0 = 12.5. ceil(12.5) = 13. round(12.5) = 13. floor(12.5) = 12.
+                    formats(JPEG, WEBP)
+                        .expect(13, 13),
+                    formats(PNG)
+                        .expect(12, 12)),
+            below(VERSION_CODES.N)
+                .with(
+                    formats(JPEG)
+                        .expect(13, 13),
+                    formats(PNG, WEBP)
+                        .expect(12, 12)))
+        // Upscaling
+        .setTargetDimensions(500, 500)
+        .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(200, 200))
+        .givenSquareImageWithDimensionOf(450, onAllApisAndAllFormatsExpect(450, 450))
+        .givenImageWithDimensionsOf(200, 450, onAllApisAndAllFormatsExpect(200, 450))
+        .run();
+  }
+
+  @Test
+  public void calculateScaling_withAtLeast() throws IOException {
+    new Tester(DownsampleStrategy.AT_LEAST)
+        .setTargetDimensions(100, 100)
+        .givenSquareImageWithDimensionOf(100, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(300, onAllApisAndAllFormatsExpect(150, 150))
+        .givenImageWithDimensionsOf(799, 100, onAllApisAndAllFormatsExpect(799, 100))
+        .givenImageWithDimensionsOf(800, 100, onAllApisAndAllFormatsExpect(800, 100))
+        .givenImageWithDimensionsOf(801, 100, onAllApisAndAllFormatsExpect(801, 100))
+        .givenImageWithDimensionsOf(100, 800, onAllApisAndAllFormatsExpect(100, 800))
+        .givenImageWithDimensionsOf(87, 78, onAllApisAndAllFormatsExpect(87, 78))
+        // Upscaling
+        .setTargetDimensions(500, 500)
+        .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(200, 200))
+        .givenSquareImageWithDimensionOf(450, onAllApisAndAllFormatsExpect(450, 450))
+        .givenImageWithDimensionsOf(200, 450, onAllApisAndAllFormatsExpect(200, 450))
+        .run();
+  }
+
+  @Test
+  public void calculateScaling_withCenterInside() throws IOException {
+    new Tester(DownsampleStrategy.CENTER_INSIDE)
+        .setTargetDimensions(100, 100)
+        .givenSquareImageWithDimensionOf(100, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(400, onAllApisAndAllFormatsExpect(100, 100))
+        .givenImageWithDimensionsOf(300, 300,
+            atAndAbove(KITKAT).with(allFormats().expect(100, 100)),
+            below(KITKAT).with(allFormats().expect(150, 150)))
+        .givenImageWithDimensionsOf(799, 100,
+            atAndAbove(KITKAT).with(allFormats().expect(100, 13)),
+            below(KITKAT)
+                .with(
+                    formats(JPEG)
+                        .expect(200, 25),
+                    formats(PNG, WEBP)
+                        .expect(199, 25)))
+        .givenImageWithDimensionsOf(800, 100,
+            atAndAbove(KITKAT).with(allFormats().expect(100, 13)),
+            below(KITKAT).with(allFormats().expect(200, 25)))
+        .givenImageWithDimensionsOf(801, 100,
+            atAndAbove(VERSION_CODES.N)
+                .with(
+                    formats(JPEG, WEBP)
+                        .expect(100, 13),
+                    formats(PNG)
+                        .expect(100, 12)),
+            apis(KITKAT, VERSION_CODES.M)
+              .with(
+                  formats(JPEG)
+                      .expect(100, 13),
+                  formats(PNG, WEBP)
+                      .expect(100, 12)),
+            below(KITKAT)
+                .with(
+                    // JPEG is correct because CENTER_INSIDE wants to give a subsequent
+                    // transformation an image that is greater in size than the requested size. On
+                    // Api > VERSION_CODES.KITKAT, CENTER_INSIDE can do the transformation itself.
+                    // On < VERSION_CODES.KITKAT, it has to assume a subsequent transformation will
+                    // be called.
+                    formats(JPEG)
+                        .expect(101, 13),
+                    formats(PNG, WEBP)
+                        .expect(100, 12)))
+        .givenImageWithDimensionsOf(100, 800,
+            atAndAbove(KITKAT).with(allFormats().expect(13, 100)),
+            below(KITKAT).with(allFormats().expect(25, 200)))
+        .givenImageWithDimensionsOf(87, 78, onAllApisAndAllFormatsExpect(87, 78))
+        .setTargetDimensions(897, 897)
+        .givenImageWithDimensionsOf(2208, 1520,
+            atAndAbove(KITKAT).with(allFormats().expect(897, 618)),
+            below(KITKAT).with(allFormats().expect(1104, 760)))
+        // Upscaling
+        .setTargetDimensions(500, 500)
+        .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(200, 200))
+        .givenSquareImageWithDimensionOf(450, onAllApisAndAllFormatsExpect(450, 450))
+        .givenImageWithDimensionsOf(200, 450, onAllApisAndAllFormatsExpect(200, 450))
+        .run();
+  }
+
+  @Test
+  public void calculateScaling_withCenterOutside() throws IOException {
+    new Tester(DownsampleStrategy.CENTER_OUTSIDE)
+        .setTargetDimensions(100, 100)
+        .givenSquareImageWithDimensionOf(100, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(400, onAllApisAndAllFormatsExpect(100, 100))
+        .givenImageWithDimensionsOf(300, 300,
+            atAndAbove(KITKAT).with(allFormats().expect(100, 100)),
+            below(KITKAT).with(allFormats().expect(150, 150)))
+        .givenImageWithDimensionsOf(799, 100, onAllApisAndAllFormatsExpect(799, 100))
+        .givenImageWithDimensionsOf(800, 100, onAllApisAndAllFormatsExpect(800, 100))
+        .givenImageWithDimensionsOf(801, 100, onAllApisAndAllFormatsExpect(801, 100))
+        .givenImageWithDimensionsOf(100, 800, onAllApisAndAllFormatsExpect(100, 800))
+        .givenImageWithDimensionsOf(87, 78,
+            atAndAbove(KITKAT).with(allFormats().expect(112, 100)),
+            below(KITKAT).with(allFormats().expect(87, 78)))
+        // Upscaling
+        .setTargetDimensions(500, 500)
+        .givenSquareImageWithDimensionOf(200,
+            atAndAbove(KITKAT).with(allFormats().expect(500, 500)),
+            below(KITKAT).with(allFormats().expect(200, 200)))
+        .givenSquareImageWithDimensionOf(450,
+            atAndAbove(KITKAT).with(allFormats().expect(500, 500)),
+            below(KITKAT).with(allFormats().expect(450, 450)))
+        .givenImageWithDimensionsOf(200, 450,
+            atAndAbove(KITKAT).with(allFormats().expect(500, 1125)),
+            below(KITKAT).with(allFormats().expect(200, 450)))
+        .run();
+  }
+
+  @Test
+  public void calculateScaling_withNone() throws IOException {
+    new Tester(DownsampleStrategy.NONE)
+        .setTargetDimensions(100, 100)
+        .givenSquareImageWithDimensionOf(100, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(200, 200))
+        .givenSquareImageWithDimensionOf(400, onAllApisAndAllFormatsExpect(400, 400))
+        .givenSquareImageWithDimensionOf(300, onAllApisAndAllFormatsExpect(300, 300))
+        .givenImageWithDimensionsOf(799, 100, onAllApisAndAllFormatsExpect(799, 100))
+        .givenImageWithDimensionsOf(800, 100, onAllApisAndAllFormatsExpect(800, 100))
+        .givenImageWithDimensionsOf(801, 100, onAllApisAndAllFormatsExpect(801, 100))
+        .givenImageWithDimensionsOf(100, 800, onAllApisAndAllFormatsExpect(100, 800))
+        .givenImageWithDimensionsOf(87, 78, onAllApisAndAllFormatsExpect(87, 78))
+        .setTargetDimensions(500, 500)
+        .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(200, 200))
+        .givenSquareImageWithDimensionOf(450, onAllApisAndAllFormatsExpect(450, 450))
+        .givenImageWithDimensionsOf(200, 450, onAllApisAndAllFormatsExpect(200, 450))
+        .run();
+  }
+
+  @Test
+  public void calculateScaling_withFitCenter() throws IOException {
+    new Tester(DownsampleStrategy.FIT_CENTER)
+        .setTargetDimensions(100, 100)
+        .givenSquareImageWithDimensionOf(100, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(400, onAllApisAndAllFormatsExpect(100, 100))
+        .givenImageWithDimensionsOf(300, 300,
+            atAndAbove(KITKAT).with(allFormats().expect(100, 100)),
+            below(KITKAT).with(allFormats().expect(150, 150)))
+        .givenImageWithDimensionsOf(799, 100,
+            atAndAbove(KITKAT).with(allFormats().expect(100, 13)),
+            below(KITKAT)
+                .with(
+                    formats(JPEG)
+                        .expect(200, 25),
+                    formats(PNG, WEBP)
+                        .expect(199, 25)))
+        .givenImageWithDimensionsOf(800, 100,
+            atAndAbove(KITKAT).with(allFormats().expect(100, 13)),
+            below(KITKAT).with(allFormats().expect(200, 25)))
+        .givenImageWithDimensionsOf(801, 100,
+            atAndAbove(VERSION_CODES.N)
+                .with(
+                    formats(JPEG, WEBP)
+                        .expect(100, 13),
+                    formats(PNG)
+                        .expect(100, 12)),
+            apis(KITKAT, VERSION_CODES.M)
+                .with(
+                    formats(JPEG)
+                        .expect(100, 13),
+                    formats(PNG, WEBP)
+                        .expect(100, 12)),
+            below(KITKAT)
+                .with(
+                    // JPEG is correct because FIT_CENTER wants to give a subsequent transformation
+                    // an image that is greater in size than the requested size. On
+                    // Api > VERSION_CODES.KITKAT, FIT_CENTER can do the transformation itself.
+                    // On < VERSION_CODES.KITKAT, it has to assume a transformation will be run
+                    // after it that will fix the rounding error.
+                    formats(JPEG)
+                        .expect(101, 13),
+                    formats(PNG, WEBP)
+                        .expect(100, 12)))
+        .givenImageWithDimensionsOf(100, 800,
+            atAndAbove(KITKAT).with(allFormats().expect(13, 100)),
+            below(KITKAT).with(allFormats().expect(25, 200)))
+        .givenImageWithDimensionsOf(87, 78,
+            atAndAbove(KITKAT).with(allFormats().expect(100, 90)),
+            below(KITKAT).with(allFormats().expect(87, 78)))
+        .setTargetDimensions(897, 897)
+        .givenImageWithDimensionsOf(2208, 1520,
+            atAndAbove(KITKAT).with(allFormats().expect(897, 618)),
+            below(KITKAT).with(allFormats().expect(1104, 760)))
+        .setTargetDimensions(270, 270)
+        // This set of larger image examples exercises sample sizes > 8. Android' scaling logic
+        // varies for jpegs.
+        .givenImageWithDimensionsOf(9014, 1638,
+            // 15 and 16 will OOM so don't run them.
+            atAndAbove(KITKAT).with(allFormats().expect(270, 49)),
+            apis(VERSION_CODES.JELLY_BEAN_MR1, VERSION_CODES.JELLY_BEAN_MR2)
+                .with(allFormats().expect(281, 51)))
+        .givenImageWithDimensionsOf(1638, 9014,
+            // 15 and 16 will OOM so don't run them.
+            atAndAbove(KITKAT).with(allFormats().expect(49, 270)),
+            apis(VERSION_CODES.JELLY_BEAN_MR1, VERSION_CODES.JELLY_BEAN_MR2)
+                .with(allFormats().expect(51, 281)))
+        .givenImageWithDimensionsOf(1638, 1638,
+            atAndAbove(KITKAT).with(allFormats().expect(270, 270)),
+            below(KITKAT)
+                .with(
+                    formats(JPEG)
+                        .expect(410, 410),
+                    formats(PNG, WEBP)
+                        .expect(409, 409)))
+        .givenImageWithDimensionsOf(4507, 819,
+            atAndAbove(KITKAT).with(allFormats().expect(270, 49)),
+            below(KITKAT).with(
+                formats(JPEG)
+                    .expect(282, 51),
+                formats(PNG, WEBP)
+                    .expect(281, 51)))
+        .givenImageWithDimensionsOf(4503, 819,
+            atAndAbove(KITKAT).with(allFormats().expect(270, 49)),
+            below(KITKAT).with(allFormats().expect(281, 51)))
+        // Upscaling
+        .setTargetDimensions(500, 500)
+        .givenSquareImageWithDimensionOf(200,
+            atAndAbove(KITKAT).with(allFormats().expect(500, 500)),
+            below(KITKAT).with(allFormats().expect(200, 200)))
+        .givenSquareImageWithDimensionOf(450,
+            atAndAbove(KITKAT).with(allFormats().expect(500, 500)),
+            below(KITKAT).with(allFormats().expect(450, 450)))
+        .givenImageWithDimensionsOf(200, 450,
+            atAndAbove(KITKAT).with(allFormats().expect(222, 500)),
+            below(KITKAT).with(allFormats().expect(200, 450)))
+        .run();
+  }
+
+  /** Returns an error string if the test failed, and {@code null} otherwise. */
+  @Nullable
+  private static String runScaleTest(
+      CompressFormat format,
+      int initialWidth,
+      int initialHeight,
+      int targetWidth,
+      int targetHeight,
+      DownsampleStrategy strategy,
+      int expectedWidth,
+      int expectedHeight) throws IOException {
+    Downsampler downsampler = buildDownsampler();
+
+    InputStream is = openBitmapStream(format, initialWidth, initialHeight);
+    Options options = new Options().set(DownsampleStrategy.OPTION, strategy);
+    Bitmap bitmap = downsampler.decode(is, targetWidth, targetHeight, options).get();
+    try {
+      if (bitmap.getWidth() != expectedWidth || bitmap.getHeight() != expectedHeight) {
+        return "API: " + Build.VERSION.SDK_INT + ", os: " + Build.VERSION.RELEASE
+            + ", format: " + format + ", strategy: " + strategy + " -"
+            + " Initial " + readableDimens(initialWidth, initialHeight)
+            + " Target " + readableDimens(targetWidth, targetHeight)
+            + " Expected " + readableDimens(expectedWidth, expectedHeight)
+            + ", but Received " + readableDimens(bitmap.getWidth(), bitmap.getHeight());
+      }
+    } finally {
+      bitmap.recycle();
+    }
+    return null;
+  }
+
+  private static String readableDimens(int width, int height) {
+    return "[" + width + "x" + height + "]";
+  }
+
+  private static Downsampler buildDownsampler() {
+    List<ImageHeaderParser> parsers =
+        Collections.<ImageHeaderParser>singletonList(new DefaultImageHeaderParser());
+    DisplayMetrics displayMetrics = new DisplayMetrics();
+    // XHDPI.
+    displayMetrics.densityDpi = 320;
+    BitmapPool bitmapPool = new BitmapPoolAdapter();
+    ArrayPool arrayPool = new LruArrayPool();
+    return new Downsampler(parsers, displayMetrics, bitmapPool, arrayPool);
+  }
+
+  private static InputStream openBitmapStream(CompressFormat format, int width, int height) {
+    Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888);
+    ByteArrayOutputStream os = new ByteArrayOutputStream();
+    bitmap.compress(format, 100 /*quality*/, os);
+    bitmap.recycle();
+    byte[] data = os.toByteArray();
+    return new ByteArrayInputStream(data);
+  }
+
+  static final class Tester {
+    private final DownsampleStrategy strategy;
+    private final List<TestCase> testCases = new ArrayList<>();
+
+    private int targetWidth;
+    private int targetHeight;
+
+    Tester(DownsampleStrategy strategy) {
+      this.strategy = strategy;
+    }
+
+    Tester setTargetDimensions(int targetWidth, int targetHeight) {
+      this.targetWidth = targetWidth;
+      this.targetHeight = targetHeight;
+      return this;
+    }
+
+    Tester givenSquareImageWithDimensionOf(int dimension, Api... apis) {
+      return givenImageWithDimensionsOf(dimension, dimension, apis);
+    }
+
+    Tester givenImageWithDimensionsOf(
+        int sourceWidth, int sourceHeight, Api... apis) {
+      testCases.add(new TestCase(sourceWidth, sourceHeight, targetWidth, targetHeight, apis));
+      return this;
+    }
+
+    void run() throws IOException {
+      List<String> results = new ArrayList<>();
+      for (TestCase testCase : testCases) {
+        results.addAll(testCase.test(strategy));
+      }
+
+      if (results.isEmpty()) {
+        return;
+      }
+
+      StringBuilder failure = new StringBuilder("Failing Tests:\n");
+      for (String result : results) {
+        failure.append(result).append("\n");
+      }
+      fail(failure.substring(0, failure.length() - 1));
+    }
+
+    private static final class TestCase {
+      private final int sourceWidth;
+      private final int sourceHeight;
+      private final int targetWidth;
+      private final int targetHeight;
+      private final Api[] apis;
+
+      TestCase(int sourceWidth, int sourceHeight, int targetWidth, int targetHeight, Api... apis) {
+        this.sourceWidth = sourceWidth;
+        this.sourceHeight = sourceHeight;
+        this.targetWidth = targetWidth;
+        this.targetHeight = targetHeight;
+        this.apis = apis;
+      }
+
+      List<String> test(DownsampleStrategy strategy)
+          throws IOException {
+        List<String> results = new ArrayList<>();
+        for (Api api : apis) {
+          results.addAll(api.test(sourceWidth, sourceHeight, targetWidth, targetHeight, strategy));
+        }
+        return results;
+      }
+    }
+  }
+
+  static final class Api {
+    private final int startVersion;
+    private final int stopVersion;
+    private final Formats[] formats;
+
+    static Builder apis(int min, int max) {
+      return new Builder().min(min).max(max);
+    }
+
+    static Builder atAndAbove(int min) {
+      return new Builder().min(min);
+    }
+
+    static Builder below(int max) {
+      // max is inclusive.
+      return new Builder().max(max - 1);
+    }
+
+    static Builder allApis() {
+      return new Builder();
+    }
+
+    static Api onAllApisAndAllFormatsExpect(int width, int height) {
+      return allApis().with(allFormats().expect(width, height));
+    }
+
+    static final class Builder {
+      private int maxVersion = Integer.MAX_VALUE;
+      private int minVersion = Integer.MIN_VALUE;
+
+      Builder min(int version) {
+        minVersion = version;
+        return this;
+      }
+
+      Builder max(int version) {
+        this.maxVersion = version;
+        return this;
+      }
+
+      Api with(Formats... formats) {
+        return new Api(minVersion, maxVersion, formats);
+      }
+    }
+
+    Api(int startVersion, int stopVersion, Formats... formats) {
+      this.startVersion = startVersion;
+      this.stopVersion = stopVersion;
+      this.formats = formats;
+    }
+
+    List<String> test(
+        int sourceWidth,
+        int sourceHeight,
+        int targetWidth,
+        int targetHeight,
+        DownsampleStrategy strategy)
+        throws IOException {
+      if (Build.VERSION.SDK_INT < startVersion || Build.VERSION.SDK_INT > stopVersion) {
+        return Collections.emptyList();
+      }
+
+      List<String> results = new ArrayList<>();
+      for (Formats format : formats) {
+        results.addAll(
+            format.runTest(sourceWidth, sourceHeight, targetWidth, targetHeight, strategy));
+
+      }
+      return results;
+    }
+  }
+
+  static final class Formats {
+    private final int expectedWidth;
+    private final int expectedHeight;
+    private final CompressFormat[] formats;
+
+    static final class Builder {
+      private final CompressFormat[] formats;
+
+      static Builder allFormats() {
+        return formats(CompressFormat.values());
+      }
+
+      static Builder formats(CompressFormat... formats) {
+        return new Builder(formats);
+      }
+
+      Builder(CompressFormat... formats) {
+        this.formats = formats;
+      }
+
+      Formats expect(int width, int height) {
+        return new Formats(formats, width, height);
+      }
+    }
+
+    Formats(CompressFormat[] formats, int expectedWidth, int expectedHeight) {
+      this.formats = formats;
+      this.expectedWidth = expectedWidth;
+      this.expectedHeight = expectedHeight;
+    }
+
+    List<String> runTest(
+        int sourceWidth,
+        int sourceHeight,
+        int targetWidth,
+        int targetHeight,
+        DownsampleStrategy strategy) throws IOException {
+      List<String> result = new ArrayList<>();
+      for (CompressFormat format : formats) {
+        String testResult = runScaleTest(
+            format,
+            sourceWidth,
+            sourceHeight,
+            targetWidth,
+            targetHeight,
+            strategy,
+            expectedWidth,
+            expectedHeight);
+        if (testResult != null) {
+          result.add(testResult);
+        }
+      }
+      return result;
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
new file mode 100644
index 000000000..9d5bddd32
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
@@ -0,0 +1,220 @@
+package com.bumptech.glide.load.resource.gif;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.Manifest.permission;
+import android.content.Context;
+import android.os.Build;
+import android.view.View;
+import android.view.WindowManager;
+import android.view.WindowManager.LayoutParams;
+import android.widget.ImageView;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.rule.GrantPermissionRule;
+import androidx.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.resource.gif.GifDrawable.GifState;
+import com.bumptech.glide.load.resource.gif.GifFrameLoader.OnEveryFrameListener;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import com.bumptech.glide.util.Preconditions;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestName;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+public class GifDrawableTest {
+  @Rule public final TestName testName = new TestName();
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  @Rule public final GrantPermissionRule grantPermissionRule;
+  private final ConcurrencyHelper concurrencyHelper = new ConcurrencyHelper();
+
+  {
+    if (Build.VERSION.SDK_INT > Build.VERSION_CODES.M) {
+      grantPermissionRule = GrantPermissionRule.grant(permission.SYSTEM_ALERT_WINDOW);
+    } else {
+      grantPermissionRule = GrantPermissionRule.grant();
+    }
+  }
+
+  private Context context;
+
+  @Before
+  public void setUp() {
+    context = InstrumentationRegistry.getTargetContext();
+  }
+
+  @Test
+  public void loadGif_withInterlacedTransparentGif_sizeOriginal_succeeds()
+      throws ExecutionException, InterruptedException {
+    GifDrawable gifDrawable =
+        concurrencyHelper.get(
+            GlideApp.with(context)
+                .asGif()
+                .load(ResourceIds.raw.interlaced_transparent_gif)
+                .submit());
+    assertThat(gifDrawable).isNotNull();
+  }
+
+  @Test
+  public void loadGif_withInterlacedTransparentGif_downsampled_succeeds()
+      throws ExecutionException, InterruptedException {
+    GifDrawable gifDrawable =
+        concurrencyHelper.get(
+            GlideApp.with(context)
+                .asGif()
+                .load(ResourceIds.raw.interlaced_transparent_gif)
+                .submit(10, 10));
+    assertThat(gifDrawable).isNotNull();
+  }
+
+  @Test
+  public void loadGif_withTransparentGif_sizeOriginal_succeeds()
+      throws ExecutionException, InterruptedException {
+    GifDrawable gifDrawable =
+        concurrencyHelper.get(
+            GlideApp.with(context)
+                .asGif()
+                .load(ResourceIds.raw.transparent_gif)
+                .submit());
+    assertThat(gifDrawable).isNotNull();
+  }
+
+  @Test
+  public void loadGif_withTransparentGif_downsampled_succeeds()
+      throws ExecutionException, InterruptedException {
+    GifDrawable gifDrawable =
+        concurrencyHelper.get(
+            GlideApp.with(context)
+                .asGif()
+                .load(ResourceIds.raw.transparent_gif)
+                .submit(10, 10));
+    assertThat(gifDrawable).isNotNull();
+  }
+
+  @Test
+  public void loadGif_withOpaqueGif_sizeOriginal_succeeds()
+      throws ExecutionException, InterruptedException {
+    GifDrawable gifDrawable =
+        concurrencyHelper.get(
+            GlideApp.with(context)
+                .asGif()
+                .load(ResourceIds.raw.opaque_gif)
+                .submit());
+    assertThat(gifDrawable).isNotNull();
+  }
+
+  @Test
+  public void loadGif_withOpaqueGif_downsampled_succeeds()
+      throws ExecutionException, InterruptedException {
+    GifDrawable gifDrawable =
+        concurrencyHelper.get(
+            GlideApp.with(context)
+                .asGif()
+                .load(ResourceIds.raw.opaque_gif)
+                .submit(10, 10));
+    assertThat(gifDrawable).isNotNull();
+  }
+
+  @Test
+  public void loadGif_withOpaqueInterlacedGif_sizeOriginal_succeeds()
+      throws ExecutionException, InterruptedException {
+    GifDrawable gifDrawable =
+        concurrencyHelper.get(
+            GlideApp.with(context)
+                .asGif()
+              .load(ResourceIds.raw.opaque_interlaced_gif)
+              .submit());
+    assertThat(gifDrawable).isNotNull();
+  }
+
+  @Test
+  public void loadGif_withOpaqueInterlacedGif_downsampled_succeeds()
+      throws ExecutionException, InterruptedException {
+    GifDrawable gifDrawable =
+        concurrencyHelper.get(
+            GlideApp.with(context)
+                .asGif()
+                .load(ResourceIds.raw.opaque_interlaced_gif)
+                .submit(10, 10));
+    assertThat(gifDrawable).isNotNull();
+  }
+
+  @Test
+  public void loadGif_intoImageView_afterStop_restartsGif()
+      throws ExecutionException, InterruptedException {
+    // Mimic the state the Drawable can get into if it was loaded into a View previously and stopped
+    // so that it ended up with a pending frame that finished after the stop call.
+    final GifDrawable gifDrawable =
+        concurrencyHelper.get(
+            GlideApp.with(context)
+                .asGif()
+                .load(ResourceIds.raw.dl_world_anim)
+                .submit(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL));
+
+    final CountDownLatch waitForGifFrame = new CountDownLatch(1);
+    // Starting/Stopping loads in GIFs must happen on the main thread.
+    concurrencyHelper.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            // Make sure a frame is loaded while the drawable is stopped.
+            GifState gifState =
+                (GifState) Preconditions.checkNotNull(gifDrawable.getConstantState());
+            gifState.frameLoader.setOnEveryFrameReadyListener(new OnEveryFrameListener() {
+              @Override
+              public void onFrameReady() {
+                waitForGifFrame.countDown();
+              }
+            });
+            gifDrawable.start();
+            gifDrawable.stop();
+          }
+        });
+    ConcurrencyHelper.waitOnLatch(waitForGifFrame);
+
+    // Load the Drawable with the pending frame into a new View and make sure it ends up in the
+    // running state.
+    final ImageView imageView = new ImageView(context);
+    concurrencyHelper.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            addViewToWindow(imageView);
+          }
+        });
+
+    concurrencyHelper.loadOnMainThread(
+        GlideApp.with(context)
+            .load(gifDrawable)
+            .override(Target.SIZE_ORIGINAL),
+        imageView);
+
+    GifDrawable drawableFromView = (GifDrawable) imageView.getDrawable();
+    assertThat(drawableFromView.isRunning()).isTrue();
+
+    drawableFromView.stop();
+    gifDrawable.stop();
+  }
+
+  @SuppressWarnings("deprecation")
+  private void addViewToWindow(View view) {
+    WindowManager.LayoutParams layoutParams = new WindowManager.LayoutParams();
+    layoutParams.height = WindowManager.LayoutParams.MATCH_PARENT;
+    layoutParams.width = WindowManager.LayoutParams.MATCH_PARENT;
+    layoutParams.type =
+        Build.VERSION.SDK_INT >= Build.VERSION_CODES.O
+            ? LayoutParams.TYPE_APPLICATION_OVERLAY
+            : Build.VERSION.SDK_INT == Build.VERSION_CODES.M
+                ? LayoutParams.TYPE_TOAST : LayoutParams.TYPE_SYSTEM_ALERT;
+    WindowManager windowManager =
+        (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
+    Preconditions.checkNotNull(windowManager).addView(view, layoutParams);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapRegressionTester.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapRegressionTester.java
new file mode 100644
index 000000000..fa8a62338
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapRegressionTester.java
@@ -0,0 +1,186 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.CompressFormat;
+import android.graphics.BitmapFactory;
+import android.os.Build;
+import android.os.Environment;
+import android.support.annotation.Nullable;
+import androidx.test.InstrumentationRegistry;
+import com.bumptech.glide.RequestBuilder;
+import java.io.BufferedOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.lang.reflect.Method;
+import java.util.Arrays;
+import java.util.concurrent.ExecutionException;
+import org.junit.rules.TestName;
+
+/**
+ * Checks for regressions for a given Glide load by comparing the result of a load to a previously
+ * saved Bitmap.
+ *
+ * <p>Can be used to generate or re-generate expected {@link Bitmap}s by placing a file named
+ * "regenerate" in /sdcard/DCIM/test_files. The apks containing this tester will need to have
+ * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE}. Resources can be split by apk
+ * by adding {@link SplitBySdk} to test methods or classes. If {@link SplitBySdk} is added to both
+ * a test class and a particular method, the values from the method will be used.
+ *
+ * <p>This class only handles exactly one Bitmap comparison per test method because the resource
+ * names it expects and generates are based on the method name.
+ */
+public final class BitmapRegressionTester {
+  private static final String RESOURCE_TYPE = "raw";
+  private static final String EXTENSION = ".png";
+  private static final String REGENERATE_SIGNAL_FILE_NAME = "regenerate";
+  private static final String GENERATED_FILES_DIR = "test_files";
+  private static final String SEPARATOR = "_";
+
+  private final Class<?> testClass;
+  private final TestName testName;
+  private final Context context = InstrumentationRegistry.getTargetContext();
+
+  public BitmapRegressionTester(Class<?> testClass, TestName testName) {
+    this.testClass = testClass;
+    this.testName = testName;
+
+    if (testClass.getAnnotation(RegressionTest.class) == null) {
+      throw new IllegalArgumentException(
+          testClass + " must be annotated with " + RegressionTest.class);
+    }
+  }
+
+  public Bitmap test(RequestBuilder<Bitmap> request)
+      throws ExecutionException, InterruptedException {
+    Bitmap result = request
+        .submit()
+        .get();
+    if (writeNewExpected()) {
+      writeBitmap(result);
+    }
+    Bitmap expected = decodeExpected();
+    BitmapSubject.assertThat(result).sameAs(expected);
+    return result;
+  }
+
+  private String getResourceName() {
+    return getClassNameString()
+        + SEPARATOR + testName.getMethodName().toLowerCase()
+        + getSdkIntString()
+        + getCpuString();
+  }
+
+  private String getClassNameString() {
+    StringBuilder result = new StringBuilder();
+    for (char c : testClass.getSimpleName().toCharArray()) {
+      if (Character.isUpperCase(c)) {
+        result.append(Character.toLowerCase(c));
+      }
+    }
+    return result.toString();
+  }
+
+  @Nullable
+  private SplitBySdk getSplitBySdkValues() {
+    SplitBySdk result;
+    try {
+      Method method =
+          testClass.getMethod(testName.getMethodName(), /*parameterTypes=*/ (Class[]) null);
+      result = method.getAnnotation(SplitBySdk.class);
+    } catch (NoSuchMethodException e) {
+      throw new RuntimeException(e);
+    }
+
+    if (result == null) {
+      result = testClass.getAnnotation(SplitBySdk.class);
+    }
+    return result;
+  }
+
+  @SuppressWarnings("deprecation")
+  private String getCpuString() {
+    return splitByCpu() ? SEPARATOR + Build.CPU_ABI.replace("-", "_") : "";
+  }
+
+  private boolean splitByCpu() {
+    return testClass.getAnnotation(SplitByCpu.class) != null;
+  }
+
+  private String getSdkIntString() {
+    SplitBySdk splitBySdk = getSplitBySdkValues();
+    if (splitBySdk == null) {
+      return "";
+    }
+    int targetSdk = -1;
+    int[] values = splitBySdk.value();
+    Arrays.sort(values);
+    for (int value : values) {
+      if (value > Build.VERSION.SDK_INT) {
+        break;
+      }
+      targetSdk = value;
+    }
+
+    if (targetSdk == -1) {
+      return "";
+    }
+
+    return SEPARATOR + targetSdk;
+  }
+
+  private File getTestFilesDir() {
+    File dir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM);
+    return new File(dir, GENERATED_FILES_DIR);
+  }
+
+  private void writeBitmap(Bitmap bitmap) {
+    File testFilesDir = getTestFilesDir();
+    File subdirectory = new File(testFilesDir, RESOURCE_TYPE);
+    if (!subdirectory.exists() && !subdirectory.mkdirs()) {
+      throw new IllegalArgumentException("Failed to make directory: " + subdirectory);
+    }
+
+    File file = new File(subdirectory, getResourceName() + EXTENSION);
+    if (file.exists() && !file.delete()) {
+      throw new IllegalStateException("Failed to remove existing file: " + file);
+    }
+
+    OutputStream os = null;
+    try {
+      os = new BufferedOutputStream(new FileOutputStream(file));
+      bitmap.compress(CompressFormat.PNG, /*quality=*/100, os);
+      os.close();
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    } finally {
+      if (os != null) {
+        try {
+          os.close();
+        } catch (IOException e) {
+          // Ignored.
+        }
+      }
+    }
+  }
+
+  private boolean writeNewExpected() {
+    File testFiles = getTestFilesDir();
+    return new File(testFiles, REGENERATE_SIGNAL_FILE_NAME).exists();
+  }
+
+  private Bitmap decodeExpected() {
+    int resourceId =
+        context.getResources()
+            .getIdentifier(getResourceName(), RESOURCE_TYPE, context.getPackageName());
+    if (resourceId == 0) {
+      throw new IllegalArgumentException("Failed to find resource for: " + getResourceName()
+       + " with type: " + RESOURCE_TYPE + " and package: " + context.getPackageName());
+    }
+    BitmapFactory.Options options = new BitmapFactory.Options();
+    options.inScaled = false;
+    return BitmapFactory.decodeResource(context.getResources(), resourceId, options);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapSubject.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapSubject.java
new file mode 100644
index 000000000..cdacb09bd
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapSubject.java
@@ -0,0 +1,122 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.NonNull;
+import android.support.v4.content.res.ResourcesCompat;
+import androidx.test.InstrumentationRegistry;
+import com.google.common.truth.FailureMetadata;
+import com.google.common.truth.Subject;
+import com.google.common.truth.Truth;
+
+/**
+ * Truth assertions for comparing {@link Bitmap}s.
+ */
+// Test APIs.
+@SuppressWarnings({"WeakerAccess", "unused"})
+public final class BitmapSubject extends Subject<BitmapSubject, Bitmap> {
+
+  private static final Subject.Factory<BitmapSubject, Bitmap> FACTORY =
+      new Subject.Factory<BitmapSubject, Bitmap>() {
+        @Override
+        public BitmapSubject createSubject(
+            @NonNull FailureMetadata metadata, @NonNull Bitmap actual) {
+          return new BitmapSubject(metadata, actual);
+        }
+      };
+
+  private BitmapSubject(FailureMetadata failureMetadata, Bitmap subject) {
+    super(failureMetadata, subject);
+  }
+
+  public static BitmapSubject assertThat(Drawable drawable) {
+    if (!(drawable instanceof BitmapDrawable)) {
+      throw new IllegalArgumentException("Not a BitmapDrawable: " + drawable);
+    }
+    return assertThat(((BitmapDrawable) drawable).getBitmap());
+  }
+
+  public static BitmapSubject assertThat(Bitmap bitmap) {
+    return Truth.assertAbout(FACTORY).that(bitmap);
+  }
+
+  @Override
+  protected String actualCustomStringRepresentation() {
+    return getDisplayString(actual());
+  }
+
+  private static String getDisplayString(Bitmap bitmap) {
+     return "<"
+        + "[" + bitmap.getWidth() + "x" + bitmap.getHeight() + "]"
+        + " "
+        + bitmap.getConfig()
+        + ">";
+  }
+
+  public void sameAs(@DrawableRes int resourceId) {
+    Context context = InstrumentationRegistry.getTargetContext();
+    Drawable drawable =
+        ResourcesCompat.getDrawable(context.getResources(), resourceId, context.getTheme());
+    sameAs(drawable);
+  }
+
+  public void hasDimensions(int expectedWidth, int expectedHeight) {
+    int actualWidth = actual().getWidth();
+    int actualHeight = actual().getHeight();
+    String message;
+    if (expectedWidth != actualWidth && expectedHeight != actualHeight) {
+      message = "has dimensions of [" + expectedWidth + "x" + expectedHeight + "]";
+    } else if (expectedWidth != actualWidth) {
+      message = "has width of " + expectedWidth;
+    } else if (expectedHeight != actualHeight) {
+      message = "has height of " + expectedHeight;
+    } else {
+      message = null;
+    }
+
+    if (message != null) {
+      fail(message);
+    }
+  }
+
+  public void isMutable()  {
+    if (!actual().isMutable()) {
+      fail("is mutable");
+    }
+  }
+
+  public void isImmutable() {
+    if (actual().isMutable()) {
+      fail("is immutable");
+    }
+  }
+
+  public void isNotRecycled() {
+    if (actual().isRecycled()) {
+      fail("is not recycled");
+    }
+  }
+
+  @SuppressWarnings({"unchecked", "ConstantConditions"})
+  public void sameAs(Drawable other) {
+    if (!(other instanceof BitmapDrawable)) {
+      fail("Not a BitmapDrawable");
+    }
+    sameAs(((BitmapDrawable) other).getBitmap());
+  }
+
+  public void sameAs(Bitmap other) {
+    if (!actual().sameAs(other)) {
+      fail("is the same as " + getDisplayString(other));
+    }
+  }
+
+  public void isNotSameAs(Bitmap other) {
+    if (actual().sameAs(other)) {
+      fail("is not the same as " + getDisplayString(other));
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/CanonicalBitmap.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/CanonicalBitmap.java
new file mode 100644
index 000000000..d990cf4f8
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/CanonicalBitmap.java
@@ -0,0 +1,55 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import androidx.test.InstrumentationRegistry;
+import com.bumptech.glide.util.Preconditions;
+
+public final class CanonicalBitmap {
+  @Nullable
+  private Bitmap bitmap;
+  @Nullable
+  private Float scaleFactor;
+
+  @NonNull
+  public synchronized Bitmap getBitmap() {
+    if (bitmap == null) {
+      bitmap = decodeBitmap();
+    }
+    return bitmap;
+  }
+
+  public CanonicalBitmap scale(float scaleFactor) {
+    Preconditions.checkArgument(bitmap == null, "Can't set scale factor after decoding image");
+    this.scaleFactor = scaleFactor;
+    return this;
+  }
+
+  public int getWidth() {
+    return getBitmap().getWidth();
+  }
+
+  public int getHeight() {
+    return getBitmap().getHeight();
+  }
+
+  private Bitmap decodeBitmap() {
+    Context context = InstrumentationRegistry.getTargetContext();
+    BitmapFactory.Options options = new BitmapFactory.Options();
+    options.inScaled = false;
+    int resourceId = ResourceIds.raw.canonical;
+    Bitmap result = BitmapFactory.decodeResource(context.getResources(), resourceId, options);
+    if (scaleFactor != null) {
+      result = Bitmap.createScaledBitmap(
+          result,
+          (int) (result.getWidth() * scaleFactor),
+          (int) (result.getHeight() * scaleFactor),
+          /*filter=*/false);
+    }
+    // Make sure the Bitmap is immutable.
+    return result;
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java
new file mode 100644
index 000000000..20888d70a
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java
@@ -0,0 +1,327 @@
+package com.bumptech.glide.test;
+
+import android.graphics.drawable.Drawable;
+import android.os.Debug;
+import android.os.Handler;
+import android.os.Looper;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.widget.ImageView;
+import androidx.test.InstrumentationRegistry;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.request.FutureTarget;
+import com.bumptech.glide.request.Request;
+import com.bumptech.glide.request.target.DrawableImageViewTarget;
+import com.bumptech.glide.request.target.SizeReadyCallback;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.util.Preconditions;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
+
+/**
+ * Helper for running sections of code on the main thread in emulator tests.
+ */
+public class ConcurrencyHelper {
+  private final Handler handler = new Handler(Looper.getMainLooper());
+  private static final long TIMEOUT_SECONDS = 10;
+  private static final TimeUnit TIMEOUT_UNIT = TimeUnit.SECONDS;
+
+  public <T> T get(final Future<T> future) {
+    final AtomicReference<T> reference = new AtomicReference<>();
+    wait(new Waiter() {
+      @Override
+      public boolean await(long timeout, TimeUnit timeUnit) throws InterruptedException {
+        try {
+          reference.set(future.get(timeout, timeUnit));
+          return true;
+        } catch (ExecutionException e) {
+          throw new RuntimeException(e.getCause());
+        } catch (TimeoutException e) {
+          return false;
+        }
+      }
+    });
+    return reference.get();
+  }
+
+  public <T> Target<T> wait(FutureTarget<T> future) {
+    get(future);
+    return future;
+  }
+
+  public void loadOnOtherThread(final Runnable runnable) {
+    final AtomicBoolean isDone = new AtomicBoolean();
+    final Thread thread = new Thread(new Runnable() {
+      @Override
+      public void run() {
+        runnable.run();
+        isDone.set(true);
+      }
+    });
+    thread.start();
+
+    wait(new Waiter() {
+      @Override
+      public boolean await(long timeout, TimeUnit timeUnit) throws InterruptedException {
+        thread.join(timeUnit.toMillis(timeout));
+        return isDone.get();
+      }
+    });
+  }
+
+  public void loadOnMainThread(
+      final RequestBuilder<Drawable> builder, ImageView imageView) {
+    loadOnMainThread(builder, new DrawableImageViewTarget(imageView));
+  }
+
+  public void clearOnMainThread(final ImageView imageView) {
+    runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.with(InstrumentationRegistry.getTargetContext())
+            .clear(imageView);
+      }
+    });
+  }
+
+  public void loadUntilFirstFinish(
+      final RequestBuilder<Drawable> builder, ImageView imageView) {
+    loadUntilFirstFinish(builder, new DrawableImageViewTarget(imageView));
+  }
+
+  private <T> void loadUntilFirstFinish(
+      final RequestBuilder<T> builder, final Target<T> target) {
+    final CountDownLatch latch = new CountDownLatch(1);
+    callOnMainThread(new Callable<Target<T>>() {
+      @Override
+      public Target<T> call() {
+        builder.into(new Target<T>() {
+          @Override
+          public void onStart() {
+            target.onStart();
+          }
+
+          @Override
+          public void onStop() {
+            target.onStop();
+          }
+
+          @Override
+          public void onDestroy() {
+            target.onDestroy();
+          }
+
+          @Override
+          public void onResourceReady(@NonNull T resource,
+              @Nullable Transition<? super T> transition) {
+            target.onResourceReady(resource, transition);
+            latch.countDown();
+          }
+
+          @Override
+          public void onLoadCleared(@Nullable Drawable placeholder) {
+            target.onLoadCleared(placeholder);
+          }
+
+          @Override
+          public void onLoadStarted(@Nullable Drawable placeholder) {
+            target.onLoadStarted(placeholder);
+          }
+
+          @Override
+          public void onLoadFailed(@Nullable Drawable errorDrawable) {
+            target.onLoadFailed(errorDrawable);
+            latch.countDown();
+          }
+
+          @Override
+          public void getSize(@NonNull SizeReadyCallback cb) {
+            target.getSize(cb);
+          }
+
+          @Override
+          public void removeCallback(@NonNull SizeReadyCallback cb) {
+            target.removeCallback(cb);
+          }
+
+          @Override
+          public void setRequest(@Nullable Request request) {
+            target.setRequest(request);
+          }
+
+          @Nullable
+          @Override
+          public Request getRequest() {
+            return target.getRequest();
+          }
+        });
+        return target;
+      }
+    });
+    waitOnLatch(latch);
+  }
+
+  private <T> void loadOnMainThread(final RequestBuilder<T> builder, final Target<T> target) {
+    final CountDownLatch latch = new CountDownLatch(1);
+    callOnMainThread(new Callable<Target<T>>() {
+      @Override
+      public Target<T> call() {
+        builder.into(new Target<T>() {
+          @Override
+          public void onStart() {
+            target.onStart();
+          }
+
+          @Override
+          public void onStop() {
+            target.onStop();
+          }
+
+          @Override
+          public void onDestroy() {
+            target.onDestroy();
+          }
+
+          @Override
+          public void onResourceReady(@NonNull T resource,
+              @Nullable Transition<? super T> transition) {
+            target.onResourceReady(resource, transition);
+            if (!Preconditions.checkNotNull(getRequest()).isRunning()) {
+              latch.countDown();
+            }
+          }
+
+          @Override
+          public void onLoadCleared(@Nullable Drawable placeholder) {
+            target.onLoadCleared(placeholder);
+          }
+
+          @Override
+          public void onLoadStarted(@Nullable Drawable placeholder) {
+            target.onLoadStarted(placeholder);
+          }
+
+          @Override
+          public void onLoadFailed(@Nullable Drawable errorDrawable) {
+            target.onLoadFailed(errorDrawable);
+            if (!Preconditions.checkNotNull(getRequest()).isRunning()) {
+              latch.countDown();
+            }
+          }
+
+          @Override
+          public void getSize(@NonNull SizeReadyCallback cb) {
+            target.getSize(cb);
+          }
+
+          @Override
+          public void removeCallback(@NonNull SizeReadyCallback cb) {
+            target.removeCallback(cb);
+          }
+
+          @Override
+          public void setRequest(@Nullable Request request) {
+            target.setRequest(request);
+          }
+
+          @Nullable
+          @Override
+          public Request getRequest() {
+            return target.getRequest();
+          }
+        });
+        return target;
+      }
+    });
+    waitOnLatch(latch);
+  }
+
+  public void pokeMainThread() {
+    runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        // Do nothing.
+      }
+    });
+  }
+
+  public void runOnMainThread(final Runnable runnable) {
+    callOnMainThread(new Callable<Void>() {
+      @Override
+      public Void call() {
+        runnable.run();
+        return null;
+      }
+    });
+  }
+
+  private <T> void callOnMainThread(final Callable<T> callable) {
+    final CountDownLatch latch = new CountDownLatch(1);
+    handler.post(new Runnable() {
+      @Override
+      public void run() {
+        try {
+          callable.call();
+        } catch (Exception e) {
+          throw new RuntimeException(e);
+        }
+        latch.countDown();
+      }
+    });
+    waitOnLatch(latch);
+  }
+
+  public static void waitOnLatch(final CountDownLatch latch) {
+    wait(new Waiter() {
+      @Override
+      public boolean await(long timeout, TimeUnit timeUnit) throws InterruptedException {
+        return latch.await(timeout, timeUnit);
+      }
+    });
+  }
+
+  private interface Waiter {
+    boolean await(long timeout, TimeUnit timeUnit) throws InterruptedException;
+  }
+
+  private static void wait(Waiter waiter) {
+    boolean isFinished = false;
+    do {
+      try {
+        try {
+          isFinished = waiter.await(TIMEOUT_SECONDS, TIMEOUT_UNIT);
+          if (!isFinished) {
+            throw new WaiterException("Timed out while waiting");
+          }
+        } catch (InterruptedException e) {
+          throw new WaiterException(e);
+        }
+      } catch (WaiterException e) {
+        if (Debug.isDebuggerConnected()) {
+          continue;
+        }
+        throw e;
+      }
+    } while (Debug.isDebuggerConnected() && !isFinished);
+  }
+
+  private static final class WaiterException extends RuntimeException {
+    private static final long serialVersionUID = -627297254223169728L;
+
+    WaiterException(String message) {
+      super(message);
+    }
+
+    WaiterException(Throwable cause) {
+      super(cause);
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/Matchers.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/Matchers.java
new file mode 100644
index 000000000..d941793ea
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/Matchers.java
@@ -0,0 +1,38 @@
+package com.bumptech.glide.test;
+
+import static org.mockito.Mockito.any;
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import com.bumptech.glide.request.target.Target;
+
+/**
+ * Mockito matchers for various common classes.
+ */
+public final class Matchers {
+
+  private Matchers() {
+    // Utility class.
+  }
+
+  public static Target<Drawable> anyDrawableTarget() {
+    return anyTarget();
+  }
+
+  public static Target<Bitmap> anyBitmapTarget() {
+    return anyTarget();
+  }
+
+  @SuppressWarnings("unchecked")
+  public static <T> Target<T> anyTarget() {
+    return (Target<T>) any(Target.class);
+  }
+
+  public static Bitmap anyBitmap() {
+    return any();
+  }
+
+  public static Drawable anyDrawable() {
+    return any();
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/MockModelLoader.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/MockModelLoader.java
new file mode 100644
index 000000000..2726152f6
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/MockModelLoader.java
@@ -0,0 +1,97 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import androidx.test.InstrumentationRegistry;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.model.ModelLoader;
+import com.bumptech.glide.load.model.ModelLoaderFactory;
+import com.bumptech.glide.load.model.MultiModelLoaderFactory;
+import com.bumptech.glide.signature.ObjectKey;
+
+public final class MockModelLoader<ModelT, DataT> implements ModelLoader<ModelT, DataT> {
+  private final ModelT model;
+  private final DataT data;
+
+  @SuppressWarnings("unchecked")
+  public static <ModelT, DataT> void mock(final ModelT model, final DataT data) {
+    Context context = InstrumentationRegistry.getTargetContext();
+
+    Glide.get(context)
+        .getRegistry()
+        .replace(
+            (Class<ModelT>) model.getClass(),
+            (Class<DataT>) data.getClass(),
+            new ModelLoaderFactory<ModelT, DataT>() {
+              @NonNull
+              @Override
+              public ModelLoader<ModelT, DataT> build(
+                  @NonNull MultiModelLoaderFactory multiFactory) {
+                return new MockModelLoader<>(model, data);
+              }
+
+              @Override
+              public void teardown() {
+                // Do nothing.
+              }
+            });
+  }
+
+  private MockModelLoader(ModelT model, DataT data) {
+    this.model = model;
+    this.data = data;
+  }
+
+  @Override
+  public LoadData<DataT> buildLoadData(@NonNull ModelT modelT, int width, int height,
+      @NonNull Options options) {
+    return new LoadData<>(new ObjectKey(modelT), new MockDataFetcher<>(data));
+  }
+
+  @Override
+  public boolean handles(@NonNull ModelT model) {
+    return this.model.equals(model);
+  }
+
+  private static final class MockDataFetcher<DataT> implements DataFetcher<DataT> {
+
+    private final DataT data;
+
+    MockDataFetcher(DataT data) {
+      this.data = data;
+    }
+
+    @Override
+    public void loadData(
+        @NonNull Priority priority, @NonNull DataCallback<? super DataT> callback) {
+      callback.onDataReady(data);
+    }
+
+    @Override
+    public void cleanup() {
+      // Do nothing.
+    }
+
+    @Override
+    public void cancel() {
+      // Do nothing.
+    }
+
+    @NonNull
+    @Override
+    @SuppressWarnings("unchecked")
+    public Class<DataT> getDataClass() {
+      return (Class<DataT>) data.getClass();
+    }
+
+    @NonNull
+    @Override
+    public DataSource getDataSource() {
+      return DataSource.REMOTE;
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/RegressionTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/RegressionTest.java
new file mode 100644
index 000000000..a6dd3629e
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/RegressionTest.java
@@ -0,0 +1,17 @@
+package com.bumptech.glide.test;
+
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Indicates that a test is a regression test that relies on comparing a newly transformed image to
+ * a previously generated copy of the same image to detect changes.
+ */
+@Target(ElementType.TYPE)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface RegressionTest {
+  // Intentionally empty.
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/ResourceIds.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ResourceIds.java
new file mode 100644
index 000000000..8a6b15ce4
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ResourceIds.java
@@ -0,0 +1,42 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import androidx.test.InstrumentationRegistry;
+
+/**
+ * Internally in google we don't appear to be able to reference resource ids directly, this class is
+ * a hack around that until we figure out what's going wrong.
+ */
+public final class ResourceIds {
+  private ResourceIds() {
+    // Utility class.
+  }
+
+  public interface raw {
+    int dl_world_anim = getResourceId("raw", "dl_world_anim");
+    int canonical = getResourceId("raw", "canonical");
+    int canonical_png = getResourceId("raw", "canonical_png");
+    int canonical_transparent_png = getResourceId("raw", "canonical_transparent_png");
+    int interlaced_transparent_gif = getResourceId("raw", "interlaced_transparent_gif");
+    int transparent_gif = getResourceId("raw", "transparent_gif");
+    int opaque_gif = getResourceId("raw", "opaque_gif");
+    int opaque_interlaced_gif = getResourceId("raw", "opaque_interlaced_gif");
+    int webkit_logo_p3 = getResourceId("raw", "webkit_logo_p3");
+    int video = getResourceId("raw", "video");
+  }
+
+  public interface drawable {
+    int bitmap_alias = getResourceId("drawable", "bitmap_alias");
+    int googlelogo_color_120x44dp= getResourceId("drawable", "googlelogo_color_120x44dp");
+    int shape_drawable = getResourceId("drawable", "shape_drawable");
+    int state_list_drawable = getResourceId("drawable", "state_list_drawable");
+    int vector_drawable = getResourceId("drawable", "vector_drawable");
+  }
+
+  private static int getResourceId(String type, String resourceName) {
+    Context context = InstrumentationRegistry.getTargetContext();
+    Resources res = context.getResources();
+    return res.getIdentifier(resourceName, type, context.getPackageName());
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/SplitByCpu.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/SplitByCpu.java
new file mode 100644
index 000000000..05fc9cc50
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/SplitByCpu.java
@@ -0,0 +1,15 @@
+package com.bumptech.glide.test;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Indicates that the test relies on transformations or operations that may produce different
+ * outputs on different CPUs.
+ */
+@Target(ElementType.TYPE)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface SplitByCpu {
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/SplitBySdk.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/SplitBySdk.java
new file mode 100644
index 000000000..bc882430a
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/SplitBySdk.java
@@ -0,0 +1,16 @@
+package com.bumptech.glide.test;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Used by {@link BitmapRegressionTester} to generate SDK specific resources to account for
+ * differences in Android's image decoding APIs across versions.
+ */
+@Target({ ElementType.METHOD, ElementType.TYPE })
+@Retention(RetentionPolicy.RUNTIME)
+public @interface SplitBySdk {
+  int[] value();
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/TearDownGlide.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/TearDownGlide.java
new file mode 100644
index 000000000..61263c353
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/TearDownGlide.java
@@ -0,0 +1,37 @@
+package com.bumptech.glide.test;
+
+import androidx.test.InstrumentationRegistry;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.RequestManager;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+/**
+ * Clears out Glide's disk cache and the Glide singleton after every test method.
+ */
+public final class TearDownGlide implements TestRule {
+
+  @Override
+  public Statement apply(final Statement base, Description description) {
+    return new Statement() {
+      @Override
+      public void evaluate() throws Throwable {
+        try {
+          base.evaluate();
+        } finally {
+          new ConcurrencyHelper().runOnMainThread(new Runnable() {
+            @Override
+            public void run() {
+              RequestManager requestManager =
+                  Glide.with(InstrumentationRegistry.getTargetContext());
+              requestManager.onStop();
+              requestManager.onDestroy();
+            }
+          });
+          Glide.tearDown();
+        }
+      }
+    };
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java
new file mode 100644
index 000000000..e702b7fc5
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java
@@ -0,0 +1,137 @@
+package com.bumptech.glide.test;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import androidx.test.InstrumentationRegistry;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.model.ModelLoader;
+import com.bumptech.glide.load.model.ModelLoaderFactory;
+import com.bumptech.glide.load.model.MultiModelLoaderFactory;
+import com.bumptech.glide.test.WaitModelLoader.WaitModel;
+import java.io.InputStream;
+import java.util.concurrent.CountDownLatch;
+
+/**
+ * Allows callers to load an object but force the load to pause until {@link WaitModel#countDown()}
+ * is called.
+ */
+public final class WaitModelLoader<Model, Data>
+    implements ModelLoader<WaitModel<Model>, Data> {
+
+  private final ModelLoader<Model, Data> wrapped;
+
+  private WaitModelLoader(ModelLoader<Model, Data> wrapped) {
+    this.wrapped = wrapped;
+  }
+
+  @Nullable
+  @Override
+  public LoadData<Data> buildLoadData(
+      @NonNull WaitModel<Model> waitModel, int width, int height, @NonNull Options options) {
+    LoadData<Data> wrappedLoadData = wrapped
+        .buildLoadData(waitModel.wrapped, width, height, options);
+    if (wrappedLoadData == null) {
+      return null;
+    }
+    return new LoadData<>(
+        wrappedLoadData.sourceKey, new WaitFetcher<>(wrappedLoadData.fetcher, waitModel.latch));
+  }
+
+  @Override
+  public boolean handles(@NonNull WaitModel<Model> waitModel) {
+    return wrapped.handles(waitModel.wrapped);
+  }
+
+  public static final class WaitModel<T> {
+    private final CountDownLatch latch = new CountDownLatch(1);
+    private final T wrapped;
+
+    WaitModel(T wrapped) {
+      this.wrapped = wrapped;
+    }
+
+    public void countDown() {
+      if (latch.getCount() != 1) {
+        throw new IllegalStateException();
+      }
+      latch.countDown();
+    }
+  }
+
+  public static final class Factory<Model, Data>
+      implements ModelLoaderFactory<WaitModel<Model>, Data> {
+
+    private final Class<Model> modelClass;
+    private final Class<Data> dataClass;
+
+    Factory(Class<Model> modelClass, Class<Data> dataClass) {
+      this.modelClass = modelClass;
+      this.dataClass = dataClass;
+    }
+
+    public static synchronized <T> WaitModel<T> waitOn(T model) {
+      @SuppressWarnings("unchecked") ModelLoaderFactory<WaitModel<T>, InputStream> streamFactory =
+          new Factory<>((Class<T>) model.getClass(), InputStream.class);
+      Glide.get(InstrumentationRegistry.getTargetContext())
+          .getRegistry()
+          .replace(WaitModel.class, InputStream.class, streamFactory);
+
+      return new WaitModel<>(model);
+    }
+
+    @NonNull
+    @Override
+    public ModelLoader<WaitModel<Model>, Data> build(
+        MultiModelLoaderFactory multiFactory) {
+      return new WaitModelLoader<>(multiFactory.build(modelClass, dataClass));
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+  }
+
+  private static final class WaitFetcher<Data> implements DataFetcher<Data> {
+
+    private final DataFetcher<Data> wrapped;
+    private final CountDownLatch toWaitOn;
+
+    WaitFetcher(DataFetcher<Data> wrapped, CountDownLatch toWaitOn) {
+      this.wrapped = wrapped;
+      this.toWaitOn = toWaitOn;
+    }
+
+    @Override
+    public void loadData(@NonNull Priority priority, @NonNull DataCallback<? super Data> callback) {
+      ConcurrencyHelper.waitOnLatch(toWaitOn);
+      wrapped.loadData(priority, callback);
+    }
+
+    @Override
+    public void cleanup() {
+      wrapped.cleanup();
+    }
+
+    @Override
+    public void cancel() {
+      wrapped.cancel();
+    }
+
+    @NonNull
+    @Override
+    public Class<Data> getDataClass() {
+      return wrapped.getDataClass();
+    }
+
+    @NonNull
+    @Override
+    public DataSource getDataSource() {
+      return wrapped.getDataSource();
+    }
+  }
+}
diff --git a/instrumentation/src/main/AndroidManifest.xml b/instrumentation/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..fa6e2915f
--- /dev/null
+++ b/instrumentation/src/main/AndroidManifest.xml
@@ -0,0 +1,6 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+  package="com.bumptech.glide.instrumentation">
+  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
+  <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" />
+  <application />
+</manifest>
diff --git a/instrumentation/src/main/java/com/bumptech/glide/test/InstrumentationAppGlideModule.java b/instrumentation/src/main/java/com/bumptech/glide/test/InstrumentationAppGlideModule.java
new file mode 100644
index 000000000..056d6140a
--- /dev/null
+++ b/instrumentation/src/main/java/com/bumptech/glide/test/InstrumentationAppGlideModule.java
@@ -0,0 +1,9 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
+
+@GlideModule
+public class InstrumentationAppGlideModule extends AppGlideModule {
+  // Intentionally empty.
+}
diff --git a/instrumentation/src/main/res/drawable/bitmap_alias.xml b/instrumentation/src/main/res/drawable/bitmap_alias.xml
new file mode 100644
index 000000000..7dc0bb70a
--- /dev/null
+++ b/instrumentation/src/main/res/drawable/bitmap_alias.xml
@@ -0,0 +1,3 @@
+<?xml version="1.0" encoding="utf-8"?>
+<bitmap xmlns:android="http://schemas.android.com/apk/res/android"
+  android:src="@android:drawable/star_big_off" />
diff --git a/instrumentation/src/main/res/drawable/googlelogo_color_120x44dp.9.png b/instrumentation/src/main/res/drawable/googlelogo_color_120x44dp.9.png
new file mode 100644
index 000000000..1ab50e6cf
Binary files /dev/null and b/instrumentation/src/main/res/drawable/googlelogo_color_120x44dp.9.png differ
diff --git a/instrumentation/src/main/res/drawable/shape_drawable.xml b/instrumentation/src/main/res/drawable/shape_drawable.xml
new file mode 100644
index 000000000..3b19d1445
--- /dev/null
+++ b/instrumentation/src/main/res/drawable/shape_drawable.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<shape xmlns:android="http://schemas.android.com/apk/res/android"
+  android:shape="rectangle">
+  <solid android:color="#ffabcdef"/>
+</shape>
diff --git a/instrumentation/src/main/res/drawable/state_list_drawable.xml b/instrumentation/src/main/res/drawable/state_list_drawable.xml
new file mode 100644
index 000000000..d43039f86
--- /dev/null
+++ b/instrumentation/src/main/res/drawable/state_list_drawable.xml
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="utf-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+
+  <item android:drawable="@android:drawable/checkbox_on_background"
+    android:state_pressed="true" />
+  <item android:drawable="@android:drawable/checkbox_on_background"
+    android:state_checked="true" />
+  <item android:drawable="@android:drawable/checkbox_off_background" />
+
+</selector>
diff --git a/instrumentation/src/main/res/drawable/vector_drawable.xml b/instrumentation/src/main/res/drawable/vector_drawable.xml
new file mode 100644
index 000000000..1732bb9ba
--- /dev/null
+++ b/instrumentation/src/main/res/drawable/vector_drawable.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+  android:width="64dp"
+  android:height="64dp"
+  android:viewportHeight="24.0"
+  android:viewportWidth="24.0">
+  <path
+    android:fillColor="#f9b840"
+    android:pathData="M15.5,5.5c1.1,0 2,-0.9 2,-2s-0.9,-2 -2,-2 -2,0.9
+        -2,2 0.9,2 2,2zM5,12c-2.8,0 -5,2.2 -5,5s2.2,5 5,5 5,-2.2 5,-5 -2.2,
+        -5 -5,-5zM5,20.5c-1.9,0 -3.5,-1.6 -3.5,-3.5s1.6,-3.5 3.5,-3.5 3.5,
+        1.6 3.5,3.5 -1.6,3.5 -3.5,3.5zM10.8,10.5l2.4,-2.4 0.8,0.8c1.3,1.3
+        3,2.1 5.1,2.1L19.1,9c-1.5,0 -2.7,-0.6 -3.6,-1.5l-1.9,-1.9c-0.5,-0.4
+        -1,-0.6 -1.6,-0.6s-1.1,0.2 -1.4,0.6L7.8,8.4c-0.4,0.4 -0.6,0.9 -0.6,
+        1.4 0,0.6 0.2,1.1 0.6,1.4L11,14v5h2v-6.2l-2.2,-2.3zM19,12c-2.8,0 -5,
+        2.2 -5,5s2.2,5 5,5 5,-2.2 5,-5 -2.2,-5 -5,-5zM19,20.5c-1.9,0 -3.5,-1.6
+         -3.5,-3.5s1.6,-3.5 3.5,-3.5 3.5,1.6 3.5,3.5 -1.6,3.5 -3.5,3.5z" />
+</vector>
diff --git a/instrumentation/src/main/res/raw/canonical.jpg b/instrumentation/src/main/res/raw/canonical.jpg
new file mode 100644
index 000000000..889ba2762
Binary files /dev/null and b/instrumentation/src/main/res/raw/canonical.jpg differ
diff --git a/instrumentation/src/main/res/raw/canonical_png.png b/instrumentation/src/main/res/raw/canonical_png.png
new file mode 100644
index 000000000..475aa74c4
Binary files /dev/null and b/instrumentation/src/main/res/raw/canonical_png.png differ
diff --git a/instrumentation/src/main/res/raw/canonical_transparent_png.png b/instrumentation/src/main/res/raw/canonical_transparent_png.png
new file mode 100644
index 000000000..6e8e3eb97
Binary files /dev/null and b/instrumentation/src/main/res/raw/canonical_transparent_png.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_16_armeabi_v7a.png
new file mode 100644
index 000000000..a001e38f1
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_16_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_16_x86.png
new file mode 100644
index 000000000..3a08a9026
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_21_armeabi_v7a.png
new file mode 100644
index 000000000..a001e38f1
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_21_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_21_x86.png
new file mode 100644
index 000000000..515b8e4d3
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_24_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_24_x86.png
new file mode 100644
index 000000000..16efb6214
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_16_armeabi_v7a.png
new file mode 100644
index 000000000..33ae114e4
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_16_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_16_x86.png
new file mode 100644
index 000000000..930e93090
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_21_armeabi_v7a.png
new file mode 100644
index 000000000..33ae114e4
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_21_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_21_x86.png
new file mode 100644
index 000000000..cfd574f85
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_24_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_24_x86.png
new file mode 100644
index 000000000..f8bd1018a
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_16_armeabi_v7a.png
new file mode 100644
index 000000000..3c4f98d1b
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_16_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_16_x86.png
new file mode 100644
index 000000000..fdc961ec6
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_21_armeabi_v7a.png
new file mode 100644
index 000000000..3c4f98d1b
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_21_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_21_x86.png
new file mode 100644
index 000000000..1cd39b7e8
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_24_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_24_x86.png
new file mode 100644
index 000000000..25ca7a8d8
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_16_armeabi_v7a.png
new file mode 100644
index 000000000..63613050c
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_16_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_16_x86.png
new file mode 100644
index 000000000..a6f2ebb73
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_21_armeabi_v7a.png
new file mode 100644
index 000000000..63613050c
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_21_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_21_x86.png
new file mode 100644
index 000000000..fce9cc8e9
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_24_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_24_x86.png
new file mode 100644
index 000000000..889309568
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_16_armeabi_v7a.png
new file mode 100644
index 000000000..7d9667d0c
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_16_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_16_x86.png
new file mode 100644
index 000000000..1515a3629
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_18_armeabi_v7a.png
new file mode 100644
index 000000000..b6cccc383
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_18_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_18_x86.png
new file mode 100644
index 000000000..040a0cb58
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_21_armeabi_v7a.png
new file mode 100644
index 000000000..b6cccc383
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_21_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_21_x86.png
new file mode 100644
index 000000000..3746332ad
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_23_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_23_x86.png
new file mode 100644
index 000000000..c0e1a463f
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_24_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_24_x86.png
new file mode 100644
index 000000000..84ce56297
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_26_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_26_x86.png
new file mode 100644
index 000000000..84ce56297
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_26_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_16_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_16_x86.png
new file mode 100644
index 000000000..1515a3629
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_18_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_18_x86.png
new file mode 100644
index 000000000..040a0cb58
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_21_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_21_x86.png
new file mode 100644
index 000000000..3746332ad
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_23_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_23_x86.png
new file mode 100644
index 000000000..c0e1a463f
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_24_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_24_x86.png
new file mode 100644
index 000000000..84ce56297
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_26_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_26_x86.png
new file mode 100644
index 000000000..84ce56297
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_26_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png
new file mode 100644
index 000000000..bba6152db
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_16_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_16_x86.png
new file mode 100644
index 000000000..b667fbe14
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_18_armeabi_v7a.png
new file mode 100644
index 000000000..3d86fa33a
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_18_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_18_x86.png
new file mode 100644
index 000000000..5829492f9
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png
new file mode 100644
index 000000000..3d86fa33a
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_21_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_21_x86.png
new file mode 100644
index 000000000..7de62e0ea
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_23_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_23_x86.png
new file mode 100644
index 000000000..fdc93c5f0
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_24_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_24_x86.png
new file mode 100644
index 000000000..0f6e9e1df
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_26_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_26_x86.png
new file mode 100644
index 000000000..060028372
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_26_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_16_armeabi_v7a.png
new file mode 100644
index 000000000..6d5494869
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_16_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_16_x86.png
new file mode 100644
index 000000000..80aa1e15a
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_18_armeabi_v7a.png
new file mode 100644
index 000000000..1c0e76eb5
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_18_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_18_x86.png
new file mode 100644
index 000000000..95a70ed33
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_21_armeabi_v7a.png
new file mode 100644
index 000000000..1c0e76eb5
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_21_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_21_x86.png
new file mode 100644
index 000000000..466ab5d9f
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_23_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_23_x86.png
new file mode 100644
index 000000000..810cec1b2
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_24_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_24_x86.png
new file mode 100644
index 000000000..43b654ec6
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_26_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_26_x86.png
new file mode 100644
index 000000000..ceca292da
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_26_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_16_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_16_x86.png
new file mode 100644
index 000000000..cab94eaaa
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_18_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_18_x86.png
new file mode 100644
index 000000000..640c93085
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_21_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_21_x86.png
new file mode 100644
index 000000000..9ead8030f
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_23_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_23_x86.png
new file mode 100644
index 000000000..6f4a4e311
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_24_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_24_x86.png
new file mode 100644
index 000000000..6ab29373f
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_26_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_26_x86.png
new file mode 100644
index 000000000..54d467fb6
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_26_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_16_armeabi_v7a.png
new file mode 100644
index 000000000..288e5f0a3
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_16_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_16_x86.png
new file mode 100644
index 000000000..cab94eaaa
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_18_armeabi_v7a.png
new file mode 100644
index 000000000..14f685740
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_18_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_18_x86.png
new file mode 100644
index 000000000..640c93085
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_21_armeabi_v7a.png
new file mode 100644
index 000000000..14f685740
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_21_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_21_x86.png
new file mode 100644
index 000000000..9ead8030f
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_23_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_23_x86.png
new file mode 100644
index 000000000..6f4a4e311
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_24_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_24_x86.png
new file mode 100644
index 000000000..6ab29373f
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_26_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_26_x86.png
new file mode 100644
index 000000000..54d467fb6
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_26_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png
new file mode 100644
index 000000000..b83034ff1
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_16_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_16_x86.png
new file mode 100644
index 000000000..1262ce7c0
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png
new file mode 100644
index 000000000..b83034ff1
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_21_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_21_x86.png
new file mode 100644
index 000000000..5a64e7e63
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_24_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_24_x86.png
new file mode 100644
index 000000000..396837460
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png
new file mode 100644
index 000000000..31351c2ac
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_16_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_16_x86.png
new file mode 100644
index 000000000..1a6a857c7
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png
new file mode 100644
index 000000000..31351c2ac
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_21_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_21_x86.png
new file mode 100644
index 000000000..9320e9f76
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_24_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_24_x86.png
new file mode 100644
index 000000000..fb6a40f75
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_16_armeabi_v7a.png
new file mode 100644
index 000000000..9f7ad2686
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_16_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_16_x86.png
new file mode 100644
index 000000000..2e1cbbf18
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_21_armeabi_v7a.png
new file mode 100644
index 000000000..9f7ad2686
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_21_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_21_x86.png
new file mode 100644
index 000000000..afe43f81a
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_24_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_24_x86.png
new file mode 100644
index 000000000..5c0019916
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_armeabi_v7a.png
new file mode 100644
index 000000000..fe7204f45
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_x86.png
new file mode 100644
index 000000000..7e45a3dc9
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_armeabi_v7a.png
new file mode 100644
index 000000000..fe7204f45
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_x86.png
new file mode 100644
index 000000000..c1e4e13fc
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_24_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_24_x86.png
new file mode 100644
index 000000000..e7eb65010
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/dl_world_anim.gif b/instrumentation/src/main/res/raw/dl_world_anim.gif
new file mode 100644
index 000000000..1e3b8dea2
Binary files /dev/null and b/instrumentation/src/main/res/raw/dl_world_anim.gif differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png
new file mode 100644
index 000000000..b83034ff1
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_16_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_16_x86.png
new file mode 100644
index 000000000..1262ce7c0
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_18_armeabi_v7a.png
new file mode 100644
index 000000000..b83034ff1
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_18_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_18_x86.png
new file mode 100644
index 000000000..1262ce7c0
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_19_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_19_armeabi_v7a.png
new file mode 100644
index 000000000..b83034ff1
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_19_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_19_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_19_x86.png
new file mode 100644
index 000000000..1262ce7c0
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_19_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png
new file mode 100644
index 000000000..b83034ff1
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_21_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_21_x86.png
new file mode 100644
index 000000000..5a64e7e63
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_23_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_23_x86.png
new file mode 100644
index 000000000..5a64e7e63
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_24_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_24_x86.png
new file mode 100644
index 000000000..396837460
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png
new file mode 100644
index 000000000..31351c2ac
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_16_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_16_x86.png
new file mode 100644
index 000000000..1a6a857c7
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_18_armeabi_v7a.png
new file mode 100644
index 000000000..31351c2ac
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_18_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_18_x86.png
new file mode 100644
index 000000000..1a6a857c7
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_19_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_19_armeabi_v7a.png
new file mode 100644
index 000000000..31351c2ac
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_19_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_19_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_19_x86.png
new file mode 100644
index 000000000..1a6a857c7
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_19_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png
new file mode 100644
index 000000000..31351c2ac
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_21_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_21_x86.png
new file mode 100644
index 000000000..9320e9f76
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_23_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_23_x86.png
new file mode 100644
index 000000000..9320e9f76
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_24_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_24_x86.png
new file mode 100644
index 000000000..fb6a40f75
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_16_armeabi_v7a.png
new file mode 100644
index 000000000..e1abe0fae
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_16_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_16_x86.png
new file mode 100644
index 000000000..6834ef69e
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_18_armeabi_v7a.png
new file mode 100644
index 000000000..e1abe0fae
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_18_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_18_x86.png
new file mode 100644
index 000000000..6834ef69e
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_19_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_19_armeabi_v7a.png
new file mode 100644
index 000000000..e1abe0fae
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_19_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_19_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_19_x86.png
new file mode 100644
index 000000000..6834ef69e
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_19_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_21_armeabi_v7a.png
new file mode 100644
index 000000000..e1abe0fae
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_21_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_21_x86.png
new file mode 100644
index 000000000..cbf40ecec
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_23_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_23_x86.png
new file mode 100644
index 000000000..cbf40ecec
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_24_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_24_x86.png
new file mode 100644
index 000000000..a2a03bfe4
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_armeabi_v7a.png
new file mode 100644
index 000000000..fe7204f45
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_x86.png
new file mode 100644
index 000000000..7e45a3dc9
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_18_armeabi_v7a.png
new file mode 100644
index 000000000..fe7204f45
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_18_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_18_x86.png
new file mode 100644
index 000000000..7e45a3dc9
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_19_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_19_armeabi_v7a.png
new file mode 100644
index 000000000..fe7204f45
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_19_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_19_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_19_x86.png
new file mode 100644
index 000000000..7e45a3dc9
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_19_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_armeabi_v7a.png
new file mode 100644
index 000000000..fe7204f45
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_x86.png
new file mode 100644
index 000000000..c1e4e13fc
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_23_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_23_x86.png
new file mode 100644
index 000000000..c1e4e13fc
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_24_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_24_x86.png
new file mode 100644
index 000000000..e7eb65010
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/interlaced_transparent_gif.gif b/instrumentation/src/main/res/raw/interlaced_transparent_gif.gif
new file mode 100644
index 000000000..283e0fb16
Binary files /dev/null and b/instrumentation/src/main/res/raw/interlaced_transparent_gif.gif differ
diff --git a/instrumentation/src/main/res/raw/opaque_gif.gif b/instrumentation/src/main/res/raw/opaque_gif.gif
new file mode 100644
index 000000000..3b50db910
Binary files /dev/null and b/instrumentation/src/main/res/raw/opaque_gif.gif differ
diff --git a/instrumentation/src/main/res/raw/opaque_interlaced_gif.gif b/instrumentation/src/main/res/raw/opaque_interlaced_gif.gif
new file mode 100644
index 000000000..4ebf12daf
Binary files /dev/null and b/instrumentation/src/main/res/raw/opaque_interlaced_gif.gif differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_16_armeabi_v7a.png
new file mode 100644
index 000000000..caa7c5963
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_16_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_16_x86.png
new file mode 100644
index 000000000..45956c505
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_18_armeabi_v7a.png
new file mode 100644
index 000000000..669269f2b
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_18_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_18_x86.png
new file mode 100644
index 000000000..3e4aab0a0
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_19_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_19_armeabi_v7a.png
new file mode 100644
index 000000000..669269f2b
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_19_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_19_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_19_x86.png
new file mode 100644
index 000000000..3e4aab0a0
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_19_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_21_armeabi_v7a.png
new file mode 100644
index 000000000..6c4dab5b5
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_21_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_21_x86.png
new file mode 100644
index 000000000..28cfaf4bf
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_23_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_23_x86.png
new file mode 100644
index 000000000..28cfaf4bf
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_24_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_24_x86.png
new file mode 100644
index 000000000..cd56aa644
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_26_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_26_x86.png
new file mode 100644
index 000000000..e68bc997c
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_26_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_16_armeabi_v7a.png
new file mode 100644
index 000000000..e1eda26d6
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_16_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_16_x86.png
new file mode 100644
index 000000000..6a53e1dd8
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_18_armeabi_v7a.png
new file mode 100644
index 000000000..683d55fe4
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_18_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_18_x86.png
new file mode 100644
index 000000000..c70fdea57
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_19_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_19_armeabi_v7a.png
new file mode 100644
index 000000000..683d55fe4
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_19_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_19_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_19_x86.png
new file mode 100644
index 000000000..c70fdea57
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_19_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_21_armeabi_v7a.png
new file mode 100644
index 000000000..ecbff14cb
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_21_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_21_x86.png
new file mode 100644
index 000000000..cbb3895b0
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_23_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_23_x86.png
new file mode 100644
index 000000000..843b78f9b
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_24_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_24_x86.png
new file mode 100644
index 000000000..fd26de305
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_26_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_26_x86.png
new file mode 100644
index 000000000..098a5da5e
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_26_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_16_armeabi_v7a.png
new file mode 100644
index 000000000..c8bc48aa4
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_16_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_16_x86.png
new file mode 100644
index 000000000..e42fb5cf8
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_18_armeabi_v7a.png
new file mode 100644
index 000000000..a5cda420f
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_18_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_18_x86.png
new file mode 100644
index 000000000..42229a13f
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_19_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_19_armeabi_v7a.png
new file mode 100644
index 000000000..a5cda420f
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_19_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_19_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_19_x86.png
new file mode 100644
index 000000000..42229a13f
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_19_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_21_armeabi_v7a.png
new file mode 100644
index 000000000..b29b0da31
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_21_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_21_x86.png
new file mode 100644
index 000000000..0f4b78b5d
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_23_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_23_x86.png
new file mode 100644
index 000000000..0f4b78b5d
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_24_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_24_x86.png
new file mode 100644
index 000000000..2295f8881
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_26_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_26_x86.png
new file mode 100644
index 000000000..2295f8881
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_26_x86.png differ
diff --git a/instrumentation/src/main/res/raw/transparent_gif.gif b/instrumentation/src/main/res/raw/transparent_gif.gif
new file mode 100644
index 000000000..88c7097e7
Binary files /dev/null and b/instrumentation/src/main/res/raw/transparent_gif.gif differ
diff --git a/instrumentation/src/main/res/raw/video.mp4 b/instrumentation/src/main/res/raw/video.mp4
new file mode 100644
index 000000000..3ffc91a98
Binary files /dev/null and b/instrumentation/src/main/res/raw/video.mp4 differ
diff --git a/instrumentation/src/main/res/raw/webkit_logo_p3.png b/instrumentation/src/main/res/raw/webkit_logo_p3.png
new file mode 100644
index 000000000..55bad7f81
Binary files /dev/null and b/instrumentation/src/main/res/raw/webkit_logo_p3.png differ
diff --git a/instrumentation/src/main/res/values/strings.xml b/instrumentation/src/main/res/values/strings.xml
new file mode 100644
index 000000000..55344e519
--- /dev/null
+++ b/instrumentation/src/main/res/values/strings.xml
@@ -0,0 +1,3 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+</resources>
\ No newline at end of file
diff --git a/integration/gifencoder/build.gradle b/integration/gifencoder/build.gradle
index 7219f4ffa..a2ebd546b 100644
--- a/integration/gifencoder/build.gradle
+++ b/integration/gifencoder/build.gradle
@@ -1,19 +1,18 @@
 apply plugin: 'com.android.library'
 
 dependencies {
-    compile project(':library')
-
-    testCompile project(":testutil")
-    testCompile "com.google.truth:truth:${TRUTH_VERSION}"
-    testCompile "junit:junit:${JUNIT_VERSION}"
-    testCompile "org.mockito:mockito-all:${MOCKITO_VERSION}"
-    testCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
-    testCompile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
+    implementation project(':library')
+
+    testImplementation project(":testutil")
+    testImplementation "com.google.truth:truth:${TRUTH_VERSION}"
+    testImplementation "junit:junit:${JUNIT_VERSION}"
+    testImplementation "org.mockito:mockito-core:${MOCKITO_VERSION}"
+    testImplementation "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
+    testImplementation "com.android.support:support-v4:${ANDROID_SUPPORT_VERSION}"
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     sourceSets {
         main {
diff --git a/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java
index 9051d5f12..0d67e6fd7 100644
--- a/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java
+++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java
@@ -2,6 +2,8 @@
 
 import android.content.Context;
 import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
 import android.util.Log;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.gifdecoder.GifHeader;
@@ -37,19 +39,22 @@
 
   private static final String KEY_ENCODE_TRANSFORMATION =
       "com.bumptech.glide.load.resource.gif.GifResourceEncoder.EncodeTransformation";
-   /**
+  /**
    * A boolean option that, if set to <code>true</code>, causes the fully transformed
    * GIF to be written to cache.
    *
-   * <p> Warning - encoding GIFs is slow and often produces larger and less efficient GIFs than
-   * the originals. Re-encoding may be worth it to decrease the size of very large GIFs. </p>
+   * <p>Warning - encoding GIFs is slow and often produces larger and less efficient GIFs than
+   * the originals. Re-encoding may be worth it to decrease the size of very large GIFs.
    *
-   * <p> Defaults to <code>false</code>. </p>
+   * <p>Defaults to <code>false</code>.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public static final Option<Boolean> ENCODE_TRANSFORMATION =
       Option.disk(KEY_ENCODE_TRANSFORMATION, false, new Option.CacheKeyUpdater<Boolean>() {
         @Override
-        public void update(byte[] keyBytes, Boolean value, MessageDigest messageDigest) {
+        public void update(@NonNull byte[] keyBytes, @NonNull Boolean value,
+            @NonNull MessageDigest messageDigest) {
           if (value) {
             messageDigest.update(keyBytes);
           }
@@ -59,15 +64,17 @@ public void update(byte[] keyBytes, Boolean value, MessageDigest messageDigest)
   private static final Factory FACTORY = new Factory();
   private static final String TAG = "GifEncoder";
   private final GifDecoder.BitmapProvider provider;
-  private Context context;
+  private final Context context;
   private final BitmapPool bitmapPool;
   private final Factory factory;
 
-  public ReEncodingGifResourceEncoder(Context context, BitmapPool bitmapPool) {
+  // Public API.
+  @SuppressWarnings("unused")
+  public ReEncodingGifResourceEncoder(@NonNull Context context, @NonNull BitmapPool bitmapPool) {
     this(context, bitmapPool, FACTORY);
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   ReEncodingGifResourceEncoder(Context context, BitmapPool bitmapPool, Factory factory) {
     this.context = context;
     this.bitmapPool = bitmapPool;
@@ -75,15 +82,17 @@ public ReEncodingGifResourceEncoder(Context context, BitmapPool bitmapPool) {
     this.factory = factory;
   }
 
+  @NonNull
   @Override
-  public EncodeStrategy getEncodeStrategy(Options options) {
+  public EncodeStrategy getEncodeStrategy(@NonNull Options options) {
     Boolean encodeTransformation = options.get(ENCODE_TRANSFORMATION);
     return encodeTransformation != null && encodeTransformation
         ? EncodeStrategy.TRANSFORMED : EncodeStrategy.SOURCE;
   }
 
   @Override
-  public boolean encode(Resource<GifDrawable> resource, File file, Options options) {
+  public boolean encode(@NonNull Resource<GifDrawable> resource, @NonNull File file,
+      @NonNull Options options) {
     GifDrawable drawable = resource.get();
     Transformation<Bitmap> transformation = drawable.getFrameTransformation();
     boolean isTransformed = !(transformation instanceof UnitTransformation);
@@ -191,22 +200,23 @@ private GifDecoder decodeHeaders(ByteBuffer data) {
     return transformedResource;
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class Factory {
 
-    public GifDecoder buildDecoder(GifDecoder.BitmapProvider bitmapProvider) {
+    GifDecoder buildDecoder(GifDecoder.BitmapProvider bitmapProvider) {
       return new StandardGifDecoder(bitmapProvider);
     }
 
-    public GifHeaderParser buildParser() {
+    GifHeaderParser buildParser() {
       return new GifHeaderParser();
     }
 
-    public AnimatedGifEncoder buildEncoder() {
+    AnimatedGifEncoder buildEncoder() {
       return new AnimatedGifEncoder();
     }
 
-    public Resource<Bitmap> buildFrameResource(Bitmap bitmap, BitmapPool bitmapPool) {
+    @NonNull
+    Resource<Bitmap> buildFrameResource(@NonNull Bitmap bitmap, @NonNull BitmapPool bitmapPool) {
       return new BitmapResource(bitmap, bitmapPool);
     }
   }
diff --git a/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java
index dde1d0243..641dc7357 100644
--- a/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java
+++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java
@@ -3,7 +3,6 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
-import static org.junit.Assume.assumeTrue;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
 import static org.mockito.Matchers.eq;
@@ -49,14 +48,14 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class ReEncodingGifResourceEncoderTest {
-  @Mock Resource<GifDrawable> resource;
-  @Mock GifDecoder decoder;
-  @Mock GifHeaderParser parser;
-  @Mock AnimatedGifEncoder gifEncoder;
-  @Mock Resource<Bitmap> frameResource;
-  @Mock GifDrawable gifDrawable;
-  @Mock Transformation<Bitmap> frameTransformation;
-  @Mock Resource<Bitmap> transformedResource;
+  @Mock private Resource<GifDrawable> resource;
+  @Mock private GifDecoder decoder;
+  @Mock private GifHeaderParser parser;
+  @Mock private AnimatedGifEncoder gifEncoder;
+  @Mock private Resource<Bitmap> frameResource;
+  @Mock private GifDrawable gifDrawable;
+  @Mock private Transformation<Bitmap> frameTransformation;
+  @Mock private Resource<Bitmap> transformedResource;
 
   private ReEncodingGifResourceEncoder encoder;
   private Options options;
@@ -70,6 +69,7 @@ public void setUp() {
     Application context = RuntimeEnvironment.application;
 
     ReEncodingGifResourceEncoder.Factory factory = mock(ReEncodingGifResourceEncoder.Factory.class);
+    when(decoder.getNextFrame()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
     when(factory.buildDecoder(any(GifDecoder.BitmapProvider.class))).thenReturn(decoder);
     when(factory.buildParser()).thenReturn(parser);
     when(factory.buildEncoder()).thenReturn(gifEncoder);
@@ -94,6 +94,8 @@ public void setUp() {
 
   @After
   public void tearDown() {
+    // GC before delete() to release files on Windows (https://stackoverflow.com/a/4213208/253468)
+    System.gc();
     if (file.exists() && !file.delete()) {
       throw new RuntimeException("Failed to delete file");
     }
@@ -119,8 +121,6 @@ public void testEncodeStrategy_withEncodeTransformationFalse_returnsSource() {
   @Test
   public void testEncode_withEncodeTransformationFalse_writesSourceDataToStream()
       throws IOException {
-    // Most likely an instance of http://stackoverflow.com/q/991489/253468
-    assumeTrue(!System.getProperty("os.name").startsWith("Windows"));
     options.set(ReEncodingGifResourceEncoder.ENCODE_TRANSFORMATION, false);
     String expected = "testString";
     byte[] data = expected.getBytes("UTF-8");
@@ -133,7 +133,6 @@ public void testEncode_withEncodeTransformationFalse_writesSourceDataToStream()
   @Test
   public void testEncode_WithEncodeTransformationFalse_whenOsThrows_returnsFalse()
       throws IOException {
-
     options.set(ReEncodingGifResourceEncoder.ENCODE_TRANSFORMATION, false);
     byte[] data = "testString".getBytes("UTF-8");
     when(gifDrawable.getBuffer()).thenReturn(ByteBuffer.wrap(data));
@@ -311,10 +310,7 @@ public void testRecyclesFrameResourceAfterWritingIfFrameResourceIsNotTransformed
   }
 
   @Test
-  public void testWritesBytesDirectlyToDiskIfTransformationIsUnitTransformation()
-      throws IOException {
-    // Most likely an instance of http://stackoverflow.com/q/991489/253468
-    assumeTrue(!System.getProperty("os.name").startsWith("Windows"));
+  public void testWritesBytesDirectlyToDiskIfTransformationIsUnitTransformation() {
     when(gifDrawable.getFrameTransformation()).thenReturn(UnitTransformation.<Bitmap>get());
     String expected = "expected";
     when(gifDrawable.getBuffer()).thenReturn(ByteBuffer.wrap(expected.getBytes()));
diff --git a/integration/okhttp/build.gradle b/integration/okhttp/build.gradle
index 87d700ac0..a8cd599a1 100644
--- a/integration/okhttp/build.gradle
+++ b/integration/okhttp/build.gradle
@@ -1,16 +1,15 @@
 apply plugin: 'com.android.library'
 
 dependencies {
-    compile project(':library')
+    implementation project(':library')
     annotationProcessor project(':annotation:compiler')
 
-    compile "com.squareup.okhttp:okhttp:2.7.1"
-    compile "com.android.support:support-annotations:{$SUPPORT_V4_VERSION}"
+    api "com.squareup.okhttp:okhttp:2.7.5"
+    api "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}"
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         minSdkVersion MIN_SDK_VERSION as int
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java
index fa45bb6c9..1bc1047a9 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java
@@ -1,11 +1,11 @@
 package com.bumptech.glide.integration.okhttp;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
 import com.bumptech.glide.load.model.GlideUrl;
-import com.bumptech.glide.module.GlideModule;
 import java.io.InputStream;
 
 /**
@@ -20,9 +20,9 @@
  * @deprecated replaced with com.bumptech.glide.integration.okhttp3.OkHttpGlideModule.
  */
 @Deprecated
-public class OkHttpGlideModule implements GlideModule {
+public class OkHttpGlideModule implements com.bumptech.glide.module.GlideModule {
   @Override
-  public void applyOptions(Context context, GlideBuilder builder) {
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
     // Do nothing.
   }
 
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java
index dd4bbfb27..bc81dabc0 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java
@@ -15,8 +15,11 @@
  * <p>For Applications that depend on this library and include an
  * {@link AppGlideModule} and Glide's annotation processor, this class
  * will be automatically included.
+ *
+ * @deprecated Prefer the okhttp3 version instead.
  */
 @GlideModule
+@Deprecated
 public class OkHttpLibraryGlideModule extends LibraryGlideModule {
   @Override
   public void registerComponents(Context context, Glide glide, Registry registry) {
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
index 936f95f81..dcac2f768 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
@@ -27,16 +27,19 @@
   private static final String TAG = "OkHttpFetcher";
   private final OkHttpClient client;
   private final GlideUrl url;
-  @Synthetic InputStream stream;
-  @Synthetic ResponseBody responseBody;
+  @SuppressWarnings("WeakerAccess") @Synthetic InputStream stream;
+  @SuppressWarnings("WeakerAccess") @Synthetic ResponseBody responseBody;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public OkHttpStreamFetcher(OkHttpClient client, GlideUrl url) {
     this.client = client;
     this.url = url;
   }
 
   @Override
-  public void loadData(Priority priority, final DataCallback<? super InputStream> callback) {
+  public void loadData(@NonNull Priority priority,
+      @NonNull final DataCallback<? super InputStream> callback) {
     Request.Builder requestBuilder = new Request.Builder().url(url.toStringUrl());
     for (Map.Entry<String, String> headerEntry : url.getHeaders().entrySet()) {
       String key = headerEntry.getKey();
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java
index 48468bf63..174c446f2 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.integration.okhttp;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
@@ -18,27 +19,32 @@
 
   private final OkHttpClient client;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public OkHttpUrlLoader(OkHttpClient client) {
     this.client = client;
   }
 
   @Override
-  public boolean handles(GlideUrl url) {
+  public boolean handles(@NonNull GlideUrl url) {
     return true;
   }
 
+  @SuppressWarnings("deprecation")
   @Override
-  public LoadData<InputStream> buildLoadData(GlideUrl model, int width, int height,
-      Options options) {
+  public LoadData<InputStream> buildLoadData(@NonNull GlideUrl model, int width, int height,
+      @NonNull Options options) {
     return new LoadData<>(model, new OkHttpStreamFetcher(client, model));
   }
 
   /**
    * The default factory for {@link OkHttpUrlLoader}s.
    */
+  // Public API.
+  @SuppressWarnings({"WeakerAccess", "deprecation"})
   public static class Factory implements ModelLoaderFactory<GlideUrl, InputStream> {
     private static volatile OkHttpClient internalClient;
-    private OkHttpClient client;
+    private final OkHttpClient client;
 
     private static OkHttpClient getInternalClient() {
       if (internalClient == null) {
@@ -65,6 +71,8 @@ public Factory(OkHttpClient client) {
       this.client = client;
     }
 
+    @NonNull
+    @SuppressWarnings("deprecation")
     @Override
     public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new OkHttpUrlLoader(client);
diff --git a/integration/okhttp3/build.gradle b/integration/okhttp3/build.gradle
index 6e90f1d55..8e8590841 100644
--- a/integration/okhttp3/build.gradle
+++ b/integration/okhttp3/build.gradle
@@ -1,16 +1,15 @@
 apply plugin: 'com.android.library'
 
 dependencies {
-    compile project(':library')
+    implementation project(':library')
     annotationProcessor project(':annotation:compiler')
 
-    compile "com.squareup.okhttp3:okhttp:${OK_HTTP_VERSION}"
-    compile "com.android.support:support-annotations:{$SUPPORT_V4_VERSION}"
+    api "com.squareup.okhttp3:okhttp:${OK_HTTP_VERSION}"
+    api "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}"
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         minSdkVersion MIN_SDK_VERSION as int
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java
index dc6b7b545..e58b041dd 100644
--- a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java
@@ -1,11 +1,11 @@
 package com.bumptech.glide.integration.okhttp3;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
 import com.bumptech.glide.load.model.GlideUrl;
-import com.bumptech.glide.module.GlideModule;
 import java.io.InputStream;
 
 /**
@@ -21,9 +21,9 @@
  * annotations.
  */
 @Deprecated
-public class OkHttpGlideModule implements GlideModule {
+public class OkHttpGlideModule implements com.bumptech.glide.module.GlideModule {
   @Override
-  public void applyOptions(Context context, GlideBuilder builder) {
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
     // Do nothing.
   }
 
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java
index 74eace9eb..b315acbd7 100644
--- a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.integration.okhttp3;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.Registry;
 import com.bumptech.glide.annotation.GlideModule;
@@ -19,7 +20,8 @@
 @GlideModule
 public final class OkHttpLibraryGlideModule extends LibraryGlideModule {
   @Override
-  public void registerComponents(Context context, Glide glide, Registry registry) {
+  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry) {
     registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());
   }
 }
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java
index 37f1f0e47..2b6a69b38 100644
--- a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java
@@ -8,7 +8,7 @@
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.util.ContentLengthInputStream;
-import com.bumptech.glide.util.Synthetic;
+import com.bumptech.glide.util.Preconditions;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.Map;
@@ -20,50 +20,58 @@
 /**
  * Fetches an {@link InputStream} using the okhttp library.
  */
-public class OkHttpStreamFetcher implements DataFetcher<InputStream> {
+public class OkHttpStreamFetcher implements DataFetcher<InputStream>, okhttp3.Callback {
   private static final String TAG = "OkHttpFetcher";
   private final Call.Factory client;
   private final GlideUrl url;
-  @Synthetic InputStream stream;
-  @Synthetic ResponseBody responseBody;
+  private InputStream stream;
+  private ResponseBody responseBody;
+  private DataCallback<? super InputStream> callback;
+  // call may be accessed on the main thread while the object is in use on other threads. All other
+  // accesses to variables may occur on different threads, but only one at a time.
   private volatile Call call;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public OkHttpStreamFetcher(Call.Factory client, GlideUrl url) {
     this.client = client;
     this.url = url;
   }
 
   @Override
-  public void loadData(Priority priority, final DataCallback<? super InputStream> callback) {
+  public void loadData(@NonNull Priority priority,
+      @NonNull final DataCallback<? super InputStream> callback) {
     Request.Builder requestBuilder = new Request.Builder().url(url.toStringUrl());
     for (Map.Entry<String, String> headerEntry : url.getHeaders().entrySet()) {
       String key = headerEntry.getKey();
       requestBuilder.addHeader(key, headerEntry.getValue());
     }
     Request request = requestBuilder.build();
+    this.callback = callback;
 
     call = client.newCall(request);
-    call.enqueue(new okhttp3.Callback() {
-      @Override
-      public void onFailure(Call call, IOException e) {
-        if (Log.isLoggable(TAG, Log.DEBUG)) {
-          Log.d(TAG, "OkHttp failed to obtain result", e);
-        }
-        callback.onLoadFailed(e);
-      }
+    call.enqueue(this);
+  }
 
-      @Override
-      public void onResponse(Call call, Response response) throws IOException {
-        responseBody = response.body();
-        if (response.isSuccessful()) {
-          long contentLength = responseBody.contentLength();
-          stream = ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);
-          callback.onDataReady(stream);
-        } else {
-          callback.onLoadFailed(new HttpException(response.message(), response.code()));
-        }
-      }
-    });
+  @Override
+  public void onFailure(@NonNull Call call, @NonNull IOException e) {
+    if (Log.isLoggable(TAG, Log.DEBUG)) {
+      Log.d(TAG, "OkHttp failed to obtain result", e);
+    }
+
+    callback.onLoadFailed(e);
+  }
+
+  @Override
+  public void onResponse(@NonNull Call call, @NonNull Response response) {
+    responseBody = response.body();
+    if (response.isSuccessful()) {
+      long contentLength = Preconditions.checkNotNull(responseBody).contentLength();
+      stream = ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);
+      callback.onDataReady(stream);
+    } else {
+      callback.onLoadFailed(new HttpException(response.message(), response.code()));
+    }
   }
 
   @Override
@@ -78,6 +86,7 @@ public void cleanup() {
     if (responseBody != null) {
       responseBody.close();
     }
+    callback = null;
   }
 
   @Override
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java
index b63164a59..8f8f9066c 100644
--- a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.integration.okhttp3;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
@@ -16,27 +17,31 @@
 
   private final Call.Factory client;
 
-  public OkHttpUrlLoader(Call.Factory client) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public OkHttpUrlLoader(@NonNull Call.Factory client) {
     this.client = client;
   }
 
   @Override
-  public boolean handles(GlideUrl url) {
+  public boolean handles(@NonNull GlideUrl url) {
     return true;
   }
 
   @Override
-  public LoadData<InputStream> buildLoadData(GlideUrl model, int width, int height,
-      Options options) {
+  public LoadData<InputStream> buildLoadData(@NonNull GlideUrl model, int width, int height,
+      @NonNull Options options) {
     return new LoadData<>(model, new OkHttpStreamFetcher(client, model));
   }
 
   /**
    * The default factory for {@link OkHttpUrlLoader}s.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public static class Factory implements ModelLoaderFactory<GlideUrl, InputStream> {
     private static volatile Call.Factory internalClient;
-    private Call.Factory client;
+    private final Call.Factory client;
 
     private static Call.Factory getInternalClient() {
       if (internalClient == null) {
@@ -61,10 +66,11 @@ public Factory() {
      *
      * @param client this is typically an instance of {@code OkHttpClient}.
      */
-    public Factory(Call.Factory client) {
+    public Factory(@NonNull Call.Factory client) {
       this.client = client;
     }
 
+    @NonNull
     @Override
     public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new OkHttpUrlLoader(client);
diff --git a/integration/recyclerview/build.gradle b/integration/recyclerview/build.gradle
index b08a88db7..2a6154e9f 100644
--- a/integration/recyclerview/build.gradle
+++ b/integration/recyclerview/build.gradle
@@ -1,13 +1,13 @@
 apply plugin: 'com.android.library'
 
 dependencies {
-    compile project(':library')
-    provided "com.android.support:recyclerview-v7:${SUPPORT_V7_VERSION}"
+    implementation project(':library')
+    compileOnly "com.android.support:recyclerview-v7:${ANDROID_SUPPORT_VERSION}"
+    compileOnly "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         minSdkVersion MIN_SDK_VERSION as int
diff --git a/integration/recyclerview/lint.xml b/integration/recyclerview/lint.xml
index ff7e5955c..5e2b51e98 100644
--- a/integration/recyclerview/lint.xml
+++ b/integration/recyclerview/lint.xml
@@ -1,4 +1,5 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <lint>
     <issue id="AllowBackup" severity="ignore"/>
+    <issue id="GradleDependency" severity="ignore" />
 </lint>
diff --git a/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerToListViewScrollListener.java b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerToListViewScrollListener.java
index a3fd25880..30bf14dcb 100644
--- a/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerToListViewScrollListener.java
+++ b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerToListViewScrollListener.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.integration.recyclerview;
 
+import android.support.annotation.NonNull;
 import android.support.v7.widget.LinearLayoutManager;
 import android.support.v7.widget.RecyclerView;
 import android.widget.AbsListView;
@@ -11,6 +12,8 @@
  *
  * <p>Requires that the the recycler view be using a {@link LinearLayoutManager} subclass.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public final class RecyclerToListViewScrollListener extends RecyclerView.OnScrollListener {
   public static final int UNKNOWN_SCROLL_STATE = Integer.MIN_VALUE;
   private final AbsListView.OnScrollListener scrollListener;
@@ -18,7 +21,7 @@
   private int lastVisibleCount = -1;
   private int lastItemCount = -1;
 
-  public RecyclerToListViewScrollListener(AbsListView.OnScrollListener scrollListener) {
+  public RecyclerToListViewScrollListener(@NonNull AbsListView.OnScrollListener scrollListener) {
     this.scrollListener = scrollListener;
   }
 
diff --git a/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java
index 47be184a7..988561eac 100644
--- a/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java
+++ b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java
@@ -1,7 +1,8 @@
 package com.bumptech.glide.integration.recyclerview;
 
 import android.app.Activity;
-import android.app.Fragment;
+import android.support.annotation.NonNull;
+import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
 import android.support.v7.widget.RecyclerView;
 import com.bumptech.glide.Glide;
@@ -34,17 +35,18 @@
   /**
    * Helper constructor that accepts an {@link Activity}.
    */
-  public RecyclerViewPreloader(Activity activity,
-      PreloadModelProvider<T> preloadModelProvider,
-      PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {
+  public RecyclerViewPreloader(@NonNull Activity activity,
+      @NonNull PreloadModelProvider<T> preloadModelProvider,
+      @NonNull PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {
     this(Glide.with(activity), preloadModelProvider, preloadDimensionProvider, maxPreload);
   }
 
   /**
    * Helper constructor that accepts an {@link FragmentActivity}.
    */
-  public RecyclerViewPreloader(FragmentActivity fragmentActivity,
-      PreloadModelProvider<T> preloadModelProvider, PreloadSizeProvider<T> preloadDimensionProvider,
+  public RecyclerViewPreloader(@NonNull FragmentActivity fragmentActivity,
+      @NonNull PreloadModelProvider<T> preloadModelProvider,
+      @NonNull PreloadSizeProvider<T> preloadDimensionProvider,
       int maxPreload) {
     this(Glide.with(fragmentActivity), preloadModelProvider, preloadDimensionProvider, maxPreload);
   }
@@ -52,20 +54,26 @@ public RecyclerViewPreloader(FragmentActivity fragmentActivity,
   /**
    * Helper constructor that accepts an {@link Fragment}.
    */
-  public RecyclerViewPreloader(Fragment fragment,
-      PreloadModelProvider<T> preloadModelProvider, PreloadSizeProvider<T> preloadDimensionProvider,
+  public RecyclerViewPreloader(@NonNull Fragment fragment,
+      @NonNull PreloadModelProvider<T> preloadModelProvider,
+      @NonNull PreloadSizeProvider<T> preloadDimensionProvider,
       int maxPreload) {
     this(Glide.with(fragment), preloadModelProvider, preloadDimensionProvider, maxPreload);
   }
 
   /**
-   * Helper constructor that accepts an {@link android.support.v4.app.Fragment}.
+   * Helper constructor that accepts an {@link android.app.Fragment}.
+   * @deprecated Use constructor <code>RecyclerViewPreloader(Fragment, PreloadModelProvider<T>,
+   * PreloadSizeProvider<T>)</code> instead.
    */
-  public RecyclerViewPreloader(android.support.v4.app.Fragment fragment,
-      PreloadModelProvider<T> preloadModelProvider, PreloadSizeProvider<T> preloadDimensionProvider,
+  @Deprecated
+  public RecyclerViewPreloader(@NonNull android.app.Fragment fragment,
+      @NonNull PreloadModelProvider<T> preloadModelProvider,
+      @NonNull PreloadSizeProvider<T> preloadDimensionProvider,
       int maxPreload) {
     this(Glide.with(fragment), preloadModelProvider, preloadDimensionProvider, maxPreload);
   }
+
   /**
    * Constructor that accepts interfaces for providing the dimensions of images to preload, the list
    * of models to preload for a given position, and the request to use to load images.
@@ -74,9 +82,9 @@ public RecyclerViewPreloader(android.support.v4.app.Fragment fragment,
    * @param preloadDimensionProvider Provides the dimensions of images to load.
    * @param maxPreload               Maximum number of items to preload.
    */
-  public RecyclerViewPreloader(RequestManager requestManager,
-      PreloadModelProvider<T> preloadModelProvider,
-      PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {
+  public RecyclerViewPreloader(@NonNull RequestManager requestManager,
+      @NonNull PreloadModelProvider<T> preloadModelProvider,
+      @NonNull PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {
 
     ListPreloader<T> listPreloader = new ListPreloader<>(requestManager, preloadModelProvider,
         preloadDimensionProvider, maxPreload);
diff --git a/integration/volley/build.gradle b/integration/volley/build.gradle
index 36a78dec3..a6776127a 100644
--- a/integration/volley/build.gradle
+++ b/integration/volley/build.gradle
@@ -1,22 +1,21 @@
 apply plugin: 'com.android.library'
 
 dependencies {
-    compile project(':library')
-    compile "com.android.volley:volley:${VOLLEY_VERSION}"
-    compile "com.android.support:support-annotations:{$SUPPORT_V4_VERSION}"
+    implementation project(':library')
+    api "com.android.volley:volley:${VOLLEY_VERSION}"
+    api "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}"
     annotationProcessor project(':annotation:compiler')
 
-    testCompile project(":testutil")
-    testCompile "com.google.truth:truth:${TRUTH_VERSION}"
-    testCompile "junit:junit:${JUNIT_VERSION}"
-    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}"
-    testCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
-    testCompile "com.squareup.okhttp3:mockwebserver:${MOCKWEBSERVER_VERSION}"
+    testImplementation project(":testutil")
+    testImplementation "com.google.truth:truth:${TRUTH_VERSION}"
+    testImplementation "junit:junit:${JUNIT_VERSION}"
+    testImplementation "org.mockito:mockito-core:${MOCKITO_VERSION}"
+    testImplementation "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
+    testImplementation "com.squareup.okhttp3:mockwebserver:${MOCKWEBSERVER_VERSION}"
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         minSdkVersion MIN_SDK_VERSION as int
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java
index 3a4d273ae..5756c6172 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java
@@ -1,11 +1,11 @@
 package com.bumptech.glide.integration.volley;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
 import com.bumptech.glide.load.model.GlideUrl;
-import com.bumptech.glide.module.GlideModule;
 import java.io.InputStream;
 
 /**
@@ -20,9 +20,10 @@
  * @deprecated Replaced with {@link VolleyLibraryGlideModule}.
  */
 @Deprecated
-public class VolleyGlideModule implements GlideModule {
+@SuppressWarnings("deprecation")
+public class VolleyGlideModule implements com.bumptech.glide.module.GlideModule {
   @Override
-  public void applyOptions(Context context, GlideBuilder builder) {
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
     // Do nothing.
   }
 
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyLibraryGlideModule.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyLibraryGlideModule.java
index 6fa56468c..514c62008 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyLibraryGlideModule.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyLibraryGlideModule.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.integration.volley;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.Registry;
 import com.bumptech.glide.annotation.GlideModule;
@@ -21,7 +22,8 @@
 @GlideModule
 public class VolleyLibraryGlideModule extends LibraryGlideModule {
   @Override
-  public void registerComponents(Context context, Glide glide, Registry registry) {
+  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry) {
     registry.replace(GlideUrl.class, InputStream.class, new VolleyUrlLoader.Factory(context));
   }
 }
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java
index 3a4e17415..3137fdcdb 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java
@@ -2,7 +2,6 @@
 
 import android.support.annotation.NonNull;
 import android.util.Log;
-import com.android.volley.AuthFailureError;
 import com.android.volley.NetworkResponse;
 import com.android.volley.Request;
 import com.android.volley.RequestQueue;
@@ -21,6 +20,8 @@
 /**
  * A DataFetcher backed by volley for fetching images via http.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public class VolleyStreamFetcher implements DataFetcher<InputStream> {
   private static final String TAG = "VolleyStreamFetcher";
   public static final VolleyRequestFactory DEFAULT_REQUEST_FACTORY = new VolleyRequestFactory() {
@@ -49,7 +50,8 @@ public VolleyStreamFetcher(RequestQueue requestQueue, GlideUrl url,
   }
 
   @Override
-  public void loadData(Priority priority, DataCallback<? super InputStream> callback) {
+  public void loadData(@NonNull Priority priority,
+      @NonNull DataCallback<? super InputStream> callback) {
     request = requestFactory.create(url.toStringUrl(), callback, glideToVolleyPriority(priority),
         url.getHeaders());
     requestQueue.add(request);
@@ -80,7 +82,7 @@ public DataSource getDataSource() {
     return DataSource.REMOTE;
   }
 
-  private static Request.Priority glideToVolleyPriority(Priority priority) {
+  private static Request.Priority glideToVolleyPriority(@NonNull Priority priority) {
     switch (priority) {
       case LOW:
         return Request.Priority.LOW;
@@ -97,6 +99,8 @@ public DataSource getDataSource() {
    * Default {@link com.android.volley.Request} implementation for Glide that receives errors and
    * results on volley's background thread.
    */
+  // Public API.
+  @SuppressWarnings("unused")
   public static class GlideRequest extends Request<byte[]> {
     private final DataCallback<? super InputStream> callback;
     private final Priority priority;
@@ -115,7 +119,7 @@ public GlideRequest(String url, DataCallback<? super InputStream> callback, Prio
     }
 
     @Override
-    public Map<String, String> getHeaders() throws AuthFailureError {
+    public Map<String, String> getHeaders() {
       return headers;
     }
 
@@ -129,13 +133,17 @@ protected VolleyError parseNetworkError(VolleyError volleyError) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
         Log.d(TAG, "Volley failed to retrieve response", volleyError);
       }
-      callback.onLoadFailed(volleyError);
+      if (!isCanceled()) {
+        callback.onLoadFailed(volleyError);
+      }
       return super.parseNetworkError(volleyError);
     }
 
     @Override
     protected Response<byte[]> parseNetworkResponse(NetworkResponse response) {
-      callback.onDataReady(new ByteArrayInputStream(response.data));
+      if (!isCanceled()) {
+        callback.onDataReady(new ByteArrayInputStream(response.data));
+      }
       return Response.success(response.data, HttpHeaderParser.parseCacheHeaders(response));
     }
 
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java
index 02c3c0921..a5ceda30a 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.integration.volley;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import com.android.volley.RequestQueue;
 import com.android.volley.toolbox.Volley;
 import com.bumptech.glide.load.Options;
@@ -18,29 +19,35 @@
   private final RequestQueue requestQueue;
   private final VolleyRequestFactory requestFactory;
 
+  // Public API.
+  @SuppressWarnings("unused")
   public VolleyUrlLoader(RequestQueue requestQueue) {
     this(requestQueue, VolleyStreamFetcher.DEFAULT_REQUEST_FACTORY);
   }
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public VolleyUrlLoader(RequestQueue requestQueue, VolleyRequestFactory requestFactory) {
     this.requestQueue = requestQueue;
     this.requestFactory = requestFactory;
   }
 
   @Override
-  public boolean handles(GlideUrl url) {
+  public boolean handles(@NonNull GlideUrl url) {
     return true;
   }
 
   @Override
-  public LoadData<InputStream> buildLoadData(GlideUrl url, int width, int height,
-      Options options) {
+  public LoadData<InputStream> buildLoadData(@NonNull GlideUrl url, int width, int height,
+      @NonNull Options options) {
     return new LoadData<>(url, new VolleyStreamFetcher(requestQueue, url, requestFactory));
   }
 
   /**
    * The default factory for {@link VolleyUrlLoader}s.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public static class Factory implements ModelLoaderFactory<GlideUrl, InputStream> {
     private static volatile RequestQueue internalQueue;
 
@@ -70,6 +77,7 @@ public Factory(RequestQueue requestQueue, VolleyRequestFactory requestFactory) {
       this.requestQueue = requestQueue;
     }
 
+    @NonNull
     @Override
     public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory factory) {
       return new VolleyUrlLoader(requestQueue, requestFactory);
diff --git a/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java
index b1271b9a2..740acc113 100644
--- a/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java
+++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java
@@ -51,8 +51,7 @@
 public class VolleyStreamFetcherServerTest {
   private static final String DEFAULT_PATH = "/fakepath";
 
-  @Mock VolleyRequestFactory requestFactory;
-  @Mock DataFetcher.DataCallback<InputStream> callback;
+  @Mock private DataFetcher.DataCallback<InputStream> callback;
 
   private MockWebServer mockWebServer;
   private RequestQueue requestQueue;
diff --git a/library/build.gradle b/library/build.gradle
index 92ffd8441..6f01832e2 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -1,62 +1,42 @@
 apply plugin: 'com.android.library'
-apply plugin: 'maven'
-apply plugin: 'findbugs'
-apply plugin: 'pmd'
-apply plugin: 'jacoco'
-apply plugin: 'com.github.kt3k.coveralls'
 
-findbugs {
-    toolVersion = FINDBUGS_VERSION
+if (!hasProperty('DISABLE_ERROR_PRONE')) {
+    apply plugin: "net.ltgt.errorprone"
 }
-jacoco {
-    toolVersion = JACOCO_VERSION
-}
-coveralls {
-    jacocoReportPath = 'build/reports/jacoco/jacocoTestReport/jacocoTestReport.xml'
+
+tasks.withType(JavaCompile) {
+    options.fork = true
 }
 
 dependencies {
-    compile project(':third_party:gif_decoder')
-    compile project(':third_party:disklrucache')
-    compile project(':annotation')
-    compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
-    provided "com.android.support:appcompat-v7:${SUPPORT_V7_VERSION}"
-    testCompile project(':testutil')
-    testCompile 'com.google.guava:guava-testlib:18.0'
-    testCompile "com.google.truth:truth:${TRUTH_VERSION}"
-    testCompile "junit:junit:${JUNIT_VERSION}"
-    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}"
-    testCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
-    testCompile "com.squareup.okhttp3:mockwebserver:${MOCKWEBSERVER_VERSION}"
-    testCompile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
-}
+    api project(':third_party:gif_decoder')
+    api project(':third_party:disklrucache')
+    api project(':annotation')
+    api "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
+    compileOnly "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}"
 
-android.testOptions.unitTests.all {
-    // configure max heap size of the test JVM
-    maxHeapSize = '2048m'
-    if (JavaVersion.current() <= JavaVersion.VERSION_1_7) {
-        // Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize=2048m; support was removed in 8.0
-        jvmArgs '-XX:MaxPermSize=2048m'
+    if (project.plugins.hasPlugin('net.ltgt.errorprone')) {
+        errorprone "com.google.errorprone:error_prone_core:${ERROR_PRONE_VERSION}"
     }
+
+    testImplementation "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}"
+    testImplementation project(':testutil')
+    testImplementation 'com.google.guava:guava-testlib:18.0'
+    testImplementation "com.google.truth:truth:${TRUTH_VERSION}"
+    testImplementation "junit:junit:${JUNIT_VERSION}"
+    testImplementation "org.mockito:mockito-core:${MOCKITO_VERSION}"
+    testImplementation "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
+    testImplementation "com.squareup.okhttp3:mockwebserver:${MOCKWEBSERVER_VERSION}"
+    testImplementation "com.android.support:support-v4:${ANDROID_SUPPORT_VERSION}"
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
-
         versionName VERSION_NAME as String
-
-        consumerProguardFiles 'proguard-rules.txt'
-    }
-
-    buildTypes {
-        debug {
-            testCoverageEnabled = true
-        }
     }
 
     compileOptions {
@@ -65,91 +45,18 @@ android {
     }
 }
 
-afterEvaluate {
-    if (tasks.findByName("assembleDebug") == null) {
-        return
-    }
-    task findbugs(type: FindBugs, dependsOn: assembleDebug) {
-
-        description 'Run findbugs'
-        group 'verification'
-
-        classes = fileTree('build/intermediates/classes/debug/')
-        source = fileTree('src/main/java')
-        classpath = project.configurations.compile
-
-        effort = 'max'
-
-        excludeFilter = file("findbugs-exclude.xml")
-
-        reports {
-            xml.enabled = false
-            html.enabled = true
-        }
-    }
-
-    check.dependsOn('findbugs')
-
-    pmd {
-        toolVersion '5.4.0'
-    }
-
-    task pmd(type: Pmd) {
-        targetJdk = TargetJdk.VERSION_1_7
-
-        description 'Run pmd'
-        group 'verification'
-
-        // If ruleSets is not empty, it seems to contain some
-        // defaults which override rules in the ruleset file...
-        ruleSets = []
-        ruleSetFiles = files('pmd-ruleset.xml')
-        source = fileTree('src/main/java')
-
-        reports {
-            xml.enabled = false
-            html.enabled = true
-        }
-    }
+check.dependsOn(':library:findbugs:findbugs')
+check.dependsOn(':library:pmd:pmd')
+check.dependsOn(':library:test:check')
 
-    check.dependsOn('pmd')
-
-    task jacocoTestReport(type: JacocoReport, dependsOn: testDebugUnitTest) {
-        def coverageSourceDirs = ['src/main/java']
-        group = "Reporting"
-        description = "Generate Jacoco coverage reports"
-
-        classDirectories = fileTree(
-                dir: 'build/intermediates/classes/debug',
-                excludes: ['**/R.class',
-                           '**/R$*.class',
-                           '**/BuildConfig.*',
-                           '**/Manifest*.*',
-                           '**/BitmapRequestBuilder.class',
-                           '**/DrawableRequestBuilder.class',
-                           '**/GifRequestBuilder.class',]
-        )
-
-        additionalSourceDirs = files(coverageSourceDirs)
-        sourceDirectories = files(coverageSourceDirs)
-        executionData = files('build/jacoco/testDebug.exec')
-
-        reports {
-            xml.enabled = true
-            html.enabled = true
-        }
-    }
+// Used in pmd and findbugs subprojects.
+@SuppressWarnings("GroovyUnusedDeclaration")
+def classPathForQuality() {
+    return files(
+            android.bootClasspath,
+            project.configurations.compile,
+            project.android.libraryVariants.collect { it.javaCompile.classpath }
+    )
 }
 
 apply from: "${rootProject.projectDir}/scripts/upload.gradle"
-// exclude <dependency> tag for android support-v4 library from :glide's pom
-// this will ensure that this warning will not prevent the build from completing:
-// Module 'com.github.bumptech.glide:glide:4.0.0-SNAPSHOT' depends on one or more Android Libraries
-// but is a jar. Most users will need to override support-v4 version anyway if a newer version is
-// available
-// TODO make support-v4 a <scope>runtime</scope> dependency in pom.xml
-afterEvaluate {
-    uploadArchives.repositories.mavenDeployer.pom.whenConfigured { p ->
-        p.dependencies = p.dependencies.findAll { dep -> dep.artifactId != "support-v4" }
-    }
-}
diff --git a/library/findbugs-exclude.xml b/library/findbugs-exclude.xml
index e9defbbe7..f27b2c382 100644
--- a/library/findbugs-exclude.xml
+++ b/library/findbugs-exclude.xml
@@ -38,8 +38,20 @@
 
     <!-- We make a best effort attempt to acquire the cpu count from a fixed path -->
     <Match>
-      <Class name="com.bumptech.glide.load.engine.executor.GlideExecutor" />
+      <Class name="com.bumptech.glide.load.engine.executor.RuntimeCompat" />
       <Bug pattern="DMI_HARDCODED_ABSOLUTE_FILENAME" />
     </Match>
 
+    <!-- Re-using the byte array saves allocations, there's no serious risk of mutations. -->
+    <Match>
+      <Class name="com.bumptech.glide.util.FixedPreloadSizeProvider" />
+      <Bug pattern="EI_EXPOSE_REP" />
+    </Match>
+
+    <!-- We just cache the value of hashcode, no need to also override equals. -->
+    <Match>
+      <Class name="com.bumptech.glide.util.CachedHashCodeArrayMap" />
+      <Bug pattern="EQ_DOESNT_OVERRIDE_EQUALS" />
+    </Match>
+
 </FindBugsFilter>
diff --git a/library/findbugs/build.gradle b/library/findbugs/build.gradle
new file mode 100644
index 000000000..a2e5b3f2a
--- /dev/null
+++ b/library/findbugs/build.gradle
@@ -0,0 +1,31 @@
+apply plugin: 'findbugs'
+
+findbugs {
+    toolVersion FINDBUGS_VERSION
+}
+
+def library = project(':library')
+
+tasks.create('findbugs', FindBugs) {
+    dependsOn library.tasks.compileDebugJavaWithJavac
+
+    description 'Run findbugs'
+    group 'verification'
+
+    classes = fileTree(library.tasks.compileDebugJavaWithJavac.destinationDir)
+    source library.android.sourceSets.main.java.srcDirs
+    classpath = files()
+    doFirst {
+        classpath += library.classPathForQuality()
+    }
+    effort = 'max'
+    excludeFilter = file("${library.projectDir}/findbugs-exclude.xml")
+
+    // Failures are caught and printed by the violations plugin.
+    ignoreFailures = true
+
+    reports {
+        xml.enabled = true
+        html.enabled = false
+    }
+}
diff --git a/library/lint.xml b/library/lint.xml
index 869eb6598..d904731d9 100644
--- a/library/lint.xml
+++ b/library/lint.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <lint>
     <issue id="AllowBackup" severity="ignore"/>
-    <!-- TODO: Fix this after RequestManager#get(View) uses official APIs -->
-    <issue id="RestrictedApi" severity="ignore"/>
+    <issue id="ExifInterface" severity="ignore"/>
+    <issue id="GradleDependency" severity="ignore"/>
 </lint>
diff --git a/library/pmd-ruleset.xml b/library/pmd-ruleset.xml
index 76249e191..8297a5c09 100644
--- a/library/pmd-ruleset.xml
+++ b/library/pmd-ruleset.xml
@@ -3,56 +3,168 @@
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 http://pmd.sourceforge.net/ruleset_2_0_0.xsd">
 
-    <description>This ruleset was created from PMD.rul</description>
+    <description>Check for flaws in Glide's codebase.</description>
 
-    <rule ref="rulesets/java/basic.xml">
+    <rule ref="category/java/errorprone.xml">
         <exclude name="AvoidBranchingStatementAsLastInLoop"/>
+        <!-- Not using beans. -->
+        <exclude name="BeanMembersShouldSerialize" />
+        <!-- wat -->
+        <exclude name="AvoidFieldNameMatchingTypeName" />
+        <!-- This is identifying trivial cases that are clearly correct. -->
+        <exclude name="DataflowAnomalyAnalysis" />
+        <!-- Used regularly for object pooling. -->
+        <exclude name="NullAssignment" />
+        <!-- This can make the code easier to read and avoid duplicated logic in some cases. -->
+        <exclude name="AssignmentInOperand" />
+        <!-- I don't think this is confusing. -->
+        <exclude name="AvoidFieldNameMatchingMethodName" />
+        <!-- There are enough cases where this makes sense (typically related to logic around the number of items in a collection) that a blanket ban doesn't seem like a good idea. -->
+        <exclude name="AvoidLiteralsInIfCondition" />
+        <!-- It's clear that this is bad, but we have a number of cases where it makes sense and a blanket ban is irritating. -->
+        <exclude name="AvoidCatchingThrowable" />
     </rule>
-    <rule ref="rulesets/java/braces.xml"/>
-    <rule ref="rulesets/java/strings.xml">
-        <!-- TODO: This warns about annotations, apparently fixed in a later version. -->
-        <exclude name="AvoidDuplicateLiterals"/>
+    <rule ref="category/java/errorprone.xml/AvoidDuplicateLiterals">
+      <properties>
+        <property name="skipAnnotations" value="true" />
+      </properties>
+    </rule>
+    <rule ref="category/java/codestyle.xml">
+      <!-- Abstract classes don't need to have Abstract in the name -->
+      <exclude name="AbstractNaming" />
+      <!-- Who cares? -->
+      <exclude name="AtLeastOneConstructor" />
+      <!-- Don't need to annotate package private methods. -->
+      <exclude name="DefaultPackage" />
+      <exclude name="CommentDefaultAccessModifier" />
+      <!-- Optionally implemented default empty methods are fine. -->
+      <exclude name="EmptyMethodInAbstractClassShouldBeAbstract" />
+      <!-- Why make generics less clear by using shorter names? -->
+      <exclude name="GenericsNaming" />
+      <!-- No need to enforce final if it's not necessary. -->
+      <exclude name="MethodArgumentCouldBeFinal" />
+      <exclude name="LocalVariableCouldBeFinal" />
+      <!-- This isn't always the easiest way to read a method. -->
+      <exclude name="OnlyOneReturn" />
+      <!-- Obfuscated code is best code? -->
+      <exclude name="LongVariable" />
+      <!-- This is not always true. -->
+      <exclude name="ShortClassName" />
+      <!-- A good idea but we have tons of violations. FIXME. -->
+      <exclude name="ShortMethodName" />
+      <exclude name="ShortVariable" />
+      <!-- We don't use in and out to mean modified or not modified by the method, it's useful to match framework methods. -->
+      <exclude name="AvoidPrefixingMethodParameters" />
+      <!-- No idea what this is supposed to accomplish. -->
+      <exclude name="AvoidFinalLocalVariable" />
+      <!-- These are often useful for clarity and explicitly suggested by Google's code style. -->
+      <exclude name="UselessParentheses" />
+      <!-- Theoretically this might be reasonable but the number of imports probably varies from class to class and this doesn't seem worth the overhead to maintain. -->
+      <exclude name="TooManyStaticImports" />
+      <!-- Lots of existing violations, not clear that the overhead is worthwhile though there are some cases where we definitely need to call super. FIXME. -->
+      <exclude name="CallSuperInConstructor" />
+      <!-- This is a reasonable idea, but in practice often the != null case is the expected case and it makes sense for it to come first. -->
+      <exclude name="ConfusingTernary" />
+    </rule>
+    <rule ref="category/java/performance.xml" >
+      <!-- Android may not behave the same as java VMs, using short can be clearer when working with binary data. -->
+      <exclude name="AvoidUsingShortType" />
+      <!-- The suggsted alternatives are not available until Glide's minsdk level is 26+ -->
+      <exclude name="AvoidFileStream" />
+    </rule>
+    <rule ref="category/java/bestpractices.xml" >
+      <!-- Catches any method, test or not, that has the name "tearDown". -->
+      <exclude name="JUnit4TestShouldUseAfterAnnotation" />
+      <!-- This is a good idea, but in practice it's often somewhat clearer than defining a temporary variable and we do it all over the place. -->
+      <exclude name="AvoidReassigningParameters" />
+      <!-- This ignores imports used by javadocs and is worse than the existing checkstyle check. -->
+      <exclude name="UnusedImports" />
+    </rule>
+    <rule ref="category/java/bestpractices.xml/OneDeclarationPerLine">
+      <properties>
+        <property name="strictMode" value="true" />
+        <!-- Allow `for (int i = 0, size = list.size(); i < size; i++) {`
+             Somewhat clearer to set size along with the index. -->
+        <property name="violationSuppressXPath"
+                  value="self::LocalVariableDeclaration
+                           [parent::ForInit]
+                           [Type/PrimitiveType[@Image = 'int']
+                             and VariableDeclarator/VariableDeclaratorId[@Image='i']
+                             and VariableDeclarator/VariableDeclaratorId[@Image='size']
+                           ]
+                        " />
+      </properties>
+    </rule>
+    <rule ref="category/java/bestpractices.xml/AccessorMethodGeneration"
+      message="Avoid autogenerated methods to access private fields and methods of inner / outer classes.
+                       Use @Synthetic to flag members made more visible than necessary to prevent accessors.">
+      <properties>
+        <!-- Ignore references to `private static final * * = <literal>`
+             Suppress via XPath: current node (access that generates the accessor) is .
+             Check if there exists a FieldDeclaration (private static final)
+             which has a VariableInitializer with a Literal
+             and the name (@Image) of the declaration is the same as the accessed member.
+             TODO calculated constants are false positive https://github.com/pmd/pmd/issues/808
+        -->
+        <property name="violationSuppressXPath" value="
+                .[@Image =
+                    //FieldDeclaration[@Private = 'true' and @Static='true' and @Final='true']
+                    /VariableDeclarator[
+                        VariableInitializer/Expression/PrimaryExpression[not(PrimarySuffix)]/PrimaryPrefix/Literal
+                    ]/VariableDeclaratorId/@Image
+                 ]" />
+      </properties>
     </rule>
-    <rule ref="rulesets/java/unusedcode.xml"/>
 
-    <rule ref="rulesets/java/design.xml">
-        <exclude name="ConfusingTernary"/>
-        <exclude name="EmptyMethodInAbstractClassShouldBeAbstract"/>
-        <exclude name="AvoidSynchronizedAtMethodLevel"/>
+    <rule ref="category/java/design.xml">
+        <exclude name="GodClass" />
+        <!-- No idea how you reasonably define this. -->
+        <exclude name="ExcessiveImports" />
+        <exclude name="CouplingBetweenObjects" />
+        <exclude name="TooManyMethods" />
+        <exclude name="LawOfDemeter" />
+        <exclude name="NcssCount" />
+        <exclude name="ExcessiveParameterList" />
+        <exclude name="TooManyFields" />
+        <!-- We don't define any packages to use with this rule. -->
+        <exclude name="LoosePackageCoupling" />
+        <!-- Throwing other types of exceptions doesn't seem to add much to clarify. -->
+        <exclude name="AvoidThrowingRawExceptionTypes" />
+        <exclude name="AvoidThrowingNullPointerException" />
+        <!-- TODO: explore these further. -->
+        <exclude name="CyclomaticComplexity" />
+        <exclude name="NPathComplexity" />
+        <exclude name="ExcessiveMethodLength" />
+        <exclude name="ExcessiveClassLength" />
+        <exclude name="ExcessivePublicCount" />
+        <!-- This is redundant, also caught with AvoidCatchingNPEs. -->
+        <exclude name="AvoidCatchingGenericException" />
+    </rule>
 
+    <rule ref="category/java/multithreading.xml">
+        <exclude name="AvoidSynchronizedAtMethodLevel"/>
         <!-- This check breaks on double checked locking which is safe in Java 6/7 -->
         <exclude name="NonThreadSafeSingleton"/>
-
-        <!-- TODO: Fix these -->
-        <exclude name="AvoidReassigningParameters"/>
-        <exclude name="GodClass"/>
+        <!-- Used frequently in the singleton pattern. -->
+        <exclude name="AvoidUsingVolatile" />
+        <!-- No reason to do this by default. -->
+        <exclude name="UseConcurrentHashMap" />
+        <exclude name="DoNotUseThreads" />
     </rule>
 
-    <rule ref="rulesets/java/empty.xml/EmptyCatchBlock" message="Commented blocks are ok">
+    <rule ref="category/java/errorprone.xml/EmptyCatchBlock" message="Commented blocks are ok">
         <properties>
             <property name="allowCommentedBlocks" value="true"/>
         </properties>
     </rule>
 
 
-    <!--Overrides default check to avoid violation when @Synthetic annotation is present-->
-    <rule ref="rulesets/java/design.xml/UncommentedEmptyConstructor"
-          message="Document empty constructor">
-
-        <properties>
-            <property name="xpath">
-                <value>
-                    <![CDATA[
-//ConstructorDeclaration[@Private='false'][count(BlockStatement) = 0 and
-($ignoreExplicitConstructorInvocation = 'true' or not(ExplicitConstructorInvocation)) and @containsComment = 'false'
- and not(../Annotation/MarkerAnnotation/Name[@Image='Synthetic'])]
- ]]>
-                </value>
-            </property>
-
-        </properties>
-
+  <!-- Configures check to avoid violation when @Synthetic annotation is present. -->
+    <rule ref="category/java/documentation.xml/UncommentedEmptyConstructor">
+      <properties>
+        <property name="violationSuppressXPath"
+          value="../Annotation/MarkerAnnotation/Name[@Image='Synthetic']" />
+      </properties>
     </rule>
 
-
 </ruleset>
diff --git a/library/pmd/build.gradle b/library/pmd/build.gradle
new file mode 100644
index 000000000..d02349082
--- /dev/null
+++ b/library/pmd/build.gradle
@@ -0,0 +1,39 @@
+apply plugin: 'pmd'
+
+def library = project(':library')
+
+pmd {
+    toolVersion PMD_VERSION
+}
+
+tasks.create('pmd', Pmd) {
+    dependsOn library.tasks.compileDebugJavaWithJavac
+    targetJdk = TargetJdk.VERSION_1_7
+
+    description 'Run pmd'
+    group 'verification'
+
+    // If ruleSets is not empty, it seems to contain some
+    // defaults which override rules in the ruleset file...
+    ruleSets = []
+    ruleSetFiles = files("${library.projectDir}/pmd-ruleset.xml")
+    source library.android.sourceSets.main.java.srcDirs
+    classpath = files()
+    classpath += files(library.tasks.compileDebugJavaWithJavac.destinationDir)
+    doFirst {
+        classpath += library.classPathForQuality()
+    }
+
+    //TODO enable this once new Gradle containing this flag is out
+    //see https://github.com/gradle/gradle/pull/3125#issuecomment-352442432
+    //incrementalAnalysis = true
+
+    // Failures are caught and printed by the violations plugin.
+    ignoreFailures = true
+
+    reports {
+        xml.enabled = true
+        html.enabled = false
+    }
+}
+
diff --git a/library/proguard-rules.txt b/library/proguard-rules.txt
index 078afb542..39e209882 100644
--- a/library/proguard-rules.txt
+++ b/library/proguard-rules.txt
@@ -1,6 +1,9 @@
 -keep public class * implements com.bumptech.glide.module.GlideModule
--keep public class * extends com.bumptech.glide.GeneratedAppGlideModule
--keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {
-    **[] $VALUES;
-    public *;
-}
\ No newline at end of file
+-keep public class * extends com.bumptech.glide.module.AppGlideModule
+-keep public enum com.bumptech.glide.load.ImageHeaderParser$** {
+  **[] $VALUES;
+  public *;
+}
+
+# Uncomment for DexGuard only
+#-keepresourcexmlelements manifest/application/meta-data@value=GlideModule
\ No newline at end of file
diff --git a/library/src/main/AndroidManifest.xml b/library/src/main/AndroidManifest.xml
index 06f5c692a..705db20aa 100644
--- a/library/src/main/AndroidManifest.xml
+++ b/library/src/main/AndroidManifest.xml
@@ -1,6 +1,4 @@
 <?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-          package="com.bumptech.glide">
-
-    <application/>
+<manifest package="com.bumptech.glide">
+  <application/>
 </manifest>
diff --git a/library/src/main/java/com/bumptech/glide/GeneratedAppGlideModule.java b/library/src/main/java/com/bumptech/glide/GeneratedAppGlideModule.java
index 853990ec2..5f480de80 100644
--- a/library/src/main/java/com/bumptech/glide/GeneratedAppGlideModule.java
+++ b/library/src/main/java/com/bumptech/glide/GeneratedAppGlideModule.java
@@ -16,7 +16,6 @@
   /**
    * This method can be removed when manifest parsing is no longer supported.
    */
-  @Deprecated
   @NonNull
   abstract Set<Class<?>> getExcludedModuleClasses();
 
diff --git a/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java b/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java
index 1fe9588f5..a630b4f86 100644
--- a/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java
+++ b/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.request.transition.TransitionFactory;
 import com.bumptech.glide.request.transition.ViewPropertyTransition;
 
@@ -9,7 +10,8 @@
  *
  * @param <TranscodeType> The type of the resource that will be displayed.
  */
-@SuppressWarnings("PMD.UseUtilityClass")
+// Public API.
+@SuppressWarnings({"PMD.UseUtilityClass", "unused"})
 public final class GenericTransitionOptions<TranscodeType> extends
     TransitionOptions<GenericTransitionOptions<TranscodeType>, TranscodeType> {
   /**
@@ -17,6 +19,7 @@
    *
    * @see GenericTransitionOptions#dontTransition()
    */
+  @NonNull
   public static <TranscodeType> GenericTransitionOptions<TranscodeType> withNoTransition() {
     return new GenericTransitionOptions<TranscodeType>().dontTransition();
   }
@@ -26,6 +29,7 @@
    *
    * @see GenericTransitionOptions#transition(int)
    */
+  @NonNull
   public static <TranscodeType> GenericTransitionOptions<TranscodeType> with(
       int viewAnimationId) {
     return new GenericTransitionOptions<TranscodeType>().transition(viewAnimationId);
@@ -36,8 +40,9 @@
    *
    * @see GenericTransitionOptions#transition(ViewPropertyTransition.Animator)
    */
+  @NonNull
   public static <TranscodeType> GenericTransitionOptions<TranscodeType> with(
-      ViewPropertyTransition.Animator animator) {
+      @NonNull ViewPropertyTransition.Animator animator) {
     return new GenericTransitionOptions<TranscodeType>().transition(animator);
   }
 
@@ -46,8 +51,9 @@
    *
    * @see GenericTransitionOptions#transition(TransitionFactory)
    */
+  @NonNull
   public static <TranscodeType> GenericTransitionOptions<TranscodeType> with(
-      TransitionFactory<? super TranscodeType> transitionFactory) {
+      @NonNull TransitionFactory<? super TranscodeType> transitionFactory) {
     return new GenericTransitionOptions<TranscodeType>().transition(transitionFactory);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/Glide.java b/library/src/main/java/com/bumptech/glide/Glide.java
index f8e9cfd80..89b950cd8 100644
--- a/library/src/main/java/com/bumptech/glide/Glide.java
+++ b/library/src/main/java/com/bumptech/glide/Glide.java
@@ -1,16 +1,19 @@
 package com.bumptech.glide;
 
-import android.annotation.TargetApi;
 import android.app.Activity;
 import android.content.ComponentCallbacks2;
+import android.content.ContentResolver;
 import android.content.Context;
+import android.content.res.AssetFileDescriptor;
 import android.content.res.Configuration;
 import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
 import android.net.Uri;
 import android.os.Build;
 import android.os.ParcelFileDescriptor;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.support.annotation.VisibleForTesting;
 import android.support.v4.app.Fragment;
@@ -19,6 +22,8 @@
 import android.view.View;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.data.InputStreamRewinder;
 import com.bumptech.glide.load.engine.Engine;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
@@ -51,9 +56,14 @@
 import com.bumptech.glide.load.resource.bitmap.ByteBufferBitmapDecoder;
 import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;
 import com.bumptech.glide.load.resource.bitmap.Downsampler;
+import com.bumptech.glide.load.resource.bitmap.ExifInterfaceImageHeaderParser;
+import com.bumptech.glide.load.resource.bitmap.ResourceBitmapDecoder;
 import com.bumptech.glide.load.resource.bitmap.StreamBitmapDecoder;
-import com.bumptech.glide.load.resource.bitmap.VideoBitmapDecoder;
+import com.bumptech.glide.load.resource.bitmap.UnitBitmapDecoder;
+import com.bumptech.glide.load.resource.bitmap.VideoDecoder;
 import com.bumptech.glide.load.resource.bytes.ByteBufferRewinder;
+import com.bumptech.glide.load.resource.drawable.ResourceDrawableDecoder;
+import com.bumptech.glide.load.resource.drawable.UnitDrawableDecoder;
 import com.bumptech.glide.load.resource.file.FileDecoder;
 import com.bumptech.glide.load.resource.gif.ByteBufferGifDecoder;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
@@ -62,11 +72,12 @@
 import com.bumptech.glide.load.resource.gif.StreamGifDecoder;
 import com.bumptech.glide.load.resource.transcode.BitmapBytesTranscoder;
 import com.bumptech.glide.load.resource.transcode.BitmapDrawableTranscoder;
+import com.bumptech.glide.load.resource.transcode.DrawableBytesTranscoder;
 import com.bumptech.glide.load.resource.transcode.GifDrawableBytesTranscoder;
 import com.bumptech.glide.manager.ConnectivityMonitorFactory;
 import com.bumptech.glide.manager.RequestManagerRetriever;
-import com.bumptech.glide.module.GlideModule;
 import com.bumptech.glide.module.ManifestParser;
+import com.bumptech.glide.request.RequestListener;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.ImageViewTargetFactory;
 import com.bumptech.glide.request.target.Target;
@@ -74,6 +85,7 @@
 import com.bumptech.glide.util.Util;
 import java.io.File;
 import java.io.InputStream;
+import java.lang.reflect.InvocationTargetException;
 import java.net.URL;
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
@@ -88,7 +100,6 @@
  * {@link RequestBuilder} and maintaining an {@link Engine}, {@link BitmapPool},
  * {@link com.bumptech.glide.load.engine.cache.DiskCache} and {@link MemoryCache}.
  */
-@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
 public class Glide implements ComponentCallbacks2 {
   private static final String DEFAULT_DISK_CACHE_DIR = "image_manager_disk_cache";
   private static final String TAG = "Glide";
@@ -115,7 +126,7 @@
    * @see #getPhotoCacheDir(android.content.Context, String)
    */
   @Nullable
-  public static File getPhotoCacheDir(Context context) {
+  public static File getPhotoCacheDir(@NonNull Context context) {
     return getPhotoCacheDir(context, DEFAULT_DISK_CACHE_DIR);
   }
 
@@ -128,7 +139,7 @@ public static File getPhotoCacheDir(Context context) {
    * @see #getPhotoCacheDir(android.content.Context)
    */
   @Nullable
-  public static File getPhotoCacheDir(Context context, String cacheName) {
+  public static File getPhotoCacheDir(@NonNull Context context, @NonNull String cacheName) {
     File cacheDir = context.getCacheDir();
     if (cacheDir != null) {
       File result = new File(cacheDir, cacheName);
@@ -149,7 +160,8 @@ public static File getPhotoCacheDir(Context context, String cacheName) {
    *
    * @return the singleton
    */
-  public static Glide get(Context context) {
+  @NonNull
+  public static Glide get(@NonNull Context context) {
     if (glide == null) {
       synchronized (Glide.class) {
         if (glide == null) {
@@ -161,7 +173,7 @@ public static Glide get(Context context) {
     return glide;
   }
 
-  private static void checkAndInitializeGlide(Context context) {
+  private static void checkAndInitializeGlide(@NonNull Context context) {
     // In the thread running initGlide(), one or more classes may call Glide.get(context).
     // Without this check, those calls could trigger infinite recursion.
     if (isInitializing) {
@@ -173,22 +185,49 @@ private static void checkAndInitializeGlide(Context context) {
     isInitializing = false;
   }
 
+  /**
+   * @deprecated Use {@link #init(Context, GlideBuilder)} to get a singleton compatible with
+   * Glide's generated API.
+   *
+   * <p>This method will be removed in a future version of Glide.
+   */
   @VisibleForTesting
+  @Deprecated
   public static synchronized void init(Glide glide) {
+    if (Glide.glide != null) {
+      tearDown();
+    }
     Glide.glide = glide;
   }
 
+  @VisibleForTesting
+  public static synchronized void init(@NonNull Context context, @NonNull GlideBuilder builder) {
+    if (Glide.glide != null) {
+      tearDown();
+    }
+    initializeGlide(context, builder);
+  }
+
   @VisibleForTesting
   public static synchronized void tearDown() {
+    if (glide != null) {
+      glide.getContext()
+          .getApplicationContext()
+          .unregisterComponentCallbacks(glide);
+      glide.engine.shutdown();
+    }
     glide = null;
   }
 
+  private static void initializeGlide(@NonNull Context context) {
+    initializeGlide(context, new GlideBuilder());
+  }
+
   @SuppressWarnings("deprecation")
-  private static void initializeGlide(Context context) {
+  private static void initializeGlide(@NonNull Context context, @NonNull GlideBuilder builder) {
     Context applicationContext = context.getApplicationContext();
-
     GeneratedAppGlideModule annotationGeneratedModule = getAnnotationGeneratedGlideModules();
-    List<GlideModule> manifestModules = Collections.emptyList();
+    List<com.bumptech.glide.module.GlideModule> manifestModules = Collections.emptyList();
     if (annotationGeneratedModule == null || annotationGeneratedModule.isManifestParsingEnabled()) {
       manifestModules = new ManifestParser(applicationContext).parse();
     }
@@ -197,8 +236,9 @@ private static void initializeGlide(Context context) {
         && !annotationGeneratedModule.getExcludedModuleClasses().isEmpty()) {
       Set<Class<?>> excludedModuleClasses =
           annotationGeneratedModule.getExcludedModuleClasses();
-      for (Iterator<GlideModule> iterator = manifestModules.iterator(); iterator.hasNext();) {
-        GlideModule current = iterator.next();
+      Iterator<com.bumptech.glide.module.GlideModule> iterator = manifestModules.iterator();
+      while (iterator.hasNext()) {
+        com.bumptech.glide.module.GlideModule current = iterator.next();
         if (!excludedModuleClasses.contains(current.getClass())) {
           continue;
         }
@@ -210,7 +250,7 @@ private static void initializeGlide(Context context) {
     }
 
     if (Log.isLoggable(TAG, Log.DEBUG)) {
-      for (GlideModule glideModule : manifestModules) {
+      for (com.bumptech.glide.module.GlideModule glideModule : manifestModules) {
         Log.d(TAG, "Discovered GlideModule from manifest: " + glideModule.getClass());
       }
     }
@@ -218,22 +258,21 @@ private static void initializeGlide(Context context) {
     RequestManagerRetriever.RequestManagerFactory factory =
         annotationGeneratedModule != null
             ? annotationGeneratedModule.getRequestManagerFactory() : null;
-    GlideBuilder builder = new GlideBuilder()
-        .setRequestManagerFactory(factory);
-    for (GlideModule module : manifestModules) {
+    builder.setRequestManagerFactory(factory);
+    for (com.bumptech.glide.module.GlideModule module : manifestModules) {
       module.applyOptions(applicationContext, builder);
     }
     if (annotationGeneratedModule != null) {
       annotationGeneratedModule.applyOptions(applicationContext, builder);
     }
     Glide glide = builder.build(applicationContext);
-    for (GlideModule module : manifestModules) {
+    for (com.bumptech.glide.module.GlideModule module : manifestModules) {
       module.registerComponents(applicationContext, glide, glide.registry);
     }
     if (annotationGeneratedModule != null) {
       annotationGeneratedModule.registerComponents(applicationContext, glide, glide.registry);
     }
-    context.getApplicationContext().registerComponentCallbacks(glide);
+    applicationContext.registerComponentCallbacks(glide);
     Glide.glide = glide;
   }
 
@@ -245,39 +284,45 @@ private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules() {
       Class<GeneratedAppGlideModule> clazz =
           (Class<GeneratedAppGlideModule>)
               Class.forName("com.bumptech.glide.GeneratedAppGlideModuleImpl");
-      result = clazz.newInstance();
+      result = clazz.getDeclaredConstructor().newInstance();
     } catch (ClassNotFoundException e) {
       if (Log.isLoggable(TAG, Log.WARN)) {
         Log.w(TAG, "Failed to find GeneratedAppGlideModule. You should include an"
-            + " annotationProcessor compile dependency on com.github.bumptech.glide:glide:compiler"
+            + " annotationProcessor compile dependency on com.github.bumptech.glide:compiler"
             + " in your application and a @GlideModule annotated AppGlideModule implementation or"
             + " LibraryGlideModules will be silently ignored");
       }
+    // These exceptions can't be squashed across all versions of Android.
     } catch (InstantiationException e) {
-      throw new IllegalStateException("GeneratedAppGlideModuleImpl is implemented incorrectly."
-          + " If you've manually implemented this class, remove your implementation. The Annotation"
-          + " processor will generate a correct implementation.", e);
-      // These exceptions can't be squashed across all versions of Android.
+      throwIncorrectGlideModule(e);
     } catch (IllegalAccessException e) {
-      throw new IllegalStateException("GeneratedAppGlideModuleImpl is implemented incorrectly."
-          + " If you've manually implemented this class, remove your implementation. The Annotation"
-          + " processor will generate a correct implementation.", e);
+      throwIncorrectGlideModule(e);
+    } catch (NoSuchMethodException e) {
+      throwIncorrectGlideModule(e);
+    } catch (InvocationTargetException e) {
+      throwIncorrectGlideModule(e);
     }
     return result;
   }
 
-  @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+  private static void throwIncorrectGlideModule(Exception e) {
+    throw new IllegalStateException("GeneratedAppGlideModuleImpl is implemented incorrectly."
+        + " If you've manually implemented this class, remove your implementation. The Annotation"
+        + " processor will generate a correct implementation.", e);
+  }
+
   Glide(
-      Context context,
-      Engine engine,
-      MemoryCache memoryCache,
-      BitmapPool bitmapPool,
-      ArrayPool arrayPool,
-      RequestManagerRetriever requestManagerRetriever,
-      ConnectivityMonitorFactory connectivityMonitorFactory,
+      @NonNull Context context,
+      @NonNull Engine engine,
+      @NonNull MemoryCache memoryCache,
+      @NonNull BitmapPool bitmapPool,
+      @NonNull ArrayPool arrayPool,
+      @NonNull RequestManagerRetriever requestManagerRetriever,
+      @NonNull ConnectivityMonitorFactory connectivityMonitorFactory,
       int logLevel,
-      RequestOptions defaultRequestOptions,
-      Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions) {
+      @NonNull RequestOptions defaultRequestOptions,
+      @NonNull Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions,
+      @NonNull List<RequestListener<Object>> defaultRequestListeners) {
     this.engine = engine;
     this.bitmapPool = bitmapPool;
     this.arrayPool = arrayPool;
@@ -291,93 +336,193 @@ private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules() {
     final Resources resources = context.getResources();
 
     registry = new Registry();
+    // Right now we're only using this parser for HEIF images, which are only supported on OMR1+.
+    // If we need this for other file types, we should consider removing this restriction.
+    // Note that order here matters. We want to check the ExifInterface parser first for orientation
+    // and then fall back to DefaultImageHeaderParser for other fields.
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O_MR1) {
+      registry.register(new ExifInterfaceImageHeaderParser());
+    }
     registry.register(new DefaultImageHeaderParser());
 
-    Downsampler downsampler = new Downsampler(registry.getImageHeaderParsers(),
-        resources.getDisplayMetrics(), bitmapPool, arrayPool);
+    List<ImageHeaderParser> imageHeaderParsers = registry.getImageHeaderParsers();
+    Downsampler downsampler =
+        new Downsampler(
+            imageHeaderParsers,
+            resources.getDisplayMetrics(),
+            bitmapPool,
+            arrayPool);
     ByteBufferGifDecoder byteBufferGifDecoder =
-        new ByteBufferGifDecoder(context, registry.getImageHeaderParsers(), bitmapPool, arrayPool);
-
-    registry.register(ByteBuffer.class, new ByteBufferEncoder())
-        .register(InputStream.class, new StreamEncoder(arrayPool))
+        new ByteBufferGifDecoder(context, imageHeaderParsers, bitmapPool, arrayPool);
+    ResourceDecoder<ParcelFileDescriptor, Bitmap> parcelFileDescriptorVideoDecoder =
+        VideoDecoder.parcel(bitmapPool);
+    ByteBufferBitmapDecoder byteBufferBitmapDecoder = new ByteBufferBitmapDecoder(downsampler);
+    StreamBitmapDecoder streamBitmapDecoder = new StreamBitmapDecoder(downsampler, arrayPool);
+    ResourceDrawableDecoder resourceDrawableDecoder =
+        new ResourceDrawableDecoder(context);
+    ResourceLoader.StreamFactory resourceLoaderStreamFactory =
+        new ResourceLoader.StreamFactory(resources);
+    ResourceLoader.UriFactory resourceLoaderUriFactory =
+        new ResourceLoader.UriFactory(resources);
+    ResourceLoader.FileDescriptorFactory resourceLoaderFileDescriptorFactory =
+        new ResourceLoader.FileDescriptorFactory(resources);
+    ResourceLoader.AssetFileDescriptorFactory resourceLoaderAssetFileDescriptorFactory =
+        new ResourceLoader.AssetFileDescriptorFactory(resources);
+    BitmapEncoder bitmapEncoder = new BitmapEncoder(arrayPool);
+
+    BitmapBytesTranscoder bitmapBytesTranscoder = new BitmapBytesTranscoder();
+    GifDrawableBytesTranscoder gifDrawableBytesTranscoder = new GifDrawableBytesTranscoder();
+
+    ContentResolver contentResolver = context.getContentResolver();
+
+    registry
+        .append(ByteBuffer.class, new ByteBufferEncoder())
+        .append(InputStream.class, new StreamEncoder(arrayPool))
         /* Bitmaps */
-        .append(ByteBuffer.class, Bitmap.class,
-            new ByteBufferBitmapDecoder(downsampler))
-        .append(InputStream.class, Bitmap.class,
-            new StreamBitmapDecoder(downsampler, arrayPool))
-        .append(ParcelFileDescriptor.class, Bitmap.class, new VideoBitmapDecoder(bitmapPool))
-        .register(Bitmap.class, new BitmapEncoder())
-        /* GlideBitmapDrawables */
-        .append(ByteBuffer.class, BitmapDrawable.class,
-            new BitmapDrawableDecoder<>(resources, bitmapPool,
-                new ByteBufferBitmapDecoder(downsampler)))
-        .append(InputStream.class, BitmapDrawable.class,
-            new BitmapDrawableDecoder<>(resources, bitmapPool,
-                new StreamBitmapDecoder(downsampler, arrayPool)))
-        .append(ParcelFileDescriptor.class, BitmapDrawable.class,
-            new BitmapDrawableDecoder<>(resources, bitmapPool, new VideoBitmapDecoder(bitmapPool)))
-        .register(BitmapDrawable.class, new BitmapDrawableEncoder(bitmapPool, new BitmapEncoder()))
+        .append(Registry.BUCKET_BITMAP, ByteBuffer.class, Bitmap.class, byteBufferBitmapDecoder)
+        .append(Registry.BUCKET_BITMAP, InputStream.class, Bitmap.class, streamBitmapDecoder)
+        .append(
+            Registry.BUCKET_BITMAP,
+            ParcelFileDescriptor.class,
+            Bitmap.class,
+            parcelFileDescriptorVideoDecoder)
+        .append(
+            Registry.BUCKET_BITMAP,
+            AssetFileDescriptor.class,
+            Bitmap.class,
+            VideoDecoder.asset(bitmapPool))
+        .append(Bitmap.class, Bitmap.class, UnitModelLoader.Factory.<Bitmap>getInstance())
+        .append(
+            Registry.BUCKET_BITMAP, Bitmap.class, Bitmap.class, new UnitBitmapDecoder())
+        .append(Bitmap.class, bitmapEncoder)
+        /* BitmapDrawables */
+        .append(
+            Registry.BUCKET_BITMAP_DRAWABLE,
+            ByteBuffer.class,
+            BitmapDrawable.class,
+            new BitmapDrawableDecoder<>(resources, byteBufferBitmapDecoder))
+        .append(
+            Registry.BUCKET_BITMAP_DRAWABLE,
+            InputStream.class,
+            BitmapDrawable.class,
+            new BitmapDrawableDecoder<>(resources, streamBitmapDecoder))
+        .append(
+            Registry.BUCKET_BITMAP_DRAWABLE,
+            ParcelFileDescriptor.class,
+            BitmapDrawable.class,
+            new BitmapDrawableDecoder<>(resources, parcelFileDescriptorVideoDecoder))
+        .append(BitmapDrawable.class, new BitmapDrawableEncoder(bitmapPool, bitmapEncoder))
         /* GIFs */
-        .prepend(InputStream.class, GifDrawable.class,
-            new StreamGifDecoder(registry.getImageHeaderParsers(), byteBufferGifDecoder, arrayPool))
-        .prepend(ByteBuffer.class, GifDrawable.class, byteBufferGifDecoder)
-        .register(GifDrawable.class, new GifDrawableEncoder())
+        .append(
+            Registry.BUCKET_GIF,
+            InputStream.class,
+            GifDrawable.class,
+            new StreamGifDecoder(imageHeaderParsers, byteBufferGifDecoder, arrayPool))
+        .append(Registry.BUCKET_GIF, ByteBuffer.class, GifDrawable.class, byteBufferGifDecoder)
+        .append(GifDrawable.class, new GifDrawableEncoder())
         /* GIF Frames */
-        .append(GifDecoder.class, GifDecoder.class, new UnitModelLoader.Factory<GifDecoder>())
-        .append(GifDecoder.class, Bitmap.class, new GifFrameResourceDecoder(bitmapPool))
+        // Compilation with Gradle requires the type to be specified for UnitModelLoader here.
+        .append(
+            GifDecoder.class, GifDecoder.class, UnitModelLoader.Factory.<GifDecoder>getInstance())
+        .append(
+            Registry.BUCKET_BITMAP,
+            GifDecoder.class,
+            Bitmap.class,
+            new GifFrameResourceDecoder(bitmapPool))
+        /* Drawables */
+        .append(Uri.class, Drawable.class, resourceDrawableDecoder)
+        .append(
+            Uri.class, Bitmap.class, new ResourceBitmapDecoder(resourceDrawableDecoder, bitmapPool))
         /* Files */
         .register(new ByteBufferRewinder.Factory())
         .append(File.class, ByteBuffer.class, new ByteBufferFileLoader.Factory())
         .append(File.class, InputStream.class, new FileLoader.StreamFactory())
         .append(File.class, File.class, new FileDecoder())
         .append(File.class, ParcelFileDescriptor.class, new FileLoader.FileDescriptorFactory())
-        .append(File.class, File.class, new UnitModelLoader.Factory<File>())
+        // Compilation with Gradle requires the type to be specified for UnitModelLoader here.
+        .append(File.class, File.class, UnitModelLoader.Factory.<File>getInstance())
         /* Models */
         .register(new InputStreamRewinder.Factory(arrayPool))
-        .append(int.class, InputStream.class, new ResourceLoader.StreamFactory(resources))
+        .append(int.class, InputStream.class, resourceLoaderStreamFactory)
+        .append(
+            int.class,
+            ParcelFileDescriptor.class,
+            resourceLoaderFileDescriptorFactory)
+        .append(Integer.class, InputStream.class, resourceLoaderStreamFactory)
         .append(
-                int.class,
-                ParcelFileDescriptor.class,
-                new ResourceLoader.FileDescriptorFactory(resources))
-        .append(Integer.class, InputStream.class, new ResourceLoader.StreamFactory(resources))
+            Integer.class,
+            ParcelFileDescriptor.class,
+            resourceLoaderFileDescriptorFactory)
+        .append(Integer.class, Uri.class, resourceLoaderUriFactory)
         .append(
-                Integer.class,
-                ParcelFileDescriptor.class,
-                new ResourceLoader.FileDescriptorFactory(resources))
-        .append(String.class, InputStream.class, new DataUrlLoader.StreamFactory())
+            int.class,
+            AssetFileDescriptor.class,
+            resourceLoaderAssetFileDescriptorFactory)
+        .append(
+            Integer.class,
+            AssetFileDescriptor.class,
+            resourceLoaderAssetFileDescriptorFactory)
+        .append(int.class, Uri.class, resourceLoaderUriFactory)
+        .append(String.class, InputStream.class, new DataUrlLoader.StreamFactory<String>())
+        .append(Uri.class, InputStream.class, new DataUrlLoader.StreamFactory<Uri>())
         .append(String.class, InputStream.class, new StringLoader.StreamFactory())
         .append(String.class, ParcelFileDescriptor.class, new StringLoader.FileDescriptorFactory())
+        .append(
+            String.class, AssetFileDescriptor.class, new StringLoader.AssetFileDescriptorFactory())
         .append(Uri.class, InputStream.class, new HttpUriLoader.Factory())
         .append(Uri.class, InputStream.class, new AssetUriLoader.StreamFactory(context.getAssets()))
         .append(
-                Uri.class,
-                ParcelFileDescriptor.class,
-                new AssetUriLoader.FileDescriptorFactory(context.getAssets()))
+            Uri.class,
+            ParcelFileDescriptor.class,
+            new AssetUriLoader.FileDescriptorFactory(context.getAssets()))
         .append(Uri.class, InputStream.class, new MediaStoreImageThumbLoader.Factory(context))
         .append(Uri.class, InputStream.class, new MediaStoreVideoThumbLoader.Factory(context))
         .append(
             Uri.class,
-             InputStream.class,
-             new UriLoader.StreamFactory(context.getContentResolver()))
-        .append(Uri.class, ParcelFileDescriptor.class,
-             new UriLoader.FileDescriptorFactory(context.getContentResolver()))
+            InputStream.class,
+            new UriLoader.StreamFactory(contentResolver))
+        .append(
+            Uri.class,
+            ParcelFileDescriptor.class,
+             new UriLoader.FileDescriptorFactory(contentResolver))
+        .append(
+            Uri.class,
+            AssetFileDescriptor.class,
+            new UriLoader.AssetFileDescriptorFactory(contentResolver))
         .append(Uri.class, InputStream.class, new UrlUriLoader.StreamFactory())
         .append(URL.class, InputStream.class, new UrlLoader.StreamFactory())
         .append(Uri.class, File.class, new MediaStoreFileLoader.Factory(context))
         .append(GlideUrl.class, InputStream.class, new HttpGlideUrlLoader.Factory())
         .append(byte[].class, ByteBuffer.class, new ByteArrayLoader.ByteBufferFactory())
         .append(byte[].class, InputStream.class, new ByteArrayLoader.StreamFactory())
+        .append(Uri.class, Uri.class, UnitModelLoader.Factory.<Uri>getInstance())
+        .append(Drawable.class, Drawable.class, UnitModelLoader.Factory.<Drawable>getInstance())
+        .append(Drawable.class, Drawable.class, new UnitDrawableDecoder())
         /* Transcoders */
-        .register(Bitmap.class, BitmapDrawable.class,
-            new BitmapDrawableTranscoder(resources, bitmapPool))
-        .register(Bitmap.class, byte[].class, new BitmapBytesTranscoder())
-        .register(GifDrawable.class, byte[].class, new GifDrawableBytesTranscoder());
+        .register(
+            Bitmap.class,
+            BitmapDrawable.class,
+            new BitmapDrawableTranscoder(resources))
+        .register(Bitmap.class, byte[].class, bitmapBytesTranscoder)
+        .register(
+            Drawable.class,
+            byte[].class,
+            new DrawableBytesTranscoder(
+                bitmapPool, bitmapBytesTranscoder, gifDrawableBytesTranscoder))
+        .register(GifDrawable.class, byte[].class, gifDrawableBytesTranscoder);
 
     ImageViewTargetFactory imageViewTargetFactory = new ImageViewTargetFactory();
     glideContext =
         new GlideContext(
-            context, registry, imageViewTargetFactory, defaultRequestOptions,
-            defaultTransitionOptions, engine, logLevel);
+            context,
+            arrayPool,
+            registry,
+            imageViewTargetFactory,
+            defaultRequestOptions,
+            defaultTransitionOptions,
+            defaultRequestListeners,
+            engine,
+            logLevel);
   }
 
   /**
@@ -399,10 +544,12 @@ private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules() {
    * {@link com.bumptech.glide.load.Transformation}s. Use outside of these classes is not generally
    * recommended. </p>
    */
+  @NonNull
   public BitmapPool getBitmapPool() {
     return bitmapPool;
   }
 
+  @NonNull
   public ArrayPool getArrayPool() {
     return arrayPool;
   }
@@ -410,6 +557,7 @@ public ArrayPool getArrayPool() {
   /**
    * @return The context associated with this instance.
    */
+  @NonNull
   public Context getContext() {
     return glideContext.getBaseContext();
   }
@@ -418,6 +566,7 @@ ConnectivityMonitorFactory getConnectivityMonitorFactory() {
     return connectivityMonitorFactory;
   }
 
+  @NonNull
   GlideContext getGlideContext() {
     return glideContext;
   }
@@ -447,7 +596,8 @@ GlideContext getGlideContext() {
    * {@link com.bumptech.glide.load.engine.prefill.PreFillType.Builder Builders} representing
    * individual sizes and configurations of {@link android.graphics.Bitmap}s to be pre-filled.
    */
-  public void preFillBitmapPool(PreFillType.Builder... bitmapAttributeBuilders) {
+  @SuppressWarnings("unused") // Public API
+  public void preFillBitmapPool(@NonNull PreFillType.Builder... bitmapAttributeBuilders) {
     bitmapPreFiller.preFill(bitmapAttributeBuilders);
   }
 
@@ -487,16 +637,17 @@ public void trimMemory(int level) {
    *     This method should always be called on a background thread, since it is a blocking call.
    * </p>
    */
-  @SuppressWarnings("unused") // Public API
+  // Public API.
+  @SuppressWarnings({"unused", "WeakerAccess"})
   public void clearDiskCache() {
     Util.assertBackgroundThread();
     engine.clearDiskCache();
   }
 
-
   /**
    * Internal method.
    */
+  @NonNull
   public RequestManagerRetriever getRequestManagerRetriever() {
     return requestManagerRetriever;
   }
@@ -513,7 +664,9 @@ public RequestManagerRetriever getRequestManagerRetriever() {
    *
    * @return the previous MemoryCategory used by Glide.
    */
-  public MemoryCategory setMemoryCategory(MemoryCategory memoryCategory) {
+  @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
+  public MemoryCategory setMemoryCategory(@NonNull MemoryCategory memoryCategory) {
     // Engine asserts this anyway when removing resources, fail faster and consistently
     Util.assertMainThread();
     // memory cache needs to be trimmed before bitmap pool to trim re-pooled Bitmaps too. See #687.
@@ -524,12 +677,13 @@ public MemoryCategory setMemoryCategory(MemoryCategory memoryCategory) {
     return oldCategory;
   }
 
+  @NonNull
   private static RequestManagerRetriever getRetriever(@Nullable Context context) {
     // Context could be null for other reasons (ie the user passes in null), but in practice it will
     // only occur due to errors with the Fragment lifecycle.
     Preconditions.checkNotNull(
         context,
-        "You cannot start a load on a not yet attached View or a  Fragment where getActivity() "
+        "You cannot start a load on a not yet attached View or a Fragment where getActivity() "
             + "returns null (which usually occurs when getActivity() is called before the Fragment "
             + "is attached or after the Fragment is destroyed).");
     return Glide.get(context).getRequestManagerRetriever();
@@ -557,7 +711,8 @@ private static RequestManagerRetriever getRetriever(@Nullable Context context) {
    * @see #with(android.support.v4.app.Fragment)
    * @see #with(android.support.v4.app.FragmentActivity)
    */
-  public static RequestManager with(Context context) {
+  @NonNull
+  public static RequestManager with(@NonNull Context context) {
     return getRetriever(context).get(context);
   }
 
@@ -568,7 +723,8 @@ public static RequestManager with(Context context) {
    * @param activity The activity to use.
    * @return A RequestManager for the given activity that can be used to start a load.
    */
-  public static RequestManager with(Activity activity) {
+  @NonNull
+  public static RequestManager with(@NonNull Activity activity) {
     return getRetriever(activity).get(activity);
   }
 
@@ -580,30 +736,38 @@ public static RequestManager with(Activity activity) {
    * @param activity The activity to use.
    * @return A RequestManager for the given FragmentActivity that can be used to start a load.
    */
-  public static RequestManager with(FragmentActivity activity) {
+  @NonNull
+  public static RequestManager with(@NonNull FragmentActivity activity) {
     return getRetriever(activity).get(activity);
   }
 
   /**
-   * Begin a load with Glide that will be tied to the given {@link android.app.Fragment}'s lifecycle
-   * and that uses the given {@link android.app.Fragment}'s default options.
+   * Begin a load with Glide that will be tied to the given
+   * {@link android.support.v4.app.Fragment}'s lifecycle and that uses the given
+   * {@link android.support.v4.app.Fragment}'s default options.
    *
    * @param fragment The fragment to use.
    * @return A RequestManager for the given Fragment that can be used to start a load.
    */
-  public static RequestManager with(android.app.Fragment fragment) {
+  @NonNull
+  public static RequestManager with(@NonNull Fragment fragment) {
     return getRetriever(fragment.getActivity()).get(fragment);
   }
 
   /**
-   * Begin a load with Glide that will be tied to the given
-   * {@link android.support.v4.app.Fragment}'s lifecycle and that uses the given
-   * {@link android.support.v4.app.Fragment}'s default options.
+   * Begin a load with Glide that will be tied to the given {@link android.app.Fragment}'s lifecycle
+   * and that uses the given {@link android.app.Fragment}'s default options.
    *
    * @param fragment The fragment to use.
    * @return A RequestManager for the given Fragment that can be used to start a load.
+   * @deprecated Prefer support Fragments and {@link #with(Fragment)} instead,
+   * {@link android.app.Fragment} will be deprecated. See
+   * https://github.com/android/android-ktx/pull/161#issuecomment-363270555.
    */
-  public static RequestManager with(Fragment fragment) {
+  @SuppressWarnings("deprecation")
+  @Deprecated
+  @NonNull
+  public static RequestManager with(@NonNull android.app.Fragment fragment) {
     return getRetriever(fragment.getActivity()).get(fragment);
   }
 
@@ -617,33 +781,41 @@ public static RequestManager with(Fragment fragment) {
    * <p>This method will not work if the View is not attached. Prefer the Activity and Fragment
    * variants unless you're loading in a View subclass.
    *
-   * <p>This method may be inefficient for large hierarchies. Consider memoizing the result after
-   * the View is attached.
+   * <p>This method may be inefficient aways and is definitely inefficient for large hierarchies.
+   * Consider memoizing the result after the View is attached or again, prefer the Activity and
+   * Fragment variants whenever possible.
    *
    * <p>When used in Applications that use the non-support {@link android.app.Fragment} classes,
    * calling this method will produce noisy logs from {@link android.app.FragmentManager}. Consider
    * avoiding entirely or using the {@link Fragment}s from the support library instead.
    *
+   * <p>If the support {@link FragmentActivity} class is used, this method will only attempt to
+   * discover support {@link Fragment}s. Any non-support {@link android.app.Fragment}s attached
+   * to the {@link FragmentActivity} will be ignored.
+   *
    * @param view The view to search for a containing Fragment or Activity from.
    * @return A RequestManager that can be used to start a load.
    */
-  public static RequestManager with(View view) {
+  @NonNull
+  public static RequestManager with(@NonNull View view) {
     return getRetriever(view.getContext()).get(view);
   }
 
+  @NonNull
   public Registry getRegistry() {
     return registry;
   }
 
-  void removeFromManagers(Target<?> target) {
+  boolean removeFromManagers(@NonNull Target<?> target) {
     synchronized (managers) {
       for (RequestManager requestManager : managers) {
         if (requestManager.untrack(target)) {
-          return;
+          return true;
         }
       }
     }
-    throw new IllegalStateException("Failed to remove target from managers");
+
+    return false;
   }
 
   void registerRequestManager(RequestManager requestManager) {
@@ -658,7 +830,7 @@ void registerRequestManager(RequestManager requestManager) {
   void unregisterRequestManager(RequestManager requestManager) {
     synchronized (managers) {
       if (!managers.contains(requestManager)) {
-        throw new IllegalStateException("Cannot register not yet registered manager");
+        throw new IllegalStateException("Cannot unregister not yet registered manager");
       }
       managers.remove(requestManager);
     }
diff --git a/library/src/main/java/com/bumptech/glide/GlideBuilder.java b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
index 6b319059d..bdfae965b 100644
--- a/library/src/main/java/com/bumptech/glide/GlideBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
@@ -1,14 +1,17 @@
 package com.bumptech.glide;
 
 import android.content.Context;
+import android.graphics.Bitmap;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.support.v4.util.ArrayMap;
 import android.util.Log;
-import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.engine.Engine;
+import com.bumptech.glide.load.engine.GlideException;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
 import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.LruBitmapPool;
 import com.bumptech.glide.load.engine.cache.DiskCache;
@@ -21,7 +24,12 @@
 import com.bumptech.glide.manager.DefaultConnectivityMonitorFactory;
 import com.bumptech.glide.manager.RequestManagerRetriever;
 import com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory;
+import com.bumptech.glide.request.RequestListener;
 import com.bumptech.glide.request.RequestOptions;
+import com.bumptech.glide.request.target.Target;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
 import java.util.Map;
 
 /**
@@ -42,6 +50,10 @@
   private RequestOptions defaultRequestOptions = new RequestOptions();
   @Nullable
   private RequestManagerFactory requestManagerFactory;
+  private GlideExecutor animationExecutor;
+  private boolean isActiveResourceRetentionAllowed;
+  @Nullable
+  private List<RequestListener<Object>> defaultRequestListeners;
 
   /**
    * Sets the {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} implementation to use
@@ -50,7 +62,8 @@
    * @param bitmapPool The pool to use.
    * @return This builder.
    */
-  public GlideBuilder setBitmapPool(BitmapPool bitmapPool) {
+  @NonNull
+  public GlideBuilder setBitmapPool(@Nullable BitmapPool bitmapPool) {
     this.bitmapPool = bitmapPool;
     return this;
   }
@@ -62,7 +75,8 @@ public GlideBuilder setBitmapPool(BitmapPool bitmapPool) {
    * @param arrayPool The pool to use.
    * @return This builder.
    */
-  public GlideBuilder setArrayPool(ArrayPool arrayPool) {
+  @NonNull
+  public GlideBuilder setArrayPool(@Nullable ArrayPool arrayPool) {
     this.arrayPool = arrayPool;
     return this;
   }
@@ -74,31 +88,14 @@ public GlideBuilder setArrayPool(ArrayPool arrayPool) {
    * @param memoryCache The cache to use.
    * @return This builder.
    */
-  public GlideBuilder setMemoryCache(MemoryCache memoryCache) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  @NonNull
+  public GlideBuilder setMemoryCache(@Nullable MemoryCache memoryCache) {
     this.memoryCache = memoryCache;
     return this;
   }
 
-  /**
-   * Sets the {@link com.bumptech.glide.load.engine.cache.DiskCache} implementation to use to store
-   * {@link com.bumptech.glide.load.engine.Resource} data and thumbnails.
-   *
-   * @param diskCache The disk cache to use.
-   * @return This builder.
-   * @deprecated Creating a disk cache directory on the main thread causes strict mode violations,
-   * use {@link #setDiskCache(com.bumptech.glide.load.engine.cache.DiskCache.Factory)} instead.
-   * Scheduled to be removed in Glide 4.0.
-   */
-  @Deprecated
-  public GlideBuilder setDiskCache(final DiskCache diskCache) {
-    return setDiskCache(new DiskCache.Factory() {
-      @Override
-      public DiskCache build() {
-        return diskCache;
-      }
-    });
-  }
-
   /**
    * Sets the {@link com.bumptech.glide.load.engine.cache.DiskCache.Factory} implementation to use
    * to construct the {@link com.bumptech.glide.load.engine.cache.DiskCache} to use to store {@link
@@ -107,45 +104,102 @@ public DiskCache build() {
    * @param diskCacheFactory The disk cache factory to use.
    * @return This builder.
    */
-  public GlideBuilder setDiskCache(DiskCache.Factory diskCacheFactory) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  @NonNull
+  public GlideBuilder setDiskCache(@Nullable DiskCache.Factory diskCacheFactory) {
     this.diskCacheFactory = diskCacheFactory;
     return this;
   }
 
   /**
-   * Sets the {@link java.util.concurrent.ExecutorService} implementation to use when retrieving
+   * Sets the {@link GlideExecutor} to use when retrieving
+   * {@link com.bumptech.glide.load.engine.Resource}s that are not already in the cache.
+   *
+   * <p>The thread count defaults to the number of cores available on the device, with a maximum of
+   * 4.
+   *
+   * <p>Use the {@link GlideExecutor#newSourceExecutor()} methods if you'd like to specify options
+   * for the source executor.
+   *
+   * @param service The ExecutorService to use.
+   * @return This builder.
+   * @see #setDiskCacheExecutor(GlideExecutor)
+   * @see GlideExecutor
+   *
+   * @deprecated Use {@link #setSourceExecutor(GlideExecutor)}
+   */
+  @Deprecated
+  public GlideBuilder setResizeExecutor(@Nullable GlideExecutor service) {
+    return setSourceExecutor(service);
+  }
+
+  /**
+   * Sets the {@link GlideExecutor} to use when retrieving
    * {@link com.bumptech.glide.load.engine.Resource}s that are not already in the cache.
    *
-   * <p> Any implementation must order requests based on their {@link com.bumptech.glide.Priority}
-   * for thumbnail requests to work properly.
+   * <p>The thread count defaults to the number of cores available on the device, with a maximum of
+   * 4.
+   *
+   * <p>Use the {@link GlideExecutor#newSourceExecutor()} methods if you'd like to specify options
+   * for the source executor.
    *
    * @param service The ExecutorService to use.
    * @return This builder.
    * @see #setDiskCacheExecutor(GlideExecutor)
    * @see GlideExecutor
    */
-  public GlideBuilder setResizeExecutor(GlideExecutor service) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  @NonNull
+  public GlideBuilder setSourceExecutor(@Nullable GlideExecutor service) {
     this.sourceExecutor = service;
     return this;
   }
 
   /**
-   * Sets the {@link java.util.concurrent.ExecutorService} implementation to use when retrieving
-   * {@link com.bumptech.glide.load.engine.Resource}s that are currently in cache.
+   * Sets the {@link GlideExecutor} to use when retrieving
+   * {@link com.bumptech.glide.load.engine.Resource}s that are currently in Glide's disk caches.
    *
-   * <p> Any implementation must order requests based on their {@link com.bumptech.glide.Priority}
-   * for thumbnail requests to work properly.
+   * <p>Defaults to a single thread which is usually the best combination of memory usage,
+   * jank, and performance, even on high end devices.
    *
-   * @param service The ExecutorService to use.
+   * <p>Use the {@link GlideExecutor#newDiskCacheExecutor()} if you'd like to specify options
+   * for the disk cache executor.
+   *
+   * @param service The {@link GlideExecutor} to use.
    * @return This builder.
-   * @see #setResizeExecutor(GlideExecutor)
+   * @see #setSourceExecutor(GlideExecutor)
    * @see GlideExecutor
    */
-  public GlideBuilder setDiskCacheExecutor(GlideExecutor service) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  @NonNull
+  public GlideBuilder setDiskCacheExecutor(@Nullable GlideExecutor service) {
     this.diskCacheExecutor = service;
     return this;
   }
 
+  /**
+   * Sets the {@link GlideExecutor} to use when loading frames of animated images and particularly
+   * of {@link com.bumptech.glide.load.resource.gif.GifDrawable}s.
+   *
+   * <p>Defaults to one or two threads, depending on the number of cores available.
+   *
+   * <p>Use the {@link GlideExecutor#newAnimationExecutor()} methods  if you'd like to specify
+   * options for the animation executor.
+   *
+   * @param service The {@link GlideExecutor} to use.
+   * @return This builder.
+   */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  @NonNull
+  public GlideBuilder setAnimationExecutor(@Nullable GlideExecutor service) {
+    this.animationExecutor = service;
+    return this;
+  }
+
   /**
    * Sets the default {@link RequestOptions} to use for all loads across the app.
    *
@@ -156,7 +210,8 @@ public GlideBuilder setDiskCacheExecutor(GlideExecutor service) {
    * @param requestOptions The options to use by default.
    * @return This builder.
    */
-  public GlideBuilder setDefaultRequestOptions(RequestOptions requestOptions) {
+  @NonNull
+  public GlideBuilder setDefaultRequestOptions(@Nullable RequestOptions requestOptions) {
     this.defaultRequestOptions = requestOptions;
     return this;
   }
@@ -177,31 +232,15 @@ public GlideBuilder setDefaultRequestOptions(RequestOptions requestOptions) {
    * {@link android.graphics.drawable.BitmapDrawable}s, the transition you registered for
    * {@link android.graphics.drawable.BitmapDrawable}s will be used.
    */
+  // Public API.
+  @SuppressWarnings("unused")
+  @NonNull
   public <T> GlideBuilder setDefaultTransitionOptions(
       @NonNull Class<T> clazz, @Nullable TransitionOptions<?, T> options) {
     defaultTransitionOptions.put(clazz, options);
     return this;
   }
 
-  /**
-   * Sets the {@link com.bumptech.glide.load.DecodeFormat} that will be the default format for all
-   * the default decoders that can change the {@link android.graphics.Bitmap.Config} of the {@link
-   * android.graphics.Bitmap}s they decode.
-   *
-   * <p> Decode format is always a suggestion, not a requirement. See {@link
-   * com.bumptech.glide.load.DecodeFormat} for more details. </p>
-   *
-   * @param decodeFormat The format to use.
-   * @return This builder.
-   *
-   * @deprecated Use {@link #setDefaultRequestOptions(RequestOptions)} instead.
-   */
-  @Deprecated
-  public GlideBuilder setDecodeFormat(DecodeFormat decodeFormat) {
-    defaultRequestOptions.apply(new RequestOptions().format(decodeFormat));
-    return this;
-  }
-
   /**
    * Sets the {@link MemorySizeCalculator} to use to calculate maximum sizes for default
    * {@link MemoryCache MemoryCaches} and/or default {@link BitmapPool BitmapPools}.
@@ -211,7 +250,10 @@ public GlideBuilder setDecodeFormat(DecodeFormat decodeFormat) {
    * @param builder The builder to use (will not be modified).
    * @return This builder.
    */
-  public GlideBuilder setMemorySizeCalculator(MemorySizeCalculator.Builder builder) {
+  // Public API.
+  @SuppressWarnings("unused")
+  @NonNull
+  public GlideBuilder setMemorySizeCalculator(@NonNull MemorySizeCalculator.Builder builder) {
     return setMemorySizeCalculator(builder.build());
   }
 
@@ -225,7 +267,10 @@ public GlideBuilder setMemorySizeCalculator(MemorySizeCalculator.Builder builder
    * @param calculator The calculator to use.
    * @return This builder.
    */
-  public GlideBuilder setMemorySizeCalculator(MemorySizeCalculator calculator) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  @NonNull
+  public GlideBuilder setMemorySizeCalculator(@Nullable MemorySizeCalculator calculator) {
     this.memorySizeCalculator = calculator;
     return this;
   }
@@ -238,7 +283,10 @@ public GlideBuilder setMemorySizeCalculator(MemorySizeCalculator calculator) {
    * @param factory The factory to use
    * @return This builder.
    */
-  public GlideBuilder setConnectivityMonitorFactory(ConnectivityMonitorFactory factory) {
+  // Public API.
+  @SuppressWarnings("unused")
+  @NonNull
+  public GlideBuilder setConnectivityMonitorFactory(@Nullable ConnectivityMonitorFactory factory) {
     this.connectivityMonitorFactory = factory;
     return this;
   }
@@ -268,6 +316,9 @@ public GlideBuilder setConnectivityMonitorFactory(ConnectivityMonitorFactory fac
    * @param logLevel The log level to use from {@link Log}.
    * @return This builder.
    */
+  // Public API.
+  @SuppressWarnings("unused")
+  @NonNull
   public GlideBuilder setLogLevel(int logLevel) {
     if (logLevel < Log.VERBOSE || logLevel > Log.ERROR) {
       throw new IllegalArgumentException("Log level must be one of Log.VERBOSE, Log.DEBUG,"
@@ -277,19 +328,96 @@ public GlideBuilder setLogLevel(int logLevel) {
     return this;
   }
 
-  GlideBuilder setRequestManagerFactory(
-      @Nullable RequestManagerRetriever.RequestManagerFactory factory) {
-    this.requestManagerFactory = factory;
+  /**
+   * If set to {@code true}, allows Glide to re-capture resources that are loaded into
+   * {@link com.bumptech.glide.request.target.Target}s which are subsequently de-referenced and
+   * garbage collected without being cleared.
+   *
+   * <p>Defaults to {@code false}.
+   *
+   * <p>Glide's resource re-use system is permissive, which means that's acceptable for callers to
+   * load resources into {@link com.bumptech.glide.request.target.Target}s and then never clear the
+   * {@link com.bumptech.glide.request.target.Target}. To do so, Glide uses
+   * {@link java.lang.ref.WeakReference}s to track resources that belong to
+   * {@link com.bumptech.glide.request.target.Target}s that haven't yet been cleared. Setting
+   * this method to {@code true} allows Glide to also maintain a hard reference to the underlying
+   * resource so that if the {@link com.bumptech.glide.request.target.Target} is garbage collected,
+   * Glide can return the underlying resource to it's memory cache so that subsequent requests will
+   * not unexpectedly re-load the resource from disk or source. As a side affect, it will take
+   * the system slightly longer to garbage collect the underlying resource because the weak
+   * reference has to be cleared and processed before the hard reference is removed. As a result,
+   * setting this method to {@code true} may transiently increase the memory usage of an
+   * application.
+   *
+   * <p>Leaving this method at the default {@code false} value will allow the platform to garbage
+   * collect resources more quickly, but will lead to unexpected memory cache misses if callers load
+   * resources into {@link com.bumptech.glide.request.target.Target}s but never clear them.
+   *
+   * <p>If you set this method to {@code true} you <em>must not</em> call
+   * {@link Bitmap#recycle()} or mutate any Bitmaps returned by Glide. If this method is set to
+   * {@code false}, recycling or mutating Bitmaps is inefficient but safe as long as you do not
+   * clear the corresponding {@link com.bumptech.glide.request.target.Target} used to load the
+   * {@link Bitmap}. However, if you set this method to {@code true} and recycle or mutate any
+   * returned {@link Bitmap}s or other mutable resources, Glide may recover those resources and
+   * attempt to use them later on, resulting in crashes, graphical corruption or undefined behavior.
+   *
+   * <p>Regardless of what value this method is set to, it's always good practice to clear
+   * {@link com.bumptech.glide.request.target.Target}s when you're done with the corresponding
+   * resource. Clearing {@link com.bumptech.glide.request.target.Target}s allows Glide to maximize
+   * resource re-use, minimize memory overhead and minimize unexpected behavior resulting from
+   * edge cases. If you use {@link RequestManager#clear(Target)}, calling {@link Bitmap#recycle()}
+   * or mutating {@link Bitmap}s is not only unsafe, it's also totally unnecessary and should be
+   * avoided. In all cases, prefer {@link RequestManager#clear(Target)} to {@link Bitmap#recycle()}.
+   *
+   * @return This builder.
+   */
+  // Public API.
+  @SuppressWarnings("unused")
+  @NonNull
+  public GlideBuilder setIsActiveResourceRetentionAllowed(
+      boolean isActiveResourceRetentionAllowed) {
+    this.isActiveResourceRetentionAllowed = isActiveResourceRetentionAllowed;
+    return this;
+  }
+
+  /**
+   * Adds a global {@link RequestListener} that will be added to every request started with Glide.
+   *
+   * <p>Multiple {@link RequestListener}s can be added here, in {@link RequestManager} scopes or
+   * to individual {@link RequestBuilder}s. {@link RequestListener}s are called in the order they're
+   * added. Even if an earlier {@link RequestListener} returns {@code true} from
+   * {@link RequestListener#onLoadFailed(GlideException, Object, Target, boolean)} or
+   * {@link RequestListener#onResourceReady(Object, Object, Target, DataSource, boolean)}, it will
+   * not prevent subsequent {@link RequestListener}s from being called.
+   *
+   * <p>Because Glide requests can be started for any number of individual resource types, any
+   * listener added here has to accept any generic resource type in
+   * {@link RequestListener#onResourceReady(Object, Object, Target, DataSource, boolean)}. If you
+   * must base the behavior of the listener on the resource type, you will need to use
+   * {@code instanceof} to do so. It's not safe to cast resource types without first checking
+   * with {@code instanceof}.
+   */
+  @NonNull
+  public GlideBuilder addGlobalRequestListener(@NonNull RequestListener<Object> listener) {
+    if (defaultRequestListeners == null) {
+      defaultRequestListeners = new ArrayList<>();
+    }
+    defaultRequestListeners.add(listener);
     return this;
   }
 
+  void setRequestManagerFactory(@Nullable RequestManagerFactory factory) {
+    this.requestManagerFactory = factory;
+  }
+
   // For testing.
   GlideBuilder setEngine(Engine engine) {
     this.engine = engine;
     return this;
   }
 
-  public Glide build(Context context) {
+  @NonNull
+  Glide build(@NonNull Context context) {
     if (sourceExecutor == null) {
       sourceExecutor = GlideExecutor.newSourceExecutor();
     }
@@ -298,6 +426,10 @@ public Glide build(Context context) {
       diskCacheExecutor = GlideExecutor.newDiskCacheExecutor();
     }
 
+    if (animationExecutor == null) {
+      animationExecutor = GlideExecutor.newAnimationExecutor();
+    }
+
     if (memorySizeCalculator == null) {
       memorySizeCalculator = new MemorySizeCalculator.Builder(context).build();
     }
@@ -308,7 +440,11 @@ public Glide build(Context context) {
 
     if (bitmapPool == null) {
       int size = memorySizeCalculator.getBitmapPoolSize();
-      bitmapPool = new LruBitmapPool(size);
+      if (size > 0) {
+        bitmapPool = new LruBitmapPool(size);
+      } else {
+        bitmapPool = new BitmapPoolAdapter();
+      }
     }
 
     if (arrayPool == null) {
@@ -324,12 +460,25 @@ public Glide build(Context context) {
     }
 
     if (engine == null) {
-      engine = new Engine(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor,
-          GlideExecutor.newUnlimitedSourceExecutor());
+      engine =
+          new Engine(
+              memoryCache,
+              diskCacheFactory,
+              diskCacheExecutor,
+              sourceExecutor,
+              GlideExecutor.newUnlimitedSourceExecutor(),
+              GlideExecutor.newAnimationExecutor(),
+              isActiveResourceRetentionAllowed);
+    }
+
+    if (defaultRequestListeners == null) {
+      defaultRequestListeners = Collections.emptyList();
+    } else {
+      defaultRequestListeners = Collections.unmodifiableList(defaultRequestListeners);
     }
 
-    RequestManagerRetriever requestManagerRetriever = new RequestManagerRetriever(
-        requestManagerFactory);
+    RequestManagerRetriever requestManagerRetriever =
+        new RequestManagerRetriever(requestManagerFactory);
 
     return new Glide(
         context,
@@ -341,6 +490,7 @@ public Glide build(Context context) {
         connectivityMonitorFactory,
         logLevel,
         defaultRequestOptions.lock(),
-        defaultTransitionOptions);
+        defaultTransitionOptions,
+        defaultRequestListeners);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/GlideContext.java b/library/src/main/java/com/bumptech/glide/GlideContext.java
index 1e0aa58ab..a587b19bd 100644
--- a/library/src/main/java/com/bumptech/glide/GlideContext.java
+++ b/library/src/main/java/com/bumptech/glide/GlideContext.java
@@ -1,18 +1,19 @@
 package com.bumptech.glide;
 
-import android.annotation.TargetApi;
 import android.content.Context;
 import android.content.ContextWrapper;
-import android.os.Build;
 import android.os.Handler;
 import android.os.Looper;
 import android.support.annotation.NonNull;
 import android.support.annotation.VisibleForTesting;
 import android.widget.ImageView;
 import com.bumptech.glide.load.engine.Engine;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.request.RequestListener;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.ImageViewTargetFactory;
-import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.request.target.ViewTarget;
+import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 
@@ -20,27 +21,36 @@
  * Global context for all loads in Glide containing and exposing the various registries and classes
  * required to load resources.
  */
-@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
 public class GlideContext extends ContextWrapper {
   @VisibleForTesting
   static final TransitionOptions<?, ?> DEFAULT_TRANSITION_OPTIONS =
-      new GenericTransitionOptions<Object>();
+      new GenericTransitionOptions<>();
   private final Handler mainHandler;
+  private final ArrayPool arrayPool;
   private final Registry registry;
   private final ImageViewTargetFactory imageViewTargetFactory;
   private final RequestOptions defaultRequestOptions;
+  private final List<RequestListener<Object>> defaultRequestListeners;
   private final Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions;
   private final Engine engine;
   private final int logLevel;
 
-  public GlideContext(Context context, Registry registry,
-      ImageViewTargetFactory imageViewTargetFactory, RequestOptions defaultRequestOptions,
-      Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions, Engine engine,
+  public GlideContext(
+      @NonNull Context context,
+      @NonNull ArrayPool arrayPool,
+      @NonNull Registry registry,
+      @NonNull ImageViewTargetFactory imageViewTargetFactory,
+      @NonNull RequestOptions defaultRequestOptions,
+      @NonNull Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions,
+      @NonNull List<RequestListener<Object>> defaultRequestListeners,
+      @NonNull Engine engine,
       int logLevel) {
     super(context.getApplicationContext());
+    this.arrayPool = arrayPool;
     this.registry = registry;
     this.imageViewTargetFactory = imageViewTargetFactory;
     this.defaultRequestOptions = defaultRequestOptions;
+    this.defaultRequestListeners = defaultRequestListeners;
     this.defaultTransitionOptions = defaultTransitionOptions;
     this.engine = engine;
     this.logLevel = logLevel;
@@ -48,13 +58,17 @@ public GlideContext(Context context, Registry registry,
     mainHandler = new Handler(Looper.getMainLooper());
   }
 
+  public List<RequestListener<Object>> getDefaultRequestListeners() {
+    return defaultRequestListeners;
+  }
+
   public RequestOptions getDefaultRequestOptions() {
     return defaultRequestOptions;
   }
 
   @SuppressWarnings("unchecked")
   @NonNull
-  public <T> TransitionOptions<?, T> getDefaultTransitionOptions(Class<T> transcodeClass) {
+  public <T> TransitionOptions<?, T> getDefaultTransitionOptions(@NonNull Class<T> transcodeClass) {
     TransitionOptions<?, ?> result = defaultTransitionOptions.get(transcodeClass);
     if (result == null) {
       for (Entry<Class<?>, TransitionOptions<?, ?>> value : defaultTransitionOptions.entrySet()) {
@@ -69,18 +83,23 @@ public RequestOptions getDefaultRequestOptions() {
     return (TransitionOptions<?, T>) result;
   }
 
-  public <X> Target<X> buildImageViewTarget(ImageView imageView, Class<X> transcodeClass) {
+  @NonNull
+  public <X> ViewTarget<ImageView, X> buildImageViewTarget(
+      @NonNull ImageView imageView, @NonNull Class<X> transcodeClass) {
     return imageViewTargetFactory.buildTarget(imageView, transcodeClass);
   }
 
+  @NonNull
   public Handler getMainHandler() {
     return mainHandler;
   }
 
+  @NonNull
   public Engine getEngine() {
     return engine;
   }
 
+  @NonNull
   public Registry getRegistry() {
     return registry;
   }
@@ -88,4 +107,9 @@ public Registry getRegistry() {
   public int getLogLevel() {
     return logLevel;
   }
+
+  @NonNull
+  public ArrayPool getArrayPool() {
+    return arrayPool;
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/ListPreloader.java b/library/src/main/java/com/bumptech/glide/ListPreloader.java
index 9844786b3..e82125729 100644
--- a/library/src/main/java/com/bumptech/glide/ListPreloader.java
+++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.widget.AbsListView;
 import com.bumptech.glide.request.target.BaseTarget;
@@ -24,7 +25,6 @@
  * @param <T> The type of the model being displayed in the list.
  */
 public class ListPreloader<T> implements AbsListView.OnScrollListener {
-
   private final int maxPreload;
   private final PreloadTargetQueue preloadTargetQueue;
   private final RequestManager requestManager;
@@ -33,7 +33,7 @@
 
   private int lastEnd;
   private int lastStart;
-  private int lastFirstVisible;
+  private int lastFirstVisible = -1;
   private int totalItemCount;
 
   private boolean isIncreasing = true;
@@ -47,25 +47,45 @@
   public interface PreloadModelProvider<U> {
 
     /**
-     * Returns a non null list of all models that need to be loaded for the list to display adapter
-     * items in positions between {@code start} and {@code end}.
+     * Returns a {@link List} of models that need to be loaded for the list to display adapter items
+     * in positions between {@code start} and {@code end}.
+     *
+     * <p>A list of any size can be returned so there can be multiple models per adapter position.
+     *
+     * <p>Every model returned by this method is expected to produce a valid {@link RequestBuilder}
+     * in {@link #getPreloadRequestBuilder(Object)}. If that's not possible for any set of models,
+     * avoid including them in the {@link List} returned by this method.
      *
-     * <p> A list of any size can be returned so there can be multiple models per adapter position.
-     * </p>
+     * <p>Although it's acceptable for the returned {@link List} to contain {@code null} models,
+     * it's best to filter them from the list instead of adding {@code null} to avoid unnecessary
+     * logic and expanding the size of the {@link List}
      *
      * @param position The adapter position.
      */
+    @NonNull
     List<U> getPreloadItems(int position);
 
     /**
-     * Returns a non null {@link RequestBuilder} for a given item. Must exactly match the request
-     * used to load the resource in the list.
+     * Returns a {@link RequestBuilder} for a given item on which
+     * {@link RequestBuilder#load(Object)}} has been called or {@code null} if no valid load can be
+     * started.
+     *
+     * <p>For the preloader to be effective, the {@link RequestBuilder} returned here must use
+     * exactly the same size and set of options as the {@link RequestBuilder} used when the ``View``
+     * is bound. You may need to specify a size in both places to ensure that the width and height
+     * match exactly. If so, you can use
+     * {@link com.bumptech.glide.request.RequestOptions#override(int, int)} to do so.
+     *
+     * <p>The target and context will be provided by the preloader.
      *
-     * <p> The target and context will be provided by the preloader. </p>
+     * <p>If {@link RequestBuilder#load(Object)} is not called by this method, the preloader will
+     * trigger a {@link RuntimeException}. If you don't want to load a particular item or position,
+     * filter it from the list returned by {@link #getPreloadItems(int)}.
      *
      * @param item The model to load.
      */
-    RequestBuilder getPreloadRequestBuilder(U item);
+    @Nullable
+    RequestBuilder<?> getPreloadRequestBuilder(@NonNull U item);
   }
 
   /**
@@ -80,13 +100,14 @@
      * Returns the size of the view in the list where the resources will be displayed in pixels in
      * the format [x, y], or {@code null} if no size is currently available.
      *
-     * <p> Note - The dimensions returned here must precisely match those of the view in the list.
-     * </p>
+     * <p>Note - The dimensions returned here must precisely match those of the view in the list.
+     *
+     * <p>If this method returns {@code null}, then no request will be started for the given item.
      *
      * @param item A model
      */
     @Nullable
-    int[] getPreloadSize(T item, int adapterPosition, int perItemPosition);
+    int[] getPreloadSize(@NonNull T item, int adapterPosition, int perItemPosition);
   }
 
   /**
@@ -98,8 +119,9 @@
    * @param preloadDimensionProvider Provides the dimensions of images to load.
    * @param maxPreload               Maximum number of items to preload.
    */
-  public ListPreloader(RequestManager requestManager, PreloadModelProvider<T> preloadModelProvider,
-      PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {
+  public ListPreloader(@NonNull RequestManager requestManager,
+      @NonNull PreloadModelProvider<T> preloadModelProvider,
+      @NonNull PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {
     this.requestManager = requestManager;
     this.preloadModelProvider = preloadModelProvider;
     this.preloadDimensionProvider = preloadDimensionProvider;
@@ -148,12 +170,12 @@ private void preload(int from, int to) {
     if (from < to) {
       // Increasing
       for (int i = start; i < end; i++) {
-        preloadAdapterPosition(this.preloadModelProvider.getPreloadItems(i), i, true);
+        preloadAdapterPosition(preloadModelProvider.getPreloadItems(i), i, true);
       }
     } else {
       // Decreasing
       for (int i = end - 1; i >= start; i--) {
-        preloadAdapterPosition(this.preloadModelProvider.getPreloadItems(i), i, false);
+        preloadAdapterPosition(preloadModelProvider.getPreloadItems(i), i, false);
       }
     }
 
@@ -175,13 +197,22 @@ private void preloadAdapterPosition(List<T> items, int position, boolean isIncre
   }
 
   @SuppressWarnings("unchecked")
-  private void preloadItem(T item, int position, int i) {
-    final int[] dimensions = this.preloadDimensionProvider.getPreloadSize(item, position, i);
-    if (dimensions != null) {
-      RequestBuilder<Object> preloadRequestBuilder =
-          this.preloadModelProvider.getPreloadRequestBuilder(item);
-      preloadRequestBuilder.into(preloadTargetQueue.next(dimensions[0], dimensions[1]));
+  private void preloadItem(@Nullable T item, int position, int perItemPosition) {
+    if (item == null) {
+      return;
+    }
+    int[] dimensions =
+        preloadDimensionProvider.getPreloadSize(item, position, perItemPosition);
+    if (dimensions == null) {
+      return;
     }
+    RequestBuilder<Object> preloadRequestBuilder =
+        (RequestBuilder<Object>) preloadModelProvider.getPreloadRequestBuilder(item);
+    if (preloadRequestBuilder == null) {
+      return;
+    }
+
+    preloadRequestBuilder.into(preloadTargetQueue.next(dimensions[0], dimensions[1]));
   }
 
   private void cancelAll() {
@@ -193,7 +224,9 @@ private void cancelAll() {
   private static final class PreloadTargetQueue {
     private final Queue<PreloadTarget> queue;
 
-    public PreloadTargetQueue(int size) {
+    // The loop is short and the only point is to create the objects.
+    @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")
+    PreloadTargetQueue(int size) {
       queue = Util.createQueue(size);
 
       for (int i = 0; i < size; i++) {
@@ -210,7 +243,7 @@ public PreloadTarget next(int width, int height) {
     }
   }
 
-  private static class PreloadTarget extends BaseTarget<Object> {
+  private static final class PreloadTarget extends BaseTarget<Object> {
     @Synthetic int photoHeight;
     @Synthetic int photoWidth;
 
@@ -218,17 +251,18 @@ public PreloadTarget next(int width, int height) {
     PreloadTarget() { }
 
     @Override
-    public void onResourceReady(Object resource, Transition<? super Object> transition) {
+    public void onResourceReady(@NonNull Object resource,
+        @Nullable Transition<? super Object> transition) {
       // Do nothing.
     }
 
     @Override
-    public void getSize(SizeReadyCallback cb) {
+    public void getSize(@NonNull SizeReadyCallback cb) {
       cb.onSizeReady(photoWidth, photoHeight);
     }
 
     @Override
-    public void removeCallback(SizeReadyCallback cb) {
+    public void removeCallback(@NonNull SizeReadyCallback cb) {
       // Do nothing because we don't retain references to SizeReadyCallbacks.
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/MemoryCategory.java b/library/src/main/java/com/bumptech/glide/MemoryCategory.java
index a5781f62d..af84e0454 100644
--- a/library/src/main/java/com/bumptech/glide/MemoryCategory.java
+++ b/library/src/main/java/com/bumptech/glide/MemoryCategory.java
@@ -18,7 +18,7 @@
    */
   HIGH(1.5f);
 
-  private float multiplier;
+  private final float multiplier;
 
   MemoryCategory(float multiplier) {
     this.multiplier = multiplier;
diff --git a/library/src/main/java/com/bumptech/glide/ModelTypes.java b/library/src/main/java/com/bumptech/glide/ModelTypes.java
new file mode 100644
index 000000000..42a14053e
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/ModelTypes.java
@@ -0,0 +1,55 @@
+package com.bumptech.glide;
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import java.io.File;
+import java.net.URL;
+
+/**
+ * Ensures that the set of explicitly supported model types remains consistent across Glide's
+ * API surface.
+ */
+interface ModelTypes<T> {
+  @NonNull
+  @CheckResult
+  T load(@Nullable Bitmap bitmap);
+
+  @NonNull
+  @CheckResult
+  T load(@Nullable Drawable drawable);
+
+  @NonNull
+  @CheckResult
+  T load(@Nullable String string);
+
+  @NonNull
+  @CheckResult
+  T load(@Nullable Uri uri);
+
+  @NonNull
+  @CheckResult
+  T load(@Nullable File file);
+
+  @NonNull
+  @CheckResult
+  T load(@RawRes @DrawableRes @Nullable Integer resourceId);
+
+  @Deprecated
+  @CheckResult
+  T load(@Nullable URL url);
+
+  @NonNull
+  @CheckResult
+  T load(@Nullable byte[] model);
+
+  @NonNull
+  @CheckResult
+  @SuppressWarnings("unchecked")
+  T load(@Nullable Object model);
+}
diff --git a/library/src/main/java/com/bumptech/glide/Registry.java b/library/src/main/java/com/bumptech/glide/Registry.java
index 7468be5be..c5903fcf2 100644
--- a/library/src/main/java/com/bumptech/glide/Registry.java
+++ b/library/src/main/java/com/bumptech/glide/Registry.java
@@ -1,8 +1,11 @@
 package com.bumptech.glide;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.support.v4.util.Pools.Pool;
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.ResourceEncoder;
 import com.bumptech.glide.load.data.DataRewinder;
@@ -23,13 +26,23 @@
 import com.bumptech.glide.provider.ResourceEncoderRegistry;
 import com.bumptech.glide.util.pool.FactoryPools;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 
 /**
- * Manages component registration.
+ * Manages component registration to extend or replace Glide's default loading, decoding, and
+ * encoding logic.
  */
+// Public API.
+@SuppressWarnings({"WeakerAccess", "unused"})
 public class Registry {
+  public static final String BUCKET_GIF = "Gif";
+  public static final String BUCKET_BITMAP = "Bitmap";
+  public static final String BUCKET_BITMAP_DRAWABLE = "BitmapDrawable";
+  private static final String BUCKET_PREPEND_ALL = "legacy_prepend_all";
+  private static final String BUCKET_APPEND_ALL = "legacy_append";
+
   private final ModelLoaderRegistry modelLoaderRegistry;
   private final EncoderRegistry encoderRegistry;
   private final ResourceDecoderRegistry decoderRegistry;
@@ -41,96 +54,431 @@
   private final ModelToResourceClassCache modelToResourceClassCache =
       new ModelToResourceClassCache();
   private final LoadPathCache loadPathCache = new LoadPathCache();
-  private final Pool<List<Exception>> exceptionListPool = FactoryPools.threadSafeList();
+  private final Pool<List<Throwable>> throwableListPool = FactoryPools.threadSafeList();
 
   public Registry() {
-    this.modelLoaderRegistry = new ModelLoaderRegistry(exceptionListPool);
+    this.modelLoaderRegistry = new ModelLoaderRegistry(throwableListPool);
     this.encoderRegistry = new EncoderRegistry();
     this.decoderRegistry = new ResourceDecoderRegistry();
     this.resourceEncoderRegistry = new ResourceEncoderRegistry();
     this.dataRewinderRegistry = new DataRewinderRegistry();
     this.transcoderRegistry = new TranscoderRegistry();
     this.imageHeaderParserRegistry = new ImageHeaderParserRegistry();
+    setResourceDecoderBucketPriorityList(
+        Arrays.asList(BUCKET_GIF, BUCKET_BITMAP, BUCKET_BITMAP_DRAWABLE));
+  }
+
+  /**
+   * Registers the given {@link Encoder} for the given data class (InputStream, FileDescriptor etc).
+   *
+   * <p>The {@link Encoder} will be used both for the exact data class and any subtypes. For
+   * example, registering an {@link Encoder} for {@link java.io.InputStream} will result in the
+   * {@link Encoder} being used for
+   * {@link android.content.res.AssetFileDescriptor.AutoCloseInputStream},
+   * {@link java.io.FileInputStream} and any other subclass.
+   *
+   * <p>If multiple {@link Encoder}s are registered for the same type or super type, the
+   * {@link Encoder} that is registered first will be used.
+   *
+   * @deprecated Use the equivalent {@link #append(Class, Class, ModelLoaderFactory)} method
+   * instead.
+   */
+  @NonNull
+  @Deprecated
+  public <Data> Registry register(@NonNull Class<Data> dataClass, @NonNull Encoder<Data> encoder) {
+    return append(dataClass, encoder);
+  }
+
+  /**
+   * Appends the given {@link Encoder} onto the list of available {@link Encoder}s so that it is
+   * attempted after all earlier and default {@link Encoder}s for the given data class.
+   *
+   * <p>The {@link Encoder} will be used both for the exact data class and any subtypes. For
+   * example, registering an {@link Encoder} for {@link java.io.InputStream} will result in the
+   * {@link Encoder} being used for
+   * {@link android.content.res.AssetFileDescriptor.AutoCloseInputStream},
+   * {@link java.io.FileInputStream} and any other subclass.
+   *
+   * <p>If multiple {@link Encoder}s are registered for the same type or super type, the
+   * {@link Encoder} that is registered first will be used.
+   *
+   * @see #prepend(Class, Encoder)
+   */
+  @NonNull
+  public <Data> Registry append(@NonNull Class<Data> dataClass, @NonNull Encoder<Data> encoder) {
+    encoderRegistry.append(dataClass, encoder);
+    return this;
+  }
+
+  /**
+   * Prepends the given {@link Encoder} into the list of available {@link Encoder}s
+   * so that it is attempted before all later and default {@link Encoder}s for the given
+   * data class.
+   *
+   * <p>This method allows you to replace the default {@link Encoder} because it ensures
+   * the registered {@link Encoder} will run first. If multiple {@link Encoder}s are registered for
+   * the same type or super type, the {@link Encoder} that is registered first will be used.
+   *
+   * @see #append(Class, Encoder)
+   */
+  @NonNull
+  public <Data> Registry prepend(@NonNull Class<Data> dataClass, @NonNull Encoder<Data> encoder) {
+    encoderRegistry.prepend(dataClass, encoder);
+    return this;
+  }
+
+  /**
+   * Appends the given {@link ResourceDecoder} onto the list of all available
+   * {@link ResourceDecoder}s allowing it to be used if all earlier and default
+   * {@link ResourceDecoder}s for the given types fail (or there are none).
+   *
+   * <p>If you're attempting to replace an existing {@link ResourceDecoder} or would like to ensure
+   * that your {@link ResourceDecoder} gets the chance to run before an existing
+   * {@link ResourceDecoder}, use {@link #prepend(Class, Class, ResourceDecoder)}. This method is
+   * best for new types of resources and data or as a way to add an additional fallback decoder
+   * for an existing type of data.
+   *
+   * @see #append(String, Class, Class, ResourceDecoder)
+   * @see #prepend(Class, Class, ResourceDecoder)
+   *
+   * @param dataClass The data that will be decoded from
+   * ({@link java.io.InputStream}, {@link java.io.FileDescriptor} etc).
+   * @param resourceClass The resource that will be decoded to ({@link android.graphics.Bitmap},
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} etc).
+   * @param decoder The {@link ResourceDecoder} to register.
+   */
+  @NonNull
+  public <Data, TResource> Registry append(
+      @NonNull Class<Data> dataClass,
+      @NonNull Class<TResource> resourceClass,
+      @NonNull ResourceDecoder<Data, TResource> decoder) {
+    append(BUCKET_APPEND_ALL, dataClass, resourceClass, decoder);
+    return this;
+  }
+
+  /**
+   * Appends the given {@link ResourceDecoder} onto the list of available {@link ResourceDecoder}s
+   * in this bucket, allowing it to be used if all earlier and default {@link ResourceDecoder}s for
+   * the given types in this bucket fail (or there are none).
+   *
+   * <p>If you're attempting to replace an existing {@link ResourceDecoder} or would like to ensure
+   * that your {@link ResourceDecoder} gets the chance to run before an existing
+   * {@link ResourceDecoder}, use {@link #prepend(Class, Class, ResourceDecoder)}. This method is
+   * best for new types of resources and data or as a way to add an additional fallback decoder
+   * for an existing type of data.
+   *
+   * @see #prepend(String, Class, Class, ResourceDecoder)
+   * @see #setResourceDecoderBucketPriorityList(List)
+   *
+   * @param bucket The bucket identifier to add this decoder to.
+   * @param dataClass The data that will be decoded from
+   * ({@link java.io.InputStream}, {@link java.io.FileDescriptor} etc).
+   * @param resourceClass The resource that will be decoded to ({@link android.graphics.Bitmap},
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} etc).
+   * @param decoder The {@link ResourceDecoder} to register.
+   */
+  @NonNull
+  public <Data, TResource> Registry append(
+      @NonNull String bucket,
+      @NonNull Class<Data> dataClass,
+      @NonNull Class<TResource> resourceClass,
+      @NonNull ResourceDecoder<Data, TResource> decoder) {
+    decoderRegistry.append(bucket, decoder, dataClass, resourceClass);
+    return this;
+  }
+
+  /**
+   * Prepends the given {@link ResourceDecoder} into the list of all available
+   * {@link ResourceDecoder}s so that it is attempted before all later and default
+   * {@link ResourceDecoder}s for the given types.
+   *
+   * <p>This method allows you to replace the default {@link ResourceDecoder} because it ensures
+   * the registered {@link ResourceDecoder} will run first. You can use the
+   * {@link ResourceDecoder#handles(Object, Options)} to fall back to the default
+   * {@link ResourceDecoder}s if you only want to change the default functionality for certain
+   * types of data.
+   *
+   * @see #prepend(String, Class, Class, ResourceDecoder)
+   * @see #append(Class, Class, ResourceDecoder)
+   *
+   * @param dataClass The data that will be decoded from
+   * ({@link java.io.InputStream}, {@link java.io.FileDescriptor} etc).
+   * @param resourceClass The resource that will be decoded to ({@link android.graphics.Bitmap},
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} etc).
+   * @param decoder The {@link ResourceDecoder} to register.
+   */
+  @NonNull
+  public <Data, TResource> Registry prepend(
+      @NonNull Class<Data> dataClass,
+      @NonNull Class<TResource> resourceClass,
+      @NonNull ResourceDecoder<Data, TResource> decoder) {
+    prepend(BUCKET_PREPEND_ALL, dataClass, resourceClass, decoder);
+    return this;
   }
 
-  public <Data> Registry register(Class<Data> dataClass, Encoder<Data> encoder) {
-    encoderRegistry.add(dataClass, encoder);
+  /**
+   * Prepends the given {@link ResourceDecoder} into the list of available {@link ResourceDecoder}s
+   * in the same bucket so that it is attempted before all later and default
+   * {@link ResourceDecoder}s for the given types in that bucket.
+   *
+   * <p>This method allows you to replace the default {@link ResourceDecoder} for this bucket
+   * because it ensures the registered {@link ResourceDecoder} will run first. You can use the
+   * {@link ResourceDecoder#handles(Object, Options)} to fall back to the default
+   * {@link ResourceDecoder}s if you only want to change the default functionality for certain
+   * types of data.
+   *
+   * @see #append(String, Class, Class, ResourceDecoder)
+   * @see #setResourceDecoderBucketPriorityList(List)
+   *
+   * @param bucket The bucket identifier to add this decoder to.
+   * @param dataClass The data that will be decoded from
+   * ({@link java.io.InputStream}, {@link java.io.FileDescriptor} etc).
+   * @param resourceClass The resource that will be decoded to ({@link android.graphics.Bitmap},
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} etc).
+   * @param decoder The {@link ResourceDecoder} to register.
+   */
+  @NonNull
+  public <Data, TResource> Registry prepend(
+      @NonNull String bucket,
+      @NonNull Class<Data> dataClass,
+      @NonNull Class<TResource> resourceClass,
+      @NonNull ResourceDecoder<Data, TResource> decoder) {
+    decoderRegistry.prepend(bucket, decoder, dataClass, resourceClass);
     return this;
   }
 
-  public <Data, TResource> Registry append(Class<Data> dataClass, Class<TResource> resourceClass,
-      ResourceDecoder<Data, TResource> decoder) {
-    decoderRegistry.append(decoder, dataClass, resourceClass);
+  /**
+   * Overrides the default ordering of resource decoder buckets. You may also add custom buckets
+   * which are identified as a unique string. Glide will attempt to decode using decoders in the
+   * highest priority bucket before moving on to the next one.
+   *
+   * <p>The default order is [{@link #BUCKET_GIF}, {@link #BUCKET_BITMAP},
+   * {@link #BUCKET_BITMAP_DRAWABLE}].
+   *
+   * <p>When registering decoders, you can use these buckets to specify the ordering relative only
+   * to other decoders in that bucket.
+   * @see #append(String, Class, Class, ResourceDecoder)
+   * @see #prepend(String, Class, Class, ResourceDecoder)
+   *
+   * @param buckets The list of bucket identifiers in order from highest priority to least priority.
+   */
+  // Final to avoid a PMD error.
+  @NonNull
+  public final Registry setResourceDecoderBucketPriorityList(@NonNull List<String> buckets) {
+    // See #3296 and https://bugs.openjdk.java.net/browse/JDK-6260652.
+    List<String> modifiedBuckets = new ArrayList<>(buckets.size());
+    modifiedBuckets.addAll(buckets);
+    modifiedBuckets.add(0, BUCKET_PREPEND_ALL);
+    modifiedBuckets.add(BUCKET_APPEND_ALL);
+    decoderRegistry.setBucketPriorityList(modifiedBuckets);
     return this;
   }
 
-  public <Data, TResource> Registry prepend(Class<Data> dataClass, Class<TResource> resourceClass,
-      ResourceDecoder<Data, TResource> decoder) {
-    decoderRegistry.prepend(decoder, dataClass, resourceClass);
+  /**
+   * Appends the given {@link ResourceEncoder} into the list of available {@link ResourceEncoder}s
+   * so that it is attempted after all earlier and default {@link ResourceEncoder}s for the given
+   * data type.
+   *
+   * <p>The {@link ResourceEncoder} will be used both for the exact resource class and any subtypes.
+   * For example, registering an {@link ResourceEncoder} for
+   * {@link android.graphics.drawable.Drawable} (not recommended) will result in the
+   * {@link ResourceEncoder} being used for {@link android.graphics.drawable.BitmapDrawable} and
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} and any other subclass.
+   *
+   * <p>If multiple {@link ResourceEncoder}s are registered for the same type or super type, the
+   * {@link ResourceEncoder} that is registered first will be used.
+   *
+   * @deprecated Use the equivalent {@link #append(Class, ResourceEncoder)} method instead.
+   */
+  @NonNull
+  @Deprecated
+  public <TResource> Registry register(
+      @NonNull Class<TResource> resourceClass, @NonNull ResourceEncoder<TResource> encoder) {
+    return append(resourceClass, encoder);
+  }
+
+  /**
+   * Appends the given {@link ResourceEncoder} into the list of available {@link ResourceEncoder}s
+   * so that it is attempted after all earlier and default {@link ResourceEncoder}s for the given
+   * data type.
+   *
+   * <p>The {@link ResourceEncoder} will be used both for the exact resource class and any subtypes.
+   * For example, registering an {@link ResourceEncoder} for
+   * {@link android.graphics.drawable.Drawable} (not recommended) will result in the
+   * {@link ResourceEncoder} being used for {@link android.graphics.drawable.BitmapDrawable} and
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} and any other subclass.
+   *
+   * <p>If multiple {@link ResourceEncoder}s are registered for the same type or super type, the
+   * {@link ResourceEncoder} that is registered first will be used.
+   *
+   * @see #prepend(Class, ResourceEncoder)
+   */
+  @NonNull
+  public <TResource> Registry append(
+      @NonNull Class<TResource> resourceClass, @NonNull ResourceEncoder<TResource> encoder) {
+    resourceEncoderRegistry.append(resourceClass, encoder);
     return this;
   }
 
-  public <TResource> Registry register(Class<TResource> resourceClass,
-      ResourceEncoder<TResource> encoder) {
-    resourceEncoderRegistry.add(resourceClass, encoder);
+  /**
+   * Prepends the given {@link ResourceEncoder} into the list of available {@link ResourceEncoder}s
+   * so that it is attempted before all later and default {@link ResourceEncoder}s for the given
+   * data type.
+   *
+   * <p>This method allows you to replace the default {@link ResourceEncoder} because it ensures
+   * the registered {@link ResourceEncoder} will run first. If multiple {@link ResourceEncoder}s are
+   * registered for the same type or super type, the {@link ResourceEncoder} that is registered
+   * first will be used.
+   *
+   * @see #append(Class, ResourceEncoder)
+   */
+  @NonNull
+  public <TResource> Registry prepend(
+      @NonNull Class<TResource> resourceClass, @NonNull ResourceEncoder<TResource> encoder) {
+    resourceEncoderRegistry.prepend(resourceClass, encoder);
     return this;
   }
 
-  public Registry register(DataRewinder.Factory factory) {
+  /**
+   * Registers a new {@link com.bumptech.glide.load.data.DataRewinder.Factory} to handle a
+   * non-default data type that can be rewind to allow for efficient reads of file headers.
+   */
+  @NonNull
+  public Registry register(@NonNull DataRewinder.Factory<?> factory) {
     dataRewinderRegistry.register(factory);
     return this;
   }
 
-  public <TResource, Transcode> Registry register(Class<TResource> resourceClass,
-      Class<Transcode> transcodeClass, ResourceTranscoder<TResource, Transcode> transcoder) {
+  /**
+   * Registers the given {@link ResourceTranscoder} to convert from the given resource {@link Class}
+   * to the given transcode {@link Class}.
+   *
+   * @param resourceClass The class that will be transcoded from (e.g.
+   * {@link android.graphics.Bitmap}).
+   * @param transcodeClass The class that will be transcoded to (e.g.
+   * {@link android.graphics.drawable.BitmapDrawable}).
+   * @param transcoder The {@link ResourceTranscoder} to register.
+   */
+  @NonNull
+  public <TResource, Transcode> Registry register(
+      @NonNull Class<TResource> resourceClass, @NonNull Class<Transcode> transcodeClass,
+      @NonNull ResourceTranscoder<TResource, Transcode> transcoder) {
     transcoderRegistry.register(resourceClass, transcodeClass, transcoder);
     return this;
   }
 
-  public Registry register(ImageHeaderParser parser) {
+  /**
+   * Registers a new {@link ImageHeaderParser} that can obtain some basic metadata from an image
+   * header (orientation, type etc).
+   */
+  @NonNull
+  public Registry register(@NonNull ImageHeaderParser parser) {
     imageHeaderParserRegistry.add(parser);
     return this;
   }
 
   /**
-   * Use the given factory to build a {@link com.bumptech.glide.load.model.ModelLoader} for models
-   * of the given class. Generally the best use of this method is to replace one of the default
-   * factories or add an implementation for other similar low level models. Any factory replaced by
-   * the given factory will have its {@link ModelLoaderFactory#teardown()}} method called.
+   * Appends a new {@link ModelLoaderFactory} onto the end of the existing set so that the
+   * constructed {@link ModelLoader} will be tried after all default and previously registered
+   * {@link ModelLoader}s for the given model and data classes.
    *
-   * <p> Note - If a factory already exists for the given class, it will be replaced. If that
-   * factory is not being used for any other model class, {@link ModelLoaderFactory#teardown()} will
-   * be called. </p>
+   * <p>If you're attempting to replace an existing {@link ModelLoader}, use
+   * {@link #prepend(Class, Class, ModelLoaderFactory)}. This method is best for new types of models
+   * and/or data or as a way to add an additional fallback loader for an existing type of
+   * model/data.
    *
-   * <p> Note - The factory must not be an anonymous inner class of an Activity or another object
-   * that cannot be retained statically. </p>
+   * <p>If multiple {@link ModelLoaderFactory}s are registered for the same model and/or data
+   * classes, the {@link ModelLoader}s they produce will be attempted in the order the
+   * {@link ModelLoaderFactory}s were registered. Only if all {@link ModelLoader}s fail will the
+   * entire request fail.
    *
-   * @param modelClass The model class.
-   * @param dataClass  the data class.
+   * @see #prepend(Class, Class, ModelLoaderFactory)
+   * @see #replace(Class, Class, ModelLoaderFactory)
+   *
+   * @param modelClass The model class (e.g. URL, file path).
+   * @param dataClass  the data class (e.g. {@link java.io.InputStream},
+   * {@link java.io.FileDescriptor}).
    */
-  public <Model, Data> Registry append(Class<Model> modelClass, Class<Data> dataClass,
-      ModelLoaderFactory<Model, Data> factory) {
+  @NonNull
+  public <Model, Data> Registry append(
+      @NonNull Class<Model> modelClass, @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<Model, Data> factory) {
     modelLoaderRegistry.append(modelClass, dataClass, factory);
     return this;
   }
 
-  public <Model, Data> Registry prepend(Class<Model> modelClass, Class<Data> dataClass,
-      ModelLoaderFactory<Model, Data> factory) {
+  /**
+   * Prepends a new {@link ModelLoaderFactory} onto the beginning of the existing set so that the
+   * constructed {@link ModelLoader} will be tried before all default and previously registered
+   * {@link ModelLoader}s for the given model and data classes.
+   *
+   * <p>If you're attempting to add additional functionality or add a backup that should run only
+   * after the default {@link ModelLoader}s run, use
+   * {@link #append(Class, Class, ModelLoaderFactory)}. This method is best for adding an additional
+   * case to Glide's existing functionality that should run first. This method will still run
+   * Glide's default {@link ModelLoader}s if the prepended {@link ModelLoader}s fail.
+   *
+   * <p>If multiple {@link ModelLoaderFactory}s are registered for the same model and/or data
+   * classes, the {@link ModelLoader}s they produce will be attempted in the order the
+   * {@link ModelLoaderFactory}s were registered. Only if all {@link ModelLoader}s fail will the
+   * entire request fail.
+   *
+   * @see #append(Class, Class, ModelLoaderFactory)
+   * @see #replace(Class, Class, ModelLoaderFactory)
+   *
+   * @param modelClass The model class (e.g. URL, file path).
+   * @param dataClass  the data class (e.g. {@link java.io.InputStream},
+   * {@link java.io.FileDescriptor}).
+   */
+  @NonNull
+  public <Model, Data> Registry prepend(
+      @NonNull Class<Model> modelClass, @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<Model, Data> factory) {
     modelLoaderRegistry.prepend(modelClass, dataClass, factory);
     return this;
   }
 
-  public <Model, Data> Registry replace(Class<Model> modelClass, Class<Data> dataClass,
-      ModelLoaderFactory<Model, Data> factory) {
+  /**
+   * Removes all default and previously registered {@link ModelLoaderFactory}s for the given data
+   * and model class and replaces all of them with the single {@link ModelLoader} provided.
+   *
+   * <p>If you're attempting to add additional functionality or add a backup that should run only
+   * after the default {@link ModelLoader}s run, use
+   * {@link #append(Class, Class, ModelLoaderFactory)}. This method should be used only when you
+   * want to ensure that Glide's default {@link ModelLoader}s do not run.
+   *
+   * <p>One good use case for this method is when you want to replace Glide's default networking
+   * library with your OkHttp, Volley, or your own implementation. Using
+   * {@link #prepend(Class, Class, ModelLoaderFactory)} or
+   * {@link #append(Class, Class, ModelLoaderFactory)} may still allow Glide's default networking
+   * library to run in some cases. Using this method will ensure that only your networking library
+   * will run and that the request will fail otherwise.
+   *
+   * @see #prepend(Class, Class, ModelLoaderFactory)
+   * @see #append(Class, Class, ModelLoaderFactory)
+   *
+   * @param modelClass The model class (e.g. URL, file path).
+   * @param dataClass  the data class (e.g. {@link java.io.InputStream},
+   * {@link java.io.FileDescriptor}).
+   */
+  @NonNull
+  public <Model, Data> Registry replace(
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<? extends Model, ? extends Data> factory) {
     modelLoaderRegistry.replace(modelClass, dataClass, factory);
     return this;
   }
 
+  @Nullable
   public <Data, TResource, Transcode> LoadPath<Data, TResource, Transcode> getLoadPath(
-      Class<Data> dataClass, Class<TResource> resourceClass, Class<Transcode> transcodeClass) {
+      @NonNull Class<Data> dataClass, @NonNull Class<TResource> resourceClass,
+      @NonNull Class<Transcode> transcodeClass) {
     LoadPath<Data, TResource, Transcode> result =
         loadPathCache.get(dataClass, resourceClass, transcodeClass);
-    if (result == null && !loadPathCache.contains(dataClass, resourceClass, transcodeClass)) {
+    if (loadPathCache.isEmptyLoadPath(result)) {
+      return null;
+    } else if (result == null) {
       List<DecodePath<Data, TResource, Transcode>> decodePaths =
           getDecodePaths(dataClass, resourceClass, transcodeClass);
       // It's possible there is no way to decode or transcode to the desired types from a given
@@ -138,17 +486,19 @@ public Registry register(ImageHeaderParser parser) {
       if (decodePaths.isEmpty()) {
         result = null;
       } else {
-        result = new LoadPath<>(dataClass, resourceClass, transcodeClass, decodePaths,
-            exceptionListPool);
+        result =
+            new LoadPath<>(
+                dataClass, resourceClass, transcodeClass, decodePaths, throwableListPool);
       }
       loadPathCache.put(dataClass, resourceClass, transcodeClass, result);
     }
     return result;
   }
 
+  @NonNull
   private <Data, TResource, Transcode> List<DecodePath<Data, TResource, Transcode>> getDecodePaths(
-      Class<Data> dataClass, Class<TResource> resourceClass, Class<Transcode> transcodeClass) {
-
+      @NonNull Class<Data> dataClass, @NonNull Class<TResource> resourceClass,
+      @NonNull Class<Transcode> transcodeClass) {
     List<DecodePath<Data, TResource, Transcode>> decodePaths = new ArrayList<>();
     List<Class<TResource>> registeredResourceClasses =
         decoderRegistry.getResourceClasses(dataClass, resourceClass);
@@ -163,16 +513,23 @@ public Registry register(ImageHeaderParser parser) {
             decoderRegistry.getDecoders(dataClass, registeredResourceClass);
         ResourceTranscoder<TResource, Transcode> transcoder =
             transcoderRegistry.get(registeredResourceClass, registeredTranscodeClass);
-        decodePaths.add(new DecodePath<>(dataClass, registeredResourceClass,
-            registeredTranscodeClass, decoders, transcoder, exceptionListPool));
+        @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")
+        DecodePath<Data, TResource, Transcode> path =
+            new DecodePath<>(dataClass, registeredResourceClass, registeredTranscodeClass,
+                decoders, transcoder, throwableListPool);
+        decodePaths.add(path);
       }
     }
     return decodePaths;
   }
 
+  @NonNull
   public <Model, TResource, Transcode> List<Class<?>> getRegisteredResourceClasses(
-      Class<Model> modelClass, Class<TResource> resourceClass, Class<Transcode> transcodeClass) {
-    List<Class<?>> result = modelToResourceClassCache.get(modelClass, resourceClass);
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<TResource> resourceClass,
+      @NonNull Class<Transcode> transcodeClass) {
+    List<Class<?>> result =
+        modelToResourceClassCache.get(modelClass, resourceClass, transcodeClass);
 
     if (result == null) {
       result = new ArrayList<>();
@@ -184,22 +541,23 @@ public Registry register(ImageHeaderParser parser) {
           List<Class<Transcode>> registeredTranscodeClasses = transcoderRegistry
               .getTranscodeClasses(registeredResourceClass, transcodeClass);
           if (!registeredTranscodeClasses.isEmpty() && !result.contains(registeredResourceClass)) {
-              result.add(registeredResourceClass);
+            result.add(registeredResourceClass);
           }
         }
       }
-      modelToResourceClassCache.put(modelClass, resourceClass,
-          Collections.unmodifiableList(result));
+      modelToResourceClassCache.put(
+          modelClass, resourceClass, transcodeClass, Collections.unmodifiableList(result));
     }
 
     return result;
   }
 
-  public boolean isResourceEncoderAvailable(Resource<?> resource) {
+  public boolean isResourceEncoderAvailable(@NonNull Resource<?> resource) {
     return resourceEncoderRegistry.get(resource.getResourceClass()) != null;
   }
 
-  public <X> ResourceEncoder<X> getResultEncoder(Resource<X> resource)
+  @NonNull
+  public <X> ResourceEncoder<X> getResultEncoder(@NonNull Resource<X> resource)
       throws NoResultEncoderAvailableException {
     ResourceEncoder<X> resourceEncoder = resourceEncoderRegistry.get(resource.getResourceClass());
     if (resourceEncoder != null) {
@@ -208,8 +566,9 @@ public boolean isResourceEncoderAvailable(Resource<?> resource) {
     throw new NoResultEncoderAvailableException(resource.getResourceClass());
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
-  public <X> Encoder<X> getSourceEncoder(X data) throws NoSourceEncoderAvailableException {
+  public <X> Encoder<X> getSourceEncoder(@NonNull X data) throws NoSourceEncoderAvailableException {
     Encoder<X> encoder = encoderRegistry.getEncoder((Class<X>) data.getClass());
     if (encoder != null) {
       return encoder;
@@ -217,11 +576,13 @@ public boolean isResourceEncoderAvailable(Resource<?> resource) {
     throw new NoSourceEncoderAvailableException(data.getClass());
   }
 
-  public <X> DataRewinder<X> getRewinder(X data) {
+  @NonNull
+  public <X> DataRewinder<X> getRewinder(@NonNull X data) {
     return dataRewinderRegistry.build(data);
   }
 
-  public <Model> List<ModelLoader<Model, ?>> getModelLoaders(Model model) {
+  @NonNull
+  public <Model> List<ModelLoader<Model, ?>> getModelLoaders(@NonNull Model model) {
     List<ModelLoader<Model, ?>> result = modelLoaderRegistry.getModelLoaders(model);
     if (result.isEmpty()) {
       throw new NoModelLoaderAvailableException(model);
@@ -229,6 +590,7 @@ public boolean isResourceEncoderAvailable(Resource<?> resource) {
     return result;
   }
 
+  @NonNull
   public List<ImageHeaderParser> getImageHeaderParsers() {
     List<ImageHeaderParser> result = imageHeaderParserRegistry.getParsers();
     if (result.isEmpty()) {
@@ -241,12 +603,15 @@ public boolean isResourceEncoderAvailable(Resource<?> resource) {
    * Thrown when no {@link com.bumptech.glide.load.model.ModelLoader} is registered for a given
    * model class.
    */
+  // Never serialized by Glide.
+  @SuppressWarnings("serial")
   public static class NoModelLoaderAvailableException extends MissingComponentException {
-    public NoModelLoaderAvailableException(Object model) {
+    public NoModelLoaderAvailableException(@NonNull Object model) {
       super("Failed to find any ModelLoaders for model: " + model);
     }
 
-    public NoModelLoaderAvailableException(Class<?> modelClass, Class<?> dataClass) {
+    public NoModelLoaderAvailableException(@NonNull Class<?> modelClass,
+        @NonNull Class<?> dataClass) {
       super("Failed to find any ModelLoaders for model: " + modelClass + " and data: " + dataClass);
     }
   }
@@ -254,17 +619,24 @@ public NoModelLoaderAvailableException(Class<?> modelClass, Class<?> dataClass)
   /**
    * Thrown when no {@link ResourceEncoder} is registered for a given resource class.
    */
+  // Never serialized by Glide.
+  @SuppressWarnings("serial")
   public static class NoResultEncoderAvailableException extends MissingComponentException {
-    public NoResultEncoderAvailableException(Class<?> resourceClass) {
-      super("Failed to find result encoder for resource class: " + resourceClass);
+    public NoResultEncoderAvailableException(@NonNull Class<?> resourceClass) {
+      super("Failed to find result encoder for resource class: " + resourceClass
+          + ", you may need to consider registering a new Encoder for the requested type or"
+          + " DiskCacheStrategy.DATA/DiskCacheStrategy.NONE if caching your transformed resource is"
+          + " unnecessary.");
     }
   }
 
   /**
    * Thrown when no {@link Encoder} is registered for a given data class.
    */
+  // Never serialized by Glide.
+  @SuppressWarnings("serial")
   public static class NoSourceEncoderAvailableException extends MissingComponentException {
-    public NoSourceEncoderAvailableException(Class<?> dataClass) {
+    public NoSourceEncoderAvailableException(@NonNull Class<?> dataClass) {
       super("Failed to find source encoder for data class: " + dataClass);
     }
   }
@@ -272,8 +644,10 @@ public NoSourceEncoderAvailableException(Class<?> dataClass) {
   /**
    * Thrown when some necessary component is missing for a load.
    */
+  // Never serialized by Glide.
+  @SuppressWarnings("serial")
   public static class MissingComponentException extends RuntimeException {
-    public MissingComponentException(String message) {
+    public MissingComponentException(@NonNull String message) {
       super(message);
     }
   }
@@ -281,6 +655,8 @@ public MissingComponentException(String message) {
   /**
    * Thrown when no {@link ImageHeaderParser} is registered.
    */
+  // Never serialized by Glide.
+  @SuppressWarnings("serial")
   public static final class NoImageHeaderParserException extends MissingComponentException {
     public NoImageHeaderParserException() {
       super("Failed to find image header parser.");
diff --git a/library/src/main/java/com/bumptech/glide/RequestBuilder.java b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
index 62e7db0eb..a01d45500 100644
--- a/library/src/main/java/com/bumptech/glide/RequestBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
@@ -1,12 +1,24 @@
 package com.bumptech.glide;
 
+import static com.bumptech.glide.request.RequestOptions.diskCacheStrategyOf;
 import static com.bumptech.glide.request.RequestOptions.signatureOf;
+import static com.bumptech.glide.request.RequestOptions.skipMemoryCacheOf;
 
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
 import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
 import android.widget.ImageView;
+import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.ErrorRequestCoordinator;
 import com.bumptech.glide.request.FutureTarget;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.RequestCoordinator;
@@ -17,13 +29,15 @@
 import com.bumptech.glide.request.ThumbnailRequestCoordinator;
 import com.bumptech.glide.request.target.PreloadTarget;
 import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.request.target.ViewTarget;
 import com.bumptech.glide.signature.ApplicationVersionSignature;
-import com.bumptech.glide.signature.ObjectKey;
 import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
 import java.io.File;
 import java.net.URL;
-import java.util.UUID;
+import java.util.ArrayList;
+import java.util.List;
 
 /**
  * A generic class that can handle setting options and staring loads for generic resource types.
@@ -31,19 +45,21 @@
  * @param <TranscodeType> The type of resource that will be delivered to the
  * {@link com.bumptech.glide.request.target.Target}.
  */
-public class RequestBuilder<TranscodeType> implements Cloneable {
+// Public API.
+@SuppressWarnings({"unused", "WeakerAccess"})
+public class RequestBuilder<TranscodeType> extends BaseRequestOptions<RequestBuilder<TranscodeType>>
+    implements Cloneable,
+    ModelTypes<RequestBuilder<TranscodeType>> {
   // Used in generated subclasses
   protected static final RequestOptions DOWNLOAD_ONLY_OPTIONS =
       new RequestOptions().diskCacheStrategy(DiskCacheStrategy.DATA).priority(Priority.LOW)
           .skipMemoryCache(true);
 
-  private final GlideContext context;
+  private final Context context;
   private final RequestManager requestManager;
   private final Class<TranscodeType> transcodeClass;
-  private final RequestOptions defaultRequestOptions;
   private final Glide glide;
-
-  @NonNull protected RequestOptions requestOptions;
+  private final GlideContext glideContext;
 
   @NonNull
   @SuppressWarnings("unchecked")
@@ -52,47 +68,69 @@
   @Nullable private Object model;
   // model may occasionally be null, so to enforce that load() was called, put a boolean rather
   // than relying on model not to be null.
-  @Nullable private RequestListener<TranscodeType> requestListener;
+  @Nullable private List<RequestListener<TranscodeType>> requestListeners;
   @Nullable private RequestBuilder<TranscodeType> thumbnailBuilder;
+  @Nullable private RequestBuilder<TranscodeType> errorBuilder;
   @Nullable private Float thumbSizeMultiplier;
   private boolean isDefaultTransitionOptionsSet = true;
   private boolean isModelSet;
   private boolean isThumbnailBuilt;
 
-  protected RequestBuilder(Glide glide, RequestManager requestManager,
-      Class<TranscodeType> transcodeClass) {
+  // We only override the method to change the return type, not the functionality.
+  @SuppressLint("CheckResult")
+  @SuppressWarnings("PMD.ConstructorCallsOverridableMethod")
+  protected RequestBuilder(
+      @NonNull Glide glide,
+      RequestManager requestManager,
+      Class<TranscodeType> transcodeClass,
+      Context context) {
     this.glide = glide;
     this.requestManager = requestManager;
-    this.context = glide.getGlideContext();
     this.transcodeClass = transcodeClass;
-    this.defaultRequestOptions = requestManager.getDefaultRequestOptions();
+    this.context = context;
     this.transitionOptions = requestManager.getDefaultTransitionOptions(transcodeClass);
-    this.requestOptions = defaultRequestOptions;
+    this.glideContext = glide.getGlideContext();
+
+    initRequestListeners(requestManager.getDefaultRequestListeners());
+    apply(requestManager.getDefaultRequestOptions());
   }
 
+  @SuppressWarnings("PMD.ConstructorCallsOverridableMethod")
   protected RequestBuilder(Class<TranscodeType> transcodeClass, RequestBuilder<?> other) {
-    this(other.glide, other.requestManager, transcodeClass);
+    this(other.glide, other.requestManager, transcodeClass, other.context);
     model = other.model;
     isModelSet = other.isModelSet;
-    requestOptions = other.requestOptions;
+
+    apply(other);
+  }
+
+  // Casting from Object to a specific type is always safe.
+  @SuppressWarnings("unchecked")
+  // addListener always returns the same instance.
+  @SuppressLint("CheckResult")
+  private void initRequestListeners(List<RequestListener<Object>> requestListeners) {
+    for (RequestListener<Object> listener : requestListeners) {
+      addListener((RequestListener<TranscodeType>) listener);
+    }
   }
 
   /**
-   * Applies the given options to the request, options set or unset in the given options will
-   * replace those previously set in options in this class.
+   * Applies the given options to the request.
    *
-   * @see RequestOptions#apply(RequestOptions)
+   * <p>As with {@link RequestOptions#apply(BaseRequestOptions)}, {@code #apply} only replaces those
+   * values that are explicitly set in the given {@link RequestOptions} object. If you need to
+   * completely reset all previously set options, create a new {@code RequestBuilder} instead of
+   * using this method.
+   *
+   * @see RequestOptions#apply(BaseRequestOptions)
    * @return This request builder.
    */
-  public RequestBuilder<TranscodeType> apply(@NonNull RequestOptions requestOptions) {
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<TranscodeType> apply(@NonNull BaseRequestOptions<?> requestOptions) {
     Preconditions.checkNotNull(requestOptions);
-    this.requestOptions = getMutableOptions().apply(requestOptions);
-    return this;
-  }
-
-  protected RequestOptions getMutableOptions() {
-    return defaultRequestOptions == this.requestOptions
-        ? this.requestOptions.clone() : this.requestOptions;
+    return super.apply(requestOptions);
   }
 
   /**
@@ -104,6 +142,8 @@ protected RequestOptions getMutableOptions() {
    *
    * @return This request builder.
    */
+  @NonNull
+  @CheckResult
   public RequestBuilder<TranscodeType> transition(
       @NonNull TransitionOptions<?, ? super TranscodeType> transitionOptions) {
     this.transitionOptions = Preconditions.checkNotNull(transitionOptions);
@@ -112,18 +152,70 @@ protected RequestOptions getMutableOptions() {
   }
 
   /**
-   * Sets a RequestBuilder listener to monitor the resource load. It's best to create a single
+   * Sets a {@link RequestListener} to monitor the resource load. It's best to create a single
    * instance of an exception handler per type of request (usually activity/fragment) rather than
    * pass one in per request to avoid some redundant object allocation.
    *
+   * <p>Subsequent calls to this method will replace previously set listeners. To set multiple
+   * listeners, use {@link #addListener} instead.
+   *
    * @param requestListener The request listener to use.
    * @return This request builder.
    */
+  @NonNull
+  @CheckResult
   @SuppressWarnings("unchecked")
   public RequestBuilder<TranscodeType> listener(
       @Nullable RequestListener<TranscodeType> requestListener) {
-    this.requestListener = requestListener;
+    this.requestListeners = null;
+    return addListener(requestListener);
+  }
+
+  /**
+   * Adds a {@link RequestListener}. If called multiple times, all passed
+   * {@link RequestListener listeners} will be called in order.
+   *
+   * @param requestListener The request listener to use. If {@code null}, this method is a noop.
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public RequestBuilder<TranscodeType> addListener(
+      @Nullable RequestListener<TranscodeType> requestListener) {
+    if (requestListener != null) {
+      if (this.requestListeners == null) {
+        this.requestListeners = new ArrayList<>();
+      }
+      this.requestListeners.add(requestListener);
+    }
+    return this;
+  }
 
+  /**
+   * Sets a {@link RequestBuilder} that is built and run if the load started by this
+   * {@link RequestBuilder} fails.
+   *
+   * <p>If this {@link RequestBuilder} uses a thumbnail that succeeds the given error
+   * {@link RequestBuilder} will be started anyway if the non-thumbnail request fails.
+   *
+   * <p>Recursive calls to this method as well as calls to {@link #thumbnail(float)} and
+   * {@link #thumbnail(RequestBuilder)} are supported for the given error {@link RequestBuilder}.
+   *
+   * <p>Unlike {@link #thumbnail(RequestBuilder)} and {@link #thumbnail(float)}, no options from
+   * this primary {@link RequestBuilder} are propagated to the given error {@link RequestBuilder}.
+   * Options like priority, override widths and heights and transitions must be applied
+   * independently to the error builder.
+   *
+   * <p>The given {@link RequestBuilder} will start and potentially override a fallback drawable
+   * if it's set on this {@link RequestBuilder} via
+   * {@link RequestOptions#fallback(android.graphics.drawable.Drawable)} or
+   * {@link RequestOptions#fallback(int)}.
+   *
+   * @return This {@link RequestBuilder}.
+   */
+  @NonNull
+  public RequestBuilder<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> errorBuilder) {
+    this.errorBuilder = errorBuilder;
     return this;
   }
 
@@ -134,12 +226,19 @@ protected RequestOptions getMutableOptions() {
    * requests will actually finish. However, if the thumb request completes after the full request,
    * the thumb resource will never replace the full resource.
    *
-   * @param thumbnailRequest The request to use to load the thumbnail.
-   * @return This request builder.
+   * <p>Recursive calls to thumbnail are supported.
+   *
+   * <p>Overrides any previous calls to this method, {@link #thumbnail(float)} and
+   * {@link #thumbnail(RequestBuilder[])}.
+   *
    * @see #thumbnail(float)
+   * @see #thumbnail(RequestBuilder[])
    *
-   * <p> Recursive calls to thumbnail are supported. </p>
+   * @param thumbnailRequest The request to use to load the thumbnail.
+   * @return This request builder.
    */
+  @NonNull
+  @CheckResult
   @SuppressWarnings("unchecked")
   public RequestBuilder<TranscodeType> thumbnail(
       @Nullable RequestBuilder<TranscodeType> thumbnailRequest) {
@@ -148,30 +247,99 @@ protected RequestOptions getMutableOptions() {
     return this;
   }
 
+  /**
+   * Recursively applies {@link #thumbnail(RequestBuilder)} so that the {@link RequestBuilder}s are
+   * loaded as thumbnails in the given priority order.
+   *
+   * <p>{@link #thumbnail(RequestBuilder)} is applied in the order given so that the
+   * {@link RequestBuilder} at position 0 has the {@link RequestBuilder} at position 1 applied
+   * as using its thumbnail method, the {@link RequestBuilder} at position 1 has the
+   * {@link RequestBuilder} at position 2 applied using its thumbnail method and so on.
+   *
+   * <p>Calling this method with an {@code null} array of {@link RequestBuilder} thumbnails or
+   * an empty array of {@link RequestBuilder} thumbnails is equivalent to calling
+   * {@link #thumbnail(RequestBuilder)} with {@code null}.
+   *
+   * <p>Any individual {@link RequestBuilder} in the array of thumbnails provided here may be
+   * {@code null}. {@code null} {@link RequestBuilder}s are ignored and excluded from the recursive
+   * chain.
+   *
+   * <p>The {@link RequestBuilder} objects provided here may be mutated and have any previous
+   * calls to this method or {@link #thumbnail(RequestBuilder)} methods overridden.
+   *
+   * <p>Overrides any previous calls to {@link #thumbnail(RequestBuilder)},
+   * {@link #thumbnail(float)} and this method.
+   *
+   * @see #thumbnail(float)
+   * @see #thumbnail(RequestBuilder)
+   *
+   * @return This request builder.
+   */
+  @SuppressWarnings({"CheckResult", "unchecked"})
+  @NonNull
+  @CheckResult
+  public RequestBuilder<TranscodeType> thumbnail(
+      @Nullable RequestBuilder<TranscodeType>... thumbnails) {
+    if (thumbnails == null || thumbnails.length == 0) {
+      return thumbnail((RequestBuilder<TranscodeType>) null);
+    }
+
+    RequestBuilder<TranscodeType> previous = null;
+
+    // Start with the lowest priority thumbnail so that we can safely handle mutations if
+    // autoClone() is enabled by assigning the result of calling thumbnail() during the iteration.
+    // Starting with the highest priority thumbnail would prevent us from assigning the result of
+    // thumbnail because the mutated request wouldn't be used in the next iteration.
+    for (int i = thumbnails.length - 1; i >= 0; i--) {
+      RequestBuilder<TranscodeType> current = thumbnails[i];
+      // Ignore null thumbnails.
+      if (current == null) {
+        continue;
+      }
+
+      if (previous == null) {
+        // If we don't yet have our first non-null request, set it and continue.
+        previous = current;
+      } else {
+        // Otherwise make our next lowest priority request the thumbnail of our current request.
+        previous = current.thumbnail(previous);
+      }
+    }
+    return thumbnail(previous);
+  }
+
   /**
    * Loads a resource in an identical manner to this request except with the dimensions of the
    * target multiplied by the given size multiplier. If the thumbnail load completes before the full
    * size load, the thumbnail will be shown. If the thumbnail load completes after the full size
    * load, the thumbnail will not be shown.
    *
-   * <p> Note - The thumbnail resource will be smaller than the size requested so the target (or
+   * <p>Note - The thumbnail resource will be smaller than the size requested so the target (or
    * {@link ImageView}) must be able to scale the thumbnail appropriately. See
-   * {@link android.widget.ImageView.ScaleType}. </p>
+   * {@link android.widget.ImageView.ScaleType}.
    *
-   * <p> Almost all options will be copied from the original load, including the {@link
+   * <p>Almost all options will be copied from the original load, including the {@link
    * com.bumptech.glide.load.model.ModelLoader}, {@link com.bumptech.glide.load.ResourceDecoder},
    * and {@link com.bumptech.glide.load.Transformation}s. However,
    * {@link com.bumptech.glide.request.RequestOptions#placeholder(int)} and
    * {@link com.bumptech.glide.request.RequestOptions#error(int)}, and
    * {@link #listener(RequestListener)} will only be used on the full size load and will not be
-   * copied for the thumbnail load. </p>
+   * copied for the thumbnail load.
+   *
+   * <p>Recursive calls to thumbnail are supported.
    *
-   * <p> Recursive calls to thumbnail are supported. </p>
+   * <p>Overrides any previous calls to this method, {@link #thumbnail(RequestBuilder[])},
+   *  and {@link #thumbnail(RequestBuilder)}.
+   *
+   * @see #thumbnail(RequestBuilder)
+   * @see #thumbnail(RequestBuilder[])
    *
    * @param sizeMultiplier The multiplier to apply to the {@link Target}'s dimensions when loading
    *                       the thumbnail.
    * @return This request builder.
    */
+  @NonNull
+  @CheckResult
   @SuppressWarnings("unchecked")
   public RequestBuilder<TranscodeType> thumbnail(float sizeMultiplier) {
     if (sizeMultiplier < 0f || sizeMultiplier > 1f) {
@@ -185,25 +353,79 @@ protected RequestOptions getMutableOptions() {
   /**
    * Sets the specific model to load data for.
    *
-   * <p> This method must be called at least once before
-   * {@link #into(com.bumptech.glide.request.target.Target)} is called. </p>
-   *
    * @param model The model to load data for, or null.
    * @return This request builder.
    */
+  @NonNull
+  @CheckResult
   @SuppressWarnings("unchecked")
+  @Override
   public RequestBuilder<TranscodeType> load(@Nullable Object model) {
     return loadGeneric(model);
   }
 
+  @NonNull
   private RequestBuilder<TranscodeType> loadGeneric(@Nullable Object model) {
     this.model = model;
     isModelSet = true;
     return this;
   }
+  /**
+   * Returns an object to load the given {@link Bitmap}.
+   *
+   * <p>It's almost always better to allow Glide to load {@link Bitmap}s than
+   * pass {@link Bitmap}s into Glide. If you have a custom way to obtain {@link Bitmap}s that is
+   * not supported by Glide by default, consider registering a custom
+   * {@link com.bumptech.glide.load.model.ModelLoader} or
+   * {@link com.bumptech.glide.load.ResourceDecoder} instead of using this method.
+   *
+   * <p>The {@link DiskCacheStrategy} is set to {@link DiskCacheStrategy#NONE}. Previous calls to
+   * {@link #apply(BaseRequestOptions)} or previously applied {@link DiskCacheStrategy}s will be
+   * overridden by this method. Applying an {@link DiskCacheStrategy} other than
+   * {@link DiskCacheStrategy#NONE} after calling this method may result in undefined behavior.
+   *
+   * <p>In memory caching relies on Object equality. The contents of the {@link Bitmap}s are not
+   * compared.
+   *
+   * @see #load(Object)
+   */
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<TranscodeType> load(@Nullable Bitmap bitmap) {
+    return loadGeneric(bitmap)
+        .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
+  }
+
+  /**
+   * Returns a request builder to load the given {@link Drawable}.
+   *
+   * <p>It's almost always better to allow Glide to load {@link Bitmap}s than to pass
+   * {@link Bitmap}s into Glide using this method . If you have a custom way to obtain
+   * {@link Bitmap}s that is not supported by Glide by default, consider registering a custom
+   * {@link com.bumptech.glide.load.model.ModelLoader} or
+   * {@link com.bumptech.glide.load.ResourceDecoder} instead of using this method.
+   *
+   * <p>The {@link DiskCacheStrategy} is set to {@link DiskCacheStrategy#NONE}. Previous calls to
+   * {@link #apply(BaseRequestOptions)} or previously applied {@link DiskCacheStrategy}s will be
+   * overridden by this method. Applying an {@link DiskCacheStrategy} other than
+   * {@link DiskCacheStrategy#NONE} after calling this method may result in undefined behavior.
+   *
+   * <p>In memory caching relies on Object equality. The contents of the {@link Drawable}s are not
+   * compared.
+   *
+   * @see #load(Object)
+   */
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<TranscodeType> load(@Nullable Drawable drawable) {
+    return loadGeneric(drawable)
+        .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
+  }
 
   /**
-   * Returns a request builder to load the given {@link java.lang.String}. signature.
+   * Returns a request builder to load the given {@link java.lang.String}.
    *
    * <p> Note - this method caches data using only the given String as the cache key. If the data is
    * a Uri outside of your control, or you otherwise expect the data represented by the given String
@@ -221,6 +443,9 @@ protected RequestOptions getMutableOptions() {
    * @param string A file path, or a uri or url handled by
    * {@link com.bumptech.glide.load.model.UriLoader}.
    */
+  @NonNull
+  @Override
+  @CheckResult
   public RequestBuilder<TranscodeType> load(@Nullable String string) {
     return loadGeneric(string);
   }
@@ -243,6 +468,9 @@ protected RequestOptions getMutableOptions() {
    * @param uri The Uri representing the image. Must be of a type handled by
    * {@link com.bumptech.glide.load.model.UriLoader}.
    */
+  @NonNull
+  @CheckResult
+  @Override
   public RequestBuilder<TranscodeType> load(@Nullable Uri uri) {
     return loadGeneric(uri);
   }
@@ -250,7 +478,7 @@ protected RequestOptions getMutableOptions() {
   /**
    * Returns a request builder to load the given {@link File}.
    *
-   * <p> Note - this method caches data for Files using only the file path itself as the cache key.
+   * <p>Note - this method caches data for Files using only the file path itself as the cache key.
    * The data in the File can change so using this method can lead to displaying stale data. If you
    * expect the data in the File to change, Consider using
    * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)}
@@ -259,23 +487,25 @@ protected RequestOptions getMutableOptions() {
    * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
    * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
    * appropriate.
-   * </p>
    *
    * @see #load(Object)
    *
    * @param file The File containing the image
    */
+  @NonNull
+  @CheckResult
+  @Override
   public RequestBuilder<TranscodeType> load(@Nullable File file) {
     return loadGeneric(file);
   }
 
   /**
-   * Returns a request builder to load the given resource id. Returns a request builder that uses
-   * the {@link com.bumptech.glide.load.model.ModelLoaderFactory} currently registered or
+   * Returns a request builder that uses the
+   * {@link com.bumptech.glide.load.model.ModelLoaderFactory} currently registered or
    * {@link Integer} to load the image represented by the given {@link Integer} resource id.
    * Defaults to {@link com.bumptech.glide.load.model.ResourceLoader} to load resource id models.
    *
-   * <p> By default this method adds a version code based signature to the cache key used to cache
+   * <p>By default this method adds a version code based signature to the cache key used to cache
    * this resource in Glide. This signature is sufficient to guarantee that end users will see the
    * most up to date versions of your Drawables, but during development if you do not increment your
    * version code before each install and you replace a Drawable with different data without
@@ -283,12 +513,28 @@ protected RequestOptions getMutableOptions() {
    * using {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} via
    * {@link RequestOptions#diskCacheStrategy(com.bumptech.glide.load.engine.DiskCacheStrategy)}
    * during development, and re-enabling the default
-   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESOURCE} for release builds. </p>
+   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESOURCE} for release builds.
+   *
+   * <p>This method will load non-{@link android.graphics.Bitmap} resources like
+   * {@link android.graphics.drawable.VectorDrawable}s. Although Glide makes a best effort to apply
+   * {@link com.bumptech.glide.load.Transformation}s to these {@link Drawable}s by either extracting
+   * the underlying {@link Bitmap} or by converting the {@link Drawable} to a {@link Bitmap}, Glide
+   * is still not able to transform all types of resources. Animated {@link Drawable}s cannot be
+   * transformed (other than {@link com.bumptech.glide.load.resource.gif.GifDrawable}). To avoid
+   * load failures if a {@link Drawable} can't be transformed, use the optional transformation
+   * methods like {@link RequestOptions#optionalTransform(Class, Transformation)}.
+   *
+   * <p>In some cases converting {@link Drawable}s to {@link Bitmap}s may be inefficient. Use this
+   * method, especially in conjunction with {@link com.bumptech.glide.load.Transformation}s with
+   * caution for non-{@link Bitmap} {@link Drawable}s.
    *
    * @see #load(Integer)
    * @see com.bumptech.glide.signature.ApplicationVersionSignature
    */
-  public RequestBuilder<TranscodeType> load(@Nullable Integer resourceId) {
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer resourceId) {
     return loadGeneric(resourceId).apply(signatureOf(ApplicationVersionSignature.obtain(context)));
   }
 
@@ -297,11 +543,13 @@ protected RequestOptions getMutableOptions() {
    *
    * @param url The URL representing the image.
    * @see #load(Object)
-   * @deprecated The {@link java.net.URL} class has <a href="http://goo.gl/c4hHNu">a number of
-   * performance problems</a> and should generally be avoided when possible. Prefer
-   * {@link #load(android.net.Uri)} or {@link #load(String)}.
+   * @deprecated The {@link java.net.URL} class has
+   * <a href="http://goo.gl/c4hHNu">a number of performance problems</a> and should generally be
+   * avoided when possible. Prefer {@link #load(android.net.Uri)} or {@link #load(String)}.
    */
   @Deprecated
+  @CheckResult
+  @Override
   public RequestBuilder<TranscodeType> load(@Nullable URL url) {
     return loadGeneric(url);
   }
@@ -309,15 +557,23 @@ protected RequestOptions getMutableOptions() {
   /**
    * Returns a request to load the given byte array.
    *
-   * <p> Note - by default loads for bytes are not cached in either the memory or the disk cache.
-   * </p>
+   * <p>Note - by default loads for bytes are not cached in either the memory or the disk cache.
    *
    * @param model the data to load.
    * @see #load(Object)
    */
+  @NonNull
+  @CheckResult
+  @Override
   public RequestBuilder<TranscodeType> load(@Nullable byte[] model) {
-    return loadGeneric(model).apply(signatureOf(new ObjectKey(UUID.randomUUID().toString()))
-        .diskCacheStrategy(DiskCacheStrategy.NONE).skipMemoryCache(true /*skipMemoryCache*/));
+    RequestBuilder<TranscodeType> result = loadGeneric(model);
+    if (!result.isDiskCacheStrategySet()) {
+        result = result.apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
+    }
+    if (!result.isSkipMemoryCacheSet()) {
+      result = result.apply(skipMemoryCacheOf(true /*skipMemoryCache*/));
+    }
+    return result;
   }
 
   /**
@@ -328,17 +584,17 @@ protected RequestOptions getMutableOptions() {
    * arguments, the current model is not copied copied so changes to the model will affect both
    * builders. </p>
    */
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings({
+      "unchecked",
+      // we don't want to throw to be user friendly
+      "PMD.CloneThrowsCloneNotSupportedException"
+  })
+  @CheckResult
   @Override
   public RequestBuilder<TranscodeType> clone() {
-    try {
-      RequestBuilder<TranscodeType> result = (RequestBuilder<TranscodeType>) super.clone();
-      result.requestOptions = result.requestOptions.clone();
-      result.transitionOptions = result.transitionOptions.clone();
-      return result;
-    } catch (CloneNotSupportedException e) {
-      throw new RuntimeException(e);
-    }
+    RequestBuilder<TranscodeType> result = super.clone();
+    result.transitionOptions = result.transitionOptions.clone();
+    return result;
   }
 
   /**
@@ -348,31 +604,64 @@ protected RequestOptions getMutableOptions() {
    * @return The given target.
    * @see RequestManager#clear(Target)
    */
+  @NonNull
   public <Y extends Target<TranscodeType>> Y into(@NonNull Y target) {
+    return into(target, /*targetListener=*/ null);
+  }
+
+  @NonNull
+  @Synthetic <Y extends Target<TranscodeType>> Y into(
+      @NonNull Y target,
+      @Nullable RequestListener<TranscodeType> targetListener) {
+    return into(target, targetListener, /*options=*/ this);
+  }
+
+  private <Y extends Target<TranscodeType>> Y into(
+      @NonNull Y target,
+      @Nullable RequestListener<TranscodeType> targetListener,
+      BaseRequestOptions<?> options) {
     Util.assertMainThread();
     Preconditions.checkNotNull(target);
     if (!isModelSet) {
       throw new IllegalArgumentException("You must call #load() before calling #into()");
     }
 
-    requestOptions.lock();
-    Request request = buildRequest(target);
+    Request request = buildRequest(target, targetListener, options);
 
     Request previous = target.getRequest();
-    if (previous != null) {
-      if (request.isEquivalentTo(previous)) {
-        request.recycle();
-        return target;
+    if (request.isEquivalentTo(previous)
+        && !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) {
+      request.recycle();
+      // If the request is completed, beginning again will ensure the result is re-delivered,
+      // triggering RequestListeners and Targets. If the request is failed, beginning again will
+      // restart the request, giving it another chance to complete. If the request is already
+      // running, we can let it continue running without interruption.
+      if (!Preconditions.checkNotNull(previous).isRunning()) {
+        // Use the previous request rather than the new one to allow for optimizations like skipping
+        // setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions
+        // that are done in the individual Request.
+        previous.begin();
       }
-      requestManager.clear(target);
+      return target;
     }
 
+    requestManager.clear(target);
     target.setRequest(request);
     requestManager.track(target, request);
 
     return target;
   }
 
+  // If the caller is using skipMemoryCache and the previous request is finished, calling begin on
+  // the previous request will complete from memory because it will just use the resource that had
+  // already been loaded. If the previous request isn't complete, we can wait for it to finish
+  // because the previous request must also be using skipMemoryCache for the requests to be
+  // equivalent. See #2663 for additional context.
+  private boolean isSkipMemoryCacheWithCompletePreviousRequest(
+      BaseRequestOptions<?> options, Request previous) {
+    return !options.isMemoryCacheable() && previous.isComplete();
+  }
+
   /**
    * Sets the {@link ImageView} the resource will be loaded into, cancels any existing loads into
    * the view, and frees any resources Glide may have previously loaded into the view so they may be
@@ -384,30 +673,32 @@ protected RequestOptions getMutableOptions() {
    * @return The
    * {@link com.bumptech.glide.request.target.Target} used to wrap the given {@link ImageView}.
    */
-  public Target<TranscodeType> into(ImageView view) {
+  @NonNull
+  public ViewTarget<ImageView, TranscodeType> into(@NonNull ImageView view) {
     Util.assertMainThread();
     Preconditions.checkNotNull(view);
 
+    BaseRequestOptions<?> requestOptions = this;
     if (!requestOptions.isTransformationSet()
         && requestOptions.isTransformationAllowed()
         && view.getScaleType() != null) {
-      if (requestOptions.isLocked()) {
-        requestOptions = requestOptions.clone();
-      }
+      // Clone in this method so that if we use this RequestBuilder to load into a View and then
+      // into a different target, we don't retain the transformation applied based on the previous
+      // View's scale type.
       switch (view.getScaleType()) {
         case CENTER_CROP:
-          requestOptions.optionalCenterCrop();
+          requestOptions = requestOptions.clone().optionalCenterCrop();
           break;
         case CENTER_INSIDE:
-          requestOptions.optionalCenterInside();
+          requestOptions = requestOptions.clone().optionalCenterInside();
           break;
         case FIT_CENTER:
         case FIT_START:
         case FIT_END:
-          requestOptions.optionalFitCenter();
+          requestOptions = requestOptions.clone().optionalFitCenter();
           break;
         case FIT_XY:
-          requestOptions.optionalCenterInside();
+          requestOptions = requestOptions.clone().optionalCenterInside();
           break;
         case CENTER:
         case MATRIX:
@@ -416,7 +707,10 @@ protected RequestOptions getMutableOptions() {
       }
     }
 
-    return into(context.buildImageViewTarget(view, transcodeClass));
+    return into(
+        glideContext.buildImageViewTarget(view, transcodeClass),
+        /*targetListener=*/ null,
+        requestOptions);
   }
 
   /**
@@ -451,6 +745,7 @@ protected RequestOptions getMutableOptions() {
    * @see #submit(int, int)
    * @see #into(Target)
    */
+  @NonNull
   public FutureTarget<TranscodeType> submit() {
     return submit(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
   }
@@ -467,21 +762,22 @@ protected RequestOptions getMutableOptions() {
    *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
    *               previously called).
    */
+  @NonNull
   public FutureTarget<TranscodeType> submit(int width, int height) {
     final RequestFutureTarget<TranscodeType> target =
-        new RequestFutureTarget<>(context.getMainHandler(), width, height);
+        new RequestFutureTarget<>(glideContext.getMainHandler(), width, height);
 
     if (Util.isOnBackgroundThread()) {
-      context.getMainHandler().post(new Runnable() {
+      glideContext.getMainHandler().post(new Runnable() {
         @Override
         public void run() {
           if (!target.isCancelled()) {
-            into(target);
+            into(target, target);
           }
         }
       });
     } else {
-      into(target);
+      into(target, target);
     }
 
     return target;
@@ -505,6 +801,7 @@ public void run() {
    * {@link RequestManager#clear(Target)}.
    * @see com.bumptech.glide.ListPreloader
    */
+  @NonNull
   public Target<TranscodeType> preload(int width, int height) {
     final PreloadTarget<TranscodeType> target = PreloadTarget.obtain(requestManager, width, height);
     return into(target);
@@ -519,6 +816,7 @@ public void run() {
    * {@link RequestManager#clear(Target)}
    * @see #preload(int, int)
    */
+  @NonNull
   public Target<TranscodeType> preload() {
     return preload(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
   }
@@ -534,7 +832,8 @@ public void run() {
    * @deprecated Use {@link RequestManager#downloadOnly()} and {@link #into(Target)}.
    */
   @Deprecated
-  public <Y extends Target<File>> Y downloadOnly(Y target) {
+  @CheckResult
+  public <Y extends Target<File>> Y downloadOnly(@NonNull Y target) {
     return getDownloadOnlyRequest().into(target);
   }
 
@@ -548,18 +847,22 @@ public void run() {
    * @return A {@link java.util.concurrent.Future} that can be used to retrieve the cache File
    * containing the data.
    *
-   * @deprecated Use {@link RequestManager#downloadOnly()} and {@link #into(int, int)}.
+   * @deprecated Use {@link RequestManager#downloadOnly()} and {@link #submit(int, int)}.
    */
   @Deprecated
+  @CheckResult
   public FutureTarget<File> downloadOnly(int width, int height) {
     return getDownloadOnlyRequest().submit(width, height);
   }
 
+  @NonNull
+  @CheckResult
   protected RequestBuilder<File> getDownloadOnlyRequest() {
     return new RequestBuilder<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
   }
 
-  private Priority getThumbnailPriority(Priority current) {
+  @NonNull
+  private Priority getThumbnailPriority(@NonNull Priority current) {
     switch (current) {
       case LOW:
         return Priority.NORMAL;
@@ -569,19 +872,87 @@ private Priority getThumbnailPriority(Priority current) {
       case IMMEDIATE:
         return Priority.IMMEDIATE;
       default:
-        throw new IllegalArgumentException("unknown priority: " + requestOptions.getPriority());
+        throw new IllegalArgumentException("unknown priority: " + getPriority());
     }
   }
 
-  private Request buildRequest(Target<TranscodeType> target) {
-    return buildRequestRecursive(target, null, transitionOptions, requestOptions.getPriority(),
-        requestOptions.getOverrideWidth(), requestOptions.getOverrideHeight());
+  private Request buildRequest(
+      Target<TranscodeType> target,
+      @Nullable RequestListener<TranscodeType> targetListener,
+      BaseRequestOptions<?> requestOptions) {
+    return buildRequestRecursive(
+        target,
+        targetListener,
+        /*parentCoordinator=*/ null,
+        transitionOptions,
+        requestOptions.getPriority(),
+        requestOptions.getOverrideWidth(),
+        requestOptions.getOverrideHeight(),
+        requestOptions);
   }
 
-  private Request buildRequestRecursive(Target<TranscodeType> target,
-      @Nullable ThumbnailRequestCoordinator parentCoordinator,
+  private Request buildRequestRecursive(
+      Target<TranscodeType> target,
+      @Nullable RequestListener<TranscodeType> targetListener,
+      @Nullable RequestCoordinator parentCoordinator,
       TransitionOptions<?, ? super TranscodeType> transitionOptions,
-      Priority priority, int overrideWidth, int overrideHeight) {
+      Priority priority,
+      int overrideWidth,
+      int overrideHeight,
+      BaseRequestOptions<?> requestOptions) {
+
+    // Build the ErrorRequestCoordinator first if necessary so we can update parentCoordinator.
+    ErrorRequestCoordinator errorRequestCoordinator = null;
+    if (errorBuilder != null) {
+      errorRequestCoordinator = new ErrorRequestCoordinator(parentCoordinator);
+      parentCoordinator = errorRequestCoordinator;
+    }
+
+    Request mainRequest =
+        buildThumbnailRequestRecursive(
+            target,
+            targetListener,
+            parentCoordinator,
+            transitionOptions,
+            priority,
+            overrideWidth,
+            overrideHeight,
+            requestOptions);
+
+    if (errorRequestCoordinator == null) {
+      return mainRequest;
+    }
+
+    int errorOverrideWidth = errorBuilder.getOverrideWidth();
+    int errorOverrideHeight = errorBuilder.getOverrideHeight();
+    if (Util.isValidDimensions(overrideWidth, overrideHeight)
+        && !errorBuilder.isValidOverride()) {
+      errorOverrideWidth = requestOptions.getOverrideWidth();
+      errorOverrideHeight = requestOptions.getOverrideHeight();
+    }
+
+    Request errorRequest = errorBuilder.buildRequestRecursive(
+        target,
+        targetListener,
+        errorRequestCoordinator,
+        errorBuilder.transitionOptions,
+        errorBuilder.getPriority(),
+        errorOverrideWidth,
+        errorOverrideHeight,
+        errorBuilder);
+    errorRequestCoordinator.setRequests(mainRequest, errorRequest);
+    return errorRequestCoordinator;
+  }
+
+  private Request buildThumbnailRequestRecursive(
+      Target<TranscodeType> target,
+      RequestListener<TranscodeType> targetListener,
+      @Nullable RequestCoordinator parentCoordinator,
+      TransitionOptions<?, ? super TranscodeType> transitionOptions,
+      Priority priority,
+      int overrideWidth,
+      int overrideHeight,
+      BaseRequestOptions<?> requestOptions) {
     if (thumbnailBuilder != null) {
       // Recursive case: contains a potentially recursive thumbnail request builder.
       if (isThumbnailBuilt) {
@@ -598,55 +969,98 @@ private Request buildRequestRecursive(Target<TranscodeType> target,
         thumbTransitionOptions = transitionOptions;
       }
 
-      Priority thumbPriority = thumbnailBuilder.requestOptions.isPrioritySet()
-          ? thumbnailBuilder.requestOptions.getPriority() : getThumbnailPriority(priority);
+      Priority thumbPriority = thumbnailBuilder.isPrioritySet()
+          ? thumbnailBuilder.getPriority() : getThumbnailPriority(priority);
 
-      int thumbOverrideWidth = thumbnailBuilder.requestOptions.getOverrideWidth();
-      int thumbOverrideHeight = thumbnailBuilder.requestOptions.getOverrideHeight();
+      int thumbOverrideWidth = thumbnailBuilder.getOverrideWidth();
+      int thumbOverrideHeight = thumbnailBuilder.getOverrideHeight();
       if (Util.isValidDimensions(overrideWidth, overrideHeight)
-          && !thumbnailBuilder.requestOptions.isValidOverride()) {
+          && !thumbnailBuilder.isValidOverride()) {
         thumbOverrideWidth = requestOptions.getOverrideWidth();
         thumbOverrideHeight = requestOptions.getOverrideHeight();
       }
 
       ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
-      Request fullRequest = obtainRequest(target, requestOptions, coordinator,
-          transitionOptions, priority, overrideWidth, overrideHeight);
+      Request fullRequest =
+          obtainRequest(
+              target,
+              targetListener,
+              requestOptions,
+              coordinator,
+              transitionOptions,
+              priority,
+              overrideWidth,
+              overrideHeight);
       isThumbnailBuilt = true;
       // Recursively generate thumbnail requests.
-      Request thumbRequest = thumbnailBuilder.buildRequestRecursive(target, coordinator,
-          thumbTransitionOptions, thumbPriority, thumbOverrideWidth, thumbOverrideHeight);
+      Request thumbRequest =
+          thumbnailBuilder.buildRequestRecursive(
+              target,
+              targetListener,
+              coordinator,
+              thumbTransitionOptions,
+              thumbPriority,
+              thumbOverrideWidth,
+              thumbOverrideHeight,
+              thumbnailBuilder);
       isThumbnailBuilt = false;
       coordinator.setRequests(fullRequest, thumbRequest);
       return coordinator;
     } else if (thumbSizeMultiplier != null) {
       // Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse.
       ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
-      Request fullRequest = obtainRequest(target, requestOptions, coordinator, transitionOptions,
-          priority, overrideWidth, overrideHeight);
-      RequestOptions thumbnailOptions = requestOptions.clone()
-          .sizeMultiplier(thumbSizeMultiplier);
+      Request fullRequest =
+          obtainRequest(
+              target,
+              targetListener,
+              requestOptions,
+              coordinator,
+              transitionOptions,
+              priority,
+              overrideWidth,
+              overrideHeight);
+      BaseRequestOptions<?> thumbnailOptions =
+          requestOptions.clone().sizeMultiplier(thumbSizeMultiplier);
 
-      Request thumbnailRequest = obtainRequest(target, thumbnailOptions, coordinator,
-          transitionOptions, getThumbnailPriority(priority), overrideWidth, overrideHeight);
+      Request thumbnailRequest =
+          obtainRequest(
+              target,
+              targetListener,
+              thumbnailOptions,
+              coordinator,
+              transitionOptions,
+              getThumbnailPriority(priority),
+              overrideWidth,
+              overrideHeight);
 
       coordinator.setRequests(fullRequest, thumbnailRequest);
       return coordinator;
     } else {
       // Base case: no thumbnail.
-      return obtainRequest(target, requestOptions, parentCoordinator, transitionOptions, priority,
-          overrideWidth, overrideHeight);
+      return obtainRequest(
+          target,
+          targetListener,
+          requestOptions,
+          parentCoordinator,
+          transitionOptions,
+          priority,
+          overrideWidth,
+          overrideHeight);
     }
   }
 
-  private Request obtainRequest(Target<TranscodeType> target,
-      RequestOptions requestOptions, RequestCoordinator requestCoordinator,
-      TransitionOptions<?, ? super TranscodeType> transitionOptions, Priority priority,
-      int overrideWidth, int overrideHeight) {
-    requestOptions.lock();
-
+  private Request obtainRequest(
+      Target<TranscodeType> target,
+      RequestListener<TranscodeType> targetListener,
+      BaseRequestOptions<?> requestOptions,
+      RequestCoordinator requestCoordinator,
+      TransitionOptions<?, ? super TranscodeType> transitionOptions,
+      Priority priority,
+      int overrideWidth,
+      int overrideHeight) {
     return SingleRequest.obtain(
         context,
+        glideContext,
         model,
         transcodeClass,
         requestOptions,
@@ -654,9 +1068,10 @@ private Request obtainRequest(Target<TranscodeType> target,
         overrideHeight,
         priority,
         target,
-        requestListener,
+        targetListener,
+        requestListeners,
         requestCoordinator,
-        context.getEngine(),
+        glideContext.getEngine(),
         transitionOptions.getTransitionFactory());
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/RequestManager.java b/library/src/main/java/com/bumptech/glide/RequestManager.java
index 3ca48388c..9e0cdb6c3 100644
--- a/library/src/main/java/com/bumptech/glide/RequestManager.java
+++ b/library/src/main/java/com/bumptech/glide/RequestManager.java
@@ -7,12 +7,18 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
+import android.net.Uri;
 import android.os.Handler;
 import android.os.Looper;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
 import android.view.View;
+import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.engine.GlideException;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 import com.bumptech.glide.manager.ConnectivityMonitor;
 import com.bumptech.glide.manager.ConnectivityMonitorFactory;
@@ -22,6 +28,7 @@
 import com.bumptech.glide.manager.RequestTracker;
 import com.bumptech.glide.manager.TargetTracker;
 import com.bumptech.glide.request.Request;
+import com.bumptech.glide.request.RequestListener;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.request.target.ViewTarget;
@@ -29,6 +36,9 @@
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
 import java.io.File;
+import java.net.URL;
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 /**
  * A class for managing and starting requests for Glide. Can use activity, fragment and connectivity
@@ -42,7 +52,8 @@
  * @see Glide#with(android.support.v4.app.Fragment)
  * @see Glide#with(Context)
  */
-public class RequestManager implements LifecycleListener {
+public class RequestManager implements LifecycleListener,
+    ModelTypes<RequestBuilder<Drawable>> {
   private static final RequestOptions DECODE_TYPE_BITMAP = decodeTypeOf(Bitmap.class).lock();
   private static final RequestOptions DECODE_TYPE_GIF = decodeTypeOf(GifDrawable.class).lock();
   private static final RequestOptions DOWNLOAD_ONLY_OPTIONS =
@@ -50,6 +61,7 @@
           .skipMemoryCache(true);
 
   protected final Glide glide;
+  protected final Context context;
   @Synthetic final Lifecycle lifecycle;
   private final RequestTracker requestTracker;
   private final RequestManagerTreeNode treeNode;
@@ -62,12 +74,23 @@ public void run() {
   };
   private final Handler mainHandler = new Handler(Looper.getMainLooper());
   private final ConnectivityMonitor connectivityMonitor;
+  // Adding default listeners should be much less common than starting new requests. We want
+  // some way of making sure that requests don't mutate our listeners without creating a new copy of
+  // the list each time a request is started.
+  private final CopyOnWriteArrayList<RequestListener<Object>> defaultRequestListeners;
 
-  @NonNull
   private RequestOptions requestOptions;
 
-  public RequestManager(Glide glide, Lifecycle lifecycle, RequestManagerTreeNode treeNode) {
-    this(glide, lifecycle, treeNode, new RequestTracker(), glide.getConnectivityMonitorFactory());
+  public RequestManager(
+      @NonNull Glide glide, @NonNull Lifecycle lifecycle,
+      @NonNull RequestManagerTreeNode treeNode, @NonNull Context context) {
+    this(
+        glide,
+        lifecycle,
+        treeNode,
+        new RequestTracker(),
+        glide.getConnectivityMonitorFactory(),
+        context);
   }
 
   // Our usage is safe here.
@@ -77,16 +100,18 @@ public RequestManager(Glide glide, Lifecycle lifecycle, RequestManagerTreeNode t
       Lifecycle lifecycle,
       RequestManagerTreeNode treeNode,
       RequestTracker requestTracker,
-      ConnectivityMonitorFactory factory) {
+      ConnectivityMonitorFactory factory,
+      Context context) {
     this.glide = glide;
     this.lifecycle = lifecycle;
     this.treeNode = treeNode;
     this.requestTracker = requestTracker;
-
-    final Context context = glide.getGlideContext().getBaseContext();
+    this.context = context;
 
     connectivityMonitor =
-        factory.build(context, new RequestManagerConnectivityListener(requestTracker));
+        factory.build(
+            context.getApplicationContext(),
+            new RequestManagerConnectivityListener(requestTracker));
 
     // If we're the application level request manager, we may be created on a background thread.
     // In that case we cannot risk synchronously pausing or resuming requests, so we hack around the
@@ -99,17 +124,19 @@ public RequestManager(Glide glide, Lifecycle lifecycle, RequestManagerTreeNode t
     }
     lifecycle.addListener(connectivityMonitor);
 
+    defaultRequestListeners =
+        new CopyOnWriteArrayList<>(glide.getGlideContext().getDefaultRequestListeners());
     setRequestOptions(glide.getGlideContext().getDefaultRequestOptions());
 
     glide.registerRequestManager(this);
   }
 
   protected void setRequestOptions(@NonNull RequestOptions toSet) {
-    this.requestOptions = toSet.clone().autoClone();
+    requestOptions = toSet.clone().autoClone();
   }
 
-  private void updateRequestOptions(RequestOptions toUpdate) {
-    this.requestOptions.apply(toUpdate);
+  private void updateRequestOptions(@NonNull RequestOptions toUpdate) {
+    requestOptions = requestOptions.apply(toUpdate);
   }
 
   /**
@@ -130,7 +157,8 @@ private void updateRequestOptions(RequestOptions toUpdate) {
    *
    * @return This request manager.
    */
-  public RequestManager applyDefaultRequestOptions(RequestOptions requestOptions) {
+  @NonNull
+  public RequestManager applyDefaultRequestOptions(@NonNull RequestOptions requestOptions) {
     updateRequestOptions(requestOptions);
     return this;
   }
@@ -140,9 +168,8 @@ public RequestManager applyDefaultRequestOptions(RequestOptions requestOptions)
    * with the given {@link RequestOptions}.
    *
    * <p>The {@link RequestOptions} provided here replace those that have been previously provided
-   * via {@link GlideBuilder#setDefaultRequestOptions(RequestOptions)}, {@link
-   * #setDefaultRequestOptions(RequestOptions)} and {@link
-   * #applyDefaultRequestOptions(RequestOptions)}.
+   * via this method, {@link GlideBuilder#setDefaultRequestOptions(RequestOptions)}, and
+   * {@link #applyDefaultRequestOptions(RequestOptions)}.
    *
    * <p>Subsequent calls to {@link #applyDefaultRequestOptions(RequestOptions)} will not mutate
    * the {@link RequestOptions} provided here. Instead the manager will create a clone of these
@@ -152,31 +179,33 @@ public RequestManager applyDefaultRequestOptions(RequestOptions requestOptions)
    *
    * @return This request manager.
    */
-  public RequestManager setDefaultRequestOptions(RequestOptions requestOptions) {
+  @NonNull
+  public RequestManager setDefaultRequestOptions(@NonNull RequestOptions requestOptions) {
     setRequestOptions(requestOptions);
     return this;
   }
 
   /**
-   * @see android.content.ComponentCallbacks2#onTrimMemory(int)
+   * Adds a default {@link RequestListener} that will be added to every request started with this
+   * {@link RequestManager}.
    *
-   * @deprecated This method is called automatically by Glide's internals and shouldn't be called
-   * externally.
-   */
-  @Deprecated
-  public void onTrimMemory(int level) {
-    glide.onTrimMemory(level);
-  }
-
-  /**
-   * @see android.content.ComponentCallbacks2#onLowMemory()
+   * <p>Multiple {@link RequestListener}s can be added here, in {@link RequestManager} scopes or
+   * to individual {@link RequestBuilder}s. {@link RequestListener}s are called in the order they're
+   * added. Even if an earlier {@link RequestListener} returns {@code true} from
+   * {@link RequestListener#onLoadFailed(GlideException, Object, Target, boolean)} or
+   * {@link RequestListener#onResourceReady(Object, Object, Target, DataSource, boolean)}, it will
+   * not prevent subsequent {@link RequestListener}s from being called.
    *
-   * @deprecated This method is called automatically by Glide's internals and shouldn't be called
-   * externally.
+   * <p>Because Glide requests can be started for any number of individual resource types, any
+   * listener added here has to accept any generic resource type in
+   * {@link RequestListener#onResourceReady(Object, Object, Target, DataSource, boolean)}. If you
+   * must base the behavior of the listener on the resource type, you will need to use
+   * {@code instanceof} to do so. It's not safe to cast resource types without first checking
+   * with {@code instanceof}.
    */
-  @Deprecated
-  public void onLowMemory() {
-    glide.onLowMemory();
+  public RequestManager addDefaultRequestListener(RequestListener<Object> requestListener) {
+    defaultRequestListeners.add(requestListener);
+    return this;
   }
 
   /**
@@ -193,6 +222,10 @@ public boolean isPaused() {
   /**
    * Cancels any in progress loads, but does not clear resources of completed loads.
    *
+   * <p>Note #{@link #resumeRequests()} must be called for any requests made before or while the
+   * manager is paused to complete. RequestManagers attached to Fragments and Activities
+   * automatically resume onStart().
+   *
    * @see #isPaused()
    * @see #resumeRequests()
    */
@@ -201,6 +234,27 @@ public void pauseRequests() {
     requestTracker.pauseRequests();
   }
 
+  /**
+   * Cancels any in progress loads and clears resources of completed loads.
+   *
+   * <p>Note #{@link #resumeRequests()} must be called for any requests made before or while the
+   * manager is paused to complete. RequestManagers attached to Fragments and Activities
+   * automatically resume onStart().
+   *
+   * <p>This will release the memory used by completed bitmaps but leaves them in any configured
+   * caches. When an #{@link android.app.Activity} receives #{@link
+   * android.app.Activity#onTrimMemory(int)} at a level of #{@link
+   * android.content.ComponentCallbacks2#TRIM_MEMORY_BACKGROUND} this is desirable in order to keep
+   * your process alive longer.
+   *
+   * @see #isPaused()
+   * @see #resumeRequests()
+   */
+  public void pauseAllRequests() {
+    Util.assertMainThread();
+    requestTracker.pauseAllRequests();
+  }
+
   /**
    * Performs {@link #pauseRequests()} recursively for all managers that are contextually
    * descendant to this manager based on the Activity/Fragment hierarchy:
@@ -215,6 +269,8 @@ public void pauseRequests() {
    * <p>Note, on pre-Jelly Bean MR1 calling pause on a Fragment will not cause child fragments to
    * pause, in this case either call pause on the Activity or use a support Fragment.
    */
+  // Public API.
+  @SuppressWarnings({"WeakerAccess", "unused"})
   public void pauseRequestsRecursive() {
     Util.assertMainThread();
     pauseRequests();
@@ -239,6 +295,8 @@ public void resumeRequests() {
    * descendant to this manager based on the Activity/Fragment hierarchy. The hierarchical semantics
    * are identical as for {@link #pauseRequestsRecursive()}.
    */
+  // Public API.
+  @SuppressWarnings("unused")
   public void resumeRequestsRecursive() {
     Util.assertMainThread();
     resumeRequests();
@@ -292,6 +350,8 @@ public void onDestroy() {
    *
    * @return A new request builder for loading a {@link android.graphics.Bitmap}
    */
+  @NonNull
+  @CheckResult
   public RequestBuilder<Bitmap> asBitmap() {
     return as(Bitmap.class).apply(DECODE_TYPE_BITMAP);
   }
@@ -309,6 +369,8 @@ public void onDestroy() {
    * @return A new request builder for loading a
    * {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
    */
+  @NonNull
+  @CheckResult
   public RequestBuilder<GifDrawable> asGif() {
     return as(GifDrawable.class).apply(DECODE_TYPE_GIF);
   }
@@ -323,16 +385,120 @@ public void onDestroy() {
    *
    * @return A new request builder for loading a {@link Drawable}.
    */
+  @NonNull
+  @CheckResult
   public RequestBuilder<Drawable> asDrawable() {
     return as(Drawable.class);
   }
 
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(Bitmap)}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<Drawable> load(@Nullable Bitmap bitmap) {
+    return asDrawable().load(bitmap);
+  }
+
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(Drawable)}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<Drawable> load(@Nullable Drawable drawable) {
+    return asDrawable().load(drawable);
+  }
+
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(String)}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<Drawable> load(@Nullable String string) {
+    return asDrawable().load(string);
+  }
+
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(Uri)}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<Drawable> load(@Nullable Uri uri) {
+    return asDrawable().load(uri);
+  }
+
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(File)}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<Drawable> load(@Nullable File file) {
+    return asDrawable().load(file);
+  }
+
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(Integer)}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @SuppressWarnings("deprecation")
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<Drawable> load(@RawRes @DrawableRes @Nullable Integer resourceId) {
+    return asDrawable().load(resourceId);
+  }
+
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(URL)}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @SuppressWarnings("deprecation")
+  @CheckResult
+  @Override
+  @Deprecated
+  public RequestBuilder<Drawable> load(@Nullable URL url) {
+    return asDrawable().load(url);
+  }
+
+
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(byte[])}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<Drawable> load(@Nullable byte[] model) {
+    return asDrawable().load(model);
+  }
+
   /**
    * A helper method equivalent to calling {@link #asDrawable()} and then {@link
    * RequestBuilder#load(Object)} with the given model.
    *
    * @return A new request builder for loading a {@link Drawable} using the given model.
    */
+  @NonNull
+  @CheckResult
+  @Override
   public RequestBuilder<Drawable> load(@Nullable Object model) {
     return asDrawable().load(model);
   }
@@ -348,6 +514,8 @@ public void onDestroy() {
    *
    * @return A new request builder for downloading content to cache and returning the cache File.
    */
+  @NonNull
+  @CheckResult
   public RequestBuilder<File> downloadOnly() {
     return as(File.class).apply(DOWNLOAD_ONLY_OPTIONS);
   }
@@ -358,6 +526,8 @@ public void onDestroy() {
    *
    * @return A new request builder for loading a {@link Drawable} using the given model.
    */
+  @NonNull
+  @CheckResult
   public RequestBuilder<File> download(@Nullable Object model) {
     return downloadOnly().load(model);
   }
@@ -371,6 +541,8 @@ public void onDestroy() {
    *
    * @return A new request builder for obtaining File paths to content.
    */
+  @NonNull
+  @CheckResult
   public RequestBuilder<File> asFile() {
     return as(File.class).apply(skipMemoryCacheOf(true));
   }
@@ -383,8 +555,11 @@ public void onDestroy() {
    * @param resourceClass The resource to decode.
    * @return A new request builder for loading the given resource class.
    */
-  public <ResourceType> RequestBuilder<ResourceType> as(Class<ResourceType> resourceClass) {
-    return new RequestBuilder<>(glide, this, resourceClass);
+  @NonNull
+  @CheckResult
+  public <ResourceType> RequestBuilder<ResourceType> as(
+      @NonNull Class<ResourceType> resourceClass) {
+    return new RequestBuilder<>(glide, this, resourceClass, context);
   }
 
   /**
@@ -399,7 +574,7 @@ public void onDestroy() {
    *                                  tag.
    * @see #clear(Target)
    */
-  public void clear(View view) {
+  public void clear(@NonNull View view) {
     clear(new ClearTarget(view));
   }
 
@@ -426,14 +601,33 @@ public void run() {
     }
   }
 
-  private void untrackOrDelegate(Target<?> target) {
+  private void untrackOrDelegate(@NonNull Target<?> target) {
     boolean isOwnedByUs = untrack(target);
-    if (!isOwnedByUs) {
-      glide.removeFromManagers(target);
+    // We'll end up here if the Target was cleared after the RequestManager that started the request
+    // is destroyed. That can happen for at least two reasons:
+    // 1. We call clear() on a background thread using something other than Application Context
+    // RequestManager.
+    // 2. The caller retains a reference to the RequestManager after the corresponding Activity or
+    // Fragment is destroyed, starts a load with it, and then clears that load with a different
+    // RequestManager. Callers seem especially likely to do this in retained Fragments (#2262).
+    //
+    // #1 is always an error. At best the caller is leaking memory briefly in something like an
+    // AsyncTask. At worst the caller is leaking an Activity or Fragment for a sustained period of
+    // time if they do something like reference the Activity RequestManager in a long lived
+    // background thread or task.
+    //
+    // #2 is always an error. Callers shouldn't be starting new loads using RequestManagers after
+    // the corresponding Activity or Fragment is destroyed because retaining any reference to the
+    // RequestManager leaks memory. It's possible that there's some brief period of time during or
+    // immediately after onDestroy where this is reasonable, but I can't think of why.
+    if (!isOwnedByUs && !glide.removeFromManagers(target) && target.getRequest() != null) {
+      Request request = target.getRequest();
+      target.setRequest(null);
+      request.clear();
     }
   }
 
-  boolean untrack(Target<?> target) {
+  boolean untrack(@NonNull Target<?> target) {
     Request request = target.getRequest();
     // If the Target doesn't have a request, it's already been cleared.
     if (request == null) {
@@ -449,11 +643,15 @@ boolean untrack(Target<?> target) {
     }
   }
 
-  void track(Target<?> target, Request request) {
+  void track(@NonNull Target<?> target, @NonNull Request request) {
     targetTracker.track(target);
     requestTracker.runRequest(request);
   }
 
+  List<RequestListener<Object>> getDefaultRequestListeners() {
+    return defaultRequestListeners;
+  }
+
   RequestOptions getDefaultRequestOptions() {
     return requestOptions;
   }
@@ -472,7 +670,7 @@ public String toString() {
       .ConnectivityListener {
     private final RequestTracker requestTracker;
 
-    public RequestManagerConnectivityListener(RequestTracker requestTracker) {
+    RequestManagerConnectivityListener(@NonNull RequestTracker requestTracker) {
       this.requestTracker = requestTracker;
     }
 
@@ -486,12 +684,13 @@ public void onConnectivityChanged(boolean isConnected) {
 
   private static class ClearTarget extends ViewTarget<View, Object> {
 
-    public ClearTarget(View view) {
+    ClearTarget(@NonNull View view) {
       super(view);
     }
 
     @Override
-    public void onResourceReady(Object resource, Transition<? super Object> transition) {
+    public void onResourceReady(@NonNull Object resource,
+        @Nullable Transition<? super Object> transition) {
       // Do nothing.
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/TransitionOptions.java b/library/src/main/java/com/bumptech/glide/TransitionOptions.java
index 7768f6fcc..ce2cfe469 100644
--- a/library/src/main/java/com/bumptech/glide/TransitionOptions.java
+++ b/library/src/main/java/com/bumptech/glide/TransitionOptions.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.request.transition.NoTransition;
 import com.bumptech.glide.request.transition.TransitionFactory;
 import com.bumptech.glide.request.transition.ViewAnimationFactory;
@@ -23,6 +24,7 @@
    *
    * @return This request builder.
    */
+  @NonNull
   public final CHILD dontTransition() {
     return transition(NoTransition.getFactory());
   }
@@ -36,8 +38,9 @@ public final CHILD dontTransition() {
    *                        transition.
    * @return This request builder.
    */
+  @NonNull
   public final CHILD transition(int viewAnimationId) {
-    return transition(new ViewAnimationFactory<TranscodeType>(viewAnimationId));
+    return transition(new ViewAnimationFactory<>(viewAnimationId));
   }
 
   /**
@@ -49,18 +52,35 @@ public final CHILD transition(int viewAnimationId) {
    *                 .Animator} to run.
    * @return This request builder.
    */
-  public final CHILD transition(ViewPropertyTransition.Animator animator) {
-    return transition(new ViewPropertyAnimationFactory<TranscodeType>(animator));
+  @NonNull
+  public final CHILD transition(@NonNull ViewPropertyTransition.Animator animator) {
+    return transition(new ViewPropertyAnimationFactory<>(animator));
   }
 
-  public final CHILD transition(TransitionFactory<? super TranscodeType> transitionFactory) {
+  /**
+   * Uses the given {@link TransitionFactory} to build a
+   * {@link com.bumptech.glide.request.transition.Transition} for each request started with these
+   * {@code TransitionOptions}.
+   *
+   * @return This request builder.
+   */
+  @NonNull
+  public final CHILD transition(
+      @NonNull TransitionFactory<? super TranscodeType> transitionFactory) {
     this.transitionFactory = Preconditions.checkNotNull(transitionFactory);
     return self();
   }
 
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings({
+      // cast to CHILD is safe given the generic argument represents the object's runtime class
+      "unchecked",
+      // CHILD is the correct class name.
+      "PMD.CloneMethodReturnTypeMustMatchClassName",
+      // we don't want to throw to be user friendly
+      "PMD.CloneThrowsCloneNotSupportedException"
+  })
   @Override
-  protected final CHILD clone() {
+  public final CHILD clone() {
     try {
       return (CHILD) super.clone();
     } catch (CloneNotSupportedException e) {
diff --git a/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java
index 118d407dd..3fac0791c 100644
--- a/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java
+++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java
@@ -15,10 +15,15 @@
    * should return {@link android.graphics.Bitmap.Config#ARGB_8888} for
    * {@link android.graphics.Bitmap#getConfig()} when possible.
    *
+   * <p>On Android O+, this format will will use ARGB_8888 only when it's not possible to use
+   * {@link android.graphics.Bitmap.Config#HARDWARE}. More information is available about hardware
+   * Bitmaps here: https://goo.gl/tn2A6k. If you need to disable hardware Bitmaps for a particular
+   * request, use {@link com.bumptech.glide.request.RequestOptions#disallowHardwareConfig()}.
+   *
    * <p> GIF images decoded by {@link android.graphics.BitmapFactory} currently use an internal
    * hidden format that is returned as null from {@link android.graphics.Bitmap#getConfig()}. Since
    * we cannot force {@link android.graphics.BitmapFactory} to always return our desired config,
-   * this setting is a preference, not a promise.</p>
+   * this setting is a preference, not a promise.
    */
   PREFER_ARGB_8888,
 
@@ -28,6 +33,9 @@
    * {@link android.graphics.Bitmap#getConfig()}. Bitmaps decoded from formats that don't support or
    * use alpha should return {@link android.graphics.Bitmap.Config#RGB_565} for
    * {@link android.graphics.Bitmap#getConfig()}.
+   *
+   * <p>On Android O+, this format will will use ARGB_8888 only when it's not possible to use
+   * {@link android.graphics.Bitmap.Config#HARDWARE}.
    */
   PREFER_RGB_565;
 
diff --git a/library/src/main/java/com/bumptech/glide/load/Encoder.java b/library/src/main/java/com/bumptech/glide/load/Encoder.java
index db652b1ad..400cc7422 100644
--- a/library/src/main/java/com/bumptech/glide/load/Encoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/Encoder.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load;
 
+import android.support.annotation.NonNull;
 import java.io.File;
 
 /**
@@ -8,7 +9,6 @@
  * @param <T> The type of the data that will be written.
  */
 public interface Encoder<T> {
-
   /**
    * Writes the given data to the given output stream and returns True if the write completed
    * successfully and should be committed.
@@ -17,5 +17,5 @@
    * @param file The File to write the data to.
    * @param options The put of options to apply when encoding.
    */
-  boolean encode(T data, File file, Options options);
+  boolean encode(@NonNull T data, @NonNull File file, @NonNull Options options);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/HttpException.java b/library/src/main/java/com/bumptech/glide/load/HttpException.java
index 6b4430c98..b13edc5d7 100644
--- a/library/src/main/java/com/bumptech/glide/load/HttpException.java
+++ b/library/src/main/java/com/bumptech/glide/load/HttpException.java
@@ -10,7 +10,11 @@
  * users may attempt to retry or otherwise uniformly handle certain types of errors regardless of
  * the underlying http library.
  */
+// Public API.
+@SuppressWarnings({"WeakerAccess", "unused"})
 public final class HttpException extends IOException {
+  private static final long serialVersionUID = 1L;
+
   public static final int UNKNOWN = -1;
   private final int statusCode;
 
diff --git a/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java
index 6cecef3ac..b188c4df3 100644
--- a/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java
+++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import java.io.IOException;
 import java.io.InputStream;
@@ -10,9 +11,9 @@
  */
 public interface ImageHeaderParser {
   /**
-   * A constant indicating we were unable to parse the orientation from the image either because
-   * no exif segment containing orientation data existed, or because of an I/O error attempting to
-   * read the exif segment.
+   * A constant indicating we were unable to parse the orientation from the image either because no
+   * exif segment containing orientation data existed, or because of an I/O error attempting to read
+   * the exif segment.
    */
   int UNKNOWN_ORIENTATION = -1;
 
@@ -32,10 +33,9 @@
     WEBP_A(true),
     /** WebP type without alpha. */
     WEBP(false),
-    /**
-     * Unrecognized type.
-     */
+    /** Unrecognized type. */
     UNKNOWN(false);
+
     private final boolean hasAlpha;
 
     ImageType(boolean hasAlpha) {
@@ -47,8 +47,11 @@ public boolean hasAlpha() {
     }
   }
 
-  ImageType getType(InputStream is) throws IOException;
-  ImageType getType(ByteBuffer byteBuffer) throws IOException;
+  @NonNull
+  ImageType getType(@NonNull InputStream is) throws IOException;
+
+  @NonNull
+  ImageType getType(@NonNull ByteBuffer byteBuffer) throws IOException;
 
   /**
    * Parse the orientation from the image header. If it doesn't handle this image type (or this is
@@ -56,8 +59,9 @@ public boolean hasAlpha() {
    *
    * @return The exif orientation if present or -1 if the header couldn't be parsed or doesn't
    * contain an orientation
-   * @throws IOException
    */
-  int getOrientation(InputStream is, ArrayPool byteArrayPool) throws IOException;
-  int getOrientation(ByteBuffer byteBuffer, ArrayPool byteArrayPool) throws IOException;
+  int getOrientation(@NonNull InputStream is, @NonNull ArrayPool byteArrayPool) throws IOException;
+
+  int getOrientation(@NonNull ByteBuffer byteBuffer, @NonNull ArrayPool byteArrayPool)
+      throws IOException;
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java
index b092e15f2..97930be11 100644
--- a/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java
+++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import com.bumptech.glide.load.ImageHeaderParser.ImageType;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
@@ -20,8 +21,9 @@
   private ImageHeaderParserUtils() { }
 
   /** Returns the ImageType for the given InputStream. */
-  public static ImageType getType(List<ImageHeaderParser> parsers, @Nullable InputStream is,
-      ArrayPool byteArrayPool) throws IOException {
+  @NonNull
+  public static ImageType getType(@NonNull List<ImageHeaderParser> parsers,
+      @Nullable InputStream is, @NonNull ArrayPool byteArrayPool) throws IOException {
     if (is == null) {
       return ImageType.UNKNOWN;
     }
@@ -31,7 +33,9 @@ public static ImageType getType(List<ImageHeaderParser> parsers, @Nullable Input
     }
 
     is.mark(MARK_POSITION);
-    for (ImageHeaderParser parser : parsers) {
+    //noinspection ForLoopReplaceableByForEach to improve perf
+    for (int i = 0, size = parsers.size(); i < size; i++) {
+      ImageHeaderParser parser = parsers.get(i);
       try {
         ImageType type = parser.getType(is);
         if (type != ImageType.UNKNOWN) {
@@ -46,13 +50,17 @@ public static ImageType getType(List<ImageHeaderParser> parsers, @Nullable Input
   }
 
   /** Returns the ImageType for the given ByteBuffer. */
-  public static ImageType getType(List<ImageHeaderParser> parsers, @Nullable ByteBuffer buffer)
+  @NonNull
+  public static ImageType getType(@NonNull List<ImageHeaderParser> parsers,
+      @Nullable ByteBuffer buffer)
       throws IOException {
     if (buffer == null) {
       return ImageType.UNKNOWN;
     }
 
-    for (ImageHeaderParser parser : parsers) {
+    //noinspection ForLoopReplaceableByForEach to improve perf
+    for (int i = 0, size = parsers.size(); i < size; i++) {
+      ImageHeaderParser parser = parsers.get(i);
       ImageType type = parser.getType(buffer);
       if (type != ImageType.UNKNOWN) {
         return type;
@@ -62,9 +70,11 @@ public static ImageType getType(List<ImageHeaderParser> parsers, @Nullable ByteB
     return ImageType.UNKNOWN;
   }
 
-  /** Returns the orientation for the given InputStream. */
-  public static int getOrientation(List<ImageHeaderParser> parsers, @Nullable InputStream is,
-      ArrayPool byteArrayPool) throws IOException {
+  /**
+   * Returns the orientation for the given InputStream.
+   */
+  public static int getOrientation(@NonNull List<ImageHeaderParser> parsers,
+      @Nullable InputStream is, @NonNull ArrayPool byteArrayPool) throws IOException {
     if (is == null) {
       return ImageHeaderParser.UNKNOWN_ORIENTATION;
     }
@@ -74,7 +84,9 @@ public static int getOrientation(List<ImageHeaderParser> parsers, @Nullable Inpu
     }
 
     is.mark(MARK_POSITION);
-    for (ImageHeaderParser parser : parsers) {
+    //noinspection ForLoopReplaceableByForEach to improve perf
+    for (int i = 0, size = parsers.size(); i < size; i++) {
+      ImageHeaderParser parser = parsers.get(i);
       try {
         int orientation = parser.getOrientation(is, byteArrayPool);
         if (orientation != ImageHeaderParser.UNKNOWN_ORIENTATION) {
diff --git a/library/src/main/java/com/bumptech/glide/load/Key.java b/library/src/main/java/com/bumptech/glide/load/Key.java
index 47bb2e01a..f78a7b168 100644
--- a/library/src/main/java/com/bumptech/glide/load/Key.java
+++ b/library/src/main/java/com/bumptech/glide/load/Key.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load;
 
+import android.support.annotation.NonNull;
 import java.nio.charset.Charset;
 import java.security.MessageDigest;
 
@@ -21,11 +22,19 @@
    * <p> Note - Using {@link java.security.MessageDigest#reset()} inside of this method will result
    * in undefined behavior. </p>
    */
-  void updateDiskCacheKey(MessageDigest messageDigest);
+  void updateDiskCacheKey(@NonNull MessageDigest messageDigest);
 
+  /**
+   * For caching to work correctly, implementations <em>must</em> implement this method and
+   * {@link #hashCode()}.
+   */
   @Override
   boolean equals(Object o);
 
+  /**
+   * For caching to work correctly, implementations <em>must</em> implement this method and
+   * {@link #equals(Object)}.
+   */
   @Override
   int hashCode();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java
index c4c5d712b..6b1d038f2 100644
--- a/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.Resource;
 import java.security.MessageDigest;
 import java.util.Arrays;
@@ -15,15 +16,16 @@
   private final Collection<? extends Transformation<T>> transformations;
 
   @SafeVarargs
-  public MultiTransformation(Transformation<T>... transformations) {
-    if (transformations.length < 1) {
+  @SuppressWarnings("varargs")
+  public MultiTransformation(@NonNull Transformation<T>... transformations) {
+    if (transformations.length == 0) {
       throw new IllegalArgumentException(
           "MultiTransformation must contain at least one Transformation");
     }
     this.transformations = Arrays.asList(transformations);
   }
 
-  public MultiTransformation(Collection<? extends Transformation<T>> transformationList) {
+  public MultiTransformation(@NonNull Collection<? extends Transformation<T>> transformationList) {
     if (transformationList.isEmpty()) {
       throw new IllegalArgumentException(
           "MultiTransformation must contain at least one Transformation");
@@ -31,9 +33,10 @@ public MultiTransformation(Collection<? extends Transformation<T>> transformatio
     this.transformations = transformationList;
   }
 
+  @NonNull
   @Override
   public Resource<T> transform(
-      Context context, Resource<T> resource, int outWidth, int outHeight) {
+      @NonNull Context context, @NonNull Resource<T> resource, int outWidth, int outHeight) {
     Resource<T> previous = resource;
 
     for (Transformation<T> transformation : transformations) {
@@ -61,7 +64,7 @@ public int hashCode() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     for (Transformation<T> transformation : transformations) {
       transformation.updateDiskCacheKey(messageDigest);
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/Option.java b/library/src/main/java/com/bumptech/glide/load/Option.java
index a63bdc44b..561264871 100644
--- a/library/src/main/java/com/bumptech/glide/load/Option.java
+++ b/library/src/main/java/com/bumptech/glide/load/Option.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import com.bumptech.glide.util.Preconditions;
 import java.security.MessageDigest;
@@ -26,7 +27,8 @@
 public final class Option<T> {
   private static final CacheKeyUpdater<Object> EMPTY_UPDATER = new CacheKeyUpdater<Object>() {
     @Override
-    public void update(byte[] keyBytes, Object value, MessageDigest messageDigest) {
+    public void update(@NonNull byte[] keyBytes, @NonNull Object value,
+        @NonNull MessageDigest messageDigest) {
       // Do nothing.
     }
   };
@@ -43,8 +45,9 @@ public void update(byte[] keyBytes, Object value, MessageDigest messageDigest) {
    * @param key A unique package prefixed {@link String} that identifies this option (must be
    *            stable across builds, so {@link Class#getName()} should <em>not</em> be used).
    */
-  public static <T> Option<T> memory(String key) {
-    return new Option<>(key, null /*defaultValue*/, Option.<T>emptyUpdater());
+  @NonNull
+  public static <T> Option<T> memory(@NonNull String key) {
+    return new Option<>(key, null, Option.<T>emptyUpdater());
   }
 
   /**
@@ -54,7 +57,8 @@ public void update(byte[] keyBytes, Object value, MessageDigest messageDigest) {
    * @param key A unique package prefixed {@link String} that identifies this option (must be
    *            stable across builds, so {@link Class#getName()} should <em>not</em> be used).
    */
-  public static <T> Option<T> memory(String key, T defaultValue) {
+  @NonNull
+  public static <T> Option<T> memory(@NonNull String key, @NonNull T defaultValue) {
     return new Option<>(key, defaultValue, Option.<T>emptyUpdater());
   }
 
@@ -65,8 +69,10 @@ public void update(byte[] keyBytes, Object value, MessageDigest messageDigest) {
    * @param key A unique package prefixed {@link String} that identifies this option (must be
    *            stable across builds, so {@link Class#getName()} should <em>not</em> be used).
    */
-  public static <T> Option<T> disk(String key, CacheKeyUpdater<T> cacheKeyUpdater) {
-    return new Option<>(key, null /*defaultValue*/, cacheKeyUpdater);
+  @NonNull
+  public static <T> Option<T> disk(@NonNull String key,
+      @NonNull CacheKeyUpdater<T> cacheKeyUpdater) {
+    return new Option<>(key, null, cacheKeyUpdater);
   }
 
   /**
@@ -77,11 +83,14 @@ public void update(byte[] keyBytes, Object value, MessageDigest messageDigest) {
    * @param key A unique package prefixed {@link String} that identifies this option (must be
    *            stable across builds, so {@link Class#getName()} should <em>not</em> be used).
    */
-  public static <T> Option<T> disk(String key, T defaultValue, CacheKeyUpdater<T> cacheKeyUpdater) {
+  @NonNull
+  public static <T> Option<T> disk(@NonNull String key, @Nullable T defaultValue,
+      @NonNull CacheKeyUpdater<T> cacheKeyUpdater) {
     return new Option<>(key, defaultValue, cacheKeyUpdater);
   }
 
-  Option(String key, T defaultValue, CacheKeyUpdater<T> cacheKeyUpdater) {
+  private Option(@NonNull String key, @Nullable T defaultValue,
+      @NonNull CacheKeyUpdater<T> cacheKeyUpdater) {
     this.key = Preconditions.checkNotEmpty(key);
     this.defaultValue = defaultValue;
     this.cacheKeyUpdater = Preconditions.checkNotNull(cacheKeyUpdater);
@@ -90,6 +99,8 @@ public void update(byte[] keyBytes, Object value, MessageDigest messageDigest) {
   /**
    * Returns a reasonable default to use if no other value is set, or {@code null}.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   @Nullable
   public T getDefaultValue() {
     return defaultValue;
@@ -100,10 +111,11 @@ public T getDefaultValue() {
    * value using the {@link com.bumptech.glide.load.Option.CacheKeyUpdater} optionally provided in
    * the constructor.
    */
-  public void update(T value, MessageDigest messageDigest) {
+  public void update(@NonNull T value, @NonNull MessageDigest messageDigest) {
     cacheKeyUpdater.update(getKeyBytes(), value, messageDigest);
   }
 
+  @NonNull
   private byte[] getKeyBytes() {
     if (keyBytes == null) {
       keyBytes = key.getBytes(Key.CHARSET);
@@ -125,6 +137,7 @@ public int hashCode() {
     return key.hashCode();
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
   private static <T> CacheKeyUpdater<T> emptyUpdater() {
     return (CacheKeyUpdater<T>) EMPTY_UPDATER;
@@ -147,7 +160,19 @@ public String toString() {
     /**
      * Updates the given {@link MessageDigest} with the bytes of the given key (to avoid incidental
      * value collisions when values are not particularly unique) and value.
+     *
+     * <p>If your {@link Option} shouldn't affect the disk cache key, you should not implement this
+     * class and use {@link Option#memory(String)} or {@link Option#memory(String, Object)} instead.
+     *
+     * @param keyBytes The bytes of the {@link String} used as the key for this particular
+     * {@link Option}. Should be added to the {@code messageDigest} using
+     * {@link MessageDigest#update(byte[])} by all implementations if the digest is updated with
+     * the given {@code value} parameter.
+     *
+     * @param value The value of of this particular option. Typically you should convert the value
+     * to a byte array using some stable mechanism and then call
+     * {@link MessageDigest#update(byte[])} to update the given digest.
      */
-    void update(byte[] keyBytes, T value, MessageDigest messageDigest);
+    void update(@NonNull byte[] keyBytes, @NonNull T value, @NonNull MessageDigest messageDigest);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/Options.java b/library/src/main/java/com/bumptech/glide/load/Options.java
index 32aa7c227..6609a080f 100644
--- a/library/src/main/java/com/bumptech/glide/load/Options.java
+++ b/library/src/main/java/com/bumptech/glide/load/Options.java
@@ -1,27 +1,31 @@
 package com.bumptech.glide.load;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.support.v4.util.ArrayMap;
 import android.support.v4.util.SimpleArrayMap;
+import com.bumptech.glide.util.CachedHashCodeArrayMap;
 import java.security.MessageDigest;
-import java.util.Map;
 
 /**
  * A set of {@link Option Options} to apply to in memory and disk cache keys.
  */
 public final class Options implements Key {
-  private final ArrayMap<Option<?>, Object> values = new ArrayMap<>();
+  private final ArrayMap<Option<?>, Object> values = new CachedHashCodeArrayMap<>();
 
-  public void putAll(Options other) {
+  public void putAll(@NonNull Options other) {
     values.putAll((SimpleArrayMap<Option<?>, Object>) other.values);
   }
 
-  public <T> Options set(Option<T> option, T value) {
+  @NonNull
+  public <T> Options set(@NonNull Option<T> option, @NonNull T value) {
     values.put(option, value);
     return this;
   }
 
+  @Nullable
   @SuppressWarnings("unchecked")
-  public <T> T get(Option<T> option) {
+  public <T> T get(@NonNull Option<T> option) {
     return values.containsKey(option) ? (T) values.get(option) : option.getDefaultValue();
   }
 
@@ -40,9 +44,11 @@ public int hashCode() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
-    for (Map.Entry<Option<?>, Object> entry : values.entrySet()) {
-      updateDiskCacheKey(entry.getKey(), entry.getValue(), messageDigest);
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
+    for (int i = 0; i < values.size(); i++) {
+      Option<?> key = values.keyAt(i);
+      Object value = values.valueAt(i);
+      updateDiskCacheKey(key, value, messageDigest);
     }
   }
 
@@ -54,7 +60,8 @@ public String toString() {
   }
 
   @SuppressWarnings("unchecked")
-  private static <T> void updateDiskCacheKey(Option<T> option, Object value, MessageDigest md) {
+  private static <T> void updateDiskCacheKey(@NonNull Option<T> option, @NonNull Object value,
+      @NonNull MessageDigest md) {
     option.update((T) value, md);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java
index f8e67f7e0..977339e25 100644
--- a/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import com.bumptech.glide.load.engine.Resource;
 import java.io.IOException;
@@ -16,29 +17,26 @@
    * Returns {@code true} if this decoder is capable of decoding the given source with the given
    * options, and {@code false} otherwise.
    *
-   * <p> Decoders should make a best effort attempt to quickly determine if they are likely to be
+   * <p>Decoders should make a best effort attempt to quickly determine if they are likely to be
    * able to decode data, but should not attempt to completely read the given data. A typical
    * implementation would check the file headers verify they match content the decoder expects to
-   * handle (i.e. a GIF decoder should verify that the image contains the GIF header block. </p>
+   * handle (i.e. a GIF decoder should verify that the image contains the GIF header block.
    *
-   * <p> Decoders that return {@code true} from {@link #handles(Object, Options)} may still
-   * return {@code null} from {@link #decode(Object, int, int, Options)} if the data is
-   * partial or formatted incorrectly. </p>
-   *
-   * @throws IOException
+   * <p>Decoders that return {@code true} from {@code handles} may still return {@code null} from
+   * {@link #decode(Object, int, int, Options)} if the data is partial or formatted incorrectly.
    */
-  boolean handles(T source, Options options) throws IOException;
+  boolean handles(@NonNull T source, @NonNull Options options) throws IOException;
 
   /**
    * Returns a decoded resource from the given data or null if no resource could be decoded.
    *
-   * <p> The {@code source} is managed by the caller, there's no need to close it. The returned
-   * {@link Resource} will be {@link Resource#recycle() released} when the engine sees fit. </p>
+   * <p>The {@code source} is managed by the caller, there's no need to close it. The returned
+   * {@link Resource} will be {@link Resource#recycle() released} when the engine sees fit.
    *
-   * <p> Note - The {@code width} and {@code height} arguments are hints only, there is no
+   * <p>Note - The {@code width} and {@code height} arguments are hints only, there is no
    * requirement that the decoded resource exactly match the given dimensions. A typical use case
    * would be to use the target dimensions to determine how much to downsample Bitmaps by to avoid
-   * overly large allocations. </p>
+   * overly large allocations.
    *
    * @param source  The data the resource should be decoded from.
    * @param width   The ideal width in pixels of the decoded resource, or {@link
@@ -52,8 +50,8 @@
    *                all of their option keys are present. However, implementations may assume that
    *                if one of their option keys is present, it's value is non-null and is of the
    *                expected type.
-   * @throws IOException
    */
   @Nullable
-  Resource<Z> decode(T source, int width, int height, Options options) throws IOException;
+  Resource<Z> decode(@NonNull T source, int width, int height, @NonNull Options options)
+      throws IOException;
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/ResourceEncoder.java b/library/src/main/java/com/bumptech/glide/load/ResourceEncoder.java
index 941d3845d..d17985845 100644
--- a/library/src/main/java/com/bumptech/glide/load/ResourceEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/ResourceEncoder.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.Resource;
 
 /**
@@ -10,5 +11,6 @@
  */
 public interface ResourceEncoder<T> extends Encoder<Resource<T>> {
   // specializing the generic arguments
-  EncodeStrategy getEncodeStrategy(Options options);
+  @NonNull
+  EncodeStrategy getEncodeStrategy(@NonNull Options options);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/Transformation.java b/library/src/main/java/com/bumptech/glide/load/Transformation.java
index 3d5c96e0f..2e9ab29d9 100644
--- a/library/src/main/java/com/bumptech/glide/load/Transformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/Transformation.java
@@ -1,7 +1,10 @@
 package com.bumptech.glide.load;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.Resource;
+import java.nio.charset.Charset;
+import java.security.MessageDigest;
 
 /**
  * A class for performing an arbitrary transformation on a resource that implements
@@ -9,11 +12,17 @@
  * cache and {@link #updateDiskCacheKey(java.security.MessageDigest)}} to identify the
  * transformation in disk caches.
  *
- * <p>Using the fully qualified class name (not {@link Class#getName()} to avoid proguard
- * obfuscation) is an easy way to implement
- * {@link #updateDiskCacheKey(java.security.MessageDigest)}} correctly.
+ * <p>Using the fully qualified class name as a static final {@link String} (not
+ * {@link Class#getName()} to avoid proguard obfuscation) is an easy way to implement
+ * {@link #updateDiskCacheKey(java.security.MessageDigest)}} correctly. If additional arguments are
+ * required they can be passed in to the constructor of the {@code Transformation} and then used to
+ * update the {@link java.security.MessageDigest} passed in to
+ * {@link #updateDiskCacheKey(MessageDigest)}. If arguments are primitive types, they can typically
+ * easily be serialized using {@link java.nio.ByteBuffer}. {@link String} types can be serialized
+ * with {@link String#getBytes(Charset)} using the constant {@link #CHARSET}.
  *
- * <p>Implementations <em>must</em> implement {@link #equals(Object)} and {@link #hashCode()}.
+ * <p>Implementations <em>must</em> implement {@link #equals(Object)} and {@link #hashCode()} for
+ * memory caching to work correctly.
  *
  * @param <T> The type of the resource being transformed.
  */
@@ -53,19 +62,7 @@
    *                  original resource height.
    * @return The transformed resource.
    */
-  Resource<T> transform(Context context, Resource<T> resource, int outWidth, int outHeight);
-
-  /**
-   * For caching to work correctly, implementations <em>must</em> implement this method and
-   * {@link #hashCode()}.
-   */
-  @Override
-  boolean equals(Object o);
-
-  /**
-   * For caching to work correctly, implementations <em>must</em> implement this method and
-   * {@link #equals(Object)}.
-   */
-  @Override
-  int hashCode();
+  @NonNull
+  Resource<T> transform(@NonNull Context context, @NonNull Resource<T> resource,
+      int outWidth, int outHeight);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/AssetFileDescriptorLocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/AssetFileDescriptorLocalUriFetcher.java
new file mode 100644
index 000000000..66a287823
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/data/AssetFileDescriptorLocalUriFetcher.java
@@ -0,0 +1,39 @@
+package com.bumptech.glide.load.data;
+
+import android.content.ContentResolver;
+import android.content.res.AssetFileDescriptor;
+import android.net.Uri;
+import android.support.annotation.NonNull;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+
+/**
+ * Fetches an {@link AssetFileDescriptor} for a local {@link android.net.Uri}.
+ */
+public final class AssetFileDescriptorLocalUriFetcher extends LocalUriFetcher<AssetFileDescriptor> {
+
+  public AssetFileDescriptorLocalUriFetcher(ContentResolver contentResolver, Uri uri) {
+    super(contentResolver, uri);
+  }
+
+  @Override
+  protected AssetFileDescriptor loadResource(Uri uri, ContentResolver contentResolver)
+      throws FileNotFoundException {
+    AssetFileDescriptor result = contentResolver.openAssetFileDescriptor(uri, "r");
+    if (result == null) {
+      throw new FileNotFoundException("FileDescriptor is null for: " + uri);
+    }
+    return result;
+  }
+
+  @Override
+  protected void close(AssetFileDescriptor data) throws IOException {
+    data.close();
+  }
+
+  @NonNull
+  @Override
+  public Class<AssetFileDescriptor> getDataClass() {
+    return AssetFileDescriptor.class;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java
index 366a9ad3d..f21eb6c64 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java
@@ -19,13 +19,15 @@
   private final AssetManager assetManager;
   private T data;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public AssetPathFetcher(AssetManager assetManager, String assetPath) {
     this.assetManager = assetManager;
     this.assetPath = assetPath;
   }
 
   @Override
-  public void loadData(Priority priority, DataCallback<? super T> callback) {
+  public void loadData(@NonNull Priority priority, @NonNull DataCallback<? super T> callback) {
     try {
       data = loadResource(assetManager, assetPath);
     } catch (IOException e) {
@@ -74,7 +76,6 @@ public DataSource getDataSource() {
    * Closes the concrete data type if necessary.
    *
    * @param data The data to close.
-   * @throws IOException
    */
   protected abstract void close(T data) throws IOException;
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/BufferedOutputStream.java b/library/src/main/java/com/bumptech/glide/load/data/BufferedOutputStream.java
new file mode 100644
index 000000000..ce9cd17b1
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/data/BufferedOutputStream.java
@@ -0,0 +1,102 @@
+package com.bumptech.glide.load.data;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * An {@link OutputStream} implementation that recycles and re-uses {@code byte[]}s using the
+ * provided {@link ArrayPool}.
+ */
+public final class BufferedOutputStream extends OutputStream {
+  @NonNull
+  private final OutputStream out;
+  private byte[] buffer;
+  private ArrayPool arrayPool;
+  private int index;
+
+  public BufferedOutputStream(@NonNull OutputStream out, @NonNull ArrayPool arrayPool) {
+    this(out, arrayPool, ArrayPool.STANDARD_BUFFER_SIZE_BYTES);
+  }
+
+  @VisibleForTesting
+  BufferedOutputStream(@NonNull OutputStream out, ArrayPool arrayPool, int bufferSize) {
+    this.out = out;
+    this.arrayPool = arrayPool;
+    buffer = arrayPool.get(bufferSize, byte[].class);
+  }
+
+  @Override
+  public void write(int b) throws IOException {
+    buffer[index++] = (byte) b;
+    maybeFlushBuffer();
+  }
+
+  @Override
+  public void write(@NonNull byte[] b) throws IOException {
+    write(b, 0, b.length);
+  }
+
+  @Override
+  public void write(@NonNull byte[] b, int initialOffset, int length) throws IOException {
+    int writtenSoFar = 0;
+    do {
+      int remainingToWrite = length - writtenSoFar;
+      int currentOffset = initialOffset + writtenSoFar;
+      // If we still need to write at least the buffer size worth of bytes, we might as well do so
+      // directly and avoid the overhead of copying to the buffer first.
+      if (index == 0 && remainingToWrite >= buffer.length) {
+        out.write(b, currentOffset, remainingToWrite);
+        return;
+      }
+
+      int remainingSpaceInBuffer = buffer.length - index;
+      int totalBytesToWriteToBuffer = Math.min(remainingToWrite, remainingSpaceInBuffer);
+
+      System.arraycopy(b, currentOffset, buffer, index, totalBytesToWriteToBuffer);
+
+      index += totalBytesToWriteToBuffer;
+      writtenSoFar += totalBytesToWriteToBuffer;
+
+      maybeFlushBuffer();
+    } while (writtenSoFar < length);
+  }
+
+  @Override
+  public void flush() throws IOException {
+    flushBuffer();
+    out.flush();
+  }
+
+  private void flushBuffer() throws IOException {
+    if (index > 0) {
+      out.write(buffer, 0, index);
+      index = 0;
+    }
+  }
+
+  private void maybeFlushBuffer() throws IOException {
+    if (index == buffer.length) {
+      flushBuffer();
+    }
+  }
+
+  @Override
+  public void close() throws IOException {
+    try {
+      flush();
+    } finally {
+      out.close();
+    }
+    release();
+  }
+
+  private void release() {
+    if (buffer != null) {
+      arrayPool.put(buffer);
+      buffer = null;
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java
index 9889eaf06..4a1674fd9 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java
@@ -39,7 +39,7 @@
      *
      * @param e a non-null {@link Exception} indicating why the load failed.
      */
-    void onLoadFailed(Exception e);
+    void onLoadFailed(@NonNull Exception e);
   }
 
   /**
@@ -63,7 +63,7 @@
    * @param callback The callback to use when the request is complete
    * @see #cleanup() where the data retuned will be cleaned up
    */
-  void loadData(Priority priority, DataCallback<? super T> callback);
+  void loadData(@NonNull Priority priority, @NonNull DataCallback<? super T> callback);
 
   /**
    * Cleanup or recycle any resources used by this data fetcher. This method will be called in a
diff --git a/library/src/main/java/com/bumptech/glide/load/data/DataRewinder.java b/library/src/main/java/com/bumptech/glide/load/data/DataRewinder.java
index 73dd6411e..805198ca6 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/DataRewinder.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/DataRewinder.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.data;
 
+import android.support.annotation.NonNull;
 import java.io.IOException;
 
 /**
@@ -20,12 +21,14 @@
     /**
      * Returns a new {@link com.bumptech.glide.load.data.DataRewinder} wrapping the given data.
      */
-    DataRewinder<T> build(T data);
+    @NonNull
+    DataRewinder<T> build(@NonNull T data);
 
     /**
      * Returns the class of data this factory can produce
      * {@link com.bumptech.glide.load.data.DataRewinder}s for.
      */
+    @NonNull
     Class<T> getDataClass();
   }
 
@@ -34,8 +37,8 @@
    * returns the re-wound data (or a wrapper for the re-wound data).
    *
    * @return An object pointing to the wrapped data.
-   * @throws IOException
    */
+  @NonNull
   T rewindAndGet() throws IOException;
 
   /**
diff --git a/library/src/main/java/com/bumptech/glide/load/data/DataRewinderRegistry.java b/library/src/main/java/com/bumptech/glide/load/data/DataRewinderRegistry.java
index 1d7ce3c2e..9aa20bc8f 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/DataRewinderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/DataRewinderRegistry.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.data;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.util.Preconditions;
 import java.util.HashMap;
 import java.util.Map;
@@ -12,23 +13,26 @@
   private final Map<Class<?>, DataRewinder.Factory<?>> rewinders = new HashMap<>();
   private static final DataRewinder.Factory<?> DEFAULT_FACTORY =
       new DataRewinder.Factory<Object>() {
+        @NonNull
         @Override
-        public DataRewinder<Object> build(Object data) {
+        public DataRewinder<Object> build(@NonNull Object data) {
           return new DefaultRewinder(data);
         }
 
+        @NonNull
         @Override
         public Class<Object> getDataClass() {
           throw new UnsupportedOperationException("Not implemented");
         }
       };
 
-  public synchronized void register(DataRewinder.Factory<?> factory) {
+  public synchronized void register(@NonNull DataRewinder.Factory<?> factory) {
     rewinders.put(factory.getDataClass(), factory);
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
-  public synchronized <T> DataRewinder<T> build(T data) {
+  public synchronized <T> DataRewinder<T> build(@NonNull T data) {
     Preconditions.checkNotNull(data);
     DataRewinder.Factory<T> result = (DataRewinder.Factory<T>) rewinders.get(data.getClass());
     if (result == null) {
@@ -46,13 +50,14 @@ public synchronized void register(DataRewinder.Factory<?> factory) {
     return result.build(data);
   }
 
-  private static class DefaultRewinder implements DataRewinder<Object> {
+  private static final class DefaultRewinder implements DataRewinder<Object> {
     private final Object data;
 
-    public DefaultRewinder(Object data) {
+    DefaultRewinder(@NonNull Object data) {
       this.data = data;
     }
 
+    @NonNull
     @Override
     public Object rewindAndGet() {
       return data;
diff --git a/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java b/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java
index de4436d93..85df91b5f 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.data;
 
+import android.support.annotation.NonNull;
 import java.io.FilterInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -15,46 +16,46 @@
   /** Allow two bytes for the file format. */
   private static final int SEGMENT_START_POSITION = 2;
   private static final byte[] EXIF_SEGMENT = new byte[] {
-      /** segment start id. */
+      /* segment start id. */
       (byte) 0xFF,
-      /** segment type. */
+      /* segment type. */
       (byte) 0xE1,
-      /** segmentLength. */
+      /* segmentLength. */
       0x00,
       (byte) 0x1C,
-      /** exif identifier. */
+      /* exif identifier. */
       0x45,
       0x78,
       0x69,
       0x66,
       0x00,
       0x00,
-      /** motorola byte order (big endian). */
+      /* motorola byte order (big endian). */
       (byte) 0x4D,
       (byte) 0x4D,
-      /** filler? */
+      /* filler? */
       0x00,
       0x00,
-      /** first id offset. */
+      /* first id offset. */
       0x00,
       0x00,
       0x00,
       0x08,
-      /** tagCount. */
+      /* tagCount. */
       0x00,
       0x01,
-      /** exif tag type. */
+      /* exif tag type. */
       0x01,
       0x12,
-      /** 2 byte format. */
+      /* 2 byte format. */
       0x00,
       0x02,
-      /** component count. */
+      /* component count. */
       0x00,
       0x00,
       0x00,
       0x01,
-      /** 2 byte orientation value, the first byte of which is always 0. */
+      /* 2 byte orientation value, the first byte of which is always 0. */
       0x00,
   };
   private static final int SEGMENT_LENGTH = EXIF_SEGMENT.length;
@@ -75,8 +76,10 @@ public boolean markSupported() {
     return false;
   }
 
+  // No need for synchronized since all we do is throw.
+  @SuppressWarnings("UnsynchronizedOverridesSynchronized")
   @Override
-  public void mark(int readlimit) {
+  public void mark(int readLimit) {
     throw new UnsupportedOperationException();
   }
 
@@ -97,7 +100,7 @@ public int read() throws IOException {
   }
 
   @Override
-  public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
+  public int read(@NonNull byte[] buffer, int byteOffset, int byteCount) throws IOException {
     int read;
     if (position > ORIENTATION_POSITION) {
       read = super.read(buffer, byteOffset, byteCount);
@@ -120,11 +123,14 @@ public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException
   public long skip(long byteCount) throws IOException {
     long skipped = super.skip(byteCount);
     if (skipped > 0) {
-      position += skipped;
+      // See https://errorprone.info/bugpattern/NarrowingCompoundAssignment.
+      position = (int) (position + skipped);
     }
     return skipped;
   }
 
+  // No need for synchronized since all we do is throw.
+  @SuppressWarnings("UnsynchronizedOverridesSynchronized")
   @Override
   public void reset() throws IOException {
     throw new UnsupportedOperationException();
diff --git a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java
index 6a6bf316c..176f206d9 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java
@@ -3,7 +3,6 @@
 import android.content.res.AssetManager;
 import android.os.ParcelFileDescriptor;
 import android.support.annotation.NonNull;
-
 import java.io.IOException;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java
index 09b6e5e26..2a159b92b 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java
@@ -5,7 +5,6 @@
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
 import android.support.annotation.NonNull;
-
 import java.io.FileNotFoundException;
 import java.io.IOException;
 
diff --git a/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
index 91a464a37..e8f914b6e 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.data;
 
 import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
 import android.text.TextUtils;
 import android.util.Log;
 import com.bumptech.glide.Priority;
@@ -23,9 +24,13 @@
 public class HttpUrlFetcher implements DataFetcher<InputStream> {
   private static final String TAG = "HttpUrlFetcher";
   private static final int MAXIMUM_REDIRECTS = 5;
-  // Visible for testing.
+  @VisibleForTesting
   static final HttpUrlConnectionFactory DEFAULT_CONNECTION_FACTORY =
       new DefaultHttpUrlConnectionFactory();
+  /**
+   * Returned when a connection error prevented us from receiving an http error.
+   */
+  private static final int INVALID_STATUS_CODE = -1;
 
   private final GlideUrl glideUrl;
   private final int timeout;
@@ -39,7 +44,7 @@ public HttpUrlFetcher(GlideUrl glideUrl, int timeout) {
     this(glideUrl, timeout, DEFAULT_CONNECTION_FACTORY);
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   HttpUrlFetcher(GlideUrl glideUrl, int timeout, HttpUrlConnectionFactory connectionFactory) {
     this.glideUrl = glideUrl;
     this.timeout = timeout;
@@ -47,25 +52,22 @@ public HttpUrlFetcher(GlideUrl glideUrl, int timeout) {
   }
 
   @Override
-  public void loadData(Priority priority, DataCallback<? super InputStream> callback) {
+  public void loadData(@NonNull Priority priority,
+      @NonNull DataCallback<? super InputStream> callback) {
     long startTime = LogTime.getLogTime();
-    final InputStream result;
     try {
-      result = loadDataWithRedirects(glideUrl.toURL(), 0 /*redirects*/, null /*lastUrl*/,
-          glideUrl.getHeaders());
+      InputStream result = loadDataWithRedirects(glideUrl.toURL(), 0, null, glideUrl.getHeaders());
+      callback.onDataReady(result);
     } catch (IOException e) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
         Log.d(TAG, "Failed to load data for url", e);
       }
       callback.onLoadFailed(e);
-      return;
-    }
-
-    if (Log.isLoggable(TAG, Log.VERBOSE)) {
-      Log.v(TAG, "Finished http url fetcher fetch in " + LogTime.getElapsedMillis(startTime)
-          + " ms and loaded " + result);
+    } finally {
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+        Log.v(TAG, "Finished http url fetcher fetch in " + LogTime.getElapsedMillis(startTime));
+      }
     }
-    callback.onDataReady(result);
   }
 
   private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,
@@ -100,26 +102,41 @@ private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,
 
     // Connect explicitly to avoid errors in decoders if connection fails.
     urlConnection.connect();
+    // Set the stream so that it's closed in cleanup to avoid resource leaks. See #2352.
+    stream = urlConnection.getInputStream();
     if (isCancelled) {
       return null;
     }
     final int statusCode = urlConnection.getResponseCode();
-    if (statusCode / 100 == 2) {
+    if (isHttpOk(statusCode)) {
       return getStreamForSuccessfulRequest(urlConnection);
-    } else if (statusCode / 100 == 3) {
+    } else if (isHttpRedirect(statusCode)) {
       String redirectUrlString = urlConnection.getHeaderField("Location");
       if (TextUtils.isEmpty(redirectUrlString)) {
         throw new HttpException("Received empty or null redirect url");
       }
       URL redirectUrl = new URL(url, redirectUrlString);
+      // Closing the stream specifically is required to avoid leaking ResponseBodys in addition
+      // to disconnecting the url connection below. See #2352.
+      cleanup();
       return loadDataWithRedirects(redirectUrl, redirects + 1, url, headers);
-    } else if (statusCode == -1) {
+    } else if (statusCode == INVALID_STATUS_CODE) {
       throw new HttpException(statusCode);
     } else {
       throw new HttpException(urlConnection.getResponseMessage(), statusCode);
     }
   }
 
+  // Referencing constants is less clear than a simple static method.
+  private static boolean isHttpOk(int statusCode) {
+    return statusCode / 100 == 2;
+  }
+
+  // Referencing constants is less clear than a simple static method.
+  private static boolean isHttpRedirect(int statusCode) {
+    return statusCode / 100 == 3;
+  }
+
   private InputStream getStreamForSuccessfulRequest(HttpURLConnection urlConnection)
       throws IOException {
     if (TextUtils.isEmpty(urlConnection.getContentEncoding())) {
@@ -146,6 +163,7 @@ public void cleanup() {
     if (urlConnection != null) {
       urlConnection.disconnect();
     }
+    urlConnection = null;
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/data/InputStreamRewinder.java b/library/src/main/java/com/bumptech/glide/load/data/InputStreamRewinder.java
index 08fce42d8..9a0766ce7 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/InputStreamRewinder.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/InputStreamRewinder.java
@@ -1,7 +1,9 @@
 package com.bumptech.glide.load.data;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.resource.bitmap.RecyclableBufferedInputStream;
+import com.bumptech.glide.util.Synthetic;
 import java.io.IOException;
 import java.io.InputStream;
 
@@ -15,11 +17,13 @@
 
   private final RecyclableBufferedInputStream bufferedStream;
 
+  @Synthetic
   InputStreamRewinder(InputStream is, ArrayPool byteArrayPool) {
     bufferedStream = new RecyclableBufferedInputStream(is, byteArrayPool);
     bufferedStream.mark(MARK_LIMIT);
   }
 
+  @NonNull
   @Override
   public InputStream rewindAndGet() throws IOException {
     bufferedStream.reset();
@@ -42,11 +46,13 @@ public Factory(ArrayPool byteArrayPool) {
       this.byteArrayPool = byteArrayPool;
     }
 
+    @NonNull
     @Override
     public DataRewinder<InputStream> build(InputStream data) {
       return new InputStreamRewinder(data, byteArrayPool);
     }
 
+    @NonNull
     @Override
     public Class<InputStream> getDataClass() {
       return InputStream.class;
diff --git a/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java
index 81d12b054..68ee75305 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java
@@ -30,13 +30,16 @@
    *                by {@link ContentResolver#openInputStream(android.net.Uri)}
    * @see ContentResolver#openInputStream(android.net.Uri)
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public LocalUriFetcher(ContentResolver contentResolver, Uri uri) {
     this.contentResolver = contentResolver;
     this.uri = uri;
   }
 
   @Override
-  public final void loadData(Priority priority, DataCallback<? super T> callback) {
+  public final void loadData(@NonNull Priority priority,
+      @NonNull DataCallback<? super T> callback) {
     try {
       data = loadResource(uri, contentResolver);
     } catch (FileNotFoundException e) {
diff --git a/library/src/main/java/com/bumptech/glide/load/data/StreamAssetPathFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/StreamAssetPathFetcher.java
index d09c414e8..aaad13214 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/StreamAssetPathFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/StreamAssetPathFetcher.java
@@ -2,7 +2,6 @@
 
 import android.content.res.AssetManager;
 import android.support.annotation.NonNull;
-
 import java.io.IOException;
 import java.io.InputStream;
 
diff --git a/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
index b690aa93f..758e4a543 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
@@ -1,13 +1,10 @@
 package com.bumptech.glide.load.data;
 
-import android.annotation.TargetApi;
 import android.content.ContentResolver;
 import android.content.UriMatcher;
 import android.net.Uri;
-import android.os.Build;
 import android.provider.ContactsContract;
 import android.support.annotation.NonNull;
-
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
@@ -89,7 +86,6 @@ private InputStream loadResourceFromUri(Uri uri, ContentResolver contentResolver
     }
   }
 
-  @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
   private InputStream openContactPhotoInputStream(ContentResolver contentResolver, Uri contactUri) {
     return ContactsContract.Contacts.openContactPhotoInputStream(contentResolver, contactUri,
         true /*preferHighres*/);
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/MediaStoreUtil.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/MediaStoreUtil.java
index dc6cbef6e..d7f7e44af 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/mediastore/MediaStoreUtil.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/MediaStoreUtil.java
@@ -3,6 +3,7 @@
 import android.content.ContentResolver;
 import android.net.Uri;
 import android.provider.MediaStore;
+import com.bumptech.glide.request.target.Target;
 
 /**
  * Utility classes for interacting with the media store.
@@ -33,6 +34,9 @@ public static boolean isMediaStoreImageUri(Uri uri) {
   }
 
   public static boolean isThumbnailSize(int width, int height) {
-    return width <= MINI_THUMB_WIDTH && height <= MINI_THUMB_HEIGHT;
+    return width != Target.SIZE_ORIGINAL
+        && height != Target.SIZE_ORIGINAL
+        && width <= MINI_THUMB_WIDTH
+        && height <= MINI_THUMB_HEIGHT;
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
index 64fcec28f..3b90b0a6b 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
@@ -6,6 +6,7 @@
 import android.net.Uri;
 import android.provider.MediaStore;
 import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
 import android.util.Log;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.Priority;
@@ -28,8 +29,6 @@
   private final ThumbnailStreamOpener opener;
   private InputStream inputStream;
 
-  // TODO(nnaze): These build methods do not need the full Glide or Context objects.
-
   public static ThumbFetcher buildImageFetcher(Context context, Uri uri) {
     return build(context, uri, new ImageThumbnailQuery(context.getContentResolver()));
   }
@@ -46,14 +45,15 @@ private static ThumbFetcher build(Context context, Uri uri, ThumbnailQuery query
     return new ThumbFetcher(uri, opener);
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   ThumbFetcher(Uri mediaStoreImageUri, ThumbnailStreamOpener opener) {
     this.mediaStoreImageUri = mediaStoreImageUri;
     this.opener = opener;
   }
 
   @Override
-  public void loadData(Priority priority, DataCallback<? super InputStream> callback) {
+  public void loadData(@NonNull Priority priority,
+      @NonNull DataCallback<? super InputStream> callback) {
     try {
       inputStream = openThumbInputStream();
     } catch (FileNotFoundException e) {
@@ -118,11 +118,11 @@ public DataSource getDataSource() {
     }
 
     private static final String[] PATH_PROJECTION = {
-      MediaStore.Video.Thumbnails.DATA
+        MediaStore.Video.Thumbnails.DATA
     };
     private static final String PATH_SELECTION =
         MediaStore.Video.Thumbnails.KIND + " = " + MediaStore.Video.Thumbnails.MINI_KIND
-        + " AND " + MediaStore.Video.Thumbnails.VIDEO_ID + " = ?";
+            + " AND " + MediaStore.Video.Thumbnails.VIDEO_ID + " = ?";
 
     @Override
     public Cursor query(Uri uri) {
@@ -146,11 +146,11 @@ public Cursor query(Uri uri) {
     }
 
     private static final String[] PATH_PROJECTION = {
-      MediaStore.Images.Thumbnails.DATA,
+        MediaStore.Images.Thumbnails.DATA,
     };
     private static final String PATH_SELECTION =
         MediaStore.Images.Thumbnails.KIND + " = " + MediaStore.Images.Thumbnails.MINI_KIND
-        + " AND " + MediaStore.Images.Thumbnails.IMAGE_ID + " = ?";
+            + " AND " + MediaStore.Images.Thumbnails.IMAGE_ID + " = ?";
 
     @Override
     public Cursor query(Uri uri) {
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
index 323f02e17..7749477ac 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
@@ -3,6 +3,8 @@
 import android.content.ContentResolver;
 import android.database.Cursor;
 import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.text.TextUtils;
 import android.util.Log;
 import com.bumptech.glide.load.ImageHeaderParser;
@@ -24,13 +26,13 @@
   private final ContentResolver contentResolver;
   private final List<ImageHeaderParser> parsers;
 
-  public ThumbnailStreamOpener(
+  ThumbnailStreamOpener(
       List<ImageHeaderParser> parsers, ThumbnailQuery query, ArrayPool byteArrayPool,
       ContentResolver contentResolver) {
     this(parsers, DEFAULT_SERVICE, query, byteArrayPool, contentResolver);
   }
 
-  public ThumbnailStreamOpener(
+  ThumbnailStreamOpener(
       List<ImageHeaderParser> parsers,
       FileService service,
       ThumbnailQuery query,
@@ -43,13 +45,13 @@ public ThumbnailStreamOpener(
     this.parsers = parsers;
   }
 
-  public int getOrientation(Uri uri) {
+  int getOrientation(Uri uri) {
     InputStream is = null;
     try {
       is = contentResolver.openInputStream(uri);
       return ImageHeaderParserUtils.getOrientation(parsers, is, byteArrayPool);
-      // openInputStream can throw NPEs.
-    } catch (IOException | NullPointerException e) {
+      // PMD.AvoidCatchingNPE framework method openInputStream can throw NPEs.
+    } catch (@SuppressWarnings("PMD.AvoidCatchingNPE") IOException | NullPointerException e) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
         Log.d(TAG, "Failed to open uri: " + uri, e);
       }
@@ -66,37 +68,43 @@ public int getOrientation(Uri uri) {
   }
 
   public InputStream open(Uri uri) throws FileNotFoundException {
-    Uri thumbnailUri = null;
-    InputStream inputStream = null;
+    String path = getPath(uri);
+    if (TextUtils.isEmpty(path)) {
+      return null;
+    }
+
+    File file = service.get(path);
+    if (!isValid(file)) {
+      return null;
+    }
+
+    Uri thumbnailUri = Uri.fromFile(file);
+    try {
+      return contentResolver.openInputStream(thumbnailUri);
+      // PMD.AvoidCatchingNPE framework method openInputStream can throw NPEs.
+    } catch (@SuppressWarnings("PMD.AvoidCatchingNPE") NullPointerException e) {
+      throw (FileNotFoundException)
+          new FileNotFoundException("NPE opening uri: " + uri + " -> " + thumbnailUri).initCause(e);
+    }
+  }
 
+  @Nullable
+  private String getPath(@NonNull Uri uri) {
     final Cursor cursor = query.query(uri);
     try {
-      if (cursor == null || !cursor.moveToFirst()) {
+      if (cursor != null && cursor.moveToFirst()) {
+        return cursor.getString(0);
+      } else {
         return null;
       }
-      String path = cursor.getString(0);
-      if (TextUtils.isEmpty(path)) {
-        return null;
-      }
-
-      File file = service.get(path);
-      if (service.exists(file) && service.length(file) > 0) {
-        thumbnailUri = Uri.fromFile(file);
-      }
     } finally {
       if (cursor != null) {
         cursor.close();
       }
     }
-    if (thumbnailUri != null) {
-      try {
-        inputStream = contentResolver.openInputStream(thumbnailUri);
-        // openInputStream can throw NPEs.
-      } catch (NullPointerException e) {
-        throw (FileNotFoundException)
-          new FileNotFoundException("NPE opening uri: " + thumbnailUri).initCause(e);
-      }
-    }
-    return inputStream;
+  }
+
+  private boolean isValid(File file) {
+    return service.exists(file) && 0 < service.length(file);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java b/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java
new file mode 100644
index 000000000..5ccbf7b7f
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java
@@ -0,0 +1,201 @@
+package com.bumptech.glide.load.engine;
+
+import android.os.Handler;
+import android.os.Handler.Callback;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Process;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.engine.EngineResource.ResourceListener;
+import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Synthetic;
+import com.bumptech.glide.util.Util;
+import java.lang.ref.ReferenceQueue;
+import java.lang.ref.WeakReference;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.TimeUnit;
+
+final class ActiveResources {
+  private static final int MSG_CLEAN_REF = 1;
+
+  private final boolean isActiveResourceRetentionAllowed;
+  private final Handler mainHandler = new Handler(Looper.getMainLooper(), new Callback() {
+    @Override
+    public boolean handleMessage(Message msg) {
+      if (msg.what == MSG_CLEAN_REF) {
+        cleanupActiveReference((ResourceWeakReference) msg.obj);
+        return true;
+      }
+      return false;
+    }
+  });
+  @VisibleForTesting
+  final Map<Key, ResourceWeakReference> activeEngineResources = new HashMap<>();
+
+  private ResourceListener listener;
+
+  /**
+   * Lazily instantiate to avoid exceptions if Glide is initialized on a background thread.
+   *
+   * @see <a href="https://github.com/bumptech/glide/issues/295">#295</a>
+   */
+  @Nullable
+  private ReferenceQueue<EngineResource<?>> resourceReferenceQueue;
+  @Nullable
+  private Thread cleanReferenceQueueThread;
+  private volatile boolean isShutdown;
+  @Nullable
+  private volatile DequeuedResourceCallback cb;
+
+  ActiveResources(boolean isActiveResourceRetentionAllowed) {
+    this.isActiveResourceRetentionAllowed = isActiveResourceRetentionAllowed;
+  }
+
+  void setListener(ResourceListener listener) {
+    this.listener = listener;
+  }
+
+  void activate(Key key, EngineResource<?> resource) {
+    ResourceWeakReference toPut =
+        new ResourceWeakReference(
+            key,
+            resource,
+            getReferenceQueue(),
+            isActiveResourceRetentionAllowed);
+
+    ResourceWeakReference removed = activeEngineResources.put(key, toPut);
+    if (removed != null) {
+      removed.reset();
+    }
+  }
+
+  void deactivate(Key key) {
+    ResourceWeakReference removed = activeEngineResources.remove(key);
+    if (removed != null) {
+      removed.reset();
+    }
+  }
+
+  @Nullable
+  EngineResource<?> get(Key key) {
+    ResourceWeakReference activeRef = activeEngineResources.get(key);
+    if (activeRef == null) {
+      return null;
+    }
+
+    EngineResource<?> active = activeRef.get();
+    if (active == null) {
+      cleanupActiveReference(activeRef);
+    }
+    return active;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic void cleanupActiveReference(@NonNull ResourceWeakReference ref) {
+    Util.assertMainThread();
+    activeEngineResources.remove(ref.key);
+
+    if (!ref.isCacheable || ref.resource == null) {
+      return;
+    }
+    EngineResource<?> newResource =
+        new EngineResource<>(ref.resource, /*isCacheable=*/ true, /*isRecyclable=*/ false);
+    newResource.setResourceListener(ref.key, listener);
+    listener.onResourceReleased(ref.key, newResource);
+  }
+
+  private ReferenceQueue<EngineResource<?>> getReferenceQueue() {
+    if (resourceReferenceQueue == null) {
+      resourceReferenceQueue = new ReferenceQueue<>();
+      cleanReferenceQueueThread = new Thread(new Runnable() {
+        @SuppressWarnings("InfiniteLoopStatement")
+        @Override
+        public void run() {
+          Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
+          cleanReferenceQueue();
+        }
+      }, "glide-active-resources");
+      cleanReferenceQueueThread.start();
+    }
+    return resourceReferenceQueue;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic void cleanReferenceQueue() {
+    while (!isShutdown) {
+      try {
+        ResourceWeakReference ref = (ResourceWeakReference) resourceReferenceQueue.remove();
+        mainHandler.obtainMessage(MSG_CLEAN_REF, ref).sendToTarget();
+
+        // This section for testing only.
+        DequeuedResourceCallback current = cb;
+        if (current != null) {
+          current.onResourceDequeued();
+        }
+        // End for testing only.
+      } catch (InterruptedException e) {
+        Thread.currentThread().interrupt();
+      }
+    }
+  }
+
+  @VisibleForTesting
+  void setDequeuedResourceCallback(DequeuedResourceCallback cb) {
+    this.cb = cb;
+  }
+
+  @VisibleForTesting
+  interface DequeuedResourceCallback {
+    void onResourceDequeued();
+  }
+
+  @VisibleForTesting
+  void shutdown() {
+    isShutdown = true;
+    if (cleanReferenceQueueThread == null) {
+      return;
+    }
+
+    cleanReferenceQueueThread.interrupt();
+    try {
+      cleanReferenceQueueThread.join(TimeUnit.SECONDS.toMillis(5));
+      if (cleanReferenceQueueThread.isAlive()) {
+        throw new RuntimeException("Failed to join in time");
+      }
+    } catch (InterruptedException e) {
+      Thread.currentThread().interrupt();
+    }
+  }
+
+  @VisibleForTesting
+  static final class ResourceWeakReference extends WeakReference<EngineResource<?>> {
+    @SuppressWarnings("WeakerAccess") @Synthetic final Key key;
+    @SuppressWarnings("WeakerAccess") @Synthetic final boolean isCacheable;
+
+    @Nullable @SuppressWarnings("WeakerAccess") @Synthetic Resource<?> resource;
+
+    @Synthetic
+    @SuppressWarnings("WeakerAccess")
+    ResourceWeakReference(
+        @NonNull Key key,
+        @NonNull EngineResource<?> referent,
+        @NonNull ReferenceQueue<? super EngineResource<?>> queue,
+        boolean isActiveResourceRetentionAllowed) {
+      super(referent, queue);
+      this.key = Preconditions.checkNotNull(key);
+      this.resource =
+          referent.isCacheable() && isActiveResourceRetentionAllowed
+              ? Preconditions.checkNotNull(referent.getResource()) : null;
+      isCacheable = referent.isCacheable();
+    }
+
+    void reset() {
+      resource = null;
+      clear();
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java
index a97652e7d..bc19d18eb 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.data.DataFetcher;
@@ -15,7 +16,7 @@
 class DataCacheGenerator implements DataFetcherGenerator,
     DataFetcher.DataCallback<Object> {
 
-  private List<Key> cacheKeys;
+  private final List<Key> cacheKeys;
   private final DecodeHelper<?> helper;
   private final FetcherReadyCallback cb;
 
@@ -50,6 +51,9 @@ public boolean startNext() {
       }
 
       Key sourceId = cacheKeys.get(sourceIdIndex);
+      // PMD.AvoidInstantiatingObjectsInLoops The loop iterates a limited number of times
+      // and the actions it performs are much more expensive than a single allocation.
+      @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")
       Key originalKey = new DataCacheKey(sourceId, helper.getSignature());
       cacheFile = helper.getDiskCache().get(originalKey);
       if (cacheFile != null) {
@@ -92,7 +96,7 @@ public void onDataReady(Object data) {
   }
 
   @Override
-  public void onLoadFailed(Exception e) {
+  public void onLoadFailed(@NonNull Exception e) {
     cb.onDataFetcherFailed(sourceKey, e, loadData.fetcher, DataSource.DATA_DISK_CACHE);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java
index e70792c74..5177438a9 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Key;
 import java.security.MessageDigest;
 
@@ -11,12 +12,12 @@
   private final Key sourceKey;
   private final Key signature;
 
-  public DataCacheKey(Key sourceKey, Key signature) {
+  DataCacheKey(Key sourceKey, Key signature) {
     this.sourceKey = sourceKey;
     this.signature = signature;
   }
 
-  public Key getSourceKey() {
+  Key getSourceKey() {
     return sourceKey;
   }
 
@@ -45,7 +46,7 @@ public String toString() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     sourceKey.updateDiskCacheKey(messageDigest);
     signature.updateDiskCacheKey(messageDigest);
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheWriter.java b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheWriter.java
index eb7d4a4bd..59f39bd00 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheWriter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheWriter.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.cache.DiskCache;
@@ -26,7 +27,7 @@
   }
 
   @Override
-  public boolean write(File file) {
+  public boolean write(@NonNull File file) {
     return encoder.encode(data, file, options);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
index bbd9504ed..6a4283f1c 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
@@ -8,6 +8,8 @@
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceEncoder;
 import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DecodeJob.DiskCacheProvider;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.cache.DiskCache;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoader.LoadData;
@@ -16,6 +18,7 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
 
 final class DecodeHelper<Transcode> {
 
@@ -37,9 +40,10 @@
   private Priority priority;
   private DiskCacheStrategy diskCacheStrategy;
   private boolean isTransformationRequired;
+  private boolean isScaleOnlyOrNoTransform;
 
   @SuppressWarnings("unchecked")
-  <R> DecodeHelper<R> init(
+  <R> void init(
       GlideContext glideContext,
       Object model,
       Key signature,
@@ -52,7 +56,8 @@
       Options options,
       Map<Class<?>, Transformation<?>> transformations,
       boolean isTransformationRequired,
-      DecodeJob.DiskCacheProvider diskCacheProvider) {
+      boolean isScaleOnlyOrNoTransform,
+      DiskCacheProvider diskCacheProvider) {
     this.glideContext = glideContext;
     this.model = model;
     this.signature = signature;
@@ -66,12 +71,8 @@
     this.options = options;
     this.transformations = transformations;
     this.isTransformationRequired = isTransformationRequired;
+    this.isScaleOnlyOrNoTransform = isScaleOnlyOrNoTransform;
 
-    return (DecodeHelper<R>) this;
-  }
-
-  Object getModel() {
-    return model;
   }
 
   void clear() {
@@ -119,6 +120,18 @@ int getHeight() {
     return height;
   }
 
+  ArrayPool getArrayPool() {
+    return glideContext.getArrayPool();
+  }
+
+  Class<?> getTranscodeClass() {
+    return transcodeClass;
+  }
+
+  Class<?> getModelClass() {
+    return model.getClass();
+  }
+
   List<Class<?>> getRegisteredResourceClasses() {
     return glideContext.getRegistry()
         .getRegisteredResourceClasses(model.getClass(), resourceClass, transcodeClass);
@@ -132,10 +145,23 @@ boolean hasLoadPath(Class<?> dataClass) {
     return glideContext.getRegistry().getLoadPath(dataClass, resourceClass, transcodeClass);
   }
 
+  boolean isScaleOnlyOrNoTransform() {
+    return isScaleOnlyOrNoTransform;
+  }
+
   @SuppressWarnings("unchecked")
   <Z> Transformation<Z> getTransformation(Class<Z> resourceClass) {
     Transformation<Z> result = (Transformation<Z>) transformations.get(resourceClass);
-     if (result == null) {
+    if (result == null) {
+      for (Entry<Class<?>, Transformation<?>> entry : transformations.entrySet()) {
+        if (entry.getKey().isAssignableFrom(resourceClass)) {
+          result = (Transformation<Z>) entry.getValue();
+          break;
+        }
+      }
+    }
+
+    if (result == null) {
       if (transformations.isEmpty() && isTransformationRequired) {
         throw new IllegalArgumentException(
             "Missing transformation for " + resourceClass + ". If you wish to"
@@ -162,8 +188,8 @@ boolean isResourceEncoderAvailable(Resource<?> resource) {
 
   boolean isSourceKey(Key key) {
     List<LoadData<?>> loadData = getLoadData();
-    int size = loadData.size();
-    for (int i = 0; i < size; i++) {
+    //noinspection ForLoopReplaceableByForEach to improve perf
+    for (int i = 0, size = loadData.size(); i < size; i++) {
       LoadData<?> current = loadData.get(i);
       if (current.sourceKey.equals(key)) {
         return true;
@@ -177,8 +203,8 @@ boolean isSourceKey(Key key) {
       isLoadDataSet = true;
       loadData.clear();
       List<ModelLoader<Object, ?>> modelLoaders = glideContext.getRegistry().getModelLoaders(model);
-      int size = modelLoaders.size();
-      for (int i = 0; i < size; i++) {
+      //noinspection ForLoopReplaceableByForEach to improve perf
+      for (int i = 0, size = modelLoaders.size(); i < size; i++) {
         ModelLoader<Object, ?> modelLoader = modelLoaders.get(i);
         LoadData<?> current =
             modelLoader.buildLoadData(model, width, height, options);
@@ -195,8 +221,8 @@ boolean isSourceKey(Key key) {
       isCacheKeysSet = true;
       cacheKeys.clear();
       List<LoadData<?>> loadData = getLoadData();
-      int size = loadData.size();
-      for (int i = 0; i < size; i++) {
+      //noinspection ForLoopReplaceableByForEach to improve perf
+      for (int i = 0, size = loadData.size(); i < size; i++) {
         LoadData<?> data = loadData.get(i);
         if (!cacheKeys.contains(data.sourceKey)) {
           cacheKeys.add(data.sourceKey);
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
index 8ec74f5a2..903d0c9b6 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.engine;
 
-import android.support.v4.os.TraceCompat;
+import android.os.Build;
+import android.support.annotation.NonNull;
 import android.support.v4.util.Pools;
 import android.util.Log;
 import com.bumptech.glide.GlideContext;
@@ -15,9 +16,11 @@
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.DataRewinder;
 import com.bumptech.glide.load.engine.cache.DiskCache;
+import com.bumptech.glide.load.resource.bitmap.Downsampler;
 import com.bumptech.glide.util.LogTime;
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.pool.FactoryPools.Poolable;
+import com.bumptech.glide.util.pool.GlideTrace;
 import com.bumptech.glide.util.pool.StateVerifier;
 import java.util.ArrayList;
 import java.util.List;
@@ -38,31 +41,32 @@
     Poolable {
   private static final String TAG = "DecodeJob";
 
-  @Synthetic final DecodeHelper<R> decodeHelper = new DecodeHelper<>();
-  private final List<Exception> exceptions = new ArrayList<>();
+  private final DecodeHelper<R> decodeHelper = new DecodeHelper<>();
+  private final List<Throwable> throwables = new ArrayList<>();
   private final StateVerifier stateVerifier = StateVerifier.newInstance();
   private final DiskCacheProvider diskCacheProvider;
   private final Pools.Pool<DecodeJob<?>> pool;
-  @Synthetic final DeferredEncodeManager<?> deferredEncodeManager = new DeferredEncodeManager<>();
+  private final DeferredEncodeManager<?> deferredEncodeManager = new DeferredEncodeManager<>();
   private final ReleaseManager releaseManager = new ReleaseManager();
 
   private GlideContext glideContext;
-  @Synthetic Key signature;
+  private Key signature;
   private Priority priority;
   private EngineKey loadKey;
-  @Synthetic int width;
-  @Synthetic int height;
-  @Synthetic DiskCacheStrategy diskCacheStrategy;
-  @Synthetic Options options;
+  private int width;
+  private int height;
+  private DiskCacheStrategy diskCacheStrategy;
+  private Options options;
   private Callback<R> callback;
   private int order;
   private Stage stage;
   private RunReason runReason;
   private long startFetchTime;
   private boolean onlyRetrieveFromCache;
+  private Object model;
 
   private Thread currentThread;
-  @Synthetic Key currentSourceKey;
+  private Key currentSourceKey;
   private Key currentAttemptingKey;
   private Object currentData;
   private DataSource currentDataSource;
@@ -90,6 +94,7 @@
       DiskCacheStrategy diskCacheStrategy,
       Map<Class<?>, Transformation<?>> transformations,
       boolean isTransformationRequired,
+      boolean isScaleOnlyOrNoTransform,
       boolean onlyRetrieveFromCache,
       Options options,
       Callback<R> callback,
@@ -107,6 +112,7 @@
         options,
         transformations,
         isTransformationRequired,
+        isScaleOnlyOrNoTransform,
         diskCacheProvider);
     this.glideContext = glideContext;
     this.signature = signature;
@@ -120,6 +126,7 @@
     this.callback = callback;
     this.order = order;
     this.runReason = RunReason.INITIALIZE;
+    this.model = model;
     return this;
   }
 
@@ -135,8 +142,8 @@ boolean willDecodeFromCache() {
   /**
    * Called when this object is no longer in use externally.
    *
-   * @param isRemovedFromQueue {@code true} if we've been removed from the queue and {@link #run}
-   *                           is neither in progress nor will ever be called again.
+   * @param isRemovedFromQueue {@code true} if we've been removed from the queue and {@link #run} is
+   *                           neither in progress nor will ever be called again.
    */
   void release(boolean isRemovedFromQueue) {
     if (releaseManager.release(isRemovedFromQueue)) {
@@ -183,12 +190,13 @@ private void releaseInternal() {
     currentFetcher = null;
     startFetchTime = 0L;
     isCancelled = false;
-    exceptions.clear();
+    model = null;
+    throwables.clear();
     pool.release(this);
   }
 
   @Override
-  public int compareTo(DecodeJob<?> other) {
+  public int compareTo(@NonNull DecodeJob<?> other) {
     int result = getPriority() - other.getPriority();
     if (result == 0) {
       result = order - other.order;
@@ -213,36 +221,48 @@ public void run() {
     // This should be much more fine grained, but since Java's thread pool implementation silently
     // swallows all otherwise fatal exceptions, this will at least make it obvious to developers
     // that something is failing.
-    TraceCompat.beginSection("DecodeJob#run");
+    GlideTrace.beginSectionFormat("DecodeJob#run(model=%s)", model);
+    // Methods in the try statement can invalidate currentFetcher, so set a local variable here to
+    // ensure that the fetcher is cleaned up either way.
+    DataFetcher<?> localFetcher = currentFetcher;
     try {
       if (isCancelled) {
         notifyFailed();
         return;
       }
       runWrapped();
-    } catch (RuntimeException e) {
+    } catch (Throwable t) {
+      // Catch Throwable and not Exception to handle OOMs. Throwables are swallowed by our
+      // usage of .submit() in GlideExecutor so we're not silently hiding crashes by doing this. We
+      // are however ensuring that our callbacks are always notified when a load fails. Without this
+      // notification, uncaught throwables never notify the corresponding callbacks, which can cause
+      // loads to silently hang forever, a case that's especially bad for users using Futures on
+      // background threads.
       if (Log.isLoggable(TAG, Log.DEBUG)) {
         Log.d(TAG, "DecodeJob threw unexpectedly"
             + ", isCancelled: " + isCancelled
-            + ", stage: " + stage, e);
+            + ", stage: " + stage, t);
       }
       // When we're encoding we've already notified our callback and it isn't safe to do so again.
       if (stage != Stage.ENCODE) {
+        throwables.add(t);
         notifyFailed();
       }
       if (!isCancelled) {
-        throw e;
+        throw t;
       }
     } finally {
-      if (currentFetcher != null) {
-        currentFetcher.cleanup();
+      // Keeping track of the fetcher here and calling cleanup is excessively paranoid, we call
+      // close in all cases anyway.
+      if (localFetcher != null) {
+        localFetcher.cleanup();
       }
-      TraceCompat.endSection();
+      GlideTrace.endSection();
     }
   }
 
   private void runWrapped() {
-     switch (runReason) {
+    switch (runReason) {
       case INITIALIZE:
         stage = getNextStage(Stage.INITIALIZE);
         currentGenerator = getNextGenerator();
@@ -299,7 +319,7 @@ private void runGenerators() {
 
   private void notifyFailed() {
     setNotifiedOrThrow();
-    GlideException e = new GlideException("Failed to load resource", new ArrayList<>(exceptions));
+    GlideException e = new GlideException("Failed to load resource", new ArrayList<>(throwables));
     callback.onLoadFailed(e);
     onLoadFailed();
   }
@@ -354,11 +374,11 @@ public void onDataFetcherReady(Key sourceKey, Object data, DataFetcher<?> fetche
       runReason = RunReason.DECODE_DATA;
       callback.reschedule(this);
     } else {
-      TraceCompat.beginSection("DecodeJob.decodeFromRetrievedData");
+      GlideTrace.beginSection("DecodeJob.decodeFromRetrievedData");
       try {
         decodeFromRetrievedData();
       } finally {
-        TraceCompat.endSection();
+        GlideTrace.endSection();
       }
     }
   }
@@ -369,7 +389,7 @@ public void onDataFetcherFailed(Key attemptedKey, Exception e, DataFetcher<?> fe
     fetcher.cleanup();
     GlideException exception = new GlideException("Fetching data failed", e);
     exception.setLoggingDetails(attemptedKey, dataSource, fetcher.getDataClass());
-    exceptions.add(exception);
+    throwables.add(exception);
     if (Thread.currentThread() != currentThread) {
       runReason = RunReason.SWITCH_TO_SOURCE_SERVICE;
       callback.reschedule(this);
@@ -382,15 +402,15 @@ private void decodeFromRetrievedData() {
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
       logWithTimeAndKey("Retrieved data", startFetchTime,
           "data: " + currentData
-          + ", cache key: " + currentSourceKey
-          + ", fetcher: " + currentFetcher);
+              + ", cache key: " + currentSourceKey
+              + ", fetcher: " + currentFetcher);
     }
     Resource<R> resource = null;
     try {
       resource = decodeFromData(currentFetcher, currentData, currentDataSource);
     } catch (GlideException e) {
       e.setLoggingDetails(currentAttemptingKey, currentDataSource);
-      exceptions.add(e);
+      throwables.add(e);
     }
     if (resource != null) {
       notifyEncodeAndRelease(resource, currentDataSource);
@@ -422,8 +442,10 @@ private void notifyEncodeAndRelease(Resource<R> resource, DataSource dataSource)
       if (lockedResource != null) {
         lockedResource.unlock();
       }
-      onEncodeComplete();
     }
+    // Call onEncodeComplete outside the finally block so that it's not called if the encode process
+    // throws.
+    onEncodeComplete();
   }
 
   private <Data> Resource<R> decodeFromData(DataFetcher<?> fetcher, Data data,
@@ -450,12 +472,40 @@ private void notifyEncodeAndRelease(Resource<R> resource, DataSource dataSource)
     return runLoadPath(data, dataSource, path);
   }
 
+  @NonNull
+  private Options getOptionsWithHardwareConfig(DataSource dataSource) {
+    Options options = this.options;
+    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {
+      return options;
+    }
+
+    boolean isHardwareConfigSafe =
+        dataSource == DataSource.RESOURCE_DISK_CACHE || decodeHelper.isScaleOnlyOrNoTransform();
+    Boolean isHardwareConfigAllowed = options.get(Downsampler.ALLOW_HARDWARE_CONFIG);
+
+    // If allow hardware config is defined, we can use it if it's set to false or if it's safe to
+    // use the hardware config for the request.
+    if (isHardwareConfigAllowed != null && (!isHardwareConfigAllowed || isHardwareConfigSafe)) {
+      return options;
+    }
+
+    // If allow hardware config is undefined or is set to true but it's unsafe for us to use the
+    // hardware config for this request, we need to override the config.
+    options = new Options();
+    options.putAll(this.options);
+    options.set(Downsampler.ALLOW_HARDWARE_CONFIG, isHardwareConfigSafe);
+
+    return options;
+  }
+
   private <Data, ResourceType> Resource<R> runLoadPath(Data data, DataSource dataSource,
       LoadPath<Data, ResourceType, R> path) throws GlideException {
+    Options options = getOptionsWithHardwareConfig(dataSource);
     DataRewinder<Data> rewinder = glideContext.getRegistry().getRewinder(data);
     try {
-      return path.load(rewinder, options, width, height,
-          new DecodeCallback<ResourceType>(dataSource));
+      // ResourceType in DecodeCallback below is required for compilation to work with gradle.
+      return path.load(
+          rewinder, options, width, height, new DecodeCallback<ResourceType>(dataSource));
     } finally {
       rewinder.cleanup();
     }
@@ -471,11 +521,74 @@ private void logWithTimeAndKey(String message, long startTime, String extraArgs)
         + Thread.currentThread().getName());
   }
 
+  @NonNull
   @Override
   public StateVerifier getVerifier() {
     return stateVerifier;
   }
 
+  @Synthetic
+  @NonNull
+  <Z> Resource<Z> onResourceDecoded(DataSource dataSource,
+      @NonNull Resource<Z> decoded) {
+    @SuppressWarnings("unchecked")
+    Class<Z> resourceSubClass = (Class<Z>) decoded.get().getClass();
+    Transformation<Z> appliedTransformation = null;
+    Resource<Z> transformed = decoded;
+    if (dataSource != DataSource.RESOURCE_DISK_CACHE) {
+      appliedTransformation = decodeHelper.getTransformation(resourceSubClass);
+      transformed = appliedTransformation.transform(glideContext, decoded, width, height);
+    }
+    // TODO: Make this the responsibility of the Transformation.
+    if (!decoded.equals(transformed)) {
+      decoded.recycle();
+    }
+
+    final EncodeStrategy encodeStrategy;
+    final ResourceEncoder<Z> encoder;
+    if (decodeHelper.isResourceEncoderAvailable(transformed)) {
+      encoder = decodeHelper.getResultEncoder(transformed);
+      encodeStrategy = encoder.getEncodeStrategy(options);
+    } else {
+      encoder = null;
+      encodeStrategy = EncodeStrategy.NONE;
+    }
+
+    Resource<Z> result = transformed;
+    boolean isFromAlternateCacheKey = !decodeHelper.isSourceKey(currentSourceKey);
+    if (diskCacheStrategy.isResourceCacheable(isFromAlternateCacheKey, dataSource,
+        encodeStrategy)) {
+      if (encoder == null) {
+        throw new Registry.NoResultEncoderAvailableException(transformed.get().getClass());
+      }
+      final Key key;
+      switch (encodeStrategy) {
+        case SOURCE:
+          key = new DataCacheKey(currentSourceKey, signature);
+          break;
+        case TRANSFORMED:
+          key =
+              new ResourceCacheKey(
+                  decodeHelper.getArrayPool(),
+                  currentSourceKey,
+                  signature,
+                  width,
+                  height,
+                  appliedTransformation,
+                  resourceSubClass,
+                  options);
+          break;
+        default:
+          throw new IllegalArgumentException("Unknown strategy: " + encodeStrategy);
+      }
+
+      LockedResource<Z> lockedResult = LockedResource.obtain(transformed);
+      deferredEncodeManager.init(key, encoder, lockedResult);
+      result = lockedResult;
+    }
+    return result;
+  }
+
   private final class DecodeCallback<Z> implements DecodePath.DecodeCallback<Z> {
 
     private final DataSource dataSource;
@@ -485,57 +598,10 @@ public StateVerifier getVerifier() {
       this.dataSource = dataSource;
     }
 
+    @NonNull
     @Override
-    public Resource<Z> onResourceDecoded(Resource<Z> decoded) {
-      Class<Z> resourceSubClass = getResourceClass(decoded);
-      Transformation<Z> appliedTransformation = null;
-      Resource<Z> transformed = decoded;
-      if (dataSource != DataSource.RESOURCE_DISK_CACHE) {
-        appliedTransformation = decodeHelper.getTransformation(resourceSubClass);
-        transformed = appliedTransformation.transform(glideContext, decoded, width, height);
-      }
-      // TODO: Make this the responsibility of the Transformation.
-      if (!decoded.equals(transformed)) {
-        decoded.recycle();
-      }
-
-      final EncodeStrategy encodeStrategy;
-      final ResourceEncoder<Z> encoder;
-      if (decodeHelper.isResourceEncoderAvailable(transformed)) {
-        encoder = decodeHelper.getResultEncoder(transformed);
-        encodeStrategy = encoder.getEncodeStrategy(options);
-      } else {
-        encoder = null;
-        encodeStrategy = EncodeStrategy.NONE;
-      }
-
-      Resource<Z> result = transformed;
-      boolean isFromAlternateCacheKey = !decodeHelper.isSourceKey(currentSourceKey);
-      if (diskCacheStrategy.isResourceCacheable(isFromAlternateCacheKey, dataSource,
-          encodeStrategy)) {
-        if (encoder == null) {
-          throw new Registry.NoResultEncoderAvailableException(transformed.get().getClass());
-        }
-        final Key key;
-        if (encodeStrategy == EncodeStrategy.SOURCE) {
-          key = new DataCacheKey(currentSourceKey, signature);
-        } else if (encodeStrategy == EncodeStrategy.TRANSFORMED) {
-          key = new ResourceCacheKey(currentSourceKey, signature, width, height,
-              appliedTransformation, resourceSubClass, options);
-        } else {
-          throw new IllegalArgumentException("Unknown strategy: " + encodeStrategy);
-        }
-
-        LockedResource<Z> lockedResult = LockedResource.obtain(transformed);
-        deferredEncodeManager.init(key, encoder, lockedResult);
-        result = lockedResult;
-      }
-      return result;
-    }
-
-    @SuppressWarnings("unchecked")
-    private Class<Z> getResourceClass(Resource<Z> resource) {
-      return (Class<Z>) resource.get().getClass();
+    public Resource<Z> onResourceDecoded(@NonNull Resource<Z> decoded) {
+      return DecodeJob.this.onResourceDecoded(dataSource, decoded);
     }
   }
 
@@ -577,8 +643,8 @@ private boolean isComplete(boolean isRemovedFromQueue) {
   }
 
   /**
-   * Allows transformed resources to be encoded after the transcoded result is already delivered
-   * to requestors.
+   * Allows transformed resources to be encoded after the transcoded result is already delivered to
+   * requestors.
    */
   private static class DeferredEncodeManager<Z> {
     private Key key;
@@ -597,13 +663,13 @@ private boolean isComplete(boolean isRemovedFromQueue) {
     }
 
     void encode(DiskCacheProvider diskCacheProvider, Options options) {
-      TraceCompat.beginSection("DecodeJob.encode");
+      GlideTrace.beginSection("DecodeJob.encode");
       try {
         diskCacheProvider.getDiskCache().put(key,
             new DataCacheWriter<>(encoder, toEncode, options));
       } finally {
         toEncode.unlock();
-        TraceCompat.endSection();
+        GlideTrace.endSection();
       }
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java
index 6198bc5f0..919dc7584 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java
@@ -1,11 +1,13 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
 import android.support.v4.util.Pools.Pool;
 import android.util.Log;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.data.DataRewinder;
 import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
+import com.bumptech.glide.util.Preconditions;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
@@ -23,13 +25,13 @@
   private final Class<DataType> dataClass;
   private final List<? extends ResourceDecoder<DataType, ResourceType>> decoders;
   private final ResourceTranscoder<ResourceType, Transcode> transcoder;
-  private final Pool<List<Exception>> listPool;
+  private final Pool<List<Throwable>> listPool;
   private final String failureMessage;
 
   public DecodePath(Class<DataType> dataClass, Class<ResourceType> resourceClass,
       Class<Transcode> transcodeClass,
       List<? extends ResourceDecoder<DataType, ResourceType>> decoders,
-      ResourceTranscoder<ResourceType, Transcode> transcoder, Pool<List<Exception>> listPool) {
+      ResourceTranscoder<ResourceType, Transcode> transcoder, Pool<List<Throwable>> listPool) {
     this.dataClass = dataClass;
     this.decoders = decoders;
     this.transcoder = transcoder;
@@ -39,15 +41,16 @@ public DecodePath(Class<DataType> dataClass, Class<ResourceType> resourceClass,
   }
 
   public Resource<Transcode> decode(DataRewinder<DataType> rewinder, int width, int height,
-      Options options, DecodeCallback<ResourceType> callback) throws GlideException {
+      @NonNull Options options, DecodeCallback<ResourceType> callback) throws GlideException {
     Resource<ResourceType> decoded = decodeResource(rewinder, width, height, options);
     Resource<ResourceType> transformed = callback.onResourceDecoded(decoded);
-    return transcoder.transcode(transformed);
+    return transcoder.transcode(transformed, options);
   }
 
+  @NonNull
   private Resource<ResourceType> decodeResource(DataRewinder<DataType> rewinder, int width,
-      int height, Options options) throws GlideException {
-    List<Exception> exceptions = listPool.acquire();
+      int height, @NonNull Options options) throws GlideException {
+    List<Throwable> exceptions = Preconditions.checkNotNull(listPool.acquire());
     try {
       return decodeResourceWithList(rewinder, width, height, options, exceptions);
     } finally {
@@ -55,9 +58,11 @@ public DecodePath(Class<DataType> dataClass, Class<ResourceType> resourceClass,
     }
   }
 
+  @NonNull
   private Resource<ResourceType> decodeResourceWithList(DataRewinder<DataType> rewinder, int width,
-      int height, Options options, List<Exception> exceptions) throws GlideException {
+      int height, @NonNull Options options, List<Throwable> exceptions) throws GlideException {
     Resource<ResourceType> result = null;
+    //noinspection ForLoopReplaceableByForEach to improve perf
     for (int i = 0, size = decoders.size(); i < size; i++) {
       ResourceDecoder<DataType, ResourceType> decoder = decoders.get(i);
       try {
@@ -66,7 +71,9 @@ public DecodePath(Class<DataType> dataClass, Class<ResourceType> resourceClass,
           data = rewinder.rewindAndGet();
           result = decoder.decode(data, width, height, options);
         }
-      } catch (IOException e) {
+        // Some decoders throw unexpectedly. If they do, we shouldn't fail the entire load path, but
+        // instead log and continue. See #2406 for an example.
+      } catch (IOException | RuntimeException | OutOfMemoryError e) {
         if (Log.isLoggable(TAG, Log.VERBOSE)) {
           Log.v(TAG, "Failed to decode data for " + decoder, e);
         }
@@ -91,6 +98,7 @@ public String toString() {
   }
 
   interface DecodeCallback<ResourceType> {
-    Resource<ResourceType> onResourceDecoded(Resource<ResourceType> resource);
+    @NonNull
+    Resource<ResourceType> onResourceDecoded(@NonNull Resource<ResourceType> resource);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
index 1dc070d50..dbeb547cf 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
@@ -1,7 +1,8 @@
 package com.bumptech.glide.load.engine;
 
-import android.os.Looper;
-import android.os.MessageQueue;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 import android.support.v4.util.Pools;
 import android.util.Log;
 import com.bumptech.glide.GlideContext;
@@ -16,13 +17,13 @@
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
 import com.bumptech.glide.request.ResourceCallback;
 import com.bumptech.glide.util.LogTime;
+import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
 import com.bumptech.glide.util.pool.FactoryPools;
-import java.lang.ref.ReferenceQueue;
-import java.lang.ref.WeakReference;
-import java.util.HashMap;
 import java.util.Map;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.TimeUnit;
 
 /**
  * Responsible for starting loads and managing active and cached resources.
@@ -32,64 +33,62 @@
     EngineResource.ResourceListener {
   private static final String TAG = "Engine";
   private static final int JOB_POOL_SIZE = 150;
-  private final Map<Key, EngineJob<?>> jobs;
+  private static final boolean VERBOSE_IS_LOGGABLE = Log.isLoggable(TAG, Log.VERBOSE);
+  private final Jobs jobs;
   private final EngineKeyFactory keyFactory;
   private final MemoryCache cache;
   private final EngineJobFactory engineJobFactory;
-  private final Map<Key, WeakReference<EngineResource<?>>> activeResources;
   private final ResourceRecycler resourceRecycler;
   private final LazyDiskCacheProvider diskCacheProvider;
   private final DecodeJobFactory decodeJobFactory;
+  private final ActiveResources activeResources;
 
-  // Lazily instantiate to avoid exceptions if Glide is initialized on a background thread. See
-  // #295.
-  private ReferenceQueue<EngineResource<?>> resourceReferenceQueue;
-
-  /**
-   * Allows a request to indicate it no longer is interested in a given load.
-   */
-  public static class LoadStatus {
-    private final EngineJob<?> engineJob;
-    private final ResourceCallback cb;
-
-    public LoadStatus(ResourceCallback cb, EngineJob<?> engineJob) {
-      this.cb = cb;
-      this.engineJob = engineJob;
-    }
-
-    public void cancel() {
-      engineJob.removeCallback(cb);
-    }
-  }
-
-  public Engine(MemoryCache memoryCache,
+  public Engine(
+      MemoryCache memoryCache,
       DiskCache.Factory diskCacheFactory,
       GlideExecutor diskCacheExecutor,
       GlideExecutor sourceExecutor,
-      GlideExecutor sourceUnlimitedExecutor) {
-    this(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor, sourceUnlimitedExecutor,
-        null, null, null, null, null, null);
+      GlideExecutor sourceUnlimitedExecutor,
+      GlideExecutor animationExecutor,
+      boolean isActiveResourceRetentionAllowed) {
+    this(
+        memoryCache,
+        diskCacheFactory,
+        diskCacheExecutor,
+        sourceExecutor,
+        sourceUnlimitedExecutor,
+        animationExecutor,
+        /*jobs=*/ null,
+        /*keyFactory=*/ null,
+        /*activeResources=*/ null,
+        /*engineJobFactory=*/ null,
+        /*decodeJobFactory=*/ null,
+        /*resourceRecycler=*/ null,
+        isActiveResourceRetentionAllowed);
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   Engine(MemoryCache cache,
       DiskCache.Factory diskCacheFactory,
       GlideExecutor diskCacheExecutor,
       GlideExecutor sourceExecutor,
       GlideExecutor sourceUnlimitedExecutor,
-      Map<Key, EngineJob<?>> jobs,
+      GlideExecutor animationExecutor,
+      Jobs jobs,
       EngineKeyFactory keyFactory,
-      Map<Key, WeakReference<EngineResource<?>>> activeResources,
+      ActiveResources activeResources,
       EngineJobFactory engineJobFactory,
       DecodeJobFactory decodeJobFactory,
-      ResourceRecycler resourceRecycler) {
+      ResourceRecycler resourceRecycler,
+      boolean isActiveResourceRetentionAllowed) {
     this.cache = cache;
     this.diskCacheProvider = new LazyDiskCacheProvider(diskCacheFactory);
 
     if (activeResources == null) {
-      activeResources = new HashMap<>();
+      activeResources = new ActiveResources(isActiveResourceRetentionAllowed);
     }
     this.activeResources = activeResources;
+    activeResources.setListener(this);
 
     if (keyFactory == null) {
       keyFactory = new EngineKeyFactory();
@@ -97,13 +96,14 @@ public Engine(MemoryCache memoryCache,
     this.keyFactory = keyFactory;
 
     if (jobs == null) {
-      jobs = new HashMap<>();
+      jobs = new Jobs();
     }
     this.jobs = jobs;
 
     if (engineJobFactory == null) {
-      engineJobFactory = new EngineJobFactory(diskCacheExecutor, sourceExecutor,
-          sourceUnlimitedExecutor, this);
+      engineJobFactory =
+          new EngineJobFactory(
+              diskCacheExecutor, sourceExecutor, sourceUnlimitedExecutor, animationExecutor, this);
     }
     this.engineJobFactory = engineJobFactory;
 
@@ -121,19 +121,26 @@ public Engine(MemoryCache memoryCache,
   }
 
   /**
-   * Starts a load for the given arguments. Must be called on the main thread.
+   * Starts a load for the given arguments.
+   *
+   * <p>Must be called on the main thread.
    *
-   * <p> The flow for any request is as follows: <ul> <li>Check the memory cache and provide the
-   * cached resource if present</li> <li>Check the current put of actively used resources and return
-   * the active resource if present</li> <li>Check the current put of in progress loads and add the
-   * cb to the in progress load if present</li> <li>Start a new load</li> </ul> </p>
+   * <p>The flow for any request is as follows:
+   * <ul>
+   *   <li>Check the current set of actively used resources, return the active resource if
+   *   present, and move any newly inactive resources into the memory cache.</li>
+   *   <li>Check the memory cache and provide the cached resource if present.</li>
+   *   <li>Check the current set of in progress loads and add the cb to the in progress load if
+   *   one is present.</li>
+   *   <li>Start a new load.</li>
+   * </ul>
    *
-   * <p> Active resources are those that have been provided to at least one request and have not yet
+   * <p>Active resources are those that have been provided to at least one request and have not yet
    * been released. Once all consumers of a resource have released that resource, the resource then
    * goes to cache. If the resource is ever returned to a new consumer from cache, it is re-added to
    * the active resources. If the resource is evicted from the cache, its resources are recycled and
    * re-used if possible and the resource is discarded. There is no strict requirement that
-   * consumers release their resources so active resources are held weakly. </p>
+   * consumers release their resources so active resources are held weakly.
    *
    * @param width  The target width in pixels of the desired resource.
    * @param height The target height in pixels of the desired resource.
@@ -151,67 +158,79 @@ public Engine(MemoryCache memoryCache,
       DiskCacheStrategy diskCacheStrategy,
       Map<Class<?>, Transformation<?>> transformations,
       boolean isTransformationRequired,
+      boolean isScaleOnlyOrNoTransform,
       Options options,
       boolean isMemoryCacheable,
       boolean useUnlimitedSourceExecutorPool,
+      boolean useAnimationPool,
       boolean onlyRetrieveFromCache,
       ResourceCallback cb) {
     Util.assertMainThread();
-    long startTime = LogTime.getLogTime();
+    long startTime = VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : 0;
 
     EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,
         resourceClass, transcodeClass, options);
 
-    EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);
-    if (cached != null) {
-      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);
-      if (Log.isLoggable(TAG, Log.VERBOSE)) {
-        logWithTimeAndKey("Loaded resource from cache", startTime, key);
-      }
-      return null;
-    }
-
     EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);
     if (active != null) {
       cb.onResourceReady(active, DataSource.MEMORY_CACHE);
-      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+      if (VERBOSE_IS_LOGGABLE) {
         logWithTimeAndKey("Loaded resource from active resources", startTime, key);
       }
       return null;
     }
 
-    EngineJob<?> current = jobs.get(key);
+    EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);
+    if (cached != null) {
+      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);
+      if (VERBOSE_IS_LOGGABLE) {
+        logWithTimeAndKey("Loaded resource from cache", startTime, key);
+      }
+      return null;
+    }
+
+    EngineJob<?> current = jobs.get(key, onlyRetrieveFromCache);
     if (current != null) {
       current.addCallback(cb);
-      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+      if (VERBOSE_IS_LOGGABLE) {
         logWithTimeAndKey("Added to existing load", startTime, key);
       }
       return new LoadStatus(cb, current);
     }
 
-    EngineJob<R> engineJob = engineJobFactory.build(key, isMemoryCacheable,
-        useUnlimitedSourceExecutorPool);
-    DecodeJob<R> decodeJob = decodeJobFactory.build(
-        glideContext,
-        model,
-        key,
-        signature,
-        width,
-        height,
-        resourceClass,
-        transcodeClass,
-        priority,
-        diskCacheStrategy,
-        transformations,
-        isTransformationRequired,
-        onlyRetrieveFromCache,
-        options,
-        engineJob);
+    EngineJob<R> engineJob =
+        engineJobFactory.build(
+            key,
+            isMemoryCacheable,
+            useUnlimitedSourceExecutorPool,
+            useAnimationPool,
+            onlyRetrieveFromCache);
+
+    DecodeJob<R> decodeJob =
+        decodeJobFactory.build(
+            glideContext,
+            model,
+            key,
+            signature,
+            width,
+            height,
+            resourceClass,
+            transcodeClass,
+            priority,
+            diskCacheStrategy,
+            transformations,
+            isTransformationRequired,
+            isScaleOnlyOrNoTransform,
+            onlyRetrieveFromCache,
+            options,
+            engineJob);
+
     jobs.put(key, engineJob);
+
     engineJob.addCallback(cb);
     engineJob.start(decodeJob);
 
-    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+    if (VERBOSE_IS_LOGGABLE) {
       logWithTimeAndKey("Started new load", startTime, key);
     }
     return new LoadStatus(cb, engineJob);
@@ -221,20 +240,14 @@ private static void logWithTimeAndKey(String log, long startTime, Key key) {
     Log.v(TAG, log + " in " + LogTime.getElapsedMillis(startTime) + "ms, key: " + key);
   }
 
+  @Nullable
   private EngineResource<?> loadFromActiveResources(Key key, boolean isMemoryCacheable) {
     if (!isMemoryCacheable) {
       return null;
     }
-
-    EngineResource<?> active = null;
-    WeakReference<EngineResource<?>> activeRef = activeResources.get(key);
-    if (activeRef != null) {
-      active = activeRef.get();
-      if (active != null) {
-        active.acquire();
-      } else {
-        activeResources.remove(key);
-      }
+    EngineResource<?> active = activeResources.get(key);
+    if (active != null) {
+      active.acquire();
     }
 
     return active;
@@ -248,12 +261,11 @@ private static void logWithTimeAndKey(String log, long startTime, Key key) {
     EngineResource<?> cached = getEngineResourceFromCache(key);
     if (cached != null) {
       cached.acquire();
-      activeResources.put(key, new ResourceWeakReference(key, cached, getReferenceQueue()));
+      activeResources.activate(key, cached);
     }
     return cached;
   }
 
-  @SuppressWarnings("unchecked")
   private EngineResource<?> getEngineResourceFromCache(Key key) {
     Resource<?> cached = cache.remove(key);
 
@@ -264,7 +276,7 @@ private static void logWithTimeAndKey(String log, long startTime, Key key) {
       // Save an object allocation if we've cached an EngineResource (the typical case).
       result = (EngineResource<?>) cached;
     } else {
-      result = new EngineResource<>(cached, true /*isMemoryCacheable*/);
+      result = new EngineResource<>(cached, true /*isMemoryCacheable*/, true /*isRecyclable*/);
     }
     return result;
   }
@@ -280,39 +292,37 @@ public void release(Resource<?> resource) {
 
   @SuppressWarnings("unchecked")
   @Override
-  public void onEngineJobComplete(Key key, EngineResource<?> resource) {
+  public void onEngineJobComplete(EngineJob<?> engineJob, Key key, EngineResource<?> resource) {
     Util.assertMainThread();
     // A null resource indicates that the load failed, usually due to an exception.
     if (resource != null) {
       resource.setResourceListener(key, this);
 
       if (resource.isCacheable()) {
-        activeResources.put(key, new ResourceWeakReference(key, resource, getReferenceQueue()));
+        activeResources.activate(key, resource);
       }
     }
-    // TODO: should this check that the engine job is still current?
-    jobs.remove(key);
+
+    jobs.removeIfCurrent(key, engineJob);
   }
 
   @Override
-  public void onEngineJobCancelled(EngineJob engineJob, Key key) {
+  public void onEngineJobCancelled(EngineJob<?> engineJob, Key key) {
     Util.assertMainThread();
-    EngineJob<?> current = jobs.get(key);
-    if (engineJob.equals(current)) {
-      jobs.remove(key);
-    }
+
+    jobs.removeIfCurrent(key, engineJob);
   }
 
   @Override
-  public void onResourceRemoved(final Resource<?> resource) {
+  public void onResourceRemoved(@NonNull final Resource<?> resource) {
     Util.assertMainThread();
     resourceRecycler.recycle(resource);
   }
 
   @Override
-  public void onResourceReleased(Key cacheKey, EngineResource resource) {
+  public void onResourceReleased(Key cacheKey, EngineResource<?> resource) {
     Util.assertMainThread();
-    activeResources.remove(cacheKey);
+    activeResources.deactivate(cacheKey);
     if (resource.isCacheable()) {
       cache.put(cacheKey, resource);
     } else {
@@ -324,13 +334,28 @@ public void clearDiskCache() {
     diskCacheProvider.getDiskCache().clear();
   }
 
-  private ReferenceQueue<EngineResource<?>> getReferenceQueue() {
-    if (resourceReferenceQueue == null) {
-      resourceReferenceQueue = new ReferenceQueue<>();
-      MessageQueue queue = Looper.myQueue();
-      queue.addIdleHandler(new RefQueueIdleHandler(activeResources, resourceReferenceQueue));
+  @VisibleForTesting
+  public void shutdown() {
+    engineJobFactory.shutdown();
+    diskCacheProvider.clearDiskCacheIfCreated();
+    activeResources.shutdown();
+  }
+
+  /**
+   * Allows a request to indicate it no longer is interested in a given load.
+   */
+  public static class LoadStatus {
+    private final EngineJob<?> engineJob;
+    private final ResourceCallback cb;
+
+    LoadStatus(ResourceCallback cb, EngineJob<?> engineJob) {
+      this.cb = cb;
+      this.engineJob = engineJob;
+    }
+
+    public void cancel() {
+      engineJob.removeCallback(cb);
     }
-    return resourceReferenceQueue;
   }
 
   private static class LazyDiskCacheProvider implements DecodeJob.DiskCacheProvider {
@@ -338,10 +363,18 @@ public void clearDiskCache() {
     private final DiskCache.Factory factory;
     private volatile DiskCache diskCache;
 
-    public LazyDiskCacheProvider(DiskCache.Factory factory) {
+    LazyDiskCacheProvider(DiskCache.Factory factory) {
       this.factory = factory;
     }
 
+    @VisibleForTesting
+    synchronized void clearDiskCacheIfCreated() {
+      if (diskCache == null) {
+        return;
+      }
+      diskCache.clear();
+    }
+
     @Override
     public DiskCache getDiskCache() {
       if (diskCache == null) {
@@ -358,47 +391,15 @@ public DiskCache getDiskCache() {
     }
   }
 
-  private static class ResourceWeakReference extends WeakReference<EngineResource<?>> {
-    @Synthetic final Key key;
-
-    public ResourceWeakReference(Key key, EngineResource<?> r,
-        ReferenceQueue<? super EngineResource<?>> q) {
-      super(r, q);
-      this.key = key;
-    }
-  }
-
-  // Responsible for cleaning up the active resource map by remove weak references that have been
-  // cleared.
-  private static class RefQueueIdleHandler implements MessageQueue.IdleHandler {
-    private final Map<Key, WeakReference<EngineResource<?>>> activeResources;
-    private final ReferenceQueue<EngineResource<?>> queue;
-
-    public RefQueueIdleHandler(Map<Key, WeakReference<EngineResource<?>>> activeResources,
-        ReferenceQueue<EngineResource<?>> queue) {
-      this.activeResources = activeResources;
-      this.queue = queue;
-    }
-
-    @Override
-    public boolean queueIdle() {
-      ResourceWeakReference ref = (ResourceWeakReference) queue.poll();
-      if (ref != null) {
-        activeResources.remove(ref.key);
-      }
-
-      return true;
-    }
-  }
-
-  // Visible for testing.
+  @VisibleForTesting
   static class DecodeJobFactory {
     @Synthetic final DecodeJob.DiskCacheProvider diskCacheProvider;
-    @Synthetic final Pools.Pool<DecodeJob<?>> pool = FactoryPools.simple(JOB_POOL_SIZE,
-        new FactoryPools.Factory<DecodeJob<?>>() {
+    @Synthetic final Pools.Pool<DecodeJob<?>> pool =
+        FactoryPools.simple(JOB_POOL_SIZE,
+            new FactoryPools.Factory<DecodeJob<?>>() {
           @Override
           public DecodeJob<?> create() {
-            return new DecodeJob<Object>(diskCacheProvider, pool);
+            return new DecodeJob<>(diskCacheProvider, pool);
           }
         });
     private int creationOrder;
@@ -420,10 +421,11 @@ public boolean queueIdle() {
         DiskCacheStrategy diskCacheStrategy,
         Map<Class<?>, Transformation<?>> transformations,
         boolean isTransformationRequired,
+        boolean isScaleOnlyOrNoTransform,
         boolean onlyRetrieveFromCache,
         Options options,
         DecodeJob.Callback<R> callback) {
-      DecodeJob<R> result = (DecodeJob<R>) pool.acquire();
+      DecodeJob<R> result = Preconditions.checkNotNull((DecodeJob<R>) pool.acquire());
       return result.init(
           glideContext,
           model,
@@ -437,6 +439,7 @@ public boolean queueIdle() {
           diskCacheStrategy,
           transformations,
           isTransformationRequired,
+          isScaleOnlyOrNoTransform,
           onlyRetrieveFromCache,
           options,
           callback,
@@ -444,34 +447,79 @@ public boolean queueIdle() {
     }
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class EngineJobFactory {
     @Synthetic final GlideExecutor diskCacheExecutor;
     @Synthetic final GlideExecutor sourceExecutor;
     @Synthetic final GlideExecutor sourceUnlimitedExecutor;
+    @Synthetic final GlideExecutor animationExecutor;
     @Synthetic final EngineJobListener listener;
-    @Synthetic final Pools.Pool<EngineJob<?>> pool = FactoryPools.simple(JOB_POOL_SIZE,
-        new FactoryPools.Factory<EngineJob<?>>() {
-          @Override
-          public EngineJob<?> create() {
-            return new EngineJob<Object>(diskCacheExecutor, sourceExecutor, sourceUnlimitedExecutor,
-                listener, pool);
-          }
-        });
-
-    EngineJobFactory(GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor,
-        GlideExecutor sourceUnlimitedExecutor, EngineJobListener listener) {
+    @Synthetic final Pools.Pool<EngineJob<?>> pool =
+        FactoryPools.simple(
+            JOB_POOL_SIZE,
+            new FactoryPools.Factory<EngineJob<?>>() {
+              @Override
+              public EngineJob<?> create() {
+                return new EngineJob<>(
+                    diskCacheExecutor,
+                    sourceExecutor,
+                    sourceUnlimitedExecutor,
+                    animationExecutor,
+                    listener,
+                    pool);
+              }
+            });
+
+    EngineJobFactory(
+        GlideExecutor diskCacheExecutor,
+        GlideExecutor sourceExecutor,
+        GlideExecutor sourceUnlimitedExecutor,
+        GlideExecutor animationExecutor,
+        EngineJobListener listener) {
       this.diskCacheExecutor = diskCacheExecutor;
       this.sourceExecutor = sourceExecutor;
       this.sourceUnlimitedExecutor = sourceUnlimitedExecutor;
+      this.animationExecutor = animationExecutor;
       this.listener = listener;
     }
 
+    @VisibleForTesting
+    void shutdown() {
+      shutdownAndAwaitTermination(diskCacheExecutor);
+      shutdownAndAwaitTermination(sourceExecutor);
+      shutdownAndAwaitTermination(sourceUnlimitedExecutor);
+      shutdownAndAwaitTermination(animationExecutor);
+    }
+
     @SuppressWarnings("unchecked")
-    <R> EngineJob<R> build(Key key, boolean isMemoryCacheable,
-        boolean useUnlimitedSourceGeneratorPool) {
-      EngineJob<R> result = (EngineJob<R>) pool.acquire();
-      return result.init(key, isMemoryCacheable, useUnlimitedSourceGeneratorPool);
+    <R> EngineJob<R> build(
+        Key key,
+        boolean isMemoryCacheable,
+        boolean useUnlimitedSourceGeneratorPool,
+        boolean useAnimationPool,
+        boolean onlyRetrieveFromCache) {
+      EngineJob<R> result = Preconditions.checkNotNull((EngineJob<R>) pool.acquire());
+      return result.init(
+          key,
+          isMemoryCacheable,
+          useUnlimitedSourceGeneratorPool,
+          useAnimationPool,
+          onlyRetrieveFromCache);
+    }
+
+    private static void shutdownAndAwaitTermination(ExecutorService pool) {
+      long shutdownSeconds = 5;
+      pool.shutdown();
+      try {
+        if (!pool.awaitTermination(shutdownSeconds, TimeUnit.SECONDS)) {
+          pool.shutdownNow();
+          if (!pool.awaitTermination(shutdownSeconds, TimeUnit.SECONDS)) {
+            throw new RuntimeException("Failed to shutdown");
+          }
+        }
+      } catch (InterruptedException ie) {
+        throw new RuntimeException(ie);
+      }
     }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
index 3517092ac..344a15036 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
@@ -3,6 +3,8 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
+import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
 import android.support.v4.util.Pools;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
@@ -39,10 +41,13 @@
   private final GlideExecutor diskCacheExecutor;
   private final GlideExecutor sourceExecutor;
   private final GlideExecutor sourceUnlimitedExecutor;
+  private final GlideExecutor animationExecutor;
 
   private Key key;
   private boolean isCacheable;
   private boolean useUnlimitedSourceGeneratorPool;
+  private boolean useAnimationPool;
+  private boolean onlyRetrieveFromCache;
   private Resource<?> resource;
   private DataSource dataSource;
   private boolean hasResource;
@@ -57,31 +62,53 @@
   // Checked primarily on the main thread, but also on other threads in reschedule.
   private volatile boolean isCancelled;
 
-  EngineJob(GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor,
+  EngineJob(
+      GlideExecutor diskCacheExecutor,
+      GlideExecutor sourceExecutor,
       GlideExecutor sourceUnlimitedExecutor,
-      EngineJobListener listener, Pools.Pool<EngineJob<?>> pool) {
-    this(diskCacheExecutor, sourceExecutor, sourceUnlimitedExecutor, listener, pool,
+      GlideExecutor animationExecutor,
+      EngineJobListener listener,
+      Pools.Pool<EngineJob<?>> pool) {
+    this(
+        diskCacheExecutor,
+        sourceExecutor,
+        sourceUnlimitedExecutor,
+        animationExecutor,
+        listener,
+        pool,
         DEFAULT_FACTORY);
   }
 
-  // Visible for testing.
-  EngineJob(GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor,
+  @VisibleForTesting
+  EngineJob(
+      GlideExecutor diskCacheExecutor,
+      GlideExecutor sourceExecutor,
       GlideExecutor sourceUnlimitedExecutor,
-      EngineJobListener listener, Pools.Pool<EngineJob<?>> pool,
+      GlideExecutor animationExecutor,
+      EngineJobListener listener,
+      Pools.Pool<EngineJob<?>> pool,
       EngineResourceFactory engineResourceFactory) {
     this.diskCacheExecutor = diskCacheExecutor;
     this.sourceExecutor = sourceExecutor;
     this.sourceUnlimitedExecutor = sourceUnlimitedExecutor;
+    this.animationExecutor = animationExecutor;
     this.listener = listener;
     this.pool = pool;
     this.engineResourceFactory = engineResourceFactory;
   }
 
-  // Visible for testing.
-  EngineJob<R> init(Key key, boolean isCacheable, boolean useUnlimitedSourceGeneratorPool) {
+  @VisibleForTesting
+  EngineJob<R> init(
+      Key key,
+      boolean isCacheable,
+      boolean useUnlimitedSourceGeneratorPool,
+      boolean useAnimationPool,
+      boolean onlyRetrieveFromCache) {
     this.key = key;
     this.isCacheable = isCacheable;
     this.useUnlimitedSourceGeneratorPool = useUnlimitedSourceGeneratorPool;
+    this.useAnimationPool = useAnimationPool;
+    this.onlyRetrieveFromCache = onlyRetrieveFromCache;
     return this;
   }
 
@@ -93,7 +120,7 @@ public void start(DecodeJob<R> decodeJob) {
     executor.execute(decodeJob);
   }
 
-  public void addCallback(ResourceCallback cb) {
+  void addCallback(ResourceCallback cb) {
     Util.assertMainThread();
     stateVerifier.throwIfRecycled();
     if (hasResource) {
@@ -105,7 +132,7 @@ public void addCallback(ResourceCallback cb) {
     }
   }
 
-  public void removeCallback(ResourceCallback cb) {
+  void removeCallback(ResourceCallback cb) {
     Util.assertMainThread();
     stateVerifier.throwIfRecycled();
     if (hasResource || hasLoadFailed) {
@@ -118,8 +145,13 @@ public void removeCallback(ResourceCallback cb) {
     }
   }
 
+  boolean onlyRetrieveFromCache() {
+    return onlyRetrieveFromCache;
+  }
+
   private GlideExecutor getActiveSourceExecutor() {
-    return useUnlimitedSourceGeneratorPool ? sourceUnlimitedExecutor : sourceExecutor;
+    return useUnlimitedSourceGeneratorPool
+        ? sourceUnlimitedExecutor : (useAnimationPool ? animationExecutor : sourceExecutor);
   }
 
   // We cannot remove callbacks while notifying our list of callbacks directly because doing so
@@ -176,9 +208,11 @@ void handleResultOnMainThread() {
     // Hold on to resource for duration of request so we don't recycle it in the middle of
     // notifying if it synchronously released by one of the callbacks.
     engineResource.acquire();
-    listener.onEngineJobComplete(key, engineResource);
+    listener.onEngineJobComplete(this, key, engineResource);
 
-    for (ResourceCallback cb : cbs) {
+    //noinspection ForLoopReplaceableByForEach to improve perf
+    for (int i = 0, size = cbs.size(); i < size; i++) {
+      ResourceCallback cb = cbs.get(i);
       if (!isInIgnoredCallbacks(cb)) {
         engineResource.acquire();
         cb.onResourceReady(engineResource, dataSource);
@@ -252,7 +286,7 @@ void handleExceptionOnMainThread() {
     }
     hasLoadFailed = true;
 
-    listener.onEngineJobComplete(key, null);
+    listener.onEngineJobComplete(this, key, null);
 
     for (ResourceCallback cb : cbs) {
       if (!isInIgnoredCallbacks(cb)) {
@@ -263,21 +297,23 @@ void handleExceptionOnMainThread() {
     release(false /*isRemovedFromQueue*/);
   }
 
+  @NonNull
   @Override
   public StateVerifier getVerifier() {
     return stateVerifier;
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class EngineResourceFactory {
     public <R> EngineResource<R> build(Resource<R> resource, boolean isMemoryCacheable) {
-      return new EngineResource<>(resource, isMemoryCacheable);
+      return new EngineResource<>(resource, isMemoryCacheable, /*isRecyclable=*/ true);
     }
   }
 
   private static class MainThreadCallback implements Handler.Callback {
 
     @Synthetic
+    @SuppressWarnings("WeakerAccess")
     MainThreadCallback() { }
 
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineJobListener.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineJobListener.java
index 0d3c2e410..4b068286f 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineJobListener.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJobListener.java
@@ -4,7 +4,7 @@
 
 interface EngineJobListener {
 
-  void onEngineJobComplete(Key key, EngineResource<?> resource);
+  void onEngineJobComplete(EngineJob<?> engineJob, Key key, EngineResource<?> resource);
 
-  void onEngineJobCancelled(EngineJob engineJob, Key key);
+  void onEngineJobCancelled(EngineJob<?> engineJob, Key key);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java
index a95e820a8..9f16b6115 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.Transformation;
@@ -21,9 +22,15 @@
   private final Options options;
   private int hashCode;
 
-  public EngineKey(Object model, Key signature, int width, int height,
-      Map<Class<?>, Transformation<?>> transformations, Class<?> resourceClass,
-      Class<?> transcodeClass, Options options) {
+  EngineKey(
+      Object model,
+      Key signature,
+      int width,
+      int height,
+      Map<Class<?>, Transformation<?>> transformations,
+      Class<?> resourceClass,
+      Class<?> transcodeClass,
+      Options options) {
     this.model = Preconditions.checkNotNull(model);
     this.signature = Preconditions.checkNotNull(signature, "Signature must not be null");
     this.width = width;
@@ -83,7 +90,7 @@ public String toString() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     throw new UnsupportedOperationException();
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineKeyFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineKeyFactory.java
index ec00d0a06..05e7a55a0 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineKeyFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineKeyFactory.java
@@ -8,7 +8,7 @@
 class EngineKeyFactory {
 
   @SuppressWarnings("rawtypes")
-  public EngineKey buildKey(Object model, Key signature, int width, int height,
+  EngineKey buildKey(Object model, Key signature, int width, int height,
       Map<Class<?>, Transformation<?>> transformations, Class<?> resourceClass,
       Class<?> transcodeClass, Options options) {
     return new EngineKey(model, signature, width, height, transformations, resourceClass,
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
index c03168f69..75bb1b841 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.engine;
 
 import android.os.Looper;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.util.Preconditions;
 
@@ -12,6 +13,7 @@
  */
 class EngineResource<Z> implements Resource<Z> {
   private final boolean isCacheable;
+  private final boolean isRecyclable;
   private ResourceListener listener;
   private Key key;
   private int acquired;
@@ -22,9 +24,10 @@
     void onResourceReleased(Key key, EngineResource<?> resource);
   }
 
-  EngineResource(Resource<Z> toWrap, boolean isCacheable) {
+  EngineResource(Resource<Z> toWrap, boolean isCacheable, boolean isRecyclable) {
     resource = Preconditions.checkNotNull(toWrap);
     this.isCacheable = isCacheable;
+    this.isRecyclable = isRecyclable;
   }
 
   void setResourceListener(Key key, ResourceListener listener) {
@@ -32,15 +35,21 @@ void setResourceListener(Key key, ResourceListener listener) {
     this.listener = listener;
   }
 
+  Resource<Z> getResource() {
+    return resource;
+  }
+
   boolean isCacheable() {
     return isCacheable;
   }
 
+  @NonNull
   @Override
   public Class<Z> getResourceClass() {
     return resource.getResourceClass();
   }
 
+  @NonNull
   @Override
   public Z get() {
     return resource.get();
@@ -60,7 +69,9 @@ public void recycle() {
       throw new IllegalStateException("Cannot recycle a resource that has already been recycled");
     }
     isRecycled = true;
-    resource.recycle();
+    if (isRecyclable) {
+      resource.recycle();
+    }
   }
 
   /**
@@ -86,9 +97,9 @@ void acquire() {
    * Decrements the number of consumers using the wrapped resource. Must be called on the main
    * thread.
    *
-   * <p> This must only be called when a consumer that called the {@link #acquire()} method is now
-   * done with the resource. Generally external users should never callthis method, the framework
-   * will take care of this for you. </p>
+   * <p>This must only be called when a consumer that called the {@link #acquire()} method is now
+   * done with the resource. Generally external users should never call this method, the framework
+   * will take care of this for you.
    */
   void release() {
     if (acquired <= 0) {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java b/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
index 4dca3166a..79d05eff5 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
@@ -15,24 +15,29 @@
 /**
  * An exception with zero or more causes indicating why a load in Glide failed.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public final class GlideException extends Exception {
+  private static final long serialVersionUID = 1L;
+
   private static final StackTraceElement[] EMPTY_ELEMENTS = new StackTraceElement[0];
 
-  private final List<Exception> causes;
+  private final List<Throwable> causes;
   private Key key;
   private DataSource dataSource;
   private Class<?> dataClass;
+  private String detailMessage;
 
   public GlideException(String message) {
-    this(message, Collections.<Exception>emptyList());
+    this(message, Collections.<Throwable>emptyList());
   }
 
-  public GlideException(String detailMessage, Exception cause) {
+  public GlideException(String detailMessage, Throwable cause) {
     this(detailMessage, Collections.singletonList(cause));
   }
 
-  public GlideException(String detailMessage, List<Exception> causes) {
-    super(detailMessage);
+  public GlideException(String detailMessage, List<Throwable> causes) {
+    this.detailMessage = detailMessage;
     setStackTrace(EMPTY_ELEMENTS);
     this.causes = causes;
   }
@@ -47,6 +52,10 @@ void setLoggingDetails(Key key, DataSource dataSource, Class<?> dataClass) {
     this.dataClass = dataClass;
   }
 
+
+
+  // No need to synchronize when doing nothing whatsoever.
+  @SuppressWarnings("UnsynchronizedOverridesSynchronized")
   @Override
   public Throwable fillInStackTrace() {
     // Avoid an expensive allocation by doing nothing here. Causes should contain all relevant
@@ -62,7 +71,7 @@ public Throwable fillInStackTrace() {
    *
    * @see #getRootCauses()
    */
-  public List<Exception> getCauses() {
+  public List<Throwable> getCauses() {
     return causes;
   }
 
@@ -74,8 +83,8 @@ public Throwable fillInStackTrace() {
    * a given model using multiple different pathways, there may be multiple related or unrelated
    * reasons for a load to fail.
    */
-  public List<Exception> getRootCauses() {
-    List<Exception> rootCauses = new ArrayList<>();
+  public List<Throwable> getRootCauses() {
+    List<Throwable> rootCauses = new ArrayList<>();
     addRootCauses(this, rootCauses);
     return rootCauses;
   }
@@ -88,21 +97,20 @@ public Throwable fillInStackTrace() {
    * complete stack traces.
    */
   public void logRootCauses(String tag) {
-    Log.e(tag, getClass() + ": " + getMessage());
-    List<Exception> causes = getRootCauses();
+    List<Throwable> causes = getRootCauses();
     for (int i = 0, size = causes.size(); i < size; i++) {
       Log.i(tag, "Root cause (" + (i + 1) + " of " + size + ")", causes.get(i));
     }
   }
 
-  private void addRootCauses(Exception exception, List<Exception> rootCauses) {
-    if (exception instanceof GlideException) {
-      GlideException glideException = (GlideException) exception;
-      for (Exception e : glideException.getCauses()) {
-        addRootCauses(e, rootCauses);
+  private void addRootCauses(Throwable throwable, List<Throwable> rootCauses) {
+    if (throwable instanceof GlideException) {
+      GlideException glideException = (GlideException) throwable;
+      for (Throwable t : glideException.getCauses()) {
+        addRootCauses(t, rootCauses);
       }
     } else {
-      rootCauses.add(exception);
+      rootCauses.add(throwable);
     }
   }
 
@@ -126,29 +134,47 @@ private void printStackTrace(Appendable appendable) {
     appendCauses(getCauses(), new IndentedAppendable(appendable));
   }
 
+  // PMD doesn't seem to notice that we're allocating the builder with the suggested size.
+  @SuppressWarnings("PMD.InsufficientStringBufferDeclaration")
   @Override
   public String getMessage() {
-    return super.getMessage()
-        + (dataClass != null ? ", " + dataClass : "")
-        + (dataSource != null ? ", " + dataSource : "")
-        + (key != null ? ", " + key : "");
+    StringBuilder result = new StringBuilder(71)
+        .append(detailMessage)
+        .append(dataClass != null ? ", " + dataClass : "")
+        .append(dataSource != null ? ", " + dataSource : "")
+        .append(key != null ? ", " + key : "");
+
+    List<Throwable> rootCauses = getRootCauses();
+    if (rootCauses.isEmpty()) {
+      return result.toString();
+    } else if (rootCauses.size() == 1) {
+      result.append("\nThere was 1 cause:");
+    } else {
+      result.append("\nThere were ").append(rootCauses.size()).append(" causes:");
+    }
+    for (Throwable cause : rootCauses) {
+      result.append('\n')
+          .append(cause.getClass().getName()).append('(').append(cause.getMessage()).append(')');
+    }
+    result.append("\n call GlideException#logRootCauses(String) for more detail");
+    return result.toString();
   }
 
   // Appendable throws, PrintWriter, PrintStream, and IndentedAppendable do not, so this should
   // never happen.
   @SuppressWarnings("PMD.PreserveStackTrace")
-  private static void appendExceptionMessage(Exception e, Appendable appendable) {
+  private static void appendExceptionMessage(Throwable t, Appendable appendable) {
     try {
-      appendable.append(e.getClass().toString()).append(": ").append(e.getMessage()).append('\n');
+      appendable.append(t.getClass().toString()).append(": ").append(t.getMessage()).append('\n');
     } catch (IOException e1) {
-      throw new RuntimeException(e);
+      throw new RuntimeException(t);
     }
   }
 
   // Appendable throws, PrintWriter, PrintStream, and IndentedAppendable do not, so this should
   // never happen.
   @SuppressWarnings("PMD.PreserveStackTrace")
-  private static void appendCauses(List<Exception> causes, Appendable appendable) {
+  private static void appendCauses(List<Throwable> causes, Appendable appendable) {
     try {
       appendCausesWrapped(causes, appendable);
     } catch (IOException e) {
@@ -157,7 +183,7 @@ private static void appendCauses(List<Exception> causes, Appendable appendable)
   }
 
   @SuppressWarnings("ThrowableResultOfMethodCallIgnored")
-  private static void appendCausesWrapped(List<Exception> causes, Appendable appendable)
+  private static void appendCausesWrapped(List<Throwable> causes, Appendable appendable)
       throws IOException {
     int size = causes.size();
     for (int i = 0; i < size; i++) {
@@ -167,7 +193,7 @@ private static void appendCausesWrapped(List<Exception> causes, Appendable appen
           .append(String.valueOf(size))
           .append("): ");
 
-      Exception cause = causes.get(i);
+      Throwable cause = causes.get(i);
       if (cause instanceof GlideException) {
         GlideException glideCause = (GlideException) cause;
         glideCause.printStackTrace(appendable);
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Jobs.java b/library/src/main/java/com/bumptech/glide/load/engine/Jobs.java
new file mode 100644
index 000000000..93b3106f7
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Jobs.java
@@ -0,0 +1,36 @@
+package com.bumptech.glide.load.engine;
+
+import android.support.annotation.VisibleForTesting;
+import com.bumptech.glide.load.Key;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
+final class Jobs {
+  private final Map<Key, EngineJob<?>> jobs = new HashMap<>();
+  private final Map<Key, EngineJob<?>> onlyCacheJobs = new HashMap<>();
+
+  @VisibleForTesting
+  Map<Key, EngineJob<?>> getAll() {
+    return Collections.unmodifiableMap(jobs);
+  }
+
+  EngineJob<?> get(Key key, boolean onlyRetrieveFromCache) {
+    return getJobMap(onlyRetrieveFromCache).get(key);
+  }
+
+  void put(Key key, EngineJob<?> job) {
+    getJobMap(job.onlyRetrieveFromCache()).put(key, job);
+  }
+
+  void removeIfCurrent(Key key, EngineJob<?> expected) {
+    Map<Key, EngineJob<?>> jobMap = getJobMap(expected.onlyRetrieveFromCache());
+    if (expected.equals(jobMap.get(key))) {
+      jobMap.remove(key);
+    }
+  }
+
+  private Map<Key, EngineJob<?>> getJobMap(boolean onlyRetrieveFromCache) {
+    return onlyRetrieveFromCache ? onlyCacheJobs : jobs;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/LoadPath.java b/library/src/main/java/com/bumptech/glide/load/engine/LoadPath.java
index d182da6ea..dca8f8952 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/LoadPath.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/LoadPath.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
 import android.support.v4.util.Pools.Pool;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataRewinder;
@@ -21,13 +22,13 @@
  */
 public class LoadPath<Data, ResourceType, Transcode> {
   private final Class<Data> dataClass;
-  private final Pool<List<Exception>> listPool;
+  private final Pool<List<Throwable>> listPool;
   private final List<? extends DecodePath<Data, ResourceType, Transcode>> decodePaths;
   private final String failureMessage;
 
   public LoadPath(Class<Data> dataClass, Class<ResourceType> resourceClass,
       Class<Transcode> transcodeClass,
-      List<DecodePath<Data, ResourceType, Transcode>> decodePaths, Pool<List<Exception>> listPool) {
+      List<DecodePath<Data, ResourceType, Transcode>> decodePaths, Pool<List<Throwable>> listPool) {
     this.dataClass = dataClass;
     this.listPool = listPool;
     this.decodePaths = Preconditions.checkNotEmpty(decodePaths);
@@ -35,22 +36,23 @@ public LoadPath(Class<Data> dataClass, Class<ResourceType> resourceClass,
         + resourceClass.getSimpleName() + "->" + transcodeClass.getSimpleName() + "}";
   }
 
-  public Resource<Transcode> load(DataRewinder<Data> rewinder, Options options, int width,
+  public Resource<Transcode> load(DataRewinder<Data> rewinder, @NonNull Options options, int width,
       int height, DecodePath.DecodeCallback<ResourceType> decodeCallback) throws GlideException {
-    List<Exception> exceptions = listPool.acquire();
+    List<Throwable> throwables = Preconditions.checkNotNull(listPool.acquire());
     try {
-      return loadWithExceptionList(rewinder, options, width, height, decodeCallback, exceptions);
+      return loadWithExceptionList(rewinder, options, width, height, decodeCallback, throwables);
     } finally {
-      listPool.release(exceptions);
+      listPool.release(throwables);
     }
   }
 
-  private Resource<Transcode> loadWithExceptionList(DataRewinder<Data> rewinder, Options options,
+  private Resource<Transcode> loadWithExceptionList(DataRewinder<Data> rewinder,
+      @NonNull Options options,
       int width, int height, DecodePath.DecodeCallback<ResourceType> decodeCallback,
-      List<Exception> exceptions) throws GlideException {
-    int size = decodePaths.size();
+      List<Throwable> exceptions) throws GlideException {
     Resource<Transcode> result = null;
-    for (int i = 0; i < size; i++) {
+    //noinspection ForLoopReplaceableByForEach to improve perf
+    for (int i = 0, size = decodePaths.size(); i < size; i++) {
       DecodePath<Data, ResourceType, Transcode> path = decodePaths.get(i);
       try {
         result = path.decode(rewinder, width, height, options, decodeCallback);
@@ -75,7 +77,6 @@ public LoadPath(Class<Data> dataClass, Class<ResourceType> resourceClass,
 
   @Override
   public String toString() {
-    return "LoadPath{" + "decodePaths="
-        + Arrays.toString(decodePaths.toArray(new DecodePath[decodePaths.size()])) + '}';
+    return "LoadPath{" + "decodePaths=" + Arrays.toString(decodePaths.toArray()) + '}';
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java b/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java
index 5ee05aca7..594b26441 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java
@@ -1,6 +1,8 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
 import android.support.v4.util.Pools;
+import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.pool.FactoryPools;
 import com.bumptech.glide.util.pool.StateVerifier;
@@ -27,12 +29,14 @@
   private boolean isRecycled;
 
   @SuppressWarnings("unchecked")
+  @NonNull
   static <Z> LockedResource<Z> obtain(Resource<Z> resource) {
-    LockedResource<Z> result = (LockedResource<Z>) POOL.acquire();
+    LockedResource<Z> result = Preconditions.checkNotNull((LockedResource<Z>) POOL.acquire());
     result.init(resource);
     return result;
   }
 
+  @SuppressWarnings("WeakerAccess")
   @Synthetic
   LockedResource() { }
 
@@ -47,7 +51,7 @@ private void release() {
     POOL.release(this);
   }
 
-  public synchronized void unlock() {
+  synchronized void unlock() {
     stateVerifier.throwIfRecycled();
 
     if (!isLocked) {
@@ -59,11 +63,13 @@ public synchronized void unlock() {
     }
   }
 
+  @NonNull
   @Override
   public Class<Z> getResourceClass() {
     return toWrap.getResourceClass();
   }
 
+  @NonNull
   @Override
   public Z get() {
     return toWrap.get();
@@ -85,6 +91,7 @@ public synchronized void recycle() {
     }
   }
 
+  @NonNull
   @Override
   public StateVerifier getVerifier() {
     return stateVerifier;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Resource.java b/library/src/main/java/com/bumptech/glide/load/engine/Resource.java
index 3717a889d..6667381ba 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Resource.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Resource.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
 
 /**
  * A resource interface that wraps a particular type so that it can be pooled and reused.
@@ -11,6 +12,7 @@
   /**
    * Returns the {@link Class} of the wrapped resource.
    */
+  @NonNull
   Class<Z> getResourceClass();
 
   /**
@@ -23,6 +25,7 @@
    * {@link android.graphics.drawable.Drawable Drawable}s should always return a new
    * {@link android.graphics.drawable.Drawable Drawable}. </p>
    */
+  @NonNull
   Z get();
 
   /**
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java
index b0d444ed9..aee163a33 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Transformation;
@@ -19,7 +20,7 @@
   private final FetcherReadyCallback cb;
   private final DecodeHelper<?> helper;
 
-  private int sourceIdIndex = 0;
+  private int sourceIdIndex;
   private int resourceClassIndex = -1;
   private Key sourceKey;
   private List<ModelLoader<File, ?>> modelLoaders;
@@ -31,11 +32,13 @@
   private File cacheFile;
   private ResourceCacheKey currentKey;
 
-  public ResourceCacheGenerator(DecodeHelper<?> helper, FetcherReadyCallback cb) {
+  ResourceCacheGenerator(DecodeHelper<?> helper, FetcherReadyCallback cb) {
     this.helper = helper;
     this.cb = cb;
   }
 
+  // See TODO below.
+  @SuppressWarnings("PMD.CollapsibleIfStatements")
   @Override
   public boolean startNext() {
     List<Key> sourceIds = helper.getCacheKeys();
@@ -43,6 +46,14 @@ public boolean startNext() {
       return false;
     }
     List<Class<?>> resourceClasses = helper.getRegisteredResourceClasses();
+    if (resourceClasses.isEmpty()) {
+      if (File.class.equals(helper.getTranscodeClass())) {
+        return false;
+      }
+      throw new IllegalStateException(
+         "Failed to find any load path from " + helper.getModelClass() + " to "
+             + helper.getTranscodeClass());
+    }
     while (modelLoaders == null || !hasNextModelLoader()) {
       resourceClassIndex++;
       if (resourceClassIndex >= resourceClasses.size()) {
@@ -56,12 +67,22 @@ public boolean startNext() {
       Key sourceId = sourceIds.get(sourceIdIndex);
       Class<?> resourceClass = resourceClasses.get(resourceClassIndex);
       Transformation<?> transformation = helper.getTransformation(resourceClass);
-
-      currentKey = new ResourceCacheKey(sourceId, helper.getSignature(), helper.getWidth(),
-          helper.getHeight(), transformation, resourceClass, helper.getOptions());
+      // PMD.AvoidInstantiatingObjectsInLoops Each iteration is comparatively expensive anyway,
+      // we only run until the first one succeeds, the loop runs for only a limited
+      // number of iterations on the order of 10-20 in the worst case.
+      currentKey =
+          new ResourceCacheKey(// NOPMD AvoidInstantiatingObjectsInLoops
+              helper.getArrayPool(),
+              sourceId,
+              helper.getSignature(),
+              helper.getWidth(),
+              helper.getHeight(),
+              transformation,
+              resourceClass,
+              helper.getOptions());
       cacheFile = helper.getDiskCache().get(currentKey);
       if (cacheFile != null) {
-        this.sourceKey = sourceId;
+        sourceKey = sourceId;
         modelLoaders = helper.getModelLoaders(cacheFile);
         modelLoaderIndex = 0;
       }
@@ -71,9 +92,8 @@ public boolean startNext() {
     boolean started = false;
     while (!started && hasNextModelLoader()) {
       ModelLoader<File, ?> modelLoader = modelLoaders.get(modelLoaderIndex++);
-      loadData =
-          modelLoader.buildLoadData(cacheFile, helper.getWidth(), helper.getHeight(),
-              helper.getOptions());
+      loadData = modelLoader.buildLoadData(cacheFile,
+          helper.getWidth(), helper.getHeight(), helper.getOptions());
       if (loadData != null && helper.hasLoadPath(loadData.fetcher.getDataClass())) {
         started = true;
         loadData.fetcher.loadData(helper.getPriority(), this);
@@ -102,7 +122,7 @@ public void onDataReady(Object data) {
   }
 
   @Override
-  public void onLoadFailed(Exception e) {
+  public void onLoadFailed(@NonNull Exception e) {
     cb.onDataFetcherFailed(currentKey, e, loadData.fetcher, DataSource.RESOURCE_DISK_CACHE);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java
index 2fbd7051e..afd18a739 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java
@@ -1,8 +1,10 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.util.LruCache;
 import com.bumptech.glide.util.Util;
 import java.nio.ByteBuffer;
@@ -13,6 +15,7 @@
  */
 final class ResourceCacheKey implements Key {
   private static final LruCache<Class<?>, byte[]> RESOURCE_CLASS_BYTES = new LruCache<>(50);
+  private final ArrayPool arrayPool;
   private final Key sourceKey;
   private final Key signature;
   private final int width;
@@ -21,8 +24,16 @@
   private final Options options;
   private final Transformation<?> transformation;
 
-  public ResourceCacheKey(Key sourceKey, Key signature, int width, int height,
-      Transformation<?> appliedTransformation, Class<?> decodedResourceClass, Options options) {
+  ResourceCacheKey(
+      ArrayPool arrayPool,
+      Key sourceKey,
+      Key signature,
+      int width,
+      int height,
+      Transformation<?> appliedTransformation,
+      Class<?> decodedResourceClass,
+      Options options) {
+    this.arrayPool = arrayPool;
     this.sourceKey = sourceKey;
     this.signature = signature;
     this.width = width;
@@ -62,8 +73,9 @@ public int hashCode() {
 
   // TODO: Include relevant options?
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
-    byte[] dimensions = ByteBuffer.allocate(8).putInt(width).putInt(height).array();
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
+    byte[] dimensions = arrayPool.getExact(8, byte[].class);
+    ByteBuffer.wrap(dimensions).putInt(width).putInt(height).array();
     signature.updateDiskCacheKey(messageDigest);
     sourceKey.updateDiskCacheKey(messageDigest);
     messageDigest.update(dimensions);
@@ -72,6 +84,7 @@ public void updateDiskCacheKey(MessageDigest messageDigest) {
     }
     options.updateDiskCacheKey(messageDigest);
     messageDigest.update(getResourceClassBytes());
+    arrayPool.put(dimensions);
   }
 
   private byte[] getResourceClassBytes() {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java b/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java
index 6d8d365b8..4ad3cf905 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java
@@ -14,7 +14,7 @@
   private final Handler handler =
       new Handler(Looper.getMainLooper(), new ResourceRecyclerCallback());
 
-  public void recycle(Resource<?> resource) {
+  void recycle(Resource<?> resource) {
     Util.assertMainThread();
 
     if (isRecycling) {
@@ -30,8 +30,8 @@ public void recycle(Resource<?> resource) {
     }
   }
 
-  private static class ResourceRecyclerCallback implements Handler.Callback {
-    public static final int RECYCLE_RESOURCE = 1;
+  private static final class ResourceRecyclerCallback implements Handler.Callback {
+    static final int RECYCLE_RESOURCE = 1;
 
     @Synthetic
     ResourceRecyclerCallback() { }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java
index c3f3420dc..5a57b971b 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
 import android.util.Log;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Encoder;
@@ -32,7 +33,7 @@
   private volatile ModelLoader.LoadData<?> loadData;
   private DataCacheKey originalKey;
 
-  public SourceGenerator(DecodeHelper<?> helper, FetcherReadyCallback cb) {
+  SourceGenerator(DecodeHelper<?> helper, FetcherReadyCallback cb) {
     this.helper = helper;
     this.cb = cb;
   }
@@ -114,7 +115,7 @@ public void onDataReady(Object data) {
   }
 
   @Override
-  public void onLoadFailed(Exception e) {
+  public void onLoadFailed(@NonNull Exception e) {
     cb.onDataFetcherFailed(originalKey, e, loadData.fetcher, loadData.fetcher.getDataSource());
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java
index 18427396a..e53c49de4 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java
@@ -3,7 +3,7 @@
  * Interface for handling operations on a primitive array type.
  * @param <T> Array type (e.g. byte[], int[])
  */
-public interface ArrayAdapterInterface<T> {
+interface ArrayAdapterInterface<T> {
 
   /**
    * TAG for logging.
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java
index bfdb18621..7cb169dbb 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java
@@ -15,17 +15,42 @@
    *
    * <p>Arrays may be ignored, for example if the array is larger than the maximum size of the
    * pool.
+   *
+   * @deprecated Use {@link #put(Object)}
    */
+  @Deprecated
   <T> void put(T array, Class<T> arrayClass);
 
+  /**
+   * Optionally adds the given array of the given type to the pool.
+   *
+   * <p>Arrays may be ignored, for example if the array is larger than the maximum size of the
+   * pool.
+   */
+  <T> void put(T array);
+
   /**
    * Returns a non-null array of the given type with a length >= to the given size.
    *
    * <p>If an array of the given size isn't in the pool, a new one will be allocated.
    *
    * <p>This class makes no guarantees about the contents of the returned array.
+   *
+   * @see #getExact(int, Class)
    */
   <T> T get(int size, Class<T> arrayClass);
+
+  /**
+   * Returns a non-null array of the given type with a length exactly equal to the given size.
+   *
+   * <p>If an array of the given size isn't in the pool, a new one will be allocated.
+   *
+   * <p>This class makes no guarantees about the contents of the returned array.
+   *
+   * @see #get(int, Class)
+   */
+  <T> T getExact(int size, Class<T> arrayClass);
+
   /**
    * Clears all arrays from the pool.
    */
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java
index f9448856b..58ee33826 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
 import android.graphics.Bitmap;
+import android.support.annotation.VisibleForTesting;
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
 
@@ -12,6 +13,7 @@
   private final KeyPool keyPool = new KeyPool();
   private final GroupedLinkedMap<Key, Bitmap> groupedMap = new GroupedLinkedMap<>();
 
+  @Override
   public void put(Bitmap bitmap) {
     final Key key = keyPool.get(bitmap.getWidth(), bitmap.getHeight(), bitmap.getConfig());
 
@@ -54,14 +56,15 @@ private static String getBitmapString(Bitmap bitmap) {
     return getBitmapString(bitmap.getWidth(), bitmap.getHeight(), bitmap.getConfig());
   }
 
+  @SuppressWarnings("WeakerAccess")
   @Synthetic
   static String getBitmapString(int width, int height, Bitmap.Config config) {
     return "[" + width + "x" + height + "], " + config;
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class KeyPool extends BaseKeyPool<Key> {
-    public Key get(int width, int height, Bitmap.Config config) {
+    Key get(int width, int height, Bitmap.Config config) {
       Key result = get();
       result.init(width, height, config);
       return result;
@@ -73,7 +76,7 @@ protected Key create() {
     }
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class Key implements Poolable {
     private final KeyPool pool;
     private int width;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java
index ffdba43d3..ccb085511 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java
@@ -7,7 +7,7 @@
   private static final int MAX_SIZE = 20;
   private final Queue<T> keyPool = Util.createQueue(MAX_SIZE);
 
-  protected T get() {
+  T get() {
     T result = keyPool.poll();
     if (result == null) {
       result = create();
@@ -21,5 +21,5 @@ public void offer(T key) {
     }
   }
 
-  protected abstract T create();
+  abstract T create();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java
index 3fecc0360..b57a9f3d4 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java
@@ -11,7 +11,7 @@
   /**
    * Returns the current maximum size of the pool in bytes.
    */
-  int getMaxSize();
+  long getMaxSize();
 
   /**
    * Multiplies the initial size of the pool by the given multiplier to dynamically and
@@ -85,8 +85,7 @@
    * @param config The {@link android.graphics.Bitmap.Config} of the desired {@link
    *               android.graphics.Bitmap}.
    * @return A {@link android.graphics.Bitmap} with exactly the given width, height, and config
-   * potentially containing random image data or null if no such {@link android.graphics.Bitmap}
-   * could be obtained from the pool.
+   * potentially containing random image data.
    * @see #get(int, int, android.graphics.Bitmap.Config)
    */
   @NonNull
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java
index af72c1b82..60652581e 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java
@@ -10,7 +10,7 @@
  */
 public class BitmapPoolAdapter implements BitmapPool {
   @Override
-  public int getMaxSize() {
+  public long getMaxSize() {
     return 0;
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java
index d190a475f..9060fd825 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java
@@ -127,11 +127,11 @@ private void makeTail(LinkedEntry<K, V> entry) {
 
     // Used only for the first item in the list which we will treat specially and which will not
     // contain a value.
-    public LinkedEntry() {
+    LinkedEntry() {
       this(null);
     }
 
-    public LinkedEntry(K key) {
+    LinkedEntry(K key) {
       next = prev = this;
       this.key = key;
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java
index 6da2cb0e0..596e15574 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java
@@ -16,13 +16,14 @@
  */
 public final class LruArrayPool implements ArrayPool {
   // 4MB.
-  static final int DEFAULT_SIZE = 4 * 1024 * 1024;
+  private static final int DEFAULT_SIZE = 4 * 1024 * 1024;
 
   /**
    * The maximum number of times larger an int array may be to be than a requested size to eligible
    * to be returned from the pool.
    */
-  private static final int MAX_OVER_SIZE_MULTIPLE = 8;
+  @VisibleForTesting
+  static final int MAX_OVER_SIZE_MULTIPLE = 8;
   /** Used to calculate the maximum % of the total pool size a single byte array may consume. */
   private static final int SINGLE_ARRAY_MAX_SIZE_DIVISOR = 2;
 
@@ -47,8 +48,17 @@ public LruArrayPool(int maxSize) {
     this.maxSize = maxSize;
   }
 
+  @Deprecated
   @Override
-  public synchronized <T> void put(T array, Class<T> arrayClass) {
+  public <T> void put(T array, Class<T> arrayClass) {
+    put(array);
+  }
+
+  @Override
+  public synchronized <T> void put(T array) {
+    @SuppressWarnings("unchecked")
+    Class<T> arrayClass = (Class<T>) array.getClass();
+
     ArrayAdapterInterface<T> arrayAdapter = getAdapterFromType(arrayClass);
     int size = arrayAdapter.getArrayLength(array);
     int arrayBytes = size * arrayAdapter.getElementSizeInBytes();
@@ -66,35 +76,43 @@ public LruArrayPool(int maxSize) {
   }
 
   @Override
-  public <T> T get(int size, Class<T> arrayClass) {
-    ArrayAdapterInterface<T> arrayAdapter = getAdapterFromType(arrayClass);
-    T result;
-    synchronized (this) {
-      Integer possibleSize = getSizesForAdapter(arrayClass).ceilingKey(size);
-      final Key key;
-      if (mayFillRequest(size, possibleSize)) {
-        key = keyPool.get(possibleSize, arrayClass);
-      } else {
-        key = keyPool.get(size, arrayClass);
-      }
+  public synchronized <T> T getExact(int size, Class<T> arrayClass) {
+    Key key = keyPool.get(size, arrayClass);
+    return getForKey(key, arrayClass);
+  }
 
-      result = getArrayForKey(key);
-      if (result != null) {
-        currentSize -= arrayAdapter.getArrayLength(result) * arrayAdapter.getElementSizeInBytes();
-        decrementArrayOfSize(arrayAdapter.getArrayLength(result), arrayClass);
-      }
+  @Override
+  public synchronized <T> T get(int size, Class<T> arrayClass) {
+    Integer possibleSize = getSizesForAdapter(arrayClass).ceilingKey(size);
+    final Key key;
+    if (mayFillRequest(size, possibleSize)) {
+      key = keyPool.get(possibleSize, arrayClass);
+    } else {
+      key = keyPool.get(size, arrayClass);
+    }
+    return getForKey(key, arrayClass);
+  }
+
+  private <T> T getForKey(Key key, Class<T> arrayClass) {
+    ArrayAdapterInterface<T> arrayAdapter = getAdapterFromType(arrayClass);
+    T result = getArrayForKey(key);
+    if (result != null) {
+      currentSize -= arrayAdapter.getArrayLength(result) * arrayAdapter.getElementSizeInBytes();
+      decrementArrayOfSize(arrayAdapter.getArrayLength(result), arrayClass);
     }
 
     if (result == null) {
       if (Log.isLoggable(arrayAdapter.getTag(), Log.VERBOSE)) {
-        Log.v(arrayAdapter.getTag(), "Allocated " + size + " bytes");
+        Log.v(arrayAdapter.getTag(), "Allocated " + key.size + " bytes");
       }
-      result = arrayAdapter.newArray(size);
+      result = arrayAdapter.newArray(key.size);
     }
     return result;
   }
 
-  @SuppressWarnings("unchecked")
+
+  // Our cast is safe because the Key is based on the type.
+  @SuppressWarnings({"unchecked", "TypeParameterUnusedInFormals"})
   @Nullable
   private <T> T getArrayForKey(Key key) {
     return (T) groupedMap.get(key);
@@ -122,7 +140,8 @@ public synchronized void clearMemory() {
   public synchronized void trimMemory(int level) {
     if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
       clearMemory();
-    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {
+    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN
+        || level == android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL) {
       evictToSize(maxSize / 2);
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
index 2cf9c0f37..d233c9130 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
@@ -26,18 +26,18 @@
 
   private final LruPoolStrategy strategy;
   private final Set<Bitmap.Config> allowedConfigs;
-  private final int initialMaxSize;
+  private final long initialMaxSize;
   private final BitmapTracker tracker;
 
-  private int maxSize;
-  private int currentSize;
+  private long maxSize;
+  private long currentSize;
   private int hits;
   private int misses;
   private int puts;
   private int evictions;
 
   // Exposed for testing only.
-  LruBitmapPool(int maxSize, LruPoolStrategy strategy, Set<Bitmap.Config> allowedConfigs) {
+  LruBitmapPool(long maxSize, LruPoolStrategy strategy, Set<Bitmap.Config> allowedConfigs) {
     this.initialMaxSize = maxSize;
     this.maxSize = maxSize;
     this.strategy = strategy;
@@ -50,7 +50,7 @@
    *
    * @param maxSize The initial maximum size of the pool in bytes.
    */
-  public LruBitmapPool(int maxSize) {
+  public LruBitmapPool(long maxSize) {
     this(maxSize, getDefaultStrategy(), getDefaultAllowedConfigs());
   }
 
@@ -62,12 +62,14 @@ public LruBitmapPool(int maxSize) {
    *                       allowed to be put into the pool. Configs not in the allowed put will be
    *                       rejected.
    */
-  public LruBitmapPool(int maxSize, Set<Bitmap.Config> allowedConfigs) {
+  // Public API.
+  @SuppressWarnings("unused")
+  public LruBitmapPool(long maxSize, Set<Bitmap.Config> allowedConfigs) {
     this(maxSize, getDefaultStrategy(), allowedConfigs);
   }
 
   @Override
-  public int getMaxSize() {
+  public long getMaxSize() {
     return maxSize;
   }
 
@@ -126,7 +128,7 @@ public Bitmap get(int width, int height, Bitmap.Config config) {
       // contents individually, so we do so here. See issue #131.
       result.eraseColor(Color.TRANSPARENT);
     } else {
-      result = Bitmap.createBitmap(width, height, config);
+      result = createBitmap(width, height, config);
     }
 
     return result;
@@ -137,13 +139,34 @@ public Bitmap get(int width, int height, Bitmap.Config config) {
   public Bitmap getDirty(int width, int height, Bitmap.Config config) {
     Bitmap result = getDirtyOrNull(width, height, config);
     if (result == null) {
-      result = Bitmap.createBitmap(width, height, config);
+      result = createBitmap(width, height, config);
     }
     return result;
   }
 
+  @NonNull
+  private static Bitmap createBitmap(int width, int height, @Nullable Bitmap.Config config) {
+    return Bitmap.createBitmap(width, height, config != null ? config : DEFAULT_CONFIG);
+  }
+
+  @TargetApi(Build.VERSION_CODES.O)
+  private static void assertNotHardwareConfig(Bitmap.Config config) {
+    // Avoid short circuiting on sdk int since it breaks on some versions of Android.
+    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {
+      return;
+    }
+
+    if (config == Bitmap.Config.HARDWARE) {
+      throw new IllegalArgumentException("Cannot create a mutable Bitmap with config: " + config
+          + ". Consider setting Downsampler#ALLOW_HARDWARE_CONFIG to false in your RequestOptions"
+          + " and/or in GlideBuilder.setDefaultRequestOptions");
+    }
+  }
+
   @Nullable
-  private synchronized Bitmap getDirtyOrNull(int width, int height, Bitmap.Config config) {
+  private synchronized Bitmap getDirtyOrNull(
+      int width, int height, @Nullable Bitmap.Config config) {
+    assertNotHardwareConfig(config);
     // Config will be null for non public config types, which can lead to transformations naively
     // passing in null as the requested config here. See issue #194.
     final Bitmap result = strategy.get(width, height, config != null ? config : DEFAULT_CONFIG);
@@ -196,12 +219,13 @@ public void trimMemory(int level) {
     }
     if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
       clearMemory();
-    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {
-      trimToSize(maxSize / 2);
+    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN
+        || level == android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL) {
+      trimToSize(getMaxSize() / 2);
     }
   }
 
-  private synchronized void trimToSize(int size) {
+  private synchronized void trimToSize(long size) {
     while (currentSize > size) {
       final Bitmap removed = strategy.removeLast();
       // TODO: This shouldn't ever happen, see #331.
@@ -245,12 +269,18 @@ private static LruPoolStrategy getDefaultStrategy() {
     return strategy;
   }
 
+  @TargetApi(Build.VERSION_CODES.O)
   private static Set<Bitmap.Config> getDefaultAllowedConfigs() {
-    Set<Bitmap.Config> configs = new HashSet<>();
-    configs.addAll(Arrays.asList(Bitmap.Config.values()));
-    if (Build.VERSION.SDK_INT >= 19) {
+    Set<Bitmap.Config> configs = new HashSet<>(Arrays.asList(Bitmap.Config.values()));
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
+      // GIFs, among other types, end up with a native Bitmap config that doesn't map to a java
+      // config and is treated as null in java code. On KitKat+ these Bitmaps can be reconfigured
+      // and are suitable for re-use.
       configs.add(null);
     }
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+      configs.remove(Bitmap.Config.HARDWARE);
+    }
     return Collections.unmodifiableSet(configs);
   }
 
@@ -284,7 +314,7 @@ public void remove(Bitmap bitmap) {
     }
   }
 
-  private static class NullBitmapTracker implements BitmapTracker {
+  private static final class NullBitmapTracker implements BitmapTracker {
 
     @Synthetic
     NullBitmapTracker() { }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/PrettyPrintTreeMap.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/PrettyPrintTreeMap.java
index 5d4176f3c..220d3beff 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/PrettyPrintTreeMap.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/PrettyPrintTreeMap.java
@@ -2,6 +2,8 @@
 
 import java.util.TreeMap;
 
+// Never serialized.
+@SuppressWarnings("serial")
 class PrettyPrintTreeMap<K, V> extends TreeMap<K, V> {
   @Override
   public String toString() {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
index 05964ba05..e496fde4e 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
@@ -1,11 +1,14 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
-import android.annotation.TargetApi;
 import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
 import android.os.Build;
 import android.support.annotation.Nullable;
+import android.support.annotation.RequiresApi;
+import android.support.annotation.VisibleForTesting;
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
+import java.util.Arrays;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.NavigableMap;
@@ -22,15 +25,26 @@
  * the performance of applications. This class works around #301 by only allowing re-use of
  * {@link android.graphics.Bitmap Bitmaps} with a matching number of bytes per pixel. </p>
  */
-@TargetApi(Build.VERSION_CODES.KITKAT)
+@RequiresApi(Build.VERSION_CODES.KITKAT)
 public class SizeConfigStrategy implements LruPoolStrategy {
   private static final int MAX_SIZE_MULTIPLE = 8;
-  private static final Bitmap.Config[] ARGB_8888_IN_CONFIGS =
-      new Bitmap.Config[] {
-          Bitmap.Config.ARGB_8888,
-          // The value returned by Bitmaps with the hidden Bitmap config.
-          null,
-      };
+
+  private static final Bitmap.Config[] ARGB_8888_IN_CONFIGS;
+  static {
+    Bitmap.Config[] result =
+        new Bitmap.Config[] {
+            Bitmap.Config.ARGB_8888,
+            // The value returned by Bitmaps with the hidden Bitmap config.
+            null,
+        };
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+      result = Arrays.copyOf(result, result.length + 1);
+      result[result.length - 1] = Config.RGBA_F16;
+    }
+    ARGB_8888_IN_CONFIGS = result;
+  }
+  private static final Bitmap.Config[] RGBA_F16_IN_CONFIGS = ARGB_8888_IN_CONFIGS;
+
   // We probably could allow ARGB_4444 and RGB_565 to decode into each other, but ARGB_4444 is
   // deprecated and we'd rather be safe.
   private static final Bitmap.Config[] RGB_565_IN_CONFIGS =
@@ -160,7 +174,7 @@ public String toString() {
     return sb.append(")}").toString();
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class KeyPool extends BaseKeyPool<Key> {
 
     public Key get(int size, Bitmap.Config config) {
@@ -175,7 +189,7 @@ protected Key create() {
     }
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static final class Key implements Poolable {
     private final KeyPool pool;
 
@@ -186,7 +200,7 @@ public Key(KeyPool pool) {
       this.pool = pool;
     }
 
-    // Visible for testing.
+    @VisibleForTesting
     Key(KeyPool pool, int size, Bitmap.Config config) {
       this(pool);
       init(size, config);
@@ -231,6 +245,12 @@ static String getBitmapString(int size, Bitmap.Config config) {
   }
 
   private static Bitmap.Config[] getInConfigs(Bitmap.Config requested) {
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+      if (Bitmap.Config.RGBA_F16.equals(requested)) { // NOPMD - Avoid short circuiting sdk checks.
+        return RGBA_F16_IN_CONFIGS;
+      }
+    }
+
     switch (requested) {
       case ARGB_8888:
         return ARGB_8888_IN_CONFIGS;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java
index 205ec7e4f..5536b75db 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java
@@ -1,12 +1,13 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
-import android.annotation.TargetApi;
 import android.graphics.Bitmap;
 import android.os.Build;
 import android.support.annotation.Nullable;
+import android.support.annotation.RequiresApi;
+import android.support.annotation.VisibleForTesting;
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
-import java.util.TreeMap;
+import java.util.NavigableMap;
 
 /**
  * A strategy for reusing bitmaps that relies on
@@ -14,12 +15,12 @@
  *
  * <p> Requires {@link Build.VERSION_CODES#KITKAT KitKat} or higher. </p>
  */
-@TargetApi(Build.VERSION_CODES.KITKAT)
-class SizeStrategy implements LruPoolStrategy {
+@RequiresApi(Build.VERSION_CODES.KITKAT)
+final class SizeStrategy implements LruPoolStrategy {
   private static final int MAX_SIZE_MULTIPLE = 8;
   private final KeyPool keyPool = new KeyPool();
   private final GroupedLinkedMap<Key, Bitmap> groupedMap = new GroupedLinkedMap<>();
-  private final TreeMap<Integer, Integer> sortedSizes = new PrettyPrintTreeMap<>();
+  private final NavigableMap<Integer, Integer> sortedSizes = new PrettyPrintTreeMap<>();
 
   @Override
   public void put(Bitmap bitmap) {
@@ -101,16 +102,16 @@ private static String getBitmapString(Bitmap bitmap) {
     return getBitmapString(size);
   }
 
-  @Synthetic
-  static String getBitmapString(int size) {
+  @Synthetic static String getBitmapString(int size) {
     return "[" + size + "]";
   }
 
-  // Visible for testing.
+  // Non-final for mocking.
+  @VisibleForTesting
   static class KeyPool extends BaseKeyPool<Key> {
 
     public Key get(int size) {
-      Key result = get();
+      Key result = super.get();
       result.init(size);
       return result;
     }
@@ -121,7 +122,7 @@ protected Key create() {
     }
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static final class Key implements Poolable {
     private final KeyPool pool;
     @Synthetic int size;
@@ -148,6 +149,8 @@ public int hashCode() {
       return size;
     }
 
+    // PMD.AccessorMethodGeneration: https://github.com/pmd/pmd/issues/807
+    @SuppressWarnings("PMD.AccessorMethodGeneration")
     @Override
     public String toString() {
       return getBitmapString(size);
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java
index 31cdcf025..7bcfd02e4 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.engine.cache;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import com.bumptech.glide.load.Key;
 import java.io.File;
@@ -13,16 +14,13 @@
    * An interface for lazily creating a disk cache.
    */
   interface Factory {
+    /** 250 MB of cache. */
+    int DEFAULT_DISK_CACHE_SIZE = 250 * 1024 * 1024;
+    String DEFAULT_DISK_CACHE_DIR = "image_manager_disk_cache";
 
-      /** 250 MB of cache. */
-      int DEFAULT_DISK_CACHE_SIZE = 250 * 1024 * 1024;
-      String DEFAULT_DISK_CACHE_DIR = "image_manager_disk_cache";
-
-      /**
-       * Returns a new disk cache, or {@code null} if no disk cache could be created.
-       */
-      @Nullable
-      DiskCache build();
+    /** Returns a new disk cache, or {@code null} if no disk cache could be created. */
+    @Nullable
+    DiskCache build();
   }
 
   /**
@@ -35,7 +33,7 @@
      *
      * @param file The File the Writer should write to.
      */
-    boolean write(File file);
+    boolean write(@NonNull File file);
   }
 
   /**
@@ -64,6 +62,8 @@
    *
    * @param key The key to remove.
    */
+  // Public API.
+  @SuppressWarnings("unused")
   void delete(Key key);
 
   /**
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheAdapter.java
index d551af16a..8642d5275 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheAdapter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheAdapter.java
@@ -27,4 +27,14 @@ public void delete(Key key) {
   public void clear() {
       // no op, default for overriders
   }
+
+  /**
+   * Default factory for {@link DiskCacheAdapter}.
+   */
+  public static final class Factory implements DiskCache.Factory {
+    @Override
+    public DiskCache build() {
+      return new DiskCacheAdapter();
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java
index 13318a8fc..d11f0f02a 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.load.engine.cache;
 
-import com.bumptech.glide.load.Key;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayDeque;
@@ -19,16 +18,16 @@
  *  0, the lock can safely be removed from the map. </p>
  */
 final class DiskCacheWriteLocker {
-  private final Map<Key, WriteLock> locks = new HashMap<>();
+  private final Map<String, WriteLock> locks = new HashMap<>();
   private final WriteLockPool writeLockPool = new WriteLockPool();
 
-  void acquire(Key key) {
+  void acquire(String safeKey) {
     WriteLock writeLock;
     synchronized (this) {
-      writeLock = locks.get(key);
+      writeLock = locks.get(safeKey);
       if (writeLock == null) {
         writeLock = writeLockPool.obtain();
-        locks.put(key, writeLock);
+        locks.put(safeKey, writeLock);
       }
       writeLock.interestedThreads++;
     }
@@ -36,24 +35,24 @@ void acquire(Key key) {
     writeLock.lock.lock();
   }
 
-  void release(Key key) {
+  void release(String safeKey) {
     WriteLock writeLock;
     synchronized (this) {
-      writeLock = Preconditions.checkNotNull(locks.get(key));
+      writeLock = Preconditions.checkNotNull(locks.get(safeKey));
       if (writeLock.interestedThreads < 1) {
         throw new IllegalStateException("Cannot release a lock that is not held"
-            + ", key: " + key
+            + ", safeKey: " + safeKey
             + ", interestedThreads: " + writeLock.interestedThreads);
       }
 
       writeLock.interestedThreads--;
       if (writeLock.interestedThreads == 0) {
-        WriteLock removed = locks.remove(key);
+        WriteLock removed = locks.remove(safeKey);
         if (!removed.equals(writeLock)) {
           throw new IllegalStateException("Removed the wrong lock"
               + ", expected to remove: " + writeLock
               + ", but actually removed: " + removed
-              + ", key: " + key);
+              + ", safeKey: " + safeKey);
         }
         writeLockPool.offer(removed);
       }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheFactory.java
index f24fa6dd2..9518b4c85 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheFactory.java
@@ -7,10 +7,12 @@
  * disk cache directory.
  *
  * <p>If you need to make I/O access before returning the cache directory use the {@link
- * DiskLruCacheFactory#DiskLruCacheFactory(CacheDirectoryGetter, int)} constructor variant.
+ * DiskLruCacheFactory#DiskLruCacheFactory(CacheDirectoryGetter, long)} constructor variant.
  */
+// Public API.
+@SuppressWarnings("unused")
 public class DiskLruCacheFactory implements DiskCache.Factory {
-  private final int diskCacheSize;
+  private final long diskCacheSize;
   private final CacheDirectoryGetter cacheDirectoryGetter;
 
   /**
@@ -20,7 +22,7 @@
     File getCacheDirectory();
   }
 
-  public DiskLruCacheFactory(final String diskCacheFolder, int diskCacheSize) {
+  public DiskLruCacheFactory(final String diskCacheFolder, long diskCacheSize) {
     this(new CacheDirectoryGetter() {
       @Override
       public File getCacheDirectory() {
@@ -30,7 +32,7 @@ public File getCacheDirectory() {
   }
 
   public DiskLruCacheFactory(final String diskCacheFolder, final String diskCacheName,
-      int diskCacheSize) {
+                             long diskCacheSize) {
     this(new CacheDirectoryGetter() {
       @Override
       public File getCacheDirectory() {
@@ -46,7 +48,9 @@ public File getCacheDirectory() {
    * @param cacheDirectoryGetter Interface called out of UI thread to get the cache folder.
    * @param diskCacheSize        Desired max bytes size for the LRU disk cache.
    */
-  public DiskLruCacheFactory(CacheDirectoryGetter cacheDirectoryGetter, int diskCacheSize) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public DiskLruCacheFactory(CacheDirectoryGetter cacheDirectoryGetter, long diskCacheSize) {
     this.diskCacheSize = diskCacheSize;
     this.cacheDirectoryGetter = cacheDirectoryGetter;
   }
@@ -63,6 +67,6 @@ public DiskCache build() {
       return null;
     }
 
-    return DiskLruCacheWrapper.get(cacheDir, diskCacheSize);
+    return DiskLruCacheWrapper.create(cacheDir, diskCacheSize);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
index c0e6f5269..2cedfe0b2 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
@@ -15,18 +15,18 @@
  * The default DiskCache implementation. There must be no more than one active instance for a given
  * directory at a time.
  *
- * @see #get(java.io.File, int)
+ * @see #get(java.io.File, long)
  */
 public class DiskLruCacheWrapper implements DiskCache {
   private static final String TAG = "DiskLruCacheWrapper";
 
   private static final int APP_VERSION = 1;
   private static final int VALUE_COUNT = 1;
-  private static DiskLruCacheWrapper wrapper = null;
+  private static DiskLruCacheWrapper wrapper;
 
   private final SafeKeyGenerator safeKeyGenerator;
   private final File directory;
-  private final int maxSize;
+  private final long maxSize;
   private final DiskCacheWriteLocker writeLocker = new DiskCacheWriteLocker();
   private DiskLruCache diskLruCache;
 
@@ -38,8 +38,12 @@
    * @param directory The directory for the disk cache
    * @param maxSize   The max size for the disk cache
    * @return The new disk cache with the given arguments, or the current cache if one already exists
+   *
+   * @deprecated Use {@link #create(File, long)} to create a new cache with the specified arguments.
    */
-  public static synchronized DiskCache get(File directory, int maxSize) {
+  @SuppressWarnings("deprecation")
+  @Deprecated
+  public static synchronized DiskCache get(File directory, long maxSize) {
     // TODO calling twice with different arguments makes it return the cache for the same
     // directory, it's public!
     if (wrapper == null) {
@@ -48,7 +52,25 @@ public static synchronized DiskCache get(File directory, int maxSize) {
     return wrapper;
   }
 
-  protected DiskLruCacheWrapper(File directory, int maxSize) {
+  /**
+   * Create a new DiskCache in the given directory with a specified max size.
+   *
+   * @param directory The directory for the disk cache
+   * @param maxSize   The max size for the disk cache
+   * @return The new disk cache with the given arguments
+   */
+  @SuppressWarnings("deprecation")
+  public static DiskCache create(File directory, long maxSize) {
+    return new DiskLruCacheWrapper(directory, maxSize);
+  }
+
+  /**
+   * @deprecated Do not extend this class.
+   */
+  @Deprecated
+  // Deprecated public API.
+  @SuppressWarnings({"WeakerAccess", "DeprecatedIsStillUsed"})
+  protected DiskLruCacheWrapper(File directory, long maxSize) {
     this.directory = directory;
     this.maxSize = maxSize;
     this.safeKeyGenerator = new SafeKeyGenerator();
@@ -88,9 +110,9 @@ public File get(Key key) {
   public void put(Key key, Writer writer) {
     // We want to make sure that puts block so that data is available when put completes. We may
     // actually not write any data if we find that data is written by the time we acquire the lock.
-    writeLocker.acquire(key);
+    String safeKey = safeKeyGenerator.getSafeKey(key);
+    writeLocker.acquire(safeKey);
     try {
-      String safeKey = safeKeyGenerator.getSafeKey(key);
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
         Log.v(TAG, "Put: Obtained: " + safeKey + " for for Key: " + key);
       }
@@ -121,7 +143,7 @@ public void put(Key key, Writer writer) {
         }
       }
     } finally {
-      writeLocker.release(key);
+      writeLocker.release(safeKey);
     }
   }
 
@@ -141,11 +163,15 @@ public void delete(Key key) {
   public synchronized void clear() {
     try {
       getDiskCache().delete();
-      resetDiskCache();
     } catch (IOException e) {
       if (Log.isLoggable(TAG, Log.WARN)) {
-        Log.w(TAG, "Unable to clear disk cache", e);
+        Log.w(TAG, "Unable to clear disk cache or disk cache cleared externally", e);
       }
+    } finally {
+      // Delete can close the cache but still throw. If we don't null out the disk cache here, every
+      // subsequent request will try to act on a closed disk cache and fail. By nulling out the disk
+      // cache we at least allow for attempts to open the cache in the future. See #2465.
+      resetDiskCache();
     }
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalCacheDiskCacheFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalCacheDiskCacheFactory.java
index ab4ca652c..08b8d4dde 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalCacheDiskCacheFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalCacheDiskCacheFactory.java
@@ -8,7 +8,12 @@
  * disk cache directory.
  *
  * <p><b>Images can be read by everyone when using external disk cache.</b>
+ *
+ * @deprecated use {@link ExternalPreferredCacheDiskCacheFactory} instead.
  */
+// Public API.
+@SuppressWarnings({"unused", "WeakerAccess"})
+@Deprecated
 public final class ExternalCacheDiskCacheFactory extends DiskLruCacheFactory {
 
   public ExternalCacheDiskCacheFactory(Context context) {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalPreferredCacheDiskCacheFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalPreferredCacheDiskCacheFactory.java
new file mode 100644
index 000000000..4f2743b1e
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalPreferredCacheDiskCacheFactory.java
@@ -0,0 +1,65 @@
+package com.bumptech.glide.load.engine.cache;
+
+import android.content.Context;
+import android.support.annotation.Nullable;
+import java.io.File;
+
+/**
+ * Creates an {@link com.bumptech.glide.disklrucache.DiskLruCache} based disk cache in the external
+ * disk cache directory, which falls back to the internal disk cache if no external storage is
+ * available. If ever fell back to the internal disk cache, will use that one from that moment on.
+ *
+ * <p><b>Images can be read by everyone when using external disk cache.</b>
+ */
+// Public API.
+@SuppressWarnings({"unused", "WeakerAccess"})
+public final class ExternalPreferredCacheDiskCacheFactory extends DiskLruCacheFactory {
+
+  public ExternalPreferredCacheDiskCacheFactory(Context context) {
+    this(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR,
+        DiskCache.Factory.DEFAULT_DISK_CACHE_SIZE);
+  }
+
+  public ExternalPreferredCacheDiskCacheFactory(Context context, long diskCacheSize) {
+    this(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR, diskCacheSize);
+  }
+
+  public ExternalPreferredCacheDiskCacheFactory(final Context context, final String diskCacheName,
+                                                final long diskCacheSize) {
+    super(new CacheDirectoryGetter() {
+      @Nullable
+      private File getInternalCacheDirectory() {
+        File cacheDirectory = context.getCacheDir();
+        if (cacheDirectory == null) {
+          return null;
+        }
+        if (diskCacheName != null) {
+          return new File(cacheDirectory, diskCacheName);
+        }
+        return cacheDirectory;
+      }
+
+      @Override
+      public File getCacheDirectory() {
+        File internalCacheDirectory = getInternalCacheDirectory();
+
+        // Already used internal cache, so keep using that one,
+        // thus avoiding using both external and internal with transient errors.
+        if ((null != internalCacheDirectory) && internalCacheDirectory.exists()) {
+          return internalCacheDirectory;
+        }
+
+        File cacheDirectory = context.getExternalCacheDir();
+
+        // Shared storage is not available.
+        if ((cacheDirectory == null) || (!cacheDirectory.canWrite())) {
+          return internalCacheDirectory;
+        }
+        if (diskCacheName != null) {
+          return new File(cacheDirectory, diskCacheName);
+        }
+        return cacheDirectory;
+      }
+    }, diskCacheSize);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java
index 225743b89..18afb52f0 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java
@@ -7,6 +7,8 @@
  * Creates an {@link com.bumptech.glide.disklrucache.DiskLruCache} based disk cache in the internal
  * disk cache directory.
  */
+// Public API.
+@SuppressWarnings({"WeakerAccess", "unused"})
 public final class InternalCacheDiskCacheFactory extends DiskLruCacheFactory {
 
   public InternalCacheDiskCacheFactory(Context context) {
@@ -14,12 +16,12 @@ public InternalCacheDiskCacheFactory(Context context) {
         DiskCache.Factory.DEFAULT_DISK_CACHE_SIZE);
   }
 
-  public InternalCacheDiskCacheFactory(Context context, int diskCacheSize) {
+  public InternalCacheDiskCacheFactory(Context context, long diskCacheSize) {
     this(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR, diskCacheSize);
   }
 
   public InternalCacheDiskCacheFactory(final Context context, final String diskCacheName,
-      int diskCacheSize) {
+                                       long diskCacheSize) {
     super(new CacheDirectoryGetter() {
       @Override
       public File getCacheDirectory() {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java
index 44071a869..75c5329e1 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java
@@ -1,6 +1,8 @@
 package com.bumptech.glide.load.engine.cache;
 
 import android.annotation.SuppressLint;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.util.LruCache;
@@ -16,38 +18,44 @@
    *
    * @param size The maximum size in bytes the in memory cache can use.
    */
-  public LruResourceCache(int size) {
+  public LruResourceCache(long size) {
     super(size);
   }
 
   @Override
-  public void setResourceRemovedListener(ResourceRemovedListener listener) {
+  public void setResourceRemovedListener(@NonNull ResourceRemovedListener listener) {
     this.listener = listener;
   }
 
   @Override
-  protected void onItemEvicted(Key key, Resource<?> item) {
-    if (listener != null) {
+  protected void onItemEvicted(@NonNull Key key, @Nullable Resource<?> item) {
+    if (listener != null && item != null) {
       listener.onResourceRemoved(item);
     }
   }
 
   @Override
-  protected int getSize(Resource<?> item) {
-    return item.getSize();
+  protected int getSize(@Nullable Resource<?> item) {
+    if (item == null) {
+      return super.getSize(null);
+    } else {
+      return item.getSize();
+    }
   }
 
   @SuppressLint("InlinedApi")
   @Override
   public void trimMemory(int level) {
     if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
-      // Nearing middle of list of cached background apps
+      // Entering list of cached background apps
       // Evict our entire bitmap cache
       clearMemory();
-    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {
-      // Entering list of cached background apps
+    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN
+        || level == android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL) {
+      // The app's UI is no longer visible, or app is in the foreground but system is running
+      // critically low on memory
       // Evict oldest half of our bitmap cache
-      trimToSize(getCurrentSize() / 2);
+      trimToSize(getMaxSize() / 2);
     }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCache.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCache.java
index 3cf56d4c5..3210e6821 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCache.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.engine.cache;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.Resource;
@@ -12,18 +13,18 @@
    * An interface that will be called whenever a bitmap is removed from the cache.
    */
   interface ResourceRemovedListener {
-    void onResourceRemoved(Resource<?> removed);
+    void onResourceRemoved(@NonNull Resource<?> removed);
   }
 
   /**
    * Returns the sum of the sizes of all the contents of the cache in bytes.
    */
-  int getCurrentSize();
+  long getCurrentSize();
 
   /**
    * Returns the current maximum size in bytes of the cache.
    */
-  int getMaxSize();
+  long getMaxSize();
 
   /**
    * Adjust the maximum size of the cache by multiplying the original size of the cache by the given
@@ -42,7 +43,7 @@
    * @param key The key.
    */
   @Nullable
-  Resource<?> remove(Key key);
+  Resource<?> remove(@NonNull Key key);
 
   /**
    * Add bitmap to the cache with the given key.
@@ -52,14 +53,14 @@
    * @return The old value of key (null if key is not in map).
    */
   @Nullable
-  Resource<?> put(Key key, Resource<?> resource);
+  Resource<?> put(@NonNull Key key, @Nullable Resource<?> resource);
 
   /**
    * Set the listener to be called when a bitmap is removed from the cache.
    *
    * @param listener The listener.
    */
-  void setResourceRemovedListener(ResourceRemovedListener listener);
+  void setResourceRemovedListener(@NonNull ResourceRemovedListener listener);
 
   /**
    * Evict all items from the memory cache.
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCacheAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCacheAdapter.java
index e2f92de07..70deb5ce6 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCacheAdapter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCacheAdapter.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.load.engine.cache;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.Resource;
 
@@ -11,12 +13,12 @@
   private ResourceRemovedListener listener;
 
   @Override
-  public int getCurrentSize() {
+  public long getCurrentSize() {
     return 0;
   }
 
   @Override
-  public int getMaxSize() {
+  public long getMaxSize() {
     return 0;
   }
 
@@ -25,19 +27,23 @@ public void setSizeMultiplier(float multiplier) {
     // Do nothing.
   }
 
+  @Nullable
   @Override
-  public Resource<?> remove(Key key) {
+  public Resource<?> remove(@NonNull Key key) {
     return null;
   }
 
+  @Nullable
   @Override
-  public Resource<?> put(Key key, Resource<?> resource) {
-    listener.onResourceRemoved(resource);
+  public Resource<?> put(@NonNull Key key, @Nullable Resource<?> resource) {
+    if (resource != null) {
+      listener.onResourceRemoved(resource);
+    }
     return null;
   }
 
   @Override
-  public void setResourceRemovedListener(ResourceRemovedListener listener) {
+  public void setResourceRemovedListener(@NonNull ResourceRemovedListener listener) {
     this.listener = listener;
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
index 7e0bb505e..1418c466b 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
@@ -1,12 +1,15 @@
 package com.bumptech.glide.load.engine.cache;
 
+import android.annotation.TargetApi;
 import android.app.ActivityManager;
 import android.content.Context;
 import android.os.Build;
+import android.support.annotation.VisibleForTesting;
 import android.text.format.Formatter;
 import android.util.DisplayMetrics;
 import android.util.Log;
 import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Synthetic;
 
 /**
  * A calculator that tries to intelligently determine cache sizes for a given device based on some
@@ -14,9 +17,9 @@
  */
 public final class MemorySizeCalculator {
   private static final String TAG = "MemorySizeCalculator";
-  // Visible for testing.
+  @VisibleForTesting
   static final int BYTES_PER_ARGB_8888_PIXEL = 4;
-  static final int LOW_MEMORY_BYTE_ARRAY_POOL_DIVISOR = 2;
+  private static final int LOW_MEMORY_BYTE_ARRAY_POOL_DIVISOR = 2;
 
   private final int bitmapPoolSize;
   private final int memoryCacheSize;
@@ -28,30 +31,34 @@
     int getHeightPixels();
   }
 
-  MemorySizeCalculator(Context context, ActivityManager activityManager,
-      ScreenDimensions screenDimensions, float memoryCacheScreens, float bitmapPoolScreens,
-      int targetArrayPoolSize, float maxSizeMultiplier, float lowMemoryMaxSizeMultiplier) {
-    this.context = context;
+  // Package private to avoid PMD warning.
+  MemorySizeCalculator(MemorySizeCalculator.Builder builder) {
+    this.context = builder.context;
+
     arrayPoolSize =
-        isLowMemoryDevice(activityManager)
-            ? targetArrayPoolSize / LOW_MEMORY_BYTE_ARRAY_POOL_DIVISOR
-            : targetArrayPoolSize;
-    final int maxSize = getMaxSize(activityManager, maxSizeMultiplier, lowMemoryMaxSizeMultiplier);
+        isLowMemoryDevice(builder.activityManager)
+            ? builder.arrayPoolSizeBytes / LOW_MEMORY_BYTE_ARRAY_POOL_DIVISOR
+            : builder.arrayPoolSizeBytes;
+    int maxSize =
+        getMaxSize(
+            builder.activityManager, builder.maxSizeMultiplier, builder.lowMemoryMaxSizeMultiplier);
+
+    int widthPixels = builder.screenDimensions.getWidthPixels();
+    int heightPixels = builder.screenDimensions.getHeightPixels();
+    int screenSize = widthPixels * heightPixels * BYTES_PER_ARGB_8888_PIXEL;
 
-    final int screenSize = screenDimensions.getWidthPixels() * screenDimensions.getHeightPixels()
-        * BYTES_PER_ARGB_8888_PIXEL;
+    int targetBitmapPoolSize = Math.round(screenSize * builder.bitmapPoolScreens);
 
-    int targetPoolSize = Math.round(screenSize * bitmapPoolScreens);
-    int targetMemoryCacheSize = Math.round(screenSize * memoryCacheScreens);
+    int targetMemoryCacheSize = Math.round(screenSize * builder.memoryCacheScreens);
     int availableSize = maxSize - arrayPoolSize;
 
-    if (targetMemoryCacheSize + targetPoolSize <= availableSize) {
+    if (targetMemoryCacheSize + targetBitmapPoolSize <= availableSize) {
       memoryCacheSize = targetMemoryCacheSize;
-      bitmapPoolSize = targetPoolSize;
+      bitmapPoolSize = targetBitmapPoolSize;
     } else {
-      float part = availableSize / (bitmapPoolScreens + memoryCacheScreens);
-      memoryCacheSize = Math.round(part * memoryCacheScreens);
-      bitmapPoolSize = Math.round(part * bitmapPoolScreens);
+      float part = availableSize / (builder.bitmapPoolScreens + builder.memoryCacheScreens);
+      memoryCacheSize = Math.round(part * builder.memoryCacheScreens);
+      bitmapPoolSize = Math.round(part * builder.bitmapPoolScreens);
     }
 
     if (Log.isLoggable(TAG, Log.DEBUG)) {
@@ -65,13 +72,13 @@
               + ", byte array size: "
               + toMb(arrayPoolSize)
               + ", memory class limited? "
-              + (targetMemoryCacheSize + targetPoolSize > maxSize)
+              + (targetMemoryCacheSize + targetBitmapPoolSize > maxSize)
               + ", max size: "
               + toMb(maxSize)
               + ", memoryClass: "
-              + activityManager.getMemoryClass()
+              + builder.activityManager.getMemoryClass()
               + ", isLowMemoryDevice: "
-              + isLowMemoryDevice(activityManager));
+              + isLowMemoryDevice(builder.activityManager));
     }
   }
 
@@ -108,13 +115,15 @@ private String toMb(int bytes) {
     return Formatter.formatFileSize(context, bytes);
   }
 
-  private static boolean isLowMemoryDevice(ActivityManager activityManager) {
+  @TargetApi(Build.VERSION_CODES.KITKAT)
+  @Synthetic static boolean isLowMemoryDevice(ActivityManager activityManager) {
     // Explicitly check with an if statement, on some devices both parts of boolean expressions
     // can be evaluated even if we'd normally expect a short circuit.
+    //noinspection SimplifiableIfStatement
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
       return activityManager.isLowRamDevice();
     } else {
-      return false;
+      return true;
     }
   }
 
@@ -122,26 +131,36 @@ private static boolean isLowMemoryDevice(ActivityManager activityManager) {
    * Constructs an {@link MemorySizeCalculator} with reasonable defaults that can be optionally
    * overridden.
    */
+  // Public API.
+  @SuppressWarnings({"WeakerAccess", "unused"})
   public static final class Builder {
-    // Visible for testing.
+    @VisibleForTesting
     static final int MEMORY_CACHE_TARGET_SCREENS = 2;
-    static final int BITMAP_POOL_TARGET_SCREENS = 4;
+
+    /**
+     * On Android O+, we use {@link android.graphics.Bitmap.Config#HARDWARE} for all reasonably
+     * sized images unless we're creating thumbnails for the first time. As a result, the Bitmap
+     * pool is much less important on O than it was on previous versions.
+     */
+    static final int BITMAP_POOL_TARGET_SCREENS =
+        Build.VERSION.SDK_INT < Build.VERSION_CODES.O ? 4 : 1;
+
     static final float MAX_SIZE_MULTIPLIER = 0.4f;
     static final float LOW_MEMORY_MAX_SIZE_MULTIPLIER = 0.33f;
     // 4MB.
     static final int ARRAY_POOL_SIZE_BYTES = 4 * 1024 * 1024;
 
-    private final Context context;
+    @Synthetic final Context context;
 
-    // Modifiable for testing.
-    private ActivityManager activityManager;
-    private ScreenDimensions screenDimensions;
+    // Modifiable (non-final) for testing.
+    @Synthetic ActivityManager activityManager;
+    @Synthetic ScreenDimensions screenDimensions;
 
-    private float memoryCacheScreens = MEMORY_CACHE_TARGET_SCREENS;
-    private float bitmapPoolScreens = BITMAP_POOL_TARGET_SCREENS;
-    private float maxSizeMultiplier = MAX_SIZE_MULTIPLIER;
-    private float lowMemoryMaxSizeMultiplier = LOW_MEMORY_MAX_SIZE_MULTIPLIER;
-    private int arrayPoolSizeBytes = ARRAY_POOL_SIZE_BYTES;
+    @Synthetic float memoryCacheScreens = MEMORY_CACHE_TARGET_SCREENS;
+    @Synthetic float bitmapPoolScreens = BITMAP_POOL_TARGET_SCREENS;
+    @Synthetic float maxSizeMultiplier = MAX_SIZE_MULTIPLIER;
+    @Synthetic float lowMemoryMaxSizeMultiplier = LOW_MEMORY_MAX_SIZE_MULTIPLIER;
+    @Synthetic int arrayPoolSizeBytes = ARRAY_POOL_SIZE_BYTES;
 
     public Builder(Context context) {
       this.context = context;
@@ -149,6 +168,14 @@ public Builder(Context context) {
           (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
       screenDimensions =
           new DisplayMetricsScreenDimensions(context.getResources().getDisplayMetrics());
+
+      // On Android O+ Bitmaps are allocated natively, ART is much more efficient at managing
+      // garbage and we rely heavily on HARDWARE Bitmaps, making Bitmap re-use much less important.
+      // We prefer to preserve RAM on these devices and take the small performance hit of not
+      // re-using Bitmaps and textures when loading very small images or generating thumbnails.
+      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O && isLowMemoryDevice(activityManager)) {
+        bitmapPoolScreens = 0;
+      }
     }
 
     /**
@@ -157,7 +184,7 @@ public Builder(Context context) {
      * returns this Builder.
      */
     public Builder setMemoryCacheScreens(float memoryCacheScreens) {
-      Preconditions.checkArgument(bitmapPoolScreens >= 0,
+      Preconditions.checkArgument(memoryCacheScreens >= 0,
           "Memory cache screens must be greater than or equal to 0");
       this.memoryCacheScreens = memoryCacheScreens;
       return this;
@@ -217,29 +244,27 @@ public Builder setArrayPoolSize(int arrayPoolSizeBytes) {
       return this;
     }
 
-    // Visible for testing.
+    @VisibleForTesting
     Builder setActivityManager(ActivityManager activityManager) {
       this.activityManager = activityManager;
       return this;
     }
 
-    // Visible for testing.
+    @VisibleForTesting
     Builder setScreenDimensions(ScreenDimensions screenDimensions) {
       this.screenDimensions = screenDimensions;
       return this;
     }
 
     public MemorySizeCalculator build() {
-      return new MemorySizeCalculator(context, activityManager, screenDimensions,
-          memoryCacheScreens, bitmapPoolScreens, arrayPoolSizeBytes, maxSizeMultiplier,
-          lowMemoryMaxSizeMultiplier);
-      }
+      return new MemorySizeCalculator(this);
+    }
   }
 
   private static final class DisplayMetricsScreenDimensions implements ScreenDimensions {
     private final DisplayMetrics displayMetrics;
 
-    public DisplayMetricsScreenDimensions(DisplayMetrics displayMetrics) {
+    DisplayMetricsScreenDimensions(DisplayMetrics displayMetrics) {
       this.displayMetrics = displayMetrics;
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java
index 2a81c4d9a..f726ef10e 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java
@@ -1,8 +1,10 @@
 package com.bumptech.glide.load.engine.cache;
 
+import android.support.annotation.NonNull;
 import android.support.v4.util.Pools;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.util.LruCache;
+import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
 import com.bumptech.glide.util.pool.FactoryPools;
@@ -14,6 +16,8 @@
  * A class that generates and caches safe and unique string file names from {@link
  * com.bumptech.glide.load.Key}s.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public class SafeKeyGenerator {
   private final LruCache<Key, String> loadIdToSafeHash = new LruCache<>(1000);
   private final Pools.Pool<PoolableDigestContainer> digestPool = FactoryPools.threadSafe(10,
@@ -43,7 +47,7 @@ public String getSafeKey(Key key) {
   }
 
   private String calculateHexStringDigest(Key key) {
-    PoolableDigestContainer container = digestPool.acquire();
+    PoolableDigestContainer container = Preconditions.checkNotNull(digestPool.acquire());
     try {
       key.updateDiskCacheKey(container.messageDigest);
       // calling digest() will automatically reset()
@@ -62,6 +66,7 @@ private String calculateHexStringDigest(Key key) {
       this.messageDigest = messageDigest;
     }
 
+    @NonNull
     @Override
     public StateVerifier getVerifier() {
       return stateVerifier;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
index b79e11178..7f8845534 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
@@ -3,59 +3,67 @@
 import android.os.StrictMode;
 import android.os.StrictMode.ThreadPolicy;
 import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
 import android.util.Log;
 import com.bumptech.glide.util.Synthetic;
-import java.io.File;
-import java.io.FilenameFilter;
-import java.util.concurrent.BlockingQueue;
+import java.util.Collection;
+import java.util.List;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Future;
 import java.util.concurrent.PriorityBlockingQueue;
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
-import java.util.regex.Pattern;
+import java.util.concurrent.TimeoutException;
 
 /**
  * A prioritized {@link ThreadPoolExecutor} for running jobs in Glide.
  */
-public final class GlideExecutor extends ThreadPoolExecutor {
-
+public final class GlideExecutor implements ExecutorService {
   /**
    * The default thread name prefix for executors used to load/decode/transform data not found in
    * cache.
    */
-  public static final String DEFAULT_SOURCE_EXECUTOR_NAME = "source";
+  private static final String DEFAULT_SOURCE_EXECUTOR_NAME = "source";
+
   /**
    * The default thread name prefix for executors used to load/decode/transform data found in
    * Glide's cache.
    */
-  public static final String DEFAULT_DISK_CACHE_EXECUTOR_NAME = "disk-cache";
+  private static final String DEFAULT_DISK_CACHE_EXECUTOR_NAME = "disk-cache";
+
   /**
    * The default thread count for executors used to load/decode/transform data found in Glide's
    * cache.
    */
-  public static final int DEFAULT_DISK_CACHE_EXECUTOR_THREADS = 1;
+  private static final int DEFAULT_DISK_CACHE_EXECUTOR_THREADS = 1;
 
   private static final String TAG = "GlideExecutor";
-  private static final String CPU_NAME_REGEX = "cpu[0-9]+";
-  private static final String CPU_LOCATION = "/sys/devices/system/cpu/";
-  // Don't use more than four threads when automatically determining thread count..
-  private static final int MAXIMUM_AUTOMATIC_THREAD_COUNT = 4;
-  private final boolean executeSynchronously;
 
   /**
    * The default thread name prefix for executors from unlimited thread pool used to
    * load/decode/transform data not found in cache.
    */
   private static final String SOURCE_UNLIMITED_EXECUTOR_NAME = "source-unlimited";
+
+  private static final String ANIMATION_EXECUTOR_NAME = "animation";
+
   /**
-   * The default keep alive time for threads in source unlimited executor pool in milliseconds.
+   * The default keep alive time for threads in our cached thread pools in milliseconds.
    */
-  private static final long SOURCE_UNLIMITED_EXECUTOR_KEEP_ALIVE_TIME_MS =
-      TimeUnit.SECONDS.toMillis(10);
+  private static final long KEEP_ALIVE_TIME_MS = TimeUnit.SECONDS.toMillis(10);
+
+  // Don't use more than four threads when automatically determining thread count..
+  private static final int MAXIMUM_AUTOMATIC_THREAD_COUNT = 4;
+
+  // May be accessed on other threads, but this is an optimization only so it's ok if we set its
+  // value more than once.
+  private static volatile int bestThreadCount;
+
+  private final ExecutorService delegate;
 
   /**
    * Returns a new fixed thread pool with the default thread count returned from
@@ -67,8 +75,32 @@
    * <p>Disk cache executors do not allow network operations on their threads.
    */
   public static GlideExecutor newDiskCacheExecutor() {
-    return newDiskCacheExecutor(DEFAULT_DISK_CACHE_EXECUTOR_THREADS,
-        DEFAULT_DISK_CACHE_EXECUTOR_NAME, UncaughtThrowableStrategy.DEFAULT);
+    return newDiskCacheExecutor(
+        DEFAULT_DISK_CACHE_EXECUTOR_THREADS,
+        DEFAULT_DISK_CACHE_EXECUTOR_NAME,
+        UncaughtThrowableStrategy.DEFAULT);
+  }
+
+  /**
+   * Returns a new fixed thread pool with the default thread count returned from
+   * {@link #calculateBestThreadCount()}, the {@link #DEFAULT_DISK_CACHE_EXECUTOR_NAME} thread name
+   * prefix, and a custom
+   * {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy}
+   * uncaught throwable strategy.
+   *
+   * <p>Disk cache executors do not allow network operations on their threads.
+   * @param uncaughtThrowableStrategy The {@link
+   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
+   *                                  handle uncaught exceptions.
+   */
+  // Public API.
+  @SuppressWarnings("unused")
+  public static GlideExecutor newDiskCacheExecutor(
+          UncaughtThrowableStrategy uncaughtThrowableStrategy) {
+    return newDiskCacheExecutor(
+        DEFAULT_DISK_CACHE_EXECUTOR_THREADS,
+        DEFAULT_DISK_CACHE_EXECUTOR_NAME,
+        uncaughtThrowableStrategy);
   }
 
   /**
@@ -83,10 +115,18 @@ public static GlideExecutor newDiskCacheExecutor() {
    * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
    *                                  handle uncaught exceptions.
    */
-  public static GlideExecutor newDiskCacheExecutor(int threadCount, String name,
-      UncaughtThrowableStrategy uncaughtThrowableStrategy) {
-    return new GlideExecutor(threadCount, name, uncaughtThrowableStrategy,
-        true /*preventNetworkOperations*/, false /*executeSynchronously*/);
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public static GlideExecutor newDiskCacheExecutor(
+      int threadCount, String name, UncaughtThrowableStrategy uncaughtThrowableStrategy) {
+    return new GlideExecutor(
+        new ThreadPoolExecutor(
+            threadCount /* corePoolSize */,
+            threadCount /* maximumPoolSize */,
+            0 /* keepAliveTime */,
+            TimeUnit.MILLISECONDS,
+            new PriorityBlockingQueue<Runnable>(),
+            new DefaultThreadFactory(name, uncaughtThrowableStrategy, true)));
   }
 
   /**
@@ -99,10 +139,35 @@ public static GlideExecutor newDiskCacheExecutor(int threadCount, String name,
    * <p>Source executors allow network operations on their threads.
    */
   public static GlideExecutor newSourceExecutor() {
-    return newSourceExecutor(calculateBestThreadCount(), DEFAULT_SOURCE_EXECUTOR_NAME,
+    return newSourceExecutor(
+        calculateBestThreadCount(),
+        DEFAULT_SOURCE_EXECUTOR_NAME,
         UncaughtThrowableStrategy.DEFAULT);
   }
 
+  /**
+   * Returns a new fixed thread pool with the default thread count returned from
+   * {@link #calculateBestThreadCount()}, the {@link #DEFAULT_SOURCE_EXECUTOR_NAME} thread name
+   * prefix, and a custom
+   * {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy}
+   * uncaught throwable strategy.
+   *
+   * <p>Source executors allow network operations on their threads.
+   *
+   * @param uncaughtThrowableStrategy The {@link
+   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
+   *                                  handle uncaught exceptions.
+   */
+  // Public API.
+  @SuppressWarnings("unused")
+  public static GlideExecutor newSourceExecutor(
+      UncaughtThrowableStrategy uncaughtThrowableStrategy) {
+    return newSourceExecutor(
+        calculateBestThreadCount(),
+        DEFAULT_SOURCE_EXECUTOR_NAME,
+        uncaughtThrowableStrategy);
+  }
+
   /**
    * Returns a new fixed thread pool with the given thread count, thread name prefix,
    * and {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy}.
@@ -115,15 +180,23 @@ public static GlideExecutor newSourceExecutor() {
    * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
    *                                  handle uncaught exceptions.
    */
-  public static GlideExecutor newSourceExecutor(int threadCount, String name,
-      UncaughtThrowableStrategy uncaughtThrowableStrategy) {
-    return new GlideExecutor(threadCount, name, uncaughtThrowableStrategy,
-        false /*preventNetworkOperations*/, false /*executeSynchronously*/);
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public static GlideExecutor newSourceExecutor(
+      int threadCount, String name, UncaughtThrowableStrategy uncaughtThrowableStrategy) {
+    return new GlideExecutor(
+        new ThreadPoolExecutor(
+            threadCount /* corePoolSize */,
+            threadCount /* maximumPoolSize */,
+            0 /* keepAliveTime */,
+            TimeUnit.MILLISECONDS,
+            new PriorityBlockingQueue<Runnable>(),
+            new DefaultThreadFactory(name, uncaughtThrowableStrategy, false)));
   }
 
   /**
    * Returns a new unlimited thread pool with zero core thread count to make sure no threads are
-   * created by default, {@link #SOURCE_UNLIMITED_EXECUTOR_KEEP_ALIVE_TIME_MS} keep alive
+   * created by default, {@link #KEEP_ALIVE_TIME_MS} keep alive
    * time, the {@link #SOURCE_UNLIMITED_EXECUTOR_NAME} thread name prefix, the
    * {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy#DEFAULT}
    * uncaught throwable strategy, and the {@link SynchronousQueue} since using default unbounded
@@ -136,167 +209,193 @@ public static GlideExecutor newSourceExecutor(int threadCount, String name,
    * <p>Source executors allow network operations on their threads.
    */
   public static GlideExecutor newUnlimitedSourceExecutor() {
-    return new GlideExecutor(0 /* corePoolSize */,
-        Integer.MAX_VALUE /* maximumPoolSize */,
-        SOURCE_UNLIMITED_EXECUTOR_KEEP_ALIVE_TIME_MS,
-        SOURCE_UNLIMITED_EXECUTOR_NAME,
-        UncaughtThrowableStrategy.DEFAULT,
-        false /*preventNetworkOperations*/,
-        false /*executeSynchronously*/,
-        new SynchronousQueue<Runnable>());
+    return new GlideExecutor(new ThreadPoolExecutor(
+        0,
+        Integer.MAX_VALUE,
+        KEEP_ALIVE_TIME_MS,
+        TimeUnit.MILLISECONDS,
+        new SynchronousQueue<Runnable>(),
+        new DefaultThreadFactory(
+            SOURCE_UNLIMITED_EXECUTOR_NAME,
+            UncaughtThrowableStrategy.DEFAULT,
+            false)));
   }
 
-  // Visible for testing.
-  GlideExecutor(int poolSize, String name,
-      UncaughtThrowableStrategy uncaughtThrowableStrategy, boolean preventNetworkOperations,
-      boolean executeSynchronously) {
-    this(
-        poolSize /* corePoolSize */,
-        poolSize /* maximumPoolSize */,
-        0 /* keepAliveTimeInMs */,
-        name,
-        uncaughtThrowableStrategy,
-        preventNetworkOperations,
-        executeSynchronously);
+  /**
+   * Returns a new cached thread pool that defaults to either one or two threads depending on the
+   * number of available cores to use when loading frames of animations.
+   */
+  public static GlideExecutor newAnimationExecutor() {
+    int bestThreadCount = calculateBestThreadCount();
+    // We don't want to add a ton of threads running animations in parallel with our source and
+    // disk cache executors. Doing so adds unnecessary CPU load and can also dramatically increase
+    // our maximum memory usage. Typically one thread is sufficient here, but for higher end devices
+    // with more cores, two threads can provide better performance if lots of GIFs are showing at
+    // once.
+    int maximumPoolSize = bestThreadCount >= 4 ? 2 : 1;
+
+    return newAnimationExecutor(maximumPoolSize, UncaughtThrowableStrategy.DEFAULT);
   }
 
-  GlideExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTimeInMs, String name,
-      UncaughtThrowableStrategy uncaughtThrowableStrategy, boolean preventNetworkOperations,
-      boolean executeSynchronously) {
-    this(
-        corePoolSize,
-        maximumPoolSize,
-        keepAliveTimeInMs,
-        name,
-        uncaughtThrowableStrategy,
-        preventNetworkOperations,
-        executeSynchronously,
-        new PriorityBlockingQueue<Runnable>());
+  /**
+   * Returns a new cached thread pool with the given thread count and
+   * {@link UncaughtThrowableStrategy} to use when loading frames of animations.
+   */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public static GlideExecutor newAnimationExecutor(
+      int threadCount, UncaughtThrowableStrategy uncaughtThrowableStrategy) {
+     return new GlideExecutor(
+        new ThreadPoolExecutor(
+            0 /* corePoolSize */,
+            threadCount,
+            KEEP_ALIVE_TIME_MS,
+            TimeUnit.MILLISECONDS,
+            new PriorityBlockingQueue<Runnable>(),
+            new DefaultThreadFactory(
+                ANIMATION_EXECUTOR_NAME,
+                uncaughtThrowableStrategy,
+                true)));
   }
 
-  GlideExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTimeInMs, String name,
-      UncaughtThrowableStrategy uncaughtThrowableStrategy, boolean preventNetworkOperations,
-      boolean executeSynchronously, BlockingQueue<Runnable> queue) {
-    super(
-        corePoolSize,
-        maximumPoolSize,
-        keepAliveTimeInMs,
-        TimeUnit.MILLISECONDS,
-        queue,
-        new DefaultThreadFactory(name, uncaughtThrowableStrategy, preventNetworkOperations));
-    this.executeSynchronously = executeSynchronously;
+  @VisibleForTesting
+  GlideExecutor(ExecutorService delegate) {
+    this.delegate = delegate;
   }
 
   @Override
-  public void execute(Runnable command) {
-    if (executeSynchronously) {
-      command.run();
-    } else {
-      super.execute(command);
-    }
+  public void execute(@NonNull Runnable command) {
+    delegate.execute(command);
   }
 
   @NonNull
   @Override
-  public Future<?> submit(Runnable task) {
-    return maybeWait(super.submit(task));
+  public Future<?> submit(@NonNull Runnable task) {
+    return delegate.submit(task);
   }
 
-  private <T> Future<T> maybeWait(Future<T> future) {
-    if (executeSynchronously) {
-      boolean interrupted = false;
-      try {
-        while (!future.isDone()) {
-          try {
-            future.get();
-          } catch (ExecutionException e) {
-            throw new RuntimeException(e);
-          } catch (InterruptedException e) {
-            interrupted = true;
-          }
-        }
-      } finally {
-        if (interrupted) {
-          Thread.currentThread().interrupt();
-        }
-      }
-    }
-    return future;
+  @NonNull
+  @Override
+  public <T> List<Future<T>> invokeAll(@NonNull Collection<? extends Callable<T>> tasks)
+      throws InterruptedException {
+    return delegate.invokeAll(tasks);
+  }
+
+  @NonNull
+  @Override
+  public <T> List<Future<T>> invokeAll(
+      @NonNull Collection<? extends Callable<T>> tasks,
+      long timeout,
+      @NonNull TimeUnit unit) throws InterruptedException {
+    return delegate.invokeAll(tasks, timeout, unit);
   }
 
   @NonNull
   @Override
-  public <T> Future<T> submit(Runnable task, T result) {
-    return maybeWait(super.submit(task, result));
+  public <T> T invokeAny(@NonNull Collection<? extends Callable<T>> tasks)
+      throws InterruptedException, ExecutionException {
+    return delegate.invokeAny(tasks);
   }
 
   @Override
-  public <T> Future<T> submit(Callable<T> task) {
-    return maybeWait(super.submit(task));
+  public <T> T invokeAny(
+      @NonNull Collection<? extends Callable<T>> tasks,
+      long timeout,
+      @NonNull TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
+    return delegate.invokeAny(tasks, timeout, unit);
+  }
+
+  @NonNull
+  @Override
+  public <T> Future<T> submit(@NonNull Runnable task, T result) {
+    return delegate.submit(task, result);
+  }
+
+  @Override
+  public <T> Future<T> submit(@NonNull Callable<T> task) {
+    return delegate.submit(task);
+  }
+
+  @Override
+  public void shutdown() {
+    delegate.shutdown();
+  }
+
+  @NonNull
+  @Override
+  public List<Runnable> shutdownNow() {
+    return delegate.shutdownNow();
+  }
+
+  @Override
+  public boolean isShutdown() {
+    return delegate.isShutdown();
+  }
+
+  @Override
+  public boolean isTerminated() {
+    return delegate.isTerminated();
+  }
+
+  @Override
+  public boolean awaitTermination(long timeout, @NonNull TimeUnit unit)
+      throws InterruptedException {
+    return delegate.awaitTermination(timeout, unit);
+  }
+
+  @Override
+  public String toString() {
+    return delegate.toString();
   }
 
   /**
    * Determines the number of cores available on the device.
-   *
-   * <p>{@link Runtime#availableProcessors()} returns the number of awake cores, which may not
-   * be the number of available cores depending on the device's current state. See
-   * http://goo.gl/8H670N.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public static int calculateBestThreadCount() {
-    // We override the current ThreadPolicy to allow disk reads.
-    // This shouldn't actually do disk-IO and accesses a device file.
-    // See: https://github.com/bumptech/glide/issues/1170
-    ThreadPolicy originalPolicy = StrictMode.allowThreadDiskReads();
-    File[] cpus = null;
-    try {
-      File cpuInfo = new File(CPU_LOCATION);
-      final Pattern cpuNamePattern = Pattern.compile(CPU_NAME_REGEX);
-      cpus = cpuInfo.listFiles(new FilenameFilter() {
-        @Override
-        public boolean accept(File file, String s) {
-          return cpuNamePattern.matcher(s).matches();
-        }
-      });
-    } catch (Throwable t) {
-      if (Log.isLoggable(TAG, Log.ERROR)) {
-        Log.e(TAG, "Failed to calculate accurate cpu count", t);
-      }
-    } finally {
-      StrictMode.setThreadPolicy(originalPolicy);
+    if (bestThreadCount == 0) {
+      bestThreadCount =
+          Math.min(MAXIMUM_AUTOMATIC_THREAD_COUNT, RuntimeCompat.availableProcessors());
     }
-
-    int cpuCount = cpus != null ? cpus.length : 0;
-    int availableProcessors = Math.max(1, Runtime.getRuntime().availableProcessors());
-    return Math.min(MAXIMUM_AUTOMATIC_THREAD_COUNT, Math.max(availableProcessors, cpuCount));
+    return bestThreadCount;
   }
 
   /**
    * A strategy for handling unexpected and uncaught {@link Throwable}s thrown by futures run on the
    * pool.
    */
-  public enum UncaughtThrowableStrategy {
+  public interface UncaughtThrowableStrategy {
     /**
      * Silently catches and ignores the uncaught {@link Throwable}s.
      */
-    IGNORE,
+    // Public API.
+    @SuppressWarnings("unused")
+    UncaughtThrowableStrategy IGNORE = new UncaughtThrowableStrategy() {
+      @Override
+      public void handle(Throwable t) {
+        //ignore
+      }
+    };
     /**
      * Logs the uncaught {@link Throwable}s using {@link #TAG} and {@link Log}.
      */
-    LOG {
+    UncaughtThrowableStrategy LOG = new UncaughtThrowableStrategy() {
       @Override
-      protected void handle(Throwable t) {
+      public void handle(Throwable t) {
         if (t != null && Log.isLoggable(TAG, Log.ERROR)) {
           Log.e(TAG, "Request threw uncaught throwable", t);
         }
       }
-    },
+    };
     /**
      * Rethrows the uncaught {@link Throwable}s to crash the app.
      */
-    THROW {
+    // Public API.
+    @SuppressWarnings("unused")
+    UncaughtThrowableStrategy THROW = new UncaughtThrowableStrategy() {
       @Override
-      protected void handle(Throwable t) {
-        super.handle(t);
+      public void handle(Throwable t) {
         if (t != null) {
           throw new RuntimeException("Request threw uncaught throwable", t);
         }
@@ -304,11 +403,9 @@ protected void handle(Throwable t) {
     };
 
     /** The default strategy, currently {@link #LOG}. */
-    public static final UncaughtThrowableStrategy DEFAULT = LOG;
+    UncaughtThrowableStrategy DEFAULT = LOG;
 
-    protected void handle(Throwable t) {
-      // Ignore.
-    }
+    void handle(Throwable t);
   }
 
   /**
@@ -316,6 +413,9 @@ protected void handle(Throwable t) {
    * android.os.Process#THREAD_PRIORITY_BACKGROUND}.
    */
   private static final class DefaultThreadFactory implements ThreadFactory {
+    private static final int DEFAULT_PRIORITY = android.os.Process.THREAD_PRIORITY_BACKGROUND
+        + android.os.Process.THREAD_PRIORITY_MORE_FAVORABLE;
+
     private final String name;
     @Synthetic final UncaughtThrowableStrategy uncaughtThrowableStrategy;
     @Synthetic final boolean preventNetworkOperations;
@@ -333,9 +433,8 @@ public synchronized Thread newThread(@NonNull Runnable runnable) {
       final Thread result = new Thread(runnable, "glide-" + name + "-thread-" + threadNum) {
         @Override
         public void run() {
-          android.os.Process.setThreadPriority(
-              android.os.Process.THREAD_PRIORITY_BACKGROUND
-              + android.os.Process.THREAD_PRIORITY_MORE_FAVORABLE);
+          // why PMD suppression is needed: https://github.com/pmd/pmd/issues/808
+          android.os.Process.setThreadPriority(DEFAULT_PRIORITY); //NOPMD AccessorMethodGeneration
           if (preventNetworkOperations) {
             StrictMode.setThreadPolicy(
                 new ThreadPolicy.Builder()
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/executor/RuntimeCompat.java b/library/src/main/java/com/bumptech/glide/load/engine/executor/RuntimeCompat.java
new file mode 100644
index 000000000..8dc69bdeb
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/RuntimeCompat.java
@@ -0,0 +1,68 @@
+package com.bumptech.glide.load.engine.executor;
+
+import android.os.Build;
+import android.os.StrictMode;
+import android.os.StrictMode.ThreadPolicy;
+import android.util.Log;
+import java.io.File;
+import java.io.FilenameFilter;
+import java.util.regex.Pattern;
+
+/**
+ * Compatibility methods for {@link java.lang.Runtime}.
+ */
+final class RuntimeCompat {
+  private static final String TAG = "GlideRuntimeCompat";
+  private static final String CPU_NAME_REGEX = "cpu[0-9]+";
+  private static final String CPU_LOCATION = "/sys/devices/system/cpu/";
+
+  private RuntimeCompat() {
+    // Utility class.
+  }
+
+  /**
+   * Determines the number of cores available on the device.
+   */
+  static int availableProcessors() {
+    int cpus = Runtime.getRuntime().availableProcessors();
+    if (Build.VERSION.SDK_INT < 17) {
+      cpus = Math.max(getCoreCountPre17(), cpus);
+    }
+    return cpus;
+  }
+
+  /**
+   * Determines the number of cores available on the device (pre-v17).
+   *
+   * <p>Before Jellybean, {@link Runtime#availableProcessors()} returned the number of awake cores,
+   * which may not be the number of available cores depending on the device's current state. See
+   * https://stackoverflow.com/a/30150409.
+   *
+   * @return the maximum number of processors available to the VM; never smaller than one
+   */
+  @SuppressWarnings("PMD")
+  private static int getCoreCountPre17() {
+    // We override the current ThreadPolicy to allow disk reads.
+    // This shouldn't actually do disk-IO and accesses a device file.
+    // See: https://github.com/bumptech/glide/issues/1170
+    File[] cpus = null;
+    ThreadPolicy originalPolicy = StrictMode.allowThreadDiskReads();
+    try {
+      File cpuInfo = new File(CPU_LOCATION);
+      final Pattern cpuNamePattern = Pattern.compile(CPU_NAME_REGEX);
+      cpus = cpuInfo.listFiles(new FilenameFilter() {
+        @Override
+        public boolean accept(File file, String s) {
+          return cpuNamePattern.matcher(s).matches();
+        }
+      });
+    } catch (Throwable t) {
+      if (Log.isLoggable(TAG, Log.ERROR)) {
+        Log.e(TAG, "Failed to calculate accurate cpu count", t);
+      }
+    } finally {
+      StrictMode.setThreadPolicy(originalPolicy);
+    }
+    return Math.max(1, cpus != null ? cpus.length : 0);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java
index a2f92a9db..a8c5d641c 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java
@@ -4,6 +4,8 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.os.SystemClock;
+import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
 import android.util.Log;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
@@ -28,7 +30,8 @@
  * limit, we assume a GC has occurred, stop the current allocations, and try again after a delay.
  */
 final class BitmapPreFillRunner implements Runnable {
-  private static final String TAG = "PreFillRunner";
+  @VisibleForTesting
+  static final String TAG = "PreFillRunner";
   private static final Clock DEFAULT_CLOCK = new Clock();
 
   /**
@@ -62,15 +65,25 @@
   private long currentDelay = INITIAL_BACKOFF_MS;
   private boolean isCancelled;
 
-  public BitmapPreFillRunner(BitmapPool bitmapPool, MemoryCache memoryCache,
-      PreFillQueue allocationOrder) {
-    this(bitmapPool, memoryCache, allocationOrder, DEFAULT_CLOCK,
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public BitmapPreFillRunner(
+      BitmapPool bitmapPool, MemoryCache memoryCache, PreFillQueue allocationOrder) {
+    this(
+        bitmapPool,
+        memoryCache,
+        allocationOrder,
+        DEFAULT_CLOCK,
         new Handler(Looper.getMainLooper()));
   }
 
-  // Visible for testing.
-  BitmapPreFillRunner(BitmapPool bitmapPool, MemoryCache memoryCache, PreFillQueue allocationOrder,
-      Clock clock, Handler handler) {
+  @VisibleForTesting
+  BitmapPreFillRunner(
+      BitmapPool bitmapPool,
+      MemoryCache memoryCache,
+      PreFillQueue allocationOrder,
+      Clock clock,
+      Handler handler) {
     this.bitmapPool = bitmapPool;
     this.memoryCache = memoryCache;
     this.toPrefill = allocationOrder;
@@ -86,33 +99,44 @@ public void cancel() {
    * Attempts to allocate {@link android.graphics.Bitmap}s and returns {@code true} if there are
    * more {@link android.graphics.Bitmap}s to allocate and {@code false} otherwise.
    */
-  private boolean allocate() {
+  @VisibleForTesting
+  boolean allocate() {
     long start = clock.now();
     while (!toPrefill.isEmpty() && !isGcDetected(start)) {
       PreFillType toAllocate = toPrefill.remove();
       final Bitmap bitmap;
       if (!seenTypes.contains(toAllocate)) {
         seenTypes.add(toAllocate);
-        bitmap = bitmapPool.getDirty(toAllocate.getWidth(), toAllocate.getHeight(),
-            toAllocate.getConfig());
+        bitmap =
+            bitmapPool.getDirty(
+                toAllocate.getWidth(), toAllocate.getHeight(), toAllocate.getConfig());
       } else {
-        bitmap = Bitmap.createBitmap(toAllocate.getWidth(), toAllocate.getHeight(),
-            toAllocate.getConfig());
+        bitmap =
+            Bitmap.createBitmap(
+                toAllocate.getWidth(), toAllocate.getHeight(), toAllocate.getConfig());
       }
 
+      // Order matters here! If the Bitmap is too large or the BitmapPool is too full, it may be
+      // recycled after the call to bitmapPool#put below.
+      int bitmapSize = Util.getBitmapByteSize(bitmap);
+
       // Don't over fill the memory cache to avoid evicting useful resources, but make sure it's
-      // not empty so
-      // we use all available space.
-      if (getFreeMemoryCacheBytes() >= Util.getBitmapByteSize(bitmap)) {
-        memoryCache.put(new UniqueKey(), BitmapResource.obtain(bitmap, bitmapPool));
+      // not empty so that we use all available space.
+      if (getFreeMemoryCacheBytes() >= bitmapSize) {
+        // We could probably make UniqueKey just always return false from equals,
+        // but the allocation of the Key is not nearly as expensive as the allocation of the Bitmap,
+        // so it's probably not worth it.
+        @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")
+        Key uniqueKey = new UniqueKey();
+        memoryCache.put(uniqueKey, BitmapResource.obtain(bitmap, bitmapPool));
       } else {
         bitmapPool.put(bitmap);
       }
 
       if (Log.isLoggable(TAG, Log.DEBUG)) {
         Log.d(TAG,
-            "allocated [" + toAllocate.getWidth() + "x" + toAllocate.getHeight() + "] " + toAllocate
-                .getConfig() + " size: " + Util.getBitmapByteSize(bitmap));
+            "allocated [" + toAllocate.getWidth() + "x" + toAllocate.getHeight() + "] "
+                + toAllocate.getConfig() + " size: " + bitmapSize);
       }
     }
 
@@ -123,7 +147,7 @@ private boolean isGcDetected(long startTimeMs) {
     return clock.now() - startTimeMs >= MAX_DURATION_MS;
   }
 
-  private int getFreeMemoryCacheBytes() {
+  private long getFreeMemoryCacheBytes() {
     return memoryCache.getMaxSize() - memoryCache.getCurrentSize();
   }
 
@@ -140,20 +164,21 @@ private long getNextDelay() {
     return result;
   }
 
-  private static class UniqueKey implements Key {
+  private static final class UniqueKey implements Key {
 
     @Synthetic
+    @SuppressWarnings("WeakerAccess")
     UniqueKey() { }
 
     @Override
-    public void updateDiskCacheKey(MessageDigest messageDigest) {
+    public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
       throw new UnsupportedOperationException();
     }
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class Clock {
-    public long now() {
+    long now() {
       return SystemClock.currentThreadTimeMillis();
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java
index 42a5a46c1..09d00876d 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java
@@ -3,6 +3,7 @@
 import android.graphics.Bitmap;
 import android.os.Handler;
 import android.os.Looper;
+import android.support.annotation.VisibleForTesting;
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
@@ -30,6 +31,7 @@ public BitmapPreFiller(MemoryCache memoryCache, BitmapPool bitmapPool,
     this.defaultFormat = defaultFormat;
   }
 
+  @SuppressWarnings("deprecation")
   public void preFill(PreFillType.Builder... bitmapAttributeBuilders) {
     if (current != null) {
       current.cancel();
@@ -39,7 +41,8 @@ public void preFill(PreFillType.Builder... bitmapAttributeBuilders) {
     for (int i = 0; i < bitmapAttributeBuilders.length; i++) {
       PreFillType.Builder builder = bitmapAttributeBuilders[i];
       if (builder.getConfig() == null) {
-        builder.setConfig(defaultFormat == DecodeFormat.PREFER_ARGB_8888
+        builder.setConfig(
+            defaultFormat == DecodeFormat.PREFER_ARGB_8888
             ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565);
       }
       bitmapAttributes[i] = builder.build();
@@ -50,9 +53,9 @@ public void preFill(PreFillType.Builder... bitmapAttributeBuilders) {
     handler.post(current);
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   PreFillQueue generateAllocationOrder(PreFillType... preFillSizes) {
-    final int maxSize =
+    final long maxSize =
         memoryCache.getMaxSize() - memoryCache.getCurrentSize() + bitmapPool.getMaxSize();
 
     int totalWeight = 0;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillType.java b/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillType.java
index 9c07fb07c..31a8b529a 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillType.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillType.java
@@ -2,6 +2,7 @@
 
 import android.graphics.Bitmap;
 import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 import com.bumptech.glide.util.Preconditions;
 
 /**
@@ -10,7 +11,7 @@
  * single size and configuration.
  */
 public final class PreFillType {
-  // Visible for testing.
+  @VisibleForTesting
   static final Bitmap.Config DEFAULT_CONFIG = Bitmap.Config.RGB_565;
   private final int width;
   private final int height;
diff --git a/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java
index 7083de7bc..9eea06323 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java
@@ -4,6 +4,7 @@
 import android.content.res.AssetManager;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.FileDescriptorAssetPathFetcher;
@@ -25,20 +26,22 @@
   private final AssetManager assetManager;
   private final AssetFetcherFactory<Data> factory;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public AssetUriLoader(AssetManager assetManager, AssetFetcherFactory<Data> factory) {
     this.assetManager = assetManager;
     this.factory = factory;
   }
 
   @Override
-  public LoadData<Data> buildLoadData(Uri model, int width, int height,
-      Options options) {
+  public LoadData<Data> buildLoadData(@NonNull Uri model, int width, int height,
+      @NonNull Options options) {
     String assetPath = model.toString().substring(ASSET_PREFIX_LENGTH);
     return new LoadData<>(new ObjectKey(model), factory.buildFetcher(assetManager, assetPath));
   }
 
   @Override
-  public boolean handles(Uri model) {
+  public boolean handles(@NonNull Uri model) {
     return ContentResolver.SCHEME_FILE.equals(model.getScheme()) && !model.getPathSegments()
         .isEmpty() && ASSET_PATH_SEGMENT.equals(model.getPathSegments().get(0));
   }
@@ -64,6 +67,7 @@ public StreamFactory(AssetManager assetManager) {
       this.assetManager = assetManager;
     }
 
+    @NonNull
     @Override
     public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new AssetUriLoader<>(assetManager, this);
@@ -93,6 +97,7 @@ public FileDescriptorFactory(AssetManager assetManager) {
       this.assetManager = assetManager;
     }
 
+    @NonNull
     @Override
     public ModelLoader<Uri, ParcelFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
       return new AssetUriLoader<>(assetManager, this);
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
index de57d499f..bb8213fc1 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
@@ -1,12 +1,11 @@
 package com.bumptech.glide.load.model;
 
 import android.support.annotation.NonNull;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
-import com.bumptech.glide.signature.EmptySignature;
+import com.bumptech.glide.signature.ObjectKey;
 import java.io.ByteArrayInputStream;
 import java.io.InputStream;
 import java.nio.ByteBuffer;
@@ -21,28 +20,30 @@
 public class ByteArrayLoader<Data> implements ModelLoader<byte[], Data> {
   private final Converter<Data> converter;
 
+  @SuppressWarnings("WeakerAccess") // Public API
   public ByteArrayLoader(Converter<Data> converter) {
     this.converter = converter;
   }
 
   @Override
-  public LoadData<Data> buildLoadData(byte[] model, int width, int height,
-      Options options) {
-    // TODO: compare the actual bytes?
-    return new LoadData<>(EmptySignature.obtain(), new Fetcher<>(model, converter));
+  public LoadData<Data> buildLoadData(
+      @NonNull byte[] model, int width, int height, @NonNull Options options) {
+    return new LoadData<>(new ObjectKey(model), new Fetcher<>(model, converter));
   }
 
   @Override
-  public boolean handles(byte[] model) {
+  public boolean handles(@NonNull byte[] model) {
     return true;
   }
 
   /**
    * Converts between a byte array a desired model class.
+   *
    * @param <Data> The type of data to convert to.
    */
   public interface Converter<Data> {
     Data convert(byte[] model);
+
     Class<Data> getDataClass();
   }
 
@@ -50,13 +51,19 @@ public boolean handles(byte[] model) {
     private final byte[] model;
     private final Converter<Data> converter;
 
-    public Fetcher(byte[] model, Converter<Data> converter) {
+    /**
+     * @param model We really ought to copy the model, but doing so can be hugely expensive and/or
+     *              lead to OOMs. In practice it's unlikely that users would pass an array into
+     *              Glide and then mutate it.
+     */
+    @SuppressWarnings("PMD.ArrayIsStoredDirectly")
+    Fetcher(byte[] model, Converter<Data> converter) {
       this.model = model;
       this.converter = converter;
     }
 
     @Override
-    public void loadData(Priority priority, DataCallback<? super Data> callback) {
+    public void loadData(@NonNull Priority priority, @NonNull DataCallback<? super Data> callback) {
       Data result = converter.convert(model);
       callback.onDataReady(result);
     }
@@ -90,8 +97,9 @@ public DataSource getDataSource() {
    */
   public static class ByteBufferFactory implements ModelLoaderFactory<byte[], ByteBuffer> {
 
+    @NonNull
     @Override
-    public ModelLoader<byte[], ByteBuffer> build(MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<byte[], ByteBuffer> build(@NonNull MultiModelLoaderFactory multiFactory) {
       return new ByteArrayLoader<>(new Converter<ByteBuffer>() {
         @Override
         public ByteBuffer convert(byte[] model) {
@@ -116,8 +124,9 @@ public void teardown() {
    */
   public static class StreamFactory implements ModelLoaderFactory<byte[], InputStream> {
 
+    @NonNull
     @Override
-    public ModelLoader<byte[], InputStream> build(MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<byte[], InputStream> build(@NonNull MultiModelLoaderFactory multiFactory) {
       return new ByteArrayLoader<>(new Converter<InputStream>() {
         @Override
         public InputStream convert(byte[] model) {
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferEncoder.java b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferEncoder.java
index 278d16f2f..9c8b6a121 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferEncoder.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.model;
 
+import android.support.annotation.NonNull;
 import android.util.Log;
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.Options;
@@ -15,7 +16,7 @@
   private static final String TAG = "ByteBufferEncoder";
 
   @Override
-  public boolean encode(ByteBuffer data, File file, Options options) {
+  public boolean encode(@NonNull ByteBuffer data, @NonNull File file, @NonNull Options options) {
     boolean success = false;
     try {
       ByteBufferUtil.toFile(data, file);
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java
index 82a787898..c56d04b08 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java
@@ -8,6 +8,7 @@
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.signature.ObjectKey;
 import com.bumptech.glide.util.ByteBufferUtil;
+import com.bumptech.glide.util.Synthetic;
 import java.io.File;
 import java.io.IOException;
 import java.nio.ByteBuffer;
@@ -19,13 +20,13 @@
   private static final String TAG = "ByteBufferFileLoader";
 
   @Override
-  public LoadData<ByteBuffer> buildLoadData(File file, int width, int height,
-      Options options) {
+  public LoadData<ByteBuffer> buildLoadData(@NonNull File file, int width, int height,
+      @NonNull Options options) {
     return new LoadData<>(new ObjectKey(file), new ByteBufferFetcher(file));
   }
 
   @Override
-  public boolean handles(File file) {
+  public boolean handles(@NonNull File file) {
     return true;
   }
 
@@ -34,8 +35,9 @@ public boolean handles(File file) {
    */
   public static class Factory implements ModelLoaderFactory<File, ByteBuffer> {
 
+    @NonNull
     @Override
-    public ModelLoader<File, ByteBuffer> build(MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<File, ByteBuffer> build(@NonNull MultiModelLoaderFactory multiFactory) {
       return new ByteBufferFileLoader();
     }
 
@@ -45,17 +47,20 @@ public void teardown() {
     }
   }
 
-  private static class ByteBufferFetcher implements DataFetcher<ByteBuffer> {
+  private static final class ByteBufferFetcher implements DataFetcher<ByteBuffer> {
 
     private final File file;
 
-    public ByteBufferFetcher(File file) {
+    @Synthetic
+    @SuppressWarnings("WeakerAccess")
+    ByteBufferFetcher(File file) {
       this.file = file;
     }
 
     @Override
-    public void loadData(Priority priority, DataCallback<? super ByteBuffer> callback) {
-      ByteBuffer result = null;
+    public void loadData(@NonNull Priority priority,
+        @NonNull DataCallback<? super ByteBuffer> callback) {
+      ByteBuffer result;
       try {
         result = ByteBufferUtil.fromFile(file);
       } catch (IOException e) {
diff --git a/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java
index 4f522f4ac..646c43907 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java
@@ -20,26 +20,33 @@
  *
  * <p>Briefly, a 'data' URL has the form: <pre>data:[mediatype][;base64],some_data</pre>
  *
- * @param <Data> The type of data that can be opened.
+ * @param <Model> The type of Model that we can retrieve data for, e.g. {@link String}.
+ * @param <Data> The type of data that can be opened, e.g. {@link InputStream}.
  */
-public final class DataUrlLoader<Data> implements ModelLoader<String, Data> {
+public final class DataUrlLoader<Model, Data> implements ModelLoader<Model, Data> {
 
   private static final String DATA_SCHEME_IMAGE = "data:image";
   private static final String BASE64_TAG = ";base64";
   private final DataDecoder<Data> dataDecoder;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public DataUrlLoader(DataDecoder<Data> dataDecoder) {
     this.dataDecoder = dataDecoder;
   }
 
   @Override
-  public LoadData<Data> buildLoadData(String model, int width, int height, Options options) {
-    return new LoadData<>(new ObjectKey(model), new DataUriFetcher<Data>(model, dataDecoder));
+  public LoadData<Data> buildLoadData(@NonNull Model model, int width, int height,
+      @NonNull Options options) {
+    return new LoadData<>(
+        new ObjectKey(model), new DataUriFetcher<>(model.toString(), dataDecoder));
   }
 
   @Override
-  public boolean handles(String url) {
-    return url.startsWith(DATA_SCHEME_IMAGE);
+  public boolean handles(@NonNull Model model) {
+    // We expect Model to be a Uri or a String, both of which implement toString() efficiently. We
+    // should reconsider this implementation before adding any new Model types.
+    return model.toString().startsWith(DATA_SCHEME_IMAGE);
   }
 
   /**
@@ -62,13 +69,13 @@ public boolean handles(String url) {
     private final DataDecoder<Data> reader;
     private Data data;
 
-    public DataUriFetcher(String dataUri, DataDecoder<Data> reader) {
+    DataUriFetcher(String dataUri, DataDecoder<Data> reader) {
       this.dataUri = dataUri;
       this.reader = reader;
     }
 
     @Override
-    public void loadData(Priority priority, DataCallback<? super Data> callback) {
+    public void loadData(@NonNull Priority priority, @NonNull DataCallback<? super Data> callback) {
       try {
         data = reader.decode(dataUri);
         callback.onDataReady(data);
@@ -105,9 +112,11 @@ public DataSource getDataSource() {
   }
 
   /**
-   * Factory for loading {@link InputStream} from Data URL string.
+   * Factory for loading {@link InputStream}s from data uris.
+   *
+   * @param <Model> The type of Model we can obtain data for, e.g. String.
    */
-  public static final class StreamFactory implements ModelLoaderFactory<String, InputStream> {
+  public static final class StreamFactory<Model> implements ModelLoaderFactory<Model, InputStream> {
 
     private final DataDecoder<InputStream> opener;
 
@@ -147,13 +156,15 @@ public void close(InputStream inputStream) throws IOException {
       };
     }
 
+    @NonNull
     @Override
-    public final ModelLoader<String, InputStream> build(MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Model, InputStream> build(
+        @NonNull MultiModelLoaderFactory multiFactory) {
       return new DataUrlLoader<>(opener);
     }
 
     @Override
-    public final void teardown() {
+    public void teardown() {
       // Do nothing.
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
index 3d6fb70c3..e4f0d9178 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
@@ -25,18 +25,20 @@
 
   private final FileOpener<Data> fileOpener;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public FileLoader(FileOpener<Data> fileOpener) {
     this.fileOpener = fileOpener;
   }
 
   @Override
-  public LoadData<Data> buildLoadData(File model, int width, int height,
-      Options options) {
+  public LoadData<Data> buildLoadData(@NonNull File model, int width, int height,
+      @NonNull Options options) {
     return new LoadData<>(new ObjectKey(model), new FileFetcher<>(model, fileOpener));
   }
 
   @Override
-  public boolean handles(File model) {
+  public boolean handles(@NonNull File model) {
     return true;
   }
 
@@ -50,18 +52,18 @@ public boolean handles(File model) {
     Class<Data> getDataClass();
   }
 
-  private static class FileFetcher<Data> implements DataFetcher<Data> {
+  private static final class FileFetcher<Data> implements DataFetcher<Data> {
     private final File file;
     private final FileOpener<Data> opener;
     private Data data;
 
-    public FileFetcher(File file, FileOpener<Data> opener) {
+    FileFetcher(File file, FileOpener<Data> opener) {
       this.file = file;
       this.opener = opener;
     }
 
     @Override
-    public void loadData(Priority priority, DataCallback<? super Data> callback) {
+    public void loadData(@NonNull Priority priority, @NonNull DataCallback<? super Data> callback) {
       try {
         data = opener.open(file);
       } catch (FileNotFoundException e) {
@@ -114,8 +116,9 @@ public Factory(FileOpener<Data> opener) {
       this.opener = opener;
     }
 
+    @NonNull
     @Override
-    public final ModelLoader<File, Data> build(MultiModelLoaderFactory multiFactory) {
+    public final ModelLoader<File, Data> build(@NonNull MultiModelLoaderFactory multiFactory) {
       return new FileLoader<>(opener);
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java
index 02a26aa26..4661d3b0d 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.model;
 
 import android.net.Uri;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.text.TextUtils;
 import com.bumptech.glide.load.Key;
@@ -26,7 +27,7 @@
  * convenience. </p>
  */
 public class GlideUrl implements Key {
-  private static final String ALLOWED_URI_CHARS = "@#&=*+-_.,:!?()/~'%";
+  private static final String ALLOWED_URI_CHARS = "@#&=*+-_.,:!?()/~'%;$";
   private final Headers headers;
   @Nullable private final URL url;
   @Nullable private final String stringUrl;
@@ -86,7 +87,7 @@ private String getSafeStringUrl() {
     if (TextUtils.isEmpty(safeStringUrl)) {
       String unsafeStringUrl = stringUrl;
       if (TextUtils.isEmpty(unsafeStringUrl)) {
-        unsafeStringUrl = url.toString();
+        unsafeStringUrl = Preconditions.checkNotNull(url).toString();
       }
       safeStringUrl = Uri.encode(unsafeStringUrl, ALLOWED_URI_CHARS);
     }
@@ -103,13 +104,15 @@ private String getSafeStringUrl() {
   /**
    * Returns an inexpensive to calculate {@link String} suitable for use as a disk cache key.
    *
-   * <p> This method does not include headers. </p>
+   * <p>This method does not include headers.
    *
-   * <p> Unlike {@link #toStringUrl()}} and {@link #toURL()}, this method does not escape
-   * input. </p>
+   * <p>Unlike {@link #toStringUrl()}} and {@link #toURL()}, this method does not escape
+   * input.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public String getCacheKey() {
-    return stringUrl != null ? stringUrl : url.toString();
+    return stringUrl != null ? stringUrl : Preconditions.checkNotNull(url).toString();
   }
 
   @Override
@@ -118,7 +121,7 @@ public String toString() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     messageDigest.update(getCacheKeyBytes());
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java
index 66a76cd11..c00cc434f 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java
@@ -9,16 +9,14 @@
  * <p> Implementations should implement equals() and hashcode() </p> .
  */
 public interface LazyHeaderFactory {
-
-    /**
-     * Returns an http header, or {@code null} if no header could be built.
-     *
-     * <p>Returning {@code null} or an empty String from this method will result in this particular
-     * key/value being excluded from the headers provided in the request. If there are multiple
-     * factories or values for a particular key, any non-null values will still be included for that
-     * key.
-     */
-    @Nullable
-    String buildHeader();
-
+  /**
+   * Returns an http header, or {@code null} if no header could be built.
+   *
+   * <p>Returning {@code null} or an empty String from this method will result in this particular
+   * key/value being excluded from the headers provided in the request. If there are multiple
+   * factories or values for a particular key, any non-null values will still be included for that
+   * key.
+   */
+  @Nullable
+  String buildHeader();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
index 1eb43556d..e7f446ca5 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.load.model;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
 import android.text.TextUtils;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -41,28 +43,32 @@
     Map<String, String> combinedHeaders = new HashMap<>();
 
     for (Map.Entry<String, List<LazyHeaderFactory>> entry : headers.entrySet()) {
-      StringBuilder sb = new StringBuilder();
-      List<LazyHeaderFactory> factories = entry.getValue();
-      int size = factories.size();
-      for (int i = 0; i < size; i++) {
-        LazyHeaderFactory factory = factories.get(i);
-        String header = factory.buildHeader();
-        if (!TextUtils.isEmpty(header)) {
-          sb.append(header);
-          if (i != factories.size() - 1) {
-            sb.append(',');
-          }
-        }
-      }
-      String values = sb.toString();
+      String values = buildHeaderValue(entry.getValue());
       if (!TextUtils.isEmpty(values)) {
-        combinedHeaders.put(entry.getKey(), sb.toString());
+        combinedHeaders.put(entry.getKey(), values);
       }
     }
 
     return combinedHeaders;
   }
 
+  @NonNull
+  private String buildHeaderValue(@NonNull List<LazyHeaderFactory> factories) {
+    StringBuilder sb = new StringBuilder();
+    int size = factories.size();
+    for (int i = 0; i < size; i++) {
+      LazyHeaderFactory factory = factories.get(i);
+      String header = factory.buildHeader();
+      if (!TextUtils.isEmpty(header)) {
+        sb.append(header);
+        if (i != factories.size() - 1) {
+          sb.append(',');
+        }
+      }
+    }
+    return sb.toString();
+  }
+
   @Override
   public String toString() {
     return "LazyHeaders{"
@@ -95,11 +101,9 @@ public int hashCode() {
    * {@link #addHeader(String, String)}, even though {@link #addHeader(String, LazyHeaderFactory)}
    * would usually append an additional value. </p>
    */
-   // PMD doesn't like the necessary static block to initialize DEFAULT_HEADERS.
-  @SuppressWarnings("PMD.FieldDeclarationsShouldBeAtStartOfClass")
   public static final class Builder {
     private static final String USER_AGENT_HEADER = "User-Agent";
-    private static final String DEFAULT_USER_AGENT = System.getProperty("http.agent");
+    private static final String DEFAULT_USER_AGENT = getSanitizedUserAgent();
     private static final Map<String, List<LazyHeaderFactory>> DEFAULT_HEADERS;
 
     // Set Accept-Encoding header to do our best to avoid gzip since it's both inefficient for
@@ -127,7 +131,6 @@ public int hashCode() {
      * (i.e. an OAuth token). </p>
      *
      * @see #addHeader(String, LazyHeaderFactory)
-
      */
     public Builder addHeader(String key, String value) {
       return addHeader(key, new StringHeaderFactory(value));
@@ -162,6 +165,7 @@ public Builder addHeader(String key, LazyHeaderFactory factory) {
      * <p> Use {@link #setHeader(String, LazyHeaderFactory)} if obtaining the value requires I/O
      * (i.e. an OAuth token). </p>
      */
+    @SuppressWarnings({"UnusedReturnValue", "WeakerAccess"}) // Public API
     public Builder setHeader(String key, String value) {
       return setHeader(key, value == null ? null : new StringHeaderFactory(value));
     }
@@ -214,13 +218,39 @@ public LazyHeaders build() {
     }
 
     private Map<String, List<LazyHeaderFactory>> copyHeaders() {
-      Map<String, List<LazyHeaderFactory>> result =
-          new HashMap<>(headers.size());
+      Map<String, List<LazyHeaderFactory>> result = new HashMap<>(headers.size());
       for (Map.Entry<String, List<LazyHeaderFactory>> entry : headers.entrySet()) {
-        result.put(entry.getKey(), new ArrayList<>(entry.getValue()));
+        @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")
+        List<LazyHeaderFactory> valueCopy = new ArrayList<>(entry.getValue());
+        result.put(entry.getKey(), valueCopy);
       }
       return result;
     }
+
+    /**
+     * Ensures that the default header will pass OkHttp3's checks for header values.
+     *
+     * @see <a href="https://github.com/bumptech/glide/issues/2331">#2331</a>
+     */
+    @VisibleForTesting
+    static String getSanitizedUserAgent() {
+      String defaultUserAgent = System.getProperty("http.agent");
+      if (TextUtils.isEmpty(defaultUserAgent)) {
+        return defaultUserAgent;
+      }
+
+      int length = defaultUserAgent.length();
+      StringBuilder sb = new StringBuilder(defaultUserAgent.length());
+      for (int i = 0; i < length; i++) {
+        char c = defaultUserAgent.charAt(i);
+        if ((c > '\u001f' || c == '\t') && c < '\u007f') {
+          sb.append(c);
+        } else {
+          sb.append('?');
+        }
+      }
+      return sb.toString();
+    }
   }
 
   static final class StringHeaderFactory implements LazyHeaderFactory {
diff --git a/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java
index 7d389f197..6b36fb0ec 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java
@@ -18,21 +18,24 @@
 /**
  * Loads the file path for {@link MediaStore} owned {@link Uri uris}.
  */
-public final class MediaStoreFileLoader implements ModelLoader<Uri, File>  {
+public final class MediaStoreFileLoader implements ModelLoader<Uri, File> {
 
   private final Context context;
 
-  MediaStoreFileLoader(Context context) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public MediaStoreFileLoader(Context context) {
     this.context = context;
   }
 
   @Override
-  public LoadData<File> buildLoadData(Uri uri, int width, int height, Options options) {
+  public LoadData<File> buildLoadData(@NonNull Uri uri, int width, int height,
+      @NonNull Options options) {
     return new LoadData<>(new ObjectKey(uri), new FilePathFetcher(context, uri));
   }
 
   @Override
-  public boolean handles(Uri uri) {
+  public boolean handles(@NonNull Uri uri) {
     return MediaStoreUtil.isMediaStoreUri(uri);
   }
 
@@ -50,7 +53,7 @@ public boolean handles(Uri uri) {
     }
 
     @Override
-    public void loadData(Priority priority, DataCallback<? super File> callback) {
+    public void loadData(@NonNull Priority priority, @NonNull DataCallback<? super File> callback) {
       Cursor cursor = context.getContentResolver().query(uri, PROJECTION, null /*selection*/,
           null /*selectionArgs*/, null /*sortOrder*/);
 
@@ -106,6 +109,7 @@ public Factory(Context context) {
       this.context = context;
     }
 
+    @NonNull
     @Override
     public ModelLoader<Uri, File> build(MultiModelLoaderFactory multiFactory) {
       return new MediaStoreFileLoader(context);
diff --git a/library/src/main/java/com/bumptech/glide/load/model/Model.java b/library/src/main/java/com/bumptech/glide/load/model/Model.java
new file mode 100644
index 000000000..b82f75f55
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/model/Model.java
@@ -0,0 +1,30 @@
+package com.bumptech.glide.load.model;
+
+import android.support.annotation.Nullable;
+
+/**
+ * An optional interface that models can implement to enhance control over Glide behaviors.
+ */
+public interface Model {
+
+  /**
+   * Returns {@code true} if this model produces the same image using the same mechanism
+   * (server, authentication, source etc) as the given model.
+   * <p>
+   * Models must also override {@link Object#equals(Object other)} and {@link Object#hashCode()}
+   * to ensure that caching functions correctly.
+   * If this object returns {@code true} from this method for a given Model,
+   * it must also be equal to and have the same hash code as the given model.
+   * <p>
+   * However, this model may be equal to and have the same hash code as a given model
+   * but still return {@code false} from this method.
+   * This method optionally allows you to differentiate between Models that load the same image
+   * via multiple different means.
+   * For example one Model might load the image from server A and another model might load
+   * the same image from server B.
+   * The models must be equal to each other with the same hash code because they load
+   * the same image. However two requests made with the different models are not exactly the
+   * same because the way the image is loaded will differ.
+   */
+  boolean isEquivalentTo(@Nullable Object other);
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java b/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java
index a4f10978a..c654de2fc 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java
@@ -1,6 +1,8 @@
 package com.bumptech.glide.load.model;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 import com.bumptech.glide.util.LruCache;
 import com.bumptech.glide.util.Util;
 import java.util.Queue;
@@ -19,14 +21,16 @@
 
   private final LruCache<ModelKey<A>, B> cache;
 
+  // Public API.
+  @SuppressWarnings("unused")
   public ModelCache() {
     this(DEFAULT_SIZE);
   }
 
-  public ModelCache(int size) {
+  public ModelCache(long size) {
     cache = new LruCache<ModelKey<A>, B>(size) {
       @Override
-      protected void onItemEvicted(ModelKey<A> key, B item) {
+      protected void onItemEvicted(@NonNull ModelKey<A> key, @Nullable B item) {
         key.release();
       }
     };
@@ -68,7 +72,7 @@ public void clear() {
     cache.clearMemory();
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static final class ModelKey<A> {
     private static final Queue<ModelKey<?>> KEY_QUEUE = Util.createQueue(0);
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java
index 230551c5d..2ef8de0dc 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.model;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
@@ -46,11 +47,12 @@
     public final List<Key> alternateKeys;
     public final DataFetcher<Data> fetcher;
 
-    public LoadData(Key sourceKey, DataFetcher<Data> fetcher) {
+    public LoadData(@NonNull Key sourceKey, @NonNull DataFetcher<Data> fetcher) {
       this(sourceKey, Collections.<Key>emptyList(), fetcher);
     }
 
-    public LoadData(Key sourceKey, List<Key> alternateKeys, DataFetcher<Data> fetcher) {
+    public LoadData(@NonNull Key sourceKey, @NonNull List<Key> alternateKeys,
+        @NonNull DataFetcher<Data> fetcher) {
       this.sourceKey = Preconditions.checkNotNull(sourceKey);
       this.alternateKeys = Preconditions.checkNotNull(alternateKeys);
       this.fetcher = Preconditions.checkNotNull(fetcher);
@@ -77,7 +79,8 @@ public LoadData(Key sourceKey, List<Key> alternateKeys, DataFetcher<Data> fetche
    *               the resource should be loaded at its original height.
    */
   @Nullable
-  LoadData<Data> buildLoadData(Model model, int width, int height, Options options);
+  LoadData<Data> buildLoadData(@NonNull Model model, int width, int height,
+      @NonNull Options options);
 
   /**
    * Returns true if the given model is a of a recognized type that this loader can probably load.
@@ -89,5 +92,5 @@ public LoadData(Key sourceKey, List<Key> alternateKeys, DataFetcher<Data> fetche
    * results are acceptable. {@link ModelLoader ModelLoaders} that return true from this method may
    * return {@code null} from {@link #buildLoadData(Object, int, int, Options)} </p>
    */
-  boolean handles(Model model);
+  boolean handles(@NonNull Model model);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java
index 19e126019..921d4c488 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java
@@ -1,12 +1,19 @@
 package com.bumptech.glide.load.model;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Registry;
 
 /**
- * An interface for creating a {@link ModelLoader} for a given model type. Will be retained
- * statically so should not retain {@link Context} or any other objects that cannot be retained for
- * the life of the application. ModelLoaders will not be retained statically so it is safe for any
- * ModelLoader built by this factory to retain a reference to a {@link Context}.
+ * An interface for creating a {@link ModelLoader} for a given model type.
+ *
+ * <p>The application {@link android.content.Context} can be passed in to the constructor of the
+ * factory when necessary. It's unsafe to retain {@link android.app.Activity}
+ * {@link android.content.Context}s in factories. The {@link android.content.Context} can be
+ * obtained from
+ * {@link com.bumptech.glide.module.LibraryGlideModule#registerComponents(Context, Glide, Registry)}
+ * in most cases.
  *
  * @param <T> The type of the model the {@link com.bumptech.glide.load.model.ModelLoader}s built by
  *            this factory can handle
@@ -22,7 +29,8 @@
    *                     {@link ModelLoader}s that this factory's {@link ModelLoader} may depend on
    * @return A new {@link ModelLoader}
    */
-  ModelLoader<T, Y> build(MultiModelLoaderFactory multiFactory);
+  @NonNull
+  ModelLoader<T, Y> build(@NonNull MultiModelLoaderFactory multiFactory);
 
   /**
    * A lifecycle method that will be called when this factory is about to replaced.
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java
index 77923f2c4..1efe114f8 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.load.model;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.support.v4.util.Pools.Pool;
 import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayList;
@@ -12,72 +14,94 @@
  * Maintains an ordered put of {@link ModelLoader}s and the model and data types they handle in
  * order from highest priority to lowest.
  */
+// Hides Model throughout.
+@SuppressWarnings("TypeParameterHidesVisibleType")
 public class ModelLoaderRegistry {
 
   private final MultiModelLoaderFactory multiModelLoaderFactory;
   private final ModelLoaderCache cache = new ModelLoaderCache();
 
-  public ModelLoaderRegistry(Pool<List<Exception>> exceptionListPool) {
-    this(new MultiModelLoaderFactory(exceptionListPool));
+  public ModelLoaderRegistry(@NonNull Pool<List<Throwable>> throwableListPool) {
+    this(new MultiModelLoaderFactory(throwableListPool));
   }
 
-  // Visible for testing.
-  ModelLoaderRegistry(MultiModelLoaderFactory multiModelLoaderFactory) {
+  private ModelLoaderRegistry(@NonNull MultiModelLoaderFactory multiModelLoaderFactory) {
     this.multiModelLoaderFactory = multiModelLoaderFactory;
   }
 
-  public synchronized <Model, Data> void append(Class<Model> modelClass, Class<Data> dataClass,
-      ModelLoaderFactory<Model, Data> factory) {
+  public synchronized <Model, Data> void append(
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<? extends Model, ? extends Data> factory) {
     multiModelLoaderFactory.append(modelClass, dataClass, factory);
     cache.clear();
   }
 
-  public synchronized <Model, Data> void prepend(Class<Model> modelClass, Class<Data> dataClass,
-      ModelLoaderFactory<Model, Data> factory) {
+  public synchronized <Model, Data> void prepend(
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<? extends Model, ? extends Data> factory) {
     multiModelLoaderFactory.prepend(modelClass, dataClass, factory);
     cache.clear();
   }
 
-  public synchronized <Model, Data> void remove(Class<Model> modelClass, Class<Data> dataClass) {
+  public synchronized <Model, Data> void remove(@NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass) {
     tearDown(multiModelLoaderFactory.remove(modelClass, dataClass));
     cache.clear();
   }
 
-  public synchronized <Model, Data> void replace(Class<Model> modelClass, Class<Data> dataClass,
-      ModelLoaderFactory<Model, Data> factory) {
+  public synchronized <Model, Data> void replace(
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<? extends Model, ? extends Data> factory) {
     tearDown(multiModelLoaderFactory.replace(modelClass, dataClass, factory));
     cache.clear();
   }
 
-  private <Model, Data> void tearDown(List<ModelLoaderFactory<Model, Data>> factories) {
-    for (ModelLoaderFactory<?, ?> factory : factories) {
+  private <Model, Data> void tearDown(
+      @NonNull List<ModelLoaderFactory<? extends Model, ? extends Data>> factories) {
+    for (ModelLoaderFactory<? extends Model, ? extends Data> factory : factories) {
       factory.teardown();
     }
   }
 
-  public synchronized <A> List<ModelLoader<A, ?>> getModelLoaders(A model) {
+  // We're allocating in a loop to avoid allocating empty lists that will never have anything added
+  // to them.
+  @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")
+  @NonNull
+  public <A> List<ModelLoader<A, ?>> getModelLoaders(@NonNull A model) {
     List<ModelLoader<A, ?>> modelLoaders = getModelLoadersForClass(getClass(model));
     int size = modelLoaders.size();
-    List<ModelLoader<A, ?>> filteredLoaders = new ArrayList<>(size);
+    boolean isEmpty = true;
+    List<ModelLoader<A, ?>> filteredLoaders = Collections.emptyList();
+    //noinspection ForLoopReplaceableByForEach to improve perf
     for (int i = 0; i < size; i++) {
       ModelLoader<A, ?> loader = modelLoaders.get(i);
       if (loader.handles(model)) {
+        if (isEmpty) {
+          filteredLoaders = new ArrayList<>(size - i);
+          isEmpty = false;
+        }
         filteredLoaders.add(loader);
       }
     }
     return filteredLoaders;
   }
 
-  public synchronized <Model, Data> ModelLoader<Model, Data> build(Class<Model> modelClass,
-      Class<Data> dataClass) {
+  public synchronized <Model, Data> ModelLoader<Model, Data> build(@NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass) {
     return multiModelLoaderFactory.build(modelClass, dataClass);
   }
 
-  public synchronized List<Class<?>> getDataClasses(Class<?> modelClass) {
+  @NonNull
+  public synchronized List<Class<?>> getDataClasses(@NonNull Class<?> modelClass) {
     return multiModelLoaderFactory.getDataClasses(modelClass);
   }
 
-  private <A> List<ModelLoader<A, ?>> getModelLoadersForClass(Class<A> modelClass) {
+  @NonNull
+  private synchronized <A> List<ModelLoader<A, ?>> getModelLoadersForClass(
+      @NonNull Class<A> modelClass) {
     List<ModelLoader<A, ?>> loaders = cache.get(modelClass);
     if (loaders == null) {
       loaders = Collections.unmodifiableList(multiModelLoaderFactory.build(modelClass));
@@ -86,8 +110,9 @@ public ModelLoaderRegistry(Pool<List<Exception>> exceptionListPool) {
     return loaders;
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
-  private static <A> Class<A> getClass(A model) {
+  private static <A> Class<A> getClass(@NonNull A model) {
     return (Class<A>) model.getClass();
   }
 
@@ -108,6 +133,7 @@ public void clear() {
       }
     }
 
+    @Nullable
     @SuppressWarnings("unchecked")
     public <Model> List<ModelLoader<Model, ?>> get(Class<Model> modelClass) {
       Entry<Model> entry = (Entry<Model>) cachedModelLoaders.get(modelClass);
diff --git a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java
index d18d12e46..bbe616a76 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java
@@ -27,20 +27,21 @@
 class MultiModelLoader<Model, Data> implements ModelLoader<Model, Data> {
 
   private final List<ModelLoader<Model, Data>> modelLoaders;
-  private final Pool<List<Exception>> exceptionListPool;
+  private final Pool<List<Throwable>> exceptionListPool;
 
-  MultiModelLoader(List<ModelLoader<Model, Data>> modelLoaders,
-      Pool<List<Exception>> exceptionListPool) {
+  MultiModelLoader(@NonNull List<ModelLoader<Model, Data>> modelLoaders,
+      @NonNull Pool<List<Throwable>> exceptionListPool) {
     this.modelLoaders = modelLoaders;
     this.exceptionListPool = exceptionListPool;
   }
 
   @Override
-  public LoadData<Data> buildLoadData(Model model, int width, int height,
-      Options options) {
+  public LoadData<Data> buildLoadData(@NonNull Model model, int width, int height,
+      @NonNull Options options) {
     Key sourceKey = null;
     int size = modelLoaders.size();
     List<DataFetcher<Data>> fetchers = new ArrayList<>(size);
+    //noinspection ForLoopReplaceableByForEach to improve perf
     for (int i = 0; i < size; i++) {
       ModelLoader<Model, Data> modelLoader = modelLoaders.get(i);
       if (modelLoader.handles(model)) {
@@ -51,12 +52,12 @@
         }
       }
     }
-    return !fetchers.isEmpty()
+    return !fetchers.isEmpty() && sourceKey != null
         ? new LoadData<>(sourceKey, new MultiFetcher<>(fetchers, exceptionListPool)) : null;
   }
 
   @Override
-  public boolean handles(Model model) {
+  public boolean handles(@NonNull Model model) {
     for (ModelLoader<Model, Data> modelLoader : modelLoaders) {
       if (modelLoader.handles(model)) {
         return true;
@@ -67,39 +68,41 @@ public boolean handles(Model model) {
 
   @Override
   public String toString() {
-    return "MultiModelLoader{" + "modelLoaders=" + Arrays
-        .toString(modelLoaders.toArray(new ModelLoader[modelLoaders.size()])) + '}';
+    return "MultiModelLoader{" + "modelLoaders=" + Arrays.toString(modelLoaders.toArray()) + '}';
   }
 
   static class MultiFetcher<Data> implements DataFetcher<Data>, DataCallback<Data> {
 
     private final List<DataFetcher<Data>> fetchers;
-    private final Pool<List<Exception>> exceptionListPool;
+    private final Pool<List<Throwable>> throwableListPool;
     private int currentIndex;
     private Priority priority;
     private DataCallback<? super Data> callback;
     @Nullable
-    private List<Exception> exceptions;
+    private List<Throwable> exceptions;
 
-    MultiFetcher(List<DataFetcher<Data>> fetchers, Pool<List<Exception>> exceptionListPool) {
-      this.exceptionListPool = exceptionListPool;
+    MultiFetcher(
+        @NonNull List<DataFetcher<Data>> fetchers,
+        @NonNull Pool<List<Throwable>> throwableListPool) {
+      this.throwableListPool = throwableListPool;
       Preconditions.checkNotEmpty(fetchers);
       this.fetchers = fetchers;
       currentIndex = 0;
     }
 
     @Override
-    public void loadData(Priority priority, DataCallback<? super Data> callback) {
+    public void loadData(
+        @NonNull Priority priority, @NonNull DataCallback<? super Data> callback) {
       this.priority = priority;
       this.callback = callback;
-      exceptions = exceptionListPool.acquire();
+      exceptions = throwableListPool.acquire();
       fetchers.get(currentIndex).loadData(priority, this);
     }
 
     @Override
     public void cleanup() {
       if (exceptions != null) {
-        exceptionListPool.release(exceptions);
+        throwableListPool.release(exceptions);
       }
       exceptions = null;
       for (DataFetcher<Data> fetcher : fetchers) {
@@ -127,7 +130,7 @@ public DataSource getDataSource() {
     }
 
     @Override
-    public void onDataReady(Data data) {
+    public void onDataReady(@Nullable Data data) {
       if (data != null) {
         callback.onDataReady(data);
       } else {
@@ -136,8 +139,8 @@ public void onDataReady(Data data) {
     }
 
     @Override
-    public void onLoadFailed(Exception e) {
-      exceptions.add(e);
+    public void onLoadFailed(@NonNull Exception e) {
+      Preconditions.checkNotNull(exceptions).add(e);
       startNextOrFail();
     }
 
@@ -146,6 +149,7 @@ private void startNextOrFail() {
         currentIndex++;
         loadData(priority, callback);
       } else {
+        Preconditions.checkNotNull(exceptions);
         callback.onLoadFailed(new GlideException("Fetch failed", new ArrayList<>(exceptions)));
       }
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java
index 4c63136a5..a286bc09d 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java
@@ -1,6 +1,8 @@
 package com.bumptech.glide.load.model;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 import android.support.v4.util.Pools.Pool;
 import com.bumptech.glide.Registry.NoModelLoaderAvailableException;
 import com.bumptech.glide.load.Options;
@@ -16,51 +18,66 @@
  * Capable of building an {@link ModelLoader} that wraps one or more other {@link ModelLoader}s for
  * a given model and data class.
  */
+// Hides Model throughout.
+@SuppressWarnings("TypeParameterHidesVisibleType")
 public class MultiModelLoaderFactory {
   private static final Factory DEFAULT_FACTORY = new Factory();
   private static final ModelLoader<Object, Object> EMPTY_MODEL_LOADER = new EmptyModelLoader();
   private final List<Entry<?, ?>> entries = new ArrayList<>();
   private final Factory factory;
   private final Set<Entry<?, ?>> alreadyUsedEntries = new HashSet<>();
-  private final Pool<List<Exception>> exceptionListPool;
+  private final Pool<List<Throwable>> throwableListPool;
 
-  public MultiModelLoaderFactory(Pool<List<Exception>> exceptionListPool) {
-    this(exceptionListPool, DEFAULT_FACTORY);
+  public MultiModelLoaderFactory(@NonNull Pool<List<Throwable>> throwableListPool) {
+    this(throwableListPool, DEFAULT_FACTORY);
   }
 
-  // Visible for testing.
-  MultiModelLoaderFactory(Pool<List<Exception>> exceptionListPool,
-      Factory factory) {
-    this.exceptionListPool = exceptionListPool;
+  @VisibleForTesting
+  MultiModelLoaderFactory(@NonNull Pool<List<Throwable>> throwableListPool,
+      @NonNull Factory factory) {
+    this.throwableListPool = throwableListPool;
     this.factory = factory;
   }
 
-  synchronized <Model, Data> void append(Class<Model> modelClass, Class<Data> dataClass,
-      ModelLoaderFactory<Model, Data> factory) {
-    add(modelClass, dataClass, factory, true /*append*/);
+  synchronized <Model, Data> void append(
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<? extends Model, ? extends Data> factory) {
+    add(modelClass, dataClass, factory, /*append=*/ true);
   }
 
-  synchronized <Model, Data> void prepend(Class<Model> modelClass, Class<Data> dataClass,
-      ModelLoaderFactory<Model, Data> factory) {
-    add(modelClass, dataClass, factory, false /*append*/);
+  synchronized <Model, Data> void prepend(
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<? extends Model, ? extends Data> factory) {
+    add(modelClass, dataClass, factory, /*append=*/ false);
   }
 
-  private <Model, Data> void add(Class<Model> modelClass, Class<Data> dataClass,
-      ModelLoaderFactory<Model, Data> factory, boolean append) {
+  private <Model, Data> void add(
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<? extends Model, ? extends Data> factory,
+      boolean append) {
     Entry<Model, Data> entry = new Entry<>(modelClass, dataClass, factory);
     entries.add(append ? entries.size() : 0, entry);
   }
 
-  synchronized <Model, Data> List<ModelLoaderFactory<Model, Data>> replace(Class<Model> modelClass,
-      Class<Data> dataClass, ModelLoaderFactory<Model, Data> factory) {
-    List<ModelLoaderFactory<Model, Data>> removed = remove(modelClass, dataClass);
+  @NonNull
+  synchronized <Model, Data> List<ModelLoaderFactory<? extends Model, ? extends Data>> replace(
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<? extends Model, ? extends Data> factory) {
+    List<ModelLoaderFactory<? extends Model, ? extends Data>> removed =
+        remove(modelClass, dataClass);
     append(modelClass, dataClass, factory);
     return removed;
   }
 
-  synchronized <Model, Data> List<ModelLoaderFactory<Model, Data>> remove(Class<Model> modelClass,
-      Class<Data> dataClass) {
-    List<ModelLoaderFactory<Model, Data>> factories = new ArrayList<>();
+  @NonNull
+  synchronized <Model, Data> List<ModelLoaderFactory<? extends Model, ? extends Data>> remove(
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass) {
+    List<ModelLoaderFactory<? extends Model, ? extends Data>> factories = new ArrayList<>();
     for (Iterator<Entry<?, ?>> iterator = entries.iterator(); iterator.hasNext(); ) {
       Entry<?, ?> entry = iterator.next();
       if (entry.handles(modelClass, dataClass)) {
@@ -71,7 +88,8 @@ public MultiModelLoaderFactory(Pool<List<Exception>> exceptionListPool) {
     return factories;
   }
 
-  synchronized <Model> List<ModelLoader<Model, ?>> build(Class<Model> modelClass) {
+  @NonNull
+  synchronized <Model> List<ModelLoader<Model, ?>> build(@NonNull Class<Model> modelClass) {
     try {
       List<ModelLoader<Model, ?>> loaders = new ArrayList<>();
       for (Entry<?, ?> entry : entries) {
@@ -96,7 +114,8 @@ public MultiModelLoaderFactory(Pool<List<Exception>> exceptionListPool) {
     }
   }
 
-  synchronized List<Class<?>> getDataClasses(Class<?> modelClass) {
+  @NonNull
+  synchronized List<Class<?>> getDataClasses(@NonNull Class<?> modelClass) {
     List<Class<?>> result = new ArrayList<>();
     for (Entry<?, ?> entry : entries) {
       if (!result.contains(entry.dataClass) && entry.handles(modelClass)) {
@@ -106,8 +125,9 @@ public MultiModelLoaderFactory(Pool<List<Exception>> exceptionListPool) {
     return result;
   }
 
-  public synchronized <Model, Data> ModelLoader<Model, Data> build(Class<Model> modelClass,
-      Class<Data> dataClass) {
+  @NonNull
+  public synchronized <Model, Data> ModelLoader<Model, Data> build(@NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass) {
     try {
       List<ModelLoader<Model, Data>> loaders = new ArrayList<>();
       boolean ignoredAnyEntries = false;
@@ -128,7 +148,7 @@ public MultiModelLoaderFactory(Pool<List<Exception>> exceptionListPool) {
         }
       }
       if (loaders.size() > 1) {
-        return factory.build(loaders, exceptionListPool);
+        return factory.build(loaders, throwableListPool);
       } else if (loaders.size() == 1) {
         return loaders.get(0);
       } else {
@@ -147,16 +167,19 @@ public MultiModelLoaderFactory(Pool<List<Exception>> exceptionListPool) {
     }
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
-  private <Model, Data> ModelLoaderFactory<Model, Data> getFactory(Entry<?, ?> entry) {
+  private <Model, Data> ModelLoaderFactory<Model, Data> getFactory(@NonNull Entry<?, ?> entry) {
     return (ModelLoaderFactory<Model, Data>) entry.factory;
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
-  private <Model, Data> ModelLoader<Model, Data> build(Entry<?, ?> entry) {
+  private <Model, Data> ModelLoader<Model, Data> build(@NonNull Entry<?, ?> entry) {
     return (ModelLoader<Model, Data>) Preconditions.checkNotNull(entry.factory.build(this));
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
   private static <Model, Data> ModelLoader<Model, Data> emptyModelLoader() {
     return (ModelLoader<Model, Data>) EMPTY_MODEL_LOADER;
@@ -165,44 +188,48 @@ public MultiModelLoaderFactory(Pool<List<Exception>> exceptionListPool) {
   private static class Entry<Model, Data> {
     private final Class<Model> modelClass;
     @Synthetic final Class<Data> dataClass;
-    @Synthetic final ModelLoaderFactory<Model, Data> factory;
+    @Synthetic final ModelLoaderFactory<? extends Model, ? extends Data> factory;
 
-    public Entry(Class<Model> modelClass, Class<Data> dataClass,
-        ModelLoaderFactory<Model, Data> factory) {
+    public Entry(
+        @NonNull Class<Model> modelClass,
+        @NonNull Class<Data> dataClass,
+        @NonNull ModelLoaderFactory<? extends Model, ? extends Data> factory) {
       this.modelClass = modelClass;
       this.dataClass = dataClass;
       this.factory = factory;
     }
 
-    public boolean handles(Class<?> modelClass, Class<?> dataClass) {
+    public boolean handles(@NonNull Class<?> modelClass, @NonNull Class<?> dataClass) {
       return handles(modelClass) && this.dataClass.isAssignableFrom(dataClass);
     }
 
-    public boolean handles(Class<?> modelClass) {
+    public boolean handles(@NonNull Class<?> modelClass) {
       return this.modelClass.isAssignableFrom(modelClass);
     }
   }
 
   static class Factory {
+    @NonNull
     public <Model, Data> MultiModelLoader<Model, Data> build(
-        List<ModelLoader<Model, Data>> modelLoaders, Pool<List<Exception>> exceptionListPool) {
-      return new MultiModelLoader<>(modelLoaders, exceptionListPool);
+        @NonNull List<ModelLoader<Model, Data>> modelLoaders,
+        @NonNull Pool<List<Throwable>> throwableListPool) {
+      return new MultiModelLoader<>(modelLoaders, throwableListPool);
     }
   }
 
   private static class EmptyModelLoader implements ModelLoader<Object, Object> {
-
     @Synthetic
     EmptyModelLoader() { }
 
     @Nullable
     @Override
-    public LoadData<Object> buildLoadData(Object o, int width, int height, Options options) {
+    public LoadData<Object> buildLoadData(@NonNull Object o, int width, int height,
+        @NonNull Options options) {
       return null;
     }
 
     @Override
-    public boolean handles(Object o) {
+    public boolean handles(@NonNull Object o) {
       return false;
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
index 24fc4b6ef..1abc1fab4 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
@@ -1,9 +1,11 @@
 package com.bumptech.glide.load.model;
 
 import android.content.ContentResolver;
+import android.content.res.AssetFileDescriptor;
 import android.content.res.Resources;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.util.Log;
 import com.bumptech.glide.load.Options;
@@ -20,14 +22,16 @@
   private final ModelLoader<Uri, Data> uriLoader;
   private final Resources resources;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public ResourceLoader(Resources resources, ModelLoader<Uri, Data> uriLoader) {
     this.resources = resources;
     this.uriLoader = uriLoader;
   }
 
   @Override
-  public LoadData<Data> buildLoadData(Integer model, int width, int height, Options options) {
-
+  public LoadData<Data> buildLoadData(@NonNull Integer model, int width, int height,
+      @NonNull Options options) {
     Uri uri = getResourceUri(model);
     return uri == null ? null : uriLoader.buildLoadData(uri, width, height, options);
   }
@@ -48,7 +52,7 @@ private Uri getResourceUri(Integer model) {
   }
 
   @Override
-  public boolean handles(Integer model) {
+  public boolean handles(@NonNull Integer model) {
     // TODO: check that this is in fact a resource id.
     return true;
   }
@@ -64,6 +68,7 @@ public StreamFactory(Resources resources) {
       this.resources = resources;
     }
 
+    @NonNull
     @Override
     public ModelLoader<Integer, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new ResourceLoader<>(resources, multiFactory.build(Uri.class, InputStream.class));
@@ -87,6 +92,7 @@ public FileDescriptorFactory(Resources resources) {
       this.resources = resources;
     }
 
+    @NonNull
     @Override
     public ModelLoader<Integer, ParcelFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
       return new ResourceLoader<>(
@@ -98,4 +104,51 @@ public void teardown() {
       // Do nothing.
     }
   }
+
+  /**
+   * Loads {@link AssetFileDescriptor}s from resource ids.
+   */
+  public static final class AssetFileDescriptorFactory
+      implements ModelLoaderFactory<Integer, AssetFileDescriptor> {
+
+    private final Resources resources;
+
+    public AssetFileDescriptorFactory(Resources resources) {
+      this.resources = resources;
+    }
+
+    @Override
+    public ModelLoader<Integer, AssetFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
+      return new ResourceLoader<>(
+          resources, multiFactory.build(Uri.class, AssetFileDescriptor.class));
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+  }
+
+  /**
+   * Factory for loading resource {@link Uri}s from Android resource ids.
+   */
+  public static class UriFactory implements ModelLoaderFactory<Integer, Uri> {
+
+    private final Resources resources;
+
+    public UriFactory(Resources resources) {
+      this.resources = resources;
+    }
+
+    @NonNull
+    @Override
+    public ModelLoader<Integer, Uri> build(MultiModelLoaderFactory multiFactory) {
+      return new ResourceLoader<>(resources, UnitModelLoader.<Uri>getInstance());
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java
index 28a06ca9e..9fa8a0ec7 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.model;
 
+import android.support.annotation.NonNull;
 import android.util.Log;
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.Options;
@@ -23,7 +24,7 @@ public StreamEncoder(ArrayPool byteArrayPool) {
   }
 
   @Override
-  public boolean encode(InputStream data, File file, Options options) {
+  public boolean encode(@NonNull InputStream data, @NonNull File file, @NonNull Options options) {
     byte[] buffer = byteArrayPool.get(ArrayPool.STANDARD_BUFFER_SIZE_BYTES, byte[].class);
     boolean success = false;
     OutputStream os = null;
@@ -47,7 +48,7 @@ public boolean encode(InputStream data, File file, Options options) {
           // Do nothing.
         }
       }
-      byteArrayPool.put(buffer, byte[].class);
+      byteArrayPool.put(buffer);
     }
     return success;
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java b/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
index 62061cf16..c00fac18e 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
@@ -1,7 +1,9 @@
 package com.bumptech.glide.load.model;
 
+import android.content.res.AssetFileDescriptor;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.text.TextUtils;
 import com.bumptech.glide.load.Options;
@@ -17,19 +19,26 @@
 public class StringLoader<Data> implements ModelLoader<String, Data> {
   private final ModelLoader<Uri, Data> uriLoader;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public StringLoader(ModelLoader<Uri, Data> uriLoader) {
     this.uriLoader = uriLoader;
   }
 
   @Override
-  public LoadData<Data> buildLoadData(String model, int width, int height,
-      Options options) {
+  public LoadData<Data> buildLoadData(@NonNull String model, int width, int height,
+      @NonNull Options options) {
     Uri uri = parseUri(model);
-    return uri == null ? null : uriLoader.buildLoadData(uri, width, height, options);
+    if (uri == null || !uriLoader.handles(uri)) {
+      return null;
+    }
+    return uriLoader.buildLoadData(uri, width, height, options);
   }
 
   @Override
-  public boolean handles(String model) {
+  public boolean handles(@NonNull String model) {
+    // Avoid parsing the Uri twice and simply return null from buildLoadData if we don't handle this
+    // particular Uri type.
     return true;
   }
 
@@ -38,7 +47,8 @@ private static Uri parseUri(String model) {
     Uri uri;
     if (TextUtils.isEmpty(model)) {
       return null;
-    } else if (model.startsWith("/")) {
+    // See https://pmd.github.io/pmd-6.0.0/pmd_rules_java_performance.html#simplifystartswith
+    } else if (model.charAt(0) == '/') {
       uri = toFileUri(model);
     } else {
       uri = Uri.parse(model);
@@ -59,8 +69,10 @@ private static Uri toFileUri(String path) {
    */
   public static class StreamFactory implements ModelLoaderFactory<String, InputStream> {
 
+    @NonNull
     @Override
-    public ModelLoader<String, InputStream> build(MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<String, InputStream> build(
+        @NonNull MultiModelLoaderFactory multiFactory) {
       return new StringLoader<>(multiFactory.build(Uri.class, InputStream.class));
     }
 
@@ -76,8 +88,10 @@ public void teardown() {
   public static class FileDescriptorFactory
       implements ModelLoaderFactory<String, ParcelFileDescriptor> {
 
+    @NonNull
     @Override
-    public ModelLoader<String, ParcelFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<String, ParcelFileDescriptor> build(
+        @NonNull MultiModelLoaderFactory multiFactory) {
       return new StringLoader<>(multiFactory.build(Uri.class, ParcelFileDescriptor.class));
     }
 
@@ -86,4 +100,22 @@ public void teardown() {
       // Do nothing.
     }
   }
+
+  /**
+   * Loads {@link AssetFileDescriptor}s from Strings.
+   */
+  public static final class AssetFileDescriptorFactory
+      implements ModelLoaderFactory<String, AssetFileDescriptor> {
+
+    @Override
+    public ModelLoader<String, AssetFileDescriptor> build(
+        @NonNull MultiModelLoaderFactory multiFactory) {
+      return new StringLoader<>(multiFactory.build(Uri.class, AssetFileDescriptor.class));
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
index a2b346c6f..670e86986 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.model;
 
 import android.support.annotation.NonNull;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Options;
@@ -15,15 +14,32 @@
  * @param <Model> The type of model that will also be returned as decodable data.
  */
 public class UnitModelLoader<Model> implements ModelLoader<Model, Model> {
+  @SuppressWarnings("deprecation")
+  private static final UnitModelLoader<?> INSTANCE = new UnitModelLoader<>();
+
+  @SuppressWarnings("unchecked")
+  public static <T> UnitModelLoader<T> getInstance() {
+    return (UnitModelLoader<T>) INSTANCE;
+  }
+
+  /**
+   * @deprecated Use {@link #getInstance()} instead.
+   */
+  // Need constructor to document deprecation, will be removed, when constructor is privatized.
+  @SuppressWarnings({"PMD.UnnecessaryConstructor", "DeprecatedIsStillUsed"})
+  @Deprecated
+  public UnitModelLoader() {
+    // Intentionally empty.
+  }
 
   @Override
-  public LoadData<Model> buildLoadData(Model model, int width, int height,
-      Options options) {
+  public LoadData<Model> buildLoadData(@NonNull Model model, int width, int height,
+      @NonNull Options options) {
     return new LoadData<>(new ObjectKey(model), new UnitFetcher<>(model));
   }
 
   @Override
-  public boolean handles(Model model) {
+  public boolean handles(@NonNull Model model) {
     return true;
   }
 
@@ -31,12 +47,13 @@ public boolean handles(Model model) {
 
     private final Model resource;
 
-    public UnitFetcher(Model resource) {
+    UnitFetcher(Model resource) {
       this.resource = resource;
     }
 
     @Override
-    public void loadData(Priority priority, DataCallback<? super Model> callback) {
+    public void loadData(@NonNull Priority priority,
+        @NonNull DataCallback<? super Model> callback) {
       callback.onDataReady(resource);
     }
 
@@ -69,11 +86,29 @@ public DataSource getDataSource() {
    *
    * @param <Model> The type of model that will also be returned as decodable data.
    */
+  // PMD.SingleMethodSingleton false positive: https://github.com/pmd/pmd/issues/816
+  @SuppressWarnings("PMD.SingleMethodSingleton")
   public static class Factory<Model> implements ModelLoaderFactory<Model, Model> {
+    @SuppressWarnings("deprecation")
+    private static final Factory<?> FACTORY = new Factory<>();
 
+    @SuppressWarnings("unchecked")
+    public static <T> Factory<T> getInstance() {
+      return (Factory<T>) FACTORY;
+    }
+
+    /** @deprecated Use {@link #getInstance()} instead. */
+    // Need constructor to document deprecation, will be removed, when constructor is privatized.
+    @SuppressWarnings("PMD.UnnecessaryConstructor")
+    @Deprecated
+    public Factory() {
+      // Intentionally empty.
+    }
+
+    @NonNull
     @Override
     public ModelLoader<Model, Model> build(MultiModelLoaderFactory multiFactory) {
-      return new UnitModelLoader<>();
+      return UnitModelLoader.getInstance();
     }
 
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java
index 26cc3be5f..77a316dd4 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java
@@ -1,9 +1,12 @@
 package com.bumptech.glide.load.model;
 
 import android.content.ContentResolver;
+import android.content.res.AssetFileDescriptor;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.AssetFileDescriptorLocalUriFetcher;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.FileDescriptorLocalUriFetcher;
 import com.bumptech.glide.load.data.StreamLocalUriFetcher;
@@ -35,18 +38,20 @@
 
   private final LocalUriFetcherFactory<Data> factory;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public UriLoader(LocalUriFetcherFactory<Data> factory) {
     this.factory = factory;
   }
 
   @Override
-  public LoadData<Data> buildLoadData(Uri model, int width, int height,
-      Options options) {
+  public LoadData<Data> buildLoadData(@NonNull Uri model, int width, int height,
+      @NonNull Options options) {
     return new LoadData<>(new ObjectKey(model), factory.build(model));
   }
 
   @Override
-  public boolean handles(Uri model) {
+  public boolean handles(@NonNull Uri model) {
     return SCHEMES.contains(model.getScheme());
   }
 
@@ -76,6 +81,7 @@ public StreamFactory(ContentResolver contentResolver) {
       return new StreamLocalUriFetcher(contentResolver, uri);
     }
 
+    @NonNull
     @Override
     public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new UriLoader<>(this);
@@ -90,8 +96,8 @@ public void teardown() {
   /**
    * Loads {@link ParcelFileDescriptor}s from {@link Uri}s.
    */
-  public static class FileDescriptorFactory implements ModelLoaderFactory<Uri,
-      ParcelFileDescriptor>,
+  public static class FileDescriptorFactory
+      implements ModelLoaderFactory<Uri, ParcelFileDescriptor>,
       LocalUriFetcherFactory<ParcelFileDescriptor> {
 
     private final ContentResolver contentResolver;
@@ -105,6 +111,7 @@ public FileDescriptorFactory(ContentResolver contentResolver) {
       return new FileDescriptorLocalUriFetcher(contentResolver, uri);
     }
 
+    @NonNull
     @Override
     public ModelLoader<Uri, ParcelFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
       return new UriLoader<>(this);
@@ -115,4 +122,33 @@ public void teardown() {
       // Do nothing.
     }
   }
+
+  /**
+   * Loads {@link AssetFileDescriptor}s from {@link Uri}s.
+   */
+  public static final class AssetFileDescriptorFactory
+      implements ModelLoaderFactory<Uri, AssetFileDescriptor>,
+      LocalUriFetcherFactory<AssetFileDescriptor> {
+
+    private final ContentResolver contentResolver;
+
+    public AssetFileDescriptorFactory(ContentResolver contentResolver) {
+      this.contentResolver = contentResolver;
+    }
+
+    @Override
+    public ModelLoader<Uri, AssetFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
+      return new UriLoader<>(this);
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+
+    @Override
+    public DataFetcher<AssetFileDescriptor> build(Uri uri) {
+      return new AssetFileDescriptorLocalUriFetcher(contentResolver, uri);
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java
index af2f2459a..f51b8698f 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.model;
 
 import android.net.Uri;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import java.io.InputStream;
 import java.util.Arrays;
@@ -25,18 +26,21 @@
   );
   private final ModelLoader<GlideUrl, Data> urlLoader;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public UrlUriLoader(ModelLoader<GlideUrl, Data> urlLoader) {
     this.urlLoader = urlLoader;
   }
 
   @Override
-  public LoadData<Data> buildLoadData(Uri uri, int width, int height, Options options) {
+  public LoadData<Data> buildLoadData(@NonNull Uri uri, int width, int height,
+      @NonNull Options options) {
     GlideUrl glideUrl = new GlideUrl(uri.toString());
     return urlLoader.buildLoadData(glideUrl, width, height, options);
   }
 
   @Override
-  public boolean handles(Uri uri) {
+  public boolean handles(@NonNull Uri uri) {
     return SCHEMES.contains(uri.getScheme());
   }
 
@@ -46,6 +50,7 @@ public boolean handles(Uri uri) {
    */
   public static class StreamFactory implements ModelLoaderFactory<Uri, InputStream> {
 
+    @NonNull
     @Override
     public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new UrlUriLoader<>(multiFactory.build(GlideUrl.class, InputStream.class));
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java
index d2944e47e..20c765776 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.model.stream;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.text.TextUtils;
 import com.bumptech.glide.load.Key;
@@ -10,6 +11,7 @@
 import com.bumptech.glide.load.model.ModelLoader;
 import java.io.InputStream;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
 
@@ -35,7 +37,8 @@ protected BaseGlideUrlLoader(ModelLoader<GlideUrl, InputStream> concreteLoader,
 
   @Override
   @Nullable
-  public LoadData<InputStream> buildLoadData(Model model, int width, int height, Options options) {
+  public LoadData<InputStream> buildLoadData(@NonNull Model model, int width, int height,
+      @NonNull Options options) {
     GlideUrl result = null;
     if (modelCache != null) {
       result = modelCache.get(model, width, height);
@@ -59,7 +62,7 @@ protected BaseGlideUrlLoader(ModelLoader<GlideUrl, InputStream> concreteLoader,
     List<String> alternateUrls = getAlternateUrls(model, width, height, options);
     LoadData<InputStream> concreteLoaderData = concreteLoader.buildLoadData(result, width, height,
         options);
-    if (alternateUrls.isEmpty()) {
+    if (concreteLoaderData == null || alternateUrls.isEmpty()) {
       return concreteLoaderData;
     } else {
       return new LoadData<>(concreteLoaderData.sourceKey, getAlternateKeys(alternateUrls),
@@ -67,7 +70,9 @@ protected BaseGlideUrlLoader(ModelLoader<GlideUrl, InputStream> concreteLoader,
     }
   }
 
-  private static List<Key> getAlternateKeys(List<String> alternateUrls) {
+  // Creating a limited number of objects as the sole purpose of the loop.
+  @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")
+  private static List<Key> getAlternateKeys(Collection<String> alternateUrls) {
     List<Key> result = new ArrayList<>(alternateUrls.size());
     for (String alternate : alternateUrls) {
       result.add(new GlideUrl(alternate));
@@ -108,6 +113,8 @@ protected BaseGlideUrlLoader(ModelLoader<GlideUrl, InputStream> concreteLoader,
    * @param width The width in pixels of the view/target the image will be loaded into.
    * @param height The height in pixels of the view/target the image will be loaded into.
    */
+  // Public API.
+  @SuppressWarnings({"unused", "WeakerAccess"})
   @Nullable
   protected Headers getHeaders(Model model, int width, int height, Options options) {
     return Headers.DEFAULT;
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java
index d29625946..e149e1916 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.model.stream;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
@@ -15,6 +16,8 @@
  * An {@link com.bumptech.glide.load.model.ModelLoader} for translating {@link
  * com.bumptech.glide.load.model.GlideUrl} (http/https URLS) into {@link java.io.InputStream} data.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public class HttpGlideUrlLoader implements ModelLoader<GlideUrl, InputStream> {
   /**
    * An integer option that is used to determine the maximum connect and read timeout durations (in
@@ -31,13 +34,13 @@ public HttpGlideUrlLoader() {
     this(null);
   }
 
-  public HttpGlideUrlLoader(ModelCache<GlideUrl, GlideUrl> modelCache) {
+  public HttpGlideUrlLoader(@Nullable ModelCache<GlideUrl, GlideUrl> modelCache) {
     this.modelCache = modelCache;
   }
 
   @Override
-  public LoadData<InputStream> buildLoadData(GlideUrl model, int width, int height,
-      Options options) {
+  public LoadData<InputStream> buildLoadData(@NonNull GlideUrl model, int width, int height,
+      @NonNull Options options) {
     // GlideUrls memoize parsed URLs so caching them saves a few object instantiations and time
     // spent parsing urls.
     GlideUrl url = model;
@@ -53,7 +56,7 @@ public HttpGlideUrlLoader(ModelCache<GlideUrl, GlideUrl> modelCache) {
   }
 
   @Override
-  public boolean handles(GlideUrl model) {
+  public boolean handles(@NonNull GlideUrl model) {
     return true;
   }
 
@@ -63,6 +66,7 @@ public boolean handles(GlideUrl model) {
   public static class Factory implements ModelLoaderFactory<GlideUrl, InputStream> {
     private final ModelCache<GlideUrl, GlideUrl> modelCache = new ModelCache<>(500);
 
+    @NonNull
     @Override
     public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new HttpGlideUrlLoader(modelCache);
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java
index 37b1e12fa..7ff6639b2 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.model.stream;
 
 import android.net.Uri;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
@@ -21,17 +22,20 @@
 
   private final ModelLoader<GlideUrl, InputStream> urlLoader;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public HttpUriLoader(ModelLoader<GlideUrl, InputStream> urlLoader) {
     this.urlLoader = urlLoader;
   }
 
   @Override
-  public LoadData<InputStream> buildLoadData(Uri model, int width, int height, Options options) {
+  public LoadData<InputStream> buildLoadData(@NonNull Uri model, int width, int height,
+      @NonNull Options options) {
     return urlLoader.buildLoadData(new GlideUrl(model.toString()), width, height, options);
   }
 
   @Override
-  public boolean handles(Uri model) {
+  public boolean handles(@NonNull Uri model) {
     return SCHEMES.contains(model.getScheme());
   }
 
@@ -40,6 +44,7 @@ public boolean handles(Uri model) {
    */
   public static class Factory implements ModelLoaderFactory<Uri, InputStream> {
 
+    @NonNull
     @Override
     public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new HttpUriLoader(multiFactory.build(GlideUrl.class, InputStream.class));
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java
index c10cfc90a..aba0fe3cf 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java
@@ -2,6 +2,7 @@
 
 import android.content.Context;
 import android.net.Uri;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.mediastore.MediaStoreUtil;
 import com.bumptech.glide.load.data.mediastore.ThumbFetcher;
@@ -16,14 +17,17 @@
  * thumbnails for those {@link Uri}s in the media store.
  */
 public class MediaStoreImageThumbLoader implements ModelLoader<Uri, InputStream> {
-  public final Context context;
+  private final Context context;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public MediaStoreImageThumbLoader(Context context) {
     this.context = context.getApplicationContext();
   }
 
   @Override
-  public LoadData<InputStream> buildLoadData(Uri model, int width, int height, Options options) {
+  public LoadData<InputStream> buildLoadData(@NonNull Uri model, int width, int height,
+      @NonNull Options options) {
     if (MediaStoreUtil.isThumbnailSize(width, height)) {
       return new LoadData<>(new ObjectKey(model), ThumbFetcher.buildImageFetcher(context, model));
     } else {
@@ -32,7 +36,7 @@ public MediaStoreImageThumbLoader(Context context) {
   }
 
   @Override
-  public boolean handles(Uri model) {
+  public boolean handles(@NonNull Uri model) {
     return MediaStoreUtil.isMediaStoreImageUri(model);
   }
 
@@ -47,6 +51,7 @@ public Factory(Context context) {
       this.context = context;
     }
 
+    @NonNull
     @Override
     public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new MediaStoreImageThumbLoader(context);
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java
index 2263f1cc5..0685decb1 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java
@@ -2,6 +2,7 @@
 
 import android.content.Context;
 import android.net.Uri;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.mediastore.MediaStoreUtil;
@@ -9,7 +10,7 @@
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoaderFactory;
 import com.bumptech.glide.load.model.MultiModelLoaderFactory;
-import com.bumptech.glide.load.resource.bitmap.VideoBitmapDecoder;
+import com.bumptech.glide.load.resource.bitmap.VideoDecoder;
 import com.bumptech.glide.signature.ObjectKey;
 import java.io.InputStream;
 
@@ -17,23 +18,25 @@
  * Loads {@link InputStream}s from media store video {@link Uri}s that point to pre-generated
  * thumbnails for those {@link Uri}s in the media store.
  *
- * <p>If {@link VideoBitmapDecoder#TARGET_FRAME} is set with a non-null value that is not equal to
- * {@link VideoBitmapDecoder#DEFAULT_FRAME}, this loader will always return {@code null}. The media
+ * <p>If {@link VideoDecoder#TARGET_FRAME} is set with a non-null value that is not equal to
+ * {@link VideoDecoder#DEFAULT_FRAME}, this loader will always return {@code null}. The media
  * store does not use a defined frame to generate the thumbnail, so we cannot accurately fulfill
  * requests for specific frames.
  */
 public class MediaStoreVideoThumbLoader implements ModelLoader<Uri, InputStream> {
   private final Context context;
 
-  MediaStoreVideoThumbLoader(Context context) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public MediaStoreVideoThumbLoader(Context context) {
     this.context = context.getApplicationContext();
   }
 
   @Override
   @Nullable
-  public LoadData<InputStream> buildLoadData(Uri model, int width, int height, Options options) {
+  public LoadData<InputStream> buildLoadData(@NonNull Uri model, int width, int height,
+      @NonNull Options options) {
     if (MediaStoreUtil.isThumbnailSize(width, height) && isRequestingDefaultFrame(options)) {
-      // TODO(nnaze): Tighten down this call to just the dependencies neede by buildVideoFetcher
       return new LoadData<>(new ObjectKey(model), ThumbFetcher.buildVideoFetcher(context, model));
     } else {
       return null;
@@ -41,12 +44,12 @@
   }
 
   private boolean isRequestingDefaultFrame(Options options) {
-    Long specifiedFrame = options.get(VideoBitmapDecoder.TARGET_FRAME);
-    return specifiedFrame != null && specifiedFrame == VideoBitmapDecoder.DEFAULT_FRAME;
+    Long specifiedFrame = options.get(VideoDecoder.TARGET_FRAME);
+    return specifiedFrame != null && specifiedFrame == VideoDecoder.DEFAULT_FRAME;
   }
 
   @Override
-  public boolean handles(Uri model) {
+  public boolean handles(@NonNull Uri model) {
     return MediaStoreUtil.isMediaStoreVideoUri(model);
   }
 
@@ -62,6 +65,7 @@ public Factory(Context context) {
       this.context = context;
     }
 
+    @NonNull
     @Override
     public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new MediaStoreVideoThumbLoader(context);
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java
index 1dc7951d4..c3995affa 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.model.stream;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
@@ -17,17 +18,20 @@
 public class UrlLoader implements ModelLoader<URL, InputStream> {
   private final ModelLoader<GlideUrl, InputStream> glideUrlLoader;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public UrlLoader(ModelLoader<GlideUrl, InputStream> glideUrlLoader) {
     this.glideUrlLoader = glideUrlLoader;
   }
 
   @Override
-  public LoadData<InputStream> buildLoadData(URL model, int width, int height, Options options) {
+  public LoadData<InputStream> buildLoadData(@NonNull URL model, int width, int height,
+      @NonNull Options options) {
     return glideUrlLoader.buildLoadData(new GlideUrl(model), width, height, options);
   }
 
   @Override
-  public boolean handles(URL model) {
+  public boolean handles(@NonNull URL model) {
     return true;
   }
 
@@ -36,6 +40,7 @@ public boolean handles(URL model) {
    */
   public static class StreamFactory implements ModelLoaderFactory<URL, InputStream> {
 
+    @NonNull
     @Override
     public ModelLoader<URL, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new UrlLoader(multiFactory.build(GlideUrl.class, InputStream.class));
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/SimpleResource.java b/library/src/main/java/com/bumptech/glide/load/resource/SimpleResource.java
index 5291061e0..9b6c8e465 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/SimpleResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/SimpleResource.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.resource;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.util.Preconditions;
 
@@ -14,16 +15,18 @@
 public class SimpleResource<T> implements Resource<T> {
   protected final T data;
 
-  public SimpleResource(T data) {
+  public SimpleResource(@NonNull T data) {
     this.data = Preconditions.checkNotNull(data);
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
   @Override
   public Class<T> getResourceClass() {
     return (Class<T>) data.getClass();
   }
 
+  @NonNull
   @Override
   public final T get() {
     return data;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java
index 023e2d978..9602c2564 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java
@@ -1,17 +1,18 @@
 package com.bumptech.glide.load.resource;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import java.security.MessageDigest;
 
 /**
- * A noop Transformation that simply returns the given resource.
+ * A no-op Transformation that simply returns the given resource.
  *
  * @param <T> The type of the resource that will always be returned unmodified.
  */
 public final class UnitTransformation<T> implements Transformation<T> {
-  private static final Transformation<?> TRANSFORMATION = new UnitTransformation<Object>();
+  private static final Transformation<?> TRANSFORMATION = new UnitTransformation<>();
 
   /**
    * Returns a UnitTransformation for the given type.
@@ -19,6 +20,7 @@
    * @param <T> The type of the resource to be transformed.
    */
   @SuppressWarnings("unchecked")
+  @NonNull
   public static <T> UnitTransformation<T> get() {
     return (UnitTransformation<T>) TRANSFORMATION;
   }
@@ -27,13 +29,15 @@ private UnitTransformation() {
     // Only accessible as a singleton.
   }
 
+  @NonNull
   @Override
-  public Resource<T> transform(Context context, Resource<T> resource, int outWidth, int outHeight) {
+  public Resource<T> transform(@NonNull Context context, @NonNull Resource<T> resource,
+      int outWidth, int outHeight) {
     return resource;
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     // Do nothing.
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java
index 5a0f9064d..40a2d4c92 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java
@@ -4,7 +4,7 @@
 import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
-import com.bumptech.glide.Glide;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
@@ -21,32 +21,41 @@
 
   private final ResourceDecoder<DataType, Bitmap> decoder;
   private final Resources resources;
-  private final BitmapPool bitmapPool;
 
+  // Public API.
+  @SuppressWarnings({"unused", "WeakerAccess"})
   public BitmapDrawableDecoder(Context context, ResourceDecoder<DataType, Bitmap> decoder) {
-    this(context.getResources(), Glide.get(context).getBitmapPool(), decoder);
+    this(context.getResources(), decoder);
   }
 
-  public BitmapDrawableDecoder(Resources resources, BitmapPool bitmapPool,
+  /**
+   * @deprecated Use {@link #BitmapDrawableDecoder(Context, ResourceDecoder)}, {@code bitmapPool}
+   * is ignored.
+   */
+  @Deprecated
+  public BitmapDrawableDecoder(
+      Resources resources,
+      @SuppressWarnings("unused") BitmapPool bitmapPool,
       ResourceDecoder<DataType, Bitmap> decoder) {
+    this(resources, decoder);
+  }
+
+  public BitmapDrawableDecoder(
+      @NonNull Resources resources, @NonNull ResourceDecoder<DataType, Bitmap> decoder) {
     this.resources = Preconditions.checkNotNull(resources);
-    this.bitmapPool = Preconditions.checkNotNull(bitmapPool);
     this.decoder = Preconditions.checkNotNull(decoder);
   }
 
   @Override
-  public boolean handles(DataType source, Options options) throws IOException {
+  public boolean handles(@NonNull DataType source, @NonNull Options options) throws IOException {
     return decoder.handles(source, options);
   }
 
   @Override
-  public Resource<BitmapDrawable> decode(DataType source, int width, int height, Options options)
+  public Resource<BitmapDrawable> decode(@NonNull DataType source, int width, int height,
+      @NonNull Options options)
       throws IOException {
     Resource<Bitmap> bitmapResource = decoder.decode(source, width, height, options);
-    if (bitmapResource == null) {
-      return null;
-    }
-
-    return LazyBitmapDrawableResource.obtain(resources, bitmapPool, bitmapResource.get());
+    return LazyBitmapDrawableResource.obtain(resources, bitmapResource);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableEncoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableEncoder.java
index a414e6dd0..a955d9d05 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableEncoder.java
@@ -2,6 +2,7 @@
 
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.EncodeStrategy;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceEncoder;
@@ -23,12 +24,14 @@ public BitmapDrawableEncoder(BitmapPool bitmapPool, ResourceEncoder<Bitmap> enco
   }
 
   @Override
-  public boolean encode(Resource<BitmapDrawable> data, File file, Options options) {
+  public boolean encode(@NonNull Resource<BitmapDrawable> data, @NonNull File file,
+      @NonNull Options options) {
     return encoder.encode(new BitmapResource(data.get().getBitmap(), bitmapPool), file, options);
   }
 
+  @NonNull
   @Override
-  public EncodeStrategy getEncodeStrategy(Options options) {
+  public EncodeStrategy getEncodeStrategy(@NonNull Options options) {
     return encoder.getEncodeStrategy(options);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java
index 989664e20..736c02ea6 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.drawable.BitmapDrawable;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.drawable.DrawableResource;
@@ -20,11 +21,14 @@
     implements Initializable {
   private final BitmapPool bitmapPool;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public BitmapDrawableResource(BitmapDrawable drawable, BitmapPool bitmapPool) {
     super(drawable);
     this.bitmapPool = bitmapPool;
   }
 
+  @NonNull
   @Override
   public Class<BitmapDrawable> getResourceClass() {
     return BitmapDrawable.class;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java
index 299e31d42..2b3bdc574 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java
@@ -3,63 +3,58 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
-import com.bumptech.glide.Glide;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
 import java.security.MessageDigest;
 
 /**
  * Transforms {@link android.graphics.drawable.BitmapDrawable}s.
+ *
+ * @deprecated Use {@link DrawableTransformation} instead.
  */
+@Deprecated
 public class BitmapDrawableTransformation implements Transformation<BitmapDrawable> {
 
-  private final Transformation<Bitmap> wrapped;
+  private final Transformation<Drawable> wrapped;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public BitmapDrawableTransformation(Transformation<Bitmap> wrapped) {
-    this.wrapped = Preconditions.checkNotNull(wrapped);
-  }
-
-  /**
-   * @deprecated use {@link #BitmapDrawableTransformation(Transformation)}}
-   */
-  @Deprecated
-  public BitmapDrawableTransformation(
-      @SuppressWarnings("unused") Context context, Transformation<Bitmap> wrapped) {
-    this(wrapped);
-  }
-
-  /**
-   * @deprecated use {@link #BitmapDrawableTransformation(Transformation)}}
-   */
-  @Deprecated
-  public BitmapDrawableTransformation(
-      @SuppressWarnings("unused") Context context,
-      @SuppressWarnings("unused") BitmapPool bitmapPool,
-      Transformation<Bitmap> wrapped) {
-    this(wrapped);
+    this.wrapped =
+        Preconditions.checkNotNull(new DrawableTransformation(wrapped, /*isRequired=*/ false));
   }
 
+  @NonNull
   @Override
   public Resource<BitmapDrawable> transform(
-      Context context, Resource<BitmapDrawable> drawableResourceToTransform, int outWidth,
-      int outHeight) {
-    BitmapDrawable drawableToTransform = drawableResourceToTransform.get();
-    Bitmap bitmapToTransform = drawableToTransform.getBitmap();
-
-    BitmapPool bitmapPool = Glide.get(context).getBitmapPool();
-    BitmapResource bitmapResourceToTransform = BitmapResource.obtain(bitmapToTransform, bitmapPool);
-    Resource<Bitmap> transformedBitmapResource =
-        wrapped.transform(context, bitmapResourceToTransform, outWidth, outHeight);
+      @NonNull Context context, @NonNull Resource<BitmapDrawable> drawableResourceToTransform,
+      int outWidth, int outHeight) {
+    Resource<Drawable> toTransform = convertToDrawableResource(drawableResourceToTransform);
+    Resource<Drawable> transformed = wrapped.transform(context, toTransform, outWidth, outHeight);
+    return convertToBitmapDrawableResource(transformed);
+  }
 
-    if (transformedBitmapResource.equals(bitmapResourceToTransform)) {
-      return drawableResourceToTransform;
-    } else {
-      return LazyBitmapDrawableResource.obtain(context, transformedBitmapResource.get());
+  @SuppressWarnings("unchecked")
+  private static Resource<BitmapDrawable> convertToBitmapDrawableResource(
+      Resource<Drawable> resource) {
+    if (!(resource.get() instanceof BitmapDrawable)) {
+      throw new IllegalArgumentException(
+          "Wrapped transformation unexpectedly returned a non BitmapDrawable resource: "
+              + resource.get());
     }
+    return (Resource<BitmapDrawable>) (Resource<?>) resource;
+  }
+
+  @SuppressWarnings("unchecked")
+  private static Resource<Drawable> convertToDrawableResource(
+      Resource<BitmapDrawable> toConvert) {
+    return (Resource<Drawable>) (Resource<? extends Drawable>) toConvert;
   }
 
+  @SuppressWarnings("deprecation")
   @Override
   public boolean equals(Object o) {
     if (o instanceof BitmapDrawableTransformation) {
@@ -75,7 +70,7 @@ public int hashCode() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     wrapped.updateDiskCacheKey(messageDigest);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java
index 8a2fdf327..8dcd98372 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java
@@ -1,15 +1,19 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.Bitmap;
-import android.support.v4.os.TraceCompat;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.util.Log;
 import com.bumptech.glide.load.EncodeStrategy;
 import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceEncoder;
+import com.bumptech.glide.load.data.BufferedOutputStream;
 import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.util.LogTime;
 import com.bumptech.glide.util.Util;
+import com.bumptech.glide.util.pool.GlideTrace;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
@@ -48,13 +52,28 @@
       "com.bumptech.glide.load.resource.bitmap.BitmapEncoder.CompressionFormat");
 
   private static final String TAG = "BitmapEncoder";
+  @Nullable
+  private final ArrayPool arrayPool;
+
+  public BitmapEncoder(@NonNull ArrayPool arrayPool) {
+    this.arrayPool = arrayPool;
+  }
+
+  /**
+   * @deprecated Use {@link #BitmapEncoder(ArrayPool)} instead.
+   */
+  @Deprecated
+  public BitmapEncoder() {
+    arrayPool = null;
+  }
 
   @Override
-  public boolean encode(Resource<Bitmap> resource, File file, Options options) {
+  public boolean encode(@NonNull Resource<Bitmap> resource, @NonNull File file,
+      @NonNull Options options) {
     final Bitmap bitmap = resource.get();
     Bitmap.CompressFormat format = getFormat(bitmap, options);
-    TraceCompat.beginSection(
-        "encode: [" + bitmap.getWidth() + "x" + bitmap.getHeight() + "] " + format);
+    GlideTrace.
+        beginSectionFormat("encode: [%dx%d] %s", bitmap.getWidth(), bitmap.getHeight(), format);
     try {
       long start = LogTime.getLogTime();
       int quality = options.get(COMPRESSION_QUALITY);
@@ -63,6 +82,9 @@ public boolean encode(Resource<Bitmap> resource, File file, Options options) {
       OutputStream os = null;
       try {
         os = new FileOutputStream(file);
+        if (arrayPool != null) {
+          os = new BufferedOutputStream(os, arrayPool);
+        }
         bitmap.compress(format, quality, os);
         os.close();
         success = true;
@@ -88,7 +110,7 @@ public boolean encode(Resource<Bitmap> resource, File file, Options options) {
       }
       return success;
     } finally {
-      TraceCompat.endSection();
+      GlideTrace.endSection();
     }
   }
 
@@ -103,8 +125,9 @@ public boolean encode(Resource<Bitmap> resource, File file, Options options) {
     }
   }
 
+  @NonNull
   @Override
-  public EncodeStrategy getEncodeStrategy(Options options) {
+  public EncodeStrategy getEncodeStrategy(@NonNull Options options) {
     return EncodeStrategy.TRANSFORMED;
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java
index 102c688c0..49e57a956 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.engine.Resource;
@@ -24,7 +25,7 @@
    * @param bitmapPool A non-null {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool}.
    */
   @Nullable
-  public static BitmapResource obtain(@Nullable Bitmap bitmap, BitmapPool bitmapPool) {
+  public static BitmapResource obtain(@Nullable Bitmap bitmap, @NonNull BitmapPool bitmapPool) {
     if (bitmap == null) {
       return null;
     } else {
@@ -32,16 +33,18 @@ public static BitmapResource obtain(@Nullable Bitmap bitmap, BitmapPool bitmapPo
     }
   }
 
-  public BitmapResource(Bitmap bitmap, BitmapPool bitmapPool) {
+  public BitmapResource(@NonNull Bitmap bitmap, @NonNull BitmapPool bitmapPool) {
     this.bitmap = Preconditions.checkNotNull(bitmap, "Bitmap must not be null");
     this.bitmapPool = Preconditions.checkNotNull(bitmapPool, "BitmapPool must not be null");
   }
 
+  @NonNull
   @Override
   public Class<Bitmap> getResourceClass() {
     return Bitmap.class;
   }
 
+  @NonNull
   @Override
   public Bitmap get() {
     return bitmap;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java
index f204cc54e..44bc67066 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java
@@ -9,6 +9,8 @@
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.util.Util;
+import java.nio.charset.Charset;
+import java.security.MessageDigest;
 
 /**
  * A simple {@link com.bumptech.glide.load.Transformation} for transforming
@@ -18,9 +20,9 @@
  * Use cases will look something like this:
  * <pre>
  * <code>
- * public class FillSpace extends BaseBitmapTransformation {
+ * public class FillSpace extends BitmapTransformation {
  *     private static final String ID = "com.bumptech.glide.transformations.FillSpace";
- *     private static final String ID_BYTES = ID.getBytes(STRING_CHARSET_NAME);
+ *     private static final byte[] ID_BYTES = ID.getBytes(Charset.forName("UTF-8"));
  *
  *     {@literal @Override}
  *     public Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {
@@ -32,7 +34,7 @@
  *     }
  *
  *     {@literal @Override}
- *     public void equals(Object o) {
+ *     public boolean equals(Object o) {
  *       return o instanceof FillSpace;
  *     }
  *
@@ -42,33 +44,31 @@
  *     }
  *
  *     {@literal @Override}
- *     public void updateDiskCacheKey(MessageDigest messageDigest)
- *         throws UnsupportedEncodingException {
+ *     public void updateDiskCacheKey(MessageDigest messageDigest) {
  *       messageDigest.update(ID_BYTES);
  *     }
  * }
  * </code>
  * </pre>
+ *
+ * <p>Using the fully qualified class name as a static final {@link String} (not
+ * {@link Class#getName()} to avoid proguard obfuscation) is an easy way to implement
+ * {@link #updateDiskCacheKey(java.security.MessageDigest)}} correctly. If additional arguments are
+ * required they can be passed in to the constructor of the {@code Transformation} and then used to
+ * update the {@link java.security.MessageDigest} passed in to
+ * {@link #updateDiskCacheKey(MessageDigest)}. If arguments are primitive types, they can typically
+ * easily be serialized using {@link java.nio.ByteBuffer}. {@link String} types can be serialized
+ * with {@link String#getBytes(Charset)} using the constant {@link #CHARSET}.
+ *
+ * <p>As with all {@link Transformation}s, all subclasses <em>must</em> implement
+ * {@link #equals(Object)} and {@link #hashCode()} for memory caching to work correctly.
  */
 public abstract class BitmapTransformation implements Transformation<Bitmap> {
 
-  public BitmapTransformation() {
-    // Intentionally empty.
-  }
-
-  @Deprecated
-  public BitmapTransformation(@SuppressWarnings("unused") Context context) {
-    this();
-  }
-
-  @Deprecated
-  public BitmapTransformation(@SuppressWarnings("unused") BitmapPool bitmapPool) {
-    this();
-  }
-
+  @NonNull
   @Override
   public final Resource<Bitmap> transform(
-      Context context, Resource<Bitmap> resource, int outWidth, int outHeight) {
+      @NonNull Context context, @NonNull Resource<Bitmap> resource, int outWidth, int outHeight) {
     if (!Util.isValidDimensions(outWidth, outHeight)) {
       throw new IllegalArgumentException(
           "Cannot apply transformation on width: " + outWidth + " or height: " + outHeight
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java
index 61900b789..e5e335bc4 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java
@@ -2,6 +2,7 @@
 
 import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.TransitionOptions;
 import com.bumptech.glide.request.transition.BitmapTransitionFactory;
 import com.bumptech.glide.request.transition.DrawableCrossFadeFactory;
@@ -10,6 +11,8 @@
 /**
  * Contains {@link Bitmap} specific animation options.
  */
+// Public API.
+@SuppressWarnings({"unused", "WeakerAccess"})
 public final class BitmapTransitionOptions extends
     TransitionOptions<BitmapTransitionOptions, Bitmap> {
 
@@ -18,6 +21,7 @@
    *
    * @see #crossFade()
    */
+  @NonNull
   public static BitmapTransitionOptions withCrossFade() {
     return new BitmapTransitionOptions().crossFade();
   }
@@ -27,6 +31,7 @@ public static BitmapTransitionOptions withCrossFade() {
    *
    * @see #crossFade(int)
    */
+  @NonNull
   public static BitmapTransitionOptions withCrossFade(int duration) {
     return new BitmapTransitionOptions().crossFade(duration);
   }
@@ -36,8 +41,9 @@ public static BitmapTransitionOptions withCrossFade(int duration) {
    *
    * @see #crossFade(DrawableCrossFadeFactory)
    */
+  @NonNull
   public static BitmapTransitionOptions withCrossFade(
-      DrawableCrossFadeFactory drawableCrossFadeFactory) {
+      @NonNull DrawableCrossFadeFactory drawableCrossFadeFactory) {
     return new BitmapTransitionOptions().crossFade(drawableCrossFadeFactory);
   }
 
@@ -46,8 +52,9 @@ public static BitmapTransitionOptions withCrossFade(
    *
    * @see #crossFade(DrawableCrossFadeFactory.Builder)
    */
+  @NonNull
   public static BitmapTransitionOptions withCrossFade(
-      DrawableCrossFadeFactory.Builder builder) {
+      @NonNull DrawableCrossFadeFactory.Builder builder) {
     return new BitmapTransitionOptions().crossFade(builder);
   }
 
@@ -57,8 +64,9 @@ public static BitmapTransitionOptions withCrossFade(
    *
    * @see #transitionUsing(TransitionFactory)
    */
+  @NonNull
   public static BitmapTransitionOptions withWrapped(
-      TransitionFactory<Drawable> drawableCrossFadeFactory) {
+      @NonNull TransitionFactory<Drawable> drawableCrossFadeFactory) {
     return new BitmapTransitionOptions().transitionUsing(drawableCrossFadeFactory);
   }
 
@@ -67,8 +75,9 @@ public static BitmapTransitionOptions withWrapped(
    *
    * @see com.bumptech.glide.GenericTransitionOptions#with(TransitionFactory)
    */
+  @NonNull
   public static BitmapTransitionOptions with(
-      TransitionFactory<Bitmap> transitionFactory) {
+      @NonNull TransitionFactory<Bitmap> transitionFactory) {
     return new BitmapTransitionOptions().transition(transitionFactory);
   }
 
@@ -76,6 +85,7 @@ public static BitmapTransitionOptions with(
    * Enables a cross fade animation between both the placeholder and the first resource and between
    * subsequent resources (if thumbnails are used).
    */
+  @NonNull
   public BitmapTransitionOptions crossFade() {
     return crossFade(new DrawableCrossFadeFactory.Builder());
   }
@@ -88,6 +98,7 @@ public BitmapTransitionOptions crossFade() {
    *     {@code DrawableCrossFadeFactory.Builder(int)}.
    * @see com.bumptech.glide.request.transition.DrawableCrossFadeFactory.Builder
    */
+  @NonNull
   public BitmapTransitionOptions crossFade(int duration) {
     return crossFade(new DrawableCrossFadeFactory.Builder(duration));
   }
@@ -96,15 +107,18 @@ public BitmapTransitionOptions crossFade(int duration) {
    * Enables a cross fade animation between both the placeholder and the first resource and between
    * subsequent resources (if thumbnails are used).
    */
-  public BitmapTransitionOptions crossFade(DrawableCrossFadeFactory drawableCrossFadeFactory) {
+  @NonNull
+  public BitmapTransitionOptions crossFade(
+      @NonNull DrawableCrossFadeFactory drawableCrossFadeFactory) {
     return transitionUsing(drawableCrossFadeFactory);
   }
 
   /**
    * Enables a any Drawable based animation to run on Bitmaps as well.
    */
+  @NonNull
   public BitmapTransitionOptions transitionUsing(
-      TransitionFactory<Drawable> drawableCrossFadeFactory) {
+      @NonNull TransitionFactory<Drawable> drawableCrossFadeFactory) {
     return transition(new BitmapTransitionFactory(drawableCrossFadeFactory));
   }
 
@@ -112,7 +126,8 @@ public BitmapTransitionOptions transitionUsing(
    * Enables a cross fade animation between both the placeholder and the first resource and between
    * subsequent resources (if thumbnails are used).
    */
-  public BitmapTransitionOptions crossFade(DrawableCrossFadeFactory.Builder builder) {
+  @NonNull
+  public BitmapTransitionOptions crossFade(@NonNull DrawableCrossFadeFactory.Builder builder) {
     return transitionUsing(builder.build());
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ByteBufferBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ByteBufferBitmapDecoder.java
index 6a6c9ec8f..97084a025 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ByteBufferBitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ByteBufferBitmapDecoder.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
@@ -20,12 +21,13 @@ public ByteBufferBitmapDecoder(Downsampler downsampler) {
   }
 
   @Override
-  public boolean handles(ByteBuffer source, Options options) throws IOException {
+  public boolean handles(@NonNull ByteBuffer source, @NonNull Options options) {
     return downsampler.handles(source);
   }
 
   @Override
-  public Resource<Bitmap> decode(ByteBuffer source, int width, int height, Options options)
+  public Resource<Bitmap> decode(@NonNull ByteBuffer source, int width, int height,
+      @NonNull Options options)
       throws IOException {
     InputStream is = ByteBufferUtil.toStream(source);
     return downsampler.decode(is, width, height, options);
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java
index bdc38562a..da0d1a1ec 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.load.resource.bitmap;
 
-import android.content.Context;
 import android.graphics.Bitmap;
 import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
@@ -17,22 +16,6 @@
   private static final String ID = "com.bumptech.glide.load.resource.bitmap.CenterCrop";
   private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
 
-  public CenterCrop() {
-    // Intentionally empty.
-  }
-
-  @Deprecated
-  public CenterCrop(@SuppressWarnings("unused") Context context) {
-    this();
-  }
-
-  @Deprecated
-  public CenterCrop(@SuppressWarnings("unused") BitmapPool bitmapPool) {
-    this();
-  }
-
-  // Bitmap doesn't implement equals, so == and .equals are equivalent here.
-  @SuppressWarnings("PMD.CompareObjectsWithEquals")
   @Override
   protected Bitmap transform(
       @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {
@@ -50,7 +33,7 @@ public int hashCode() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     messageDigest.update(ID_BYTES);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java
index 6efdbad47..b707b0fc8 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.load.resource.bitmap;
 
-import android.content.Context;
 import android.graphics.Bitmap;
 import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
@@ -17,26 +16,6 @@
   private static final String ID = "com.bumptech.glide.load.resource.bitmap.CenterInside";
   private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
 
-  public CenterInside() {
-    // Intentionally empty.
-  }
-
-  /**
-   * Use {@link #CenterInside()}.
-   */
-  @Deprecated
-  public CenterInside(@SuppressWarnings("unused") Context context) {
-    this();
-  }
-
-  /**
-   * Use {@link #CenterInside()}.
-   */
-  @Deprecated
-  public CenterInside(@SuppressWarnings("unused") BitmapPool bitmapPool) {
-    this();
-  }
-
   @Override
   protected Bitmap transform(
       @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {
@@ -54,7 +33,7 @@ public int hashCode() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     messageDigest.update(ID_BYTES);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java
index 655487175..7d5d5968b 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.load.resource.bitmap;
 
-import android.content.Context;
 import android.graphics.Bitmap;
 import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
@@ -19,26 +18,6 @@
   private static final String ID = "com.bumptech.glide.load.resource.bitmap.CircleCrop." + VERSION;
   private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
 
-  public CircleCrop() {
-    // Intentionally empty.
-  }
-
-  /**
-   * @deprecated Use {@link #CircleCrop()}.
-   */
-  @Deprecated
-  public CircleCrop(@SuppressWarnings("unused") Context context) {
-    this();
-  }
-
-  /**
-   * @deprecated Use {@link #CircleCrop()}
-   */
-  @Deprecated
-  public CircleCrop(@SuppressWarnings("unused") BitmapPool bitmapPool) {
-    this();
-  }
-
   // Bitmap doesn't implement equals, so == and .equals are equivalent here.
   @SuppressWarnings("PMD.CompareObjectsWithEquals")
   @Override
@@ -58,7 +37,7 @@ public int hashCode() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     messageDigest.update(ID_BYTES);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParser.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParser.java
index 5bfe67f8c..a6e7c10cb 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParser.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParser.java
@@ -6,6 +6,7 @@
 import static com.bumptech.glide.load.ImageHeaderParser.ImageType.PNG_A;
 import static com.bumptech.glide.load.ImageHeaderParser.ImageType.UNKNOWN;
 
+import android.support.annotation.NonNull;
 import android.util.Log;
 import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
@@ -31,7 +32,7 @@
   private static final int MOTOROLA_TIFF_MAGIC_NUMBER = 0x4D4D;
   // "II".
   private static final int INTEL_TIFF_MAGIC_NUMBER = 0x4949;
-  static final String JPEG_EXIF_SEGMENT_PREAMBLE = "Exif\0\0";
+  private static final String JPEG_EXIF_SEGMENT_PREAMBLE = "Exif\0\0";
   static final byte[] JPEG_EXIF_SEGMENT_PREAMBLE_BYTES =
       JPEG_EXIF_SEGMENT_PREAMBLE.getBytes(Charset.forName("UTF-8"));
   private static final int SEGMENT_SOS = 0xDA;
@@ -56,37 +57,42 @@
   private static final int WEBP_EXTENDED_ALPHA_FLAG = 1 << 4;
   private static final int WEBP_LOSSLESS_ALPHA_FLAG = 1 << 3;
 
+  @NonNull
   @Override
-  public ImageType getType(InputStream is) throws IOException {
+  public ImageType getType(@NonNull InputStream is) throws IOException {
     return getType(new StreamReader(Preconditions.checkNotNull(is)));
   }
 
+  @NonNull
   @Override
-  public ImageType getType(ByteBuffer byteBuffer) throws IOException {
+  public ImageType getType(@NonNull ByteBuffer byteBuffer) throws IOException {
     return getType(new ByteBufferReader(Preconditions.checkNotNull(byteBuffer)));
   }
 
   @Override
-  public int getOrientation(InputStream is, ArrayPool byteArrayPool) throws IOException {
+  public int getOrientation(@NonNull InputStream is, @NonNull ArrayPool byteArrayPool)
+      throws IOException {
     return getOrientation(new StreamReader(Preconditions.checkNotNull(is)),
         Preconditions.checkNotNull(byteArrayPool));
   }
 
   @Override
-  public int getOrientation(ByteBuffer byteBuffer, ArrayPool byteArrayPool) throws IOException {
+  public int getOrientation(@NonNull ByteBuffer byteBuffer, @NonNull ArrayPool byteArrayPool)
+      throws IOException {
     return getOrientation(new ByteBufferReader(Preconditions.checkNotNull(byteBuffer)),
         Preconditions.checkNotNull(byteArrayPool));
   }
 
+  @NonNull
   private ImageType getType(Reader reader) throws IOException {
-    int firstTwoBytes = reader.getUInt16();
+    final int firstTwoBytes = reader.getUInt16();
 
     // JPEG.
     if (firstTwoBytes == EXIF_MAGIC_NUMBER) {
       return JPEG;
     }
 
-    final int firstFourBytes = firstTwoBytes << 16 & 0xFFFF0000 | reader.getUInt16() & 0xFFFF;
+    final int firstFourBytes = (firstTwoBytes << 16 & 0xFFFF0000) | (reader.getUInt16() & 0xFFFF);
     // PNG.
     if (firstFourBytes == PNG_HEADER) {
       // See: http://stackoverflow.com/questions/2057923/how-to-check-a-png-for-grayscale-alpha
@@ -109,11 +115,13 @@ private ImageType getType(Reader reader) throws IOException {
     }
     // Bytes 4 - 7 contain length information. Skip these.
     reader.skip(4);
-    final int thirdFourBytes = reader.getUInt16() << 16 & 0xFFFF0000 | reader.getUInt16() & 0xFFFF;
+    final int thirdFourBytes =
+        (reader.getUInt16() << 16 & 0xFFFF0000) | (reader.getUInt16() & 0xFFFF);
     if (thirdFourBytes != WEBP_HEADER) {
       return UNKNOWN;
     }
-    final int fourthFourBytes = reader.getUInt16() << 16 & 0xFFFF0000 | reader.getUInt16() & 0xFFFF;
+    final int fourthFourBytes =
+        (reader.getUInt16() << 16 & 0xFFFF0000) | (reader.getUInt16() & 0xFFFF);
     if ((fourthFourBytes & VP8_HEADER_MASK) != VP8_HEADER) {
       return UNKNOWN;
     }
@@ -137,7 +145,6 @@ private ImageType getType(Reader reader) throws IOException {
    *
    * @return The exif orientation if present or -1 if the header couldn't be parsed or doesn't
    * contain an orientation
-   * @throws IOException
    */
   private int getOrientation(Reader reader, ArrayPool byteArrayPool) throws IOException {
     final int magicNumber = reader.getUInt16();
@@ -160,7 +167,7 @@ private int getOrientation(Reader reader, ArrayPool byteArrayPool) throws IOExce
       try {
         return parseExifSegment(reader, exifData, exifSegmentLength);
       } finally {
-        byteArrayPool.put(exifData, byte[].class);
+        byteArrayPool.put(exifData);
       }
     }
   }
@@ -207,10 +214,8 @@ private boolean hasJpegExifPreamble(byte[] exifData, int exifSegmentLength) {
    * {@code -1} if no exif segment is found.
    */
   private int moveToExifSegmentAndGetLength(Reader reader) throws IOException {
-    short segmentId, segmentType;
-    int segmentLength;
     while (true) {
-      segmentId = reader.getUInt8();
+      short segmentId = reader.getUInt8();
       if (segmentId != SEGMENT_START_ID) {
         if (Log.isLoggable(TAG, Log.DEBUG)) {
           Log.d(TAG, "Unknown segmentId=" + segmentId);
@@ -218,8 +223,7 @@ private int moveToExifSegmentAndGetLength(Reader reader) throws IOException {
         return -1;
       }
 
-      segmentType = reader.getUInt8();
-
+      short segmentType = reader.getUInt8();
       if (segmentType == SEGMENT_SOS) {
         return -1;
       } else if (segmentType == MARKER_EOI) {
@@ -230,18 +234,17 @@ private int moveToExifSegmentAndGetLength(Reader reader) throws IOException {
       }
 
       // Segment length includes bytes for segment length.
-      segmentLength = reader.getUInt16() - 2;
-
+      int segmentLength = reader.getUInt16() - 2;
       if (segmentType != EXIF_SEGMENT_TYPE) {
         long skipped = reader.skip(segmentLength);
         if (skipped != segmentLength) {
-            if (Log.isLoggable(TAG, Log.DEBUG)) {
-                Log.d(TAG, "Unable to skip enough data"
-                    + ", type: " + segmentType
-                    + ", wanted to skip: " + segmentLength
-                    + ", but actually skipped: " + skipped);
-            }
-            return -1;
+          if (Log.isLoggable(TAG, Log.DEBUG)) {
+            Log.d(TAG, "Unable to skip enough data"
+                + ", type: " + segmentType
+                + ", wanted to skip: " + segmentLength
+                + ", but actually skipped: " + skipped);
+          }
+          return -1;
         }
       } else {
         return segmentLength;
@@ -254,34 +257,35 @@ private static int parseExifSegment(RandomAccessReader segmentData) {
 
     short byteOrderIdentifier = segmentData.getInt16(headerOffsetSize);
     final ByteOrder byteOrder;
-    if (byteOrderIdentifier == MOTOROLA_TIFF_MAGIC_NUMBER) {
-      byteOrder = ByteOrder.BIG_ENDIAN;
-    } else if (byteOrderIdentifier == INTEL_TIFF_MAGIC_NUMBER) {
-      byteOrder = ByteOrder.LITTLE_ENDIAN;
-    } else {
-      if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "Unknown endianness = " + byteOrderIdentifier);
-      }
-      byteOrder = ByteOrder.BIG_ENDIAN;
+    switch (byteOrderIdentifier) {
+      case MOTOROLA_TIFF_MAGIC_NUMBER:
+        byteOrder = ByteOrder.BIG_ENDIAN;
+        break;
+      case INTEL_TIFF_MAGIC_NUMBER:
+        byteOrder = ByteOrder.LITTLE_ENDIAN;
+        break;
+      default:
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "Unknown endianness = " + byteOrderIdentifier);
+        }
+        byteOrder = ByteOrder.BIG_ENDIAN;
+        break;
     }
 
     segmentData.order(byteOrder);
 
     int firstIfdOffset = segmentData.getInt32(headerOffsetSize + 4) + headerOffsetSize;
     int tagCount = segmentData.getInt16(firstIfdOffset);
-
-    int tagOffset, tagType, formatCode, componentCount;
     for (int i = 0; i < tagCount; i++) {
-      tagOffset = calcTagOffset(firstIfdOffset, i);
-      tagType = segmentData.getInt16(tagOffset);
+      final int tagOffset = calcTagOffset(firstIfdOffset, i);
 
+      final int tagType = segmentData.getInt16(tagOffset);
       // We only want orientation.
       if (tagType != ORIENTATION_TAG_TYPE) {
         continue;
       }
 
-      formatCode = segmentData.getInt16(tagOffset + 2);
-
+      final int formatCode = segmentData.getInt16(tagOffset + 2);
       // 12 is max format code.
       if (formatCode < 1 || formatCode > 12) {
         if (Log.isLoggable(TAG, Log.DEBUG)) {
@@ -290,8 +294,7 @@ private static int parseExifSegment(RandomAccessReader segmentData) {
         continue;
       }
 
-      componentCount = segmentData.getInt32(tagOffset + 4);
-
+      final int componentCount = segmentData.getInt32(tagOffset + 4);
       if (componentCount < 0) {
         if (Log.isLoggable(TAG, Log.DEBUG)) {
           Log.d(TAG, "Negative tiff component count");
@@ -305,7 +308,6 @@ private static int parseExifSegment(RandomAccessReader segmentData) {
       }
 
       final int byteCount = componentCount + BYTES_PER_FORMAT[formatCode];
-
       if (byteCount > 4) {
         if (Log.isLoggable(TAG, Log.DEBUG)) {
           Log.d(TAG, "Got byte count > 4, not orientation, continuing, formatCode=" + formatCode);
@@ -314,7 +316,6 @@ private static int parseExifSegment(RandomAccessReader segmentData) {
       }
 
       final int tagValueOffset = tagOffset + 8;
-
       if (tagValueOffset < 0 || tagValueOffset > segmentData.length()) {
         if (Log.isLoggable(TAG, Log.DEBUG)) {
           Log.d(TAG, "Illegal tagValueOffset=" + tagValueOffset + " tagType=" + tagType);
@@ -394,24 +395,24 @@ private boolean isAvailable(int offset, int byteSize) {
     }
 
     @Override
-    public int getUInt16() throws IOException {
+    public int getUInt16() {
       return (getByte() << 8 & 0xFF00) | (getByte() & 0xFF);
     }
 
     @Override
-    public short getUInt8() throws IOException {
+    public short getUInt8() {
       return (short) (getByte() & 0xFF);
     }
 
     @Override
-    public long skip(long total) throws IOException {
+    public long skip(long total) {
       int toSkip = (int) Math.min(byteBuffer.remaining(), total);
       byteBuffer.position(byteBuffer.position() + toSkip);
       return toSkip;
     }
 
     @Override
-    public int read(byte[] buffer, int byteCount) throws IOException {
+    public int read(byte[] buffer, int byteCount) {
       int toRead = Math.min(byteCount, byteBuffer.remaining());
       if (toRead == 0) {
         return -1;
@@ -421,7 +422,7 @@ public int read(byte[] buffer, int byteCount) throws IOException {
     }
 
     @Override
-    public int getByte() throws IOException {
+    public int getByte() {
       if (byteBuffer.remaining() < 1) {
         return -1;
       }
@@ -431,6 +432,7 @@ public int getByte() throws IOException {
 
   private static final class StreamReader implements Reader {
     private final InputStream is;
+
     // Motorola / big endian byte order.
     StreamReader(InputStream is) {
       this.is = is;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java
index 71548c5e9..e2fb472d5 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java
@@ -1,10 +1,25 @@
 package com.bumptech.glide.load.resource.bitmap;
 
+import com.bumptech.glide.load.Option;
 import com.bumptech.glide.util.Synthetic;
 
 /**
  * Indicates the algorithm to use when downsampling images.
+ *
+ * <p>{@code DownsampleStrategy} does not provide any guarantees about output sizes. Behavior will
+ * differ depending on the {@link com.bumptech.glide.load.ResourceDecoder} using the strategy and
+ * the version of Android the code runs on. Use {@code DownsampleStrategy} as an optimization to
+ * improve memory efficiency only. If you need a particular size or shape output, use an
+ * {@link com.bumptech.glide.load.Transformation} either instead or in addition to a
+ * {@code DownsampleStrategy}.
+ *
+ * <p>Some differences between versions of Android and
+ * {@link com.bumptech.glide.load.ResourceDecoder}s are listed below, but the list is not
+ * comprehensive because {@link DownsampleStrategy} only controls it's output scale value, not
+ * how that output value is used.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public abstract class DownsampleStrategy {
 
   /**
@@ -16,8 +31,8 @@
    * and height. To avoid upscaling, use {@link #AT_LEAST}, {@link #AT_MOST} or
    * {@link #CENTER_INSIDE}.
    *
-   * <p>On pre-KitKat devices, this is equivalent to {@link #AT_MOST} because only power of
-   * two downsampling can be used.
+   * <p>On pre-KitKat devices, {@link Downsampler} treats this as equivalent to {@link #AT_MOST}
+   * because only power of two downsampling can be used.
    */
   public static final DownsampleStrategy FIT_CENTER = new FitCenter();
 
@@ -30,20 +45,24 @@
    * and height. To avoid upscaling, use {@link #AT_LEAST}, {@link #AT_MOST},
    * or {@link #CENTER_INSIDE}.
    *
-   * <p>On pre-KitKat devices, this is equivalent to {@link #AT_LEAST} because only power of
-   * two downsampling can be used.
+   * <p>On pre-KitKat devices, {@link Downsampler} treats this as equivalent to
+   * {@link #AT_LEAST} because only power of two downsampling can be used.
    */
   public static final DownsampleStrategy CENTER_OUTSIDE = new CenterOutside();
 
   /**
    * Downsamples so the image's smallest dimension is between the given dimensions and 2x the given
    * dimensions, with no size restrictions on the image's largest dimension.
+   *
+   * <p>Does not upscale if the requested dimensions are larger than the original dimensions.
    */
   public static final DownsampleStrategy AT_LEAST = new AtLeast();
 
   /**
    * Downsamples so the image's largest dimension is between 1/2 the given dimensions and the given
    * dimensions, with no restrictions on the image's smallest dimension.
+   *
+   * <p>Does not upscale if the requested dimensions are larger than the original dimensions.
    */
   public static final DownsampleStrategy AT_MOST = new AtMost();
 
@@ -52,7 +71,7 @@
    * maintaining its original aspect ratio, so that one of the image's dimensions is exactly equal
    * to the requested size and the other is less or equal than the requested size.
    *
-   * <p>This method will not upscale.</p>
+   * <p>Does not upscale if the requested dimensions are larger than the original dimensions.
    */
   public static final DownsampleStrategy CENTER_INSIDE = new CenterInside();
 
@@ -66,6 +85,17 @@
    */
   public static final DownsampleStrategy DEFAULT = CENTER_OUTSIDE;
 
+  /**
+   * Indicates the {@link com.bumptech.glide.load.resource.bitmap.DownsampleStrategy} option that
+   * will be used to calculate the sample size to use to downsample an image given the original
+   * and target dimensions of the image.
+   */
+  // The exact String value here is retained to avoid breaking cache keys for images that were
+  // loaded with older versions of Glide.
+  public static final Option<DownsampleStrategy> OPTION =
+      Option.memory(
+          "com.bumptech.glide.load.resource.bitmap.Downsampler.DownsampleStrategy", DEFAULT);
+
   /**
    * Returns a float (0, +infinity) indicating a scale factor to apply to the source
    * width and height when displayed in the requested width and height.
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
index 1d71f533c..53e7d25f4 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
@@ -2,6 +2,7 @@
 
 import android.annotation.TargetApi;
 import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
 import android.graphics.BitmapFactory;
 import android.os.Build;
 import android.support.annotation.Nullable;
@@ -9,6 +10,7 @@
 import android.util.Log;
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.ImageHeaderParser.ImageType;
 import com.bumptech.glide.load.ImageHeaderParserUtils;
 import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
@@ -16,7 +18,9 @@
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy.SampleSizeRounding;
+import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.util.LogTime;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Util;
 import java.io.IOException;
@@ -34,7 +38,7 @@
  * Downsamples, decodes, and rotates images according to their exif orientation.
  */
 public final class Downsampler {
-  private static final String TAG = "Downsampler";
+  static final String TAG = "Downsampler";
   /**
    * Indicates the {@link com.bumptech.glide.load.DecodeFormat} that will be used in conjunction
    * with the image format to determine the {@link android.graphics.Bitmap.Config} to provide to
@@ -46,11 +50,11 @@
    * Indicates the {@link com.bumptech.glide.load.resource.bitmap.DownsampleStrategy} option that
    * will be used to calculate the sample size to use to downsample an image given the original
    * and target dimensions of the image.
+   *
+   * @deprecated Use {@link DownsampleStrategy#OPTION} directly instead.
    */
-  public static final Option<DownsampleStrategy> DOWNSAMPLE_STRATEGY =
-      Option.memory("com.bumptech.glide.load.resource.bitmap.Downsampler.DownsampleStrategy",
-          DownsampleStrategy.AT_LEAST);
-
+  @Deprecated
+  public static final Option<DownsampleStrategy> DOWNSAMPLE_STRATEGY = DownsampleStrategy.OPTION;
   /**
    * Ensure that the size of the bitmap is fixed to the requested width and height of the
    * resource from the caller.  The final resource dimensions may differ from the requested
@@ -61,9 +65,32 @@
    * bitmap for a collection of requested resources so that the bitmap pool will not need to
    * allocate new bitmaps for images of different sizes.
    */
+  // Public API
+  @SuppressWarnings("WeakerAccess")
   public static final Option<Boolean> FIX_BITMAP_SIZE_TO_REQUESTED_DIMENSIONS =
       Option.memory("com.bumptech.glide.load.resource.bitmap.Downsampler.FixBitmapSize", false);
 
+  /**
+   * Indicates that it's safe or unsafe to decode {@link Bitmap}s with
+   * {@link Bitmap.Config#HARDWARE}.
+   *
+   * <p>Callers should almost never set this value to {@code true} manually. Glide will already do
+   * so when Glide believes it's safe to do (when no transformations are applied). Instead, callers
+   * can set this value to {@code false} to prevent Glide from decoding hardware bitmaps if Glide
+   * is unable to detect that hardware bitmaps are unsafe. For example, you should set this to
+   * {@code false} if you plan to draw it to a software {@link android.graphics.Canvas} or if you
+   * plan to inspect the {@link Bitmap}s pixels with {@link Bitmap#getPixel(int, int)} or
+   * {@link Bitmap#getPixels(int[], int, int, int, int, int, int)}.
+   *
+   * <p>Callers can disable hardware {@link Bitmap}s for all loads using
+   * {@link com.bumptech.glide.GlideBuilder#setDefaultRequestOptions(RequestOptions)}.
+   *
+   * <p>This option is ignored unless we're on Android O+.
+   */
+  public static final Option<Boolean> ALLOW_HARDWARE_CONFIG =
+      Option.memory(
+          "com.bumptech.glide.load.resource.bitmap.Downsampler.AllowHardwareDecode", false);
+
   private static final String WBMP_MIME_TYPE = "image/vnd.wap.wbmp";
   private static final String ICO_MIME_TYPE = "image/x-ico";
   private static final Set<String> NO_DOWNSAMPLE_PRE_N_MIME_TYPES =
@@ -82,7 +109,7 @@ public void onObtainBounds() {
     }
 
     @Override
-    public void onDecodeComplete(BitmapPool bitmapPool, Bitmap downsampled) throws IOException {
+    public void onDecodeComplete(BitmapPool bitmapPool, Bitmap downsampled) {
       // Do nothing.
     }
   };
@@ -95,14 +122,15 @@ public void onDecodeComplete(BitmapPool bitmapPool, Bitmap downsampled) throws I
           )
       );
   private static final Queue<BitmapFactory.Options> OPTIONS_QUEUE = Util.createQueue(0);
-  // 5MB. This is the max image header size we can handle, we preallocate a much smaller buffer
+  // 10MB. This is the max image header size we can handle, we preallocate a much smaller buffer
   // but will resize up to this amount if necessary.
-  private static final int MARK_POSITION = 5 * 1024 * 1024;
+  private static final int MARK_POSITION = 10 * 1024 * 1024;
 
   private final BitmapPool bitmapPool;
   private final DisplayMetrics displayMetrics;
   private final ArrayPool byteArrayPool;
   private final List<ImageHeaderParser> parsers;
+  private final HardwareConfigState hardwareConfigState = HardwareConfigState.getInstance();
 
   public Downsampler(List<ImageHeaderParser> parsers, DisplayMetrics displayMetrics,
       BitmapPool bitmapPool, ArrayPool byteArrayPool) {
@@ -112,12 +140,12 @@ public Downsampler(List<ImageHeaderParser> parsers, DisplayMetrics displayMetric
     this.byteArrayPool = Preconditions.checkNotNull(byteArrayPool);
   }
 
-  public boolean handles(InputStream is) {
+  public boolean handles(@SuppressWarnings("unused") InputStream is) {
     // We expect Downsampler to handle any available type Android supports.
     return true;
   }
 
-  public boolean handles(ByteBuffer byteBuffer) {
+  public boolean handles(@SuppressWarnings("unused") ByteBuffer byteBuffer) {
     // We expect downsampler to handle any available type Android supports.
     return true;
   }
@@ -158,7 +186,7 @@ public boolean handles(ByteBuffer byteBuffer) {
    * @return A new bitmap containing the image from the given InputStream, or recycle if recycle is
    * not null.
    */
-  @SuppressWarnings("resource")
+  @SuppressWarnings({"resource", "deprecation"})
   public Resource<Bitmap> decode(InputStream is, int requestedWidth, int requestedHeight,
       Options options, DecodeCallbacks callbacks) throws IOException {
     Preconditions.checkArgument(is.markSupported(), "You must provide an InputStream that supports"
@@ -169,51 +197,79 @@ public boolean handles(ByteBuffer byteBuffer) {
     bitmapFactoryOptions.inTempStorage = bytesForOptions;
 
     DecodeFormat decodeFormat = options.get(DECODE_FORMAT);
-    DownsampleStrategy downsampleStrategy = options.get(DOWNSAMPLE_STRATEGY);
+    DownsampleStrategy downsampleStrategy = options.get(DownsampleStrategy.OPTION);
     boolean fixBitmapToRequestedDimensions = options.get(FIX_BITMAP_SIZE_TO_REQUESTED_DIMENSIONS);
+    boolean isHardwareConfigAllowed =
+      options.get(ALLOW_HARDWARE_CONFIG) != null && options.get(ALLOW_HARDWARE_CONFIG);
 
     try {
       Bitmap result = decodeFromWrappedStreams(is, bitmapFactoryOptions,
-          downsampleStrategy, decodeFormat, requestedWidth, requestedHeight,
-          fixBitmapToRequestedDimensions, callbacks);
+          downsampleStrategy, decodeFormat, isHardwareConfigAllowed, requestedWidth,
+          requestedHeight, fixBitmapToRequestedDimensions, callbacks);
       return BitmapResource.obtain(result, bitmapPool);
     } finally {
       releaseOptions(bitmapFactoryOptions);
-      byteArrayPool.put(bytesForOptions, byte[].class);
+      byteArrayPool.put(bytesForOptions);
     }
   }
 
   private Bitmap decodeFromWrappedStreams(InputStream is,
       BitmapFactory.Options options, DownsampleStrategy downsampleStrategy,
-      DecodeFormat decodeFormat, int requestedWidth, int requestedHeight,
-      boolean fixBitmapToRequestedDimensions, DecodeCallbacks callbacks) throws IOException {
+      DecodeFormat decodeFormat, boolean isHardwareConfigAllowed, int requestedWidth,
+      int requestedHeight, boolean fixBitmapToRequestedDimensions,
+      DecodeCallbacks callbacks) throws IOException {
+    long startTime = LogTime.getLogTime();
 
     int[] sourceDimensions = getDimensions(is, options, callbacks, bitmapPool);
     int sourceWidth = sourceDimensions[0];
     int sourceHeight = sourceDimensions[1];
     String sourceMimeType = options.outMimeType;
 
+    // If we failed to obtain the image dimensions, we may end up with an incorrectly sized Bitmap,
+    // so we want to use a mutable Bitmap type. One way this can happen is if the image header is so
+    // large (10mb+) that our attempt to use inJustDecodeBounds fails and we're forced to decode the
+    // full size image.
+    if (sourceWidth == -1 || sourceHeight == -1) {
+      isHardwareConfigAllowed = false;
+    }
+
     int orientation = ImageHeaderParserUtils.getOrientation(parsers, is, byteArrayPool);
     int degreesToRotate = TransformationUtils.getExifOrientationDegrees(orientation);
-
-    options.inPreferredConfig = getConfig(is, decodeFormat);
-    if (options.inPreferredConfig != Bitmap.Config.ARGB_8888) {
-      options.inDither = true;
-    }
+    boolean isExifOrientationRequired = TransformationUtils.isExifOrientationRequired(orientation);
 
     int targetWidth = requestedWidth == Target.SIZE_ORIGINAL ? sourceWidth : requestedWidth;
     int targetHeight = requestedHeight == Target.SIZE_ORIGINAL ? sourceHeight : requestedHeight;
 
-    calculateScaling(downsampleStrategy, degreesToRotate, sourceWidth, sourceHeight, targetWidth,
-        targetHeight, options);
+    ImageType imageType = ImageHeaderParserUtils.getType(parsers, is, byteArrayPool);
+
+    calculateScaling(
+        imageType,
+        is,
+        callbacks,
+        bitmapPool,
+        downsampleStrategy,
+        degreesToRotate,
+        sourceWidth,
+        sourceHeight,
+        targetWidth,
+        targetHeight,
+        options);
+    calculateConfig(
+        is,
+        decodeFormat,
+        isHardwareConfigAllowed,
+        isExifOrientationRequired,
+        options,
+        targetWidth,
+        targetHeight);
 
     boolean isKitKatOrGreater = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT;
     // Prior to KitKat, the inBitmap size must exactly match the size of the bitmap we're decoding.
-    if ((options.inSampleSize == 1 || isKitKatOrGreater)
-        && shouldUsePool(is)) {
+    if ((options.inSampleSize == 1 || isKitKatOrGreater) && shouldUsePool(imageType)) {
       int expectedWidth;
       int expectedHeight;
-      if (fixBitmapToRequestedDimensions && isKitKatOrGreater) {
+      if (sourceWidth >= 0 && sourceHeight >= 0
+          && fixBitmapToRequestedDimensions && isKitKatOrGreater) {
         expectedWidth = targetWidth;
         expectedHeight = targetHeight;
       } else {
@@ -245,7 +301,7 @@ private Bitmap decodeFromWrappedStreams(InputStream is,
 
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
       logDecode(sourceWidth, sourceHeight, sourceMimeType, options, downsampled,
-          requestedWidth, requestedHeight);
+          requestedWidth, requestedHeight, startTime);
     }
 
     Bitmap rotated = null;
@@ -263,12 +319,24 @@ private Bitmap decodeFromWrappedStreams(InputStream is,
     return rotated;
   }
 
-  // Visible for testing.
-  static void calculateScaling(DownsampleStrategy downsampleStrategy, int degreesToRotate,
-      int sourceWidth, int sourceHeight, int targetWidth, int targetHeight,
-      BitmapFactory.Options options) {
+  private static void calculateScaling(
+      ImageType imageType,
+      InputStream is,
+      DecodeCallbacks decodeCallbacks,
+      BitmapPool bitmapPool,
+      DownsampleStrategy downsampleStrategy,
+      int degreesToRotate,
+      int sourceWidth,
+      int sourceHeight,
+      int targetWidth,
+      int targetHeight,
+      BitmapFactory.Options options) throws IOException {
     // We can't downsample source content if we can't determine its dimensions.
     if (sourceWidth <= 0 || sourceHeight <= 0) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Unable to determine dimensions for: " + imageType
+            + " with target [" + targetWidth + "x" + targetHeight + "]");
+      }
       return;
     }
 
@@ -287,7 +355,9 @@ static void calculateScaling(DownsampleStrategy downsampleStrategy, int degreesT
 
     if (exactScaleFactor <= 0f) {
       throw new IllegalArgumentException("Cannot scale with factor: " + exactScaleFactor
-          + " from: " + downsampleStrategy);
+          + " from: " + downsampleStrategy
+          + ", source: [" + sourceWidth + "x" + sourceHeight + "]"
+          + ", target: [" + targetWidth + "x" + targetHeight + "]");
     }
     SampleSizeRounding rounding = downsampleStrategy.getSampleSizeRounding(sourceWidth,
         sourceHeight, targetWidth, targetHeight);
@@ -295,8 +365,8 @@ static void calculateScaling(DownsampleStrategy downsampleStrategy, int degreesT
       throw new IllegalArgumentException("Cannot round with null rounding");
     }
 
-    int outWidth = (int) (exactScaleFactor * sourceWidth + 0.5f);
-    int outHeight = (int) (exactScaleFactor * sourceHeight + 0.5f);
+    int outWidth = round(exactScaleFactor * sourceWidth);
+    int outHeight = round(exactScaleFactor * sourceHeight);
 
     int widthScaleFactor = sourceWidth / outWidth;
     int heightScaleFactor = sourceHeight / outHeight;
@@ -318,14 +388,61 @@ static void calculateScaling(DownsampleStrategy downsampleStrategy, int degreesT
       }
     }
 
-    float adjustedScaleFactor = powerOfTwoSampleSize * exactScaleFactor;
-
+    // Here we mimic framework logic for determining how inSampleSize division is rounded on various
+    // versions of Android. The logic here has been tested on emulators for Android versions 15-26.
+    // PNG - Always uses floor
+    // JPEG - Always uses ceiling
+    // Webp - Prior to N, always uses floor. At and after N, always uses round.
     options.inSampleSize = powerOfTwoSampleSize;
+    int powerOfTwoWidth;
+    int powerOfTwoHeight;
+    if (imageType == ImageType.JPEG) {
+      // libjpegturbo can downsample up to a sample size of 8. libjpegturbo uses ceiling to round.
+      // After libjpegturbo's native rounding, skia does a secondary scale using floor
+      // (integer division). Here we replicate that logic.
+      int nativeScaling = Math.min(powerOfTwoSampleSize, 8);
+      powerOfTwoWidth = (int) Math.ceil(sourceWidth / (float) nativeScaling);
+      powerOfTwoHeight = (int) Math.ceil(sourceHeight / (float) nativeScaling);
+      int secondaryScaling = powerOfTwoSampleSize / 8;
+      if (secondaryScaling > 0) {
+        powerOfTwoWidth = powerOfTwoWidth / secondaryScaling;
+        powerOfTwoHeight = powerOfTwoHeight / secondaryScaling;
+      }
+    } else if (imageType == ImageType.PNG || imageType == ImageType.PNG_A) {
+      powerOfTwoWidth = (int) Math.floor(sourceWidth / (float) powerOfTwoSampleSize);
+      powerOfTwoHeight = (int) Math.floor(sourceHeight / (float) powerOfTwoSampleSize);
+    } else if (imageType == ImageType.WEBP || imageType == ImageType.WEBP_A) {
+      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
+        powerOfTwoWidth = Math.round(sourceWidth / (float) powerOfTwoSampleSize);
+        powerOfTwoHeight = Math.round(sourceHeight / (float) powerOfTwoSampleSize);
+      } else {
+        powerOfTwoWidth = (int) Math.floor(sourceWidth / (float) powerOfTwoSampleSize);
+        powerOfTwoHeight = (int) Math.floor(sourceHeight / (float) powerOfTwoSampleSize);
+      }
+    } else if (
+        sourceWidth % powerOfTwoSampleSize != 0 || sourceHeight % powerOfTwoSampleSize != 0) {
+      // If we're not confident the image is in one of our types, fall back to checking the
+      // dimensions again. inJustDecodeBounds decodes do obey inSampleSize.
+      int[] dimensions = getDimensions(is, options, decodeCallbacks, bitmapPool);
+      // Power of two downsampling in BitmapFactory uses a variety of random factors to determine
+      // rounding that we can't reliably replicate for all image formats. Use ceiling here to make
+      // sure that we at least provide a Bitmap that's large enough to fit the content we're going
+      // to load.
+      powerOfTwoWidth = dimensions[0];
+      powerOfTwoHeight = dimensions[1];
+    } else {
+      powerOfTwoWidth = sourceWidth / powerOfTwoSampleSize;
+      powerOfTwoHeight = sourceHeight / powerOfTwoSampleSize;
+    }
+
+    double adjustedScaleFactor = downsampleStrategy.getScaleFactor(
+        powerOfTwoWidth, powerOfTwoHeight, targetWidth, targetHeight);
+
     // Density scaling is only supported if inBitmap is null prior to KitKat. Avoid setting
     // densities here so we calculate the final Bitmap size correctly.
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
-      options.inTargetDensity = (int) (1000 * adjustedScaleFactor + 0.5f);
-      options.inDensity = 1000;
+      options.inTargetDensity = adjustTargetDensityForError(adjustedScaleFactor);
+      options.inDensity = getDensityMultiplier(adjustedScaleFactor);
     }
     if (isScaling(options)) {
       options.inScaled = true;
@@ -337,6 +454,7 @@ static void calculateScaling(DownsampleStrategy downsampleStrategy, int degreesT
       Log.v(TAG, "Calculate scaling"
           + ", source: [" + sourceWidth + "x" + sourceHeight + "]"
           + ", target: [" + targetWidth + "x" + targetHeight + "]"
+          + ", power of two scaled: [" + powerOfTwoWidth + "x" + powerOfTwoHeight + "]"
           + ", exact scale factor: " + exactScaleFactor
           + ", power of 2 sample size: " + powerOfTwoSampleSize
           + ", adjusted scale factor: " + adjustedScaleFactor
@@ -345,31 +463,68 @@ static void calculateScaling(DownsampleStrategy downsampleStrategy, int degreesT
     }
   }
 
-  private boolean shouldUsePool(InputStream is) throws IOException {
+  /**
+   * BitmapFactory calculates the density scale factor as a float. This introduces some non-trivial
+   * error. This method attempts to account for that error by adjusting the inTargetDensity so that
+   * the final scale factor is as close to our target as possible.
+   */
+  private static int adjustTargetDensityForError(double adjustedScaleFactor) {
+    int densityMultiplier = getDensityMultiplier(adjustedScaleFactor);
+    int targetDensity = round(densityMultiplier * adjustedScaleFactor);
+    float scaleFactorWithError = targetDensity / (float) densityMultiplier;
+    double difference = adjustedScaleFactor / scaleFactorWithError;
+    return round(difference * targetDensity);
+  }
+
+  private static int getDensityMultiplier(double adjustedScaleFactor) {
+    return (int) Math.round(
+        Integer.MAX_VALUE
+            * (adjustedScaleFactor <= 1D ? adjustedScaleFactor : 1 / adjustedScaleFactor));
+  }
+
+  // This is weird, but it matches the logic in a bunch of Android views/framework classes for
+  // rounding.
+  private static int round(double value) {
+    return (int) (value + 0.5d);
+  }
+
+  private boolean shouldUsePool(ImageType imageType) {
     // On KitKat+, any bitmap (of a given config) can be used to decode any other bitmap
     // (with the same config).
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
       return true;
     }
 
-    try {
-      ImageHeaderParser.ImageType type = ImageHeaderParserUtils.getType(parsers, is, byteArrayPool);
-      // We cannot reuse bitmaps when decoding images that are not PNG or JPG prior to KitKat.
-      // See: https://groups.google.com/forum/#!msg/android-developers/Mp0MFVFi1Fo/e8ZQ9FGdWdEJ
-      return TYPES_THAT_USE_POOL_PRE_KITKAT.contains(type);
-    } catch (IOException e) {
-      if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "Cannot determine the image type from header", e);
-      }
-    }
-    return false;
+    // We cannot reuse bitmaps when decoding images that are not PNG or JPG prior to KitKat.
+    // See: https://groups.google.com/forum/#!msg/android-developers/Mp0MFVFi1Fo/e8ZQ9FGdWdEJ
+    return TYPES_THAT_USE_POOL_PRE_KITKAT.contains(imageType);
   }
 
-  private Bitmap.Config getConfig(InputStream is, DecodeFormat format) throws IOException {
+  @SuppressWarnings("deprecation")
+  private void calculateConfig(
+      InputStream is,
+      DecodeFormat format,
+      boolean isHardwareConfigAllowed,
+      boolean isExifOrientationRequired,
+      BitmapFactory.Options optionsWithScaling,
+      int targetWidth,
+      int targetHeight) {
+
+    if (hardwareConfigState.setHardwareConfigIfAllowed(
+        targetWidth,
+        targetHeight,
+        optionsWithScaling,
+        format,
+        isHardwareConfigAllowed,
+        isExifOrientationRequired)) {
+      return;
+    }
+
     // Changing configs can cause skewing on 4.1, see issue #128.
     if (format == DecodeFormat.PREFER_ARGB_8888
         || Build.VERSION.SDK_INT == Build.VERSION_CODES.JELLY_BEAN) {
-      return Bitmap.Config.ARGB_8888;
+      optionsWithScaling.inPreferredConfig = Bitmap.Config.ARGB_8888;
+      return;
     }
 
     boolean hasAlpha = false;
@@ -382,7 +537,11 @@ private boolean shouldUsePool(InputStream is) throws IOException {
       }
     }
 
-    return hasAlpha ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
+    optionsWithScaling.inPreferredConfig =
+        hasAlpha ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
+    if (optionsWithScaling.inPreferredConfig == Config.RGB_565) {
+      optionsWithScaling.inDither = true;
+    }
   }
 
   /**
@@ -410,7 +569,7 @@ private static Bitmap decodeStream(InputStream is, BitmapFactory.Options options
       // size. To avoid unnecessary allocations reading image data, we fix the mark limit so that it
       // is no larger than our current buffer size here. We need to do so immediately before
       // decoding the full image to avoid having our mark limit overridden by other calls to
-      // markand reset. See issue #225.
+      // mark and reset. See issue #225.
       callbacks.onObtainBounds();
     }
     // BitmapFactory.Options out* variables are reset by most calls to decodeStream, successful or
@@ -457,7 +616,8 @@ private static boolean isScaling(BitmapFactory.Options options) {
   }
 
   private static void logDecode(int sourceWidth, int sourceHeight, String outMimeType,
-      BitmapFactory.Options options, Bitmap result, int requestedWidth, int requestedHeight) {
+      BitmapFactory.Options options, Bitmap result, int requestedWidth, int requestedHeight,
+      long startTime) {
     Log.v(TAG, "Decoded " + getBitmapString(result)
         + " from [" + sourceWidth + "x" + sourceHeight + "] " + outMimeType
         + " with inBitmap " + getInBitmapString(options)
@@ -465,7 +625,8 @@ private static void logDecode(int sourceWidth, int sourceHeight, String outMimeT
         + ", sample size: " + options.inSampleSize
         + ", density: " + options.inDensity
         + ", target density: " + options.inTargetDensity
-        + ", thread: " + Thread.currentThread().getName());
+        + ", thread: " + Thread.currentThread().getName()
+        + ", duration: " + LogTime.getElapsedMillis(startTime));
   }
 
   private static String getInBitmapString(BitmapFactory.Options options) {
@@ -498,10 +659,31 @@ private static IOException newIoExceptionForInBitmapAssertion(IllegalArgumentExc
           + ", inBitmap: " + getInBitmapString(options), e);
   }
 
-  private static void setInBitmap(BitmapFactory.Options options, BitmapPool bitmapPool, int width,
-      int height) {
+  @SuppressWarnings("PMD.CollapsibleIfStatements")
+  @TargetApi(Build.VERSION_CODES.O)
+  private static void setInBitmap(
+      BitmapFactory.Options options, BitmapPool bitmapPool, int width, int height) {
+    @Nullable Bitmap.Config expectedConfig = null;
+    // Avoid short circuiting, it appears to break on some devices.
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+      if (options.inPreferredConfig == Config.HARDWARE) {
+        return;
+      }
+      // On API 26 outConfig may be null for some images even if the image is valid, can be decoded
+      // and outWidth/outHeight/outColorSpace are populated (see b/71513049).
+      expectedConfig = options.outConfig;
+    }
+
+    if (expectedConfig == null) {
+      // We're going to guess that BitmapFactory will return us the config we're requesting. This
+      // isn't always the case, even though our guesses tend to be conservative and prefer configs
+      // of larger sizes so that the Bitmap will fit our image anyway. If we're wrong here and the
+      // config we choose is too small, our initial decode will fail, but we will retry with no
+      // inBitmap which will succeed so if we're wrong here, we're less efficient but still correct.
+      expectedConfig = options.inPreferredConfig;
+    }
     // BitmapFactory will clear out the Bitmap before writing to it, so getDirty is safe.
-    options.inBitmap = bitmapPool.getDirty(width, height, options.inPreferredConfig);
+    options.inBitmap = bitmapPool.getDirty(width, height, expectedConfig);
   }
 
   private static synchronized BitmapFactory.Options getDefaultOptions() {
@@ -524,6 +706,7 @@ private static void releaseOptions(BitmapFactory.Options decodeBitmapOptions) {
     }
   }
 
+  @SuppressWarnings("deprecation")
   private static void resetOptions(BitmapFactory.Options decodeBitmapOptions) {
     decodeBitmapOptions.inTempStorage = null;
     decodeBitmapOptions.inDither = false;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableToBitmapConverter.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableToBitmapConverter.java
new file mode 100644
index 000000000..2ed84484d
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableToBitmapConverter.java
@@ -0,0 +1,79 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.drawable.Animatable;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.Nullable;
+import android.util.Log;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
+import com.bumptech.glide.request.target.Target;
+import java.util.concurrent.locks.Lock;
+
+final class DrawableToBitmapConverter {
+  private static final String TAG = "DrawableToBitmap";
+  private static final BitmapPool NO_RECYCLE_BITMAP_POOL = new BitmapPoolAdapter() {
+    @Override
+    public void put(Bitmap bitmap) {
+      // Avoid calling super to avoid recycling the given Bitmap.
+    }
+  };
+  private DrawableToBitmapConverter() {
+    // Utility class.
+  }
+
+  @Nullable
+  static Resource<Bitmap> convert(BitmapPool bitmapPool, Drawable drawable, int width, int height) {
+    // Handle DrawableContainer or StateListDrawables that may contain one or more BitmapDrawables.
+    drawable = drawable.getCurrent();
+    Bitmap result = null;
+    boolean isRecycleable = false;
+    if (drawable instanceof BitmapDrawable) {
+      result = ((BitmapDrawable) drawable).getBitmap();
+    } else if (!(drawable instanceof Animatable)) {
+      result = drawToBitmap(bitmapPool, drawable, width, height);
+      // We created and drew to the Bitmap, so it's safe for us to recycle or re-use.
+      isRecycleable = true;
+    }
+
+    BitmapPool toUse = isRecycleable ? bitmapPool : NO_RECYCLE_BITMAP_POOL;
+    return BitmapResource.obtain(result, toUse);
+  }
+
+  @Nullable
+  private static Bitmap drawToBitmap(
+      BitmapPool bitmapPool, Drawable drawable, int width, int height) {
+    if (width == Target.SIZE_ORIGINAL && drawable.getIntrinsicWidth() <= 0) {
+      if (Log.isLoggable(TAG, Log.WARN)) {
+        Log.w(TAG, "Unable to draw " + drawable + " to Bitmap with Target.SIZE_ORIGINAL because the"
+            + " Drawable has no intrinsic width");
+      }
+      return null;
+    }
+    if (height == Target.SIZE_ORIGINAL && drawable.getIntrinsicHeight() <= 0) {
+      if (Log.isLoggable(TAG, Log.WARN)) {
+        Log.w(TAG, "Unable to draw " + drawable + " to Bitmap with Target.SIZE_ORIGINAL because the"
+            + " Drawable has no intrinsic height");
+      }
+      return null;
+    }
+    int targetWidth = drawable.getIntrinsicWidth() > 0 ? drawable.getIntrinsicWidth() : width;
+    int targetHeight = drawable.getIntrinsicHeight() > 0 ? drawable.getIntrinsicHeight() : height;
+
+    Lock lock = TransformationUtils.getBitmapDrawableLock();
+    lock.lock();
+    Bitmap result = bitmapPool.get(targetWidth, targetHeight, Bitmap.Config.ARGB_8888);
+    try {
+      Canvas canvas = new Canvas(result);
+      drawable.setBounds(0, 0, targetWidth, targetHeight);
+      drawable.draw(canvas);
+      canvas.setBitmap(null);
+    } finally {
+      lock.unlock();
+    }
+    return result;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformation.java
new file mode 100644
index 000000000..dee51f7a2
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformation.java
@@ -0,0 +1,99 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import java.security.MessageDigest;
+
+/**
+ * Applies a {@link Bitmap} {@link Transformation} to {@link Drawable}s by first attempting to
+ * convert the {@link Drawable} to a {@link Bitmap} and then running the {@link Transformation}
+ * on the converted {@link Bitmap}.
+ *
+ * <p>This class is relatively efficient for {@link BitmapDrawable} where the {@link Bitmap} is
+ * readily accessible. For non-{@link Bitmap} based {@link Drawable}s, this class must first try to
+ * draw the {@link Drawable} to a {@link Bitmap} using {@link android.graphics.Canvas}, which is
+ * less efficient. {@link Drawable}s that implement {@link android.graphics.drawable.Animatable}
+ * will fail with an exception. {@link Drawable}s that return <= 0 for
+ * {@link Drawable#getIntrinsicHeight()} and/or {@link Drawable#getIntrinsicWidth()} will fail
+ * with an exception if the requested size is
+ * {@link com.bumptech.glide.request.target.Target#SIZE_ORIGINAL}. {@link Drawable}s without
+ * intrinsic dimensions are drawn using the dimensions provided in
+ * {@link Transformation#transform(Context, Resource, int, int)}. As a result, they may be
+ * transformed incorrectly or in unexpected ways.
+ */
+public class DrawableTransformation implements Transformation<Drawable> {
+
+  private final Transformation<Bitmap> wrapped;
+  private final boolean isRequired;
+
+  public DrawableTransformation(Transformation<Bitmap> wrapped, boolean isRequired) {
+    this.wrapped = wrapped;
+    this.isRequired = isRequired;
+  }
+
+  @SuppressWarnings("unchecked")
+  public Transformation<BitmapDrawable> asBitmapDrawable() {
+    return (Transformation<BitmapDrawable>) (Transformation<?>) this;
+  }
+
+  @NonNull
+  @Override
+  public Resource<Drawable> transform(@NonNull Context context,
+      @NonNull Resource<Drawable> resource, int outWidth, int outHeight) {
+    BitmapPool bitmapPool = Glide.get(context).getBitmapPool();
+    Drawable drawable = resource.get();
+    Resource<Bitmap> bitmapResourceToTransform =
+        DrawableToBitmapConverter.convert(bitmapPool, drawable, outWidth, outHeight);
+    if (bitmapResourceToTransform == null) {
+      if (isRequired) {
+        throw new IllegalArgumentException("Unable to convert " + drawable + " to a Bitmap");
+      } else {
+        return resource;
+      }
+    }
+    Resource<Bitmap> transformedBitmapResource =
+        wrapped.transform(context, bitmapResourceToTransform, outWidth, outHeight);
+
+    if (transformedBitmapResource.equals(bitmapResourceToTransform)) {
+      transformedBitmapResource.recycle();
+      return resource;
+    } else {
+      return newDrawableResource(context, transformedBitmapResource);
+    }
+  }
+
+  // It's clearer to cast the result in a separate line from obtaining it.
+  @SuppressWarnings({"unchecked", "PMD.UnnecessaryLocalBeforeReturn"})
+  private Resource<Drawable> newDrawableResource(
+      Context context, Resource<Bitmap> transformed) {
+    Resource<? extends Drawable> result =
+        LazyBitmapDrawableResource.obtain(context.getResources(), transformed);
+    return (Resource<Drawable>) result;
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (o instanceof DrawableTransformation) {
+      DrawableTransformation other = (DrawableTransformation) o;
+      return wrapped.equals(other.wrapped);
+    }
+    return false;
+  }
+
+  @Override
+  public int hashCode() {
+    return wrapped.hashCode();
+  }
+
+  @Override
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
+    wrapped.updateDiskCacheKey(messageDigest);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ExifInterfaceImageHeaderParser.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ExifInterfaceImageHeaderParser.java
new file mode 100644
index 000000000..92152d778
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ExifInterfaceImageHeaderParser.java
@@ -0,0 +1,54 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.media.ExifInterface;
+import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.annotation.RequiresApi;
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.util.ByteBufferUtil;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+
+/**
+ * Uses {@link ExifInterface} to parse orientation data.
+ *
+ * <p>ExifInterface supports the HEIF format on OMR1+. Glide's {@link DefaultImageHeaderParser}
+ * doesn't currently support HEIF. In the future we should reconcile these two classes, but for
+ * now this is a simple way to ensure that HEIF files are oriented correctly on platforms where
+ * they're supported.
+ */
+@RequiresApi(Build.VERSION_CODES.O_MR1)
+public final class ExifInterfaceImageHeaderParser implements ImageHeaderParser {
+
+  @NonNull
+  @Override
+  public ImageType getType(@NonNull InputStream is) throws IOException {
+    return ImageType.UNKNOWN;
+  }
+
+  @NonNull
+  @Override
+  public ImageType getType(@NonNull ByteBuffer byteBuffer) throws IOException {
+    return ImageType.UNKNOWN;
+  }
+
+  @Override
+  public int getOrientation(@NonNull InputStream is, @NonNull ArrayPool byteArrayPool)
+      throws IOException {
+    ExifInterface exifInterface = new ExifInterface(is);
+    int result = exifInterface.getAttributeInt(
+            ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);
+    if (result == ExifInterface.ORIENTATION_UNDEFINED) {
+      return ImageHeaderParser.UNKNOWN_ORIENTATION;
+    }
+    return result;
+  }
+
+  @Override
+  public int getOrientation(@NonNull ByteBuffer byteBuffer, @NonNull ArrayPool byteArrayPool)
+      throws IOException {
+    return getOrientation(ByteBufferUtil.toStream(byteBuffer), byteArrayPool);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java
index c29ef691d..9c2ae89c1 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.load.resource.bitmap;
 
-import android.content.Context;
 import android.graphics.Bitmap;
 import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
@@ -15,26 +14,6 @@
   private static final String ID = "com.bumptech.glide.load.resource.bitmap.FitCenter";
   private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
 
-  public FitCenter() {
-    // Intentionally empty.
-  }
-
-  /**
-   * @deprecated Use {@link #FitCenter()}.
-   */
-  @Deprecated
-  public FitCenter(@SuppressWarnings("unused") Context context) {
-    this();
-  }
-
-  /**
-   * @deprecated Use {@link #FitCenter()}.
-   */
-  @Deprecated
-  public FitCenter(@SuppressWarnings("unused") BitmapPool bitmapPool) {
-    this();
-  }
-
   @Override
   protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,
       int outHeight) {
@@ -52,7 +31,7 @@ public int hashCode() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     messageDigest.update(ID_BYTES);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java
new file mode 100644
index 000000000..1991d205f
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java
@@ -0,0 +1,118 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.annotation.TargetApi;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.os.Build;
+import android.util.Log;
+import com.bumptech.glide.load.DecodeFormat;
+import java.io.File;
+
+/**
+ * State and constants for interacting with {@link android.graphics.Bitmap.Config#HARDWARE} on
+ * Android O+.
+ */
+final class HardwareConfigState {
+  /**
+   * The minimum size in pixels a {@link Bitmap} must be in both dimensions to be created with the
+   * {@link Bitmap.Config#HARDWARE} configuration.
+   *
+   * <p>This is a quick check that lets us skip wasting FDs (see {@link #FD_SIZE_LIST}) on small
+   * {@link Bitmap}s with relatively low memory costs.
+   *
+   * @see #FD_SIZE_LIST
+   */
+  private static final int MIN_HARDWARE_DIMENSION = 128;
+
+  /**
+   * Allows us to check to make sure we're not exceeding the FD limit for a process with hardware
+   * {@link Bitmap}s.
+   *
+   * <p>{@link Bitmap.Config#HARDWARE} {@link Bitmap}s require two FDs (depending on the driver).
+   * Processes have an FD limit of 1024 (at least on O). With sufficiently small {@link Bitmap}s
+   * and/or a sufficiently large {@link com.bumptech.glide.load.engine.cache.MemoryCache}, we can
+   * end up with enough {@link Bitmap}s in memory that we blow through the FD limit, which causes
+   * graphics errors, Binder errors, and a variety of crashes.
+   *
+   * <p>Calling list.size() should be relatively efficient (hopefully < 1ms on average) because
+   * /proc is an in-memory FS.
+   */
+  private static final File FD_SIZE_LIST = new File("/proc/self/fd");
+
+  /**
+   * Each FD check takes 1-2ms, so to avoid overhead, only check every N decodes. 50 is more or less
+   * arbitrary.
+   */
+  private static final int MINIMUM_DECODES_BETWEEN_FD_CHECKS = 50;
+
+  /**
+   * 700 with an error of 50 Bitmaps in between at two FDs each lets us use up to 800 FDs for
+   * hardware Bitmaps.
+   */
+  private static final int MAXIMUM_FDS_FOR_HARDWARE_CONFIGS = 700;
+
+  private volatile int decodesSinceLastFdCheck;
+  private volatile boolean isHardwareConfigAllowed = true;
+
+  private static volatile HardwareConfigState instance;
+
+  static HardwareConfigState getInstance() {
+    if (instance == null) {
+      synchronized (HardwareConfigState.class) {
+        if (instance == null) {
+          instance = new HardwareConfigState();
+        }
+      }
+    }
+    return instance;
+  }
+
+  private HardwareConfigState() {
+    // Singleton constructor.
+  }
+
+  @TargetApi(Build.VERSION_CODES.O)
+  @SuppressWarnings("deprecation")
+  boolean setHardwareConfigIfAllowed(
+      int targetWidth,
+      int targetHeight,
+      BitmapFactory.Options optionsWithScaling,
+      DecodeFormat decodeFormat,
+      boolean isHardwareConfigAllowed,
+      boolean isExifOrientationRequired) {
+    if (!isHardwareConfigAllowed
+        || Build.VERSION.SDK_INT < Build.VERSION_CODES.O
+        || isExifOrientationRequired) {
+      return false;
+    }
+
+    boolean result =
+        targetWidth >= MIN_HARDWARE_DIMENSION
+            && targetHeight >= MIN_HARDWARE_DIMENSION
+            // Make sure to call isFdSizeBelowHardwareLimit last because it has side affects.
+            && isFdSizeBelowHardwareLimit();
+
+    if (result) {
+      optionsWithScaling.inPreferredConfig = Bitmap.Config.HARDWARE;
+      optionsWithScaling.inMutable = false;
+    }
+    return result;
+  }
+
+  private synchronized boolean isFdSizeBelowHardwareLimit() {
+    if (++decodesSinceLastFdCheck >= MINIMUM_DECODES_BETWEEN_FD_CHECKS) {
+      decodesSinceLastFdCheck = 0;
+      int currentFds = FD_SIZE_LIST.list().length;
+      isHardwareConfigAllowed = currentFds < MAXIMUM_FDS_FOR_HARDWARE_CONFIGS;
+
+      if (!isHardwareConfigAllowed && Log.isLoggable(Downsampler.TAG, Log.WARN)) {
+        Log.w(Downsampler.TAG,
+            "Excluding HARDWARE bitmap config because we're over the file descriptor limit"
+                + ", file descriptors " + currentFds
+                + ", limit " + MAXIMUM_FDS_FOR_HARDWARE_CONFIGS);
+      }
+    }
+
+    return isHardwareConfigAllowed;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java
index 412c5cc5b..92855b5ba 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java
@@ -4,61 +4,90 @@
 import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
-import com.bumptech.glide.util.Util;
 
 /**
  * Lazily allocates a {@link android.graphics.drawable.BitmapDrawable} from a given
  * {@link android.graphics.Bitmap} on the first call to {@link #get()}.
  */
-public class LazyBitmapDrawableResource implements Resource<BitmapDrawable>,
+public final class LazyBitmapDrawableResource implements Resource<BitmapDrawable>,
     Initializable {
 
-  private final Bitmap bitmap;
   private final Resources resources;
-  private final BitmapPool bitmapPool;
+  private final Resource<Bitmap> bitmapResource;
 
+  /**
+   * @deprecated Use {@link #obtain(Resources, Resource)} instead, it can be unsafe to extract
+   * {@link Bitmap}s from their wrapped {@link Resource}.
+   */
+  @Deprecated
   public static LazyBitmapDrawableResource obtain(Context context, Bitmap bitmap) {
-    return obtain(context.getResources(), Glide.get(context).getBitmapPool(), bitmap);
+    return
+        (LazyBitmapDrawableResource)
+            obtain(
+                context.getResources(),
+                BitmapResource.obtain(bitmap, Glide.get(context).getBitmapPool()));
   }
 
+  /**
+   * @deprecated Use {@link #obtain(Resources, Resource)} instead, it can be unsafe to extract
+   * {@link Bitmap}s from their wrapped {@link Resource}.
+   */
+  @Deprecated
   public static LazyBitmapDrawableResource obtain(Resources resources, BitmapPool bitmapPool,
       Bitmap bitmap) {
-    return new LazyBitmapDrawableResource(resources, bitmapPool, bitmap);
+    return
+        (LazyBitmapDrawableResource) obtain(resources, BitmapResource.obtain(bitmap, bitmapPool));
   }
 
-  LazyBitmapDrawableResource(Resources resources, BitmapPool bitmapPool, Bitmap bitmap) {
+  @Nullable
+  public static Resource<BitmapDrawable> obtain(
+      @NonNull Resources resources, @Nullable Resource<Bitmap> bitmapResource) {
+    if (bitmapResource == null) {
+      return null;
+    }
+    return new LazyBitmapDrawableResource(resources, bitmapResource);
+
+  }
+
+  private LazyBitmapDrawableResource(@NonNull Resources resources,
+      @NonNull Resource<Bitmap> bitmapResource) {
     this.resources = Preconditions.checkNotNull(resources);
-    this.bitmapPool = Preconditions.checkNotNull(bitmapPool);
-    this.bitmap = Preconditions.checkNotNull(bitmap);
+    this.bitmapResource = Preconditions.checkNotNull(bitmapResource);
   }
 
+  @NonNull
   @Override
   public Class<BitmapDrawable> getResourceClass() {
     return BitmapDrawable.class;
   }
 
+  @NonNull
   @Override
   public BitmapDrawable get() {
-    return new BitmapDrawable(resources, bitmap);
+    return new BitmapDrawable(resources, bitmapResource.get());
   }
 
   @Override
   public int getSize() {
-    return Util.getBitmapByteSize(bitmap);
+    return bitmapResource.getSize();
   }
 
   @Override
   public void recycle() {
-    bitmapPool.put(bitmap);
+    bitmapResource.recycle();
   }
 
   @Override
   public void initialize() {
-    bitmap.prepareToDraw();
+    if (bitmapResource instanceof Initializable) {
+      ((Initializable) bitmapResource).initialize();
+    }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java
index 24f2f35ef..88ecc15a3 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java
@@ -17,6 +17,8 @@
  *  limitations under the License.
  */
 
+import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import java.io.FilterInputStream;
 import java.io.IOException;
@@ -63,12 +65,12 @@
   private int pos;
   private final ArrayPool byteArrayPool;
 
-  public RecyclableBufferedInputStream(InputStream in, ArrayPool byteArrayPool) {
+  public RecyclableBufferedInputStream(@NonNull InputStream in, @NonNull ArrayPool byteArrayPool) {
     this(in, byteArrayPool, ArrayPool.STANDARD_BUFFER_SIZE_BYTES);
   }
 
-  // Visible for testing
-  RecyclableBufferedInputStream(InputStream in, ArrayPool byteArrayPool,
+  @VisibleForTesting
+  RecyclableBufferedInputStream(@NonNull InputStream in, @NonNull ArrayPool byteArrayPool,
       int bufferSize) {
     super(in);
     this.byteArrayPool = byteArrayPool;
@@ -104,13 +106,15 @@ private static IOException streamClosed() throws IOException {
    * <p>Subsequent calls to {@link #mark(int)} will be obeyed and may cause the buffer size to
    * increase.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public synchronized void fixMarkLimit() {
     marklimit = buf.length;
   }
 
   public synchronized void release() {
     if (buf != null) {
-      byteArrayPool.put(buf, byte[].class);
+      byteArrayPool.put(buf);
       buf = null;
     }
   }
@@ -124,7 +128,7 @@ public synchronized void release() {
   @Override
   public void close() throws IOException {
     if (buf != null) {
-      byteArrayPool.put(buf, byte[].class);
+      byteArrayPool.put(buf);
       buf = null;
     }
     InputStream localIn = in;
@@ -166,7 +170,7 @@ private int fillbuf(InputStream localIn, byte[] localBuf) throws IOException {
       // Reassign buf, which will invalidate any local references
       // FIXME: what if buf was null?
       localBuf = buf = newbuf;
-      byteArrayPool.put(oldbuf, byte[].class);
+      byteArrayPool.put(oldbuf);
     } else if (markpos > 0) {
       System.arraycopy(localBuf, markpos, localBuf, 0, localBuf.length - markpos);
     }
@@ -266,7 +270,8 @@ public synchronized int read() throws IOException {
    *                                   occurs.
    */
   @Override
-  public synchronized int read(byte[] buffer, int offset, int byteCount) throws IOException {
+  public synchronized int read(@NonNull byte[] buffer, int offset, int byteCount)
+      throws IOException {
     // Use local ref since buf may be invalidated by an unsynchronized close()
     byte[] localBuf = buf;
     if (localBuf == null) {
@@ -356,31 +361,32 @@ public synchronized void reset() throws IOException {
    * Skips {@code byteCount} bytes in this stream. Subsequent calls to {@link #read} will not return
    * these bytes unless {@link #reset} is used.
    *
-   * @param byteCount the number of bytes to skip. {@link #skip} does nothing and returns 0 if
+   * @param byteCount the number of bytes to skip. This method does nothing and returns 0 if
    *                  {@code byteCount} is less than zero.
    * @return the number of bytes actually skipped.
    * @throws IOException if this stream is closed or another IOException occurs.
    */
   @Override
   public synchronized long skip(long byteCount) throws IOException {
+    if (byteCount < 1) {
+      return 0;
+    }
     // Use local refs since buf and in may be invalidated by an unsynchronized close()
     byte[] localBuf = buf;
-    InputStream localIn = in;
     if (localBuf == null) {
       throw streamClosed();
     }
-    if (byteCount < 1) {
-      return 0;
-    }
+    InputStream localIn = in;
     if (localIn == null) {
       throw streamClosed();
     }
 
     if (count - pos >= byteCount) {
-      pos += byteCount;
+      pos = (int) (pos + byteCount);
       return byteCount;
     }
-    long read = count - pos;
+    // See https://errorprone.info/bugpattern/IntLongMath.
+    long read = (long) count - pos;
     pos = count;
 
     if (markpos != -1 && byteCount <= marklimit) {
@@ -388,7 +394,8 @@ public synchronized long skip(long byteCount) throws IOException {
         return read;
       }
       if (count - pos >= byteCount - read) {
-        pos += byteCount - read;
+        // See https://errorprone.info/bugpattern/NarrowingCompoundAssignment.
+        pos = (int) (pos + byteCount - read);
         return byteCount;
       }
       // Couldn't get all the bytes, skip what we read.
@@ -403,10 +410,10 @@ public synchronized long skip(long byteCount) throws IOException {
    * An exception thrown when a mark can no longer be obeyed because the underlying buffer size is
    * smaller than the amount of data read after the mark position.
    */
-  public static class InvalidMarkException extends IOException {
+  static class InvalidMarkException extends IOException {
     private static final long serialVersionUID = -4338378848813561757L;
 
-    public InvalidMarkException(String detailMessage) {
+    InvalidMarkException(String detailMessage) {
       super(detailMessage);
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ResourceBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ResourceBitmapDecoder.java
new file mode 100644
index 000000000..3ef5b5b3e
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ResourceBitmapDecoder.java
@@ -0,0 +1,57 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.content.ContentResolver;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.resource.drawable.ResourceDrawableDecoder;
+import com.bumptech.glide.request.target.Target;
+
+/**
+ * Decodes {@link Bitmap}s from resource ids.
+ *
+ * <p>The framework will decode some resources as {@link Drawable}s that do not wrap
+ * {@link Bitmap}s. This decoder will attempt to return a {@link Bitmap} for those
+ * {@link Drawable}s anyway by drawing the {@link Drawable} to a {@link Canvas}s using
+ * the {@link Drawable}'s intrinsic bounds or the dimensions provided to
+ * {@link #decode(Object, int, int, Options)}.
+ *
+ * <p>For non-{@link Bitmap} {@link Drawable}s that return <= 0 for
+ * {@link Drawable#getIntrinsicWidth()} and/or {@link Drawable#getIntrinsicHeight()}, this
+ * decoder will fail if the width and height provided to {@link #decode(Object, int, int, Options)}
+ * are {@link Target#SIZE_ORIGINAL}.
+ */
+public class ResourceBitmapDecoder implements ResourceDecoder<Uri, Bitmap> {
+
+  private final ResourceDrawableDecoder drawableDecoder;
+  private final BitmapPool bitmapPool;
+
+  public ResourceBitmapDecoder(ResourceDrawableDecoder drawableDecoder, BitmapPool bitmapPool) {
+    this.drawableDecoder = drawableDecoder;
+    this.bitmapPool = bitmapPool;
+  }
+
+  @Override
+  public boolean handles(@NonNull Uri source, @NonNull Options options) {
+    return ContentResolver.SCHEME_ANDROID_RESOURCE.equals(source.getScheme());
+  }
+
+  @Nullable
+  @Override
+  public Resource<Bitmap> decode(@NonNull Uri source, int width, int height,
+      @NonNull Options options) {
+    Resource<Drawable> drawableResource = drawableDecoder.decode(source, width, height, options);
+    if (drawableResource == null) {
+      return null;
+    }
+    Drawable drawable = drawableResource.get();
+    return DrawableToBitmapConverter.convert(bitmapPool, drawable, width, height);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java
index be3e804a2..ae5552152 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java
@@ -1,10 +1,10 @@
 package com.bumptech.glide.load.resource.bitmap;
 
-import android.content.Context;
 import android.graphics.Bitmap;
 import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Util;
 import java.nio.ByteBuffer;
 import java.security.MessageDigest;
 
@@ -26,47 +26,29 @@ public RoundedCorners(int roundingRadius) {
     this.roundingRadius = roundingRadius;
   }
 
-  /**
-   * @param roundingRadius the corner radius (in device-specific pixels).
-   * @throws IllegalArgumentException if rounding radius is 0 or less.
-   *
-   * @deprecated Use {@link #RoundedCorners(int)}
-   */
-  @Deprecated
-  public RoundedCorners(@SuppressWarnings("unused") BitmapPool bitmapPool, int roundingRadius) {
-    this(roundingRadius);
-  }
-
-  /**
-   * @param roundingRadius the corner radius (in device-specific pixels).
-   * @throws IllegalArgumentException if rounding radius is 0 or less.
-   *
-   * @deprecated Use {@link #RoundedCorners(int)}
-   */
-  @Deprecated
-  public RoundedCorners(@SuppressWarnings("unused") Context context, int roundingRadius) {
-    this(roundingRadius);
-  }
-
   @Override
   protected Bitmap transform(
       @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {
-    return TransformationUtils.roundedCorners(pool, toTransform, outWidth, outHeight,
-        roundingRadius);
+    return TransformationUtils.roundedCorners(pool, toTransform, roundingRadius);
   }
 
   @Override
   public boolean equals(Object o) {
-    return (o instanceof RoundedCorners) && ((RoundedCorners) o).roundingRadius == roundingRadius;
+    if (o instanceof RoundedCorners) {
+      RoundedCorners other = (RoundedCorners) o;
+      return roundingRadius == other.roundingRadius;
+    }
+    return false;
   }
 
   @Override
   public int hashCode() {
-    return ID.hashCode() + roundingRadius;
+    return Util.hashCode(ID.hashCode(),
+        Util.hashCode(roundingRadius));
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     messageDigest.update(ID_BYTES);
 
     byte[] radiusData = ByteBuffer.allocate(4).putInt(roundingRadius).array();
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java
index 78ec0ff8b..00cc6f3c1 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
@@ -25,12 +26,13 @@ public StreamBitmapDecoder(Downsampler downsampler, ArrayPool byteArrayPool) {
   }
 
   @Override
-  public boolean handles(InputStream source, Options options) throws IOException {
+  public boolean handles(@NonNull InputStream source, @NonNull Options options) {
     return downsampler.handles(source);
   }
 
   @Override
-  public Resource<Bitmap> decode(InputStream source, int width, int height, Options options)
+  public Resource<Bitmap> decode(@NonNull InputStream source, int width, int height,
+      @NonNull Options options)
       throws IOException {
 
     // Use to fix the mark limit to avoid allocating buffers that fit entire images.
@@ -74,7 +76,7 @@ public boolean handles(InputStream source, Options options) throws IOException {
     private final RecyclableBufferedInputStream bufferedStream;
     private final ExceptionCatchingInputStream exceptionStream;
 
-    public UntrustedCallbacks(RecyclableBufferedInputStream bufferedStream,
+    UntrustedCallbacks(RecyclableBufferedInputStream bufferedStream,
         ExceptionCatchingInputStream exceptionStream) {
       this.bufferedStream = bufferedStream;
       this.exceptionStream = exceptionStream;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
index e7abbb8ab..1c4d4812c 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
 import android.graphics.BitmapShader;
 import android.graphics.Canvas;
 import android.graphics.Color;
@@ -13,12 +14,15 @@
 import android.media.ExifInterface;
 import android.os.Build;
 import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
 import android.util.Log;
+import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
 import java.util.Arrays;
-import java.util.List;
+import java.util.HashSet;
+import java.util.Set;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.locks.Condition;
 import java.util.concurrent.locks.Lock;
@@ -27,6 +31,8 @@
 /**
  * A class with methods to efficiently resize Bitmaps.
  */
+// Legacy Public APIs.
+@SuppressWarnings("WeakerAccess")
 public final class TransformationUtils {
   private static final String TAG = "TransformationUtils";
   public static final int PAINT_FLAGS = Paint.DITHER_FLAG | Paint.FILTER_BITMAP_FLAG;
@@ -36,19 +42,52 @@
   private static final Paint CIRCLE_CROP_BITMAP_PAINT;
 
   // See #738.
-  private static final List<String> MODELS_REQUIRING_BITMAP_LOCK =
-      Arrays.asList(
-          "XT1097",
-          "XT1085");
+  private static final Set<String> MODELS_REQUIRING_BITMAP_LOCK =
+      new HashSet<>(
+          Arrays.asList(
+              // Moto X gen 2
+              "XT1085",
+              "XT1092",
+              "XT1093",
+              "XT1094",
+              "XT1095",
+              "XT1096",
+              "XT1097",
+              "XT1098",
+              // Moto G gen 1
+              "XT1031",
+              "XT1028",
+              "XT937C",
+              "XT1032",
+              "XT1008",
+              "XT1033",
+              "XT1035",
+              "XT1034",
+              "XT939G",
+              "XT1039",
+              "XT1040",
+              "XT1042",
+              "XT1045",
+              // Moto G gen 2
+              "XT1063",
+              "XT1064",
+              "XT1068",
+              "XT1069",
+              "XT1072",
+              "XT1077",
+              "XT1078",
+              "XT1079"
+          )
+      );
+
   /**
-   * https://github.com/bumptech/glide/issues/738 On some devices (Moto X with android 5.1) bitmap
-   * drawing is not thread safe.
+   * https://github.com/bumptech/glide/issues/738 On some devices, bitmap drawing is not thread
+   * safe.
    * This lock only locks for these specific devices. For other types of devices the lock is always
    * available and therefore does not impact performance
    */
   private static final Lock BITMAP_DRAWABLE_LOCK =
       MODELS_REQUIRING_BITMAP_LOCK.contains(Build.MODEL)
-          && Build.VERSION.SDK_INT == Build.VERSION_CODES.LOLLIPOP_MR1
           ? new ReentrantLock() : new NoLock();
 
   static {
@@ -83,20 +122,23 @@ public static Bitmap centerCrop(@NonNull BitmapPool pool, @NonNull Bitmap inBitm
     }
     // From ImageView/Bitmap.createScaledBitmap.
     final float scale;
-    float dx = 0, dy = 0;
+    final float dx;
+    final float dy;
     Matrix m = new Matrix();
     if (inBitmap.getWidth() * height > width * inBitmap.getHeight()) {
       scale = (float) height / (float) inBitmap.getHeight();
       dx = (width - inBitmap.getWidth() * scale) * 0.5f;
+      dy = 0;
     } else {
       scale = (float) width / (float) inBitmap.getWidth();
+      dx = 0;
       dy = (height - inBitmap.getHeight() * scale) * 0.5f;
     }
 
     m.setScale(scale, scale);
     m.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
 
-    Bitmap result = pool.get(width, height, getSafeConfig(inBitmap));
+    Bitmap result = pool.get(width, height, getNonNullConfig(inBitmap));
     // We don't add or remove alpha, so keep the alpha setting of the Bitmap we were given.
     TransformationUtils.setAlpha(inBitmap, result);
 
@@ -127,11 +169,10 @@ public static Bitmap fitCenter(@NonNull BitmapPool pool, @NonNull Bitmap inBitma
     final float heightPercentage = height / (float) inBitmap.getHeight();
     final float minPercentage = Math.min(widthPercentage, heightPercentage);
 
-    // take the floor of the target width/height, not round. If the matrix
-    // passed into drawBitmap rounds differently, we want to slightly
-    // overdraw, not underdraw, to avoid artifacts from bitmap reuse.
-    final int targetWidth = (int) (minPercentage * inBitmap.getWidth());
-    final int targetHeight = (int) (minPercentage * inBitmap.getHeight());
+    // Round here in case we've decoded exactly the image we want, but take the floor below to
+    // avoid a line of garbage or blank pixels in images.
+    int targetWidth = Math.round(minPercentage * inBitmap.getWidth());
+    int targetHeight = Math.round(minPercentage * inBitmap.getHeight());
 
     if (inBitmap.getWidth() == targetWidth && inBitmap.getHeight() == targetHeight) {
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
@@ -140,7 +181,13 @@ public static Bitmap fitCenter(@NonNull BitmapPool pool, @NonNull Bitmap inBitma
       return inBitmap;
     }
 
-    Bitmap.Config config = getSafeConfig(inBitmap);
+    // Take the floor of the target width/height, not round. If the matrix
+    // passed into drawBitmap rounds differently, we want to slightly
+    // overdraw, not underdraw, to avoid artifacts from bitmap reuse.
+    targetWidth = (int) (minPercentage * inBitmap.getWidth());
+    targetHeight = (int) (minPercentage * inBitmap.getHeight());
+
+    Bitmap.Config config = getNonNullConfig(inBitmap);
     Bitmap toReuse = pool.get(targetWidth, targetHeight, config);
 
     // We don't add or remove alpha, so keep the alpha setting of the Bitmap we were given.
@@ -172,7 +219,7 @@ public static Bitmap fitCenter(@NonNull BitmapPool pool, @NonNull Bitmap inBitma
    * height is larger than the given dimensions
    */
   public static Bitmap centerInside(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap, int width,
-                                 int height) {
+      int height) {
     if (inBitmap.getWidth() <= width && inBitmap.getHeight() <= height) {
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
         Log.v(TAG, "requested target size larger or equal to input, returning input");
@@ -264,12 +311,13 @@ public static int getExifOrientationDegrees(int exifOrientation) {
    */
   public static Bitmap rotateImageExif(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap,
       int exifOrientation) {
-    final Matrix matrix = new Matrix();
-    initializeMatrixForRotation(exifOrientation, matrix);
-    if (matrix.isIdentity()) {
+    if (!isExifOrientationRequired(exifOrientation)) {
       return inBitmap;
     }
 
+    final Matrix matrix = new Matrix();
+    initializeMatrixForRotation(exifOrientation, matrix);
+
     // From Bitmap.createBitmap.
     final RectF newRect = new RectF(0, 0, inBitmap.getWidth(), inBitmap.getHeight());
     matrix.mapRect(newRect);
@@ -277,7 +325,7 @@ public static Bitmap rotateImageExif(@NonNull BitmapPool pool, @NonNull Bitmap i
     final int newWidth = Math.round(newRect.width());
     final int newHeight = Math.round(newRect.height());
 
-    Bitmap.Config config = getSafeConfig(inBitmap);
+    Bitmap.Config config = getNonNullConfig(inBitmap);
     Bitmap result = pool.get(newWidth, newHeight, config);
 
     matrix.postTranslate(-newRect.left, -newRect.top);
@@ -286,6 +334,25 @@ public static Bitmap rotateImageExif(@NonNull BitmapPool pool, @NonNull Bitmap i
     return result;
   }
 
+  /**
+   * Returns {@code true} if the given exif orientation indicates that a transformation is necessary
+   * and {@code false} otherwise.
+   */
+  public static boolean isExifOrientationRequired(int exifOrientation) {
+    switch (exifOrientation) {
+      case ExifInterface.ORIENTATION_FLIP_HORIZONTAL:
+      case ExifInterface.ORIENTATION_ROTATE_180:
+      case ExifInterface.ORIENTATION_FLIP_VERTICAL:
+      case ExifInterface.ORIENTATION_TRANSPOSE:
+      case ExifInterface.ORIENTATION_ROTATE_90:
+      case ExifInterface.ORIENTATION_TRANSVERSE:
+      case ExifInterface.ORIENTATION_ROTATE_270:
+        return true;
+      default:
+        return false;
+    }
+  }
+
   /**
    * Crop the image to a circle and resize to the specified width/height.  The circle crop will
    * have the same width and height equal to the min-edge of the result image.
@@ -318,7 +385,8 @@ public static Bitmap circleCrop(@NonNull BitmapPool pool, @NonNull Bitmap inBitm
     // Alpha is required for this transformation.
     Bitmap toTransform = getAlphaSafeBitmap(pool, inBitmap);
 
-    Bitmap result = pool.get(destMinEdge, destMinEdge, Bitmap.Config.ARGB_8888);
+    Bitmap.Config outConfig = getAlphaSafeConfig(inBitmap);
+    Bitmap result = pool.get(destMinEdge, destMinEdge, outConfig);
     result.setHasAlpha(true);
 
     BITMAP_DRAWABLE_LOCK.lock();
@@ -340,21 +408,34 @@ public static Bitmap circleCrop(@NonNull BitmapPool pool, @NonNull Bitmap inBitm
     return result;
   }
 
-  private static Bitmap getAlphaSafeBitmap(@NonNull BitmapPool pool,
-      @NonNull Bitmap maybeAlphaSafe) {
-    if (Bitmap.Config.ARGB_8888.equals(maybeAlphaSafe.getConfig())) {
+  private static Bitmap getAlphaSafeBitmap(
+      @NonNull BitmapPool pool, @NonNull Bitmap maybeAlphaSafe) {
+    Bitmap.Config safeConfig = getAlphaSafeConfig(maybeAlphaSafe);
+    if (safeConfig.equals(maybeAlphaSafe.getConfig())) {
       return maybeAlphaSafe;
     }
 
-    Bitmap argbBitmap = pool.get(maybeAlphaSafe.getWidth(), maybeAlphaSafe.getHeight(),
-        Bitmap.Config.ARGB_8888);
-    new Canvas(argbBitmap).drawBitmap(maybeAlphaSafe, 0 /*left*/, 0 /*top*/, null /*pain*/);
+    Bitmap argbBitmap =
+        pool.get(maybeAlphaSafe.getWidth(), maybeAlphaSafe.getHeight(), safeConfig);
+    new Canvas(argbBitmap).drawBitmap(maybeAlphaSafe, 0 /*left*/, 0 /*top*/, null /*paint*/);
 
     // We now own this Bitmap. It's our responsibility to replace it in the pool outside this method
     // when we're finished with it.
     return argbBitmap;
   }
 
+  @NonNull
+  private static Config getAlphaSafeConfig(@NonNull Bitmap inBitmap) {
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+      // Avoid short circuiting the sdk check.
+      if (Bitmap.Config.RGBA_F16.equals(inBitmap.getConfig())) { // NOPMD
+        return Bitmap.Config.RGBA_F16;
+      }
+    }
+
+    return Bitmap.Config.ARGB_8888;
+  }
+
   /**
    * Creates a bitmap from a source bitmap and rounds the corners.
    *
@@ -364,16 +445,41 @@ private static Bitmap getAlphaSafeBitmap(@NonNull BitmapPool pool,
    * @param roundingRadius the corner radius to be applied (in device-specific pixels).
    * @return a {@link Bitmap} similar to inBitmap but with rounded corners.
    * @throws IllegalArgumentException if roundingRadius, width or height is 0 or less.
+   *
+   * @deprecated Width and height are unused and ignored. Use
+   * {@link #roundedCorners(BitmapPool, Bitmap, int)} instead.
+   */
+  @Deprecated
+  public static Bitmap roundedCorners(
+      @NonNull BitmapPool pool,
+      @NonNull Bitmap inBitmap,
+      @SuppressWarnings("unused") int width,
+      @SuppressWarnings("unused") int height,
+      int roundingRadius) {
+    return roundedCorners(pool, inBitmap, roundingRadius);
+  }
+
+  /**
+   * Creates a bitmap from a source bitmap and rounds the corners.
+   *
+   * <p>This method does <em>NOT</em> resize the given {@link Bitmap}, it only rounds it's corners.
+   * To both resize and round the corners of an image, consider
+   * {@link com.bumptech.glide.request.RequestOptions#transforms(Transformation[])} and/or
+   * {@link com.bumptech.glide.load.MultiTransformation}.
+   *
+   * @param inBitmap the source bitmap to use as a basis for the created bitmap.
+   * @param roundingRadius the corner radius to be applied (in device-specific pixels).
+   * @return a {@link Bitmap} similar to inBitmap but with rounded corners.
+   * @throws IllegalArgumentException if roundingRadius, width or height is 0 or less.
    */
-  public static Bitmap roundedCorners(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap,
-      int width, int height, int roundingRadius) {
-    Preconditions.checkArgument(width > 0, "width must be greater than 0.");
-    Preconditions.checkArgument(height > 0, "height must be greater than 0.");
+  public static Bitmap roundedCorners(
+      @NonNull BitmapPool pool, @NonNull Bitmap inBitmap, int roundingRadius) {
     Preconditions.checkArgument(roundingRadius > 0, "roundingRadius must be greater than 0.");
 
     // Alpha is required for this transformation.
+    Bitmap.Config safeConfig = getAlphaSafeConfig(inBitmap);
     Bitmap toTransform = getAlphaSafeBitmap(pool, inBitmap);
-    Bitmap result = pool.get(width, height, Bitmap.Config.ARGB_8888);
+    Bitmap result = pool.get(toTransform.getWidth(), toTransform.getHeight(), safeConfig);
 
     result.setHasAlpha(true);
 
@@ -405,7 +511,8 @@ private static void clear(Canvas canvas) {
     canvas.setBitmap(null);
   }
 
-  private static Bitmap.Config getSafeConfig(Bitmap bitmap) {
+  @NonNull
+  private static Bitmap.Config getNonNullConfig(@NonNull Bitmap bitmap) {
     return bitmap.getConfig() != null ? bitmap.getConfig() : Bitmap.Config.ARGB_8888;
   }
 
@@ -421,7 +528,7 @@ private static void applyMatrix(@NonNull Bitmap inBitmap, @NonNull Bitmap target
     }
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static void initializeMatrixForRotation(int exifOrientation, Matrix matrix) {
     switch (exifOrientation) {
       case ExifInterface.ORIENTATION_FLIP_HORIZONTAL:
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/UnitBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/UnitBitmapDecoder.java
new file mode 100644
index 000000000..63e804bb1
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/UnitBitmapDecoder.java
@@ -0,0 +1,57 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.util.Util;
+
+/**
+ * Passes through a (hopefully) non-owned {@link Bitmap} as a {@link Bitmap} based {@link Resource}
+ * so that the given {@link Bitmap} is not recycled.
+ */
+public final class UnitBitmapDecoder implements ResourceDecoder<Bitmap, Bitmap> {
+
+  @Override
+  public boolean handles(@NonNull Bitmap source, @NonNull Options options) {
+    return true;
+  }
+
+  @Override
+  public Resource<Bitmap> decode(@NonNull Bitmap source, int width, int height,
+      @NonNull Options options) {
+    return new NonOwnedBitmapResource(source);
+  }
+
+  private static final class NonOwnedBitmapResource implements Resource<Bitmap> {
+
+    private final Bitmap bitmap;
+
+    NonOwnedBitmapResource(@NonNull Bitmap bitmap) {
+      this.bitmap = bitmap;
+    }
+
+    @NonNull
+    @Override
+    public Class<Bitmap> getResourceClass() {
+      return Bitmap.class;
+    }
+
+    @NonNull
+    @Override
+    public Bitmap get() {
+      return bitmap;
+    }
+
+    @Override
+    public int getSize() {
+      return Util.getBitmapByteSize(bitmap);
+    }
+
+    @Override
+    public void recycle() {
+      // Do nothing.
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
index 98d9a0e59..226765e2d 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
@@ -1,18 +1,9 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.content.Context;
-import android.graphics.Bitmap;
-import android.media.MediaMetadataRetriever;
 import android.os.ParcelFileDescriptor;
 import com.bumptech.glide.Glide;
-import com.bumptech.glide.load.Option;
-import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.security.MessageDigest;
 
 /**
  * An {@link com.bumptech.glide.load.ResourceDecoder} that can decode a thumbnail frame
@@ -20,131 +11,21 @@
  * video.
  *
  * @see android.media.MediaMetadataRetriever
+ *
+ * @deprecated Use {@link VideoDecoder#parcel(BitmapPool)} instead. This class may be removed and
+ * {@link VideoDecoder} may become final in a future version of Glide.
  */
-public class VideoBitmapDecoder implements ResourceDecoder<ParcelFileDescriptor, Bitmap> {
-  /**
-   * A constant indicating we should use whatever frame we consider best, frequently not the first
-   * frame.
-   */
-  public static final long DEFAULT_FRAME = -1;
-
-  /**
-   * A long indicating the time position (in microseconds) of the target frame which will be
-   * retrieved. {@link android.media.MediaMetadataRetriever#getFrameAtTime(long)} is used to
-   * extract the video frame.
-   *
-   * <p>When retrieving the frame at the given time position, there is no guarantee that the data
-   * source has a frame located at the position. When this happens, a frame nearby will be returned.
-   * If the long is negative, time position and option will ignored, and any frame that the
-   * implementation considers as representative may be returned.
-   */
-  public static final Option<Long> TARGET_FRAME = Option.disk(
-      "com.bumptech.glide.load.resource.bitmap.VideoBitmapDecode.TargetFrame", DEFAULT_FRAME,
-      new Option.CacheKeyUpdater<Long>() {
-        private final ByteBuffer buffer = ByteBuffer.allocate(Long.SIZE / Byte.SIZE);
-        @Override
-        public void update(byte[] keyBytes, Long value, MessageDigest messageDigest) {
-          messageDigest.update(keyBytes);
-          synchronized (buffer) {
-            buffer.position(0);
-            messageDigest.update(buffer.putLong(value).array());
-          }
-        }
-      });
-
-  /**
-   * An integer indicating the frame option used to retrieve a target frame.
-   *
-   * <p>This option will be ignored if {@link #TARGET_FRAME} is not set or is set to
-   * {@link #DEFAULT_FRAME}.
-   *
-   * @see MediaMetadataRetriever#getFrameAtTime(long, int)
-   */
-  public static final Option<Integer> FRAME_OPTION = Option.disk(
-      "com.bumptech.glide.load.resource.bitmap.VideoBitmapDecode.FrameOption",
-      null /*defaultValue*/,
-      new Option.CacheKeyUpdater<Integer>() {
-        private final ByteBuffer buffer = ByteBuffer.allocate(Integer.SIZE / Byte.SIZE);
-        @Override
-        public void update(byte[] keyBytes, Integer value, MessageDigest messageDigest) {
-          if (value == null) {
-            return;
-          }
-          messageDigest.update(keyBytes);
-          synchronized (buffer) {
-            buffer.position(0);
-            messageDigest.update(buffer.putInt(value).array());
-          }
-        }
-      }
-  );
-
-  private static final MediaMetadataRetrieverFactory DEFAULT_FACTORY =
-      new MediaMetadataRetrieverFactory();
-
-  private final BitmapPool bitmapPool;
-  private final MediaMetadataRetrieverFactory factory;
+@Deprecated
+public class VideoBitmapDecoder extends VideoDecoder<ParcelFileDescriptor> {
 
+  @SuppressWarnings("unused")
   public VideoBitmapDecoder(Context context) {
     this(Glide.get(context).getBitmapPool());
   }
 
+  // Public API
+  @SuppressWarnings("WeakerAccess")
   public VideoBitmapDecoder(BitmapPool bitmapPool) {
-    this(bitmapPool, DEFAULT_FACTORY);
-  }
-
-  // Visible for testing.
-  VideoBitmapDecoder(BitmapPool bitmapPool, MediaMetadataRetrieverFactory factory) {
-    this.bitmapPool = bitmapPool;
-    this.factory = factory;
-  }
-
-  @Override
-  public boolean handles(ParcelFileDescriptor data, Options options) {
-    MediaMetadataRetriever retriever = factory.build();
-    try {
-      retriever.setDataSource(data.getFileDescriptor());
-      return true;
-    } catch (RuntimeException e) {
-      // Throws a generic runtime exception when given invalid data.
-      return false;
-    } finally {
-      retriever.release();
-    }
-  }
-
-  @Override
-  public Resource<Bitmap> decode(ParcelFileDescriptor resource, int outWidth, int outHeight,
-      Options options) throws IOException {
-    long frameTimeMicros = options.get(TARGET_FRAME);
-    if (frameTimeMicros < 0 && frameTimeMicros != DEFAULT_FRAME) {
-      throw new IllegalArgumentException(
-          "Requested frame must be non-negative, or DEFAULT_FRAME, given: " + frameTimeMicros);
-    }
-    Integer frameOption = options.get(FRAME_OPTION);
-
-    final Bitmap result;
-    MediaMetadataRetriever mediaMetadataRetriever = factory.build();
-    try {
-      mediaMetadataRetriever.setDataSource(resource.getFileDescriptor());
-      if (frameTimeMicros == DEFAULT_FRAME) {
-        result = mediaMetadataRetriever.getFrameAtTime();
-      } else if (frameOption == null) {
-        result = mediaMetadataRetriever.getFrameAtTime(frameTimeMicros);
-      } else {
-        result = mediaMetadataRetriever.getFrameAtTime(frameTimeMicros, frameOption);
-      }
-    } finally {
-      mediaMetadataRetriever.release();
-    }
-    resource.close();
-    return BitmapResource.obtain(result, bitmapPool);
-  }
-
-  // Visible for testing.
-  static class MediaMetadataRetrieverFactory {
-    public MediaMetadataRetriever build() {
-      return new MediaMetadataRetriever();
-    }
+    super(bitmapPool, new ParcelFileDescriptorInitializer());
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoDecoder.java
new file mode 100644
index 000000000..19f192417
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoDecoder.java
@@ -0,0 +1,299 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.annotation.TargetApi;
+import android.content.res.AssetFileDescriptor;
+import android.graphics.Bitmap;
+import android.media.MediaMetadataRetriever;
+import android.os.Build;
+import android.os.Build.VERSION_CODES;
+import android.os.ParcelFileDescriptor;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
+import android.util.Log;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.request.target.Target;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.security.MessageDigest;
+
+/**
+ * Decodes video data to Bitmaps from {@link ParcelFileDescriptor}s and
+ * {@link AssetFileDescriptor}s.
+ *
+ * @param <T> The type of data, currently either {@link ParcelFileDescriptor} or
+ * {@link AssetFileDescriptor}.
+ */
+public class VideoDecoder<T> implements ResourceDecoder<T, Bitmap> {
+  private static final String TAG = "VideoDecoder";
+
+  /**
+   * A constant indicating we should use whatever frame we consider best, frequently not the first
+   * frame.
+   */
+  public static final long DEFAULT_FRAME = -1;
+
+  /** Matches the behavior of {@link MediaMetadataRetriever#getFrameAtTime(long)}. */
+  @VisibleForTesting
+  static final int DEFAULT_FRAME_OPTION = MediaMetadataRetriever.OPTION_CLOSEST_SYNC;
+
+  /**
+   * A long indicating the time position (in microseconds) of the target frame which will be
+   * retrieved. {@link android.media.MediaMetadataRetriever#getFrameAtTime(long)} is used to
+   * extract the video frame.
+   *
+   * <p>When retrieving the frame at the given time position, there is no guarantee that the data
+   * source has a frame located at the position. When this happens, a frame nearby will be returned.
+   * If the long is negative, time position and option will ignored, and any frame that the
+   * implementation considers as representative may be returned.
+   */
+  public static final Option<Long> TARGET_FRAME = Option.disk(
+      "com.bumptech.glide.load.resource.bitmap.VideoBitmapDecode.TargetFrame", DEFAULT_FRAME,
+      new Option.CacheKeyUpdater<Long>() {
+        private final ByteBuffer buffer = ByteBuffer.allocate(Long.SIZE / Byte.SIZE);
+
+        @Override
+        public void update(@NonNull byte[] keyBytes, @NonNull Long value,
+            @NonNull MessageDigest messageDigest) {
+          messageDigest.update(keyBytes);
+          synchronized (buffer) {
+            buffer.position(0);
+            messageDigest.update(buffer.putLong(value).array());
+          }
+        }
+      });
+
+  /**
+   * An integer indicating the frame option used to retrieve a target frame.
+   *
+   * <p>This option will be ignored if {@link #TARGET_FRAME} is not set or is set to
+   * {@link #DEFAULT_FRAME}.
+   *
+   * @see MediaMetadataRetriever#getFrameAtTime(long, int)
+   */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public static final Option<Integer> FRAME_OPTION = Option.disk(
+      "com.bumptech.glide.load.resource.bitmap.VideoBitmapDecode.FrameOption",
+      /*defaultValue=*/ MediaMetadataRetriever.OPTION_CLOSEST_SYNC,
+      new Option.CacheKeyUpdater<Integer>() {
+        private final ByteBuffer buffer = ByteBuffer.allocate(Integer.SIZE / Byte.SIZE);
+
+        @Override
+        public void update(@NonNull byte[] keyBytes, @NonNull Integer value,
+            @NonNull MessageDigest messageDigest) {
+          //noinspection ConstantConditions public API, people could have been doing it wrong
+          if (value == null) {
+            return;
+          }
+          messageDigest.update(keyBytes);
+          synchronized (buffer) {
+            buffer.position(0);
+            messageDigest.update(buffer.putInt(value).array());
+          }
+        }
+      }
+  );
+
+  private static final MediaMetadataRetrieverFactory DEFAULT_FACTORY =
+      new MediaMetadataRetrieverFactory();
+
+  private final MediaMetadataRetrieverInitializer<T> initializer;
+  private final BitmapPool bitmapPool;
+  private final MediaMetadataRetrieverFactory factory;
+
+  public static ResourceDecoder<AssetFileDescriptor, Bitmap> asset(BitmapPool bitmapPool) {
+    return new VideoDecoder<>(bitmapPool, new AssetFileDescriptorInitializer());
+  }
+
+  public static ResourceDecoder<ParcelFileDescriptor, Bitmap> parcel(BitmapPool bitmapPool) {
+    return new VideoDecoder<>(bitmapPool, new ParcelFileDescriptorInitializer());
+  }
+
+  VideoDecoder(
+      BitmapPool bitmapPool, MediaMetadataRetrieverInitializer<T> initializer) {
+    this(bitmapPool, initializer, DEFAULT_FACTORY);
+  }
+
+  @VisibleForTesting
+  VideoDecoder(
+      BitmapPool bitmapPool,
+      MediaMetadataRetrieverInitializer<T> initializer,
+      MediaMetadataRetrieverFactory factory) {
+    this.bitmapPool = bitmapPool;
+    this.initializer = initializer;
+    this.factory = factory;
+  }
+
+  @Override
+  public boolean handles(@NonNull T data, @NonNull Options options) {
+    // Calling setDataSource is expensive so avoid doing so unless we're actually called.
+    // For non-videos this isn't any cheaper, but for videos it safes the redundant call and
+    // 50-100ms.
+    return true;
+  }
+
+  @Override
+  public Resource<Bitmap> decode(
+      @NonNull T resource, int outWidth, int outHeight, @NonNull Options options)
+      throws IOException {
+    long frameTimeMicros = options.get(TARGET_FRAME);
+    if (frameTimeMicros < 0 && frameTimeMicros != DEFAULT_FRAME) {
+      throw new IllegalArgumentException(
+          "Requested frame must be non-negative, or DEFAULT_FRAME, given: " + frameTimeMicros);
+    }
+    Integer frameOption = options.get(FRAME_OPTION);
+    if (frameOption == null) {
+      frameOption = DEFAULT_FRAME_OPTION;
+    }
+    DownsampleStrategy downsampleStrategy = options.get(DownsampleStrategy.OPTION);
+    if (downsampleStrategy == null) {
+      downsampleStrategy = DownsampleStrategy.DEFAULT;
+    }
+
+    final Bitmap result;
+    MediaMetadataRetriever mediaMetadataRetriever = factory.build();
+    try {
+      initializer.initialize(mediaMetadataRetriever, resource);
+      result =
+          decodeFrame(
+              mediaMetadataRetriever,
+              frameTimeMicros,
+              frameOption,
+              outWidth,
+              outHeight,
+              downsampleStrategy);
+
+    } catch (RuntimeException e) {
+      // MediaMetadataRetriever APIs throw generic runtime exceptions when given invalid data.
+      throw new IOException(e);
+    } finally {
+      mediaMetadataRetriever.release();
+    }
+
+    return BitmapResource.obtain(result, bitmapPool);
+  }
+
+  @Nullable
+  private static Bitmap decodeFrame(
+      MediaMetadataRetriever mediaMetadataRetriever,
+      long frameTimeMicros,
+      int frameOption,
+      int outWidth,
+      int outHeight,
+      DownsampleStrategy strategy) {
+    Bitmap result = null;
+    // Arguably we should handle the case where just width or just height is set to
+    // Target.SIZE_ORIGINAL. Up to and including OMR1, MediaMetadataRetriever defaults to setting
+    // the dimensions to the display width and height if they aren't specified (ie
+    // getScaledFrameAtTime is not used). Given that this is an optimization only if
+    // Target.SIZE_ORIGINAL is not used and not using getScaledFrameAtTime ever would match the
+    // behavior of Glide in all versions of Android prior to OMR1, it's probably fine for now.
+    if (Build.VERSION.SDK_INT >= VERSION_CODES.O_MR1
+        && outWidth != Target.SIZE_ORIGINAL
+        && outHeight != Target.SIZE_ORIGINAL
+        && strategy != DownsampleStrategy.NONE) {
+      result =
+          decodeScaledFrame(
+              mediaMetadataRetriever, frameTimeMicros, frameOption, outWidth, outHeight, strategy);
+    }
+
+    if (result == null) {
+      result = decodeOriginalFrame(mediaMetadataRetriever, frameTimeMicros, frameOption);
+    }
+
+    return result;
+  }
+
+  @TargetApi(Build.VERSION_CODES.O_MR1)
+  private static Bitmap decodeScaledFrame(
+      MediaMetadataRetriever mediaMetadataRetriever,
+      long frameTimeMicros,
+      int frameOption,
+      int outWidth,
+      int outHeight,
+      DownsampleStrategy strategy) {
+    try {
+      int originalWidth =
+          Integer.parseInt(
+              mediaMetadataRetriever.extractMetadata(
+                  MediaMetadataRetriever.METADATA_KEY_VIDEO_WIDTH));
+      int originalHeight =
+          Integer.parseInt(
+              mediaMetadataRetriever.extractMetadata(
+                  MediaMetadataRetriever.METADATA_KEY_VIDEO_HEIGHT));
+      int orientation =
+          Integer.parseInt(
+              mediaMetadataRetriever.extractMetadata(
+                  MediaMetadataRetriever.METADATA_KEY_VIDEO_ROTATION));
+
+      if (orientation == 90 || orientation == 270) {
+        int temp = originalWidth;
+        //noinspection SuspiciousNameCombination
+        originalWidth = originalHeight;
+        originalHeight = temp;
+      }
+
+      float scaleFactor =
+          strategy.getScaleFactor(originalWidth, originalHeight, outWidth, outHeight);
+
+      int decodeWidth = Math.round(scaleFactor * originalWidth);
+      int decodeHeight = Math.round(scaleFactor * originalHeight);
+
+      return mediaMetadataRetriever.getScaledFrameAtTime(
+          frameTimeMicros, frameOption, decodeWidth, decodeHeight);
+     } catch (Throwable t) {
+      // This is aggressive, but we'd rather catch errors caused by reading and/or parsing metadata
+      // here and fall back to just decoding the frame whenever possible. If the exception is thrown
+      // just from decoding the frame, then it will be thrown and exposed to callers by the method
+      // below.
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Exception trying to decode frame on oreo+", t);
+      }
+
+      return null;
+    }
+  }
+
+  private static Bitmap decodeOriginalFrame(
+      MediaMetadataRetriever mediaMetadataRetriever,
+      long frameTimeMicros,
+      int frameOption) {
+    return mediaMetadataRetriever.getFrameAtTime(frameTimeMicros, frameOption);
+  }
+
+  @VisibleForTesting
+  static class MediaMetadataRetrieverFactory {
+    public MediaMetadataRetriever build() {
+      return new MediaMetadataRetriever();
+    }
+  }
+
+  @VisibleForTesting
+  interface MediaMetadataRetrieverInitializer<T> {
+    void initialize(MediaMetadataRetriever retriever, T data);
+  }
+
+  private static final class AssetFileDescriptorInitializer
+      implements MediaMetadataRetrieverInitializer<AssetFileDescriptor> {
+
+    @Override
+    public void initialize(MediaMetadataRetriever retriever, AssetFileDescriptor data) {
+      retriever.setDataSource(data.getFileDescriptor(), data.getStartOffset(), data.getLength());
+    }
+  }
+
+  // Visible for VideoBitmapDecoder.
+  static final class ParcelFileDescriptorInitializer
+      implements MediaMetadataRetrieverInitializer<ParcelFileDescriptor> {
+
+    @Override
+    public void initialize(MediaMetadataRetriever retriever, ParcelFileDescriptor data) {
+      retriever.setDataSource(data.getFileDescriptor());
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bytes/ByteBufferRewinder.java b/library/src/main/java/com/bumptech/glide/load/resource/bytes/ByteBufferRewinder.java
index 41315a302..a154faafb 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bytes/ByteBufferRewinder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bytes/ByteBufferRewinder.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.load.resource.bytes;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.data.DataRewinder;
-import java.io.IOException;
 import java.nio.ByteBuffer;
 
 /**
@@ -10,12 +10,15 @@
 public class ByteBufferRewinder implements DataRewinder<ByteBuffer> {
   private final ByteBuffer buffer;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public ByteBufferRewinder(ByteBuffer buffer) {
     this.buffer = buffer;
   }
 
+  @NonNull
   @Override
-  public ByteBuffer rewindAndGet() throws IOException {
+  public ByteBuffer rewindAndGet() {
     buffer.position(0);
     return buffer;
   }
@@ -30,11 +33,13 @@ public void cleanup() {
    */
   public static class Factory implements DataRewinder.Factory<ByteBuffer> {
 
+    @NonNull
     @Override
     public DataRewinder<ByteBuffer> build(ByteBuffer data) {
       return new ByteBufferRewinder(data);
     }
 
+    @NonNull
     @Override
     public Class<ByteBuffer> getDataClass() {
       return ByteBuffer.class;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bytes/BytesResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bytes/BytesResource.java
index 6b0d7a2be..88068855d 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bytes/BytesResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bytes/BytesResource.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.resource.bytes;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.util.Preconditions;
 
@@ -13,12 +14,24 @@ public BytesResource(byte[] bytes) {
     this.bytes = Preconditions.checkNotNull(bytes);
   }
 
+  @NonNull
   @Override
   public Class<byte[]> getResourceClass() {
     return byte[].class;
   }
 
+  /**
+   * In most cases it will only be retrieved once (see linked methods).
+   *
+   * @return the same array every time, do not mutate the contents. Not a copy returned, because
+   * copying the array can be prohibitively expensive and/or lead to OOMs.
+   * @see com.bumptech.glide.load.ResourceEncoder
+   * @see com.bumptech.glide.load.resource.transcode.ResourceTranscoder
+   * @see com.bumptech.glide.request.SingleRequest#onResourceReady
+   */
+  @NonNull
   @Override
+  @SuppressWarnings("PMD.MethodReturnsInternalArray")
   public byte[] get() {
     return bytes;
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableDecoderCompat.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableDecoderCompat.java
new file mode 100644
index 000000000..68f81bd84
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableDecoderCompat.java
@@ -0,0 +1,78 @@
+package com.bumptech.glide.load.resource.drawable;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.content.res.Resources.Theme;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.Nullable;
+import android.support.v4.content.ContextCompat;
+import android.support.v4.content.res.ResourcesCompat;
+import android.support.v7.content.res.AppCompatResources;
+import android.support.v7.view.ContextThemeWrapper;
+
+/**
+ * Handles decoding Drawables with the v7 support library if present and falling back to the v4
+ * support library otherwise.
+ */
+public final class DrawableDecoderCompat {
+  private static volatile boolean shouldCallAppCompatResources = true;
+  private DrawableDecoderCompat() {
+    // Utility class.
+  }
+
+  /**
+   * See {@code getDrawable(Context, int, Theme)}.
+   */
+  public static Drawable getDrawable(
+      Context ourContext, Context targetContext, @DrawableRes int id) {
+    return getDrawable(ourContext, targetContext, id, /*theme=*/ null);
+  }
+
+  /**
+   * Loads a Drawable using {@link AppCompatResources} if available and {@link ResourcesCompat}
+   * otherwise, depending on whether or not the v7 support library is included in the application.
+   *
+   * @param theme Used instead of the {@link Theme} returned from the given {@link Context} if
+   * non-null when loading the {@link Drawable}.
+   */
+  public static Drawable getDrawable(
+      Context ourContext, @DrawableRes int id, @Nullable Theme theme) {
+    return getDrawable(ourContext, ourContext, id, theme);
+  }
+
+  private static Drawable getDrawable(
+      Context ourContext, Context targetContext, @DrawableRes int id, @Nullable Theme theme) {
+    try {
+      // Race conditions may cause us to attempt to load using v7 more than once. That's ok since
+      // this check is a modest optimization and the output will be correct anyway.
+      if (shouldCallAppCompatResources) {
+        return loadDrawableV7(targetContext, id, theme);
+      }
+    } catch (NoClassDefFoundError error) {
+      shouldCallAppCompatResources = false;
+    } catch (IllegalStateException e) {
+      if (ourContext.getPackageName().equals(targetContext.getPackageName())) {
+        throw e;
+      }
+      return ContextCompat.getDrawable(targetContext, id);
+    } catch (Resources.NotFoundException e) {
+      // Ignored, this can be thrown when drawable compat attempts to decode a canary resource. If
+      // that decode attempt fails, we still want to try with the v4 ResourcesCompat below.
+    }
+
+    return loadDrawableV4(targetContext, id, theme != null ? theme : targetContext.getTheme());
+  }
+
+  private static Drawable loadDrawableV7(Context context, @DrawableRes int id,
+      @Nullable Theme theme) {
+    Context resourceContext = theme != null ? new ContextThemeWrapper(context, theme) : context;
+    return AppCompatResources.getDrawable(resourceContext, id);
+  }
+
+  private static Drawable loadDrawableV4(
+      Context context, @DrawableRes int id, @Nullable Theme theme) {
+    Resources resources = context.getResources();
+    return ResourcesCompat.getDrawable(resources, id, theme);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java
index 163cbe50a..17b74f2cc 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java
@@ -2,6 +2,9 @@
 
 import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
+import android.graphics.drawable.Drawable.ConstantState;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
@@ -25,14 +28,19 @@ public DrawableResource(T drawable) {
     this.drawable = Preconditions.checkNotNull(drawable);
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
   @Override
   public final T get() {
+    @Nullable ConstantState state = drawable.getConstantState();
+    if (state == null) {
+      return drawable;
+    }
     // Drawables contain temporary state related to how they're being displayed
     // (alpha, color filter etc), so return a new copy each time.
     // If we ever return the original drawable, it's temporary state may be changed
     // and subsequent copies may end up with that temporary state. See #276.
-    return (T) drawable.getConstantState().newDrawable();
+    return (T) state.newDrawable();
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java
index 88eeeaffa..8eec67561 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.drawable;
 
 import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.TransitionOptions;
 import com.bumptech.glide.request.transition.DrawableCrossFadeFactory;
 import com.bumptech.glide.request.transition.TransitionFactory;
@@ -8,6 +9,8 @@
 /**
  * Contains {@link Drawable} specific animation options.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public final class DrawableTransitionOptions extends
     TransitionOptions<DrawableTransitionOptions, Drawable> {
 
@@ -16,6 +19,7 @@
    *
    * @see #crossFade()
    */
+  @NonNull
   public static DrawableTransitionOptions withCrossFade() {
     return new DrawableTransitionOptions().crossFade();
   }
@@ -25,6 +29,7 @@ public static DrawableTransitionOptions withCrossFade() {
    *
    * @see #crossFade(int)
    */
+  @NonNull
   public static DrawableTransitionOptions withCrossFade(int duration) {
     return new DrawableTransitionOptions().crossFade(duration);
   }
@@ -34,8 +39,9 @@ public static DrawableTransitionOptions withCrossFade(int duration) {
    *
    * @see #crossFade(DrawableCrossFadeFactory)
    */
+  @NonNull
   public static DrawableTransitionOptions withCrossFade(
-      DrawableCrossFadeFactory drawableCrossFadeFactory) {
+      @NonNull DrawableCrossFadeFactory drawableCrossFadeFactory) {
     return new DrawableTransitionOptions().crossFade(drawableCrossFadeFactory);
   }
 
@@ -44,8 +50,9 @@ public static DrawableTransitionOptions withCrossFade(
    *
    * @see #crossFade(DrawableCrossFadeFactory.Builder)
    */
+  @NonNull
   public static DrawableTransitionOptions withCrossFade(
-      DrawableCrossFadeFactory.Builder builder) {
+      @NonNull DrawableCrossFadeFactory.Builder builder) {
     return new DrawableTransitionOptions().crossFade(builder);
   }
 
@@ -54,8 +61,9 @@ public static DrawableTransitionOptions withCrossFade(
    *
    * @see com.bumptech.glide.GenericTransitionOptions#with(TransitionFactory)
    */
+  @NonNull
   public static DrawableTransitionOptions with(
-      TransitionFactory<Drawable> transitionFactory) {
+      @NonNull TransitionFactory<Drawable> transitionFactory) {
     return new DrawableTransitionOptions().transition(transitionFactory);
   }
 
@@ -63,6 +71,7 @@ public static DrawableTransitionOptions with(
    * Enables a cross fade animation between both the placeholder and the first resource and between
    * subsequent resources (if thumbnails are used).
    */
+  @NonNull
   public DrawableTransitionOptions crossFade() {
     return crossFade(new DrawableCrossFadeFactory.Builder());
   }
@@ -75,6 +84,7 @@ public DrawableTransitionOptions crossFade() {
    *     {@code DrawableCrossFadeFactory.Builder(int)}
    * @see com.bumptech.glide.request.transition.DrawableCrossFadeFactory.Builder
    */
+  @NonNull
   public DrawableTransitionOptions crossFade(int duration) {
     return crossFade(new DrawableCrossFadeFactory.Builder(duration));
   }
@@ -83,7 +93,9 @@ public DrawableTransitionOptions crossFade(int duration) {
    * Enables a cross fade animation between both the placeholder and the first resource and between
    * subsequent resources (if thumbnails are used).
    */
-  public DrawableTransitionOptions crossFade(DrawableCrossFadeFactory drawableCrossFadeFactory) {
+  @NonNull
+  public DrawableTransitionOptions crossFade(
+      @NonNull DrawableCrossFadeFactory drawableCrossFadeFactory) {
     return transition(drawableCrossFadeFactory);
   }
 
@@ -91,7 +103,8 @@ public DrawableTransitionOptions crossFade(DrawableCrossFadeFactory drawableCros
    * Enables a cross fade animation between both the placeholder and the first resource and between
    * subsequent resources (if thumbnails are used).
    */
-  public DrawableTransitionOptions crossFade(DrawableCrossFadeFactory.Builder builder) {
+  @NonNull
+  public DrawableTransitionOptions crossFade(@NonNull DrawableCrossFadeFactory.Builder builder) {
     return crossFade(builder.build());
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/NonOwnedDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/NonOwnedDrawableResource.java
new file mode 100644
index 000000000..2cba88462
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/NonOwnedDrawableResource.java
@@ -0,0 +1,42 @@
+package com.bumptech.glide.load.resource.drawable;
+
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.engine.Resource;
+
+/**
+ * Handles generic {@link Drawable} types where we may be uncertain of their size or type and
+ * where we don't know that it's safe for us to recycle or re-use the Drawable.
+ */
+final class NonOwnedDrawableResource extends DrawableResource<Drawable> {
+
+  @SuppressWarnings("unchecked")
+  @Nullable
+  static Resource<Drawable> newInstance(@Nullable Drawable drawable) {
+    return drawable != null ? new NonOwnedDrawableResource(drawable) : null;
+  }
+
+  private NonOwnedDrawableResource(Drawable drawable) {
+    super(drawable);
+  }
+
+  @NonNull
+  @SuppressWarnings("unchecked")
+  @Override
+  public Class<Drawable> getResourceClass() {
+    return (Class<Drawable>) drawable.getClass();
+  }
+
+  @Override
+  public int getSize() {
+    // 4 bytes per pixel for ARGB_8888 Bitmaps is something of a reasonable approximation. If
+    // there are no intrinsic bounds, we can fall back just to 1.
+    return Math.max(1, drawable.getIntrinsicWidth() * drawable.getIntrinsicHeight() * 4);
+  }
+
+  @Override
+  public void recycle() {
+    // Do nothing.
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/ResourceDrawableDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/ResourceDrawableDecoder.java
new file mode 100644
index 000000000..f37045c7f
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/ResourceDrawableDecoder.java
@@ -0,0 +1,91 @@
+package com.bumptech.glide.load.resource.drawable;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.Resource;
+import java.util.List;
+
+/**
+ * Decodes {@link Drawable}s given resource {@link Uri}s.
+ *
+ * <p>This is typically used as a fallback for resource types that either aren't Bitmaps (see #350)
+ * or for resource types that we can't obtain an {@link java.io.InputStream} for using a standard
+ * {@link ContentResolver}, including some types of application icons and resources loaded from
+ * other packages.
+ */
+public class ResourceDrawableDecoder implements ResourceDecoder<Uri, Drawable> {
+  // android.resource://<package_name>/<type>/<name>.
+  private static final int NAME_URI_PATH_SEGMENTS = 2;
+  private static final int TYPE_PATH_SEGMENT_INDEX = 0;
+  private static final int NAME_PATH_SEGMENT_INDEX = 1;
+  // android.resource://<package_name>/<resource_id>
+  private static final int ID_PATH_SEGMENTS = 1;
+  private static final int RESOURCE_ID_SEGMENT_INDEX = 0;
+
+  private final Context context;
+
+  public ResourceDrawableDecoder(Context context) {
+    this.context = context.getApplicationContext();
+  }
+
+  @Override
+  public boolean handles(@NonNull Uri source, @NonNull Options options) {
+    return source.getScheme().equals(ContentResolver.SCHEME_ANDROID_RESOURCE);
+  }
+
+  @Nullable
+  @Override
+  public Resource<Drawable> decode(@NonNull Uri source, int width, int height,
+      @NonNull Options options) {
+    @DrawableRes int resId = loadResourceIdFromUri(source);
+    String packageName = source.getAuthority();
+    Context targetContext = packageName.equals(context.getPackageName())
+        ? context : getContextForPackage(source, packageName);
+    // We can't get a theme from another application.
+    Drawable drawable = DrawableDecoderCompat.getDrawable(context, targetContext, resId);
+    return NonOwnedDrawableResource.newInstance(drawable);
+  }
+
+  @NonNull
+  private Context getContextForPackage(Uri source, String packageName) {
+    try {
+      return context.createPackageContext(packageName, /*flags=*/ 0);
+    } catch (NameNotFoundException e) {
+      throw new IllegalArgumentException(
+          "Failed to obtain context or unrecognized Uri format for: " + source, e);
+    }
+  }
+
+  @DrawableRes
+  private int loadResourceIdFromUri(Uri source) {
+    List<String> segments = source.getPathSegments();
+    @DrawableRes Integer result = null;
+    if (segments.size() == NAME_URI_PATH_SEGMENTS) {
+      String packageName = source.getAuthority();
+      String typeName = segments.get(TYPE_PATH_SEGMENT_INDEX);
+      String resourceName = segments.get(NAME_PATH_SEGMENT_INDEX);
+      result = context.getResources().getIdentifier(resourceName, typeName, packageName);
+    } else if (segments.size() == ID_PATH_SEGMENTS) {
+      try {
+        result = Integer.valueOf(segments.get(RESOURCE_ID_SEGMENT_INDEX));
+      } catch (NumberFormatException e) {
+        // Ignored.
+      }
+    }
+
+    if (result == null) {
+      throw new IllegalArgumentException("Unrecognized Uri format: " + source);
+    } else if (result == 0) {
+      throw new IllegalArgumentException("Failed to obtain resource id for: " + source);
+    }
+    return result;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/UnitDrawableDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/UnitDrawableDecoder.java
new file mode 100644
index 000000000..7ac9450c7
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/UnitDrawableDecoder.java
@@ -0,0 +1,25 @@
+package com.bumptech.glide.load.resource.drawable;
+
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.Resource;
+
+/**
+ * Passes through a {@link Drawable} as a {@link Drawable} based {@link Resource}.
+ */
+public class UnitDrawableDecoder implements ResourceDecoder<Drawable, Drawable> {
+  @Override
+  public boolean handles(@NonNull Drawable source, @NonNull Options options) {
+    return true;
+  }
+
+  @Nullable
+  @Override
+  public Resource<Drawable> decode(@NonNull Drawable source, int width, int height,
+      @NonNull Options options) {
+    return NonOwnedDrawableResource.newInstance(source);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/file/FileDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/file/FileDecoder.java
index e932f3caf..a5b3e13dd 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/file/FileDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/file/FileDecoder.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.resource.file;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
@@ -12,12 +13,13 @@
 public class FileDecoder implements ResourceDecoder<File, File> {
 
   @Override
-  public boolean handles(File source, Options options) {
+  public boolean handles(@NonNull File source, @NonNull Options options) {
     return true;
   }
 
   @Override
-  public Resource<File> decode(File source, int width, int height, Options options) {
+  public Resource<File> decode(@NonNull File source, int width, int height,
+      @NonNull Options options) {
     return new FileResource(source);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/file/FileResource.java b/library/src/main/java/com/bumptech/glide/load/resource/file/FileResource.java
index beeec792e..790f33b53 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/file/FileResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/file/FileResource.java
@@ -6,6 +6,8 @@
 /**
  * A simple {@link com.bumptech.glide.load.engine.Resource} that wraps a {@link File}.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public class FileResource extends SimpleResource<File> {
   public FileResource(File file) {
     super(file);
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
index 2b56d271e..dbab1827c 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
@@ -2,16 +2,19 @@
 
 import android.content.Context;
 import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 import android.util.Log;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.gifdecoder.GifHeader;
 import com.bumptech.glide.gifdecoder.GifHeaderParser;
 import com.bumptech.glide.gifdecoder.StandardGifDecoder;
+import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.ImageHeaderParser.ImageType;
 import com.bumptech.glide.load.ImageHeaderParserUtils;
-import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.Transformation;
@@ -32,24 +35,16 @@
 public class ByteBufferGifDecoder implements ResourceDecoder<ByteBuffer, GifDrawable> {
   private static final String TAG = "BufferGifDecoder";
   private static final GifDecoderFactory GIF_DECODER_FACTORY = new GifDecoderFactory();
-
-  /**
-   *  If set to {@code true}, disables this decoder
-   *  ({@link #handles(ByteBuffer, Options)} will return {@code false}). Defaults to
-   * {@code false}.
-   */
-  public static final Option<Boolean> DISABLE_ANIMATION = Option.memory(
-      "com.bumptech.glide.load.resource.gif.ByteBufferGifDecoder.DisableAnimation", false);
-
   private static final GifHeaderParserPool PARSER_POOL = new GifHeaderParserPool();
 
   private final Context context;
   private final List<ImageHeaderParser> parsers;
   private final GifHeaderParserPool parserPool;
-  private final BitmapPool bitmapPool;
   private final GifDecoderFactory gifDecoderFactory;
   private final GifBitmapProvider provider;
 
+  // Public API.
+  @SuppressWarnings("unused")
   public ByteBufferGifDecoder(Context context) {
     this(context, Glide.get(context).getRegistry().getImageHeaderParsers(),
         Glide.get(context).getBitmapPool(), Glide.get(context).getArrayPool());
@@ -61,7 +56,7 @@ public ByteBufferGifDecoder(
     this(context, parsers, bitmapPool, arrayPool, PARSER_POOL, GIF_DECODER_FACTORY);
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   ByteBufferGifDecoder(
       Context context,
       List<ImageHeaderParser> parsers,
@@ -71,57 +66,62 @@ public ByteBufferGifDecoder(
       GifDecoderFactory gifDecoderFactory) {
     this.context = context.getApplicationContext();
     this.parsers = parsers;
-    this.bitmapPool = bitmapPool;
     this.gifDecoderFactory = gifDecoderFactory;
     this.provider = new GifBitmapProvider(bitmapPool, arrayPool);
     this.parserPool = parserPool;
   }
 
   @Override
-  public boolean handles(ByteBuffer source, Options options) throws IOException {
-    return !options.get(DISABLE_ANIMATION)
+  public boolean handles(@NonNull ByteBuffer source, @NonNull Options options) throws IOException {
+    return !options.get(GifOptions.DISABLE_ANIMATION)
         && ImageHeaderParserUtils.getType(parsers, source) == ImageType.GIF;
   }
 
   @Override
-  public GifDrawableResource decode(ByteBuffer source, int width, int height, Options options) {
+  public GifDrawableResource decode(@NonNull ByteBuffer source, int width, int height,
+      @NonNull Options options) {
     final GifHeaderParser parser = parserPool.obtain(source);
     try {
-      return decode(source, width, height, parser);
+      return decode(source, width, height, parser, options);
     } finally {
       parserPool.release(parser);
     }
   }
 
-  private GifDrawableResource decode(ByteBuffer byteBuffer, int width, int height,
-      GifHeaderParser parser) {
+  @Nullable
+  private GifDrawableResource decode(
+      ByteBuffer byteBuffer, int width, int height, GifHeaderParser parser, Options options) {
     long startTime = LogTime.getLogTime();
-    final GifHeader header = parser.parseHeader();
-    if (header.getNumFrames() <= 0 || header.getStatus() != GifDecoder.STATUS_OK) {
-      // If we couldn't decode the GIF, we will end up with a frame count of 0.
-      return null;
-    }
+    try {
+      final GifHeader header = parser.parseHeader();
+      if (header.getNumFrames() <= 0 || header.getStatus() != GifDecoder.STATUS_OK) {
+        // If we couldn't decode the GIF, we will end up with a frame count of 0.
+        return null;
+      }
 
+      Bitmap.Config config = options.get(GifOptions.DECODE_FORMAT) == DecodeFormat.PREFER_RGB_565
+          ? Bitmap.Config.RGB_565 : Bitmap.Config.ARGB_8888;
 
-    int sampleSize = getSampleSize(header, width, height);
-    GifDecoder gifDecoder = gifDecoderFactory.build(provider, header, byteBuffer, sampleSize);
-    gifDecoder.advance();
-    Bitmap firstFrame = gifDecoder.getNextFrame();
-    if (firstFrame == null) {
-      return null;
-    }
+      int sampleSize = getSampleSize(header, width, height);
+      GifDecoder gifDecoder = gifDecoderFactory.build(provider, header, byteBuffer, sampleSize);
+      gifDecoder.setDefaultBitmapConfig(config);
+      gifDecoder.advance();
+      Bitmap firstFrame = gifDecoder.getNextFrame();
+      if (firstFrame == null) {
+        return null;
+      }
 
-    Transformation<Bitmap> unitTransformation = UnitTransformation.get();
+      Transformation<Bitmap> unitTransformation = UnitTransformation.get();
 
-    GifDrawable gifDrawable =
-        new GifDrawable(context, gifDecoder, bitmapPool, unitTransformation, width, height,
-            firstFrame);
+      GifDrawable gifDrawable =
+          new GifDrawable(context, gifDecoder, unitTransformation, width, height, firstFrame);
 
-    if (Log.isLoggable(TAG, Log.VERBOSE)) {
-      Log.v(TAG, "Decoded GIF from stream in " + LogTime.getElapsedMillis(startTime));
+      return new GifDrawableResource(gifDrawable);
+    } finally {
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+        Log.v(TAG, "Decoded GIF from stream in " + LogTime.getElapsedMillis(startTime));
+      }
     }
-
-    return new GifDrawableResource(gifDrawable);
   }
 
   private static int getSampleSize(GifHeader gifHeader, int targetWidth, int targetHeight) {
@@ -131,7 +131,7 @@ private static int getSampleSize(GifHeader gifHeader, int targetWidth, int targe
     // Although functionally equivalent to 0 for BitmapFactory, 1 is a safer default for our code
     // than 0.
     int sampleSize = Math.max(1, powerOfTwoSampleSize);
-    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+    if (Log.isLoggable(TAG, Log.VERBOSE) && sampleSize > 1) {
       Log.v(TAG, "Downsampling GIF"
           + ", sampleSize: " + sampleSize
           + ", target dimens: [" + targetWidth + "x" + targetHeight + "]"
@@ -140,19 +140,19 @@ private static int getSampleSize(GifHeader gifHeader, int targetWidth, int targe
     return sampleSize;
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class GifDecoderFactory {
-    public GifDecoder build(GifDecoder.BitmapProvider provider, GifHeader header,
+    GifDecoder build(GifDecoder.BitmapProvider provider, GifHeader header,
         ByteBuffer data, int sampleSize) {
       return new StandardGifDecoder(provider, header, data, sampleSize);
     }
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class GifHeaderParserPool {
     private final Queue<GifHeaderParser> pool = Util.createQueue(0);
 
-    public synchronized GifHeaderParser obtain(ByteBuffer buffer) {
+    synchronized GifHeaderParser obtain(ByteBuffer buffer) {
       GifHeaderParser result = pool.poll();
       if (result == null) {
         result = new GifHeaderParser();
@@ -160,7 +160,7 @@ public synchronized GifHeaderParser obtain(ByteBuffer buffer) {
       return result.setData(buffer);
     }
 
-    public synchronized void release(GifHeaderParser parser) {
+    synchronized void release(GifHeaderParser parser) {
       parser.clear();
       pool.offer(parser);
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java
index a9d231006..400530d79 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java
@@ -21,29 +21,32 @@
    * when requested.
    */
   public GifBitmapProvider(BitmapPool bitmapPool) {
-    this(bitmapPool, null /* arrayPool */);
+    this(bitmapPool, /*arrayPool=*/ null);
   }
 
   /**
    * Constructs an instance with a shared array pool. Arrays will be reused where
    * possible.
    */
-  public GifBitmapProvider(BitmapPool bitmapPool, ArrayPool arrayPool) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public GifBitmapProvider(BitmapPool bitmapPool, @Nullable ArrayPool arrayPool) {
     this.bitmapPool = bitmapPool;
     this.arrayPool = arrayPool;
   }
 
   @NonNull
   @Override
-  public Bitmap obtain(int width, int height, Bitmap.Config config) {
+  public Bitmap obtain(int width, int height, @NonNull Bitmap.Config config) {
     return bitmapPool.getDirty(width, height, config);
   }
 
   @Override
-  public void release(Bitmap bitmap) {
+  public void release(@NonNull Bitmap bitmap) {
     bitmapPool.put(bitmap);
   }
 
+  @NonNull
   @Override
   public byte[] obtainByteArray(int size) {
     if (arrayPool == null) {
@@ -52,15 +55,15 @@ public void release(Bitmap bitmap) {
     return arrayPool.get(size, byte[].class);
   }
 
-  @SuppressWarnings("PMD.UseVarargs")
   @Override
-  public void release(byte[] bytes) {
+  public void release(@NonNull byte[] bytes) {
     if (arrayPool == null) {
       return;
     }
-    arrayPool.put(bytes, byte[].class);
+    arrayPool.put(bytes);
   }
 
+  @NonNull
   @Override
   public int[] obtainIntArray(int size) {
     if (arrayPool == null) {
@@ -71,10 +74,10 @@ public void release(byte[] bytes) {
 
   @SuppressWarnings("PMD.UseVarargs")
   @Override
-  public void release(int[] array) {
+  public void release(@NonNull int[] array) {
     if (arrayPool == null) {
       return;
     }
-    arrayPool.put(array, int[].class);
+    arrayPool.put(array);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
index 5e6f98eed..cd0aa5248 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
@@ -12,6 +12,7 @@
 import android.graphics.Rect;
 import android.graphics.drawable.Animatable;
 import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
 import android.support.annotation.VisibleForTesting;
 import android.view.Gravity;
 import com.bumptech.glide.Glide;
@@ -29,13 +30,18 @@
   /**
    * A constant indicating that an animated drawable should loop continuously.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public static final int LOOP_FOREVER = -1;
   /**
    * A constant indicating that an animated drawable should loop for its default number of times.
    * For animated GIFs, this constant indicates the GIF should use the netscape loop count if
    * present.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public static final int LOOP_INTRINSIC = 0;
+  private static final int GRAVITY = Gravity.FILL;
 
   private final GifState state;
   /**
@@ -74,9 +80,40 @@
    * Constructor for GifDrawable.
    *
    * @param context             A context.
-   * @param bitmapPool          A {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool}
-   *                            that can be used to return the first frame when this drawable is
-   *                            recycled.
+   * @param bitmapPool          Ignored, see deprecation note.
+   * @param frameTransformation An {@link com.bumptech.glide.load.Transformation} that can be
+   *                            applied to each frame.
+   * @param targetFrameWidth    The desired width of the frames displayed by this drawable (the
+   *                            width of the view or
+   *                            {@link com.bumptech.glide.request.target.Target}
+   *                            this drawable is being loaded into).
+   * @param targetFrameHeight   The desired height of the frames displayed by this drawable (the
+   *                            height of the view or
+   *                            {@link com.bumptech.glide.request.target.Target}
+   *                            this drawable is being loaded into).
+   * @param gifDecoder          The decoder to use to decode GIF data.
+   * @param firstFrame          The decoded and transformed first frame of this GIF.
+   * @see #setFrameTransformation(com.bumptech.glide.load.Transformation, android.graphics.Bitmap)
+   *
+   * @deprecated Use {@link #GifDrawable(Context, GifDecoder, Transformation, int, int, Bitmap)}
+   */
+  @SuppressWarnings("deprecation")
+  @Deprecated
+  public GifDrawable(
+      Context context,
+      GifDecoder gifDecoder,
+      @SuppressWarnings("unused") BitmapPool bitmapPool,
+      Transformation<Bitmap> frameTransformation,
+      int targetFrameWidth,
+      int targetFrameHeight,
+      Bitmap firstFrame) {
+    this(context, gifDecoder, frameTransformation, targetFrameWidth, targetFrameHeight, firstFrame);
+  }
+
+   /**
+   * Constructor for GifDrawable.
+   *
+   * @param context             A context.
    * @param frameTransformation An {@link com.bumptech.glide.load.Transformation} that can be
    *                            applied to each frame.
    * @param targetFrameWidth    The desired width of the frames displayed by this drawable (the
@@ -91,12 +128,15 @@
    * @param firstFrame          The decoded and transformed first frame of this GIF.
    * @see #setFrameTransformation(com.bumptech.glide.load.Transformation, android.graphics.Bitmap)
    */
-  public GifDrawable(Context context, GifDecoder gifDecoder, BitmapPool bitmapPool,
-      Transformation<Bitmap> frameTransformation, int targetFrameWidth, int targetFrameHeight,
+  public GifDrawable(
+      Context context,
+      GifDecoder gifDecoder,
+      Transformation<Bitmap> frameTransformation,
+      int targetFrameWidth,
+      int targetFrameHeight,
       Bitmap firstFrame) {
     this(
         new GifState(
-            bitmapPool,
             new GifFrameLoader(
                 // TODO(b/27524013): Factor out this call to Glide.get()
                 Glide.get(context),
@@ -112,8 +152,8 @@ public GifDrawable(Context context, GifDecoder gifDecoder, BitmapPool bitmapPool
   }
 
   @VisibleForTesting
-  GifDrawable(GifFrameLoader frameLoader, BitmapPool bitmapPool, Paint paint) {
-    this(new GifState(bitmapPool, frameLoader));
+  GifDrawable(GifFrameLoader frameLoader, Paint paint) {
+    this(new GifState(frameLoader));
     this.paint = paint;
   }
 
@@ -125,6 +165,8 @@ public Bitmap getFirstFrame() {
     return state.frameLoader.getFirstFrame();
   }
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public void setFrameTransformation(Transformation<Bitmap> frameTransformation,
       Bitmap firstFrame) {
     state.frameLoader.setFrameTransformation(frameTransformation, firstFrame);
@@ -146,6 +188,8 @@ public int getFrameCount() {
    * Returns the current frame index in the range 0..{@link #getFrameCount()} - 1, or -1 if no frame
    * is displayed.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public int getFrameIndex() {
     return state.frameLoader.getCurrentIndex();
   }
@@ -157,6 +201,8 @@ private void resetLoopCount() {
   /**
    * Starts the animation from the first frame. Can only be called while animation is not running.
    */
+  // Public API.
+  @SuppressWarnings("unused")
   public void startFromFirstFrame() {
     Preconditions.checkArgument(!isRunning, "You cannot restart a currently running animation.");
     state.frameLoader.setNextStartFromFirstFrame();
@@ -237,14 +283,13 @@ protected void onBoundsChange(Rect bounds) {
   }
 
   @Override
-  public void draw(Canvas canvas) {
+  public void draw(@NonNull Canvas canvas) {
     if (isRecycled) {
       return;
     }
 
     if (applyGravity) {
-      Gravity.apply(GifState.GRAVITY, getIntrinsicWidth(), getIntrinsicHeight(), getBounds(),
-          getDestRect());
+      Gravity.apply(GRAVITY, getIntrinsicWidth(), getIntrinsicHeight(), getBounds(), getDestRect());
       applyGravity = false;
     }
 
@@ -282,9 +327,18 @@ public int getOpacity() {
     return PixelFormat.TRANSPARENT;
   }
 
+  // See #1087.
+  private Callback findCallback() {
+    Callback callback = getCallback();
+    while (callback instanceof Drawable) {
+      callback = ((Drawable) callback).getCallback();
+    }
+    return callback;
+  }
+
   @Override
   public void onFrameReady() {
-    if (getCallback() == null) {
+    if (findCallback() == null) {
       stop();
       invalidateSelf();
       return;
@@ -319,6 +373,8 @@ boolean isRecycled() {
     return isRecycled;
   }
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public void setLoopCount(int loopCount) {
     if (loopCount <= 0 && loopCount != LOOP_FOREVER && loopCount != LOOP_INTRINSIC) {
       throw new IllegalArgumentException("Loop count must be greater than 0, or equal to "
@@ -334,21 +390,21 @@ public void setLoopCount(int loopCount) {
     }
   }
 
-  static class GifState extends ConstantState {
-    static final int GRAVITY = Gravity.FILL;
-    final BitmapPool bitmapPool;
+  static final class GifState extends ConstantState {
+    @VisibleForTesting
     final GifFrameLoader frameLoader;
 
-    public GifState(BitmapPool bitmapPool, GifFrameLoader frameLoader) {
-      this.bitmapPool = bitmapPool;
+    GifState(GifFrameLoader frameLoader) {
       this.frameLoader = frameLoader;
     }
 
+    @NonNull
     @Override
     public Drawable newDrawable(Resources res) {
       return newDrawable();
     }
 
+    @NonNull
     @Override
     public Drawable newDrawable() {
       return new GifDrawable(this);
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableEncoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableEncoder.java
index f2f842381..e73f713dc 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableEncoder.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.resource.gif;
 
+import android.support.annotation.NonNull;
 import android.util.Log;
 import com.bumptech.glide.load.EncodeStrategy;
 import com.bumptech.glide.load.Options;
@@ -16,13 +17,15 @@
 public class GifDrawableEncoder implements ResourceEncoder<GifDrawable> {
   private static final String TAG = "GifEncoder";
 
+  @NonNull
   @Override
-  public EncodeStrategy getEncodeStrategy(Options options) {
+  public EncodeStrategy getEncodeStrategy(@NonNull Options options) {
     return EncodeStrategy.SOURCE;
   }
 
   @Override
-  public boolean encode(Resource<GifDrawable> data, File file, Options options) {
+  public boolean encode(@NonNull Resource<GifDrawable> data, @NonNull File file,
+      @NonNull Options options) {
     GifDrawable drawable = data.get();
     boolean success = false;
     try {
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java
index d0275e023..090f279b8 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.resource.gif;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.resource.drawable.DrawableResource;
 
@@ -8,10 +9,13 @@
  */
 public class GifDrawableResource extends DrawableResource<GifDrawable>
     implements Initializable {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public GifDrawableResource(GifDrawable drawable) {
     super(drawable);
   }
 
+  @NonNull
   @Override
   public Class<GifDrawable> getResourceClass() {
     return GifDrawable.class;
@@ -19,7 +23,7 @@ public GifDrawableResource(GifDrawable drawable) {
 
   @Override
   public int getSize() {
-   return drawable.getSize();
+    return drawable.getSize();
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java
index 06b1a4fb4..392661b1b 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java
@@ -2,6 +2,7 @@
 
 import android.content.Context;
 import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
@@ -22,27 +23,11 @@ public GifDrawableTransformation(Transformation<Bitmap> wrapped) {
     this.wrapped = Preconditions.checkNotNull(wrapped);
   }
 
-  /**
-   * @deprecated Use {@link #GifDrawableTransformation(Transformation)}.
-   */
-  @Deprecated
-  public GifDrawableTransformation(
-      @SuppressWarnings("unused") Context context, Transformation<Bitmap> wrapped) {
-    this(wrapped);
-  }
-
-  /**
-   * @deprecated Use {@link #GifDrawableTransformation(Transformation)}
-   */
-  @Deprecated
-  public GifDrawableTransformation(
-      Transformation<Bitmap> wrapped, @SuppressWarnings("unused") BitmapPool bitmapPool) {
-    this(wrapped);
-  }
-
+  @NonNull
   @Override
   public Resource<GifDrawable> transform(
-      Context context, Resource<GifDrawable> resource, int outWidth, int outHeight) {
+      @NonNull Context context, @NonNull Resource<GifDrawable> resource,
+      int outWidth, int outHeight) {
     GifDrawable drawable = resource.get();
 
     // The drawable needs to be initialized with the correct width and height in order for a view
@@ -78,7 +63,7 @@ public int hashCode() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     wrapped.updateDiskCacheKey(messageDigest);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
index 9ad656df5..c46775bd2 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
@@ -8,6 +8,9 @@
 import android.os.Looper;
 import android.os.Message;
 import android.os.SystemClock;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.RequestManager;
@@ -19,37 +22,39 @@
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.SimpleTarget;
 import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.signature.ObjectKey;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
 import java.nio.ByteBuffer;
-import java.security.MessageDigest;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.UUID;
 
 class GifFrameLoader {
   private final GifDecoder gifDecoder;
   private final Handler handler;
   private final List<FrameCallback> callbacks = new ArrayList<>();
-  @Synthetic final RequestManager requestManager;
+  @SuppressWarnings("WeakerAccess") @Synthetic final RequestManager requestManager;
   private final BitmapPool bitmapPool;
 
-  private boolean isRunning = false;
-  private boolean isLoadPending = false;
-  private boolean startFromFirstFrame = false;
+  private boolean isRunning;
+  private boolean isLoadPending;
+  private boolean startFromFirstFrame;
   private RequestBuilder<Bitmap> requestBuilder;
   private DelayTarget current;
   private boolean isCleared;
   private DelayTarget next;
   private Bitmap firstFrame;
   private Transformation<Bitmap> transformation;
+  private DelayTarget pendingTarget;
+  @Nullable
+  private GifFrameLoader.OnEveryFrameListener onEveryFrameListener;
 
   public interface FrameCallback {
     void onFrameReady();
   }
 
-  public GifFrameLoader(
+  GifFrameLoader(
       Glide glide,
       GifDecoder gifDecoder,
       int width,
@@ -106,10 +111,10 @@ void subscribe(FrameCallback frameCallback) {
     if (isCleared) {
       throw new IllegalStateException("Cannot subscribe to a cleared frame loader");
     }
-    boolean start = callbacks.isEmpty();
     if (callbacks.contains(frameCallback)) {
       throw new IllegalStateException("Cannot subscribe twice in a row");
     }
+    boolean start = callbacks.isEmpty();
     callbacks.add(frameCallback);
     if (start) {
       start();
@@ -182,6 +187,10 @@ void clear() {
       requestManager.clear(next);
       next = null;
     }
+    if (pendingTarget != null) {
+      requestManager.clear(pendingTarget);
+      pendingTarget = null;
+    }
     gifDecoder.clear();
     isCleared = true;
   }
@@ -195,9 +204,17 @@ private void loadNextFrame() {
       return;
     }
     if (startFromFirstFrame) {
+      Preconditions.checkArgument(
+          pendingTarget == null, "Pending target must be null when starting from the first frame");
       gifDecoder.resetFrameIndex();
       startFromFirstFrame = false;
     }
+    if (pendingTarget != null) {
+      DelayTarget temp = pendingTarget;
+      pendingTarget = null;
+      onFrameReady(temp);
+      return;
+    }
     isLoadPending = true;
     // Get the delay before incrementing the pointer because the delay indicates the amount of time
     // we want to spend on the current frame.
@@ -206,7 +223,7 @@ private void loadNextFrame() {
 
     gifDecoder.advance();
     next = new DelayTarget(handler, gifDecoder.getCurrentFrameIndex(), targetTime);
-    requestBuilder.clone().apply(signatureOf(new FrameSignature())).load(gifDecoder).into(next);
+    requestBuilder.apply(signatureOf(getFrameSignature())).load(gifDecoder).into(next);
   }
 
   private void recycleFirstFrame() {
@@ -219,14 +236,35 @@ private void recycleFirstFrame() {
   void setNextStartFromFirstFrame() {
     Preconditions.checkArgument(!isRunning, "Can't restart a running animation");
     startFromFirstFrame = true;
+    if (pendingTarget != null) {
+      requestManager.clear(pendingTarget);
+      pendingTarget = null;
+    }
   }
 
-  // Visible for testing.
+  @VisibleForTesting
+  void setOnEveryFrameReadyListener(@Nullable OnEveryFrameListener onEveryFrameListener) {
+    this.onEveryFrameListener = onEveryFrameListener;
+  }
+
+  @VisibleForTesting
   void onFrameReady(DelayTarget delayTarget) {
+    if (onEveryFrameListener != null) {
+      onEveryFrameListener.onFrameReady();
+    }
+    isLoadPending = false;
     if (isCleared) {
       handler.obtainMessage(FrameLoaderCallback.MSG_CLEAR, delayTarget).sendToTarget();
       return;
     }
+    // If we're not running, notifying here will recycle the frame that we might currently be
+    // showing, which breaks things (see #2526). We also can't discard this frame because we've
+    // already incremented the frame pointer and can't decode the same frame again. Instead we'll
+    // just hang on to this next frame until start() or clear() are called.
+    if (!isRunning) {
+      pendingTarget = delayTarget;
+      return;
+    }
 
     if (delayTarget.getResource() != null) {
       recycleFirstFrame();
@@ -243,13 +281,12 @@ void onFrameReady(DelayTarget delayTarget) {
       }
     }
 
-    isLoadPending = false;
     loadNextFrame();
   }
 
   private class FrameLoaderCallback implements Handler.Callback {
-    public static final int MSG_DELAY = 1;
-    public static final int MSG_CLEAR = 2;
+    static final int MSG_DELAY = 1;
+    static final int MSG_CLEAR = 2;
 
     @Synthetic
     FrameLoaderCallback() { }
@@ -268,7 +305,7 @@ public boolean handleMessage(Message msg) {
     }
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class DelayTarget extends SimpleTarget<Bitmap> {
     private final Handler handler;
     @Synthetic final int index;
@@ -286,7 +323,8 @@ Bitmap getResource() {
     }
 
     @Override
-    public void onResourceReady(Bitmap resource, Transition<? super Bitmap> transition) {
+    public void onResourceReady(@NonNull Bitmap resource,
+        @Nullable Transition<? super Bitmap> transition) {
       this.resource = resource;
       Message msg = handler.obtainMessage(FrameLoaderCallback.MSG_DELAY, this);
       handler.sendMessageAtTime(msg, targetTime);
@@ -299,40 +337,19 @@ public void onResourceReady(Bitmap resource, Transition<? super Bitmap> transiti
         .asBitmap()
         .apply(
             diskCacheStrategyOf(DiskCacheStrategy.NONE)
+                .useAnimationPool(true)
                 .skipMemoryCache(true)
                 .override(width, height));
   }
 
-  // Visible for testing.
-  static class FrameSignature implements Key {
-    private final UUID uuid;
-
-    public FrameSignature() {
-      this(UUID.randomUUID());
-    }
-
-    // VisibleForTesting.
-    FrameSignature(UUID uuid) {
-      this.uuid = uuid;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-      if (o instanceof FrameSignature) {
-        FrameSignature other = (FrameSignature) o;
-        return other.uuid.equals(uuid);
-      }
-      return false;
-    }
-
-    @Override
-    public int hashCode() {
-      return uuid.hashCode();
-    }
+  private static Key getFrameSignature() {
+    // Some devices seem to have crypto bugs that throw exceptions when you create a new UUID.
+    // See #1510.
+    return new ObjectKey(Math.random());
+  }
 
-    @Override
-    public void updateDiskCacheKey(MessageDigest messageDigest) {
-      throw new UnsupportedOperationException("Not implemented");
-    }
+  @VisibleForTesting
+  interface OnEveryFrameListener {
+    void onFrameReady();
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java
index 4e887ed11..0fa7e28d5 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.gif;
 
 import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
@@ -20,12 +21,13 @@ public GifFrameResourceDecoder(BitmapPool bitmapPool) {
   }
 
   @Override
-  public boolean handles(GifDecoder source, Options options) {
+  public boolean handles(@NonNull GifDecoder source, @NonNull Options options) {
     return true;
   }
 
   @Override
-  public Resource<Bitmap> decode(GifDecoder source, int width, int height, Options options) {
+  public Resource<Bitmap> decode(@NonNull GifDecoder source, int width, int height,
+      @NonNull Options options) {
     Bitmap bitmap = source.getNextFrame();
     return BitmapResource.obtain(bitmap, bitmapPool);
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifOptions.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifOptions.java
new file mode 100644
index 000000000..cb2f71e5e
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifOptions.java
@@ -0,0 +1,32 @@
+package com.bumptech.glide.load.resource.gif;
+
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceDecoder;
+
+/**
+ * Options related to decoding GIFs.
+ */
+public final class GifOptions {
+
+  /**
+   * Indicates the {@link com.bumptech.glide.load.DecodeFormat} that will be used in conjunction
+   * with the particular GIF to determine the {@link android.graphics.Bitmap.Config} to use when
+   * decoding frames of GIFs.
+   */
+  public static final Option<DecodeFormat> DECODE_FORMAT = Option.memory(
+      "com.bumptech.glide.load.resource.gif.GifOptions.DecodeFormat", DecodeFormat.DEFAULT);
+
+  /**
+   * If set to {@code true}, disables the GIF {@link com.bumptech.glide.load.ResourceDecoder}s
+   * ({@link ResourceDecoder#handles(Object, Options)} will return {@code false}). Defaults to
+   * {@code false}.
+   */
+  public static final Option<Boolean> DISABLE_ANIMATION = Option.memory(
+      "com.bumptech.glide.load.resource.gif.GifOptions.DisableAnimation", false);
+
+  private GifOptions() {
+    // Utility class.
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java
index baf4abc43..2cc3b848b 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java
@@ -1,10 +1,10 @@
 package com.bumptech.glide.load.resource.gif;
 
+import android.support.annotation.NonNull;
 import android.util.Log;
 import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.ImageHeaderParser.ImageType;
 import com.bumptech.glide.load.ImageHeaderParserUtils;
-import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
@@ -22,13 +22,6 @@
  */
 public class StreamGifDecoder implements ResourceDecoder<InputStream, GifDrawable> {
   private static final String TAG = "StreamGifDecoder";
-  /**
-   * If set to {@code true}, disables this decoder
-   * ({@link #handles(InputStream, Options)} will return {@code false}). Defaults to
-   * {@code false}.
-   */
-  public static final Option<Boolean> DISABLE_ANIMATION = Option.memory(
-      "com.bumptech.glide.load.resource.gif.ByteBufferGifDecoder.DisableAnimation", false);
 
   private final List<ImageHeaderParser> parsers;
   private final ResourceDecoder<ByteBuffer, GifDrawable> byteBufferDecoder;
@@ -42,14 +35,14 @@ public StreamGifDecoder(List<ImageHeaderParser> parsers, ResourceDecoder<ByteBuf
   }
 
   @Override
-  public boolean handles(InputStream source, Options options) throws IOException {
-    return !options.get(DISABLE_ANIMATION)
+  public boolean handles(@NonNull InputStream source, @NonNull Options options) throws IOException {
+    return !options.get(GifOptions.DISABLE_ANIMATION)
         && ImageHeaderParserUtils.getType(parsers, source, byteArrayPool) == ImageType.GIF;
   }
 
   @Override
-  public Resource<GifDrawable> decode(InputStream source, int width, int height,
-      Options options) throws IOException {
+  public Resource<GifDrawable> decode(@NonNull InputStream source, int width, int height,
+      @NonNull Options options) throws IOException {
     byte[] data = inputStreamToBytes(source);
     if (data == null) {
       return null;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java
index 5e8419a7c..9274b56ff 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java
@@ -1,6 +1,9 @@
 package com.bumptech.glide.load.resource.transcode;
 
 import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.bytes.BytesResource;
 import java.io.ByteArrayOutputStream;
@@ -19,13 +22,17 @@ public BitmapBytesTranscoder() {
     this(Bitmap.CompressFormat.JPEG, 100);
   }
 
-  public BitmapBytesTranscoder(Bitmap.CompressFormat compressFormat, int quality) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public BitmapBytesTranscoder(@NonNull Bitmap.CompressFormat compressFormat, int quality) {
     this.compressFormat = compressFormat;
     this.quality = quality;
   }
 
+  @Nullable
   @Override
-  public Resource<byte[]> transcode(Resource<Bitmap> toTranscode) {
+  public Resource<byte[]> transcode(@NonNull Resource<Bitmap> toTranscode,
+      @NonNull Options options) {
     ByteArrayOutputStream os = new ByteArrayOutputStream();
     toTranscode.get().compress(compressFormat, quality, os);
     toTranscode.recycle();
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java
index 9fbbd4c05..b9dc68bb5 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java
@@ -4,7 +4,9 @@
 import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
-import com.bumptech.glide.Glide;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.bitmap.LazyBitmapDrawableResource;
@@ -16,19 +18,30 @@
  */
 public class BitmapDrawableTranscoder implements ResourceTranscoder<Bitmap, BitmapDrawable> {
   private final Resources resources;
-  private final BitmapPool bitmapPool;
 
-  public BitmapDrawableTranscoder(Context context) {
-    this(context.getResources(), Glide.get(context).getBitmapPool());
+  // Public API.
+  @SuppressWarnings("unused")
+  public BitmapDrawableTranscoder(@NonNull Context context) {
+    this(context.getResources());
   }
 
-  public BitmapDrawableTranscoder(Resources resources, BitmapPool bitmapPool) {
+  /**
+   * @deprecated Use {@link #BitmapDrawableTranscoder(Resources)}, {@code bitmapPool} is unused.
+   */
+  @Deprecated
+  public BitmapDrawableTranscoder(
+      @NonNull Resources resources, @SuppressWarnings("unused") BitmapPool bitmapPool) {
+    this(resources);
+  }
+
+  public BitmapDrawableTranscoder(@NonNull Resources resources) {
     this.resources = Preconditions.checkNotNull(resources);
-    this.bitmapPool = Preconditions.checkNotNull(bitmapPool);
   }
 
+  @Nullable
   @Override
-  public Resource<BitmapDrawable> transcode(Resource<Bitmap> toTranscode) {
-    return LazyBitmapDrawableResource.obtain(resources, bitmapPool, toTranscode.get());
+  public Resource<BitmapDrawable> transcode(@NonNull Resource<Bitmap> toTranscode,
+      @NonNull Options options) {
+    return LazyBitmapDrawableResource.obtain(resources, toTranscode);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/DrawableBytesTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/DrawableBytesTranscoder.java
new file mode 100644
index 000000000..a37e16ff6
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/DrawableBytesTranscoder.java
@@ -0,0 +1,52 @@
+package com.bumptech.glide.load.resource.transcode;
+
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.resource.bitmap.BitmapResource;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
+
+/**
+ * Obtains {@code byte[]} from {@link BitmapDrawable}s by delegating to a
+ * {@link ResourceTranscoder} for {@link Bitmap}s to {@code byte[]}s.
+ */
+public final class DrawableBytesTranscoder implements ResourceTranscoder<Drawable, byte[]> {
+  private final BitmapPool bitmapPool;
+  private final ResourceTranscoder<Bitmap, byte[]> bitmapBytesTranscoder;
+  private final ResourceTranscoder<GifDrawable, byte[]> gifDrawableBytesTranscoder;
+
+  public DrawableBytesTranscoder(
+      @NonNull BitmapPool bitmapPool,
+      @NonNull ResourceTranscoder<Bitmap, byte[]> bitmapBytesTranscoder,
+      @NonNull ResourceTranscoder<GifDrawable, byte[]> gifDrawableBytesTranscoder) {
+    this.bitmapPool = bitmapPool;
+    this.bitmapBytesTranscoder = bitmapBytesTranscoder;
+    this.gifDrawableBytesTranscoder = gifDrawableBytesTranscoder;
+  }
+
+  @Nullable
+  @Override
+  public Resource<byte[]> transcode(@NonNull Resource<Drawable> toTranscode,
+      @NonNull Options options) {
+    Drawable drawable = toTranscode.get();
+    if (drawable instanceof BitmapDrawable) {
+      return bitmapBytesTranscoder.transcode(
+          BitmapResource.obtain(((BitmapDrawable) drawable).getBitmap(), bitmapPool), options);
+    } else if (drawable instanceof GifDrawable) {
+      return gifDrawableBytesTranscoder.transcode(toGifDrawableResource(toTranscode), options);
+    }
+    return null;
+  }
+
+  @SuppressWarnings("unchecked")
+  @NonNull
+  private static Resource<GifDrawable> toGifDrawableResource(@NonNull Resource<Drawable> resource) {
+    return (Resource<GifDrawable>) (Resource<?>) resource;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java
index 94ff7864d..69e82202d 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java
@@ -1,5 +1,8 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.bytes.BytesResource;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
@@ -12,8 +15,10 @@
  * the GIF from the {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
  */
 public class GifDrawableBytesTranscoder implements ResourceTranscoder<GifDrawable, byte[]> {
+  @Nullable
   @Override
-  public Resource<byte[]> transcode(Resource<GifDrawable> toTranscode) {
+  public Resource<byte[]> transcode(@NonNull Resource<GifDrawable> toTranscode,
+      @NonNull Options options) {
     GifDrawable gifData = toTranscode.get();
     ByteBuffer byteBuffer = gifData.getBuffer();
     return new BytesResource(ByteBufferUtil.toBytes(byteBuffer));
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java
index ad1c55c6e..fbd4631bd 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java
@@ -1,5 +1,8 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 
 /**
@@ -15,5 +18,6 @@
    *
    * @param toTranscode The resource to transcode.
    */
-  Resource<R> transcode(Resource<Z> toTranscode);
+  @Nullable
+  Resource<R> transcode(@NonNull Resource<Z> toTranscode, @NonNull Options options);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistry.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistry.java
index b632c35ad..9c907b65f 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistry.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayList;
 import java.util.List;
@@ -21,8 +22,9 @@
    * @param <Z>             The type of the resource that the transcoder transcodes from.
    * @param <R>             The type of the resource that the transcoder transcodes to.
    */
-  public synchronized <Z, R> void register(Class<Z> decodedClass, Class<R> transcodedClass,
-      ResourceTranscoder<Z, R> transcoder) {
+  public synchronized <Z, R> void register(
+      @NonNull Class<Z> decodedClass, @NonNull Class<R> transcodedClass,
+      @NonNull ResourceTranscoder<Z, R> transcoder) {
     transcoders.add(new Entry<>(decodedClass, transcodedClass, transcoder));
   }
 
@@ -35,9 +37,10 @@
    * @param <Z>             The type of the resource that the transcoder transcodes from.
    * @param <R>             The type of the resource that the transcoder transcodes to.
    */
+  @NonNull
   @SuppressWarnings("unchecked")
-  public synchronized <Z, R> ResourceTranscoder<Z, R> get(Class<Z> resourceClass,
-      Class<R> transcodedClass) {
+  public synchronized <Z, R> ResourceTranscoder<Z, R> get(
+      @NonNull Class<Z> resourceClass, @NonNull Class<R> transcodedClass) {
     // For example, there may be a transcoder that can convert a GifDrawable to a Drawable, which
     // will be caught above. However, if there is no registered transcoder, we can still just use
     // the UnitTranscoder to return the Drawable because the transcode class (Drawable) is
@@ -55,8 +58,9 @@
         "No transcoder registered to transcode from " + resourceClass + " to " + transcodedClass);
   }
 
-  public synchronized <Z, R> List<Class<R>> getTranscodeClasses(Class<Z> resourceClass,
-      Class<R> transcodeClass) {
+  @NonNull
+  public synchronized <Z, R> List<Class<R>> getTranscodeClasses(
+      @NonNull Class<Z> resourceClass, @NonNull Class<R> transcodeClass) {
     List<Class<R>> transcodeClasses = new ArrayList<>();
     // GifDrawable -> Drawable is just the UnitTranscoder, as is GifDrawable -> GifDrawable.
     if (transcodeClass.isAssignableFrom(resourceClass)) {
@@ -78,7 +82,8 @@
     private final Class<R> toClass;
     @Synthetic final ResourceTranscoder<Z, R> transcoder;
 
-    Entry(Class<Z> fromClass, Class<R> toClass, ResourceTranscoder<Z, R> transcoder) {
+    Entry(@NonNull Class<Z> fromClass, @NonNull Class<R> toClass,
+        @NonNull ResourceTranscoder<Z, R> transcoder) {
       this.fromClass = fromClass;
       this.toClass = toClass;
       this.transcoder = transcoder;
@@ -90,7 +95,7 @@
      * we can fulfill requests for a more generic parent class (like Drawable). As a result, we
      * check fromClass and toClass in different orders.
      */
-    public boolean handles(Class<?> fromClass, Class<?> toClass) {
+    public boolean handles(@NonNull Class<?> fromClass, @NonNull Class<?> toClass) {
       return this.fromClass.isAssignableFrom(fromClass) && toClass.isAssignableFrom(this.toClass);
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/UnitTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/UnitTranscoder.java
index 966e11ecf..45efdf5a1 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/UnitTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/UnitTranscoder.java
@@ -1,5 +1,8 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 
 /**
@@ -8,15 +11,16 @@
  * @param <Z> The type of the resource that will be transcoded from and to.
  */
 public class UnitTranscoder<Z> implements ResourceTranscoder<Z, Z> {
-  private static final UnitTranscoder<?> UNIT_TRANSCODER = new UnitTranscoder<Object>();
+  private static final UnitTranscoder<?> UNIT_TRANSCODER = new UnitTranscoder<>();
 
   @SuppressWarnings("unchecked")
   public static <Z> ResourceTranscoder<Z, Z> get() {
     return (ResourceTranscoder<Z, Z>) UNIT_TRANSCODER;
   }
 
+  @Nullable
   @Override
-  public Resource<Z> transcode(Resource<Z> toTranscode) {
+  public Resource<Z> transcode(@NonNull Resource<Z> toTranscode, @NonNull Options options) {
     return toTranscode;
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java b/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java
index fd88428e8..8bb528050 100644
--- a/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java
+++ b/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.manager;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.util.Util;
 import java.util.Collections;
 import java.util.Set;
@@ -27,7 +28,7 @@
    * avoid adding listeners multiple times. </p>
    */
   @Override
-  public void addListener(LifecycleListener listener) {
+  public void addListener(@NonNull LifecycleListener listener) {
     lifecycleListeners.add(listener);
 
     if (isDestroyed) {
@@ -40,7 +41,7 @@ public void addListener(LifecycleListener listener) {
   }
 
   @Override
-  public void removeListener(LifecycleListener listener) {
+  public void removeListener(@NonNull LifecycleListener listener) {
     lifecycleListeners.remove(listener);
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/manager/ApplicationLifecycle.java b/library/src/main/java/com/bumptech/glide/manager/ApplicationLifecycle.java
index 5911d5234..7bf69da7e 100644
--- a/library/src/main/java/com/bumptech/glide/manager/ApplicationLifecycle.java
+++ b/library/src/main/java/com/bumptech/glide/manager/ApplicationLifecycle.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.manager;
 
+import android.support.annotation.NonNull;
+
 /**
  * A {@link com.bumptech.glide.manager.Lifecycle} implementation for tracking and notifying
  * listeners of {@link android.app.Application} lifecycle events.
@@ -9,12 +11,12 @@
  */
 class ApplicationLifecycle implements Lifecycle {
   @Override
-  public void addListener(LifecycleListener listener) {
+  public void addListener(@NonNull LifecycleListener listener) {
     listener.onStart();
   }
 
   @Override
-  public void removeListener(LifecycleListener listener) {
+  public void removeListener(@NonNull LifecycleListener listener) {
     // Do nothing.
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java
index d2967bffa..bea4b3673 100644
--- a/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java
+++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java
@@ -1,35 +1,44 @@
 package com.bumptech.glide.manager;
 
+import android.annotation.SuppressLint;
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
+import android.support.annotation.NonNull;
+import android.util.Log;
+import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
 
 /**
  * Uses {@link android.net.ConnectivityManager} to identify connectivity changes.
  */
-class DefaultConnectivityMonitor implements ConnectivityMonitor {
+final class DefaultConnectivityMonitor implements ConnectivityMonitor {
+  private static final String TAG = "ConnectivityMonitor";
   private final Context context;
-  @Synthetic final ConnectivityListener listener;
+  @SuppressWarnings("WeakerAccess") @Synthetic final ConnectivityListener listener;
 
-  @Synthetic boolean isConnected;
+  @SuppressWarnings("WeakerAccess") @Synthetic boolean isConnected;
   private boolean isRegistered;
 
   private final BroadcastReceiver connectivityReceiver = new BroadcastReceiver() {
     @Override
-    public void onReceive(Context context, Intent intent) {
+    public void onReceive(@NonNull Context context, Intent intent) {
       boolean wasConnected = isConnected;
       isConnected = isConnected(context);
       if (wasConnected != isConnected) {
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "connectivity changed, isConnected: " + isConnected);
+        }
+
         listener.onConnectivityChanged(isConnected);
       }
     }
   };
 
-  public DefaultConnectivityMonitor(Context context, ConnectivityListener listener) {
+  DefaultConnectivityMonitor(@NonNull Context context, @NonNull ConnectivityListener listener) {
     this.context = context.getApplicationContext();
     this.listener = listener;
   }
@@ -39,10 +48,19 @@ private void register() {
       return;
     }
 
+    // Initialize isConnected.
     isConnected = isConnected(context);
-    context.registerReceiver(connectivityReceiver,
-        new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION));
-    isRegistered = true;
+    try {
+      // See #1405
+      context.registerReceiver(connectivityReceiver,
+          new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION));
+      isRegistered = true;
+    } catch (SecurityException e) {
+      // See #1417, registering the receiver can throw SecurityException.
+      if (Log.isLoggable(TAG, Log.WARN)) {
+        Log.w(TAG, "Failed to register", e);
+      }
+    }
   }
 
   private void unregister() {
@@ -54,11 +72,27 @@ private void unregister() {
     isRegistered = false;
   }
 
+  @SuppressWarnings("WeakerAccess")
   @Synthetic
-  boolean isConnected(Context context) {
+  // Permissions are checked in the factory instead.
+  @SuppressLint("MissingPermission")
+  boolean isConnected(@NonNull Context context) {
     ConnectivityManager connectivityManager =
-        (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
-    NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();
+        Preconditions.checkNotNull(
+            (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE));
+    NetworkInfo networkInfo;
+    try {
+      networkInfo = connectivityManager.getActiveNetworkInfo();
+    } catch (RuntimeException e) {
+      // #1405 shows that this throws a SecurityException.
+      // b/70869360 shows that this throws NullPointerException on APIs 22, 23, and 24.
+      // b/70869360 also shows that this throws RuntimeException on API 24 and 25.
+      if (Log.isLoggable(TAG, Log.WARN)) {
+        Log.w(TAG, "Failed to determine connectivity status when connectivity changed", e);
+      }
+      // Default to true;
+      return true;
+    }
     return networkInfo != null && networkInfo.isConnected();
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactory.java b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactory.java
index 2d6702e53..6858eb370 100644
--- a/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactory.java
+++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactory.java
@@ -4,6 +4,7 @@
 import android.content.pm.PackageManager;
 import android.support.annotation.NonNull;
 import android.support.v4.content.ContextCompat;
+import android.util.Log;
 
 /**
  * A factory class that produces a functional {@link com.bumptech.glide.manager.ConnectivityMonitor}
@@ -12,14 +13,23 @@
  * the required permission.
  */
 public class DefaultConnectivityMonitorFactory implements ConnectivityMonitorFactory {
+  private static final String TAG = "ConnectivityMonitor";
   private static final String NETWORK_PERMISSION = "android.permission.ACCESS_NETWORK_STATE";
 
   @NonNull
+  @Override
   public ConnectivityMonitor build(
       @NonNull Context context,
       @NonNull ConnectivityMonitor.ConnectivityListener listener) {
     int permissionResult = ContextCompat.checkSelfPermission(context, NETWORK_PERMISSION);
     boolean hasPermission = permissionResult == PackageManager.PERMISSION_GRANTED;
+    if (Log.isLoggable(TAG, Log.DEBUG)) {
+      Log.d(
+          TAG,
+          hasPermission
+              ? "ACCESS_NETWORK_STATE permission granted, registering connectivity monitor"
+              : "ACCESS_NETWORK_STATE permission missing, cannot register connectivity monitor");
+    }
     return hasPermission
         ? new DefaultConnectivityMonitor(context, listener) : new NullConnectivityMonitor();
   }
diff --git a/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java b/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java
index 5d811cc49..7297680cd 100644
--- a/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java
+++ b/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.manager;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.RequestManager;
 import java.util.Collections;
 import java.util.Set;
@@ -8,6 +9,7 @@
  * A {@link RequestManagerTreeNode} that returns no relatives.
  */
 final class EmptyRequestManagerTreeNode implements RequestManagerTreeNode {
+    @NonNull
     @Override
     public Set<RequestManager> getDescendants() {
         return Collections.emptySet();
diff --git a/library/src/main/java/com/bumptech/glide/manager/Lifecycle.java b/library/src/main/java/com/bumptech/glide/manager/Lifecycle.java
index 53044cee1..434b5dcab 100644
--- a/library/src/main/java/com/bumptech/glide/manager/Lifecycle.java
+++ b/library/src/main/java/com/bumptech/glide/manager/Lifecycle.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.manager;
 
+import android.support.annotation.NonNull;
+
 /**
  * An interface for listening to Activity/Fragment lifecycle events.
  */
@@ -7,7 +9,7 @@
   /**
    * Adds the given listener to the set of listeners managed by this Lifecycle implementation.
    */
-  void addListener(LifecycleListener listener);
+  void addListener(@NonNull LifecycleListener listener);
 
   /**
    * Removes the given listener from the set of listeners managed by this Lifecycle implementation,
@@ -16,5 +18,5 @@
    * <p>This is an optimization only, there is no guarantee that every added listener will
    * eventually be removed.
    */
-  void removeListener(LifecycleListener listener);
+  void removeListener(@NonNull LifecycleListener listener);
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
index c799bac07..14215377a 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
@@ -5,7 +5,9 @@
 import android.app.Activity;
 import android.app.Fragment;
 import android.os.Build;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 import android.util.Log;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestManager;
@@ -23,25 +25,29 @@
  * @see com.bumptech.glide.manager.RequestManagerRetriever
  * @see com.bumptech.glide.RequestManager
  */
+@SuppressWarnings("DeprecatedIsStillUsed")
+@Deprecated
 public class RequestManagerFragment extends Fragment {
   private static final String TAG = "RMFragment";
   private final ActivityFragmentLifecycle lifecycle;
   private final RequestManagerTreeNode requestManagerTreeNode =
       new FragmentRequestManagerTreeNode();
-  private final HashSet<RequestManagerFragment> childRequestManagerFragments =
-      new HashSet<>();
+  @SuppressWarnings("deprecation")
+  private final Set<RequestManagerFragment> childRequestManagerFragments = new HashSet<>();
 
   @Nullable private RequestManager requestManager;
-  @Nullable private RequestManagerFragment rootRequestManagerFragment;
+  @SuppressWarnings("deprecation")
+  @Nullable
+  private RequestManagerFragment rootRequestManagerFragment;
   @Nullable private Fragment parentFragmentHint;
 
   public RequestManagerFragment() {
     this(new ActivityFragmentLifecycle());
   }
 
-  // For testing only.
+  @VisibleForTesting
   @SuppressLint("ValidFragment")
-  RequestManagerFragment(ActivityFragmentLifecycle lifecycle) {
+  RequestManagerFragment(@NonNull ActivityFragmentLifecycle lifecycle) {
     this.lifecycle = lifecycle;
   }
 
@@ -50,10 +56,11 @@ public RequestManagerFragment() {
    *
    * @param requestManager The request manager to use.
    */
-  public void setRequestManager(RequestManager requestManager) {
+  public void setRequestManager(@Nullable RequestManager requestManager) {
     this.requestManager = requestManager;
   }
 
+  @NonNull
   ActivityFragmentLifecycle getGlideLifecycle() {
     return lifecycle;
   }
@@ -69,14 +76,17 @@ public RequestManager getRequestManager() {
   /**
    * Returns the {@link RequestManagerTreeNode} for this fragment.
    */
+  @NonNull
   public RequestManagerTreeNode getRequestManagerTreeNode() {
     return requestManagerTreeNode;
   }
 
+  @SuppressWarnings("deprecation")
   private void addChildRequestManagerFragment(RequestManagerFragment child) {
     childRequestManagerFragments.add(child);
   }
 
+  @SuppressWarnings("deprecation")
   private void removeChildRequestManagerFragment(RequestManagerFragment child) {
     childRequestManagerFragments.remove(child);
   }
@@ -85,9 +95,12 @@ private void removeChildRequestManagerFragment(RequestManagerFragment child) {
    * Returns the set of fragments that this RequestManagerFragment's parent is a parent to. (i.e.
    * our parent is the fragment that we are annotating).
    */
+  @SuppressWarnings("deprecation")
   @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
-  public Set<RequestManagerFragment> getDescendantRequestManagerFragments() {
-    if (rootRequestManagerFragment == this) {
+  @Synthetic
+  @NonNull
+  Set<RequestManagerFragment> getDescendantRequestManagerFragments() {
+    if (equals(rootRequestManagerFragment)) {
       return Collections.unmodifiableSet(childRequestManagerFragments);
     } else if (rootRequestManagerFragment == null
         || Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {
@@ -95,7 +108,7 @@ private void removeChildRequestManagerFragment(RequestManagerFragment child) {
       // so just return an empty set.
       return Collections.emptySet();
     } else {
-      HashSet<RequestManagerFragment> descendants = new HashSet<>();
+      Set<RequestManagerFragment> descendants = new HashSet<>();
       for (RequestManagerFragment fragment : rootRequestManagerFragment
           .getDescendantRequestManagerFragments()) {
         if (isDescendant(fragment.getParentFragment())) {
@@ -110,13 +123,14 @@ private void removeChildRequestManagerFragment(RequestManagerFragment child) {
    * Sets a hint for which fragment is our parent which allows the fragment to return correct
    * information about its parents before pending fragment transactions have been executed.
    */
-  void setParentFragmentHint(Fragment parentFragmentHint) {
+  void setParentFragmentHint(@Nullable Fragment parentFragmentHint) {
     this.parentFragmentHint = parentFragmentHint;
     if (parentFragmentHint != null && parentFragmentHint.getActivity() != null) {
       registerFragmentWithRoot(parentFragmentHint.getActivity());
     }
   }
 
+  @Nullable
   @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
   private Fragment getParentFragmentUsingHint() {
     final Fragment fragment;
@@ -132,10 +146,11 @@ private Fragment getParentFragmentUsingHint() {
    * Returns true if the fragment is a descendant of our parent.
    */
   @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
-  private boolean isDescendant(Fragment fragment) {
-    Fragment root = this.getParentFragment();
-    while (fragment.getParentFragment() != null) {
-      if (fragment.getParentFragment() == root) {
+  private boolean isDescendant(@NonNull Fragment fragment) {
+    Fragment root = getParentFragment();
+    Fragment parentFragment;
+    while ((parentFragment = fragment.getParentFragment()) != null) {
+      if (parentFragment.equals(root)) {
         return true;
       }
       fragment = fragment.getParentFragment();
@@ -143,11 +158,12 @@ private boolean isDescendant(Fragment fragment) {
     return false;
   }
 
-  private void registerFragmentWithRoot(Activity activity) {
+  @SuppressWarnings("deprecation")
+  private void registerFragmentWithRoot(@NonNull Activity activity) {
     unregisterFragmentWithRoot();
-    rootRequestManagerFragment = Glide.get(activity).getRequestManagerRetriever()
-        .getRequestManagerFragment(activity.getFragmentManager(), null);
-    if (rootRequestManagerFragment != this) {
+    rootRequestManagerFragment =
+        Glide.get(activity).getRequestManagerRetriever().getRequestManagerFragment(activity);
+    if (!equals(rootRequestManagerFragment)) {
       rootRequestManagerFragment.addChildRequestManagerFragment(this);
     }
   }
@@ -159,6 +175,7 @@ private void unregisterFragmentWithRoot() {
     }
   }
 
+  @SuppressWarnings("deprecation")
   @Override
   public void onAttach(Activity activity) {
     super.onAttach(activity);
@@ -207,10 +224,12 @@ public String toString() {
     @Synthetic
     FragmentRequestManagerTreeNode() { }
 
+    @SuppressWarnings("deprecation")
+    @NonNull
     @Override
     public Set<RequestManager> getDescendants() {
       Set<RequestManagerFragment> descendantFragments = getDescendantRequestManagerFragments();
-      HashSet<RequestManager> descendants = new HashSet<>(descendantFragments.size());
+      Set<RequestManager> descendants = new HashSet<>(descendantFragments.size());
       for (RequestManagerFragment fragment : descendantFragments) {
         if (fragment.getRequestManager() != null) {
           descendants.add(fragment.getRequestManager());
@@ -219,6 +238,7 @@ public String toString() {
       return descendants;
     }
 
+    @SuppressWarnings("deprecation")
     @Override
     public String toString() {
       return super.toString() + "{fragment=" + RequestManagerFragment.this + "}";
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
index 09cc608fe..a8260fa81 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
@@ -12,7 +12,9 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
 import android.support.v4.app.FragmentManager;
@@ -32,7 +34,7 @@
  * retrieving existing ones from activities and fragment.
  */
 public class RequestManagerRetriever implements Handler.Callback {
-  // Visible for testing.
+  @VisibleForTesting
   static final String FRAGMENT_TAG = "com.bumptech.glide.manager";
   private static final String TAG = "RMRetriever";
 
@@ -42,24 +44,24 @@
   // Hacks based on the implementation of FragmentManagerImpl in the non-support libraries that
   // allow us to iterate over and retrieve all active Fragments in a FragmentManager.
   private static final String FRAGMENT_INDEX_KEY = "key";
-  private static final String FRAGMENT_MANAGER_GET_FRAGMENT_KEY = "i";
 
   /**
    * The top application level RequestManager.
    */
   private volatile RequestManager applicationManager;
 
-  // Visible for testing.
   /**
    * Pending adds for RequestManagerFragments.
    */
+  @SuppressWarnings("deprecation")
+  @VisibleForTesting
   final Map<android.app.FragmentManager, RequestManagerFragment> pendingRequestManagerFragments =
       new HashMap<>();
 
-  // Visible for testing.
   /**
    * Pending adds for SupportRequestManagerFragments.
    */
+  @VisibleForTesting
   final Map<FragmentManager, SupportRequestManagerFragment> pendingSupportRequestManagerFragments =
       new HashMap<>();
 
@@ -74,13 +76,13 @@
   private final ArrayMap<View, android.app.Fragment> tempViewToFragment = new ArrayMap<>();
   private final Bundle tempBundle = new Bundle();
 
-  // Visible for testing.
   public RequestManagerRetriever(@Nullable RequestManagerFactory factory) {
     this.factory = factory != null ? factory : DEFAULT_FACTORY;
     handler = new Handler(Looper.getMainLooper(), this /* Callback */);
   }
 
-  private RequestManager getApplicationManager(Context context) {
+  @NonNull
+  private RequestManager getApplicationManager(@NonNull Context context) {
     // Either an application context or we're on a background thread.
     if (applicationManager == null) {
       synchronized (this) {
@@ -91,9 +93,13 @@ private RequestManager getApplicationManager(Context context) {
           // ApplicationLifecycle.
 
           // TODO(b/27524013): Factor out this Glide.get() call.
-          Glide glide = Glide.get(context);
+          Glide glide = Glide.get(context.getApplicationContext());
           applicationManager =
-              factory.build(glide, new ApplicationLifecycle(), new EmptyRequestManagerTreeNode());
+              factory.build(
+                  glide,
+                  new ApplicationLifecycle(),
+                  new EmptyRequestManagerTreeNode(),
+                  context.getApplicationContext());
         }
       }
     }
@@ -101,7 +107,8 @@ private RequestManager getApplicationManager(Context context) {
     return applicationManager;
   }
 
-  public RequestManager get(Context context) {
+  @NonNull
+  public RequestManager get(@NonNull Context context) {
     if (context == null) {
       throw new IllegalArgumentException("You cannot start a load on a null Context");
     } else if (Util.isOnMainThread() && !(context instanceof Application)) {
@@ -117,38 +124,46 @@ public RequestManager get(Context context) {
     return getApplicationManager(context);
   }
 
-  public RequestManager get(FragmentActivity activity) {
+  @NonNull
+  public RequestManager get(@NonNull FragmentActivity activity) {
     if (Util.isOnBackgroundThread()) {
       return get(activity.getApplicationContext());
     } else {
       assertNotDestroyed(activity);
       FragmentManager fm = activity.getSupportFragmentManager();
-      return supportFragmentGet(activity, fm, null /*parentHint*/);
+      return supportFragmentGet(
+          activity, fm, /*parentHint=*/ null, isActivityVisible(activity));
     }
   }
 
-  public RequestManager get(Fragment fragment) {
+  @NonNull
+  public RequestManager get(@NonNull Fragment fragment) {
     Preconditions.checkNotNull(fragment.getActivity(),
           "You cannot start a load on a fragment before it is attached or after it is destroyed");
     if (Util.isOnBackgroundThread()) {
       return get(fragment.getActivity().getApplicationContext());
     } else {
       FragmentManager fm = fragment.getChildFragmentManager();
-      return supportFragmentGet(fragment.getActivity(), fm, fragment);
+      return supportFragmentGet(fragment.getActivity(), fm, fragment, fragment.isVisible());
     }
   }
 
-  public RequestManager get(Activity activity) {
+  @SuppressWarnings("deprecation")
+  @NonNull
+  public RequestManager get(@NonNull Activity activity) {
     if (Util.isOnBackgroundThread()) {
       return get(activity.getApplicationContext());
     } else {
       assertNotDestroyed(activity);
       android.app.FragmentManager fm = activity.getFragmentManager();
-      return fragmentGet(activity, fm, null /*parentHint*/);
+      return fragmentGet(
+          activity, fm, /*parentHint=*/ null, isActivityVisible(activity));
     }
   }
 
-  public RequestManager get(View view) {
+  @SuppressWarnings("deprecation")
+  @NonNull
+  public RequestManager get(@NonNull View view) {
     if (Util.isOnBackgroundThread()) {
       return get(view.getContext().getApplicationContext());
     }
@@ -163,12 +178,12 @@ public RequestManager get(View view) {
     }
 
     // Support Fragments.
+    // Although the user might have non-support Fragments attached to FragmentActivity, searching
+    // for non-support Fragments is so expensive pre O and that should be rare enough that we
+    // prefer to just fall back to the Activity directly.
     if (activity instanceof FragmentActivity) {
       Fragment fragment = findSupportFragment(view, (FragmentActivity) activity);
-      if (fragment == null) {
-        return get(activity);
-      }
-      return get(fragment);
+      return fragment != null ? get(fragment) : get(activity);
     }
 
     // Standard Fragments.
@@ -181,7 +196,7 @@ public RequestManager get(View view) {
 
   private static void findAllSupportFragmentsWithViews(
       @Nullable Collection<Fragment> topLevelFragments,
-      Map<View, Fragment> result) {
+      @NonNull Map<View, Fragment> result) {
     if (topLevelFragments == null) {
       return;
     }
@@ -196,7 +211,7 @@ private static void findAllSupportFragmentsWithViews(
   }
 
   @Nullable
-  private Fragment findSupportFragment(View target, FragmentActivity activity) {
+  private Fragment findSupportFragment(@NonNull View target, @NonNull FragmentActivity activity) {
     tempViewToSupportFragment.clear();
     findAllSupportFragmentsWithViews(
         activity.getSupportFragmentManager().getFragments(), tempViewToSupportFragment);
@@ -219,8 +234,10 @@ private Fragment findSupportFragment(View target, FragmentActivity activity) {
     return result;
   }
 
+  @SuppressWarnings({"deprecation", "DeprecatedIsStillUsed"})
+  @Deprecated
   @Nullable
-  private android.app.Fragment findFragment(View target, Activity activity) {
+  private android.app.Fragment findFragment(@NonNull View target, @NonNull Activity activity) {
     tempViewToFragment.clear();
     findAllFragmentsWithViews(activity.getFragmentManager(), tempViewToFragment);
 
@@ -228,7 +245,7 @@ private Fragment findSupportFragment(View target, FragmentActivity activity) {
 
     View activityRoot = activity.findViewById(android.R.id.content);
     View current = target;
-     while (!current.equals(activityRoot)) {
+    while (!current.equals(activityRoot)) {
       result = tempViewToFragment.get(current);
       if (result != null) {
         break;
@@ -245,14 +262,35 @@ private Fragment findSupportFragment(View target, FragmentActivity activity) {
 
   // TODO: Consider using an accessor class in the support library package to more directly retrieve
   // non-support Fragments.
+  @SuppressWarnings("deprecation")
+  @Deprecated
+  @TargetApi(Build.VERSION_CODES.O)
   private void findAllFragmentsWithViews(
-      android.app.FragmentManager fragmentManager, ArrayMap<View, android.app.Fragment> result) {
+      @NonNull android.app.FragmentManager fragmentManager,
+      @NonNull ArrayMap<View, android.app.Fragment> result) {
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+      for (android.app.Fragment fragment : fragmentManager.getFragments()) {
+        if (fragment.getView() != null) {
+          result.put(fragment.getView(), fragment);
+          findAllFragmentsWithViews(fragment.getChildFragmentManager(), result);
+        }
+      }
+    } else {
+      findAllFragmentsWithViewsPreO(fragmentManager, result);
+    }
+  }
+
+  @SuppressWarnings("deprecation")
+  @Deprecated
+  private void findAllFragmentsWithViewsPreO(
+      @NonNull android.app.FragmentManager fragmentManager,
+      @NonNull ArrayMap<View, android.app.Fragment> result) {
     int index = 0;
     while (true) {
       tempBundle.putInt(FRAGMENT_INDEX_KEY, index++);
       android.app.Fragment fragment = null;
       try {
-        fragment = fragmentManager.getFragment(tempBundle, FRAGMENT_MANAGER_GET_FRAGMENT_KEY);
+        fragment = fragmentManager.getFragment(tempBundle, FRAGMENT_INDEX_KEY);
       } catch (Exception e) {
         // This generates log spam from FragmentManager anyway.
       }
@@ -268,7 +306,8 @@ private void findAllFragmentsWithViews(
     }
   }
 
-  private Activity findActivity(Context context) {
+  @Nullable
+  private Activity findActivity(@NonNull Context context) {
     if (context instanceof Activity) {
       return (Activity) context;
     } else if (context instanceof ContextWrapper) {
@@ -279,14 +318,17 @@ private Activity findActivity(Context context) {
   }
 
   @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
-  private static void assertNotDestroyed(Activity activity) {
+  private static void assertNotDestroyed(@NonNull Activity activity) {
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1 && activity.isDestroyed()) {
       throw new IllegalArgumentException("You cannot start a load for a destroyed activity");
     }
   }
 
+  @SuppressWarnings("deprecation")
+  @Deprecated
+  @NonNull
   @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
-  public RequestManager get(android.app.Fragment fragment) {
+  public RequestManager get(@NonNull android.app.Fragment fragment) {
     if (fragment.getActivity() == null) {
       throw new IllegalArgumentException(
           "You cannot start a load on a fragment before it is attached");
@@ -295,19 +337,33 @@ public RequestManager get(android.app.Fragment fragment) {
       return get(fragment.getActivity().getApplicationContext());
     } else {
       android.app.FragmentManager fm = fragment.getChildFragmentManager();
-      return fragmentGet(fragment.getActivity(), fm, fragment);
+      return fragmentGet(fragment.getActivity(), fm, fragment, fragment.isVisible());
     }
   }
 
-  @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
-  RequestManagerFragment getRequestManagerFragment(
-      final android.app.FragmentManager fm, android.app.Fragment parentHint) {
+  @SuppressWarnings("deprecation")
+  @Deprecated
+  @NonNull
+  RequestManagerFragment getRequestManagerFragment(Activity activity) {
+    return getRequestManagerFragment(
+        activity.getFragmentManager(), /*parentHint=*/ null, isActivityVisible(activity));
+  }
+
+  @SuppressWarnings("deprecation")
+  @NonNull
+  private RequestManagerFragment getRequestManagerFragment(
+      @NonNull final android.app.FragmentManager fm,
+      @Nullable android.app.Fragment parentHint,
+      boolean isParentVisible) {
     RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);
     if (current == null) {
       current = pendingRequestManagerFragments.get(fm);
       if (current == null) {
         current = new RequestManagerFragment();
         current.setParentFragmentHint(parentHint);
+        if (isParentVisible) {
+          current.getGlideLifecycle().onStart();
+        }
         pendingRequestManagerFragments.put(fm, current);
         fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();
         handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();
@@ -316,22 +372,41 @@ RequestManagerFragment getRequestManagerFragment(
     return current;
   }
 
-  private RequestManager fragmentGet(Context context, android.app.FragmentManager fm,
-      android.app.Fragment parentHint) {
-    RequestManagerFragment current = getRequestManagerFragment(fm, parentHint);
+  @SuppressWarnings({"deprecation", "DeprecatedIsStillUsed"})
+  @Deprecated
+  @NonNull
+  private RequestManager fragmentGet(@NonNull Context context,
+      @NonNull android.app.FragmentManager fm,
+      @Nullable android.app.Fragment parentHint,
+      boolean isParentVisible) {
+    RequestManagerFragment current = getRequestManagerFragment(fm, parentHint, isParentVisible);
     RequestManager requestManager = current.getRequestManager();
     if (requestManager == null) {
       // TODO(b/27524013): Factor out this Glide.get() call.
       Glide glide = Glide.get(context);
       requestManager =
-          factory.build(glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode());
+          factory.build(
+              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);
       current.setRequestManager(requestManager);
     }
     return requestManager;
   }
 
-  SupportRequestManagerFragment getSupportRequestManagerFragment(
-      final FragmentManager fm, Fragment parentHint) {
+  @NonNull
+  SupportRequestManagerFragment getSupportRequestManagerFragment(FragmentActivity activity) {
+    return getSupportRequestManagerFragment(
+        activity.getSupportFragmentManager(), /*parentHint=*/ null, isActivityVisible(activity));
+  }
+
+  private static boolean isActivityVisible(Activity activity) {
+    // This is a poor heuristic, but it's about all we have. We'd rather err on the side of visible
+    // and start requests than on the side of invisible and ignore valid requests.
+    return !activity.isFinishing();
+  }
+
+  @NonNull
+  private SupportRequestManagerFragment getSupportRequestManagerFragment(
+      @NonNull final FragmentManager fm, @Nullable Fragment parentHint, boolean isParentVisible) {
     SupportRequestManagerFragment current =
         (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);
     if (current == null) {
@@ -339,6 +414,9 @@ SupportRequestManagerFragment getSupportRequestManagerFragment(
       if (current == null) {
         current = new SupportRequestManagerFragment();
         current.setParentFragmentHint(parentHint);
+        if (isParentVisible) {
+          current.getGlideLifecycle().onStart();
+        }
         pendingSupportRequestManagerFragments.put(fm, current);
         fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();
         handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();
@@ -347,15 +425,21 @@ SupportRequestManagerFragment getSupportRequestManagerFragment(
     return current;
   }
 
-  private RequestManager supportFragmentGet(Context context, FragmentManager fm,
-      Fragment parentHint) {
-    SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint);
+  @NonNull
+  private RequestManager supportFragmentGet(
+      @NonNull Context context,
+      @NonNull FragmentManager fm,
+      @Nullable Fragment parentHint,
+      boolean isParentVisible) {
+    SupportRequestManagerFragment current =
+        getSupportRequestManagerFragment(fm, parentHint, isParentVisible);
     RequestManager requestManager = current.getRequestManager();
     if (requestManager == null) {
       // TODO(b/27524013): Factor out this Glide.get() call.
       Glide glide = Glide.get(context);
       requestManager =
-          factory.build(glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode());
+          factory.build(
+              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);
       current.setRequestManager(requestManager);
     }
     return requestManager;
@@ -391,15 +475,20 @@ public boolean handleMessage(Message message) {
    * Used internally to create {@link RequestManager}s.
    */
   public interface RequestManagerFactory {
+    @NonNull
     RequestManager build(
-        Glide glide, Lifecycle lifecycle, RequestManagerTreeNode requestManagerTreeNode);
+        @NonNull Glide glide,
+        @NonNull Lifecycle lifecycle,
+        @NonNull RequestManagerTreeNode requestManagerTreeNode,
+        @NonNull Context context);
   }
 
   private static final RequestManagerFactory DEFAULT_FACTORY = new RequestManagerFactory() {
+    @NonNull
     @Override
-    public RequestManager build(Glide glide, Lifecycle lifecycle,
-        RequestManagerTreeNode requestManagerTreeNode) {
-      return new RequestManager(glide, lifecycle, requestManagerTreeNode);
+    public RequestManager build(@NonNull Glide glide, @NonNull Lifecycle lifecycle,
+        @NonNull RequestManagerTreeNode requestManagerTreeNode, @NonNull Context context) {
+      return new RequestManager(glide, lifecycle, requestManagerTreeNode, context);
     }
   };
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java
index 38d341b3a..20666d093 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.manager;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.RequestManager;
 import java.util.Set;
 
@@ -13,5 +14,6 @@
    * Returns all descendant {@link RequestManager}s relative to the context of the current
    * {@link RequestManager}.
    */
+  @NonNull
   Set<RequestManager> getDescendants();
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
index f735e3618..97567671b 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
@@ -1,5 +1,9 @@
 package com.bumptech.glide.manager;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
+import android.util.Log;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.util.Util;
 import java.util.ArrayList;
@@ -14,6 +18,7 @@
  * <p>This class is not thread safe and must be accessed on the main thread.
  */
 public class RequestTracker {
+  private static final String TAG = "RequestTracker";
   // Most requests will be for views and will therefore be held strongly (and safely) by the view
   // via the tag. However, a user can always pass in a different type of target which may end up not
   // being strongly referenced even though the user still would like the request to finish. Weak
@@ -33,34 +38,48 @@
   /**
    * Starts tracking the given request.
    */
-  public void runRequest(Request request) {
+  public void runRequest(@NonNull Request request) {
     requests.add(request);
     if (!isPaused) {
       request.begin();
     } else {
+      request.clear();
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+        Log.v(TAG, "Paused, delaying request");
+      }
       pendingRequests.add(request);
     }
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   void addRequest(Request request) {
     requests.add(request);
   }
 
   /**
    * Stops tracking the given request, clears, and recycles it, and returns {@code true} if the
-   * request was removed or {@code false} if the request was not found.
+   * request was removed or invalid or {@code false} if the request was not found.
    */
-  public boolean clearRemoveAndRecycle(Request request) {
-    if (request == null) {
-      return false;
+  public boolean clearRemoveAndRecycle(@Nullable Request request) {
+    // It's safe for us to recycle because this is only called when the user is explicitly clearing
+    // a Target so we know that there are no remaining references to the Request.
+    return clearRemoveAndMaybeRecycle(request, /*isSafeToRecycle=*/ true);
+  }
+
+  private boolean clearRemoveAndMaybeRecycle(@Nullable Request request, boolean isSafeToRecycle) {
+     if (request == null) {
+       // If the Request is null, the request is already cleared and we don't need to search further
+       // for its owner.
+      return true;
     }
     boolean isOwnedByUs = requests.remove(request);
     // Avoid short circuiting.
     isOwnedByUs = pendingRequests.remove(request) || isOwnedByUs;
     if (isOwnedByUs) {
       request.clear();
-      request.recycle();
+      if (isSafeToRecycle) {
+        request.recycle();
+      }
     }
     return isOwnedByUs;
   }
@@ -79,7 +98,18 @@ public void pauseRequests() {
     isPaused = true;
     for (Request request : Util.getSnapshot(requests)) {
       if (request.isRunning()) {
-        request.pause();
+        request.clear();
+        pendingRequests.add(request);
+      }
+    }
+  }
+
+  /** Stops any in progress requests and releases bitmaps associated with completed requests. */
+  public void pauseAllRequests() {
+    isPaused = true;
+    for (Request request : Util.getSnapshot(requests)) {
+      if (request.isRunning() || request.isComplete()) {
+        request.clear();
         pendingRequests.add(request);
       }
     }
@@ -91,7 +121,10 @@ public void pauseRequests() {
   public void resumeRequests() {
     isPaused = false;
     for (Request request : Util.getSnapshot(requests)) {
-      if (!request.isComplete() && !request.isCancelled() && !request.isRunning()) {
+      // We don't need to check for cleared here. Any explicit clear by a user will remove the
+      // Request from the tracker, so the only way we'd find a cleared request here is if we cleared
+      // it. As a result it should be safe for us to resume cleared requests.
+      if (!request.isComplete() && !request.isRunning()) {
         request.begin();
       }
     }
@@ -105,7 +138,9 @@ public void resumeRequests() {
    */
   public void clearRequests() {
     for (Request request : Util.getSnapshot(requests)) {
-      clearRemoveAndRecycle(request);
+      // It's unsafe to recycle the Request here because we don't know who might else have a
+      // reference to it.
+      clearRemoveAndMaybeRecycle(request, /*isSafeToRecycle=*/ false);
     }
     pendingRequests.clear();
   }
@@ -115,12 +150,12 @@ public void clearRequests() {
    */
   public void restartRequests() {
     for (Request request : Util.getSnapshot(requests)) {
-      if (!request.isComplete() && !request.isCancelled()) {
-        // Ensure the request will be restarted in onResume.
-        request.pause();
+      if (!request.isComplete() && !request.isCleared()) {
+        request.clear();
         if (!isPaused) {
           request.begin();
         } else {
+          // Ensure the request will be restarted in onResume.
           pendingRequests.add(request);
         }
       }
diff --git a/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java b/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java
index 8bf7c0ec0..7c764cbbc 100644
--- a/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java
+++ b/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java
@@ -2,7 +2,9 @@
 
 import android.annotation.SuppressLint;
 import android.content.Context;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
 import android.util.Log;
@@ -27,8 +29,7 @@
   private final ActivityFragmentLifecycle lifecycle;
   private final RequestManagerTreeNode requestManagerTreeNode =
       new SupportFragmentRequestManagerTreeNode();
-  private final HashSet<SupportRequestManagerFragment> childRequestManagerFragments =
-      new HashSet<>();
+  private final Set<SupportRequestManagerFragment> childRequestManagerFragments = new HashSet<>();
 
   @Nullable private SupportRequestManagerFragment rootRequestManagerFragment;
   @Nullable private RequestManager requestManager;
@@ -38,9 +39,9 @@ public SupportRequestManagerFragment() {
     this(new ActivityFragmentLifecycle());
   }
 
-  // For testing only.
+  @VisibleForTesting
   @SuppressLint("ValidFragment")
-  public SupportRequestManagerFragment(ActivityFragmentLifecycle lifecycle) {
+  public SupportRequestManagerFragment(@NonNull ActivityFragmentLifecycle lifecycle) {
     this.lifecycle = lifecycle;
   }
 
@@ -49,10 +50,11 @@ public SupportRequestManagerFragment(ActivityFragmentLifecycle lifecycle) {
    *
    * @param requestManager The manager to put.
    */
-  public void setRequestManager(RequestManager requestManager) {
+  public void setRequestManager(@Nullable RequestManager requestManager) {
     this.requestManager = requestManager;
   }
 
+  @NonNull
   ActivityFragmentLifecycle getGlideLifecycle() {
     return lifecycle;
   }
@@ -70,6 +72,7 @@ public RequestManager getRequestManager() {
    * to the
    * associated {@link RequestManager}.
    */
+  @NonNull
   public RequestManagerTreeNode getRequestManagerTreeNode() {
     return requestManagerTreeNode;
   }
@@ -86,13 +89,15 @@ private void removeChildRequestManagerFragment(SupportRequestManagerFragment chi
    * Returns the set of fragments that this RequestManagerFragment's parent is a parent to. (i.e.
    * our parent is the fragment that we are annotating).
    */
-  public Set<SupportRequestManagerFragment> getDescendantRequestManagerFragments() {
+  @Synthetic
+  @NonNull
+  Set<SupportRequestManagerFragment> getDescendantRequestManagerFragments() {
     if (rootRequestManagerFragment == null) {
       return Collections.emptySet();
-    } else if (rootRequestManagerFragment == this) {
+    } else if (equals(rootRequestManagerFragment)) {
       return Collections.unmodifiableSet(childRequestManagerFragments);
     } else {
-      HashSet<SupportRequestManagerFragment> descendants = new HashSet<>();
+      Set<SupportRequestManagerFragment> descendants = new HashSet<>();
       for (SupportRequestManagerFragment fragment : rootRequestManagerFragment
           .getDescendantRequestManagerFragments()) {
         if (isDescendant(fragment.getParentFragmentUsingHint())) {
@@ -107,13 +112,14 @@ private void removeChildRequestManagerFragment(SupportRequestManagerFragment chi
    * Sets a hint for which fragment is our parent which allows the fragment to return correct
    * information about its parents before pending fragment transactions have been executed.
    */
-  void setParentFragmentHint(Fragment parentFragmentHint) {
+  void setParentFragmentHint(@Nullable Fragment parentFragmentHint) {
     this.parentFragmentHint = parentFragmentHint;
     if (parentFragmentHint != null && parentFragmentHint.getActivity() != null) {
       registerFragmentWithRoot(parentFragmentHint.getActivity());
     }
   }
 
+  @Nullable
   private Fragment getParentFragmentUsingHint() {
     Fragment fragment = getParentFragment();
     return fragment != null ? fragment : parentFragmentHint;
@@ -122,10 +128,11 @@ private Fragment getParentFragmentUsingHint() {
   /**
    * Returns true if the fragment is a descendant of our parent.
    */
-  private boolean isDescendant(Fragment fragment) {
-    Fragment root = this.getParentFragmentUsingHint();
-    while (fragment.getParentFragment() != null) {
-      if (fragment.getParentFragment() == root) {
+  private boolean isDescendant(@NonNull Fragment fragment) {
+    Fragment root = getParentFragmentUsingHint();
+    Fragment parentFragment;
+    while ((parentFragment = fragment.getParentFragment()) != null) {
+      if (parentFragment.equals(root)) {
         return true;
       }
       fragment = fragment.getParentFragment();
@@ -133,11 +140,11 @@ private boolean isDescendant(Fragment fragment) {
     return false;
   }
 
-  private void registerFragmentWithRoot(FragmentActivity activity) {
+  private void registerFragmentWithRoot(@NonNull FragmentActivity activity) {
     unregisterFragmentWithRoot();
-    rootRequestManagerFragment = Glide.get(activity).getRequestManagerRetriever()
-        .getSupportRequestManagerFragment(activity.getSupportFragmentManager(), null);
-    if (rootRequestManagerFragment != this) {
+    rootRequestManagerFragment =
+        Glide.get(activity).getRequestManagerRetriever().getSupportRequestManagerFragment(activity);
+    if (!equals(rootRequestManagerFragment)) {
       rootRequestManagerFragment.addChildRequestManagerFragment(this);
     }
   }
@@ -198,11 +205,12 @@ public String toString() {
     @Synthetic
     SupportFragmentRequestManagerTreeNode() { }
 
+    @NonNull
     @Override
     public Set<RequestManager> getDescendants() {
       Set<SupportRequestManagerFragment> descendantFragments =
           getDescendantRequestManagerFragments();
-      HashSet<RequestManager> descendants = new HashSet<>(descendantFragments.size());
+      Set<RequestManager> descendants = new HashSet<>(descendantFragments.size());
       for (SupportRequestManagerFragment fragment : descendantFragments) {
         if (fragment.getRequestManager() != null) {
           descendants.add(fragment.getRequestManager());
diff --git a/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java b/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java
index 64dd276db..45ad1252a 100644
--- a/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java
+++ b/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java
@@ -1,8 +1,8 @@
 package com.bumptech.glide.manager;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.util.Util;
-import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.Set;
@@ -16,11 +16,11 @@
   private final Set<Target<?>> targets =
       Collections.newSetFromMap(new WeakHashMap<Target<?>, Boolean>());
 
-  public void track(Target<?> target) {
+  public void track(@NonNull Target<?> target) {
     targets.add(target);
   }
 
-  public void untrack(Target<?> target) {
+  public void untrack(@NonNull Target<?> target) {
     targets.remove(target);
   }
 
@@ -45,8 +45,9 @@ public void onDestroy() {
     }
   }
 
+  @NonNull
   public List<Target<?>> getAll() {
-    return new ArrayList<>(targets);
+    return Util.getSnapshot(targets);
   }
 
   public void clear() {
diff --git a/library/src/main/java/com/bumptech/glide/module/AppGlideModule.java b/library/src/main/java/com/bumptech/glide/module/AppGlideModule.java
index 9d40b969c..77f124670 100644
--- a/library/src/main/java/com/bumptech/glide/module/AppGlideModule.java
+++ b/library/src/main/java/com/bumptech/glide/module/AppGlideModule.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.module;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.GlideBuilder;
 
 /**
@@ -20,6 +21,8 @@
  * annotation processor, {@link AppGlideModule} implementations should override
  * {@link #isManifestParsingEnabled()} and return {@code false}.
  */
+// Used only in javadoc.
+@SuppressWarnings("deprecation")
 public abstract class AppGlideModule extends LibraryGlideModule implements AppliesOptions {
   /**
    * Returns {@code true} if Glide should check the AndroidManifest for {@link GlideModule}s.
@@ -34,7 +37,7 @@ public boolean isManifestParsingEnabled() {
   }
 
   @Override
-  public void applyOptions(Context context, GlideBuilder builder) {
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
     // Default empty impl.
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/module/AppliesOptions.java b/library/src/main/java/com/bumptech/glide/module/AppliesOptions.java
index 923d364f7..c92e0da64 100644
--- a/library/src/main/java/com/bumptech/glide/module/AppliesOptions.java
+++ b/library/src/main/java/com/bumptech/glide/module/AppliesOptions.java
@@ -1,11 +1,13 @@
 package com.bumptech.glide.module;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.GlideBuilder;
 
 /**
  * An internal interface, to be removed when {@link GlideModule}s are removed.
  */
+@Deprecated
 interface AppliesOptions {
   /**
    * Lazily apply options to a {@link com.bumptech.glide.GlideBuilder} immediately before the Glide
@@ -16,5 +18,5 @@
    * @param context An Application {@link android.content.Context}.
    * @param builder The {@link com.bumptech.glide.GlideBuilder} that will be used to create Glide.
    */
-  void applyOptions(Context context, GlideBuilder builder);
+  void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder);
 }
diff --git a/library/src/main/java/com/bumptech/glide/module/LibraryGlideModule.java b/library/src/main/java/com/bumptech/glide/module/LibraryGlideModule.java
index ccf368671..612dc8c13 100644
--- a/library/src/main/java/com/bumptech/glide/module/LibraryGlideModule.java
+++ b/library/src/main/java/com/bumptech/glide/module/LibraryGlideModule.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.module;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.Registry;
 
@@ -15,9 +16,11 @@
  * {@link com.bumptech.glide.annotation.Excludes} annotation to selectively remove one or more of
  * the conflicting modules.
  */
+@SuppressWarnings("deprecation")
 public abstract class LibraryGlideModule implements RegistersComponents {
   @Override
-  public void registerComponents(Context context, Glide glide, Registry registry) {
+  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry) {
     // Default empty impl.
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/module/ManifestParser.java b/library/src/main/java/com/bumptech/glide/module/ManifestParser.java
index 9b0eb69a8..6304f179a 100644
--- a/library/src/main/java/com/bumptech/glide/module/ManifestParser.java
+++ b/library/src/main/java/com/bumptech/glide/module/ManifestParser.java
@@ -4,12 +4,16 @@
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
 import android.util.Log;
+import java.lang.reflect.InvocationTargetException;
 import java.util.ArrayList;
 import java.util.List;
 
 /**
  * Parses {@link com.bumptech.glide.module.GlideModule} references out of the AndroidManifest file.
  */
+// Used only in javadoc.
+@SuppressWarnings("deprecation")
+@Deprecated
 public final class ManifestParser {
   private static final String TAG = "ManifestParser";
   private static final String GLIDE_MODULE_VALUE = "GlideModule";
@@ -65,16 +69,18 @@ private static GlideModule parseModule(String className) {
       throw new IllegalArgumentException("Unable to find GlideModule implementation", e);
     }
 
-    Object module;
+    Object module = null;
     try {
-      module = clazz.newInstance();
+      module = clazz.getDeclaredConstructor().newInstance();
+    // These can't be combined until API minimum is 19.
     } catch (InstantiationException e) {
-      throw new RuntimeException("Unable to instantiate GlideModule implementation for " + clazz,
-              e);
-      // These can't be combined until API minimum is 19.
+      throwInstantiateGlideModuleException(clazz, e);
     } catch (IllegalAccessException e) {
-      throw new RuntimeException("Unable to instantiate GlideModule implementation for " + clazz,
-              e);
+      throwInstantiateGlideModuleException(clazz, e);
+    } catch (NoSuchMethodException e) {
+      throwInstantiateGlideModuleException(clazz, e);
+    } catch (InvocationTargetException e) {
+      throwInstantiateGlideModuleException(clazz, e);
     }
 
     if (!(module instanceof GlideModule)) {
@@ -82,4 +88,8 @@ private static GlideModule parseModule(String className) {
     }
     return (GlideModule) module;
   }
+
+  private static void throwInstantiateGlideModuleException(Class<?> clazz, Exception e) {
+    throw new RuntimeException("Unable to instantiate GlideModule implementation for " + clazz, e);
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/module/RegistersComponents.java b/library/src/main/java/com/bumptech/glide/module/RegistersComponents.java
index f87a7409a..9461ee341 100644
--- a/library/src/main/java/com/bumptech/glide/module/RegistersComponents.java
+++ b/library/src/main/java/com/bumptech/glide/module/RegistersComponents.java
@@ -1,12 +1,16 @@
 package com.bumptech.glide.module;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.Registry;
 
 /**
  * An internal interface, to be removed when {@link GlideModule}s are removed.
  */
+// Used only in javadocs.
+@SuppressWarnings("deprecation")
+@Deprecated
 interface RegistersComponents {
 
   /**
@@ -19,5 +23,6 @@
    * @param glide The Glide singleton that is in the process of being initialized.
    * @param registry An {@link com.bumptech.glide.Registry} to use to register components.
    */
-  void registerComponents(Context context, Glide glide, Registry registry);
+  void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry);
 }
diff --git a/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java b/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java
index 29bd3af62..ca5148a0f 100644
--- a/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.provider;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.util.Synthetic;
@@ -7,7 +8,7 @@
 import java.util.List;
 
 /**
- * Contains an unordered list of {@link Encoder}s capable of encoding arbitrary data types.
+ * Contains an ordered list of {@link Encoder}s capable of encoding arbitrary data types.
  */
 public class EncoderRegistry {
   // TODO: This registry should probably contain a put, rather than a list.
@@ -15,7 +16,7 @@
 
   @SuppressWarnings("unchecked")
   @Nullable
-  public synchronized <T> Encoder<T> getEncoder(Class<T> dataClass) {
+  public synchronized <T> Encoder<T> getEncoder(@NonNull Class<T> dataClass) {
     for (Entry<?> entry : encoders) {
       if (entry.handles(dataClass)) {
         return (Encoder<T>) entry.encoder;
@@ -24,20 +25,24 @@
     return null;
   }
 
-  public synchronized <T> void add(Class<T> dataClass, Encoder<T> encoder) {
+  public synchronized <T> void append(@NonNull Class<T> dataClass, @NonNull Encoder<T> encoder) {
     encoders.add(new Entry<>(dataClass, encoder));
   }
 
+  public synchronized <T> void prepend(@NonNull Class<T> dataClass, @NonNull Encoder<T> encoder) {
+    encoders.add(0, new Entry<>(dataClass, encoder));
+  }
+
   private static final class Entry<T> {
     private final Class<T> dataClass;
-    @Synthetic final Encoder<T> encoder;
+    @Synthetic @SuppressWarnings("WeakerAccess") final Encoder<T> encoder;
 
-    public Entry(Class<T> dataClass, Encoder<T> encoder) {
+    Entry(@NonNull Class<T> dataClass, @NonNull Encoder<T> encoder) {
       this.dataClass = dataClass;
       this.encoder = encoder;
     }
 
-    public boolean handles(Class<?> dataClass) {
+    boolean handles(@NonNull Class<?> dataClass) {
       return this.dataClass.isAssignableFrom(dataClass);
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/provider/ImageHeaderParserRegistry.java b/library/src/main/java/com/bumptech/glide/provider/ImageHeaderParserRegistry.java
index af329320e..902fc1bd4 100644
--- a/library/src/main/java/com/bumptech/glide/provider/ImageHeaderParserRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/provider/ImageHeaderParserRegistry.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.provider;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.ImageHeaderParser;
 import java.util.ArrayList;
 import java.util.List;
@@ -10,11 +11,12 @@
 public final class ImageHeaderParserRegistry {
   private final List<ImageHeaderParser> parsers = new ArrayList<>();
 
+  @NonNull
   public synchronized List<ImageHeaderParser> getParsers() {
     return parsers;
   }
 
-  public synchronized void add(ImageHeaderParser parser) {
+  public synchronized void add(@NonNull ImageHeaderParser parser) {
     parsers.add(parser);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/provider/LoadPathCache.java b/library/src/main/java/com/bumptech/glide/provider/LoadPathCache.java
index 6cc5d9630..89d2525af 100644
--- a/library/src/main/java/com/bumptech/glide/provider/LoadPathCache.java
+++ b/library/src/main/java/com/bumptech/glide/provider/LoadPathCache.java
@@ -2,8 +2,12 @@
 
 import android.support.annotation.Nullable;
 import android.support.v4.util.ArrayMap;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.DecodePath;
 import com.bumptech.glide.load.engine.LoadPath;
+import com.bumptech.glide.load.resource.transcode.UnitTranscoder;
 import com.bumptech.glide.util.MultiClassKey;
+import java.util.Collections;
 import java.util.concurrent.atomic.AtomicReference;
 
 /**
@@ -11,19 +15,38 @@
  * {@link com.bumptech.glide.load.engine.LoadPath}s capable of decoding with the requested types.
  */
 public class LoadPathCache {
+  private static final LoadPath<?, ?, ?> NO_PATHS_SIGNAL =
+      new LoadPath<>(
+          Object.class,
+          Object.class,
+          Object.class,
+          Collections.singletonList(
+              new DecodePath<>(
+                  Object.class,
+                  Object.class,
+                  Object.class,
+                  Collections.<ResourceDecoder<Object, Object>>emptyList(),
+                  new UnitTranscoder<>(),
+                  /*listPool=*/ null)),
+          /*listPool=*/ null);
+
   private final ArrayMap<MultiClassKey, LoadPath<?, ?, ?>> cache = new ArrayMap<>();
   private final AtomicReference<MultiClassKey> keyRef = new AtomicReference<>();
 
-  public boolean contains(Class<?> dataClass, Class<?> resourceClass, Class<?> transcodeClass) {
-    MultiClassKey key = getKey(dataClass, resourceClass, transcodeClass);
-    boolean result;
-    synchronized (cache) {
-      result = cache.containsKey(key);
-    }
-    keyRef.set(key);
-    return result;
+  /**
+   * Returns {@code} true if the given {@link LoadPath} is the signal object returned from
+   * {@link #get(Class, Class, Class)} that indicates that we've previously found that there are
+   * no available paths to load the requested resources and {@code false} otherwise.
+   */
+  public boolean isEmptyLoadPath(@Nullable LoadPath<?, ?, ?> path) {
+    return NO_PATHS_SIGNAL.equals(path);
   }
 
+  /**
+   * May return {@link #NO_PATHS_SIGNAL} to indicate that we've previously found that there are 0
+   * available load paths for the requested types. Callers must check using
+   * {@link #isEmptyLoadPath(LoadPath)} before using any load path returned by this method.
+   */
   @SuppressWarnings("unchecked")
   @Nullable
   public <Data, TResource, Transcode> LoadPath<Data, TResource, Transcode> get(
@@ -38,10 +61,14 @@ public boolean contains(Class<?> dataClass, Class<?> resourceClass, Class<?> tra
     return (LoadPath<Data, TResource, Transcode>) result;
   }
 
-  public void put(Class<?> dataClass, Class<?> resourceClass, Class<?> transcodeClass,
-      LoadPath<?, ?, ?> loadPath) {
+  public void put(
+      Class<?> dataClass, Class<?> resourceClass,
+      Class<?> transcodeClass,
+      @Nullable LoadPath<?, ?, ?> loadPath) {
     synchronized (cache) {
-      cache.put(new MultiClassKey(dataClass, resourceClass, transcodeClass), loadPath);
+      cache.put(
+          new MultiClassKey(dataClass, resourceClass, transcodeClass),
+          loadPath != null ? loadPath : NO_PATHS_SIGNAL);
     }
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/provider/ModelToResourceClassCache.java b/library/src/main/java/com/bumptech/glide/provider/ModelToResourceClassCache.java
index 076661dfa..4740f4b5a 100644
--- a/library/src/main/java/com/bumptech/glide/provider/ModelToResourceClassCache.java
+++ b/library/src/main/java/com/bumptech/glide/provider/ModelToResourceClassCache.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.provider;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.support.v4.util.ArrayMap;
 import com.bumptech.glide.util.MultiClassKey;
@@ -16,25 +17,32 @@
       new ArrayMap<>();
 
   @Nullable
-  public List<Class<?>> get(Class<?> modelClass, Class<?> resourceClass) {
+  public List<Class<?>> get(
+      @NonNull Class<?> modelClass,
+      @NonNull Class<?> resourceClass,
+      @NonNull Class<?> transcodeClass) {
     MultiClassKey key = resourceClassKeyRef.getAndSet(null);
     if (key == null) {
-      key = new MultiClassKey(modelClass, resourceClass);
+      key = new MultiClassKey(modelClass, resourceClass, transcodeClass);
     } else {
-      key.set(modelClass, resourceClass);
+      key.set(modelClass, resourceClass, transcodeClass);
     }
     final List<Class<?>> result;
     synchronized (registeredResourceClassCache) {
-       result = registeredResourceClassCache.get(key);
+      result = registeredResourceClassCache.get(key);
     }
     resourceClassKeyRef.set(key);
     return result;
   }
 
-  public void put(Class<?> modelClass, Class<?> resourceClass, List<Class<?>> resourceClasses) {
+  public void put(
+      @NonNull Class<?> modelClass,
+      @NonNull Class<?> resourceClass,
+      @NonNull Class<?> transcodeClass,
+      @NonNull List<Class<?>> resourceClasses) {
     synchronized (registeredResourceClassCache) {
       registeredResourceClassCache
-          .put(new MultiClassKey(modelClass, resourceClass), resourceClasses);
+          .put(new MultiClassKey(modelClass, resourceClass, transcodeClass), resourceClasses);
     }
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/provider/ResourceDecoderRegistry.java b/library/src/main/java/com/bumptech/glide/provider/ResourceDecoderRegistry.java
index 877114e90..bc3ce0d93 100644
--- a/library/src/main/java/com/bumptech/glide/provider/ResourceDecoderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/provider/ResourceDecoderRegistry.java
@@ -1,9 +1,12 @@
 package com.bumptech.glide.provider;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 
 /**
  * Contains an ordered list of {@link ResourceDecoder}s capable of decoding arbitrary data types
@@ -11,15 +14,36 @@
  */
 @SuppressWarnings("rawtypes")
 public class ResourceDecoderRegistry {
-  private final List<Entry<?, ?>> decoders = new ArrayList<>();
+  private final List<String> bucketPriorityList = new ArrayList<>();
+  private final Map<String, List<Entry<?, ?>>> decoders = new HashMap<>();
 
+  public synchronized void setBucketPriorityList(@NonNull List<String> buckets) {
+    List<String> previousBuckets = new ArrayList<>(bucketPriorityList);
+    bucketPriorityList.clear();
+    bucketPriorityList.addAll(buckets);
+    for (String previousBucket : previousBuckets) {
+      if (!buckets.contains(previousBucket)) {
+        // Keep any buckets from the previous list that aren't included here, but but them at the
+        // end.
+        bucketPriorityList.add(previousBucket);
+      }
+    }
+  }
+
+  @NonNull
   @SuppressWarnings("unchecked")
-  public synchronized <T, R> List<ResourceDecoder<T, R>> getDecoders(Class<T> dataClass,
-      Class<R> resourceClass) {
+  public synchronized <T, R> List<ResourceDecoder<T, R>> getDecoders(@NonNull Class<T> dataClass,
+      @NonNull Class<R> resourceClass) {
     List<ResourceDecoder<T, R>> result = new ArrayList<>();
-    for (Entry<?, ?> entry : decoders) {
-      if (entry.handles(dataClass, resourceClass)) {
-        result.add((ResourceDecoder<T, R>) entry.decoder);
+    for (String bucket : bucketPriorityList) {
+      List<Entry<?, ?>> entries = decoders.get(bucket);
+      if (entries == null) {
+        continue;
+      }
+      for (Entry<?, ?> entry : entries) {
+        if (entry.handles(dataClass, resourceClass)) {
+          result.add((ResourceDecoder<T, R>) entry.decoder);
+        }
       }
     }
     // TODO: cache result list.
@@ -27,26 +51,50 @@
     return result;
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
-  public synchronized <T, R> List<Class<R>> getResourceClasses(Class<T> dataClass,
-      Class<R> resourceClass) {
+  public synchronized <T, R> List<Class<R>> getResourceClasses(@NonNull Class<T> dataClass,
+      @NonNull Class<R> resourceClass) {
     List<Class<R>> result = new ArrayList<>();
-    for (Entry<?, ?> entry : decoders) {
-      if (entry.handles(dataClass, resourceClass)) {
-        result.add((Class<R>) entry.resourceClass);
+    for (String bucket : bucketPriorityList) {
+      List<Entry<?, ?>> entries = decoders.get(bucket);
+      if (entries == null) {
+        continue;
+      }
+      for (Entry<?, ?> entry : entries) {
+        if (entry.handles(dataClass, resourceClass)
+            && !result.contains((Class<R>) entry.resourceClass)) {
+          result.add((Class<R>) entry.resourceClass);
+        }
       }
     }
     return result;
   }
 
-  public synchronized <T, R> void append(ResourceDecoder<T, R> decoder, Class<T> dataClass,
-      Class<R> resourceClass) {
-    decoders.add(new Entry<>(dataClass, resourceClass, decoder));
+  public synchronized <T, R> void append(@NonNull String bucket,
+      @NonNull ResourceDecoder<T, R> decoder,
+      @NonNull Class<T> dataClass, @NonNull Class<R> resourceClass) {
+    getOrAddEntryList(bucket).add(new Entry<>(dataClass, resourceClass, decoder));
+  }
+
+  public synchronized <T, R> void prepend(@NonNull String bucket,
+      @NonNull ResourceDecoder<T, R> decoder,
+      @NonNull Class<T> dataClass, @NonNull Class<R> resourceClass) {
+    getOrAddEntryList(bucket).add(0, new Entry<>(dataClass, resourceClass, decoder));
   }
 
-  public synchronized <T, R> void prepend(ResourceDecoder<T, R> decoder, Class<T> dataClass,
-      Class<R> resourceClass) {
-    decoders.add(0, new Entry<>(dataClass, resourceClass, decoder));
+  @NonNull
+  private synchronized List<Entry<?, ?>> getOrAddEntryList(@NonNull String bucket) {
+    if (!bucketPriorityList.contains(bucket)) {
+      // Add this unspecified bucket as a low priority bucket.
+      bucketPriorityList.add(bucket);
+    }
+    List<Entry<?, ?>> entries = decoders.get(bucket);
+    if (entries == null) {
+      entries = new ArrayList<>();
+      decoders.put(bucket, entries);
+    }
+    return entries;
   }
 
   private static class Entry<T, R> {
@@ -54,13 +102,14 @@
     @Synthetic final Class<R> resourceClass;
     @Synthetic final ResourceDecoder<T, R> decoder;
 
-    public Entry(Class<T> dataClass, Class<R> resourceClass, ResourceDecoder<T, R> decoder) {
+    public Entry(@NonNull Class<T> dataClass, @NonNull Class<R> resourceClass,
+        ResourceDecoder<T, R> decoder) {
       this.dataClass = dataClass;
       this.resourceClass = resourceClass;
       this.decoder = decoder;
     }
 
-    public boolean handles(Class<?> dataClass, Class<?> resourceClass) {
+    public boolean handles(@NonNull Class<?> dataClass, @NonNull Class<?> resourceClass) {
       return this.dataClass.isAssignableFrom(dataClass) && resourceClass
           .isAssignableFrom(this.resourceClass);
     }
diff --git a/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java b/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java
index e096cc759..b1bd2977a 100644
--- a/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.provider;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import com.bumptech.glide.load.ResourceEncoder;
 import com.bumptech.glide.util.Synthetic;
@@ -7,22 +8,28 @@
 import java.util.List;
 
 /**
- * Contains an unordered list of {@link ResourceEncoder}s capable of encoding arbitrary resource
+ * Contains an ordered list of {@link ResourceEncoder}s capable of encoding arbitrary resource
  * types.
  */
 public class ResourceEncoderRegistry {
   // TODO: this should probably be a put.
-  final List<Entry<?>> encoders = new ArrayList<>();
+  private final List<Entry<?>> encoders = new ArrayList<>();
 
-  public synchronized <Z> void add(Class<Z> resourceClass, ResourceEncoder<Z> encoder) {
+  public synchronized <Z> void append(@NonNull Class<Z> resourceClass,
+      @NonNull ResourceEncoder<Z> encoder) {
     encoders.add(new Entry<>(resourceClass, encoder));
   }
 
+  public synchronized <Z> void prepend(@NonNull Class<Z> resourceClass,
+      @NonNull ResourceEncoder<Z> encoder) {
+    encoders.add(0, new Entry<>(resourceClass, encoder));
+  }
+
   @SuppressWarnings("unchecked")
   @Nullable
-  public synchronized <Z> ResourceEncoder<Z> get(Class<Z> resourceClass) {
-    int size = encoders.size();
-    for (int i = 0; i < size; i++) {
+  public synchronized <Z> ResourceEncoder<Z> get(@NonNull Class<Z> resourceClass) {
+    //noinspection ForLoopReplaceableByForEach to improve perf
+    for (int i = 0, size = encoders.size(); i < size; i++) {
       Entry<?> entry = encoders.get(i);
       if (entry.handles(resourceClass)) {
         return (ResourceEncoder<Z>) entry.encoder;
@@ -36,13 +43,13 @@
     private final Class<T> resourceClass;
     @Synthetic final ResourceEncoder<T> encoder;
 
-    Entry(Class<T> resourceClass, ResourceEncoder<T> encoder) {
+    Entry(@NonNull Class<T> resourceClass, @NonNull ResourceEncoder<T> encoder) {
       this.resourceClass = resourceClass;
       this.encoder = encoder;
     }
 
     @Synthetic
-    boolean handles(Class<?> resourceClass) {
+    boolean handles(@NonNull Class<?> resourceClass) {
       return this.resourceClass.isAssignableFrom(resourceClass);
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java
new file mode 100644
index 000000000..08136a327
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java
@@ -0,0 +1,1430 @@
+package com.bumptech.glide.request;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.MultiTransformation;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.model.stream.HttpGlideUrlLoader;
+import com.bumptech.glide.load.resource.bitmap.BitmapEncoder;
+import com.bumptech.glide.load.resource.bitmap.CenterCrop;
+import com.bumptech.glide.load.resource.bitmap.CenterInside;
+import com.bumptech.glide.load.resource.bitmap.CircleCrop;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.load.resource.bitmap.Downsampler;
+import com.bumptech.glide.load.resource.bitmap.DrawableTransformation;
+import com.bumptech.glide.load.resource.bitmap.FitCenter;
+import com.bumptech.glide.load.resource.bitmap.VideoDecoder;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
+import com.bumptech.glide.load.resource.gif.GifDrawableTransformation;
+import com.bumptech.glide.load.resource.gif.GifOptions;
+import com.bumptech.glide.signature.EmptySignature;
+import com.bumptech.glide.util.CachedHashCodeArrayMap;
+import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Util;
+import java.util.Map;
+
+/**
+ * A base object to allow method sharing between {@link RequestOptions} and
+ * {@link com.bumptech.glide.RequestBuilder}.
+ *
+ * <p>This class is not meant for general use and may change at any time.
+ *
+ * @param <T> The particular child implementation
+ */
+@SuppressWarnings({"PMD.UseUtilityClass", "unused"})
+public abstract class BaseRequestOptions<T extends BaseRequestOptions<T>> implements Cloneable {
+  private static final int UNSET = -1;
+  private static final int SIZE_MULTIPLIER = 1 << 1;
+  private static final int DISK_CACHE_STRATEGY = 1 << 2;
+  private static final int PRIORITY = 1 << 3;
+  private static final int ERROR_PLACEHOLDER = 1 << 4;
+  private static final int ERROR_ID = 1 << 5;
+  private static final int PLACEHOLDER = 1 << 6;
+  private static final int PLACEHOLDER_ID = 1 << 7;
+  private static final int IS_CACHEABLE = 1 << 8;
+  private static final int OVERRIDE = 1 << 9;
+  private static final int SIGNATURE = 1 << 10;
+  private static final int TRANSFORMATION = 1 << 11;
+  private static final int RESOURCE_CLASS = 1 << 12;
+  private static final int FALLBACK = 1 << 13;
+  private static final int FALLBACK_ID = 1 << 14;
+  private static final int THEME = 1 << 15;
+  private static final int TRANSFORMATION_ALLOWED = 1 << 16;
+  private static final int TRANSFORMATION_REQUIRED = 1 << 17;
+  private static final int USE_UNLIMITED_SOURCE_GENERATORS_POOL = 1 << 18;
+  private static final int ONLY_RETRIEVE_FROM_CACHE = 1 << 19;
+  private static final int USE_ANIMATION_POOL = 1 << 20;
+
+  private int fields;
+  private float sizeMultiplier = 1f;
+  @NonNull
+  private DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.AUTOMATIC;
+  @NonNull
+  private Priority priority = Priority.NORMAL;
+  @Nullable
+  private Drawable errorPlaceholder;
+  private int errorId;
+  @Nullable
+  private Drawable placeholderDrawable;
+  private int placeholderId;
+  private boolean isCacheable = true;
+  private int overrideHeight = UNSET;
+  private int overrideWidth = UNSET;
+  @NonNull
+  private Key signature = EmptySignature.obtain();
+  private boolean isTransformationRequired;
+  private boolean isTransformationAllowed = true;
+  @Nullable
+  private Drawable fallbackDrawable;
+  private int fallbackId;
+  @NonNull
+  private Options options = new Options();
+  @NonNull
+  private Map<Class<?>, Transformation<?>> transformations = new CachedHashCodeArrayMap<>();
+  @NonNull
+  private Class<?> resourceClass = Object.class;
+  private boolean isLocked;
+  @Nullable
+  private Resources.Theme theme;
+  private boolean isAutoCloneEnabled;
+  private boolean useUnlimitedSourceGeneratorsPool;
+  private boolean onlyRetrieveFromCache;
+  private boolean isScaleOnlyOrNoTransform = true;
+  private boolean useAnimationPool;
+
+
+  private static boolean isSet(int fields, int flag) {
+    return (fields & flag) != 0;
+  }
+
+  /**
+   * Applies a multiplier to the {@link com.bumptech.glide.request.target.Target}'s size before
+   * loading the resource. Useful for loading thumbnails or trying to avoid loading huge resources
+   * (particularly {@link Bitmap}s on devices with overly dense screens.
+   *
+   * @param sizeMultiplier The multiplier to apply to the
+   *                       {@link com.bumptech.glide.request.target.Target}'s dimensions when
+   *                       loading the resource.
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public T sizeMultiplier(@FloatRange(from = 0, to = 1) float sizeMultiplier) {
+    if (isAutoCloneEnabled) {
+      return clone().sizeMultiplier(sizeMultiplier);
+    }
+
+    if (sizeMultiplier < 0f || sizeMultiplier > 1f) {
+      throw new IllegalArgumentException("sizeMultiplier must be between 0 and 1");
+    }
+    this.sizeMultiplier = sizeMultiplier;
+    fields |= SIZE_MULTIPLIER;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * If set to {@code true}, uses a cached unlimited {@link java.util.concurrent.Executor} to run
+   * the request.
+   *
+   * <p>This method should <em>ONLY</em> be used when a Glide load is started recursively on one
+   * of Glide's threads as part of another request. Using this method in other scenarios can lead
+   * to excessive memory usage and OOMs and/or a significant decrease in performance across an
+   * application.
+   *
+   * <p>If both this method and {@link #useAnimationPool(boolean)} are set, this method will be
+   * preferred and {@link #useAnimationPool(boolean)} will be ignored.
+   */
+  @NonNull
+  @CheckResult
+  public T useUnlimitedSourceGeneratorsPool(boolean flag) {
+    if (isAutoCloneEnabled) {
+      return clone().useUnlimitedSourceGeneratorsPool(flag);
+    }
+
+    this.useUnlimitedSourceGeneratorsPool = flag;
+    fields |= USE_UNLIMITED_SOURCE_GENERATORS_POOL;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * If set to {@code true}, uses a special {@link java.util.concurrent.Executor} that is used
+   * exclusively for decoding frames of animated resources, like GIFs.
+   *
+   * <p>The animation executor disallows network operations and must not be used for loads that
+   * may load remote data. The animation executor has fewer threads available to it than Glide's
+   * normal executors and is only useful as a way of avoiding blocking on longer and more expensive
+   * reads for critical requests like those in an animating GIF.
+   *
+   * <p>If both {@link #useUnlimitedSourceGeneratorsPool(boolean)} and this method are set,
+   * {@link #useUnlimitedSourceGeneratorsPool(boolean)} will be preferred and this method will be
+   * ignored.
+   */
+  @NonNull
+  @CheckResult
+  public T useAnimationPool(boolean flag) {
+    if (isAutoCloneEnabled) {
+      return clone().useAnimationPool(flag);
+    }
+
+    useAnimationPool = flag;
+    fields |= USE_ANIMATION_POOL;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   *
+   * If set to true, will only load an item if found in the cache, and will not fetch from source.
+   */
+  @NonNull
+  @CheckResult
+  public T onlyRetrieveFromCache(boolean flag) {
+    if (isAutoCloneEnabled) {
+      return clone().onlyRetrieveFromCache(flag);
+    }
+
+    this.onlyRetrieveFromCache = flag;
+    fields |= ONLY_RETRIEVE_FROM_CACHE;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets the {@link DiskCacheStrategy} to use for this load.
+   *
+   * <p> Defaults to {@link DiskCacheStrategy#AUTOMATIC}. </p>
+   *
+   * <p> For most applications {@link DiskCacheStrategy#RESOURCE} is
+   * ideal. Applications that use the same resource multiple times in multiple sizes and are willing
+   * to trade off some speed and disk space in return for lower bandwidth usage may want to consider
+   * using {@link DiskCacheStrategy#DATA} or
+   * {@link DiskCacheStrategy#ALL}. </p>
+   *
+   * @param strategy The strategy to use.
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public T diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    if (isAutoCloneEnabled) {
+      return clone().diskCacheStrategy(strategy);
+    }
+    this.diskCacheStrategy = Preconditions.checkNotNull(strategy);
+    fields |= DISK_CACHE_STRATEGY;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets the priority for this load.
+   *
+   * @param priority A priority.
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public T priority(@NonNull Priority priority) {
+    if (isAutoCloneEnabled) {
+      return clone().priority(priority);
+    }
+
+    this.priority = Preconditions.checkNotNull(priority);
+    fields |= PRIORITY;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets an {@link Drawable} to display while a resource is loading.
+   *
+   * <p>Replaces any previous calls to this method or {@link #placeholder(int)}.
+   *
+   * @param drawable The drawable to display as a placeholder.
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public T placeholder(@Nullable Drawable drawable) {
+    if (isAutoCloneEnabled) {
+      return clone().placeholder(drawable);
+    }
+
+    this.placeholderDrawable = drawable;
+    fields |= PLACEHOLDER;
+
+    placeholderId = 0;
+    fields &= ~PLACEHOLDER_ID;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets an Android resource id for a {@link Drawable} resource to
+   * display while a resource is loading.
+   *
+   * <p>Replaces any previous calls to this method or {@link #placeholder(Drawable)}
+   *
+   * @param resourceId The id of the resource to use as a placeholder
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public T placeholder(@DrawableRes int resourceId) {
+    if (isAutoCloneEnabled) {
+      return clone().placeholder(resourceId);
+    }
+
+    this.placeholderId = resourceId;
+    fields |= PLACEHOLDER_ID;
+
+    placeholderDrawable = null;
+    fields &= ~PLACEHOLDER;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets an {@link Drawable} to display if the model provided to
+   * {@link com.bumptech.glide.RequestBuilder#load(Object)} is {@code null}.
+   *
+   * <p> If a fallback is not set, null models will cause the error drawable to be displayed. If the
+   * error drawable is not set, the placeholder will be displayed.
+   *
+   * <p>Replaces any previous calls to this method or {@link #fallback(int)}.
+   *
+   * @see #placeholder(Drawable)
+   * @see #placeholder(int)
+   *
+   * @param drawable The drawable to display as a placeholder.
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public T fallback(@Nullable Drawable drawable) {
+    if (isAutoCloneEnabled) {
+      return clone().fallback(drawable);
+    }
+
+    this.fallbackDrawable = drawable;
+    fields |= FALLBACK;
+
+    fallbackId = 0;
+    fields &= ~FALLBACK_ID;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets a resource to display if the model provided to
+   * {@link com.bumptech.glide.RequestBuilder#load(Object)} is {@code null}.
+   *
+   * <p> If a fallback is not set, null models will cause the error drawable to be displayed. If
+   * the error drawable is not set, the placeholder will be displayed.
+   *
+   * <p>Replaces any previous calls to this method or {@link #fallback(Drawable)}.
+   *
+   * @see #placeholder(Drawable)
+   * @see #placeholder(int)
+   *
+   * @param resourceId The id of the resource to use as a fallback.
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public T fallback(@DrawableRes int resourceId) {
+    if (isAutoCloneEnabled) {
+      return clone().fallback(resourceId);
+    }
+
+    this.fallbackId = resourceId;
+    fields |= FALLBACK_ID;
+
+    fallbackDrawable = null;
+    fields &= ~FALLBACK;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets a {@link Drawable} to display if a load fails.
+   *
+   * <p>Replaces any previous calls to this method or {@link #error(int)}
+   *
+   * @param drawable The drawable to display.
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public T error(@Nullable Drawable drawable) {
+    if (isAutoCloneEnabled) {
+      return clone().error(drawable);
+    }
+
+    this.errorPlaceholder = drawable;
+    fields |= ERROR_PLACEHOLDER;
+
+    this.errorId = 0;
+    fields &= ~ERROR_ID;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets a resource to display if a load fails.
+   *
+   * <p>Replaces any previous calls to this method or {@link #error(Drawable)}
+   *
+   * @param resourceId The id of the resource to use as a placeholder.
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public T error(@DrawableRes int resourceId) {
+    if (isAutoCloneEnabled) {
+      return clone().error(resourceId);
+    }
+    this.errorId = resourceId;
+    fields |= ERROR_ID;
+
+    this.errorPlaceholder = null;
+    fields &= ~ERROR_PLACEHOLDER;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets the {@link android.content.res.Resources.Theme} to apply when loading {@link Drawable}s
+   * for resource ids provided via {@link #error(int)}, {@link #placeholder(int)}, and
+   * {@link #fallback(Drawable)}.
+   *
+   * <p>The theme is <em>NOT</em> applied in the decoder that will attempt to decode a given
+   * resource id model on Glide's background threads. The theme is used exclusively on the main
+   * thread to obtain placeholder/error/fallback drawables to avoid leaking Activities.
+   *
+   * <p>If the {@link android.content.Context} of the {@link android.app.Fragment} or
+   * {@link android.app.Activity} used to start this load has a different
+   * {@link android.content.res.Resources.Theme}, the {@link android.content.res.Resources.Theme}
+   * provided here will override the {@link android.content.res.Resources.Theme} of the
+   * {@link android.content.Context}.
+   *
+   * @param theme The theme to use when loading Drawables.
+   * @return this request builder.
+   */
+  @NonNull
+  @CheckResult
+  public T theme(@Nullable Resources.Theme theme) {
+    if (isAutoCloneEnabled) {
+      return clone().theme(theme);
+    }
+
+    this.theme = theme;
+    fields |= THEME;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Allows the loaded resource to skip the memory cache.
+   *
+   * <p> Note - this is not a guarantee. If a request is already pending for this resource and that
+   * request is not also skipping the memory cache, the resource will be cached in memory.</p>
+   *
+   * @param skip True to allow the resource to skip the memory cache.
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public T skipMemoryCache(boolean skip) {
+    if (isAutoCloneEnabled) {
+      return clone().skipMemoryCache(true);
+    }
+
+    this.isCacheable = !skip;
+    fields |= IS_CACHEABLE;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Overrides the {@link com.bumptech.glide.request.target.Target}'s width and height with the
+   * given values. This is useful for thumbnails, and should only be used for other cases when you
+   * need a very specific image size.
+   *
+   * @param width  The width in pixels to use to load the resource.
+   * @param height The height in pixels to use to load the resource.
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public T override(int width, int height) {
+    if (isAutoCloneEnabled) {
+      return clone().override(width, height);
+    }
+
+    this.overrideWidth = width;
+    this.overrideHeight = height;
+    fields |= OVERRIDE;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Overrides the {@link com.bumptech.glide.request.target.Target}'s width and height with the
+   * given size.
+   *
+   * @see #override(int, int)
+   * @param size The width and height to use.
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public T override(int size) {
+    return override(size, size);
+  }
+
+  /**
+   * Sets some additional data to be mixed in to the memory and disk cache keys allowing the caller
+   * more control over when cached data is invalidated.
+   *
+   * <p> Note - The signature does not replace the cache key, it is purely additive. </p>
+   *
+   * @param signature A unique non-null {@link Key} representing the current
+   *                  state of the model that will be mixed in to the cache key.
+   * @return This request builder.
+   * @see com.bumptech.glide.signature.ObjectKey
+   */
+  @NonNull
+  @CheckResult
+  public T signature(@NonNull Key signature) {
+    if (isAutoCloneEnabled) {
+      return clone().signature(signature);
+    }
+
+    this.signature = Preconditions.checkNotNull(signature);
+    fields |= SIGNATURE;
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Returns a copy of this request builder with all of the options put so far on this builder.
+   *
+   * <p> This method returns a "deep" copy in that all non-immutable arguments are copied such that
+   * changes to one builder will not affect the other builder. However, in addition to immutable
+   * arguments, the current model is not copied copied so changes to the model will affect both
+   * builders. </p>
+   *
+   * <p> Even if this object was locked, the cloned object returned from this method will not be
+   * locked. </p>
+   */
+  @SuppressWarnings({
+      "unchecked",
+      // we don't want to throw to be user friendly
+      "PMD.CloneThrowsCloneNotSupportedException",
+      // The types we're using here do this automatically.
+      "PMD.CloneMethodReturnTypeMustMatchClassName"
+  })
+  @CheckResult
+  @Override
+  public T clone() {
+    try {
+      BaseRequestOptions<?> result = (BaseRequestOptions<?>) super.clone();
+      result.options = new Options();
+      result.options.putAll(options);
+      result.transformations = new CachedHashCodeArrayMap<>();
+      result.transformations.putAll(transformations);
+      result.isLocked = false;
+      result.isAutoCloneEnabled = false;
+      return (T) result;
+    } catch (CloneNotSupportedException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  @NonNull
+  @CheckResult
+  public <Y> T set(@NonNull Option<Y> option, @NonNull Y value) {
+    if (isAutoCloneEnabled) {
+      return clone().set(option, value);
+    }
+
+    Preconditions.checkNotNull(option);
+    Preconditions.checkNotNull(value);
+    options.set(option, value);
+    return selfOrThrowIfLocked();
+  }
+
+  @NonNull
+  @CheckResult
+  public T decode(@NonNull Class<?> resourceClass) {
+    if (isAutoCloneEnabled) {
+      return clone().decode(resourceClass);
+    }
+
+    this.resourceClass = Preconditions.checkNotNull(resourceClass);
+    fields |= RESOURCE_CLASS;
+    return selfOrThrowIfLocked();
+  }
+
+  public final boolean isTransformationAllowed() {
+    return isTransformationAllowed;
+  }
+
+  public final boolean isTransformationSet() {
+    return isSet(TRANSFORMATION);
+  }
+
+  public final boolean isLocked() {
+    return isLocked;
+  }
+
+  /**
+   * Sets the value for key
+   * {@link com.bumptech.glide.load.resource.bitmap.BitmapEncoder#COMPRESSION_FORMAT}.
+   */
+  @NonNull
+  @CheckResult
+  public T encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return set(BitmapEncoder.COMPRESSION_FORMAT, Preconditions.checkNotNull(format));
+  }
+
+  /**
+   * Sets the value for key
+   * {@link BitmapEncoder#COMPRESSION_QUALITY}.
+   */
+  @NonNull
+  @CheckResult
+  public T encodeQuality(@IntRange(from = 0, to = 100) int quality) {
+    return set(BitmapEncoder.COMPRESSION_QUALITY, quality);
+  }
+
+  /**
+   * Sets the time position of the frame to extract from a video.
+   *
+   * <p>This is a component option specific to {@link VideoDecoder}. If the default video
+   * decoder is replaced or skipped because of your configuration, this option may be ignored.
+   *
+   * @see VideoDecoder#TARGET_FRAME
+   * @param frameTimeMicros The time position in microseconds of the desired frame. If negative, the
+   *                        Android framework implementation return a representative frame.
+   */
+  @NonNull
+  @CheckResult
+  public T frame(@IntRange(from = 0) long frameTimeMicros) {
+    return set(VideoDecoder.TARGET_FRAME, frameTimeMicros);
+  }
+
+  /**
+   * Sets the {@link DecodeFormat} to use when decoding {@link Bitmap} objects using
+   * {@link Downsampler} and Glide's default GIF decoders.
+   *
+   * <p>{@link DecodeFormat} is a request, not a requirement. It's possible the resource will be
+   * decoded using a decoder that cannot control the format
+   * ({@link android.media.MediaMetadataRetriever} for example), or that the decoder may choose to
+   * ignore the requested format if it can't display the image (i.e. RGB_565 is requested, but the
+   * image has alpha).
+   *
+   * <p>This is a component option specific to {@link Downsampler} and Glide's GIF decoders. If the
+   * default Bitmap decoders are replaced or skipped because of your configuration, this option may
+   * be ignored.
+   *
+   * <p>To set only the format used when decoding {@link Bitmap}s, use
+   * {@link #set(Option, Object)}} and {@link Downsampler#DECODE_FORMAT}. To set only the format
+   * used when decoding GIF frames, use {@link #set(Option, Object)} and
+   * {@link GifOptions#DECODE_FORMAT}.
+   *
+   * @see Downsampler#DECODE_FORMAT
+   * @see GifOptions#DECODE_FORMAT
+   */
+  @NonNull
+  @CheckResult
+  public T format(@NonNull DecodeFormat format) {
+    Preconditions.checkNotNull(format);
+    return set(Downsampler.DECODE_FORMAT, format)
+        .set(GifOptions.DECODE_FORMAT, format);
+  }
+
+  /**
+   * Disables the use of {@link android.graphics.Bitmap.Config#HARDWARE} in {@link Downsampler} to
+   * avoid errors caused by inspecting Bitmap pixels, drawing with hardware support disabled,
+   * drawing to {@link android.graphics.Canvas}s backed by {@link Bitmap}s etc.
+   *
+   * <p>It's almost never safe to set {@link Downsampler#ALLOW_HARDWARE_CONFIG} to {@code true} so
+   * we only provide a way to disable hardware configs entirely. If no option is set for
+   * {@link Downsampler#ALLOW_HARDWARE_CONFIG}, Glide will set the value per request based on
+   * whether or not a {@link Transformation} is applied and if one is, the type of
+   * {@link Transformation} applied. Built in transformations like {@link FitCenter} and
+   * {@link com.bumptech.glide.load.resource.bitmap.DownsampleStrategy.CenterOutside} can safely use
+   * {@link android.graphics.Bitmap.Config#HARDWARE} because they can be entirely replaced by
+   * scaling within {@link Downsampler}. {@link Transformation}s like {@link #circleCrop()} that
+   * can't be replicated by {@link Downsampler} cannot use {@link Bitmap.Config#HARDWARE} because
+   * {@link android.graphics.Bitmap.Config#HARDWARE} cannot be drawn to
+   * {@link android.graphics.Canvas}s, which is required by most {@link Transformation}s.
+   */
+  @NonNull
+  @CheckResult
+  public T disallowHardwareConfig() {
+    return set(Downsampler.ALLOW_HARDWARE_CONFIG, false);
+  }
+
+  /**
+   * Sets the {@link DownsampleStrategy} to use when decoding {@link Bitmap Bitmaps} using
+   * {@link Downsampler}.
+   *
+   * <p>This is a component option specific to {@link Downsampler}. If the defautlt Bitmap decoder
+   * is replaced or skipped because of your configuration, this option may be ignored.
+   */
+  @NonNull
+  @CheckResult
+  public T downsample(@NonNull DownsampleStrategy strategy) {
+    return set(DownsampleStrategy.OPTION, Preconditions.checkNotNull(strategy));
+  }
+
+  /**
+   * Sets the read and write timeout for the http requests used to load the image.
+   *
+   * <p>This is a component option specific to Glide's default networking library and
+   * {@link com.bumptech.glide.load.model.stream.HttpGlideUrlLoader}. If you use any other
+   * networking library including Glide's Volley or OkHttp integration libraries, this option will
+   * be ignored.
+   *
+   * @see com.bumptech.glide.load.model.stream.HttpGlideUrlLoader#TIMEOUT
+   * @param timeoutMs The read and write timeout in milliseconds.
+   */
+  @NonNull
+  @CheckResult
+  public T timeout(@IntRange(from = 0) int timeoutMs) {
+    return set(HttpGlideUrlLoader.TIMEOUT, timeoutMs);
+  }
+
+  /**
+   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterCrop} to all default types, and
+   * ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @see #optionalTransform(Class, Transformation)
+   * @see #centerCrop()
+   */
+  @NonNull
+  @CheckResult
+  public T optionalCenterCrop() {
+    return optionalTransform(DownsampleStrategy.CENTER_OUTSIDE, new CenterCrop());
+  }
+
+  /**
+   * Applies {@link CenterCrop} to all default types and
+   * throws an exception if asked to transform an unknown type.
+   *
+   * <p>this will override previous calls to {@link #dontTransform()} ()}.
+   *
+   * @see #transform(Class, Transformation)
+   * @see #optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public T centerCrop() {
+    return transform(DownsampleStrategy.CENTER_OUTSIDE, new CenterCrop());
+  }
+
+  /**
+   *
+   * Applies {@link FitCenter} and to all default types, {@link DownsampleStrategy#FIT_CENTER} to
+   * image types, and ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()} and previous calls to
+   * {@link #downsample(DownsampleStrategy)}.
+   *
+   * @see #optionalTransform(Class, Transformation)
+   * @see #fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public T optionalFitCenter() {
+    return optionalScaleOnlyTransform(DownsampleStrategy.FIT_CENTER, new FitCenter());
+  }
+
+  /**
+   * Applies {@link FitCenter} and to all default types, {@link DownsampleStrategy#FIT_CENTER} to
+   * image types, and throws an exception if asked to transform an unknown
+   * type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()} and previous calls to
+   * {@link #downsample(DownsampleStrategy)}.
+   *
+   * @see #transform(Class, Transformation)
+   * @see #optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public T fitCenter() {
+    return scaleOnlyTransform(DownsampleStrategy.FIT_CENTER, new FitCenter());
+  }
+
+  /**
+   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterInside} to all default types,
+   * {@link DownsampleStrategy#CENTER_INSIDE} to image types, and ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()} and previous calls to
+   * {@link #downsample(DownsampleStrategy)}.
+   *
+   * @see #optionalTransform(Class, Transformation)
+   * @see #centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public T optionalCenterInside() {
+    return optionalScaleOnlyTransform(DownsampleStrategy.CENTER_INSIDE, new CenterInside());
+  }
+
+  /**
+   * Applies {@link CenterInside} to all default types, {@link DownsampleStrategy#CENTER_INSIDE} to
+   * image types and throws an exception if asked to transform an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()} and previous calls to
+   * {@link #downsample(DownsampleStrategy)}.
+   *
+   * @see #transform(Class, Transformation)
+   * @see #optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public T centerInside() {
+    return scaleOnlyTransform(DownsampleStrategy.CENTER_INSIDE, new CenterInside());
+  }
+
+  /**
+   * Applies {@link CircleCrop} to all default types, and ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @see #optionalTransform(Transformation)
+   * @see #circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public T optionalCircleCrop() {
+    return optionalTransform(DownsampleStrategy.CENTER_OUTSIDE, new CircleCrop());
+  }
+
+  /**
+   * Applies {@link CircleCrop} to all default types and throws an exception if asked to transform
+   * an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @see #transform(Class, Transformation)
+   * @see #optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public T circleCrop() {
+    return transform(DownsampleStrategy.CENTER_INSIDE, new CircleCrop());
+  }
+
+  // calling optionalTransform() on the result of clone() requires greater access.
+  // calling downsample is guaranteed to modify the current object by the isAutoCloneEnabledCheck.
+  @SuppressWarnings({"WeakerAccess", "CheckResult"})
+  @NonNull
+  final T optionalTransform(@NonNull DownsampleStrategy downsampleStrategy,
+      @NonNull Transformation<Bitmap> transformation) {
+    if (isAutoCloneEnabled) {
+      return clone().optionalTransform(downsampleStrategy, transformation);
+    }
+
+    downsample(downsampleStrategy);
+    return transform(transformation, /*isRequired=*/ false);
+  }
+
+  // calling transform() on the result of clone() requires greater access.
+  // calling downsample is guaranteed to modify the current object by the isAutoCloneEnabledCheck.
+  @SuppressWarnings({"WeakerAccess", "CheckResult"})
+  @NonNull
+  @CheckResult
+  final T transform(@NonNull DownsampleStrategy downsampleStrategy,
+      @NonNull Transformation<Bitmap> transformation) {
+    if (isAutoCloneEnabled) {
+      return clone().transform(downsampleStrategy, transformation);
+    }
+
+    downsample(downsampleStrategy);
+    return transform(transformation);
+  }
+
+  @NonNull
+  private T scaleOnlyTransform(
+      @NonNull DownsampleStrategy strategy, @NonNull Transformation<Bitmap> transformation) {
+    return scaleOnlyTransform(strategy, transformation, true /*isTransformationRequired*/);
+  }
+
+  @NonNull
+  private T optionalScaleOnlyTransform(
+      @NonNull DownsampleStrategy strategy, @NonNull Transformation<Bitmap> transformation) {
+    return scaleOnlyTransform(strategy, transformation, false /*isTransformationRequired*/);
+  }
+
+  // We know that result will always be T since we created result.
+  @SuppressWarnings("unchecked")
+  @NonNull
+  private T scaleOnlyTransform(
+      @NonNull DownsampleStrategy strategy,
+      @NonNull Transformation<Bitmap> transformation,
+      boolean isTransformationRequired) {
+    BaseRequestOptions<T> result = isTransformationRequired
+          ? transform(strategy, transformation) : optionalTransform(strategy, transformation);
+    result.isScaleOnlyOrNoTransform = true;
+    return (T) result;
+  }
+
+  /**
+   * Applies the given {@link Transformation} for
+   * {@link Bitmap Bitmaps} to the default types ({@link Bitmap},
+   * {@link android.graphics.drawable.BitmapDrawable}, and
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable})
+   * and throws an exception if asked to transform an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param transformation Any {@link Transformation} for {@link Bitmap}s.
+   * @see #optionalTransform(Transformation)
+   * @see #optionalTransform(Class, Transformation)
+   */
+  // Guaranteed to modify the current object by the isAutoCloneEnabledCheck.
+  @SuppressWarnings("CheckResult")
+  @NonNull
+  @CheckResult
+  public T transform(@NonNull Transformation<Bitmap> transformation) {
+    return transform(transformation, /*isRequired=*/ true);
+  }
+
+  /**
+   * Applies the given {@link Transformation}s in the given order for
+   * {@link Bitmap Bitmaps} to the default types ({@link Bitmap},
+   * {@link android.graphics.drawable.BitmapDrawable}, and
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable})
+   * and throws an exception if asked to transform an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param transformations One or more {@link Transformation}s for {@link Bitmap}s.
+   * @see #optionalTransform(Transformation)
+   * @see #optionalTransform(Class, Transformation)
+   */
+  // Guaranteed to modify the current object by the isAutoCloneEnabledCheck.
+  @SuppressWarnings({"unchecked", "varargs", "CheckResult"})
+  @NonNull
+  @CheckResult
+  public T transforms(@NonNull Transformation<Bitmap>... transformations) {
+    return transform(new MultiTransformation<>(transformations), /*isRequired=*/ true);
+  }
+
+  /**
+   * Applies the given {@link Transformation} for
+   * {@link Bitmap Bitmaps} to the default types ({@link Bitmap},
+   * {@link android.graphics.drawable.BitmapDrawable}, and
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable}) and ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param transformation Any {@link Transformation} for {@link Bitmap}s.
+   * @see #transform(Transformation)
+   * @see #transform(Class, Transformation)
+   */
+  // Guaranteed to modify the current object by the isAutoCloneEnabledCheck.
+  @SuppressWarnings("CheckResult")
+  @NonNull
+  @CheckResult
+  public T optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return transform(transformation, /*isRequired=*/ false);
+  }
+
+  @NonNull
+  T transform(
+      @NonNull Transformation<Bitmap> transformation, boolean isRequired) {
+    if (isAutoCloneEnabled) {
+      return clone().transform(transformation, isRequired);
+    }
+
+    DrawableTransformation drawableTransformation =
+        new DrawableTransformation(transformation, isRequired);
+    transform(Bitmap.class, transformation, isRequired);
+    transform(Drawable.class, drawableTransformation, isRequired);
+    // TODO: remove BitmapDrawable decoder and this transformation.
+    // Registering as BitmapDrawable is simply an optimization to avoid some iteration and
+    // isAssignableFrom checks when obtaining the transformation later on. It can be removed without
+    // affecting the functionality.
+    transform(BitmapDrawable.class, drawableTransformation.asBitmapDrawable(), isRequired);
+    transform(GifDrawable.class, new GifDrawableTransformation(transformation), isRequired);
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Applies the given {@link Transformation} for any decoded resource of
+   * the given type and allows unknown resource types to be ignored.
+   *
+   * <p> Users can apply different transformations for each resource class. Applying a
+   * {@link Transformation} for a resource type that already has a
+   * {@link Transformation} will override the previous call. </p>
+   *
+   * <p> If any calls are made to the non-optional transform methods, then attempting to transform
+   * an unknown resource class will throw an exception. To allow unknown types, users must always
+   * call the optional version of each method. </p>
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param resourceClass  The type of resource to transform.
+   * @param transformation The {@link Transformation} to apply.
+   */
+  @NonNull
+  @CheckResult
+  public <Y> T optionalTransform(
+      @NonNull Class<Y> resourceClass, @NonNull Transformation<Y> transformation) {
+    return transform(resourceClass, transformation, /*isRequired=*/ false);
+  }
+
+  @NonNull
+  <Y> T transform(
+      @NonNull Class<Y> resourceClass,
+      @NonNull Transformation<Y> transformation,
+      boolean isRequired) {
+    if (isAutoCloneEnabled) {
+      return clone().transform(resourceClass, transformation, isRequired);
+    }
+
+    Preconditions.checkNotNull(resourceClass);
+    Preconditions.checkNotNull(transformation);
+    transformations.put(resourceClass, transformation);
+    fields |= TRANSFORMATION;
+    isTransformationAllowed = true;
+    fields |= TRANSFORMATION_ALLOWED;
+    // Always set to false here. Known scale only transformations will call this method and then
+    // set isScaleOnlyOrNoTransform to true immediately after.
+    isScaleOnlyOrNoTransform = false;
+    if (isRequired) {
+      fields |= TRANSFORMATION_REQUIRED;
+      isTransformationRequired = true;
+    }
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Applies the given {@link Transformation} for any decoded resource of
+   * the given type and throws if asked to transform an unknown resource type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param resourceClass  The type of resource to transform.
+   * @param transformation The {@link Transformation} to apply.
+   * @see #optionalTransform(Class, Transformation)
+   */
+  // Guaranteed to modify the current object by the isAutoCloneEnabledCheck.
+  @SuppressWarnings("CheckResult")
+  @NonNull
+  @CheckResult
+  public <Y> T transform(
+      @NonNull Class<Y> resourceClass, @NonNull Transformation<Y> transformation) {
+    return transform(resourceClass, transformation, /*isRequired=*/ true);
+  }
+
+  /**
+   * Removes all applied {@link Transformation Transformations} for all
+   * resource classes and allows unknown resource types to be transformed without throwing an
+   * exception.
+   */
+  @NonNull
+  @CheckResult
+  public T dontTransform() {
+    if (isAutoCloneEnabled) {
+      return clone().dontTransform();
+    }
+
+    transformations.clear();
+    fields &= ~TRANSFORMATION;
+    isTransformationRequired = false;
+    fields &= ~TRANSFORMATION_REQUIRED;
+    isTransformationAllowed = false;
+    fields |= TRANSFORMATION_ALLOWED;
+    isScaleOnlyOrNoTransform = true;
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Disables resource decoders that return animated resources so any resource returned will be
+   * static.
+   *
+   * <p> To disable transitions (fades etc) use
+   * {@link com.bumptech.glide.TransitionOptions#dontTransition()}</p>
+   */
+  // Guaranteed to modify the current object by the isAutoCloneEnabledCheck.
+  @SuppressWarnings("CheckResult")
+  @NonNull
+  @CheckResult
+  public T dontAnimate() {
+    return set(GifOptions.DISABLE_ANIMATION, true);
+  }
+
+  /**
+   * Updates this options set with any options that are explicitly set in the given
+   * {@code T} object and returns this object if {@link #autoClone()} is disabled or
+   * a new {@code T} object if {@link #autoClone()} is enabled.
+   *
+   * <p>{@code #apply} only replaces those values that are explicitly set in the given
+   * {@code T}. If you need to completely reset all previously set options, create a
+   * new {@code T} object instead of using this method.
+   *
+   * <p>The options that will be set to values in the returned {@code T} object is the
+   * intersection of the set of options in this {@code T} object and the given
+   * {@code T} object that were explicitly set. If the values of any of the options
+   * conflict, the values in the returned {@code T} object will be set to those in the
+   * given {@code T} object.
+   */
+  @NonNull
+  @CheckResult
+  public T apply(@NonNull BaseRequestOptions<?> o) {
+    if (isAutoCloneEnabled) {
+      return clone().apply(o);
+    }
+    BaseRequestOptions<?> other = o;
+
+    if (isSet(other.fields, SIZE_MULTIPLIER)) {
+      sizeMultiplier = other.sizeMultiplier;
+    }
+    if (isSet(other.fields, USE_UNLIMITED_SOURCE_GENERATORS_POOL)) {
+      useUnlimitedSourceGeneratorsPool = other.useUnlimitedSourceGeneratorsPool;
+    }
+    if (isSet(other.fields, USE_ANIMATION_POOL)) {
+      useAnimationPool = other.useAnimationPool;
+    }
+    if (isSet(other.fields, DISK_CACHE_STRATEGY)) {
+      diskCacheStrategy = other.diskCacheStrategy;
+    }
+    if (isSet(other.fields, PRIORITY)) {
+      priority = other.priority;
+    }
+    if (isSet(other.fields, ERROR_PLACEHOLDER)) {
+      errorPlaceholder = other.errorPlaceholder;
+      errorId = 0;
+      fields &= ~ERROR_ID;
+    }
+    if (isSet(other.fields, ERROR_ID)) {
+      errorId = other.errorId;
+      errorPlaceholder = null;
+      fields &= ~ERROR_PLACEHOLDER;
+    }
+    if (isSet(other.fields, PLACEHOLDER)) {
+      placeholderDrawable = other.placeholderDrawable;
+      placeholderId = 0;
+      fields &= ~PLACEHOLDER_ID;
+    }
+    if (isSet(other.fields, PLACEHOLDER_ID)) {
+      placeholderId = other.placeholderId;
+      placeholderDrawable = null;
+      fields &= ~PLACEHOLDER;
+    }
+    if (isSet(other.fields, IS_CACHEABLE)) {
+      isCacheable = other.isCacheable;
+    }
+    if (isSet(other.fields, OVERRIDE)) {
+      overrideWidth = other.overrideWidth;
+      overrideHeight = other.overrideHeight;
+    }
+    if (isSet(other.fields, SIGNATURE)) {
+      signature = other.signature;
+    }
+    if (isSet(other.fields, RESOURCE_CLASS)) {
+      resourceClass = other.resourceClass;
+    }
+    if (isSet(other.fields, FALLBACK)) {
+      fallbackDrawable = other.fallbackDrawable;
+      fallbackId = 0;
+      fields &= ~FALLBACK_ID;
+    }
+    if (isSet(other.fields, FALLBACK_ID)) {
+      fallbackId = other.fallbackId;
+      fallbackDrawable = null;
+      fields &= ~FALLBACK;
+    }
+    if (isSet(other.fields, THEME)) {
+      theme = other.theme;
+    }
+    if (isSet(other.fields, TRANSFORMATION_ALLOWED)) {
+      isTransformationAllowed = other.isTransformationAllowed;
+    }
+    if (isSet(other.fields, TRANSFORMATION_REQUIRED)) {
+      isTransformationRequired = other.isTransformationRequired;
+    }
+    if (isSet(other.fields, TRANSFORMATION)) {
+      transformations.putAll(other.transformations);
+      isScaleOnlyOrNoTransform = other.isScaleOnlyOrNoTransform;
+    }
+    if (isSet(other.fields, ONLY_RETRIEVE_FROM_CACHE)) {
+      onlyRetrieveFromCache = other.onlyRetrieveFromCache;
+    }
+
+    // Applying options with dontTransform() is expected to clear our transformations.
+    if (!isTransformationAllowed) {
+      transformations.clear();
+      fields &= ~TRANSFORMATION;
+      isTransformationRequired = false;
+      fields &= ~TRANSFORMATION_REQUIRED;
+      isScaleOnlyOrNoTransform = true;
+    }
+
+    fields |= other.fields;
+    options.putAll(other.options);
+
+    return selfOrThrowIfLocked();
+  }
+
+
+  @Override
+  public boolean equals(Object o) {
+    if (o instanceof BaseRequestOptions<?>) {
+      BaseRequestOptions<?> other = (BaseRequestOptions<?>) o;
+      return Float.compare(other.sizeMultiplier, sizeMultiplier) == 0
+          && errorId == other.errorId
+          && Util.bothNullOrEqual(errorPlaceholder, other.errorPlaceholder)
+          && placeholderId == other.placeholderId
+          && Util.bothNullOrEqual(placeholderDrawable, other.placeholderDrawable)
+          && fallbackId == other.fallbackId
+          && Util.bothNullOrEqual(fallbackDrawable, other.fallbackDrawable)
+          && isCacheable == other.isCacheable
+          && overrideHeight == other.overrideHeight
+          && overrideWidth == other.overrideWidth
+          && isTransformationRequired == other.isTransformationRequired
+          && isTransformationAllowed == other.isTransformationAllowed
+          && useUnlimitedSourceGeneratorsPool == other.useUnlimitedSourceGeneratorsPool
+          && onlyRetrieveFromCache == other.onlyRetrieveFromCache
+          && diskCacheStrategy.equals(other.diskCacheStrategy)
+          && priority == other.priority
+          && options.equals(other.options)
+          && transformations.equals(other.transformations)
+          && resourceClass.equals(other.resourceClass)
+          && Util.bothNullOrEqual(signature, other.signature)
+          && Util.bothNullOrEqual(theme, other.theme);
+    }
+    return false;
+  }
+
+  @Override
+  public int hashCode() {
+    int hashCode = Util.hashCode(sizeMultiplier);
+    hashCode = Util.hashCode(errorId, hashCode);
+    hashCode = Util.hashCode(errorPlaceholder, hashCode);
+    hashCode = Util.hashCode(placeholderId, hashCode);
+    hashCode = Util.hashCode(placeholderDrawable, hashCode);
+    hashCode = Util.hashCode(fallbackId, hashCode);
+    hashCode = Util.hashCode(fallbackDrawable, hashCode);
+    hashCode = Util.hashCode(isCacheable, hashCode);
+    hashCode = Util.hashCode(overrideHeight, hashCode);
+    hashCode = Util.hashCode(overrideWidth, hashCode);
+    hashCode = Util.hashCode(isTransformationRequired, hashCode);
+    hashCode = Util.hashCode(isTransformationAllowed, hashCode);
+    hashCode = Util.hashCode(useUnlimitedSourceGeneratorsPool, hashCode);
+    hashCode = Util.hashCode(onlyRetrieveFromCache, hashCode);
+    hashCode = Util.hashCode(diskCacheStrategy, hashCode);
+    hashCode = Util.hashCode(priority, hashCode);
+    hashCode = Util.hashCode(options, hashCode);
+    hashCode = Util.hashCode(transformations, hashCode);
+    hashCode = Util.hashCode(resourceClass, hashCode);
+    hashCode = Util.hashCode(signature, hashCode);
+    hashCode = Util.hashCode(theme, hashCode);
+    return hashCode;
+  }
+
+  /**
+   * Throws if any further mutations are attempted.
+   *
+   * <p> Once locked, the only way to unlock is to use {@link #clone()} </p>
+   */
+  @NonNull
+  @SuppressWarnings("unchecked")
+  public T lock() {
+    isLocked = true;
+    // This is the only place we should not check locked.
+    return self();
+  }
+
+  /**
+   * Similar to {@link #lock()} except that mutations cause a {@link #clone()} operation to happen
+   * before the mutation resulting in all methods returning a new Object and leaving the original
+   * locked object unmodified.
+   *
+   * <p>Auto clone is not retained by cloned objects returned from mutations. The cloned objects
+   * are mutable and are not locked.
+   */
+  @NonNull
+  public T autoClone() {
+    if (isLocked && !isAutoCloneEnabled) {
+      throw new IllegalStateException("You cannot auto lock an already locked options object"
+          + ", try clone() first");
+    }
+    isAutoCloneEnabled = true;
+    return lock();
+  }
+
+  @NonNull
+  @SuppressWarnings("unchecked")
+  private T selfOrThrowIfLocked() {
+    if (isLocked) {
+      throw new IllegalStateException("You cannot modify locked T, consider clone()");
+    }
+    return self();
+  }
+
+  protected boolean isAutoCloneEnabled() {
+    return isAutoCloneEnabled;
+  }
+
+  public final boolean isDiskCacheStrategySet() {
+    return isSet(DISK_CACHE_STRATEGY);
+  }
+
+  public final boolean isSkipMemoryCacheSet() {
+    return isSet(IS_CACHEABLE);
+  }
+
+  @NonNull
+  public final Map<Class<?>, Transformation<?>> getTransformations() {
+    return transformations;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  public final boolean isTransformationRequired() {
+    return isTransformationRequired;
+  }
+
+  @NonNull
+  public final Options getOptions() {
+    return options;
+  }
+
+  @NonNull
+  public final Class<?> getResourceClass() {
+    return resourceClass;
+  }
+
+  @NonNull
+  public final DiskCacheStrategy getDiskCacheStrategy() {
+    return diskCacheStrategy;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Nullable
+  public final Drawable getErrorPlaceholder() {
+    return errorPlaceholder;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  public final int getErrorId() {
+    return errorId;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  public final int getPlaceholderId() {
+    return placeholderId;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Nullable
+  public final Drawable getPlaceholderDrawable() {
+    return placeholderDrawable;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  public final int getFallbackId() {
+    return fallbackId;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Nullable
+  public final Drawable getFallbackDrawable() {
+    return fallbackDrawable;
+  }
+
+  @Nullable
+  public final Resources.Theme getTheme() {
+    return theme;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  public final boolean isMemoryCacheable() {
+    return isCacheable;
+  }
+
+  @NonNull
+  public final Key getSignature() {
+    return signature;
+  }
+
+  public final boolean isPrioritySet() {
+    return isSet(PRIORITY);
+  }
+
+  @NonNull
+  public final Priority getPriority() {
+    return priority;
+  }
+
+  public final int getOverrideWidth() {
+    return overrideWidth;
+  }
+
+  public final boolean isValidOverride() {
+    return Util.isValidDimensions(overrideWidth, overrideHeight);
+  }
+
+  public final int getOverrideHeight() {
+    return overrideHeight;
+  }
+
+  public final float getSizeMultiplier() {
+    return sizeMultiplier;
+  }
+
+  boolean isScaleOnlyOrNoTransform() {
+    return isScaleOnlyOrNoTransform;
+  }
+
+  private boolean isSet(int flag) {
+    return isSet(fields, flag);
+  }
+
+  // get is just as clear.
+  @SuppressWarnings("PMD.BooleanGetMethodName")
+  public final boolean getUseUnlimitedSourceGeneratorsPool() {
+    return useUnlimitedSourceGeneratorsPool;
+  }
+
+  // get is just as clear.
+  @SuppressWarnings("PMD.BooleanGetMethodName")
+  public final boolean getUseAnimationPool() {
+    return useAnimationPool;
+  }
+
+  // get is just as clear.
+  @SuppressWarnings("PMD.BooleanGetMethodName")
+  public final boolean getOnlyRetrieveFromCache() {
+    return onlyRetrieveFromCache;
+  }
+
+  @SuppressWarnings("unchecked")
+  private T self() {
+    return (T) this;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java b/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java
new file mode 100644
index 000000000..93b662d8f
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java
@@ -0,0 +1,143 @@
+package com.bumptech.glide.request;
+
+import android.support.annotation.Nullable;
+
+/**
+ * Runs a single primary {@link Request} until it completes and then a fallback error request only
+ * if the single primary request fails.
+ */
+public final class ErrorRequestCoordinator implements RequestCoordinator,
+    Request {
+
+  @Nullable
+  private final RequestCoordinator parent;
+  private Request primary;
+  private Request error;
+
+  public ErrorRequestCoordinator(@Nullable RequestCoordinator parent) {
+    this.parent = parent;
+  }
+
+  public void setRequests(Request primary, Request error) {
+    this.primary = primary;
+    this.error = error;
+  }
+
+  @Override
+  public void begin() {
+    if (!primary.isRunning()) {
+      primary.begin();
+    }
+  }
+
+  @Override
+  public void clear() {
+    primary.clear();
+    // Don't check primary.isFailed() here because it will have been reset by the clear call
+    // immediately before this.
+    if (error.isRunning()) {
+      error.clear();
+    }
+  }
+
+  @Override
+  public boolean isRunning() {
+    return primary.isFailed() ? error.isRunning() : primary.isRunning();
+  }
+
+  @Override
+  public boolean isComplete() {
+    return primary.isFailed() ? error.isComplete() : primary.isComplete();
+  }
+
+  @Override
+  public boolean isResourceSet() {
+    return primary.isFailed() ? error.isResourceSet() : primary.isResourceSet();
+  }
+
+  @Override
+  public boolean isCleared() {
+    return primary.isFailed() ? error.isCleared() : primary.isCleared();
+  }
+
+  @Override
+  public boolean isFailed() {
+    return primary.isFailed() && error.isFailed();
+  }
+
+  @Override
+  public void recycle() {
+    primary.recycle();
+    error.recycle();
+  }
+
+  @Override
+  public boolean isEquivalentTo(Request o) {
+    if (o instanceof ErrorRequestCoordinator) {
+      ErrorRequestCoordinator other = (ErrorRequestCoordinator) o;
+      return primary.isEquivalentTo(other.primary) && error.isEquivalentTo(other.error);
+    }
+    return false;
+  }
+
+  @Override
+  public boolean canSetImage(Request request) {
+    return parentCanSetImage() && isValidRequest(request);
+  }
+
+  private boolean parentCanSetImage() {
+    return parent == null || parent.canSetImage(this);
+  }
+
+  @Override
+  public boolean canNotifyStatusChanged(Request request) {
+    return parentCanNotifyStatusChanged() && isValidRequest(request);
+  }
+
+  @Override
+  public boolean canNotifyCleared(Request request) {
+    return parentCanNotifyCleared() && isValidRequest(request);
+  }
+
+  private boolean parentCanNotifyCleared() {
+    return parent == null || parent.canNotifyCleared(this);
+  }
+
+  private boolean parentCanNotifyStatusChanged() {
+    return parent == null || parent.canNotifyStatusChanged(this);
+  }
+
+  private boolean isValidRequest(Request request) {
+    return request.equals(primary) || (primary.isFailed() && request.equals(error));
+  }
+
+  @Override
+  public boolean isAnyResourceSet() {
+    return parentIsAnyResourceSet() || isResourceSet();
+  }
+
+  private boolean parentIsAnyResourceSet() {
+    return parent != null && parent.isAnyResourceSet();
+  }
+
+  @Override
+  public void onRequestSuccess(Request request) {
+    if (parent != null) {
+      parent.onRequestSuccess(this);
+    }
+  }
+
+  @Override
+  public void onRequestFailed(Request request) {
+    if (!request.equals(error)) {
+      if (!error.isRunning()) {
+        error.begin();
+      }
+      return;
+    }
+
+    if (parent != null) {
+      parent.onRequestFailed(this);
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/Request.java b/library/src/main/java/com/bumptech/glide/request/Request.java
index 7427ca434..f60198184 100644
--- a/library/src/main/java/com/bumptech/glide/request/Request.java
+++ b/library/src/main/java/com/bumptech/glide/request/Request.java
@@ -10,11 +10,6 @@
    */
   void begin();
 
-  /**
-   * Identical to {@link #clear()} except that the request may later be restarted.
-   */
-  void pause();
-
   /**
    * Prevents any bitmaps being loaded from previous requests, releases any resources held by this
    * request, displays the current placeholder if one was provided, and marks the request as having
@@ -22,11 +17,6 @@
    */
   void clear();
 
-  /**
-   * Returns true if this request is paused and may be restarted.
-   */
-  boolean isPaused();
-
   /**
    * Returns true if this request is running and has not completed or failed.
    */
@@ -44,9 +34,9 @@
   boolean isResourceSet();
 
   /**
-   * Returns true if the request has been cancelled.
+   * Returns true if the request has been cleared.
    */
-  boolean isCancelled();
+  boolean isCleared();
 
   /**
    * Returns true if the request has failed.
@@ -62,10 +52,10 @@
    * Returns {@code true} if this {@link Request} is equivalent to the given {@link Request} (has
    * all of the same options and sizes).
    *
-   * <p>This method is identical to {@link #equals(Object)} except that it's specific to
-   * {@link Request} subclasses. We do not use {@link #equals(Object)} directly because we track
-   * {@link Request}s in collections like {@link java.util.Set} and it's perfectly legitimate to
-   * have two different {@link Request} objects for two different
+   * <p>This method is identical to {@link Object#equals(Object)} except that it's specific to
+   * {@link Request} subclasses. We do not use {@link Object#equals(Object)} directly because we
+   * track {@link Request}s in collections like {@link java.util.Set} and it's perfectly legitimate
+   * to have two different {@link Request} objects for two different
    * {@link com.bumptech.glide.request.target.Target}s (for example). Using a similar but different
    * method let's us selectively compare {@link Request} objects to each other when it's useful in
    * specific scenarios.
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestCoordinator.java b/library/src/main/java/com/bumptech/glide/request/RequestCoordinator.java
index 2143366eb..4aa69b394 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestCoordinator.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestCoordinator.java
@@ -20,6 +20,12 @@
    */
   boolean canNotifyStatusChanged(Request request);
 
+  /**
+   * Returns {@code true} if the {@link Request} can clear the
+   * {@link com.bumptech.glide.request.target.Target}.
+   */
+  boolean canNotifyCleared(Request request);
+
   /**
    * Returns true if any coordinated {@link Request} has successfully completed.
    *
@@ -28,7 +34,10 @@
   boolean isAnyResourceSet();
 
   /**
-   * Must be called when a request coordinated by this object completes successfully.
+   * Must be called when a {@link Request} coordinated by this object completes successfully.
    */
   void onRequestSuccess(Request request);
+
+  /** Must be called when a {@link Request} coordinated by this object fails. */
+  void onRequestFailed(Request request);
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java b/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
index 4ba29827f..77dad3e09 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
@@ -2,8 +2,13 @@
 
 import android.graphics.drawable.Drawable;
 import android.os.Handler;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.GlideException;
 import com.bumptech.glide.request.target.SizeReadyCallback;
+import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.util.Util;
 import java.util.concurrent.CancellationException;
@@ -47,6 +52,7 @@
  * @param <R> The type of the resource that will be loaded.
  */
 public class RequestFutureTarget<R> implements FutureTarget<R>,
+    RequestListener<R>,
     Runnable {
   private static final Waiter DEFAULT_WAITER = new Waiter();
 
@@ -62,6 +68,7 @@
   private boolean isCancelled;
   private boolean resultReceived;
   private boolean loadFailed;
+  @Nullable private GlideException exception;
 
   /**
    * Constructor for a RequestFutureTarget. Should not be used directly.
@@ -99,7 +106,7 @@ public synchronized boolean isCancelled() {
 
   @Override
   public synchronized boolean isDone() {
-    return isCancelled || resultReceived;
+    return isCancelled || resultReceived || loadFailed;
   }
 
   @Override
@@ -112,7 +119,7 @@ public R get() throws InterruptedException, ExecutionException {
   }
 
   @Override
-  public R get(long time, TimeUnit timeUnit)
+  public R get(long time, @NonNull TimeUnit timeUnit)
       throws InterruptedException, ExecutionException, TimeoutException {
     return doGet(timeUnit.toMillis(time));
   }
@@ -121,18 +128,15 @@ public R get(long time, TimeUnit timeUnit)
    * A callback that should never be invoked directly.
    */
   @Override
-  public void getSize(SizeReadyCallback cb) {
+  public void getSize(@NonNull SizeReadyCallback cb) {
     cb.onSizeReady(width, height);
   }
 
   @Override
-  public void removeCallback(SizeReadyCallback cb) {
+  public void removeCallback(@NonNull SizeReadyCallback cb) {
     // Do nothing because we do not retain references to SizeReadyCallbacks.
   }
 
-  /**
-   * {@inheritDoc}
-   */
   @Override
   public void setRequest(@Nullable Request request) {
     this.request = request;
@@ -148,7 +152,7 @@ public Request getRequest() {
    * A callback that should never be invoked directly.
    */
   @Override
-  public void onLoadCleared(Drawable placeholder) {
+  public void onLoadCleared(@Nullable Drawable placeholder) {
     // Do nothing.
   }
 
@@ -156,7 +160,7 @@ public void onLoadCleared(Drawable placeholder) {
    * A callback that should never be invoked directly.
    */
   @Override
-  public void onLoadStarted(Drawable placeholder) {
+  public void onLoadStarted(@Nullable Drawable placeholder) {
     // Do nothing.
   }
 
@@ -164,20 +168,17 @@ public void onLoadStarted(Drawable placeholder) {
    * A callback that should never be invoked directly.
    */
   @Override
-  public synchronized void onLoadFailed(Drawable errorDrawable) {
-    loadFailed = true;
-    waiter.notifyAll(this);
+  public synchronized void onLoadFailed(@Nullable Drawable errorDrawable) {
+    // Ignored, synchronized for backwards compatibility.
   }
 
   /**
    * A callback that should never be invoked directly.
    */
   @Override
-  public synchronized void onResourceReady(R resource, Transition<? super R> transition) {
-    // We might get a null result.
-    resultReceived = true;
-    this.resource = resource;
-    waiter.notifyAll(this);
+  public synchronized void onResourceReady(@NonNull R resource,
+      @Nullable Transition<? super R> transition) {
+    // Ignored, synchronized for backwards compatibility.
   }
 
   private synchronized R doGet(Long timeoutMillis)
@@ -189,7 +190,7 @@ private synchronized R doGet(Long timeoutMillis)
     if (isCancelled) {
       throw new CancellationException();
     } else if (loadFailed) {
-      throw new ExecutionException(new IllegalStateException("Load failed"));
+      throw new ExecutionException(exception);
     } else if (resultReceived) {
       return resource;
     }
@@ -197,13 +198,18 @@ private synchronized R doGet(Long timeoutMillis)
     if (timeoutMillis == null) {
       waiter.waitForTimeout(this, 0);
     } else if (timeoutMillis > 0) {
-      waiter.waitForTimeout(this, timeoutMillis);
+      long now = System.currentTimeMillis();
+      long deadline = now + timeoutMillis;
+      while (!isDone() && now < deadline) {
+        waiter.waitForTimeout(this, deadline - now);
+        now = System.currentTimeMillis();
+      }
     }
 
     if (Thread.interrupted()) {
       throw new InterruptedException();
     } else if (loadFailed) {
-      throw new ExecutionException(new IllegalStateException("Load failed"));
+      throw new ExecutionException(exception);
     } else if (isCancelled) {
       throw new CancellationException();
     } else if (!resultReceived) {
@@ -243,14 +249,35 @@ public void onDestroy() {
     // Do nothing.
   }
 
-  // Visible for testing.
-  static class Waiter {
+  @Override
+  public synchronized boolean onLoadFailed(
+      @Nullable GlideException e, Object model, Target<R> target, boolean isFirstResource) {
+    loadFailed = true;
+    exception = e;
+    waiter.notifyAll(this);
+    return false;
+  }
+
+  @Override
+  public synchronized boolean onResourceReady(
+      R resource, Object model, Target<R> target, DataSource dataSource, boolean isFirstResource) {
+    // We might get a null result.
+    resultReceived = true;
+    this.resource = resource;
+    waiter.notifyAll(this);
+    return false;
+  }
 
-    public void waitForTimeout(Object toWaitOn, long timeoutMillis) throws InterruptedException {
+  @VisibleForTesting
+  static class Waiter {
+    // This is a simple wrapper class that is used to enable testing. The call to the wrapping class
+    // is waited on appropriately.
+    @SuppressWarnings("WaitNotInLoop")
+    void waitForTimeout(Object toWaitOn, long timeoutMillis) throws InterruptedException {
       toWaitOn.wait(timeoutMillis);
     }
 
-    public void notifyAll(Object toNotify) {
+    void notifyAll(Object toNotify) {
       toNotify.notifyAll();
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestListener.java b/library/src/main/java/com/bumptech/glide/request/RequestListener.java
index a6156b495..74b33246c 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestListener.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestListener.java
@@ -2,6 +2,7 @@
 
 import android.graphics.drawable.Drawable;
 import android.support.annotation.Nullable;
+import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.engine.GlideException;
 import com.bumptech.glide.request.target.Target;
@@ -18,33 +19,38 @@
    * {@link Target#onLoadFailed(Drawable)}. Will only be called if we currently want to display an
    * image for the given model in the given target. It is recommended to create a single instance
    * per activity/fragment rather than instantiate a new object for each call to {@code
-   * Glide.load()} to avoid object churn.
+   * Glide.with(fragment/activity).load()} to avoid object churn.
    *
-   * <p> It is safe to reload this or a different model or change what is displayed in the target at
-   * this point. For example:
+   * <p>It is not safe to reload this or a different model in this callback. If you need to do so
+   * use {@link com.bumptech.glide.RequestBuilder#error(RequestBuilder)} instead.
+   *
+   * <p>Although you can't start an entirely new load, it is safe to change what is displayed in the
+   * {@link Target} at this point, as long as you return {@code true} from the method to prevent
+   * {@link Target#onLoadFailed(Drawable)} from being called.
+   *
+   * For example:
    * <pre>
    * {@code
-   * public void onLoadFailed(Exception e, T model, Target target, boolean isFirstResource) {
+   * public boolean onLoadFailed(Exception e, T model, Target target, boolean isFirstResource) {
    *     target.setPlaceholder(R.drawable.a_specific_error_for_my_exception);
-   *     Glide.load(model).into(target);
+   *     return true; // Prevent onLoadFailed from being called on the Target.
    * }
    * }
    * </pre>
    * </p>
    *
-   * <p> Note - if you want to reload this or any other model after an exception, you will need to
-   * include all relevant builder calls (like centerCrop, placeholder etc).
-   *
    * @param e               The maybe {@code null} exception containing information about why the
    *                        request failed.
    * @param model           The model we were trying to load when the exception occurred.
    * @param target          The {@link Target} we were trying to load the image into.
    * @param isFirstResource {@code true} if this exception is for the first resource to load.
-   * @return {@code true} if the listener has handled updating the target for the given exception,
-   *         {@code false} to allow Glide's request to update the target.
+   * @return {@code true} to prevent {@link Target#onLoadFailed(Drawable)} from being called on
+   * {@code target}, typically because the listener wants to update the {@code target} or the object
+   * the {@code target} wraps itself or {@code false} to allow {@link Target#onLoadFailed(Drawable)}
+   * to be called on {@code target}.
    */
-  boolean onLoadFailed(@Nullable GlideException e, Object model, Target<R> target,
-      boolean isFirstResource);
+  boolean onLoadFailed(
+      @Nullable GlideException e, Object model, Target<R> target, boolean isFirstResource);
 
   /**
    * Called when a load completes successfully, immediately before {@link
@@ -58,10 +64,12 @@ boolean onLoadFailed(@Nullable GlideException e, Object model, Target<R> target,
    *                          loaded into the target. For example when loading a thumbnail and a
    *                          full-sized image, this will be {@code true} for the first image to
    *                          load and {@code false} for the second.
-   * @return {@code true} if the listener has handled setting the resource on the target,
-   *         {@code false} to allow Glide's request to update the target.
-   *         Setting the resource includes handling animations, be sure to take that into account.
+   *
+   * @return {@code true} to prevent {@link Target#onLoadFailed(Drawable)} from being called on
+   * {@code target}, typically because the listener wants to update the {@code target} or the object
+   * the {@code target} wraps itself or {@code false} to allow {@link Target#onLoadFailed(Drawable)}
+   * to be called on {@code target}.
    */
-  boolean onResourceReady(R resource, Object model, Target<R> target, DataSource dataSource,
-      boolean isFirstResource);
+  boolean onResourceReady(
+      R resource, Object model, Target<R> target, DataSource dataSource, boolean isFirstResource);
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
index c1d14beb5..f712ce726 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
@@ -1,64 +1,29 @@
 package com.bumptech.glide.request;
 
-import android.content.res.Resources;
 import android.graphics.Bitmap;
-import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.MultiTransformation;
 import com.bumptech.glide.load.Option;
-import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
-import com.bumptech.glide.load.model.stream.HttpGlideUrlLoader;
-import com.bumptech.glide.load.resource.bitmap.BitmapDrawableTransformation;
-import com.bumptech.glide.load.resource.bitmap.BitmapEncoder;
-import com.bumptech.glide.load.resource.bitmap.CenterCrop;
-import com.bumptech.glide.load.resource.bitmap.CenterInside;
-import com.bumptech.glide.load.resource.bitmap.CircleCrop;
 import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
-import com.bumptech.glide.load.resource.bitmap.Downsampler;
-import com.bumptech.glide.load.resource.bitmap.FitCenter;
-import com.bumptech.glide.load.resource.bitmap.VideoBitmapDecoder;
-import com.bumptech.glide.load.resource.gif.ByteBufferGifDecoder;
-import com.bumptech.glide.load.resource.gif.GifDrawable;
-import com.bumptech.glide.load.resource.gif.GifDrawableTransformation;
-import com.bumptech.glide.load.resource.gif.StreamGifDecoder;
-import com.bumptech.glide.signature.EmptySignature;
-import com.bumptech.glide.util.Preconditions;
-import com.bumptech.glide.util.Util;
-import java.util.HashMap;
-import java.util.Map;
 
 /**
  * Provides type independent options to customize loads with Glide.
+ *
+ * <p>Non-final to allow Glide's generated classes to be assignable to their non-generated
+ * equivalents.
  */
-@SuppressWarnings({"PMD.UseUtilityClass", "unused"})
-public class RequestOptions implements Cloneable {
-  private static final int UNSET = -1;
-  private static final int SIZE_MULTIPLIER = 1 << 1;
-  private static final int DISK_CACHE_STRATEGY = 1 << 2;
-  private static final int PRIORITY = 1 << 3;
-  private static final int ERROR_PLACEHOLDER = 1 << 4;
-  private static final int ERROR_ID = 1 << 5;
-  private static final int PLACEHOLDER = 1 << 6;
-  private static final int PLACEHOLDER_ID = 1 << 7;
-  private static final int IS_CACHEABLE = 1 << 8;
-  private static final int OVERRIDE = 1 << 9;
-  private static final int SIGNATURE = 1 << 10;
-  private static final int TRANSFORMATION = 1 << 11;
-  private static final int RESOURCE_CLASS = 1 << 12;
-  private static final int FALLBACK = 1 << 13;
-  private static final int FALLBACK_ID = 1 << 14;
-  private static final int THEME = 1 << 15;
-  private static final int TRANSFORMATION_ALLOWED = 1 << 16;
-  private static final int TRANSFORMATION_REQUIRED = 1 << 17;
-  private static final int USE_UNLIMITED_SOURCE_GENERATORS_POOL = 1 << 18;
-  private static final int ONLY_RETRIEVE_FROM_CACHE = 1 << 19;
+@SuppressWarnings("PMD.UseUtilityClass")
+public class RequestOptions extends BaseRequestOptions<RequestOptions> {
 
   @Nullable
   private static RequestOptions skipMemoryCacheTrueOptions;
@@ -77,60 +42,34 @@
   @Nullable
   private static RequestOptions noAnimationOptions;
 
-  private int fields;
-  private float sizeMultiplier = 1f;
-  @NonNull
-  private DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.AUTOMATIC;
-  @NonNull
-  private Priority priority = Priority.NORMAL;
-  @Nullable
-  private Drawable errorPlaceholder;
-  private int errorId;
-  @Nullable
-  private Drawable placeholderDrawable;
-  private int placeholderId;
-  private boolean isCacheable = true;
-  private int overrideHeight = RequestOptions.UNSET;
-  private int overrideWidth = RequestOptions.UNSET;
-  @NonNull
-  private Key signature = EmptySignature.obtain();
-  private boolean isTransformationRequired;
-  private boolean isTransformationAllowed = true;
-  @Nullable
-  private Drawable fallbackDrawable;
-  private int fallbackId;
-  @NonNull
-  private Options options = new Options();
-  @NonNull
-  private Map<Class<?>, Transformation<?>> transformations = new HashMap<>();
-  @NonNull
-  private Class<?> resourceClass = Object.class;
-  private boolean isLocked;
-  @Nullable
-  private Resources.Theme theme;
-  private boolean isAutoCloneEnabled;
-  private boolean useUnlimitedSourceGeneratorsPool;
-  private boolean onlyRetrieveFromCache;
 
   /**
    * Returns a {@link RequestOptions} object with {@link #sizeMultiplier(float)} set.
    */
   @SuppressWarnings("WeakerAccess") // Public API
-  public static RequestOptions sizeMultiplierOf(float sizeMultiplier) {
+  @NonNull
+  @CheckResult
+  public static RequestOptions sizeMultiplierOf(
+      @FloatRange(from = 0, to = 1) float sizeMultiplier) {
     return new RequestOptions().sizeMultiplier(sizeMultiplier);
   }
 
   /**
-   * Returns a {@link RequestOptions} object with {@link #sizeMultiplier(float)} set.
+   * Returns a {@link RequestOptions} object with {@link #diskCacheStrategy(DiskCacheStrategy)} set.
    */
+  @NonNull
+  @CheckResult
   public static RequestOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy diskCacheStrategy) {
     return new RequestOptions().diskCacheStrategy(diskCacheStrategy);
   }
 
   /**
-   * Returns a {@link RequestOptions} object with {@link #priority(Priority)}} set.
+   * Returns a {@link RequestOptions} object with {@link BaseRequestOptions#priority(Priority)}}
+   * set.
    */
   @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
+  @CheckResult
   public static RequestOptions priorityOf(@NonNull Priority priority) {
     return new RequestOptions().priority(priority);
   }
@@ -138,6 +77,8 @@ public static RequestOptions priorityOf(@NonNull Priority priority) {
   /**
    * Returns a {@link RequestOptions} object with {@link #placeholder(Drawable)} set.
    */
+  @NonNull
+  @CheckResult
   public static RequestOptions placeholderOf(@Nullable Drawable placeholder) {
     return new RequestOptions().placeholder(placeholder);
   }
@@ -145,13 +86,17 @@ public static RequestOptions placeholderOf(@Nullable Drawable placeholder) {
   /**
    * Returns a {@link RequestOptions} object with {@link #placeholder(int)} set.
    */
-  public static RequestOptions placeholderOf(int placeholderId) {
+  @NonNull
+  @CheckResult
+  public static RequestOptions placeholderOf(@DrawableRes int placeholderId) {
     return new RequestOptions().placeholder(placeholderId);
   }
 
   /**
    * Returns a {@link RequestOptions} object with {@link #error(Drawable)} set.
    */
+  @NonNull
+  @CheckResult
   public static RequestOptions errorOf(@Nullable Drawable errorDrawable) {
     return new RequestOptions().error(errorDrawable);
   }
@@ -159,13 +104,17 @@ public static RequestOptions errorOf(@Nullable Drawable errorDrawable) {
   /**
    * Returns a {@link RequestOptions} object with {@link #error(int)}} set.
    */
-  public static RequestOptions errorOf(int errorId) {
+  @NonNull
+  @CheckResult
+  public static RequestOptions errorOf(@DrawableRes int errorId) {
     return new RequestOptions().error(errorId);
   }
 
   /**
    * Returns a {@link RequestOptions} object with {@link #skipMemoryCache(boolean)} set.
    */
+  @NonNull
+  @CheckResult
   public static RequestOptions skipMemoryCacheOf(boolean skipMemoryCache) {
     if (skipMemoryCache) {
       if (skipMemoryCacheTrueOptions == null) {
@@ -184,7 +133,11 @@ public static RequestOptions skipMemoryCacheOf(boolean skipMemoryCache) {
    * Returns a {@link RequestOptions} object with {@link #override(int, int)}} set.
    */
   @SuppressWarnings("WeakerAccess") // Public API
-  public static RequestOptions overrideOf(int width, int height) {
+  @NonNull
+  @CheckResult
+  public static RequestOptions overrideOf(
+      @IntRange(from = 0) int width,
+      @IntRange(from = 0) int height) {
     return new RequestOptions().override(width, height);
   }
 
@@ -193,13 +146,17 @@ public static RequestOptions overrideOf(int width, int height) {
    * height are the given size.
    */
   @SuppressWarnings("WeakerAccess") // Public API
-  public static RequestOptions overrideOf(int size) {
+  @NonNull
+  @CheckResult
+  public static RequestOptions overrideOf(@IntRange(from = 0) int size) {
     return overrideOf(size, size);
   }
 
   /**
    * Returns a {@link RequestOptions} object with {@link #signature} set.
    */
+  @NonNull
+  @CheckResult
   public static RequestOptions signatureOf(@NonNull Key signature) {
     return new RequestOptions().signature(signature);
   }
@@ -207,6 +164,8 @@ public static RequestOptions signatureOf(@NonNull Key signature) {
   /**
    * Returns a {@link RequestOptions} object with {@link #fitCenter()} set.
    */
+  @NonNull
+  @CheckResult
   public static RequestOptions fitCenterTransform() {
     if (fitCenterOptions == null) {
       fitCenterOptions = new RequestOptions()
@@ -220,6 +179,8 @@ public static RequestOptions fitCenterTransform() {
    * Returns a {@link RequestOptions} object with {@link #centerInside()} set.
    */
   @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
+  @CheckResult
   public static RequestOptions centerInsideTransform() {
     if (centerInsideOptions == null) {
       centerInsideOptions = new RequestOptions()
@@ -233,6 +194,8 @@ public static RequestOptions centerInsideTransform() {
    * Returns a {@link RequestOptions} object with {@link #centerCrop()} set.
    */
   @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
+  @CheckResult
   public static RequestOptions centerCropTransform() {
     if (centerCropOptions == null) {
       centerCropOptions = new RequestOptions()
@@ -246,6 +209,8 @@ public static RequestOptions centerCropTransform() {
    * Returns a {@link RequestOptions} object with {@link RequestOptions#circleCrop()} set.
    */
   @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
+  @CheckResult
   public static RequestOptions circleCropTransform() {
     if (circleCropOptions == null) {
       circleCropOptions = new RequestOptions()
@@ -259,6 +224,8 @@ public static RequestOptions circleCropTransform() {
    * Returns a {@link RequestOptions} object with {@link #transform(Transformation)} set.
    */
   @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
+  @CheckResult
   public static RequestOptions bitmapTransform(@NonNull Transformation<Bitmap> transformation) {
     return new RequestOptions().transform(transformation);
   }
@@ -267,6 +234,8 @@ public static RequestOptions bitmapTransform(@NonNull Transformation<Bitmap> tra
    * Returns a {@link RequestOptions} object with {@link #dontTransform()} set.
    */
   @SuppressWarnings("WeakerAccess")
+  @NonNull
+  @CheckResult
   public static RequestOptions noTransformation() {
     if (noTransformOptions == null) {
       noTransformOptions = new RequestOptions()
@@ -280,6 +249,8 @@ public static RequestOptions noTransformation() {
    * Returns a {@link RequestOptions} object with the given {@link Option} set via
    * {@link #set(Option, Object)}.
    */
+  @NonNull
+  @CheckResult
   public static <T> RequestOptions option(@NonNull Option<T> option, @NonNull T value) {
     return new RequestOptions().set(option, value);
   }
@@ -287,6 +258,8 @@ public static RequestOptions noTransformation() {
   /**
    * Returns a {@link RequestOptions} object with {@link #decode(Class)} set.
    */
+  @NonNull
+  @CheckResult
   public static RequestOptions decodeTypeOf(@NonNull Class<?> resourceClass) {
     return new RequestOptions().decode(resourceClass);
   }
@@ -295,6 +268,8 @@ public static RequestOptions decodeTypeOf(@NonNull Class<?> resourceClass) {
    * Returns a {@link RequestOptions} object with {@link #format(DecodeFormat)} set.
    */
   @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
+  @CheckResult
   public static RequestOptions formatOf(@NonNull DecodeFormat format) {
     return new RequestOptions().format(format);
   }
@@ -303,7 +278,9 @@ public static RequestOptions formatOf(@NonNull DecodeFormat format) {
    * Returns a {@link RequestOptions} object with {@link #frame(long)} set.
    */
   @SuppressWarnings("WeakerAccess") // Public API
-  public static RequestOptions frameOf(long frameTimeMicros) {
+  @NonNull
+  @CheckResult
+  public static RequestOptions frameOf(@IntRange(from = 0) long frameTimeMicros) {
     return new RequestOptions().frame(frameTimeMicros);
   }
 
@@ -311,6 +288,8 @@ public static RequestOptions frameOf(long frameTimeMicros) {
    * Returns a {@link RequestOptions} object with {@link #downsample(DownsampleStrategy)} set.
    */
   @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
+  @CheckResult
   public static RequestOptions downsampleOf(@NonNull DownsampleStrategy strategy) {
     return new RequestOptions().downsample(strategy);
   }
@@ -318,7 +297,9 @@ public static RequestOptions downsampleOf(@NonNull DownsampleStrategy strategy)
   /**
    * Returns a {@link RequestOptions} object with {@link #timeout(int)} set.
    */
-  public static RequestOptions timeoutOf(int timeout) {
+  @NonNull
+  @CheckResult
+  public static RequestOptions timeoutOf(@IntRange(from = 0) int timeout) {
     return new RequestOptions().timeout(timeout);
   }
 
@@ -327,7 +308,9 @@ public static RequestOptions timeoutOf(int timeout) {
    * #encodeQuality(int)} called with the given quality.
    */
   @SuppressWarnings("WeakerAccess") // Public API
-  public static RequestOptions encodeQualityOf(int quality) {
+  @NonNull
+  @CheckResult
+  public static RequestOptions encodeQualityOf(@IntRange(from = 0, to = 100) int quality) {
     return new RequestOptions().encodeQuality(quality);
   }
 
@@ -336,6 +319,8 @@ public static RequestOptions encodeQualityOf(int quality) {
    * #encodeFormat(android.graphics.Bitmap.CompressFormat)} called with the given format.
    */
   @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
+  @CheckResult
   public static RequestOptions encodeFormatOf(@NonNull Bitmap.CompressFormat format) {
     return new RequestOptions().encodeFormat(format);
   }
@@ -345,6 +330,8 @@ public static RequestOptions encodeFormatOf(@NonNull Bitmap.CompressFormat forma
    * called.
    */
   @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
+  @CheckResult
   public static RequestOptions noAnimation() {
     if (noAnimationOptions == null) {
       noAnimationOptions = new RequestOptions()
@@ -354,1015 +341,4 @@ public static RequestOptions noAnimation() {
     return noAnimationOptions;
   }
 
-  private static boolean isSet(int fields, int flag) {
-    return (fields & flag) != 0;
-  }
-
-  /**
-   * Applies a multiplier to the {@link com.bumptech.glide.request.target.Target}'s size before
-   * loading the resource. Useful for loading thumbnails or trying to avoid loading huge resources
-   * (particularly {@link Bitmap}s on devices with overly dense screens.
-   *
-   * @param sizeMultiplier The multiplier to apply to the
-   *                       {@link com.bumptech.glide.request.target.Target}'s dimensions when
-   *                       loading the resource.
-   * @return This request builder.
-   */
-  public RequestOptions sizeMultiplier(float sizeMultiplier) {
-    if (isAutoCloneEnabled) {
-      return clone().sizeMultiplier(sizeMultiplier);
-    }
-
-    if (sizeMultiplier < 0f || sizeMultiplier > 1f) {
-      throw new IllegalArgumentException("sizeMultiplier must be between 0 and 1");
-    }
-    this.sizeMultiplier = sizeMultiplier;
-    fields |= SIZE_MULTIPLIER;
-
-    return selfOrThrowIfLocked();
-  }
-
-  public RequestOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
-    if (isAutoCloneEnabled) {
-      return clone().useUnlimitedSourceGeneratorsPool(flag);
-    }
-
-    this.useUnlimitedSourceGeneratorsPool = flag;
-    fields |= USE_UNLIMITED_SOURCE_GENERATORS_POOL;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * If set to true, will only load an item if found in the cache, and will not fetch from source.
-   */
-  public RequestOptions onlyRetrieveFromCache(boolean flag) {
-    if (isAutoCloneEnabled) {
-      return clone().onlyRetrieveFromCache(flag);
-    }
-
-    this.onlyRetrieveFromCache = flag;
-    fields |= ONLY_RETRIEVE_FROM_CACHE;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets the {@link DiskCacheStrategy} to use for this load.
-   *
-   * <p> Defaults to {@link DiskCacheStrategy#AUTOMATIC}. </p>
-   *
-   * <p> For most applications {@link DiskCacheStrategy#RESOURCE} is
-   * ideal. Applications that use the same resource multiple times in multiple sizes and are willing
-   * to trade off some speed and disk space in return for lower bandwidth usage may want to consider
-   * using {@link DiskCacheStrategy#DATA} or
-   * {@link DiskCacheStrategy#ALL}. </p>
-   *
-   * @param strategy The strategy to use.
-   * @return This request builder.
-   */
-  public RequestOptions diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
-    if (isAutoCloneEnabled) {
-      return clone().diskCacheStrategy(strategy);
-    }
-    this.diskCacheStrategy = Preconditions.checkNotNull(strategy);
-    fields |= DISK_CACHE_STRATEGY;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets the priority for this load.
-   *
-   * @param priority A priority.
-   * @return This request builder.
-   */
-  public RequestOptions priority(@NonNull Priority priority) {
-    if (isAutoCloneEnabled) {
-      return clone().priority(priority);
-    }
-
-    this.priority = Preconditions.checkNotNull(priority);
-    fields |= PRIORITY;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets an {@link Drawable} to display while a resource is loading.
-   *
-   * @param drawable The drawable to display as a placeholder.
-   * @return This request builder.
-   */
-  public RequestOptions placeholder(@Nullable Drawable drawable) {
-    if (isAutoCloneEnabled) {
-      return clone().placeholder(drawable);
-    }
-
-    this.placeholderDrawable = drawable;
-    fields |= PLACEHOLDER;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets an Android resource id for a {@link Drawable} resource to
-   * display while a resource is loading.
-   *
-   * @param resourceId The id of the resource to use as a placeholder
-   * @return This request builder.
-   */
-  public RequestOptions placeholder(int resourceId) {
-    if (isAutoCloneEnabled) {
-      return clone().placeholder(resourceId);
-    }
-
-    this.placeholderId = resourceId;
-    fields |= PLACEHOLDER_ID;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets an {@link Drawable} to display if the model provided to
-   * {@link com.bumptech.glide.RequestBuilder#load(Object)} is {@code null}.
-   *
-   * <p> If a fallback is not set, null models will cause the error drawable to be displayed. If the
-   * error drawable is not set, the placeholder will be displayed.
-   *
-   * @see #placeholder(Drawable)
-   * @see #placeholder(int)
-   *
-   * @param drawable The drawable to display as a placeholder.
-   * @return This request builder.
-   */
-  public RequestOptions fallback(Drawable drawable) {
-    if (isAutoCloneEnabled) {
-      return clone().fallback(drawable);
-    }
-
-    this.fallbackDrawable = drawable;
-    fields |= FALLBACK;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets a resource to display if the model provided to
-   * {@link com.bumptech.glide.RequestBuilder#load(Object)} is {@code null}.
-   *
-   * <p> If a fallback is not set, null models will cause the error drawable to be displayed. If
-   * the error drawable is not set, the placeholder will be displayed.
-   *
-   * @see #placeholder(Drawable)
-   * @see #placeholder(int)
-   *
-   * @param resourceId The id of the resource to use as a fallback.
-   * @return This request builder.
-   */
-  public RequestOptions fallback(int resourceId) {
-    if (isAutoCloneEnabled) {
-      return clone().fallback(resourceId);
-    }
-
-    this.fallbackId = resourceId;
-    fields |= FALLBACK_ID;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets a {@link Drawable} to display if a load fails.
-   *
-   * @param drawable The drawable to display.
-   * @return This request builder.
-   */
-  public RequestOptions error(@Nullable Drawable drawable) {
-    if (isAutoCloneEnabled) {
-      return clone().error(drawable);
-    }
-
-    this.errorPlaceholder = drawable;
-    fields |= ERROR_PLACEHOLDER;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets a resource to display if a load fails.
-   *
-   * @param resourceId The id of the resource to use as a placeholder.
-   * @return This request builder.
-   */
-  public RequestOptions error(int resourceId) {
-    if (isAutoCloneEnabled) {
-      return clone().error(resourceId);
-    }
-    this.errorId = resourceId;
-    fields |= ERROR_ID;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets the {@link android.content.res.Resources.Theme} to apply when loading {@link Drawable}s
-   * for resource ids provided via {@link #error(int)}, {@link #placeholder(int)}, and
-   * {@link #fallback(Drawable)}.
-   *
-   * @param theme The theme to use when loading Drawables.
-   * @return this request builder.
-   */
-  public RequestOptions theme(Resources.Theme theme) {
-    if (isAutoCloneEnabled) {
-      return clone().theme(theme);
-    }
-
-    this.theme = theme;
-    fields |= THEME;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Allows the loaded resource to skip the memory cache.
-   *
-   * <p> Note - this is not a guarantee. If a request is already pending for this resource and that
-   * request is not also skipping the memory cache, the resource will be cached in memory.</p>
-   *
-   * @param skip True to allow the resource to skip the memory cache.
-   * @return This request builder.
-   */
-  public RequestOptions skipMemoryCache(boolean skip) {
-    if (isAutoCloneEnabled) {
-      return clone().skipMemoryCache(true);
-    }
-
-    this.isCacheable = !skip;
-    fields |= IS_CACHEABLE;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Overrides the {@link com.bumptech.glide.request.target.Target}'s width and height with the
-   * given values. This is useful for thumbnails, and should only be used for other cases when you
-   * need a very specific image size.
-   *
-   * @param width  The width in pixels to use to load the resource.
-   * @param height The height in pixels to use to load the resource.
-   * @return This request builder.
-   */
-  public RequestOptions override(int width, int height) {
-    if (isAutoCloneEnabled) {
-      return clone().override(width, height);
-    }
-
-    this.overrideWidth = width;
-    this.overrideHeight = height;
-    fields |= OVERRIDE;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Overrides the {@link com.bumptech.glide.request.target.Target}'s width and height with the
-   * given size.
-   *
-   * @see #override(int, int)
-   * @param size The width and height to use.
-   * @return This request builder.
-   */
-  public RequestOptions override(int size) {
-    return override(size, size);
-  }
-
-  /**
-   * Sets some additional data to be mixed in to the memory and disk cache keys allowing the caller
-   * more control over when cached data is invalidated.
-   *
-   * <p> Note - The signature does not replace the cache key, it is purely additive. </p>
-   *
-   * @param signature A unique non-null {@link Key} representing the current
-   *                  state of the model that will be mixed in to the cache key.
-   * @return This request builder.
-   * @see com.bumptech.glide.signature.ObjectKey
-   */
-  public RequestOptions signature(@NonNull Key signature) {
-    if (isAutoCloneEnabled) {
-      return clone().signature(signature);
-    }
-
-    this.signature = Preconditions.checkNotNull(signature);
-    fields |= SIGNATURE;
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Returns a copy of this request builder with all of the options put so far on this builder.
-   *
-   * <p> This method returns a "deep" copy in that all non-immutable arguments are copied such that
-   * changes to one builder will not affect the other builder. However, in addition to immutable
-   * arguments, the current model is not copied copied so changes to the model will affect both
-   * builders. </p>
-   *
-   * <p> Even if this object was locked, the cloned object returned from this method will not be
-   * locked. </p>
-   */
-  @SuppressWarnings("unchecked")
-  @Override
-  public RequestOptions clone() {
-    try {
-      RequestOptions result = (RequestOptions) super.clone();
-      result.options = new Options();
-      result.options.putAll(options);
-      result.transformations = new HashMap<>();
-      result.transformations.putAll(transformations);
-      result.isLocked = false;
-      result.isAutoCloneEnabled = false;
-      return result;
-    } catch (CloneNotSupportedException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  public <T> RequestOptions set(@NonNull Option<T> option, @NonNull T value) {
-    if (isAutoCloneEnabled) {
-      return clone().set(option, value);
-    }
-
-    Preconditions.checkNotNull(option);
-    Preconditions.checkNotNull(value);
-    options.set(option, value);
-    return selfOrThrowIfLocked();
-  }
-
-  public RequestOptions decode(@NonNull Class<?> resourceClass) {
-    if (isAutoCloneEnabled) {
-      return clone().decode(resourceClass);
-    }
-
-    this.resourceClass = Preconditions.checkNotNull(resourceClass);
-    fields |= RESOURCE_CLASS;
-    return selfOrThrowIfLocked();
-  }
-
-  public final boolean isTransformationAllowed() {
-    return isTransformationAllowed;
-  }
-
-  public final boolean isTransformationSet() {
-    return isSet(TRANSFORMATION);
-  }
-
-  public final boolean isLocked() {
-    return isLocked;
-  }
-
-  /**
-   * Sets the value for key
-   * {@link com.bumptech.glide.load.resource.bitmap.BitmapEncoder#COMPRESSION_FORMAT}.
-   */
-  public RequestOptions encodeFormat(@NonNull Bitmap.CompressFormat format) {
-    return set(BitmapEncoder.COMPRESSION_FORMAT, Preconditions.checkNotNull(format));
-  }
-
-  /**
-   * Sets the value for key
-   * {@link BitmapEncoder#COMPRESSION_QUALITY}.
-   */
-  public RequestOptions encodeQuality(int quality) {
-    return set(BitmapEncoder.COMPRESSION_QUALITY, quality);
-  }
-
-  /**
-   * Sets the time position of the frame to extract from a video.
-   *
-   * <p>This is a component option specific to {@link VideoBitmapDecoder}. If the default video
-   * decoder is replaced or skipped because of your configuration, this option may be ignored.
-   *
-   * @see VideoBitmapDecoder#TARGET_FRAME
-   * @param frameTimeMicros The time position in microseconds of the desired frame. If negative, the
-   *                        Android framework implementation return a representative frame.
-   */
-  public RequestOptions frame(long frameTimeMicros) {
-    return set(VideoBitmapDecoder.TARGET_FRAME, frameTimeMicros);
-  }
-
-  /**
-   * Sets the {@link DecodeFormat} to use when decoding {@link Bitmap} objects using
-   * {@link Downsampler}.
-   *
-   * <p>{@link DecodeFormat} is a request, not a requirement. It's possible the resource will be
-   * decoded using a decoder that cannot control the format
-   * ({@link android.media.MediaMetadataRetriever} for example), or that the decoder may choose to
-   * ignore the requested format if it can't display the image (i.e. RGB_565 is requested, but the
-   * image has alpha).
-   *
-   * <p>This is a component option specific to {@link Downsampler}. If the defautlt Bitmap decoder
-   * is replaced or skipped because of your configuration, this option may be ignored.
-   *
-   * @see Downsampler#DECODE_FORMAT
-   */
-  public RequestOptions format(@NonNull DecodeFormat format) {
-    return set(Downsampler.DECODE_FORMAT, Preconditions.checkNotNull(format));
-  }
-
-  /**
-   * Sets the {@link DownsampleStrategy} to use when decoding {@link Bitmap Bitmaps} using
-   * {@link Downsampler}.
-   *
-   * <p>This is a component option specific to {@link Downsampler}. If the defautlt Bitmap decoder
-   * is replaced or skipped because of your configuration, this option may be ignored.
-   */
-  public RequestOptions downsample(@NonNull DownsampleStrategy strategy) {
-    return set(Downsampler.DOWNSAMPLE_STRATEGY, Preconditions.checkNotNull(strategy));
-  }
-
-  /**
-   * Sets the read and write timeout for the http requests used to load the image.
-   *
-   * <p>This is a component option specific to Glide's default networking library and
-   * {@link com.bumptech.glide.load.model.stream.HttpGlideUrlLoader}. If you use any other
-   * networking library including Glide's Volley or OkHttp integration libraries, this option will
-   * be ignored.
-   *
-   * @see com.bumptech.glide.load.model.stream.HttpGlideUrlLoader#TIMEOUT
-   * @param timeoutMs The read and write timeout in milliseconds.
-   */
-  public RequestOptions timeout(int timeoutMs) {
-    return set(HttpGlideUrlLoader.TIMEOUT, timeoutMs);
-  }
-
-  /**
-   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterCrop} to all default types, and
-   * ignores unknown types.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @see #optionalTransform(Class, Transformation)
-   * @see #centerCrop()
-   */
-  public RequestOptions optionalCenterCrop() {
-    return optionalTransform(DownsampleStrategy.CENTER_OUTSIDE, new CenterCrop());
-  }
-
-  /**
-   * Applies {@link CenterCrop} to all default types and
-   * throws an exception if asked to transform an unknown type.
-   *
-   * <p>this will override previous calls to {@link #dontTransform()} ()}.
-   *
-   * @see #transform(Class, Transformation)
-   * @see #optionalCenterCrop()
-   */
-  public RequestOptions centerCrop() {
-    return transform(DownsampleStrategy.CENTER_OUTSIDE, new CenterCrop());
-  }
-
-  /**
-   * Applies {@link com.bumptech.glide.load.resource.bitmap.FitCenter} to all default types, and
-   * ignores unknown types.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @see #optionalTransform(Class, Transformation)
-   * @see #fitCenter()
-   */
-  public RequestOptions optionalFitCenter() {
-    return optionalTransform(DownsampleStrategy.FIT_CENTER, new FitCenter());
-  }
-
-  /**
-   * Applies {@link FitCenter} to all default types and
-   * throws an exception if asked to transform an unknown type.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @see #transform(Class, Transformation)
-   * @see #optionalFitCenter()
-   */
-  public RequestOptions fitCenter() {
-    return transform(DownsampleStrategy.FIT_CENTER, new FitCenter());
-  }
-
-  /**
-   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterInside} to all default types, and
-   * ignores unknown types.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @see #optionalTransform(Class, Transformation)
-   * @see #centerInside()
-   */
-  public RequestOptions optionalCenterInside() {
-    return optionalTransform(DownsampleStrategy.CENTER_INSIDE, new CenterInside());
-  }
-
-  /**
-   * Applies {@link CenterInside} to all default types and
-   * throws an exception if asked to transform an unknown type.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @see #transform(Class, Transformation)
-   * @see #optionalCenterInside()
-   */
-  public RequestOptions centerInside() {
-    return transform(DownsampleStrategy.CENTER_INSIDE, new CenterInside());
-  }
-
-  /**
-   * Applies {@link CircleCrop} to all default types, and ignores unknown types.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @see #optionalTransform(Transformation)
-   * @see #circleCrop()
-   */
-  public RequestOptions optionalCircleCrop() {
-    return optionalTransform(DownsampleStrategy.CENTER_OUTSIDE, new CircleCrop());
-  }
-
-  /**
-   * Applies {@link CircleCrop} to all default types and throws an exception if asked to transform
-   * an unknown type.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @see #transform(Class, Transformation)
-   * @see #optionalCenterCrop()
-   */
-  public RequestOptions circleCrop() {
-    return transform(DownsampleStrategy.CENTER_INSIDE, new CircleCrop());
-  }
-
-  // calling optionalTransform() on the result of clone() requires greater access.
-  @SuppressWarnings("WeakerAccess")
-  final RequestOptions optionalTransform(DownsampleStrategy downsampleStrategy,
-      Transformation<Bitmap> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().optionalTransform(downsampleStrategy, transformation);
-    }
-
-    downsample(downsampleStrategy);
-    return optionalTransform(transformation);
-  }
-
-  // calling transform() on the result of clone() requires greater access.
-  @SuppressWarnings("WeakerAccess")
-  final RequestOptions transform(DownsampleStrategy downsampleStrategy,
-      Transformation<Bitmap> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().transform(downsampleStrategy, transformation);
-    }
-
-    downsample(downsampleStrategy);
-    return transform(transformation);
-  }
-
-  /**
-   * Applies the given {@link Transformation} for
-   * {@link Bitmap Bitmaps} to the default types ({@link Bitmap},
-   * {@link android.graphics.drawable.BitmapDrawable}, and
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable})
-   * and throws an exception if asked to transform an unknown type.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param transformation Any {@link Transformation} for
-   *                       {@link Bitmap}s.
-   * @see #optionalTransform(Transformation)
-   * @see #optionalTransform(Class, Transformation)
-   */
-  public RequestOptions transform(@NonNull Transformation<Bitmap> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().transform(transformation);
-    }
-
-    optionalTransform(transformation);
-    isTransformationRequired = true;
-    fields |= TRANSFORMATION_REQUIRED;
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Applies the given {@link Transformation}s in the given order for
-   * {@link Bitmap Bitmaps} to the default types ({@link Bitmap},
-   * {@link android.graphics.drawable.BitmapDrawable}, and
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable})
-   * and throws an exception if asked to transform an unknown type.
-   * <p>
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param transformations One or more {@link Transformation}s for {@link Bitmap}s.
-   * @see #optionalTransform(Transformation)
-   * @see #optionalTransform(Class, Transformation)
-   */
-  @SuppressWarnings("unchecked")
-  public RequestOptions transforms(@NonNull Transformation<Bitmap>... transformations) {
-    if (isAutoCloneEnabled) {
-      return clone().transforms(transformations);
-    }
-
-    optionalTransform(new MultiTransformation<>(transformations));
-    isTransformationRequired = true;
-    fields |= TRANSFORMATION_REQUIRED;
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Applies the given {@link Transformation} for
-   * {@link Bitmap Bitmaps} to the default types ({@link Bitmap},
-   * {@link android.graphics.drawable.BitmapDrawable}, and
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable}) and ignores unknown types.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param transformation Any {@link Transformation} for {@link Bitmap}s.
-   * @see #transform(Transformation)
-   * @see #transform(Class, Transformation)
-   */
-  public RequestOptions optionalTransform(Transformation<Bitmap> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().optionalTransform(transformation);
-    }
-
-    optionalTransform(Bitmap.class, transformation);
-    // TODO: remove BitmapDrawable decoder and this transformation.
-    optionalTransform(BitmapDrawable.class,
-        new BitmapDrawableTransformation(transformation));
-    optionalTransform(GifDrawable.class, new GifDrawableTransformation(transformation));
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Applies the given {@link Transformation} for any decoded resource of
-   * the given type and allows unknown resource types to be ignored.
-   *
-   * <p> Users can apply different transformations for each resource class. Applying a
-   * {@link Transformation} for a resource type that already has a
-   * {@link Transformation} will override the previous call. </p>
-   *
-   * <p> If any calls are made to the non-optional transform methods, then attempting to transform
-   * an unknown resource class will throw an exception. To allow unknown types, users must always
-   * call the optional version of each method. </p>
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param resourceClass  The type of resource to transform.
-   * @param transformation The {@link Transformation} to apply.
-   */
-  public <T> RequestOptions optionalTransform(Class<T> resourceClass,
-      Transformation<T> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().optionalTransform(resourceClass, transformation);
-    }
-
-    Preconditions.checkNotNull(resourceClass);
-    Preconditions.checkNotNull(transformation);
-    transformations.put(resourceClass, transformation);
-    fields |= TRANSFORMATION;
-    isTransformationAllowed = true;
-    fields |= TRANSFORMATION_ALLOWED;
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Applies the given {@link Transformation} for any decoded resource of
-   * the given type and throws if asked to transform an unknown resource type.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param resourceClass  The type of resource to transform.
-   * @param transformation The {@link Transformation} to apply.
-   * @see #optionalTransform(Class, Transformation)
-   */
-  public <T> RequestOptions transform(
-      Class<T> resourceClass, Transformation<T> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().transform(resourceClass, transformation);
-    }
-
-    optionalTransform(resourceClass, transformation);
-    isTransformationRequired = true;
-    fields |= TRANSFORMATION_REQUIRED;
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Removes all applied {@link Transformation Transformations} for all
-   * resource classes and allows unknown resource types to be transformed without throwing an
-   * exception.
-   */
-  public RequestOptions dontTransform() {
-    if (isAutoCloneEnabled) {
-      return clone().dontTransform();
-    }
-
-    transformations.clear();
-    fields &= ~TRANSFORMATION;
-    isTransformationRequired = false;
-    fields &= ~TRANSFORMATION_REQUIRED;
-    isTransformationAllowed = false;
-    fields |= TRANSFORMATION_ALLOWED;
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Disables resource decoders that return animated resources so any resource returned will be
-   * static.
-   *
-   * <p> To disable transitions (fades etc) use
-   * {@link com.bumptech.glide.TransitionOptions#dontTransition()}</p>
-   */
-  public RequestOptions dontAnimate() {
-    if (isAutoCloneEnabled) {
-      return clone().dontAnimate();
-    }
-
-    set(ByteBufferGifDecoder.DISABLE_ANIMATION, true);
-    set(StreamGifDecoder.DISABLE_ANIMATION, true);
-    return selfOrThrowIfLocked();
-  }
-
-  public RequestOptions apply(RequestOptions other) {
-    if (isAutoCloneEnabled) {
-      return clone().apply(other);
-    }
-
-    if (isSet(other.fields, SIZE_MULTIPLIER)) {
-      sizeMultiplier = other.sizeMultiplier;
-    }
-    if (isSet(other.fields, USE_UNLIMITED_SOURCE_GENERATORS_POOL)) {
-      useUnlimitedSourceGeneratorsPool = other.useUnlimitedSourceGeneratorsPool;
-    }
-    if (isSet(other.fields, DISK_CACHE_STRATEGY)) {
-      diskCacheStrategy = other.diskCacheStrategy;
-    }
-    if (isSet(other.fields, PRIORITY)) {
-      priority = other.priority;
-    }
-    if (isSet(other.fields, ERROR_PLACEHOLDER)) {
-      errorPlaceholder = other.errorPlaceholder;
-    }
-    if (isSet(other.fields, ERROR_ID)) {
-      errorId = other.errorId;
-    }
-    if (isSet(other.fields, PLACEHOLDER)) {
-      placeholderDrawable = other.placeholderDrawable;
-    }
-    if (isSet(other.fields, PLACEHOLDER_ID)) {
-      placeholderId = other.placeholderId;
-    }
-    if (isSet(other.fields, IS_CACHEABLE)) {
-      isCacheable = other.isCacheable;
-    }
-    if (isSet(other.fields, OVERRIDE)) {
-      overrideWidth = other.overrideWidth;
-      overrideHeight = other.overrideHeight;
-    }
-    if (isSet(other.fields, SIGNATURE)) {
-      signature = other.signature;
-    }
-    if (isSet(other.fields, RESOURCE_CLASS)) {
-      resourceClass = other.resourceClass;
-    }
-    if (isSet(other.fields, FALLBACK)) {
-      fallbackDrawable = other.fallbackDrawable;
-    }
-    if (isSet(other.fields, FALLBACK_ID)) {
-      fallbackId = other.fallbackId;
-    }
-    if (isSet(other.fields, THEME)) {
-      theme = other.theme;
-    }
-    if (isSet(other.fields, TRANSFORMATION_ALLOWED)) {
-      isTransformationAllowed = other.isTransformationAllowed;
-    }
-    if (isSet(other.fields, TRANSFORMATION_REQUIRED)) {
-      isTransformationRequired = other.isTransformationRequired;
-    }
-    if (isSet(other.fields, TRANSFORMATION)) {
-      transformations.putAll(other.transformations);
-    }
-    if (isSet(other.fields, ONLY_RETRIEVE_FROM_CACHE)) {
-      onlyRetrieveFromCache = other.onlyRetrieveFromCache;
-    }
-
-    // Applying options with dontTransform() is expected to clear our transformations.
-    if (!isTransformationAllowed) {
-      transformations.clear();
-      fields &= ~TRANSFORMATION;
-      isTransformationRequired = false;
-      fields &= ~TRANSFORMATION_REQUIRED;
-    }
-
-    fields |= other.fields;
-    options.putAll(other.options);
-
-    return selfOrThrowIfLocked();
-  }
-
-
-  @Override
-  public boolean equals(Object o) {
-    if (o instanceof RequestOptions) {
-      RequestOptions other = (RequestOptions) o;
-      return Float.compare(other.sizeMultiplier, sizeMultiplier) == 0
-          && errorId == other.errorId
-          && Util.bothNullOrEqual(errorPlaceholder, other.errorPlaceholder)
-          && placeholderId == other.placeholderId
-          && Util.bothNullOrEqual(placeholderDrawable, other.placeholderDrawable)
-          && fallbackId == other.fallbackId
-          && Util.bothNullOrEqual(fallbackDrawable, other.fallbackDrawable)
-          && isCacheable == other.isCacheable
-          && overrideHeight == other.overrideHeight
-          && overrideWidth == other.overrideWidth
-          && isTransformationRequired == other.isTransformationRequired
-          && isTransformationAllowed == other.isTransformationAllowed
-          && useUnlimitedSourceGeneratorsPool == other.useUnlimitedSourceGeneratorsPool
-          && onlyRetrieveFromCache == other.onlyRetrieveFromCache
-          && diskCacheStrategy.equals(other.diskCacheStrategy)
-          && priority == other.priority
-          && options.equals(other.options)
-          && transformations.equals(other.transformations)
-          && resourceClass.equals(other.resourceClass)
-          && Util.bothNullOrEqual(signature, other.signature)
-          && Util.bothNullOrEqual(theme, other.theme);
-    }
-    return false;
-  }
-
-  @Override
-  public int hashCode() {
-    int hashCode = Util.hashCode(sizeMultiplier);
-    hashCode = Util.hashCode(errorId, hashCode);
-    hashCode = Util.hashCode(errorPlaceholder, hashCode);
-    hashCode = Util.hashCode(placeholderId, hashCode);
-    hashCode = Util.hashCode(placeholderDrawable, hashCode);
-    hashCode = Util.hashCode(fallbackId, hashCode);
-    hashCode = Util.hashCode(fallbackDrawable, hashCode);
-    hashCode = Util.hashCode(isCacheable, hashCode);
-    hashCode = Util.hashCode(overrideHeight, hashCode);
-    hashCode = Util.hashCode(overrideWidth, hashCode);
-    hashCode = Util.hashCode(isTransformationRequired, hashCode);
-    hashCode = Util.hashCode(isTransformationAllowed, hashCode);
-    hashCode = Util.hashCode(useUnlimitedSourceGeneratorsPool, hashCode);
-    hashCode = Util.hashCode(onlyRetrieveFromCache, hashCode);
-    hashCode = Util.hashCode(diskCacheStrategy, hashCode);
-    hashCode = Util.hashCode(priority, hashCode);
-    hashCode = Util.hashCode(options, hashCode);
-    hashCode = Util.hashCode(transformations, hashCode);
-    hashCode = Util.hashCode(resourceClass, hashCode);
-    hashCode = Util.hashCode(signature, hashCode);
-    hashCode = Util.hashCode(theme, hashCode);
-    return hashCode;
-  }
-
-  /**
-   * Throws if any further mutations are attempted.
-   *
-   * <p> Once locked, the only way to unlock is to use {@link #clone()} </p>
-   */
-  @SuppressWarnings("unchecked")
-  public RequestOptions lock() {
-    isLocked = true;
-    // This is the only place we should not check locked.
-    return this;
-  }
-
-  /**
-   * Similar to {@link #lock()} except that mutations cause a {@link #clone()} operation to happen
-   * before the mutation resulting in all methods returning a new Object and leaving the original
-   * locked object unmodified.
-   *
-   * <p>Auto clone is not retained by cloned objects returned from mutations. The cloned objects
-   * are mutable and are not locked.
-   */
-  public RequestOptions autoClone() {
-    if (isLocked && !isAutoCloneEnabled) {
-      throw new IllegalStateException("You cannot auto lock an already locked options object"
-          + ", try clone() first");
-    }
-    isAutoCloneEnabled = true;
-    return lock();
-  }
-
-  @SuppressWarnings("unchecked")
-  private RequestOptions selfOrThrowIfLocked() {
-    if (isLocked) {
-      throw new IllegalStateException("You cannot modify locked RequestOptions, consider clone()");
-    }
-    return this;
-  }
-
-  @NonNull
-  public final Map<Class<?>, Transformation<?>> getTransformations() {
-    return transformations;
-  }
-
-  @SuppressWarnings("WeakerAccess")
-  public final boolean isTransformationRequired() {
-    return isTransformationRequired;
-  }
-
-  @NonNull
-  public final Options getOptions() {
-    return options;
-  }
-
-  @NonNull
-  public final Class<?> getResourceClass() {
-    return resourceClass;
-  }
-
-  @NonNull
-  public final DiskCacheStrategy getDiskCacheStrategy() {
-    return diskCacheStrategy;
-  }
-
-  @Nullable
-  @SuppressWarnings("WeakerAccess")
-  public final Drawable getErrorPlaceholder() {
-    return errorPlaceholder;
-  }
-
-  @SuppressWarnings("WeakerAccess")
-  public final int getErrorId() {
-    return errorId;
-  }
-
-  @SuppressWarnings("WeakerAccess")
-  public final int getPlaceholderId() {
-    return placeholderId;
-  }
-
-  @Nullable
-  @SuppressWarnings("WeakerAccess")
-  public final Drawable getPlaceholderDrawable() {
-    return placeholderDrawable;
-  }
-
-  @SuppressWarnings("WeakerAccess")
-  public final int getFallbackId() {
-    return fallbackId;
-  }
-
-  @Nullable
-  @SuppressWarnings("WeakerAccess")
-  public final Drawable getFallbackDrawable() {
-    return fallbackDrawable;
-  }
-
-  @Nullable
-  public final Resources.Theme getTheme() {
-    return theme;
-  }
-
-  @SuppressWarnings("WeakerAccess")
-  public final boolean isMemoryCacheable() {
-    return isCacheable;
-  }
-
-  @NonNull
-  public final Key getSignature() {
-    return signature;
-  }
-
-  public final boolean isPrioritySet() {
-    return isSet(PRIORITY);
-  }
-
-  @NonNull
-  public final Priority getPriority() {
-    return priority;
-  }
-
-  public final int getOverrideWidth() {
-    return overrideWidth;
-  }
-
-  public final boolean isValidOverride() {
-    return Util.isValidDimensions(overrideWidth, overrideHeight);
-  }
-
-  public final int getOverrideHeight() {
-    return overrideHeight;
-  }
-
-  public final float getSizeMultiplier() {
-    return sizeMultiplier;
-  }
-
-  private boolean isSet(int flag) {
-    return isSet(fields, flag);
-  }
-
-  public final boolean getUseUnlimitedSourceGeneratorsPool() {
-    return useUnlimitedSourceGeneratorsPool;
-  }
-
-  public final boolean getOnlyRetrieveFromCache() {
-    return onlyRetrieveFromCache;
-  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
index 35a28c165..7207bc57e 100644
--- a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
@@ -1,12 +1,12 @@
 package com.bumptech.glide.request;
 
-import android.content.res.Resources;
+import android.content.Context;
+import android.content.res.Resources.Theme;
 import android.graphics.drawable.Drawable;
 import android.support.annotation.DrawableRes;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-import android.support.v4.content.res.ResourcesCompat;
 import android.support.v4.util.Pools;
-import android.support.v7.content.res.AppCompatResources;
 import android.util.Log;
 import com.bumptech.glide.GlideContext;
 import com.bumptech.glide.Priority;
@@ -14,6 +14,7 @@
 import com.bumptech.glide.load.engine.Engine;
 import com.bumptech.glide.load.engine.GlideException;
 import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.resource.drawable.DrawableDecoderCompat;
 import com.bumptech.glide.request.target.SizeReadyCallback;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.request.transition.Transition;
@@ -23,6 +24,7 @@
 import com.bumptech.glide.util.Util;
 import com.bumptech.glide.util.pool.FactoryPools;
 import com.bumptech.glide.util.pool.StateVerifier;
+import java.util.List;
 
 /**
  * A {@link Request} that loads a {@link com.bumptech.glide.load.engine.Resource} into a given
@@ -45,6 +47,10 @@
           return new SingleRequest<Object>();
         }
       });
+  private boolean isCallingCallbacks;
+
+  private static final boolean IS_VERBOSE_LOGGABLE =
+      Log.isLoggable(TAG, Log.VERBOSE);
 
   private enum Status {
     /**
@@ -68,33 +74,29 @@
      */
     FAILED,
     /**
-     * Cancelled by the user, may not be restarted.
-     */
-    CANCELLED,
-    /**
-     * Cleared by the user with a placeholder set, may not be restarted.
+     * Cleared by the user with a placeholder set, may be restarted.
      */
     CLEARED,
-    /**
-     * Temporarily paused by the system, may be restarted.
-     */
-    PAUSED,
   }
 
-  private final String tag = String.valueOf(super.hashCode());
+  @Nullable
+  private final String tag = IS_VERBOSE_LOGGABLE ? String.valueOf(super.hashCode()) : null;
   private final StateVerifier stateVerifier = StateVerifier.newInstance();
 
+  @Nullable
+  private RequestListener<R> targetListener;
   private RequestCoordinator requestCoordinator;
+  private Context context;
   private GlideContext glideContext;
   @Nullable
   private Object model;
   private Class<R> transcodeClass;
-  private RequestOptions requestOptions;
+  private BaseRequestOptions<?> requestOptions;
   private int overrideWidth;
   private int overrideHeight;
   private Priority priority;
   private Target<R> target;
-  private RequestListener<R> requestListener;
+  @Nullable private List<RequestListener<R>> requestListeners;
   private Engine engine;
   private TransitionFactory<? super R> animationFactory;
   private Resource<R> resource;
@@ -106,18 +108,19 @@
   private Drawable fallbackDrawable;
   private int width;
   private int height;
-  private static boolean shouldCallAppCompatResources = true;
 
   public static <R> SingleRequest<R> obtain(
+      Context context,
       GlideContext glideContext,
       Object model,
       Class<R> transcodeClass,
-      RequestOptions requestOptions,
+      BaseRequestOptions<?> requestOptions,
       int overrideWidth,
       int overrideHeight,
       Priority priority,
       Target<R> target,
-      RequestListener<R> requestListener,
+      RequestListener<R> targetListener,
+      @Nullable List<RequestListener<R>> requestListeners,
       RequestCoordinator requestCoordinator,
       Engine engine,
       TransitionFactory<? super R> animationFactory) {
@@ -127,6 +130,7 @@
       request = new SingleRequest<>();
     }
     request.init(
+        context,
         glideContext,
         model,
         transcodeClass,
@@ -135,31 +139,36 @@
         overrideHeight,
         priority,
         target,
-        requestListener,
+        targetListener,
+        requestListeners,
         requestCoordinator,
         engine,
         animationFactory);
     return request;
   }
 
+  @SuppressWarnings("WeakerAccess")
   @Synthetic
   SingleRequest() {
     // just create, instances are reused with recycle/init
   }
 
   private void init(
+      Context context,
       GlideContext glideContext,
       Object model,
       Class<R> transcodeClass,
-      RequestOptions requestOptions,
+      BaseRequestOptions<?> requestOptions,
       int overrideWidth,
       int overrideHeight,
       Priority priority,
       Target<R> target,
-      RequestListener<R> requestListener,
+      RequestListener<R> targetListener,
+      @Nullable List<RequestListener<R>> requestListeners,
       RequestCoordinator requestCoordinator,
       Engine engine,
       TransitionFactory<? super R> animationFactory) {
+    this.context = context;
     this.glideContext = glideContext;
     this.model = model;
     this.transcodeClass = transcodeClass;
@@ -168,13 +177,15 @@ private void init(
     this.overrideHeight = overrideHeight;
     this.priority = priority;
     this.target = target;
-    this.requestListener = requestListener;
+    this.targetListener = targetListener;
+    this.requestListeners = requestListeners;
     this.requestCoordinator = requestCoordinator;
     this.engine = engine;
     this.animationFactory = animationFactory;
     status = Status.PENDING;
   }
 
+  @NonNull
   @Override
   public StateVerifier getVerifier() {
     return stateVerifier;
@@ -182,6 +193,8 @@ public StateVerifier getVerifier() {
 
   @Override
   public void recycle() {
+    assertNotCallingCallbacks();
+    context = null;
     glideContext = null;
     model = null;
     transcodeClass = null;
@@ -189,7 +202,8 @@ public void recycle() {
     overrideWidth = -1;
     overrideHeight = -1;
     target = null;
-    requestListener = null;
+    requestListeners = null;
+    targetListener = null;
     requestCoordinator = null;
     animationFactory = null;
     loadStatus = null;
@@ -203,6 +217,7 @@ public void recycle() {
 
   @Override
   public void begin() {
+    assertNotCallingCallbacks();
     stateVerifier.throwIfRecycled();
     startTime = LogTime.getLogTime();
     if (model == null) {
@@ -217,6 +232,24 @@ public void begin() {
       return;
     }
 
+    if (status == Status.RUNNING) {
+      throw new IllegalArgumentException("Cannot restart a running request");
+    }
+
+    // If we're restarted after we're complete (usually via something like a notifyDataSetChanged
+    // that starts an identical request into the same Target or View), we can simply use the
+    // resource and size we retrieved the last time around and skip obtaining a new size, starting a
+    // new load etc. This does mean that users who want to restart a load because they expect that
+    // the view size has changed will need to explicitly clear the View or Target before starting
+    // the new load.
+    if (status == Status.COMPLETE) {
+      onResourceReady(resource, DataSource.MEMORY_CACHE);
+      return;
+    }
+
+    // Restarts for requests that are neither complete nor running can be treated as new requests
+    // and can run again from the beginning.
+
     status = Status.WAITING_FOR_SIZE;
     if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
       onSizeReady(overrideWidth, overrideHeight);
@@ -228,7 +261,7 @@ public void begin() {
         && canNotifyStatusChanged()) {
       target.onLoadStarted(getPlaceholderDrawable());
     }
-    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+    if (IS_VERBOSE_LOGGABLE) {
       logV("finished run method in " + LogTime.getElapsedMillis(startTime));
     }
   }
@@ -241,16 +274,26 @@ public void begin() {
    *
    * @see #clear()
    */
-  void cancel() {
+  private void cancel() {
+    assertNotCallingCallbacks();
     stateVerifier.throwIfRecycled();
     target.removeCallback(this);
-    status = Status.CANCELLED;
     if (loadStatus != null) {
       loadStatus.cancel();
       loadStatus = null;
     }
   }
 
+  // Avoids difficult to understand errors like #2413.
+  private void assertNotCallingCallbacks() {
+    if (isCallingCallbacks) {
+      throw new IllegalStateException("You can't start or clear loads in RequestListener or"
+          + " Target callbacks. If you're trying to start a fallback request when a load fails, use"
+          + " RequestBuilder#error(RequestBuilder). Otherwise consider posting your into() or"
+          + " clear() calls to the main thread using a Handler instead.");
+    }
+  }
+
   /**
    * Cancels the current load if it is in progress, clears any resources held onto by the request
    * and replaces the loaded resource if the load completed with the placeholder.
@@ -262,6 +305,8 @@ void cancel() {
   @Override
   public void clear() {
     Util.assertMainThread();
+    assertNotCallingCallbacks();
+    stateVerifier.throwIfRecycled();
     if (status == Status.CLEARED) {
       return;
     }
@@ -270,22 +315,11 @@ public void clear() {
     if (resource != null) {
       releaseResource(resource);
     }
-    if (canNotifyStatusChanged()) {
+    if (canNotifyCleared()) {
       target.onLoadCleared(getPlaceholderDrawable());
     }
-    // Must be after cancel().
-    status = Status.CLEARED;
-  }
-
-  @Override
-  public boolean isPaused() {
-    return status == Status.PAUSED;
-  }
 
-  @Override
-  public void pause() {
-    clear();
-    status = Status.PAUSED;
+    status = Status.CLEARED;
   }
 
   private void releaseResource(Resource<?> resource) {
@@ -309,8 +343,8 @@ public boolean isResourceSet() {
   }
 
   @Override
-  public boolean isCancelled() {
-    return status == Status.CANCELLED || status == Status.CLEARED;
+  public boolean isCleared() {
+    return status == Status.CLEARED;
   }
 
   @Override
@@ -349,29 +383,9 @@ private Drawable getFallbackDrawable() {
   }
 
   private Drawable loadDrawable(@DrawableRes int resourceId) {
-    if (shouldCallAppCompatResources) {
-      return loadDrawableV7(resourceId);
-    } else {
-      return loadDrawableBase(resourceId);
-    }
-  }
-
-  /**
-   * Tries to load the drawable thanks to AppCompatResources.<br>
-   * This allows to parse VectorDrawables on legacy devices if the appcompat v7 is in the classpath.
-   */
-  private Drawable loadDrawableV7(@DrawableRes int resourceId) {
-    try {
-      return AppCompatResources.getDrawable(glideContext, resourceId);
-    } catch (NoClassDefFoundError error) {
-      shouldCallAppCompatResources = false;
-      return loadDrawableBase(resourceId);
-    }
-  }
-
-  private Drawable loadDrawableBase(@DrawableRes int resourceId) {
-    Resources resources = glideContext.getResources();
-    return ResourcesCompat.getDrawable(resources, resourceId, requestOptions.getTheme());
+    Theme theme = requestOptions.getTheme() != null
+        ? requestOptions.getTheme() : context.getTheme();
+    return DrawableDecoderCompat.getDrawable(glideContext, resourceId, theme);
   }
 
   private void setErrorPlaceholder() {
@@ -400,7 +414,7 @@ private void setErrorPlaceholder() {
   @Override
   public void onSizeReady(int width, int height) {
     stateVerifier.throwIfRecycled();
-    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+    if (IS_VERBOSE_LOGGABLE) {
       logV("Got onSizeReady in " + LogTime.getElapsedMillis(startTime));
     }
     if (status != Status.WAITING_FOR_SIZE) {
@@ -412,7 +426,7 @@ public void onSizeReady(int width, int height) {
     this.width = maybeApplySizeMultiplier(width, sizeMultiplier);
     this.height = maybeApplySizeMultiplier(height, sizeMultiplier);
 
-    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+    if (IS_VERBOSE_LOGGABLE) {
       logV("finished setup for calling load in " + LogTime.getElapsedMillis(startTime));
     }
     loadStatus = engine.load(
@@ -427,12 +441,21 @@ public void onSizeReady(int width, int height) {
         requestOptions.getDiskCacheStrategy(),
         requestOptions.getTransformations(),
         requestOptions.isTransformationRequired(),
+        requestOptions.isScaleOnlyOrNoTransform(),
         requestOptions.getOptions(),
         requestOptions.isMemoryCacheable(),
         requestOptions.getUseUnlimitedSourceGeneratorsPool(),
+        requestOptions.getUseAnimationPool(),
         requestOptions.getOnlyRetrieveFromCache(),
         this);
-    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+
+    // This is a hack that's only useful for testing right now where loads complete synchronously
+    // even though under any executor running on any thread but the main thread, the load would
+    // have completed asynchronously.
+    if (status != Status.RUNNING) {
+      loadStatus = null;
+    }
+    if (IS_VERBOSE_LOGGABLE) {
       logV("finished onSizeReady in " + LogTime.getElapsedMillis(startTime));
     }
   }
@@ -445,6 +468,10 @@ private boolean canSetResource() {
     return requestCoordinator == null || requestCoordinator.canSetImage(this);
   }
 
+  private boolean canNotifyCleared() {
+    return requestCoordinator == null || requestCoordinator.canNotifyCleared(this);
+  }
+
   private boolean canNotifyStatusChanged() {
     return requestCoordinator == null || requestCoordinator.canNotifyStatusChanged(this);
   }
@@ -459,6 +486,12 @@ private void notifyLoadSuccess() {
     }
   }
 
+  private void notifyLoadFailed() {
+    if (requestCoordinator != null) {
+      requestCoordinator.onRequestFailed(this);
+    }
+  }
+
   /**
    * A callback method that should never be invoked directly.
    */
@@ -516,11 +549,26 @@ private void onResourceReady(Resource<R> resource, R result, DataSource dataSour
           + LogTime.getElapsedMillis(startTime) + " ms");
     }
 
-    if (requestListener == null
-        || !requestListener.onResourceReady(result, model, target, dataSource, isFirstResource)) {
-      Transition<? super R> animation =
-          animationFactory.build(dataSource, isFirstResource);
-      target.onResourceReady(result, animation);
+    isCallingCallbacks = true;
+    try {
+      boolean anyListenerHandledUpdatingTarget = false;
+      if (requestListeners != null) {
+        for (RequestListener<R> listener : requestListeners) {
+          anyListenerHandledUpdatingTarget |=
+              listener.onResourceReady(result, model, target, dataSource, isFirstResource);
+        }
+      }
+      anyListenerHandledUpdatingTarget |=
+          targetListener != null
+              && targetListener.onResourceReady(result, model, target, dataSource, isFirstResource);
+
+      if (!anyListenerHandledUpdatingTarget) {
+        Transition<? super R> animation =
+            animationFactory.build(dataSource, isFirstResource);
+        target.onResourceReady(result, animation);
+      }
+    } finally {
+      isCallingCallbacks = false;
     }
 
     notifyLoadSuccess();
@@ -546,27 +594,55 @@ private void onLoadFailed(GlideException e, int maxLogLevel) {
 
     loadStatus = null;
     status = Status.FAILED;
-    //TODO: what if this is a thumbnail request?
-    if (requestListener == null
-        || !requestListener.onLoadFailed(e, model, target, isFirstReadyResource())) {
-      setErrorPlaceholder();
+
+    isCallingCallbacks = true;
+    try {
+      //TODO: what if this is a thumbnail request?
+      boolean anyListenerHandledUpdatingTarget = false;
+      if (requestListeners != null) {
+        for (RequestListener<R> listener : requestListeners) {
+          anyListenerHandledUpdatingTarget |=
+              listener.onLoadFailed(e, model, target, isFirstReadyResource());
+        }
+      }
+      anyListenerHandledUpdatingTarget |=
+          targetListener != null
+              && targetListener.onLoadFailed(e, model, target, isFirstReadyResource());
+
+      if (!anyListenerHandledUpdatingTarget) {
+        setErrorPlaceholder();
+      }
+    } finally {
+      isCallingCallbacks = false;
     }
+
+    notifyLoadFailed();
   }
 
   @Override
   public boolean isEquivalentTo(Request o) {
     if (o instanceof SingleRequest) {
-      SingleRequest that = (SingleRequest) o;
+      SingleRequest<?> that = (SingleRequest<?>) o;
       return overrideWidth == that.overrideWidth
           && overrideHeight == that.overrideHeight
-          && Util.bothNullOrEqual(model, that.model)
+          && Util.bothModelsNullEquivalentOrEquals(model, that.model)
           && transcodeClass.equals(that.transcodeClass)
           && requestOptions.equals(that.requestOptions)
-          && priority == that.priority;
+          && priority == that.priority
+          // We do not want to require that RequestListeners implement equals/hashcode, so we don't
+          // compare them using equals(). We can however, at least assert that the same amount of
+          // request listeners are present in both requests
+          && listenerCountEquals(this, that);
     }
     return false;
   }
 
+  private static boolean listenerCountEquals(SingleRequest<?> first, SingleRequest<?> second) {
+    int firstListenerCount = first.requestListeners == null ? 0 : first.requestListeners.size();
+    int secondListenerCount = second.requestListeners == null ? 0 : second.requestListeners.size();
+    return firstListenerCount == secondListenerCount;
+  }
+
   private void logV(String message) {
     Log.v(TAG, message + " this: " + tag);
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
index 6b62270e2..eaa4ba5a0 100644
--- a/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
+++ b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.request;
 
 import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 
 /**
  * A coordinator that coordinates two individual {@link Request}s that load a small thumbnail
@@ -8,17 +9,19 @@
  */
 public class ThumbnailRequestCoordinator implements RequestCoordinator,
     Request {
+  @Nullable private final RequestCoordinator parent;
+
   private Request full;
   private Request thumb;
-  @Nullable private RequestCoordinator coordinator;
   private boolean isRunning;
 
-  public ThumbnailRequestCoordinator() {
-    this(null);
+  @VisibleForTesting
+  ThumbnailRequestCoordinator() {
+    this(/*parent=*/ null);
   }
 
-  public ThumbnailRequestCoordinator(RequestCoordinator coordinator) {
-    this.coordinator = coordinator;
+  public ThumbnailRequestCoordinator(@Nullable RequestCoordinator parent) {
+    this.parent = parent;
   }
 
   public void setRequests(Request full, Request thumb) {
@@ -38,7 +41,7 @@ public boolean canSetImage(Request request) {
   }
 
   private boolean parentCanSetImage() {
-    return coordinator == null || coordinator.canSetImage(this);
+    return parent == null || parent.canSetImage(this);
   }
 
   /**
@@ -52,8 +55,17 @@ public boolean canNotifyStatusChanged(Request request) {
     return parentCanNotifyStatusChanged() && request.equals(full) && !isAnyResourceSet();
   }
 
+  @Override
+  public boolean canNotifyCleared(Request request) {
+    return parentCanNotifyCleared() && request.equals(full);
+  }
+
+  private boolean parentCanNotifyCleared() {
+    return parent == null || parent.canNotifyCleared(this);
+  }
+
   private boolean parentCanNotifyStatusChanged() {
-    return coordinator == null || coordinator.canNotifyStatusChanged(this);
+    return parent == null || parent.canNotifyStatusChanged(this);
   }
 
   @Override
@@ -66,8 +78,8 @@ public void onRequestSuccess(Request request) {
     if (request.equals(thumb)) {
       return;
     }
-    if (coordinator != null) {
-      coordinator.onRequestSuccess(this);
+    if (parent != null) {
+      parent.onRequestSuccess(this);
     }
     // Clearing the thumb is not necessarily safe if the thumb is being displayed in the Target,
     // as a layer in a cross fade for example. The only way we know the thumb is not being
@@ -77,8 +89,19 @@ public void onRequestSuccess(Request request) {
     }
   }
 
+  @Override
+  public void onRequestFailed(Request request) {
+    if (!request.equals(full)) {
+      return;
+    }
+
+    if (parent != null) {
+      parent.onRequestFailed(this);
+    }
+  }
+
   private boolean parentIsAnyResourceSet() {
-    return coordinator != null && coordinator.isAnyResourceSet();
+    return parent != null && parent.isAnyResourceSet();
   }
 
   /**
@@ -87,7 +110,9 @@ private boolean parentIsAnyResourceSet() {
   @Override
   public void begin() {
     isRunning = true;
-    if (!thumb.isRunning()) {
+    // If the request has completed previously, there's no need to restart both the full and the
+    // thumb, we can just restart the full.
+    if (!full.isComplete() && !thumb.isRunning()) {
       thumb.begin();
     }
     if (isRunning && !full.isRunning()) {
@@ -95,16 +120,6 @@ public void begin() {
     }
   }
 
-  @Override
-  public void pause() {
-    isRunning = false;
-    full.pause();
-    thumb.pause();
-  }
-
-  /**
-   * {@inheritDoc}
-   */
   @Override
   public void clear() {
     isRunning = false;
@@ -112,11 +127,6 @@ public void clear() {
     full.clear();
   }
 
-  @Override
-  public boolean isPaused() {
-    return full.isPaused();
-  }
-
   /**
    * Returns true if the full request is still running.
    */
@@ -139,8 +149,8 @@ public boolean isResourceSet() {
   }
 
   @Override
-  public boolean isCancelled() {
-    return full.isCancelled();
+  public boolean isCleared() {
+    return full.isCleared();
   }
 
   /**
@@ -151,9 +161,6 @@ public boolean isFailed() {
     return full.isFailed();
   }
 
-  /**
-   * {@inheritDoc}.
-   */
   @Override
   public void recycle() {
     full.recycle();
diff --git a/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java b/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java
index 5259a5973..85ebda0de 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java
@@ -4,6 +4,8 @@
 import android.content.ComponentName;
 import android.content.Context;
 import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.widget.RemoteViews;
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.util.Preconditions;
@@ -15,6 +17,8 @@
  * <p> Note - For cancellation to work correctly, you must pass in the same instance of this class
  * for every subsequent load. </p>
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public class AppWidgetTarget extends SimpleTarget<Bitmap> {
   private final int[] widgetIds;
   private final ComponentName componentName;
@@ -116,7 +120,8 @@ private void update() {
   }
 
   @Override
-  public void onResourceReady(Bitmap resource, Transition<? super Bitmap> transition) {
+  public void onResourceReady(@NonNull Bitmap resource,
+      @Nullable Transition<? super Bitmap> transition) {
     this.remoteViews.setImageViewBitmap(this.viewId, resource);
     this.update();
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java b/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java
index 792de64a3..026a3233f 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java
@@ -8,16 +8,23 @@
  * A base {@link Target} for loading {@link com.bumptech.glide.load.engine.Resource}s that provides
  * basic or empty implementations for most methods.
  *
- * <p> For maximum efficiency, clear this target when you have finished using or displaying the
- * {@link com.bumptech.glide.load.engine.Resource} loaded into it using
- * {@link com.bumptech.glide.RequestManager#clear(Target)}.</p>
+ * <p>For maximum efficiency, clear this target when you have finished using or displaying the
+ * {@link com.bumptech.glide.load.engine.Resource} loaded into it using {@link
+ * com.bumptech.glide.RequestManager#clear(Target)}.
  *
- * <p> For loading {@link com.bumptech.glide.load.engine.Resource}s into {@link android.view.View}s,
- * {@link com.bumptech.glide.request.target.ViewTarget} or
- * {@link com.bumptech.glide.request.target.ImageViewTarget} are preferable.</p>
+ * <p>For loading {@link com.bumptech.glide.load.engine.Resource}s into {@link android.view.View}s,
+ * {@link com.bumptech.glide.request.target.ViewTarget} or {@link
+ * com.bumptech.glide.request.target.ImageViewTarget} are preferable.
  *
  * @param <Z> The type of resource that will be received by this target.
+ * @deprecated Use {@link CustomViewTarget} if loading the content into a view, the download API if
+ *     in the background
+ *     (http://bumptech.github.io/glide/doc/getting-started.html#background-threads), or a a fully
+ *     implemented {@link Target} for any specialized use-cases. Using BaseView is unsafe if the
+ *     user does not implement {@link #onLoadCleared}, resulting in recycled bitmaps being
+ *     referenced from the UI and hard to root-cause crashes.
  */
+@Deprecated
 public abstract class BaseTarget<Z> implements Target<Z> {
 
   private Request request;
diff --git a/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java
index e71d23779..386a6a1cf 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java
@@ -8,10 +8,22 @@
  * android.graphics.Bitmap} in an {@link android.widget.ImageView}.
  */
 public class BitmapImageViewTarget extends ImageViewTarget<Bitmap> {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public BitmapImageViewTarget(ImageView view) {
     super(view);
   }
 
+  /**
+   * @deprecated Use {@link #waitForLayout()} instead.
+   */
+  // Public API.
+  @SuppressWarnings({"unused", "deprecation"})
+  @Deprecated
+  public BitmapImageViewTarget(ImageView view, boolean waitForLayout) {
+    super(view, waitForLayout);
+  }
+
   /**
    * Sets the {@link android.graphics.Bitmap} on the view using {@link
    * android.widget.ImageView#setImageBitmap(android.graphics.Bitmap)}.
diff --git a/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java
index c4b247964..90b03a62f 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java
@@ -8,11 +8,22 @@
 /**
  * Efficiently displays multiple Bitmaps loaded serially into a single {@link android.view.View}.
  */
+// Public API.
+@SuppressWarnings("unused")
 public class BitmapThumbnailImageViewTarget extends ThumbnailImageViewTarget<Bitmap> {
   public BitmapThumbnailImageViewTarget(ImageView view) {
     super(view);
   }
 
+  /**
+   * @deprecated Use {@link #waitForLayout()} instead.
+   */
+  @SuppressWarnings("deprecation")
+  @Deprecated
+  public BitmapThumbnailImageViewTarget(ImageView view, boolean waitForLayout) {
+    super(view, waitForLayout);
+  }
+
   @Override
   protected Drawable getDrawable(Bitmap resource) {
     return new BitmapDrawable(view.getResources(), resource);
diff --git a/library/src/main/java/com/bumptech/glide/request/target/CustomTarget.java b/library/src/main/java/com/bumptech/glide/request/target/CustomTarget.java
new file mode 100644
index 000000000..ede0b2baf
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/target/CustomTarget.java
@@ -0,0 +1,123 @@
+package com.bumptech.glide.request.target;
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.view.View;
+import android.widget.ImageView;
+import com.bumptech.glide.request.Request;
+import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.util.Util;
+
+/**
+ * A base {@link Target} for loading resources ({@link android.graphics.Bitmap}, {@link Drawable}
+ * etc) that are used outside of {@link android.view.View}s.
+ *
+ * <p>If you're loading a resource into a {@link View}, use
+ * {@link com.bumptech.glide.RequestBuilder#into(ImageView)}, a subclass of {@link ImageViewTarget},
+ * or {@link CustomViewTarget}. Using this class to load resources into {@link View}s can prevent
+ * Glide from correctly cancelling any previous loads, which may result in incorrect images
+ * appearing in the view, especially in scrolling views like
+ * {@link android.support.v7.widget.RecyclerView}.
+ *
+ * <p>You <em>MUST</em> implement {@link #onLoadCleared(Drawable)} and ensure that all references to
+ * any resource passed into the target in {@link #onResourceReady(Object, Transition)} are removed
+ * before {@link #onLoadCleared(Drawable)} completes. Failing to do so can result in graphical
+ * corruption, crashes caused by recycled {@link Bitmap}s, and other undefined behavior. It is never
+ * safe to leave {@link #onLoadCleared(Drawable)} unimplemented or empty. Even if you do not
+ * manually clear this {@link Target}, Glide may do so automatically after certain lifecycle events
+ * in {@link android.support.v4.app.Fragment}s and {@link android.app.Activity}s.
+ *
+ * <p>This class can only be used with {@link Target#SIZE_ORIGINAL} or when the desired resource
+ * dimensions are known when the {@link Target} is created. If you'd like to run some asynchronous
+ * process and make full use of {@link #getSize(SizeReadyCallback)} and {@link SizeReadyCallback},
+ * extend {@link Target} directly instead of using this class.
+ *
+ * @param <T> The type of resource that will be loaded (e.g. {@link Bitmap}).
+ */
+public abstract class CustomTarget<T> implements Target<T> {
+
+  private final int width;
+  private final int height;
+
+  @Nullable
+  private Request request;
+
+  /**
+   * Creates a new {@link CustomTarget} that will attempt to load the resource in its original size.
+   *
+   * <p>This constructor can cause very memory inefficient loads if the resource is large and can
+   * cause OOMs. It's provided as a convenience for when you'd like to specify dimensions with
+   * {@link com.bumptech.glide.request.RequestOptions#override(int)}. In all other cases, prefer
+   * {@link #CustomTarget(int, int)}.
+   */
+  public CustomTarget() {
+    this(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
+  }
+
+  /**
+   * Creates a new {@code CustomTarget} that will return the given {@code width} and {@link @code}
+   * as the requested size (unless overridden by
+   * {@link com.bumptech.glide.request.RequestOptions#override(int)} in the request).
+   *
+   * @param width The requested width (>= 0, or == Target.SIZE_ORIGINAL).
+   * @param height The requested height (>= 0, or == Target.SIZE_ORIGINAL).
+   */
+  public CustomTarget(int width, int height) {
+     if (!Util.isValidDimensions(width, height)) {
+      throw new IllegalArgumentException(
+          "Width and height must both be > 0 or Target#SIZE_ORIGINAL, but given" + " width: "
+              + width + " and height: " + height);
+    }
+
+    this.width = width;
+    this.height = height;
+  }
+
+  @Override
+  public void onStart() {
+    // Intentionally empty, this can be optionally implemented by subclasses.
+  }
+
+  @Override
+  public void onStop() {
+    // Intentionally empty, this can be optionally implemented by subclasses.
+  }
+
+  @Override
+  public void onDestroy() {
+    // Intentionally empty, this can be optionally implemented by subclasses.
+  }
+
+  @Override
+  public void onLoadStarted(@Nullable Drawable placeholder) {
+    // Intentionally empty, this can be optionally implemented by subclasses.
+  }
+
+  @Override
+  public void onLoadFailed(@Nullable Drawable errorDrawable) {
+    // Intentionally empty, this can be optionally implemented by subclasses.
+  }
+
+  @Override
+  public final void getSize(@NonNull SizeReadyCallback cb) {
+    cb.onSizeReady(width, height);
+  }
+
+  @Override
+  public final void removeCallback(@NonNull SizeReadyCallback cb) {
+    // Do nothing, this class does not retain SizeReadyCallbacks.
+  }
+
+  @Override
+  public final void setRequest(@Nullable Request request) {
+    this.request = request;
+  }
+
+  @Nullable
+  @Override
+  public final Request getRequest() {
+    return request;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/target/CustomViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/CustomViewTarget.java
new file mode 100644
index 000000000..28aa06465
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/target/CustomViewTarget.java
@@ -0,0 +1,496 @@
+package com.bumptech.glide.request.target;
+
+import android.content.Context;
+import android.graphics.Point;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.IdRes;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
+import android.util.Log;
+import android.view.Display;
+import android.view.View;
+import android.view.View.OnAttachStateChangeListener;
+import android.view.ViewGroup.LayoutParams;
+import android.view.ViewTreeObserver;
+import android.view.WindowManager;
+import com.bumptech.glide.R;
+import com.bumptech.glide.request.Request;
+import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Synthetic;
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * A base {@link Target} for loading resources ({@link android.graphics.Bitmap}, {@link Drawable}
+ * etc) into {@link View}s that provides default implementations for most methods and can determine
+ * the size of views using a {@link android.view.ViewTreeObserver.OnDrawListener}.
+ *
+ * @param <T> The specific subclass of view wrapped by this target (e.g.
+ *          {@link android.widget.ImageView})
+ * @param <Z> The resource type this target will receive (e.g. {@link android.graphics.Bitmap}).
+ */
+public abstract class CustomViewTarget<T extends View, Z> implements Target<Z> {
+  private static final String TAG = "CustomViewTarget";
+  @IdRes private static final int VIEW_TAG_ID =
+      R.id.glide_custom_view_target_tag;
+
+  private final SizeDeterminer sizeDeterminer;
+
+  protected final T view;
+  @Nullable private OnAttachStateChangeListener attachStateListener;
+  private boolean isClearedByUs;
+  private boolean isAttachStateListenerAdded;
+  @IdRes private int overrideTag;
+
+  /** Constructor that defaults {@code waitForLayout} to {@code false}. */
+  public CustomViewTarget(@NonNull T view) {
+    this.view = Preconditions.checkNotNull(view);
+    sizeDeterminer = new SizeDeterminer(view);
+  }
+
+  /**
+   * A required callback invoked when the resource is no longer valid and must be freed.
+   *
+   * <p>You must ensure that any current Drawable received in
+   * {@link #onResourceReady(Object, Transition)} is no longer used before redrawing the container
+   * (usually a View) or changing its visibility. <b>Not doing so will result in crashes in your
+   * app.</b>
+   *
+   * @param placeholder The placeholder drawable to optionally show, or null.
+   */
+  protected abstract void onResourceCleared(@Nullable Drawable placeholder);
+
+  /**
+   * An optional callback invoked when a resource load is started.
+   *
+   * @see Target#onLoadStarted(Drawable)
+   * @param placeholder The placeholder drawable to optionally show, or null.
+   */
+  protected void onResourceLoading(@Nullable Drawable placeholder) {
+    // Default empty.
+  }
+
+  @Override
+  public void onStart() {
+    // Default empty.
+  }
+
+  @Override
+  public void onStop() {
+    // Default empty.
+  }
+
+  @Override
+  public void onDestroy() {
+    // Default empty.
+  }
+
+  /**
+   * Indicates that Glide should always wait for any pending layout pass before checking for the
+   * size an {@link View}.
+   *
+   * <p>By default, Glide will only wait for a pending layout pass if it's unable to resolve the
+   * size from the {@link LayoutParams} or valid non-zero values for {@link View#getWidth()} and
+   * {@link View#getHeight()}.
+   *
+   * <p>Because calling this method forces Glide to wait for the layout pass to occur before
+   * starting loads, setting this parameter to {@code true} can cause Glide to asynchronous load an
+   * image even if it's in the memory cache. The load will happen asynchronously because Glide has
+   * to wait for a layout pass to occur, which won't necessarily happen in the same frame as when
+   * the image is requested. As a result, using this method can resulting in flashing in some cases
+   * and should be used sparingly.
+   *
+   * <p>If the {@link LayoutParams} of the wrapped {@link View} are set to fixed sizes, they will
+   * still be used instead of the {@link View}'s dimensions even if this method is called. This
+   * parameter is a fallback only.
+   */
+  @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
+  public final CustomViewTarget<T, Z> waitForLayout() {
+    sizeDeterminer.waitForLayout = true;
+    return this;
+  }
+
+  /**
+   * Clears the {@link View}'s {@link Request} when the {@link View} is detached from its {@link
+   * android.view.Window} and restarts the {@link Request} when the {@link View} is re-attached from
+   * its {@link android.view.Window}.
+   *
+   * <p>This is an experimental API that may be removed in a future version.
+   *
+   * <p>Using this method can save memory by allowing Glide to more eagerly clear resources when
+   * transitioning screens or swapping adapters in scrolling views. However it also substantially
+   * increases the odds that images will not be in memory if users subsequently return to a screen
+   * where images were previously loaded. Whether or not this happens will depend on the number of
+   * images loaded in the new screen and the size of the memory cache. Increasing the size of the
+   * memory cache can improve this behavior but it largely negates the memory benefits of using this
+   * method.
+   *
+   * <p>Use this method with caution and measure your memory usage to ensure that it's actually
+   * improving your memory usage in the cases you care about.
+   */
+  // Public API.
+  @NonNull
+  @SuppressWarnings({"UnusedReturnValue", "WeakerAccess"})
+  public final CustomViewTarget<T, Z> clearOnDetach() {
+    if (attachStateListener != null) {
+      return this;
+    }
+    attachStateListener = new OnAttachStateChangeListener() {
+      @Override
+      public void onViewAttachedToWindow(View v) {
+        resumeMyRequest();
+      }
+
+      @Override
+      public void onViewDetachedFromWindow(View v) {
+        pauseMyRequest();
+      }
+    };
+    maybeAddAttachStateListener();
+    return this;
+  }
+
+  /**
+   * Override the android resource id to store temporary state allowing loads to be automatically
+   * cancelled and resources re-used in scrolling lists.
+   *
+   * <p>Unlike {@link ViewTarget}, it is <b>not</b> necessary to set a custom tag id if your app
+   * uses {@link View#setTag(Object)}. It is only necessary if loading several Glide resources into
+   * the same view, for example one foreground and one background view.
+   *
+   * @param tagId The android resource id to use.
+   */
+  // Public API.
+  @SuppressWarnings({"UnusedReturnValue", "WeakerAccess"})
+  public final CustomViewTarget<T, Z> useTagId(@IdRes int tagId) {
+    if (this.overrideTag != 0) {
+      throw new IllegalArgumentException("You cannot change the tag id once it has been set.");
+    }
+    this.overrideTag = tagId;
+    return this;
+  }
+
+  /** Returns the wrapped {@link android.view.View}. */
+  @NonNull
+  public final T getView() {
+    return view;
+  }
+
+  /**
+   * Determines the size of the view by first checking {@link android.view.View#getWidth()} and
+   * {@link android.view.View#getHeight()}. If one or both are zero, it then checks the view's
+   * {@link LayoutParams}. If one or both of the params width and height are less than or equal to
+   * zero, it then adds an {@link android.view.ViewTreeObserver.OnPreDrawListener} which waits until
+   * the view has been measured before calling the callback with the view's drawn width and height.
+   *
+   * @param cb {@inheritDoc}
+   */
+  @Override
+  public final void getSize(@NonNull SizeReadyCallback cb) {
+    sizeDeterminer.getSize(cb);
+  }
+
+  @Override
+  public final void removeCallback(@NonNull SizeReadyCallback cb) {
+    sizeDeterminer.removeCallback(cb);
+  }
+
+  @Override
+  public final void onLoadStarted(@Nullable Drawable placeholder) {
+    maybeAddAttachStateListener();
+    onResourceLoading(placeholder);
+  }
+
+  @Override
+  public final void onLoadCleared(@Nullable Drawable placeholder) {
+    sizeDeterminer.clearCallbacksAndListener();
+
+    onResourceCleared(placeholder);
+    if (!isClearedByUs) {
+      maybeRemoveAttachStateListener();
+    }
+  }
+
+  /**
+   * Stores the request using {@link View#setTag(Object)}.
+   *
+   * @param request {@inheritDoc}
+   */
+  @Override
+  public final void setRequest(@Nullable Request request) {
+    setTag(request);
+  }
+
+  /** Returns any stored request using {@link android.view.View#getTag()}. */
+  @Override
+  @Nullable
+  public final Request getRequest() {
+    Object tag = getTag();
+    if (tag != null) {
+      if (tag instanceof Request) {
+        return (Request) tag;
+      } else {
+        throw new IllegalArgumentException("You must not pass non-R.id ids to setTag(id)");
+      }
+    }
+    return null;
+  }
+
+  @Override
+  public String toString() {
+    return "Target for: " + view;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  final void resumeMyRequest() {
+    Request request = getRequest();
+    if (request != null && request.isCleared()) {
+      request.begin();
+    }
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  final void pauseMyRequest() {
+    Request request = getRequest();
+    if (request != null) {
+      isClearedByUs = true;
+      request.clear();
+      isClearedByUs = false;
+    }
+  }
+
+  private void setTag(@Nullable Object tag) {
+    view.setTag(overrideTag == 0 ? VIEW_TAG_ID : overrideTag, tag);
+  }
+
+  @Nullable
+  private Object getTag() {
+    return view.getTag(overrideTag == 0 ? VIEW_TAG_ID : overrideTag);
+  }
+
+  private void maybeAddAttachStateListener() {
+    if (attachStateListener == null || isAttachStateListenerAdded) {
+      return;
+    }
+
+    view.addOnAttachStateChangeListener(attachStateListener);
+    isAttachStateListenerAdded = true;
+  }
+
+  private void maybeRemoveAttachStateListener() {
+    if (attachStateListener == null || !isAttachStateListenerAdded) {
+      return;
+    }
+
+    view.removeOnAttachStateChangeListener(attachStateListener);
+    isAttachStateListenerAdded = false;
+  }
+
+  @VisibleForTesting
+  static final class SizeDeterminer {
+    // Some negative sizes (Target.SIZE_ORIGINAL) are valid, 0 is never valid.
+    private static final int PENDING_SIZE = 0;
+    @VisibleForTesting
+    @Nullable
+    static Integer maxDisplayLength;
+    private final View view;
+    private final List<SizeReadyCallback> cbs = new ArrayList<>();
+    @Synthetic boolean waitForLayout;
+
+    @Nullable private SizeDeterminerLayoutListener layoutListener;
+
+    SizeDeterminer(@NonNull View view) {
+      this.view = view;
+    }
+
+    // Use the maximum to avoid depending on the device's current orientation.
+    private static int getMaxDisplayLength(@NonNull Context context) {
+      if (maxDisplayLength == null) {
+        WindowManager windowManager =
+            (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
+        Display display = Preconditions.checkNotNull(windowManager).getDefaultDisplay();
+        Point displayDimensions = new Point();
+        display.getSize(displayDimensions);
+        maxDisplayLength = Math.max(displayDimensions.x, displayDimensions.y);
+      }
+      return maxDisplayLength;
+    }
+
+    private void notifyCbs(int width, int height) {
+      // One or more callbacks may trigger the removal of one or more additional callbacks, so we
+      // need a copy of the list to avoid a concurrent modification exception. One place this
+      // happens is when a full request completes from the in memory cache while its thumbnail is
+      // still being loaded asynchronously. See #2237.
+      for (SizeReadyCallback cb : new ArrayList<>(cbs)) {
+        cb.onSizeReady(width, height);
+      }
+    }
+
+    @Synthetic
+    void checkCurrentDimens() {
+      if (cbs.isEmpty()) {
+        return;
+      }
+
+      int currentWidth = getTargetWidth();
+      int currentHeight = getTargetHeight();
+      if (!isViewStateAndSizeValid(currentWidth, currentHeight)) {
+        return;
+      }
+
+      notifyCbs(currentWidth, currentHeight);
+      clearCallbacksAndListener();
+    }
+
+    void getSize(@NonNull SizeReadyCallback cb) {
+      int currentWidth = getTargetWidth();
+      int currentHeight = getTargetHeight();
+      if (isViewStateAndSizeValid(currentWidth, currentHeight)) {
+        cb.onSizeReady(currentWidth, currentHeight);
+        return;
+      }
+
+      // We want to notify callbacks in the order they were added and we only expect one or two
+      // callbacks to be added a time, so a List is a reasonable choice.
+      if (!cbs.contains(cb)) {
+        cbs.add(cb);
+      }
+      if (layoutListener == null) {
+        ViewTreeObserver observer = view.getViewTreeObserver();
+        layoutListener = new SizeDeterminerLayoutListener(this);
+        observer.addOnPreDrawListener(layoutListener);
+      }
+    }
+
+    /**
+     * The callback may be called anyway if it is removed by another {@link SizeReadyCallback} or
+     * otherwise removed while we're notifying the list of callbacks.
+     *
+     * <p>See #2237.
+     */
+    void removeCallback(@NonNull SizeReadyCallback cb) {
+      cbs.remove(cb);
+    }
+
+    void clearCallbacksAndListener() {
+      // Keep a reference to the layout attachStateListener and remove it here
+      // rather than having the observer remove itself because the observer
+      // we add the attachStateListener to will be almost immediately merged into
+      // another observer and will therefore never be alive. If we instead
+      // keep a reference to the attachStateListener and remove it here, we get the
+      // current view tree observer and should succeed.
+      ViewTreeObserver observer = view.getViewTreeObserver();
+      if (observer.isAlive()) {
+        observer.removeOnPreDrawListener(layoutListener);
+      }
+      layoutListener = null;
+      cbs.clear();
+    }
+
+    private boolean isViewStateAndSizeValid(int width, int height) {
+      return isDimensionValid(width) && isDimensionValid(height);
+    }
+
+    private int getTargetHeight() {
+      int verticalPadding = view.getPaddingTop() + view.getPaddingBottom();
+      LayoutParams layoutParams = view.getLayoutParams();
+      int layoutParamSize = layoutParams != null ? layoutParams.height : PENDING_SIZE;
+      return getTargetDimen(view.getHeight(), layoutParamSize, verticalPadding);
+    }
+
+    private int getTargetWidth() {
+      int horizontalPadding = view.getPaddingLeft() + view.getPaddingRight();
+      LayoutParams layoutParams = view.getLayoutParams();
+      int layoutParamSize = layoutParams != null ? layoutParams.width : PENDING_SIZE;
+      return getTargetDimen(view.getWidth(), layoutParamSize, horizontalPadding);
+    }
+
+    private int getTargetDimen(int viewSize, int paramSize, int paddingSize) {
+      // We consider the View state as valid if the View has non-null layout params and a non-zero
+      // layout params width and height. This is imperfect. We're making an assumption that View
+      // parents will obey their child's layout parameters, which isn't always the case.
+      int adjustedParamSize = paramSize - paddingSize;
+      if (adjustedParamSize > 0) {
+        return adjustedParamSize;
+      }
+
+      // Since we always prefer layout parameters with fixed sizes, even if waitForLayout is true,
+      // we might as well ignore it and just return the layout parameters above if we have them.
+      // Otherwise we should wait for a layout pass before checking the View's dimensions.
+      if (waitForLayout && view.isLayoutRequested()) {
+        return PENDING_SIZE;
+      }
+
+      // We also consider the View state valid if the View has a non-zero width and height. This
+      // means that the View has gone through at least one layout pass. It does not mean the Views
+      // width and height are from the current layout pass. For example, if a View is re-used in
+      // RecyclerView or ListView, this width/height may be from an old position. In some cases
+      // the dimensions of the View at the old position may be different than the dimensions of the
+      // View in the new position because the LayoutManager/ViewParent can arbitrarily decide to
+      // change them. Nevertheless, in most cases this should be a reasonable choice.
+      int adjustedViewSize = viewSize - paddingSize;
+      if (adjustedViewSize > 0) {
+        return adjustedViewSize;
+      }
+
+      // Finally we consider the view valid if the layout parameter size is set to wrap_content.
+      // It's difficult for Glide to figure out what to do here. Although Target.SIZE_ORIGINAL is a
+      // coherent choice, it's extremely dangerous because original images may be much too large to
+      // fit in memory or so large that only a couple can fit in memory, causing OOMs. If users want
+      // the original image, they can always use .override(Target.SIZE_ORIGINAL). Since wrap_content
+      // may never resolve to a real size unless we load something, we aim for a square whose length
+      // is the largest screen size. That way we're loading something and that something has some
+      // hope of being downsampled to a size that the device can support. We also log a warning that
+      // tries to explain what Glide is doing and why some alternatives are preferable.
+      // Since WRAP_CONTENT is sometimes used as a default layout parameter, we always wait for
+      // layout to complete before using this fallback parameter (ConstraintLayout among others).
+      if (!view.isLayoutRequested() && paramSize == LayoutParams.WRAP_CONTENT) {
+        if (Log.isLoggable(TAG, Log.INFO)) {
+          Log.i(TAG, "Glide treats LayoutParams.WRAP_CONTENT as a request for an image the size of"
+              + " this device's screen dimensions. If you want to load the original image and are"
+              + " ok with the corresponding memory cost and OOMs (depending on the input size), use"
+              + " .override(Target.SIZE_ORIGINAL). Otherwise, use LayoutParams.MATCH_PARENT, set"
+              + " layout_width and layout_height to fixed dimension, or use .override() with fixed"
+              + " dimensions.");
+        }
+        return getMaxDisplayLength(view.getContext());
+      }
+
+      // If the layout parameters are < padding, the view size is < padding, or the layout
+      // parameters are set to match_parent or wrap_content and no layout has occurred, we should
+      // wait for layout and repeat.
+      return PENDING_SIZE;
+    }
+
+    private boolean isDimensionValid(int size) {
+      return size > 0 || size == SIZE_ORIGINAL;
+    }
+
+    private static final class SizeDeterminerLayoutListener
+        implements ViewTreeObserver.OnPreDrawListener {
+      private final WeakReference<SizeDeterminer> sizeDeterminerRef;
+
+      SizeDeterminerLayoutListener(@NonNull SizeDeterminer sizeDeterminer) {
+        sizeDeterminerRef = new WeakReference<>(sizeDeterminer);
+      }
+
+      @Override
+      public boolean onPreDraw() {
+        if (Log.isLoggable(TAG, Log.VERBOSE)) {
+          Log.v(TAG, "OnGlobalLayoutListener called attachStateListener=" + this);
+        }
+        SizeDeterminer sizeDeterminer = sizeDeterminerRef.get();
+        if (sizeDeterminer != null) {
+          sizeDeterminer.checkCurrentDimens();
+        }
+        return true;
+      }
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java
index e9ab75e01..ca9c6528d 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java
@@ -13,6 +13,16 @@ public DrawableImageViewTarget(ImageView view) {
     super(view);
   }
 
+  /**
+   * @deprecated Use {@link #waitForLayout()} instead.
+   */
+  // Public API.
+  @SuppressWarnings({"unused", "deprecation"})
+  @Deprecated
+  public DrawableImageViewTarget(ImageView view, boolean waitForLayout) {
+    super(view, waitForLayout);
+  }
+
   @Override
   protected void setResource(@Nullable Drawable resource) {
     view.setImageDrawable(resource);
diff --git a/library/src/main/java/com/bumptech/glide/request/target/DrawableThumbnailImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/DrawableThumbnailImageViewTarget.java
index 416633f7c..40ff2dad4 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/DrawableThumbnailImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableThumbnailImageViewTarget.java
@@ -6,11 +6,22 @@
 /**
  * Efficiently displays multiple Drawables loaded serially into a single {@link android.view.View}.
  */
+// Public API.
+@SuppressWarnings("unused")
 public class DrawableThumbnailImageViewTarget extends ThumbnailImageViewTarget<Drawable> {
   public DrawableThumbnailImageViewTarget(ImageView view) {
     super(view);
   }
 
+  /**
+   * @deprecated Use {@link #waitForLayout()} instead.
+   */
+  @Deprecated
+  @SuppressWarnings("deprecation")
+  public DrawableThumbnailImageViewTarget(ImageView view, boolean waitForLayout) {
+    super(view, waitForLayout);
+  }
+
   @Override
   protected Drawable getDrawable(Drawable resource) {
     return resource;
diff --git a/library/src/main/java/com/bumptech/glide/request/target/FixedSizeDrawable.java b/library/src/main/java/com/bumptech/glide/request/target/FixedSizeDrawable.java
index f5d978a22..154bdc3eb 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/FixedSizeDrawable.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/FixedSizeDrawable.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.request.target;
 
-import android.annotation.TargetApi;
 import android.content.res.Resources;
 import android.graphics.Canvas;
 import android.graphics.ColorFilter;
@@ -10,6 +9,8 @@
 import android.graphics.RectF;
 import android.graphics.drawable.Drawable;
 import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.annotation.RequiresApi;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
 
@@ -27,6 +28,8 @@
   private State state;
   private boolean mutated;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public FixedSizeDrawable(Drawable wrapped, int width, int height) {
     this(new State(wrapped.getConstantState(), width, height), wrapped);
   }
@@ -51,7 +54,7 @@ public void setBounds(int left, int top, int right, int bottom) {
   }
 
   @Override
-  public void setBounds(Rect bounds) {
+  public void setBounds(@NonNull Rect bounds) {
     super.setBounds(bounds);
     this.bounds.set(bounds);
     updateMatrix();
@@ -71,6 +74,7 @@ public int getChangingConfigurations() {
     return wrapped.getChangingConfigurations();
   }
 
+  @Deprecated
   @Override
   public void setDither(boolean dither) {
     wrapped.setDither(dither);
@@ -86,14 +90,14 @@ public Callback getCallback() {
     return wrapped.getCallback();
   }
 
-  @TargetApi(Build.VERSION_CODES.KITKAT)
+  @RequiresApi(Build.VERSION_CODES.KITKAT)
   @Override
   public int getAlpha() {
     return wrapped.getAlpha();
   }
 
   @Override
-  public void setColorFilter(int color, PorterDuff.Mode mode) {
+  public void setColorFilter(int color, @NonNull PorterDuff.Mode mode) {
     wrapped.setColorFilter(color, mode);
   }
 
@@ -102,6 +106,7 @@ public void clearColorFilter() {
     wrapped.clearColorFilter();
   }
 
+  @NonNull
   @Override
   public Drawable getCurrent() {
     return wrapped.getCurrent();
@@ -133,7 +138,7 @@ public int getMinimumHeight() {
   }
 
   @Override
-  public boolean getPadding(Rect padding) {
+  public boolean getPadding(@NonNull Rect padding) {
     return wrapped.getPadding(padding);
   }
 
@@ -144,19 +149,19 @@ public void invalidateSelf() {
   }
 
   @Override
-  public void unscheduleSelf(Runnable what) {
+  public void unscheduleSelf(@NonNull Runnable what) {
     super.unscheduleSelf(what);
     wrapped.unscheduleSelf(what);
   }
 
   @Override
-  public void scheduleSelf(Runnable what, long when) {
+  public void scheduleSelf(@NonNull Runnable what, long when) {
     super.scheduleSelf(what, when);
     wrapped.scheduleSelf(what, when);
   }
 
   @Override
-  public void draw(Canvas canvas) {
+  public void draw(@NonNull Canvas canvas) {
     canvas.save();
     canvas.concat(matrix);
     wrapped.draw(canvas);
@@ -178,6 +183,7 @@ public int getOpacity() {
     return wrapped.getOpacity();
   }
 
+  @NonNull
   @Override
   public Drawable mutate() {
     if (!mutated && super.mutate() == this) {
@@ -193,7 +199,7 @@ public ConstantState getConstantState() {
     return state;
   }
 
-  static class State extends ConstantState {
+  static final class State extends ConstantState {
     private final ConstantState wrapped;
     @Synthetic final int width;
     @Synthetic final int height;
@@ -208,11 +214,13 @@ public ConstantState getConstantState() {
       this.height = height;
     }
 
+    @NonNull
     @Override
     public Drawable newDrawable() {
       return new FixedSizeDrawable(this, wrapped.newDrawable());
     }
 
+    @NonNull
     @Override
     public Drawable newDrawable(Resources res) {
       return new FixedSizeDrawable(this, wrapped.newDrawable(res));
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java
index eb4fa50ab..6f270b9a6 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java
@@ -2,6 +2,7 @@
 
 import android.graphics.drawable.Animatable;
 import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.widget.ImageView;
 import com.bumptech.glide.request.transition.Transition;
@@ -13,6 +14,8 @@
  * @param <Z> The type of resource that this target will display in the wrapped {@link
  *            android.widget.ImageView}.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public abstract class ImageViewTarget<Z> extends ViewTarget<ImageView, Z>
     implements Transition.ViewAdapter {
 
@@ -23,6 +26,15 @@ public ImageViewTarget(ImageView view) {
     super(view);
   }
 
+  /**
+   * @deprecated Use {@link #waitForLayout()} instead.
+   */
+  @SuppressWarnings({"deprecation"})
+  @Deprecated
+  public ImageViewTarget(ImageView view, boolean waitForLayout) {
+    super(view, waitForLayout);
+  }
+
   /**
    * Returns the current {@link android.graphics.drawable.Drawable} being displayed in the view
    * using {@link android.widget.ImageView#getDrawable()}.
@@ -79,12 +91,15 @@ public void onLoadFailed(@Nullable Drawable errorDrawable) {
   @Override
   public void onLoadCleared(@Nullable Drawable placeholder) {
     super.onLoadCleared(placeholder);
+    if (animatable != null) {
+      animatable.stop();
+    }
     setResourceInternal(null);
     setDrawable(placeholder);
   }
 
   @Override
-  public void onResourceReady(Z resource, @Nullable Transition<? super Z> transition) {
+  public void onResourceReady(@NonNull Z resource, @Nullable Transition<? super Z> transition) {
     if (transition == null || !transition.transition(resource, this)) {
       setResourceInternal(resource);
     } else {
@@ -107,8 +122,10 @@ public void onStop() {
   }
 
   private void setResourceInternal(@Nullable Z resource) {
-    maybeUpdateAnimatable(resource);
+    // Order matters here. Set the resource first to make sure that the Drawable has a valid and
+    // non-null Callback before starting it.
     setResource(resource);
+    maybeUpdateAnimatable(resource);
   }
 
   private void maybeUpdateAnimatable(@Nullable Z resource) {
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java
index 33454b46a..2e91ac594 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java
@@ -2,6 +2,7 @@
 
 import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
 import android.widget.ImageView;
 
 /**
@@ -9,13 +10,14 @@
  * {@link com.bumptech.glide.request.target.Target} for a given {@link android.view.View} subclass.
  */
 public class ImageViewTargetFactory {
-
+  @NonNull
   @SuppressWarnings("unchecked")
-  public <Z> Target<Z> buildTarget(ImageView view, Class<Z> clazz) {
+  public <Z> ViewTarget<ImageView, Z> buildTarget(@NonNull ImageView view,
+      @NonNull Class<Z> clazz) {
     if (Bitmap.class.equals(clazz)) {
-      return (Target<Z>) new BitmapImageViewTarget(view);
+      return (ViewTarget<ImageView, Z>) new BitmapImageViewTarget(view);
     } else if (Drawable.class.isAssignableFrom(clazz)) {
-      return (Target<Z>) new DrawableImageViewTarget(view);
+      return (ViewTarget<ImageView, Z>) new DrawableImageViewTarget(view);
     } else {
       throw new IllegalArgumentException(
           "Unhandled class: " + clazz + ", try .as*(Class).transcode(ResourceTranscoder)");
diff --git a/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java b/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java
index 481523111..393b40cf1 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java
@@ -5,6 +5,8 @@
 import android.app.NotificationManager;
 import android.content.Context;
 import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.widget.RemoteViews;
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.util.Preconditions;
@@ -16,6 +18,8 @@
  * <p> Note - For cancellation to work correctly, you must pass in the same instance of this class
  * for every subsequent load. </p>
  */
+// Public API.
+@SuppressWarnings({"WeakerAccess", "unused"})
 public class NotificationTarget extends SimpleTarget<Bitmap> {
   private final RemoteViews remoteViews;
   private final Context context;
@@ -29,12 +33,12 @@
    * Notification in order to update it that uses {@link #SIZE_ORIGINAL} as the target width and
    * height.
    *
-   * @param context         Context to use in the AppWidgetManager initialization.
-   * @param viewId          The id of the ImageView view that will load the image.
-   * @param remoteViews     RemoteViews object which contains the ImageView that will load the
-   *                        bitmap.
-   * @param notification    The Notification object that we want to update.
-   * @param notificationId  The notificationId of the Notification that we want to load the Bitmap.
+   * @param context        Context to use in the AppWidgetManager initialization.
+   * @param viewId         The id of the ImageView view that will load the image.
+   * @param remoteViews    RemoteViews object which contains the ImageView that will load the
+   *                       bitmap.
+   * @param notification   The Notification object that we want to update.
+   * @param notificationId The notificationId of the Notification that we want to load the Bitmap.
    */
   public NotificationTarget(Context context,
       int viewId, RemoteViews remoteViews, Notification notification, int notificationId) {
@@ -58,7 +62,7 @@ public NotificationTarget(Context context,
   public NotificationTarget(Context context, int viewId, RemoteViews remoteViews,
       Notification notification, int notificationId, String notificationTag) {
     this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, notification, notificationId,
-      notificationTag);
+        notificationTag);
   }
 
   /**
@@ -98,11 +102,13 @@ public NotificationTarget(Context context, int width, int height, int viewId,
   private void update() {
     NotificationManager manager =
         (NotificationManager) this.context.getSystemService(Context.NOTIFICATION_SERVICE);
-    manager.notify(this.notificationTag, this.notificationId, this.notification);
+    Preconditions.checkNotNull(manager)
+        .notify(this.notificationTag, this.notificationId, this.notification);
   }
 
   @Override
-  public void onResourceReady(Bitmap resource, Transition<? super Bitmap> transition) {
+  public void onResourceReady(@NonNull Bitmap resource,
+      @Nullable Transition<? super Bitmap> transition) {
     this.remoteViews.setImageViewBitmap(this.viewId, resource);
     this.update();
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/PreloadTarget.java b/library/src/main/java/com/bumptech/glide/request/target/PreloadTarget.java
index 7b9f884a9..903522fc0 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/PreloadTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/PreloadTarget.java
@@ -1,7 +1,14 @@
 package com.bumptech.glide.request.target;
 
+import android.os.Handler;
+import android.os.Handler.Callback;
+import android.os.Looper;
+import android.os.Message;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.util.Synthetic;
 
 /**
  * A one time use {@link com.bumptech.glide.request.target.Target} class that loads a resource into
@@ -10,6 +17,17 @@
  * @param <Z> The type of resource that will be loaded into memory.
  */
 public final class PreloadTarget<Z> extends SimpleTarget<Z> {
+  private static final int MESSAGE_CLEAR = 1;
+  private static final Handler HANDLER = new Handler(Looper.getMainLooper(), new Callback() {
+    @Override
+    public boolean handleMessage(Message message) {
+      if (message.what == MESSAGE_CLEAR) {
+        ((PreloadTarget<?>) message.obj).clear();
+        return true;
+      }
+      return false;
+    }
+  });
 
   private final RequestManager requestManager;
 
@@ -30,7 +48,12 @@ private PreloadTarget(RequestManager requestManager, int width, int height) {
   }
 
   @Override
-  public void onResourceReady(Z resource, Transition<? super Z> transition) {
+  public void onResourceReady(@NonNull Z resource, @Nullable Transition<? super Z> transition) {
+    HANDLER.obtainMessage(MESSAGE_CLEAR, this).sendToTarget();
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic void clear() {
     requestManager.clear(this);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java b/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java
index fd1baf5b7..9d28c0bd0 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java
@@ -1,30 +1,72 @@
 package com.bumptech.glide.request.target;
 
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+import android.view.View;
 import com.bumptech.glide.util.Util;
 
 /**
- * A simple {@link com.bumptech.glide.request.target.Target} base class with default (usually noop)
+ * A simple {@link com.bumptech.glide.request.target.Target} base class with default (usually no-op)
  * implementations of non essential methods that allows the caller to specify an exact width/height.
  * Typically use cases look something like this:
+ *
  * <pre>
  * <code>
- * Glide.load("http://somefakeurl.com/fakeImage.jpeg")
- *      .asBitmap()
- *      .withFitCenter()
- *      .into(new SimpleTarget<Bitmap>(250, 250) {
+ * Target<Bitmap> target =
+ *     Glide.with(fragment)
+ *       .asBitmap()
+ *       .load("http://somefakeurl.com/fakeImage.jpeg")
+ *       .apply(fitCenterTransform())
+ *       .into(new SimpleTarget<Bitmap>(250, 250) {
  *
- *          {@literal @Override}
- *          public void onResourceReady(Bitmap resource, GlideAnimation<Bitmap> glideAnimation) {
- *              // Do something with bitmap here.
- *          }
+ *         {@literal @Override}
+ *         public void onResourceReady(Bitmap resource, Transition<? super Bitmap> transition) {
+ *           // Do something with bitmap here.
+ *         }
  *
- *      });
+ *       });
  * }
+ * // At some later point, clear the Target to release the resources, prevent load queues from
+ * // blowing out proportion, and to improve load times for future requests:
+ * Glide.with(fragment).clear(target);
  * </code>
  * </pre>
  *
+ * <p><em>Warning!</em> this class is extremely prone to mis-use. Use SimpleTarget only as a last
+ * resort. {@link ViewTarget} or a subclass of {@link ViewTarget} is almost always a better choice.
+ *
+ * <p><em>Don't forget to clear instances of this class!</em>. If you must use this class, keep in
+ * mind that unlike {@link ViewTarget} it is not safe to load into new instances of this class
+ * repeatedly if every instance updates the same underlying {@link View} or caller. If you need to
+ * load into the same {@link View} or caller repeatedly using this class, always retain a reference
+ * to the previous instance and either call {@link com.bumptech.glide.RequestManager#clear(Target)}
+ * on the old instance before starting a new load or you must re-use the old instance for the new
+ * load. Glide's {@link com.bumptech.glide.RequestBuilder#into(Target)} method returns the {@link
+ * Target} instance you provided to make retaining a reference to the {@link Target} as easy as
+ * possible. That said, you must wait until you're completely finished with the resource before
+ * calling {@link com.bumptech.glide.RequestManager#clear(Target)} and you should always null out
+ * references to any loaded resources in {@link Target#onLoadCleared(Drawable)}.
+ *
+ * <p>Always try to provide a size when using this class. Use {@link SimpleTarget#SimpleTarget(int,
+ * int)} whenever possible with values that are <em>not</em> {@link Target#SIZE_ORIGINAL}. Using
+ * {@link Target#SIZE_ORIGINAL} is unsafe if you're loading large images or are running your
+ * application on older or memory constrained devices because it can cause Glide to load very large
+ * images into memory. In some cases those images may throw {@link OutOfMemoryError} and in others
+ * they may exceed the texture limit for the device, which will prevent them from being rendered.
+ * Providing a valid size allows Glide to downsample large images, which can avoid issues with
+ * texture size or memory limitations. You don't have to worry about providing a size in most cases
+ * if you use {@link ViewTarget} so prefer {@link ViewTarget} over this class whenver possible.
+ *
+ * @see <a href="http://bumptech.github.io/glide/doc/targets.html">Glide's Target docs page</a>
  * @param <Z> The type of resource that this target will receive.
+ * @deprecated Use {@link CustomViewTarget} if loading the content into a view, the download API if
+ *     in the background
+ *     (http://bumptech.github.io/glide/doc/getting-started.html#background-threads), or a
+ *     {@link CustomTarget} for any specialized use-cases. Using BaseView is unsafe if the
+ *     user does not implement {@link #onLoadCleared}, resulting in recycled bitmaps being
+ *     referenced from the UI and hard to root-cause crashes.
  */
+@Deprecated
 public abstract class SimpleTarget<Z> extends BaseTarget<Z> {
   private final int width;
   private final int height;
@@ -33,6 +75,8 @@
    * Constructor for the target that uses {@link Target#SIZE_ORIGINAL} as the target width and
    * height.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public SimpleTarget() {
     this(SIZE_ORIGINAL, SIZE_ORIGINAL);
   }
@@ -44,6 +88,8 @@ public SimpleTarget() {
    * @param width  The width in pixels of the desired resource.
    * @param height The height in pixels of the desired resource.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public SimpleTarget(int width, int height) {
     this.width = width;
     this.height = height;
@@ -55,7 +101,7 @@ public SimpleTarget(int width, int height) {
    * @param cb {@inheritDoc}
    */
   @Override
-  public final void getSize(SizeReadyCallback cb) {
+  public final void getSize(@NonNull SizeReadyCallback cb) {
     if (!Util.isValidDimensions(width, height)) {
       throw new IllegalArgumentException(
           "Width and height must both be > 0 or Target#SIZE_ORIGINAL, but given" + " width: "
@@ -66,7 +112,7 @@ public final void getSize(SizeReadyCallback cb) {
   }
 
   @Override
-  public void removeCallback(SizeReadyCallback cb) {
+  public void removeCallback(@NonNull SizeReadyCallback cb) {
     // Do nothing, we never retain a reference to the callback.
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/Target.java b/library/src/main/java/com/bumptech/glide/request/target/Target.java
index dbdbc4779..502234774 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/Target.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/Target.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.request.target;
 
 import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import com.bumptech.glide.manager.LifecycleListener;
 import com.bumptech.glide.request.Request;
@@ -36,23 +37,19 @@
    * called. Loads can be paused and restarted due to lifecycle or connectivity events and each
    * restart may cause a call here.
    *
-   * <p>You must ensure that any current Drawable received in {@link #onResourceReady(Object,
-   * Transition)} is no longer displayed before redrawing the container (usually a View) or
-   * changing its visibility.
-   *
    * @param placeholder The placeholder drawable to optionally show, or null.
    */
   void onLoadStarted(@Nullable Drawable placeholder);
 
   /**
-   * A lifecycle callback that is called when a load fails.
+   * A <b>mandatory</b> lifecycle callback that is called when a load fails.
    *
-   * <p> Note - This may be called before {@link #onLoadStarted(android.graphics.drawable.Drawable)
-   * } if the model object is null.
+   * <p>Note - This may be called before {@link #onLoadStarted(android.graphics.drawable.Drawable) }
+   * if the model object is null.
    *
-   * <p>You must ensure that any current Drawable received in {@link #onResourceReady(Object,
-   * Transition)} is no longer displayed before redrawing the container (usually a View) or
-   * changing its visibility.
+   * <p>You <b>must</b> ensure that any current Drawable received in {@link #onResourceReady(Object,
+   * Transition)} is no longer used before redrawing the container (usually a View) or changing its
+   * visibility.
    *
    * @param errorDrawable The error drawable to optionally show, or null.
    */
@@ -63,14 +60,15 @@
    *
    * @param resource the loaded resource.
    */
-  void onResourceReady(R resource, Transition<? super R> transition);
+  void onResourceReady(@NonNull R resource, @Nullable Transition<? super R> transition);
 
   /**
-   * A lifecycle callback that is called when a load is cancelled and its resources are freed.
+   * A <b>mandatory</b> lifecycle callback that is called when a load is cancelled and its resources
+   * are freed.
    *
-   * <p>You must ensure that any current Drawable received in {@link #onResourceReady(Object,
-   * Transition)} is no longer displayed before redrawing the container (usually a View) or
-   * changing its visibility.
+   * <p>You <b>must</b> ensure that any current Drawable received in {@link #onResourceReady(Object,
+   * Transition)} is no longer used before redrawing the container (usually a View) or changing its
+   * visibility.
    *
    * @param placeholder The placeholder drawable to optionally show, or null.
    */
@@ -81,14 +79,14 @@
    *
    * @param cb The callback that must be called when the size of the target has been determined
    */
-  void getSize(SizeReadyCallback cb);
+  void getSize(@NonNull SizeReadyCallback cb);
 
   /**
    * Removes the given callback from the pending set if it's still retained.
    *
    * @param cb The callback to remove.
    */
-  void removeCallback(SizeReadyCallback cb);
+  void removeCallback(@NonNull SizeReadyCallback cb);
 
   /**
    * Sets the current request for this target to retain, should not be called outside of Glide.
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ThumbnailImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/ThumbnailImageViewTarget.java
index c3d658f9b..043d31daf 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ThumbnailImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ThumbnailImageViewTarget.java
@@ -20,12 +20,23 @@
  *
  * @param <T> The type of resource that will be displayed in the ImageView.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public abstract class ThumbnailImageViewTarget<T> extends ImageViewTarget<T> {
 
   public ThumbnailImageViewTarget(ImageView view) {
     super(view);
   }
 
+  /**
+   * @deprecated Use {@link #waitForLayout()} insetad.
+   */
+  @Deprecated
+  @SuppressWarnings({"deprecation"})
+  public ThumbnailImageViewTarget(ImageView view, boolean waitForLayout) {
+    super(view, waitForLayout);
+  }
+
   @Override
   protected void setResource(@Nullable T resource) {
     ViewGroup.LayoutParams layoutParams = view.getLayoutParams();
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
index 06ecefd40..9bc6d8b2e 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
@@ -1,11 +1,19 @@
 package com.bumptech.glide.request.target;
 
+import android.content.Context;
+import android.graphics.Point;
 import android.graphics.drawable.Drawable;
+import android.support.annotation.CallSuper;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 import android.util.Log;
+import android.view.Display;
 import android.view.View;
+import android.view.View.OnAttachStateChangeListener;
 import android.view.ViewGroup.LayoutParams;
 import android.view.ViewTreeObserver;
+import android.view.WindowManager;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
@@ -18,37 +26,182 @@
  * provides default implementations for most most methods and can determine the size of views using
  * a {@link android.view.ViewTreeObserver.OnDrawListener}.
  *
- * <p> To detect {@link View} reuse in {@link android.widget.ListView} or any {@link
+ * <p>To detect {@link View} reuse in {@link android.widget.ListView} or any {@link
  * android.view.ViewGroup} that reuses views, this class uses the {@link View#setTag(Object)} method
  * to store some metadata so that if a view is reused, any previous loads or resources from previous
- * loads can be cancelled or reused. </p>
+ * loads can be cancelled or reused.
  *
- * <p> Any calls to {@link View#setTag(Object)}} on a View given to this class will result in
+ * <p>Any calls to {@link View#setTag(Object)}} on a View given to this class will result in
  * excessive allocations and and/or {@link IllegalArgumentException}s. If you must call {@link
- * View#setTag(Object)} on a view, consider using {@link BaseTarget} or {@link SimpleTarget}
- * instead. </p>
+ * View#setTag(Object)} on a view, use {@link #setTagId(int)} to specify a custom tag for Glide to
+ * use.
  *
- * <p> Subclasses must call super in {@link #onLoadCleared(Drawable)} </p>
+ * <p>Subclasses must call super in {@link #onLoadCleared(Drawable)}
  *
  * @param <T> The specific subclass of view wrapped by this target.
  * @param <Z> The resource type this target will receive.
+ * @deprecated Use {@link CustomViewTarget}. Using this class is unsafe without implementing {@link
+ *     #onLoadCleared} and results in recycled bitmaps being referenced from the UI and hard to
+ *     root-cause crashes.
  */
+@Deprecated
 public abstract class ViewTarget<T extends View, Z> extends BaseTarget<Z> {
   private static final String TAG = "ViewTarget";
-  private static boolean isTagUsedAtLeastOnce = false;
-  @Nullable private static Integer tagId = null;
+  private static boolean isTagUsedAtLeastOnce;
+  @Nullable private static Integer tagId;
 
   protected final T view;
   private final SizeDeterminer sizeDeterminer;
+  @Nullable
+  private OnAttachStateChangeListener attachStateListener;
+  private boolean isClearedByUs;
+  private boolean isAttachStateListenerAdded;
+
 
-  public ViewTarget(T view) {
+  /**
+   * Constructor that defaults {@code waitForLayout} to {@code false}.
+   */
+  public ViewTarget(@NonNull T view) {
     this.view = Preconditions.checkNotNull(view);
     sizeDeterminer = new SizeDeterminer(view);
   }
 
+  /**
+   * @param waitForLayout If set to {@code true}, Glide will always wait for any pending layout pass
+   * before checking for the size a View. If set to {@code false} Glide will only wait for a pending
+   * layout pass if it's unable to resolve the size from layout parameters or an existing View size.
+   * Because setting this parameter to {@code true} forces Glide to wait for the layout pass to
+   * occur before starting the load, setting this parameter to {@code true} can cause flashing in
+   * some cases and should be used sparingly. If layout parameters are set to fixed sizes, they will
+   * still be used instead of the View's dimensions even if this parameter is set to {@code true}.
+   * This parameter is a fallback only.
+   *
+   * @deprecated Use {@link #waitForLayout()} instead.
+   */
+  @SuppressWarnings("WeakerAccess") // Public API
+  @Deprecated
+  public ViewTarget(@NonNull T view, boolean waitForLayout) {
+    this(view);
+    if (waitForLayout) {
+      waitForLayout();
+    }
+  }
+
+  /**
+   * Clears the {@link View}'s {@link Request} when the {@link View} is detached from its
+   * {@link android.view.Window} and restarts the {@link Request} when the {@link View} is
+   * re-attached from its {@link android.view.Window}.
+   *
+   * <p>This is an experimental API that may be removed in a future version.
+   *
+   * <p>Using this method can save memory by allowing Glide to more eagerly clear resources when
+   * transitioning screens or swapping adapters in scrolling views. However it also substantially
+   * increases the odds that images will not be in memory if users subsequently return to a screen
+   * where images were previously loaded. Whether or not this happens will depend on the number
+   * of images loaded in the new screen and the size of the memory cache. Increasing the size of
+   * the memory cache can improve this behavior but it largely negates the memory benefits of using
+   * this method.
+   *
+   * <p>Use this method with caution and measure your memory usage to ensure that it's actually
+   * improving your memory usage in the cases you care about.
+   */
+  // Public API.
+  @NonNull
+  @SuppressWarnings({"UnusedReturnValue", "WeakerAccess"})
+  public final ViewTarget<T, Z> clearOnDetach() {
+    if (attachStateListener != null) {
+      return this;
+    }
+    attachStateListener = new OnAttachStateChangeListener() {
+      @Override
+      public void onViewAttachedToWindow(View v) {
+        resumeMyRequest();
+      }
+
+      @Override
+      public void onViewDetachedFromWindow(View v) {
+        pauseMyRequest();
+      }
+    };
+    maybeAddAttachStateListener();
+    return this;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic void resumeMyRequest() {
+    Request request = getRequest();
+    if (request != null && request.isCleared()) {
+      request.begin();
+    }
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic void pauseMyRequest() {
+    Request request = getRequest();
+    // If the Request were cleared by the developer, it would be null here. The only way it's
+    // present is if the developer hasn't previously cleared this Target.
+    if (request != null) {
+      isClearedByUs = true;
+      request.clear();
+      isClearedByUs = false;
+    }
+  }
+
+  /**
+   * Indicates that Glide should always wait for any pending layout pass before checking
+   * for the size an {@link View}.
+   *
+   * <p>By default, Glide will only wait for a pending layout pass if it's unable to resolve the
+   * size from the {@link LayoutParams} or valid non-zero values for {@link View#getWidth()} and
+   * {@link View#getHeight()}.
+   *
+   * <p>Because calling this method forces Glide to wait for the layout pass to occur before
+   * starting loads, setting this parameter to {@code true} can cause Glide to asynchronous load
+   * an image even if it's in the memory cache. The load will happen asynchronously because Glide
+   * has to wait for a layout pass to occur, which won't necessarily happen in the same frame as
+   * when the image is requested. As a result, using this method can resulting in flashing in some
+   * cases and should be used sparingly.
+   *
+   * <p>If the {@link LayoutParams} of the wrapped {@link View} are set to fixed sizes, they will
+   * still be used instead of the {@link View}'s dimensions even if this method is called. This
+   * parameter is a fallback only.
+   */
+  @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
+  public final ViewTarget<T, Z> waitForLayout() {
+    sizeDeterminer.waitForLayout = true;
+    return this;
+  }
+
+  @CallSuper
+  @Override
+  public void onLoadStarted(@Nullable Drawable placeholder) {
+    super.onLoadStarted(placeholder);
+    maybeAddAttachStateListener();
+  }
+
+  private void maybeAddAttachStateListener() {
+    if (attachStateListener == null || isAttachStateListenerAdded) {
+      return;
+    }
+
+    view.addOnAttachStateChangeListener(attachStateListener);
+    isAttachStateListenerAdded = true;
+  }
+
+  private void maybeRemoveAttachStateListener() {
+    if (attachStateListener == null || !isAttachStateListenerAdded) {
+      return;
+    }
+
+    view.removeOnAttachStateChangeListener(attachStateListener);
+    isAttachStateListenerAdded = false;
+  }
+
   /**
    * Returns the wrapped {@link android.view.View}.
    */
+  @NonNull
   public T getView() {
     return view;
   }
@@ -62,20 +215,27 @@ public T getView() {
    *
    * @param cb {@inheritDoc}
    */
+  @CallSuper
   @Override
-  public void getSize(SizeReadyCallback cb) {
+  public void getSize(@NonNull SizeReadyCallback cb) {
     sizeDeterminer.getSize(cb);
   }
 
+  @CallSuper
   @Override
-  public void removeCallback(SizeReadyCallback cb) {
+  public void removeCallback(@NonNull SizeReadyCallback cb) {
     sizeDeterminer.removeCallback(cb);
   }
 
+  @CallSuper
   @Override
-  public void onLoadCleared(Drawable placeholder) {
+  public void onLoadCleared(@Nullable Drawable placeholder) {
     super.onLoadCleared(placeholder);
     sizeDeterminer.clearCallbacksAndListener();
+
+    if (!isClearedByUs) {
+      maybeRemoveAttachStateListener();
+    }
   }
 
   /**
@@ -156,26 +316,46 @@ private Object getTag() {
    *
    * @param tagId The android resource to use.
    */
+  // Public API.
+  @SuppressWarnings("unused")
   public static void setTagId(int tagId) {
-      if (ViewTarget.tagId != null || isTagUsedAtLeastOnce) {
-          throw new IllegalArgumentException("You cannot set the tag id more than once or change"
-              + " the tag id after the first request has been made");
-      }
-      ViewTarget.tagId = tagId;
+    if (ViewTarget.tagId != null || isTagUsedAtLeastOnce) {
+      throw new IllegalArgumentException("You cannot set the tag id more than once or change"
+          + " the tag id after the first request has been made");
+    }
+    ViewTarget.tagId = tagId;
   }
 
-  private static class SizeDeterminer {
+  @VisibleForTesting
+  static final class SizeDeterminer {
     // Some negative sizes (Target.SIZE_ORIGINAL) are valid, 0 is never valid.
     private static final int PENDING_SIZE = 0;
+    @VisibleForTesting
+    @Nullable
+    static Integer maxDisplayLength;
     private final View view;
     private final List<SizeReadyCallback> cbs = new ArrayList<>();
+    @Synthetic boolean waitForLayout;
 
     @Nullable private SizeDeterminerLayoutListener layoutListener;
 
-    SizeDeterminer(View view) {
+    SizeDeterminer(@NonNull View view) {
       this.view = view;
     }
 
+    // Use the maximum to avoid depending on the device's current orientation.
+    private static int getMaxDisplayLength(@NonNull Context context) {
+      if (maxDisplayLength == null) {
+        WindowManager windowManager =
+            (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
+        Display display = Preconditions.checkNotNull(windowManager).getDefaultDisplay();
+        Point displayDimensions = new Point();
+        display.getSize(displayDimensions);
+        maxDisplayLength = Math.max(displayDimensions.x, displayDimensions.y);
+      }
+      return maxDisplayLength;
+    }
+
     private void notifyCbs(int width, int height) {
       // One or more callbacks may trigger the removal of one or more additional callbacks, so we
       // need a copy of the list to avoid a concurrent modification exception. One place this
@@ -202,7 +382,7 @@ void checkCurrentDimens() {
       clearCallbacksAndListener();
     }
 
-    void getSize(SizeReadyCallback cb) {
+    void getSize(@NonNull SizeReadyCallback cb) {
       int currentWidth = getTargetWidth();
       int currentHeight = getTargetHeight();
       if (isViewStateAndSizeValid(currentWidth, currentHeight)) {
@@ -228,16 +408,16 @@ void getSize(SizeReadyCallback cb) {
      *
      * <p>See #2237.
      */
-    void removeCallback(SizeReadyCallback cb) {
+    void removeCallback(@NonNull SizeReadyCallback cb) {
       cbs.remove(cb);
     }
 
     void clearCallbacksAndListener() {
-      // Keep a reference to the layout listener and remove it here
+      // Keep a reference to the layout attachStateListener and remove it here
       // rather than having the observer remove itself because the observer
-      // we add the listener to will be almost immediately merged into
+      // we add the attachStateListener to will be almost immediately merged into
       // another observer and will therefore never be alive. If we instead
-      // keep a reference to the listener and remove it here, we get the
+      // keep a reference to the attachStateListener and remove it here, we get the
       // current view tree observer and should succeed.
       ViewTreeObserver observer = view.getViewTreeObserver();
       if (observer.isAlive()) {
@@ -248,21 +428,7 @@ void clearCallbacksAndListener() {
     }
 
     private boolean isViewStateAndSizeValid(int width, int height) {
-      return isViewStateValid() && isSizeValid(width) && isSizeValid(height);
-    }
-
-    private boolean isViewStateValid() {
-      // We consider the view state as valid if the view has
-      // non-null layout params and a non-zero layout width and height.
-      if (view.getLayoutParams() != null
-          && view.getLayoutParams().width > 0
-          && view.getLayoutParams().height > 0) {
-        return true;
-      }
-
-      // Avoid using isLaidOut because it appears to be false after a View is re-attached to a
-      // RecyclerView if the View's size before and after the attach are the same. See #1981.
-      return !view.isLayoutRequested();
+      return isDimensionValid(width) && isDimensionValid(height);
     }
 
     private int getTargetHeight() {
@@ -280,40 +446,78 @@ private int getTargetWidth() {
     }
 
     private int getTargetDimen(int viewSize, int paramSize, int paddingSize) {
-      int adjustedViewSize = viewSize - paddingSize;
-      if (isSizeValid(adjustedViewSize)) {
-        return adjustedViewSize;
+      // We consider the View state as valid if the View has non-null layout params and a non-zero
+      // layout params width and height. This is imperfect. We're making an assumption that View
+      // parents will obey their child's layout parameters, which isn't always the case.
+      int adjustedParamSize = paramSize - paddingSize;
+      if (adjustedParamSize > 0) {
+        return adjustedParamSize;
       }
 
-      if (paramSize == PENDING_SIZE) {
+      // Since we always prefer layout parameters with fixed sizes, even if waitForLayout is true,
+      // we might as well ignore it and just return the layout parameters above if we have them.
+      // Otherwise we should wait for a layout pass before checking the View's dimensions.
+      if (waitForLayout && view.isLayoutRequested()) {
         return PENDING_SIZE;
       }
 
-      if (paramSize == LayoutParams.WRAP_CONTENT) {
-        return SIZE_ORIGINAL;
-      } else if (paramSize > 0) {
-        return paramSize - paddingSize;
-      } else {
-        return PENDING_SIZE;
+      // We also consider the View state valid if the View has a non-zero width and height. This
+      // means that the View has gone through at least one layout pass. It does not mean the Views
+      // width and height are from the current layout pass. For example, if a View is re-used in
+      // RecyclerView or ListView, this width/height may be from an old position. In some cases
+      // the dimensions of the View at the old position may be different than the dimensions of the
+      // View in the new position because the LayoutManager/ViewParent can arbitrarily decide to
+      // change them. Nevertheless, in most cases this should be a reasonable choice.
+      int adjustedViewSize = viewSize - paddingSize;
+      if (adjustedViewSize > 0) {
+        return adjustedViewSize;
       }
+
+      // Finally we consider the view valid if the layout parameter size is set to wrap_content.
+      // It's difficult for Glide to figure out what to do here. Although Target.SIZE_ORIGINAL is a
+      // coherent choice, it's extremely dangerous because original images may be much too large to
+      // fit in memory or so large that only a couple can fit in memory, causing OOMs. If users want
+      // the original image, they can always use .override(Target.SIZE_ORIGINAL). Since wrap_content
+      // may never resolve to a real size unless we load something, we aim for a square whose length
+      // is the largest screen size. That way we're loading something and that something has some
+      // hope of being downsampled to a size that the device can support. We also log a warning that
+      // tries to explain what Glide is doing and why some alternatives are preferable.
+      // Since WRAP_CONTENT is sometimes used as a default layout parameter, we always wait for
+      // layout to complete before using this fallback parameter (ConstraintLayout among others).
+      if (!view.isLayoutRequested() && paramSize == LayoutParams.WRAP_CONTENT) {
+        if (Log.isLoggable(TAG, Log.INFO)) {
+          Log.i(TAG, "Glide treats LayoutParams.WRAP_CONTENT as a request for an image the size of"
+              + " this device's screen dimensions. If you want to load the original image and are"
+              + " ok with the corresponding memory cost and OOMs (depending on the input size), use"
+              + " .override(Target.SIZE_ORIGINAL). Otherwise, use LayoutParams.MATCH_PARENT, set"
+              + " layout_width and layout_height to fixed dimension, or use .override() with fixed"
+              + " dimensions.");
+        }
+        return getMaxDisplayLength(view.getContext());
+      }
+
+      // If the layout parameters are < padding, the view size is < padding, or the layout
+      // parameters are set to match_parent or wrap_content and no layout has occurred, we should
+      // wait for layout and repeat.
+      return PENDING_SIZE;
     }
 
-    private boolean isSizeValid(int size) {
+    private boolean isDimensionValid(int size) {
       return size > 0 || size == SIZE_ORIGINAL;
     }
 
-    private static class SizeDeterminerLayoutListener implements ViewTreeObserver
-        .OnPreDrawListener {
+    private static final class SizeDeterminerLayoutListener
+        implements ViewTreeObserver.OnPreDrawListener {
       private final WeakReference<SizeDeterminer> sizeDeterminerRef;
 
-      SizeDeterminerLayoutListener(SizeDeterminer sizeDeterminer) {
+      SizeDeterminerLayoutListener(@NonNull SizeDeterminer sizeDeterminer) {
         sizeDeterminerRef = new WeakReference<>(sizeDeterminer);
       }
 
       @Override
       public boolean onPreDraw() {
         if (Log.isLoggable(TAG, Log.VERBOSE)) {
-          Log.v(TAG, "OnGlobalLayoutListener called listener=" + this);
+          Log.v(TAG, "OnGlobalLayoutListener called attachStateListener=" + this);
         }
         SizeDeterminer sizeDeterminer = sizeDeterminerRef.get();
         if (sizeDeterminer != null) {
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/BitmapContainerTransitionFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/BitmapContainerTransitionFactory.java
index 012d2009b..8bec74e45 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/BitmapContainerTransitionFactory.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/BitmapContainerTransitionFactory.java
@@ -17,6 +17,8 @@
 public abstract class BitmapContainerTransitionFactory<R> implements TransitionFactory<R> {
   private final TransitionFactory<Drawable> realFactory;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public BitmapContainerTransitionFactory(TransitionFactory<Drawable> realFactory) {
     this.realFactory = realFactory;
   }
@@ -37,10 +39,10 @@ public BitmapContainerTransitionFactory(TransitionFactory<Drawable> realFactory)
    */
   protected abstract Bitmap getBitmap(R current);
 
-  private class BitmapGlideAnimation implements Transition<R> {
+  private final class BitmapGlideAnimation implements Transition<R> {
     private final Transition<Drawable> transition;
 
-    public BitmapGlideAnimation(Transition<Drawable> transition) {
+    BitmapGlideAnimation(Transition<Drawable> transition) {
       this.transition = transition;
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java
index 3aeab1922..0a8da3056 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java
@@ -13,6 +13,8 @@
  * user typically does not expect to see a transition. As a result, when the resource is loaded from
  * the memory cache this factory produces an {@link NoTransition}.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public class DrawableCrossFadeFactory implements TransitionFactory<Drawable> {
   private final int duration;
   private final boolean isCrossFadeEnabled;
@@ -39,9 +41,10 @@ protected DrawableCrossFadeFactory(int duration, boolean isCrossFadeEnabled) {
   /**
    * A Builder for {@link DrawableCrossFadeFactory}.
    */
+  @SuppressWarnings("unused")
   public static class Builder {
     private static final int DEFAULT_DURATION_MS = 300;
-    private int durationMillis;
+    private final int durationMillis;
     private boolean isCrossFadeEnabled;
 
     public Builder() {
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java
index cfdf30b31..730d84f30 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java
@@ -25,6 +25,8 @@
    *                         alpha at 100. See
    *                         {@link TransitionDrawable#setCrossFadeEnabled(boolean)}.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public DrawableCrossFadeTransition(int duration,
       boolean isCrossFadeEnabled) {
     this.duration = duration;
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java b/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java
index d5a1c1e33..1ef48eb2b 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java
@@ -10,7 +10,7 @@
  * {@link com.bumptech.glide.request.target.Target}.
  */
 public class NoTransition<R> implements Transition<R> {
-  @Synthetic static final NoTransition<?> NO_ANIMATION = new NoTransition<Object>();
+  @Synthetic static final NoTransition<?> NO_ANIMATION = new NoTransition<>();
   @SuppressWarnings("rawtypes")
   private static final TransitionFactory<?> NO_ANIMATION_FACTORY = new NoAnimationFactory();
 
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/ViewAnimationFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/ViewAnimationFactory.java
index 661c27715..e5a2cec05 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/ViewAnimationFactory.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/ViewAnimationFactory.java
@@ -14,6 +14,8 @@
   private final ViewTransition.ViewTransitionAnimationFactory viewTransitionAnimationFactory;
   private Transition<R> transition;
 
+  // Public API.
+  @SuppressWarnings("unused")
   public ViewAnimationFactory(Animation animation) {
     this(new ConcreteViewTransitionAnimationFactory(animation));
   }
@@ -52,7 +54,7 @@ public ViewAnimationFactory(int animationId) {
       .ViewTransitionAnimationFactory {
     private final Animation animation;
 
-    public ConcreteViewTransitionAnimationFactory(Animation animation) {
+    ConcreteViewTransitionAnimationFactory(Animation animation) {
       this.animation = animation;
     }
 
@@ -66,7 +68,7 @@ public Animation build(Context context) {
       .ViewTransitionAnimationFactory {
     private final int animationId;
 
-    public ResourceViewTransitionAnimationFactory(int animationId) {
+    ResourceViewTransitionAnimationFactory(int animationId) {
       this.animationId = animationId;
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/ViewPropertyTransition.java b/library/src/main/java/com/bumptech/glide/request/transition/ViewPropertyTransition.java
index e863a83be..45e75f760 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/ViewPropertyTransition.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/ViewPropertyTransition.java
@@ -19,6 +19,8 @@
    *
    * @param animator The animator to use.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public ViewPropertyTransition(Animator animator) {
     this.animator = animator;
   }
diff --git a/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java b/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java
index 974dc0abd..21d86931d 100644
--- a/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java
+++ b/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java
@@ -3,23 +3,29 @@
 import android.content.Context;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
+import android.util.Log;
 import com.bumptech.glide.load.Key;
 import java.util.UUID;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 
 /**
  * A utility class for obtaining a {@link com.bumptech.glide.load.Key} signature containing the
  * application version name using {@link android.content.pm.PackageInfo#versionCode}.
  */
 public final class ApplicationVersionSignature {
-  private static final ConcurrentHashMap<String, Key> PACKAGE_NAME_TO_KEY =
-      new ConcurrentHashMap<>();
+  private static final String TAG = "AppVersionSignature";
+  private static final ConcurrentMap<String, Key> PACKAGE_NAME_TO_KEY = new ConcurrentHashMap<>();
 
   /**
    * Returns the signature {@link com.bumptech.glide.load.Key} for version code of the Application
    * of the given Context.
    */
-  public static Key obtain(Context context) {
+  @NonNull
+  public static Key obtain(@NonNull Context context) {
     String packageName = context.getPackageName();
     Key result = PACKAGE_NAME_TO_KEY.get(packageName);
     if (result == null) {
@@ -34,26 +40,37 @@ public static Key obtain(Context context) {
     return result;
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static void reset() {
     PACKAGE_NAME_TO_KEY.clear();
   }
 
-  private static Key obtainVersionSignature(Context context) {
-    PackageInfo pInfo = null;
-    try {
-      pInfo = context.getPackageManager().getPackageInfo(context.getPackageName(), 0);
-    } catch (PackageManager.NameNotFoundException e) {
-      // Should never happen.
-      e.printStackTrace();
-    }
-    final String versionCode;
-    if (pInfo != null) {
-      versionCode = String.valueOf(pInfo.versionCode);
+  @NonNull
+  private static Key obtainVersionSignature(@NonNull Context context) {
+    PackageInfo packageInfo = getPackageInfo(context);
+    String versionCode = getVersionCode(packageInfo);
+    return new ObjectKey(versionCode);
+  }
+
+  @NonNull
+  private static String getVersionCode(@Nullable PackageInfo packageInfo) {
+    String versionCode;
+    if (packageInfo != null) {
+      versionCode = String.valueOf(packageInfo.versionCode);
     } else {
       versionCode = UUID.randomUUID().toString();
     }
-    return new ObjectKey(versionCode);
+    return versionCode;
+  }
+
+  @Nullable
+  private static PackageInfo getPackageInfo(@NonNull Context context) {
+    try {
+      return context.getPackageManager().getPackageInfo(context.getPackageName(), 0);
+    } catch (PackageManager.NameNotFoundException e) {
+      Log.e(TAG, "Cannot resolve info for" + context.getPackageName(), e);
+      return null;
+    }
   }
 
   private ApplicationVersionSignature() {
diff --git a/library/src/main/java/com/bumptech/glide/signature/EmptySignature.java b/library/src/main/java/com/bumptech/glide/signature/EmptySignature.java
index 93f572c0f..2763433aa 100644
--- a/library/src/main/java/com/bumptech/glide/signature/EmptySignature.java
+++ b/library/src/main/java/com/bumptech/glide/signature/EmptySignature.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.signature;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Key;
 import java.security.MessageDigest;
 
@@ -9,6 +10,7 @@
 public final class EmptySignature implements Key {
   private static final EmptySignature EMPTY_KEY = new EmptySignature();
 
+  @NonNull
   public static EmptySignature obtain() {
     return EMPTY_KEY;
   }
@@ -23,7 +25,7 @@ public String toString() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     // Do nothing.
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java b/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java
index e14e1a573..bb0e06b6e 100644
--- a/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java
+++ b/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java
@@ -1,7 +1,8 @@
 package com.bumptech.glide.signature;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.load.Key;
-import com.bumptech.glide.util.Util;
 import java.nio.ByteBuffer;
 import java.security.MessageDigest;
 
@@ -10,7 +11,7 @@
  * media store files like edits, rotations, and temporary file replacement.
  */
 public class MediaStoreSignature implements Key {
-  private final String mimeType;
+  @NonNull private final String mimeType;
   private final long dateModified;
   private final int orientation;
 
@@ -26,8 +27,8 @@
    * @param orientation  The orientation of the media store media. Ok to default to 0. See {@link
    *                     android.provider.MediaStore.Images.ImageColumns#ORIENTATION}.
    */
-  public MediaStoreSignature(String mimeType, long dateModified, int orientation) {
-    this.mimeType = mimeType;
+  public MediaStoreSignature(@Nullable String mimeType, long dateModified, int orientation) {
+    this.mimeType = mimeType == null ? "" : mimeType;
     this.dateModified = dateModified;
     this.orientation = orientation;
   }
@@ -50,7 +51,7 @@ public boolean equals(Object o) {
     if (orientation != that.orientation) {
       return false;
     }
-    if (!Util.bothNullOrEqual(mimeType, that.mimeType)) {
+    if (!mimeType.equals(that.mimeType)) {
       return false;
     }
     return true;
@@ -58,14 +59,14 @@ public boolean equals(Object o) {
 
   @Override
   public int hashCode() {
-    int result = mimeType != null ? mimeType.hashCode() : 0;
+    int result = mimeType.hashCode();
     result = 31 * result + (int) (dateModified ^ (dateModified >>> 32));
     result = 31 * result + orientation;
     return result;
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     byte[] data = ByteBuffer.allocate(12).putLong(dateModified).putInt(orientation).array();
     messageDigest.update(data);
     messageDigest.update(mimeType.getBytes(CHARSET));
diff --git a/library/src/main/java/com/bumptech/glide/signature/ObjectKey.java b/library/src/main/java/com/bumptech/glide/signature/ObjectKey.java
index 50ccc9f3f..ed3ea19e8 100644
--- a/library/src/main/java/com/bumptech/glide/signature/ObjectKey.java
+++ b/library/src/main/java/com/bumptech/glide/signature/ObjectKey.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.signature;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.util.Preconditions;
 import java.security.MessageDigest;
@@ -16,7 +17,7 @@
 public final class ObjectKey implements Key {
   private final Object object;
 
-  public ObjectKey(Object object) {
+  public ObjectKey(@NonNull Object object) {
     this.object = Preconditions.checkNotNull(object);
   }
 
@@ -42,7 +43,7 @@ public int hashCode() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     messageDigest.update(object.toString().getBytes(CHARSET));
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java b/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
index fca34c71a..c1e11a194 100644
--- a/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
+++ b/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.util;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.IOException;
@@ -13,6 +15,7 @@
 /**
  * Utilities for interacting with {@link java.nio.ByteBuffer}s.
  */
+@SuppressWarnings({"unused", "WeakerAccess"}) // Public API
 public final class ByteBufferUtil {
   // 16 Kb
   private static final int BUFFER_SIZE = 16384;
@@ -22,7 +25,8 @@ private ByteBufferUtil() {
     // Utility class.
   }
 
-  public static ByteBuffer fromFile(File file) throws IOException {
+  @NonNull
+  public static ByteBuffer fromFile(@NonNull File file) throws IOException {
     RandomAccessFile raf = null;
     FileChannel channel = null;
     try {
@@ -31,6 +35,11 @@ public static ByteBuffer fromFile(File file) throws IOException {
       if (fileLength > Integer.MAX_VALUE) {
         throw new IOException("File too large to map into memory");
       }
+      // See b/67710449.
+      if (fileLength == 0) {
+        throw new IOException("File unsuitable for memory mapping");
+      }
+
       raf = new RandomAccessFile(file, "r");
       channel = raf.getChannel();
       return channel.map(FileChannel.MapMode.READ_ONLY, 0, fileLength).load();
@@ -52,7 +61,7 @@ public static ByteBuffer fromFile(File file) throws IOException {
     }
   }
 
-  public static void toFile(ByteBuffer buffer, File file) throws IOException {
+  public static void toFile(@NonNull ByteBuffer buffer, @NonNull File file) throws IOException {
     buffer.position(0);
     RandomAccessFile raf = null;
     FileChannel channel = null;
@@ -81,7 +90,8 @@ public static void toFile(ByteBuffer buffer, File file) throws IOException {
     }
   }
 
-  public static void toStream(ByteBuffer byteBuffer, OutputStream os) throws IOException {
+  public static void toStream(@NonNull ByteBuffer byteBuffer,
+      @NonNull OutputStream os) throws IOException {
     SafeArray safeArray = getSafeArray(byteBuffer);
     if (safeArray != null) {
       os.write(safeArray.data, safeArray.offset, safeArray.offset + safeArray.limit);
@@ -101,7 +111,10 @@ public static void toStream(ByteBuffer byteBuffer, OutputStream os) throws IOExc
     }
   }
 
-  public static byte[] toBytes(ByteBuffer byteBuffer) {
+  // We check the appropriate offsets, so this is a spurious warning.
+  @SuppressWarnings("ByteBufferBackingArray")
+  @NonNull
+  public static byte[] toBytes(@NonNull ByteBuffer byteBuffer) {
     final byte[] result;
     SafeArray safeArray = getSafeArray(byteBuffer);
     if (safeArray != null && safeArray.offset == 0 && safeArray.limit == safeArray.data.length) {
@@ -115,11 +128,13 @@ public static void toStream(ByteBuffer byteBuffer, OutputStream os) throws IOExc
     return result;
   }
 
-  public static InputStream toStream(ByteBuffer buffer) {
+  @NonNull
+  public static InputStream toStream(@NonNull ByteBuffer buffer) {
     return new ByteBufferStream(buffer);
   }
 
-  public static ByteBuffer fromStream(InputStream stream) throws IOException {
+  @NonNull
+  public static ByteBuffer fromStream(@NonNull InputStream stream) throws IOException {
     ByteArrayOutputStream outStream = new ByteArrayOutputStream(BUFFER_SIZE);
 
     byte[] buffer = BUFFER_REF.getAndSet(null);
@@ -127,7 +142,7 @@ public static ByteBuffer fromStream(InputStream stream) throws IOException {
       buffer = new byte[BUFFER_SIZE];
     }
 
-    int n = -1;
+    int n;
     while ((n = stream.read(buffer)) >= 0) {
       outStream.write(buffer, 0, n);
     }
@@ -140,7 +155,8 @@ public static ByteBuffer fromStream(InputStream stream) throws IOException {
     return (ByteBuffer) ByteBuffer.allocateDirect(bytes.length).put(bytes).position(0);
   }
 
-  private static SafeArray getSafeArray(ByteBuffer byteBuffer) {
+  @Nullable
+  private static SafeArray getSafeArray(@NonNull ByteBuffer byteBuffer) {
     if (!byteBuffer.isReadOnly() && byteBuffer.hasArray()) {
       return new SafeArray(byteBuffer.array(), byteBuffer.arrayOffset(), byteBuffer.limit());
     }
@@ -152,7 +168,9 @@ private static SafeArray getSafeArray(ByteBuffer byteBuffer) {
     @Synthetic final int limit;
     @Synthetic final byte[] data;
 
-    public SafeArray(byte[] data, int offset, int limit) {
+    // PMD.ArrayIsStoredDirectly Copying would be prohibitively expensive and/or lead to OOMs.
+    @SuppressWarnings("PMD.ArrayIsStoredDirectly")
+    SafeArray(@NonNull byte[] data, int offset, int limit) {
       this.data = data;
       this.offset = offset;
       this.limit = limit;
@@ -161,20 +179,20 @@ public SafeArray(byte[] data, int offset, int limit) {
 
   private static class ByteBufferStream extends InputStream {
     private static final int UNSET = -1;
-    private final ByteBuffer byteBuffer;
+    @NonNull private final ByteBuffer byteBuffer;
     private int markPos = UNSET;
 
-    public ByteBufferStream(ByteBuffer byteBuffer) {
+    ByteBufferStream(@NonNull ByteBuffer byteBuffer) {
       this.byteBuffer = byteBuffer;
     }
 
     @Override
-    public int available() throws IOException {
+    public int available() {
       return byteBuffer.remaining();
     }
 
     @Override
-    public int read() throws IOException {
+    public int read() {
       if (!byteBuffer.hasRemaining()) {
         return -1;
       }
@@ -182,7 +200,7 @@ public int read() throws IOException {
     }
 
     @Override
-    public synchronized void mark(int readlimit) {
+    public synchronized void mark(int readLimit) {
       markPos = byteBuffer.position();
     }
 
@@ -192,7 +210,7 @@ public boolean markSupported() {
     }
 
     @Override
-    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
+    public int read(@NonNull byte[] buffer, int byteOffset, int byteCount) throws IOException {
       if (!byteBuffer.hasRemaining()) {
         return -1;
       }
diff --git a/library/src/main/java/com/bumptech/glide/util/CachedHashCodeArrayMap.java b/library/src/main/java/com/bumptech/glide/util/CachedHashCodeArrayMap.java
new file mode 100644
index 000000000..ff9573a84
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/util/CachedHashCodeArrayMap.java
@@ -0,0 +1,56 @@
+package com.bumptech.glide.util;
+
+import android.support.v4.util.ArrayMap;
+import android.support.v4.util.SimpleArrayMap;
+
+/**
+ * An {@link ArrayMap} that caches its hashCode to support efficient lookup.
+ *
+ * @param <K> the key type.
+ * @param <V> the value type.
+ */
+// We're overriding hashcode, but not in a way that changes the output, so we don't need to
+// override equals.
+@SuppressWarnings("PMD.OverrideBothEqualsAndHashcode")
+public final class CachedHashCodeArrayMap<K, V> extends ArrayMap<K, V> {
+
+  private int hashCode;
+
+  @Override
+  public void clear() {
+    hashCode = 0;
+    super.clear();
+  }
+
+  @Override
+  public V setValueAt(int index, V value) {
+    hashCode = 0;
+    return super.setValueAt(index, value);
+  }
+
+  @Override
+  public V put(K key, V value) {
+    hashCode = 0;
+    return super.put(key, value);
+  }
+
+  @Override
+  public void putAll(SimpleArrayMap<? extends K, ? extends V> simpleArrayMap) {
+    hashCode = 0;
+    super.putAll(simpleArrayMap);
+  }
+
+  @Override
+  public V removeAt(int index) {
+    hashCode = 0;
+    return super.removeAt(index);
+  }
+
+  @Override
+  public int hashCode() {
+    if (hashCode == 0) {
+      hashCode = super.hashCode();
+    }
+    return hashCode;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java b/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java
index 0f4803ace..2b0283e03 100644
--- a/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java
+++ b/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.util;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.text.TextUtils;
 import android.util.Log;
 import java.io.FilterInputStream;
@@ -17,15 +19,18 @@
   private final long contentLength;
   private int readSoFar;
 
-  public static InputStream obtain(InputStream other, String contentLengthHeader) {
+  @NonNull
+  public static InputStream obtain(@NonNull InputStream other,
+      @Nullable String contentLengthHeader) {
     return obtain(other, parseContentLength(contentLengthHeader));
   }
 
-  public static InputStream obtain(InputStream other, long contentLength) {
+  @NonNull
+  public static InputStream obtain(@NonNull InputStream other, long contentLength) {
     return new ContentLengthInputStream(other, contentLength);
   }
 
-  private static int parseContentLength(String contentLengthHeader) {
+  private static int parseContentLength(@Nullable String contentLengthHeader) {
     int result = UNKNOWN;
     if (!TextUtils.isEmpty(contentLengthHeader)) {
       try {
@@ -39,7 +44,7 @@ private static int parseContentLength(String contentLengthHeader) {
     return result;
   }
 
-  ContentLengthInputStream(InputStream in, long contentLength) {
+  private ContentLengthInputStream(@NonNull InputStream in, long contentLength) {
     super(in);
     this.contentLength = contentLength;
   }
@@ -62,7 +67,8 @@ public int read(byte[] buffer) throws IOException {
   }
 
   @Override
-  public synchronized int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
+  public synchronized int read(byte[] buffer, int byteOffset, int byteCount)
+      throws IOException {
     return checkReadSoFarOrThrow(super.read(buffer, byteOffset, byteCount));
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/util/ExceptionCatchingInputStream.java b/library/src/main/java/com/bumptech/glide/util/ExceptionCatchingInputStream.java
index c64b8572b..3f5b05fb0 100644
--- a/library/src/main/java/com/bumptech/glide/util/ExceptionCatchingInputStream.java
+++ b/library/src/main/java/com/bumptech/glide/util/ExceptionCatchingInputStream.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.util;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.Queue;
@@ -19,7 +21,8 @@
   private InputStream wrapped;
   private IOException exception;
 
-  public static ExceptionCatchingInputStream obtain(InputStream toWrap) {
+  @NonNull
+  public static ExceptionCatchingInputStream obtain(@NonNull InputStream toWrap) {
     ExceptionCatchingInputStream result;
     synchronized (QUEUE) {
       result = QUEUE.poll();
@@ -42,7 +45,7 @@ static void clearQueue() {
     // Do nothing.
   }
 
-  void setInputStream(InputStream toWrap) {
+  void setInputStream(@NonNull InputStream toWrap) {
     wrapped = toWrap;
   }
 
@@ -57,8 +60,8 @@ public void close() throws IOException {
   }
 
   @Override
-  public void mark(int readlimit) {
-    wrapped.mark(readlimit);
+  public void mark(int readLimit) {
+    wrapped.mark(readLimit);
   }
 
   @Override
@@ -67,7 +70,7 @@ public boolean markSupported() {
   }
 
   @Override
-  public int read(byte[] buffer) throws IOException {
+  public int read(byte[] buffer) {
     int read;
     try {
       read = wrapped.read(buffer);
@@ -79,7 +82,7 @@ public int read(byte[] buffer) throws IOException {
   }
 
   @Override
-  public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
+  public int read(byte[] buffer, int byteOffset, int byteCount) {
     int read;
     try {
       read = wrapped.read(buffer, byteOffset, byteCount);
@@ -96,7 +99,7 @@ public synchronized void reset() throws IOException {
   }
 
   @Override
-  public long skip(long byteCount) throws IOException {
+  public long skip(long byteCount) {
     long skipped;
     try {
       skipped = wrapped.skip(byteCount);
@@ -108,7 +111,7 @@ public long skip(long byteCount) throws IOException {
   }
 
   @Override
-  public int read() throws IOException {
+  public int read() {
     int result;
     try {
       result = wrapped.read();
@@ -119,6 +122,7 @@ public int read() throws IOException {
     return result;
   }
 
+  @Nullable
   public IOException getException() {
     return exception;
   }
diff --git a/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java b/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java
index b6c9e40d4..08b7ed3ba 100644
--- a/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java
+++ b/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java
@@ -1,7 +1,8 @@
 package com.bumptech.glide.util;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.ListPreloader;
-import java.util.Arrays;
 
 /**
  * A {@link com.bumptech.glide.ListPreloader.PreloadSizeProvider} with a fixed width and height.
@@ -22,8 +23,12 @@ public FixedPreloadSizeProvider(int width, int height) {
     this.size = new int[] { width, height };
   }
 
+  @Nullable
   @Override
-  public int[] getPreloadSize(T item, int adapterPosition, int itemPosition) {
-    return Arrays.copyOf(this.size, this.size.length);
+  // It's better to take on the risk that callers may mutate the array when there isn't any reason
+  // for them to do so than it the performance overhead of copying the array with every call.
+  @SuppressWarnings("PMD.MethodReturnsInternalArray")
+  public int[] getPreloadSize(@NonNull T item, int adapterPosition, int itemPosition) {
+    return size;
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/util/LogTime.java b/library/src/main/java/com/bumptech/glide/util/LogTime.java
index 834fc161d..58ddd6269 100644
--- a/library/src/main/java/com/bumptech/glide/util/LogTime.java
+++ b/library/src/main/java/com/bumptech/glide/util/LogTime.java
@@ -9,7 +9,7 @@
  */
 public final class LogTime {
   private static final double MILLIS_MULTIPLIER =
-      Build.VERSION_CODES.JELLY_BEAN_MR1 <= Build.VERSION.SDK_INT ? 1d / Math.pow(10, 6) : 1d;
+      Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1 ? 1d / Math.pow(10, 6) : 1d;
 
   private LogTime() {
     // Utility class.
@@ -21,10 +21,10 @@ private LogTime() {
    */
   @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
   public static long getLogTime() {
-    if (Build.VERSION_CODES.JELLY_BEAN_MR1 <= Build.VERSION.SDK_INT) {
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
       return SystemClock.elapsedRealtimeNanos();
     } else {
-      return System.currentTimeMillis();
+      return SystemClock.uptimeMillis();
     }
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/util/LruCache.java b/library/src/main/java/com/bumptech/glide/util/LruCache.java
index 0d47fd7d7..a2cd7d822 100644
--- a/library/src/main/java/com/bumptech/glide/util/LruCache.java
+++ b/library/src/main/java/com/bumptech/glide/util/LruCache.java
@@ -1,6 +1,8 @@
 package com.bumptech.glide.util;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.Map;
 
@@ -13,10 +15,10 @@
  * @param <Y> The type of the values.
  */
 public class LruCache<T, Y> {
-  private final LinkedHashMap<T, Y> cache = new LinkedHashMap<>(100, 0.75f, true);
-  private final int initialMaxSize;
-  private int maxSize;
-  private int currentSize = 0;
+  private final Map<T, Y> cache = new LinkedHashMap<>(100, 0.75f, true);
+  private final long initialMaxSize;
+  private long maxSize;
+  private long currentSize;
 
   /**
    * Constructor for LruCache.
@@ -24,7 +26,7 @@
    * @param size The maximum size of the cache, the units must match the units used in {@link
    *             #getSize(Object)}.
    */
-  public LruCache(int size) {
+  public LruCache(long size) {
     this.initialMaxSize = size;
     this.maxSize = size;
   }
@@ -51,31 +53,38 @@ public synchronized void setSizeMultiplier(float multiplier) {
    *
    * @param item The item to get the size of.
    */
-  protected int getSize(Y item) {
+  protected int getSize(@Nullable Y item) {
     return 1;
   }
 
+  /**
+   * Returns the number of entries stored in cache.
+   */
+  protected synchronized int getCount() {
+    return cache.size();
+  }
+
   /**
    * A callback called whenever an item is evicted from the cache. Subclasses can override.
    *
    * @param key  The key of the evicted item.
    * @param item The evicted item.
    */
-  protected void onItemEvicted(T key, Y item) {
+  protected void onItemEvicted(@NonNull T key, @Nullable Y item) {
     // optional override
   }
 
   /**
    * Returns the current maximum size of the cache in bytes.
    */
-  public synchronized int getMaxSize() {
+  public synchronized long getMaxSize() {
     return maxSize;
   }
 
   /**
    * Returns the sum of the sizes of all items in the cache.
    */
-  public synchronized int getCurrentSize() {
+  public synchronized long getCurrentSize() {
     return currentSize;
   }
 
@@ -85,7 +94,7 @@ public synchronized int getCurrentSize() {
    * @param key The key to check.
    */
 
-  public synchronized boolean contains(T key) {
+  public synchronized boolean contains(@NonNull T key) {
     return cache.containsKey(key);
   }
 
@@ -95,7 +104,7 @@ public synchronized boolean contains(T key) {
    * @param key The key to check.
    */
   @Nullable
-  public synchronized Y get(T key) {
+  public synchronized Y get(@NonNull T key) {
     return cache.get(key);
   }
 
@@ -103,31 +112,35 @@ public synchronized Y get(T key) {
    * Adds the given item to the cache with the given key and returns any previous entry for the
    * given key that may have already been in the cache.
    *
-   * <p> If the size of the item is larger than the total cache size, the item will not be added to
+   * <p>If the size of the item is larger than the total cache size, the item will not be added to
    * the cache and instead {@link #onItemEvicted(Object, Object)} will be called synchronously with
-   * the given key and item. </p>
+   * the given key and item.
    *
    * @param key  The key to add the item at.
    * @param item The item to add.
    */
-  public synchronized Y put(T key, Y item) {
+  @Nullable
+  public synchronized Y put(@NonNull T key, @Nullable Y item) {
     final int itemSize = getSize(item);
     if (itemSize >= maxSize) {
       onItemEvicted(key, item);
       return null;
     }
 
-    final Y result = cache.put(key, item);
     if (item != null) {
-      currentSize += getSize(item);
+      currentSize += itemSize;
     }
-    if (result != null) {
-      // TODO: should we call onItemEvicted here?
-      currentSize -= getSize(result);
+    @Nullable final Y old = cache.put(key, item);
+    if (old != null) {
+      currentSize -= getSize(old);
+
+      if (!old.equals(item)) {
+        onItemEvicted(key, old);
+      }
     }
     evict();
 
-    return result;
+    return old;
   }
 
   /**
@@ -136,7 +149,7 @@ public synchronized Y put(T key, Y item) {
    * @param key The key to remove the item at.
    */
   @Nullable
-  public synchronized Y remove(T key) {
+  public synchronized Y remove(@NonNull T key) {
     final Y value = cache.remove(key);
     if (value != null) {
       currentSize -= getSize(value);
@@ -157,14 +170,16 @@ public void clearMemory() {
    *
    * @param size The size the cache should be less than.
    */
-  protected synchronized void trimToSize(int size) {
+  protected synchronized void trimToSize(long size) {
     Map.Entry<T, Y> last;
+    Iterator<Map.Entry<T, Y>> cacheIterator;
     while (currentSize > size) {
-      last = cache.entrySet().iterator().next();
+      cacheIterator  = cache.entrySet().iterator();
+      last = cacheIterator.next();
       final Y toRemove = last.getValue();
       currentSize -= getSize(toRemove);
       final T key = last.getKey();
-      cache.remove(key);
+      cacheIterator.remove();
       onItemEvicted(key, toRemove);
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/util/MarkEnforcingInputStream.java b/library/src/main/java/com/bumptech/glide/util/MarkEnforcingInputStream.java
index bec16fa67..d2ce2841d 100644
--- a/library/src/main/java/com/bumptech/glide/util/MarkEnforcingInputStream.java
+++ b/library/src/main/java/com/bumptech/glide/util/MarkEnforcingInputStream.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.util;
 
+import android.support.annotation.NonNull;
 import java.io.FilterInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -14,14 +15,14 @@
 
   private int availableBytes = UNSET;
 
-  public MarkEnforcingInputStream(InputStream in) {
+  public MarkEnforcingInputStream(@NonNull InputStream in) {
     super(in);
   }
 
   @Override
-  public void mark(int readlimit) {
-    super.mark(readlimit);
-    availableBytes = readlimit;
+  public synchronized void mark(int readLimit) {
+    super.mark(readLimit);
+    availableBytes = readLimit;
   }
 
   @Override
@@ -36,7 +37,7 @@ public int read() throws IOException {
   }
 
   @Override
-  public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
+  public int read(@NonNull byte[] buffer, int byteOffset, int byteCount) throws IOException {
     int toRead = (int) getBytesToRead(byteCount);
     if (toRead == END_OF_STREAM) {
       return END_OF_STREAM;
@@ -48,7 +49,7 @@ public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException
   }
 
   @Override
-  public void reset() throws IOException {
+  public synchronized void reset() throws IOException {
     super.reset();
     availableBytes = UNSET;
   }
@@ -57,7 +58,7 @@ public void reset() throws IOException {
   public long skip(long byteCount) throws IOException {
     long toSkip = getBytesToRead(byteCount);
     if (toSkip == END_OF_STREAM) {
-      return END_OF_STREAM;
+      return 0;
     }
 
     long read = super.skip(toSkip);
@@ -83,7 +84,8 @@ private long getBytesToRead(long targetByteCount) {
 
   private void updateAvailableBytesAfterRead(long bytesRead) {
     if (availableBytes != UNSET && bytesRead != END_OF_STREAM) {
-      availableBytes -= bytesRead;
+      // See https://errorprone.info/bugpattern/NarrowingCompoundAssignment.
+      availableBytes = (int) (availableBytes - bytesRead);
     }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/util/MultiClassKey.java b/library/src/main/java/com/bumptech/glide/util/MultiClassKey.java
index 18fd5e04e..54fac7310 100644
--- a/library/src/main/java/com/bumptech/glide/util/MultiClassKey.java
+++ b/library/src/main/java/com/bumptech/glide/util/MultiClassKey.java
@@ -1,5 +1,8 @@
 package com.bumptech.glide.util;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
 /**
  * A key of two {@link Class}es to be used in hashed collections.
  */
@@ -13,19 +16,20 @@ public MultiClassKey() {
     // leave them null
   }
 
-  public MultiClassKey(Class<?> first, Class<?> second) {
+  public MultiClassKey(@NonNull Class<?> first, @NonNull Class<?> second) {
     set(first, second);
   }
 
-  public MultiClassKey(Class<?> first, Class<?> second, Class<?> third) {
+  public MultiClassKey(@NonNull Class<?> first, @NonNull Class<?> second,
+      @Nullable Class<?> third) {
     set(first, second, third);
   }
 
-  public void set(Class<?> first, Class<?> second) {
+  public void set(@NonNull Class<?> first, @NonNull Class<?> second) {
     set(first, second, null);
   }
 
-  public void set(Class<?> first, Class<?> second, Class<?> third) {
+  public void set(@NonNull Class<?> first, @NonNull Class<?> second, @Nullable Class<?> third) {
     this.first = first;
     this.second = second;
     this.third = third;
diff --git a/library/src/main/java/com/bumptech/glide/util/Preconditions.java b/library/src/main/java/com/bumptech/glide/util/Preconditions.java
index 121ead84c..4ca650fc7 100644
--- a/library/src/main/java/com/bumptech/glide/util/Preconditions.java
+++ b/library/src/main/java/com/bumptech/glide/util/Preconditions.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.util;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.text.TextUtils;
 import java.util.Collection;
 
@@ -12,31 +14,35 @@ private Preconditions() {
     // Utility class.
   }
 
-  public static void checkArgument(boolean expression, String message) {
+  public static void checkArgument(boolean expression, @NonNull String message) {
     if (!expression) {
       throw new IllegalArgumentException(message);
     }
   }
 
-  public static <T> T checkNotNull(T arg) {
+  @NonNull
+  public static <T> T checkNotNull(@Nullable T arg) {
     return checkNotNull(arg, "Argument must not be null");
   }
 
-  public static <T> T checkNotNull(T arg, String message) {
+  @NonNull
+  public static <T> T checkNotNull(@Nullable T arg, @NonNull String message) {
     if (arg == null) {
       throw new NullPointerException(message);
     }
     return arg;
   }
 
-  public static String checkNotEmpty(String string) {
+  @NonNull
+  public static String checkNotEmpty(@Nullable String string) {
     if (TextUtils.isEmpty(string)) {
       throw new IllegalArgumentException("Must not be null or empty");
     }
     return string;
   }
 
-  public static <T extends Collection<Y>, Y> T checkNotEmpty(T collection) {
+  @NonNull
+  public static <T extends Collection<Y>, Y> T checkNotEmpty(@NonNull T collection) {
     if (collection.isEmpty()) {
       throw new IllegalArgumentException("Must not be empty.");
     }
diff --git a/library/src/main/java/com/bumptech/glide/util/Util.java b/library/src/main/java/com/bumptech/glide/util/Util.java
index 00cedcece..de4b3784b 100644
--- a/library/src/main/java/com/bumptech/glide/util/Util.java
+++ b/library/src/main/java/com/bumptech/glide/util/Util.java
@@ -4,6 +4,9 @@
 import android.graphics.Bitmap;
 import android.os.Build;
 import android.os.Looper;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.model.Model;
 import com.bumptech.glide.request.target.Target;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
@@ -28,7 +31,8 @@ private Util() {
   /**
    * Returns the hex string of the given byte array representing a SHA256 hash.
    */
-  public static String sha256BytesToHex(byte[] bytes) {
+  @NonNull
+  public static String sha256BytesToHex(@NonNull byte[] bytes) {
     synchronized (SHA_256_CHARS) {
       return bytesToHex(bytes, SHA_256_CHARS);
     }
@@ -38,7 +42,8 @@ public static String sha256BytesToHex(byte[] bytes) {
   // http://stackoverflow.com/questions/9655181/convert-from-byte-array-to-hex-string-in-java
   // /9655275#9655275
   @SuppressWarnings("PMD.UseVarargs")
-  private static String bytesToHex(byte[] bytes, char[] hexChars) {
+  @NonNull
+  private static String bytesToHex(@NonNull byte[] bytes, @NonNull char[] hexChars) {
     int v;
     for (int j = 0; j < bytes.length; j++) {
       v = bytes[j] & 0xFF;
@@ -56,7 +61,7 @@ private static String bytesToHex(byte[] bytes, char[] hexChars) {
    * removed in Glide 4.0.
    */
   @Deprecated
-  public static int getSize(Bitmap bitmap) {
+  public static int getSize(@NonNull Bitmap bitmap) {
     return getBitmapByteSize(bitmap);
   }
 
@@ -64,7 +69,7 @@ public static int getSize(Bitmap bitmap) {
    * Returns the in memory size of the given {@link Bitmap} in bytes.
    */
   @TargetApi(Build.VERSION_CODES.KITKAT)
-  public static int getBitmapByteSize(Bitmap bitmap) {
+  public static int getBitmapByteSize(@NonNull Bitmap bitmap) {
     // The return value of getAllocationByteCount silently changes for recycled bitmaps from the
     // internal buffer size to row bytes * height. To avoid random inconsistencies in caches, we
     // instead assert here.
@@ -76,7 +81,7 @@ public static int getBitmapByteSize(Bitmap bitmap) {
       // Workaround for KitKat initial release NPE in Bitmap, fixed in MR1. See issue #148.
       try {
         return bitmap.getAllocationByteCount();
-      } catch (NullPointerException e) {
+      } catch (@SuppressWarnings("PMD.AvoidCatchingNPE") NullPointerException e) {
         // Do nothing.
       }
     }
@@ -87,11 +92,11 @@ public static int getBitmapByteSize(Bitmap bitmap) {
    * Returns the in memory size of {@link android.graphics.Bitmap} with the given width, height, and
    * {@link android.graphics.Bitmap.Config}.
    */
-  public static int getBitmapByteSize(int width, int height, Bitmap.Config config) {
+  public static int getBitmapByteSize(int width, int height, @Nullable Bitmap.Config config) {
     return width * height * getBytesPerPixel(config);
   }
 
-  private static int getBytesPerPixel(Bitmap.Config config) {
+  private static int getBytesPerPixel(@Nullable Bitmap.Config config) {
     // A bitmap by decoding a GIF has null "config" in certain environments.
     if (config == null) {
       config = Bitmap.Config.ARGB_8888;
@@ -106,6 +111,9 @@ private static int getBytesPerPixel(Bitmap.Config config) {
       case ARGB_4444:
         bytesPerPixel = 2;
         break;
+      case RGBA_F16:
+        bytesPerPixel = 8;
+        break;
       case ARGB_8888:
       default:
         bytesPerPixel = 4;
@@ -161,6 +169,7 @@ public static boolean isOnBackgroundThread() {
   /**
    * Creates a {@link java.util.Queue} of the given size using Glide's preferred implementation.
    */
+  @NonNull
   public static <T> Queue<T> createQueue(int size) {
     return new ArrayDeque<>(size);
   }
@@ -169,14 +178,20 @@ public static boolean isOnBackgroundThread() {
    * Returns a copy of the given list that is safe to iterate over and perform actions that may
    * modify the original list.
    *
-   * <p> See #303 and #375. </p>
+   * <p>See #303, #375, #322, #2262.
    */
-  public static <T> List<T> getSnapshot(Collection<T> other) {
-    // toArray creates a new ArrayList internally and this way we can guarantee entries will not
-    // be null. See #322.
-    List<T> result = new ArrayList<T>(other.size());
+  @NonNull
+  @SuppressWarnings("UseBulkOperation")
+  public static <T> List<T> getSnapshot(@NonNull Collection<T> other) {
+    // toArray creates a new ArrayList internally and does not guarantee that the values it contains
+    // are non-null. Collections.addAll in ArrayList uses toArray internally and therefore also
+    // doesn't guarantee that entries are non-null. WeakHashMap's iterator does avoid returning null
+    // and is therefore safe to use. See #322, #2262.
+    List<T> result = new ArrayList<>(other.size());
     for (T item : other) {
-      result.add(item);
+      if (item != null) {
+        result.add(item);
+      }
     }
     return result;
   }
@@ -186,10 +201,20 @@ public static boolean isOnBackgroundThread() {
    *
    * @see java.util.Objects#equals
    */
-  public static boolean bothNullOrEqual(Object a, Object b) {
+  public static boolean bothNullOrEqual(@Nullable Object a, @Nullable Object b) {
     return a == null ? b == null : a.equals(b);
   }
 
+  public static boolean bothModelsNullEquivalentOrEquals(@Nullable Object a, @Nullable Object b) {
+    if (a == null) {
+      return b == null;
+    }
+    if (a instanceof Model) {
+      return ((Model) a).isEquivalentTo(b);
+    }
+    return a.equals(b);
+  }
+
   public static int hashCode(int value) {
     return hashCode(value, HASH_ACCUMULATOR);
   }
@@ -206,7 +231,7 @@ public static int hashCode(float value, int accumulator) {
     return hashCode(Float.floatToIntBits(value), accumulator);
   }
 
-  public static int hashCode(Object object, int accumulator) {
+  public static int hashCode(@Nullable Object object, int accumulator) {
     return hashCode(object == null ? 0 : object.hashCode(), accumulator);
   }
 
@@ -217,5 +242,4 @@ public static int hashCode(boolean value, int accumulator) {
   public static int hashCode(boolean value) {
     return hashCode(value, HASH_ACCUMULATOR);
   }
-
 }
diff --git a/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java b/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java
index 5f341a5b4..90580d544 100644
--- a/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java
+++ b/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.util;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 import com.bumptech.glide.ListPreloader;
 import com.bumptech.glide.request.target.SizeReadyCallback;
@@ -37,22 +39,25 @@ public ViewPreloadSizeProvider() {
    * @param view A not null View the size will be extracted from async using an {@link
    *             android.view.ViewTreeObserver .OnPreDrawListener}
    */
-  public ViewPreloadSizeProvider(View view) {
-    this.viewTarget = new SizeViewTarget(view, this);
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public ViewPreloadSizeProvider(@NonNull View view) {
+    viewTarget = new SizeViewTarget(view, this);
   }
 
+  @Nullable
   @Override
-  public int[] getPreloadSize(T item, int adapterPosition, int itemPosition) {
+  public int[] getPreloadSize(@NonNull T item, int adapterPosition, int itemPosition) {
     if (size == null) {
       return null;
     } else {
-      return Arrays.copyOf(this.size, this.size.length);
+      return Arrays.copyOf(size, size.length);
     }
   }
 
   @Override
   public void onSizeReady(int width, int height) {
-    this.size = new int[] { width, height };
+    size = new int[]{width, height};
     viewTarget = null;
   }
 
@@ -65,21 +70,22 @@ public void onSizeReady(int width, int height) {
    * @param view A not null View the size will be extracted async with an {@link
    *             android.view.ViewTreeObserver .OnPreDrawListener}
    */
-  public void setView(View view) {
-    if (this.size != null || viewTarget != null) {
+  public void setView(@NonNull View view) {
+    if (size != null || viewTarget != null) {
       return;
     }
-    this.viewTarget = new SizeViewTarget(view, this);
+    viewTarget = new SizeViewTarget(view, this);
   }
 
   private static final class SizeViewTarget extends ViewTarget<View, Object> {
-    public SizeViewTarget(View view, SizeReadyCallback callback) {
+    SizeViewTarget(@NonNull View view, @NonNull SizeReadyCallback callback) {
       super(view);
       getSize(callback);
     }
 
     @Override
-    public void onResourceReady(Object resource, Transition<? super Object> transition) {
+    public void onResourceReady(@NonNull Object resource,
+        @Nullable Transition<? super Object> transition) {
       // Do nothing
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java b/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java
index 23416d80d..12e641dc5 100644
--- a/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java
+++ b/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.util.pool;
 
+import android.support.annotation.NonNull;
 import android.support.v4.util.Pools.Pool;
 import android.support.v4.util.Pools.SimplePool;
 import android.support.v4.util.Pools.SynchronizedPool;
@@ -17,7 +18,7 @@
   private static final int DEFAULT_POOL_SIZE = 20;
   private static final Resetter<Object> EMPTY_RESETTER = new Resetter<Object>() {
     @Override
-    public void reset(Object object) {
+    public void reset(@NonNull Object object) {
       // Do nothing.
     }
   };
@@ -34,7 +35,8 @@ private FactoryPools() { }
    *
    * @param <T> The type of object the pool will contains.
    */
-  public static <T extends Poolable> Pool<T> simple(int size, Factory<T> factory) {
+  @NonNull
+  public static <T extends Poolable> Pool<T> simple(int size, @NonNull Factory<T> factory) {
     return build(new SimplePool<T>(size), factory);
   }
 
@@ -48,7 +50,8 @@ private FactoryPools() { }
    *
    * @param <T> The type of object the pool will contains.
    */
-  public static <T extends Poolable> Pool<T> threadSafe(int size, Factory<T> factory) {
+  @NonNull
+  public static <T extends Poolable> Pool<T> threadSafe(int size, @NonNull Factory<T> factory) {
     return build(new SynchronizedPool<T>(size), factory);
   }
 
@@ -61,6 +64,7 @@ private FactoryPools() { }
    *
    * @param <T> The type of object that the {@link List Lists} will contain.
    */
+  @NonNull
   public static <T> Pool<List<T>> threadSafeList() {
     return threadSafeList(DEFAULT_POOL_SIZE);
   }
@@ -74,29 +78,37 @@ private FactoryPools() { }
    *
    * @param <T> The type of object that the {@link List Lists} will contain.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  @NonNull
   public static <T> Pool<List<T>> threadSafeList(int size) {
     return build(new SynchronizedPool<List<T>>(size), new Factory<List<T>>() {
+      @NonNull
       @Override
       public List<T> create() {
         return new ArrayList<>();
       }
     }, new Resetter<List<T>>() {
       @Override
-      public void reset(List<T> object) {
+      public void reset(@NonNull List<T> object) {
         object.clear();
       }
     });
   }
 
-  private static <T extends Poolable> Pool<T> build(Pool<T> pool, Factory<T> factory) {
+  @NonNull
+  private static <T extends Poolable> Pool<T> build(@NonNull Pool<T> pool,
+      @NonNull Factory<T> factory) {
     return build(pool, factory, FactoryPools.<T>emptyResetter());
   }
 
-  private static <T> Pool<T> build(Pool<T> pool, Factory<T> factory,
-      Resetter<T> resetter) {
+  @NonNull
+  private static <T> Pool<T> build(@NonNull Pool<T> pool, @NonNull Factory<T> factory,
+      @NonNull Resetter<T> resetter) {
     return new FactoryPool<>(pool, factory, resetter);
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
   private static <T> Resetter<T> emptyResetter() {
     return (Resetter<T>) EMPTY_RESETTER;
@@ -117,7 +129,7 @@ public void reset(List<T> object) {
    * @param <T> The type of Object that will be reset.
    */
   public interface Resetter<T> {
-    void reset(T object);
+    void reset(@NonNull T object);
   }
 
   /**
@@ -125,6 +137,7 @@ public void reset(List<T> object) {
    * an object pool.
    */
   public interface Poolable {
+    @NonNull
     StateVerifier getVerifier();
   }
 
@@ -133,7 +146,7 @@ public void reset(List<T> object) {
     private final Resetter<T> resetter;
     private final Pool<T> pool;
 
-    FactoryPool(Pool<T> pool, Factory<T> factory, Resetter<T> resetter) {
+    FactoryPool(@NonNull Pool<T> pool, @NonNull Factory<T> factory, @NonNull Resetter<T> resetter) {
       this.pool = pool;
       this.factory = factory;
       this.resetter = resetter;
@@ -155,7 +168,7 @@ public T acquire() {
     }
 
     @Override
-    public boolean release(T instance) {
+    public boolean release(@NonNull T instance) {
       if (instance instanceof Poolable) {
         ((Poolable) instance).getVerifier().setRecycled(true /*isRecycled*/);
       }
diff --git a/library/src/main/java/com/bumptech/glide/util/pool/GlideTrace.java b/library/src/main/java/com/bumptech/glide/util/pool/GlideTrace.java
new file mode 100644
index 000000000..78c4f0fa3
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/util/pool/GlideTrace.java
@@ -0,0 +1,56 @@
+package com.bumptech.glide.util.pool;
+
+import android.support.v4.os.TraceCompat;
+
+/**
+ * Systracing utilities for Glide.
+ */
+public final class GlideTrace {
+
+  // Enable this locally to see tracing statements.
+  private static final boolean TRACING_ENABLED = false;
+
+  /** Maximum length of a systrace tag. */
+  private static final int MAX_LENGTH = 127;
+
+  private GlideTrace() {
+    // Utility class.
+  }
+
+  private static String truncateTag(String tag) {
+    if (tag.length() > MAX_LENGTH) {
+      return tag.substring(0, MAX_LENGTH - 1);
+    }
+    return tag;
+  }
+
+  public static void beginSection(String tag) {
+    if (TRACING_ENABLED) {
+      TraceCompat.beginSection(truncateTag(tag));
+    }
+  }
+
+  public static void beginSectionFormat(String format, Object arg1) {
+    if (TRACING_ENABLED) {
+      TraceCompat.beginSection(truncateTag(String.format(format, arg1)));
+    }
+  }
+
+  public static void beginSectionFormat(String format, Object arg1, Object arg2) {
+    if (TRACING_ENABLED) {
+      TraceCompat.beginSection(truncateTag(String.format(format, arg1, arg2)));
+    }
+  }
+
+  public static void beginSectionFormat(String format, Object arg1, Object arg2, Object arg3) {
+    if (TRACING_ENABLED) {
+      TraceCompat.beginSection(truncateTag(String.format(format, arg1, arg2, arg3)));
+    }
+  }
+
+  public static void endSection() {
+    if (TRACING_ENABLED) {
+      TraceCompat.endSection();
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/util/pool/StateVerifier.java b/library/src/main/java/com/bumptech/glide/util/pool/StateVerifier.java
index 7e6577dd3..79e0b40aa 100644
--- a/library/src/main/java/com/bumptech/glide/util/pool/StateVerifier.java
+++ b/library/src/main/java/com/bumptech/glide/util/pool/StateVerifier.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.util.pool;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.util.Synthetic;
 
 /**
@@ -11,6 +12,7 @@
   /**
    * Creates a new {@link StateVerifier} instance.
    */
+  @NonNull
   public static StateVerifier newInstance() {
     if (DEBUG) {
       return new DebugStateVerifier();
@@ -68,9 +70,9 @@ public void throwIfRecycled() {
     @Override
     void setRecycled(boolean isRecycled) {
       if (isRecycled) {
-        this.recycledAtStackTraceException = new RuntimeException("Released");
+        recycledAtStackTraceException = new RuntimeException("Released");
       } else {
-        this.recycledAtStackTraceException = null;
+        recycledAtStackTraceException = null;
       }
     }
   }
diff --git a/library/src/main/res/values/ids.xml b/library/src/main/res/values/ids.xml
new file mode 100644
index 000000000..c8c7c74dd
--- /dev/null
+++ b/library/src/main/res/values/ids.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+  <item name="glide_custom_view_target_tag" type="id"/>
+</resources>
\ No newline at end of file
diff --git a/library/src/test/java/com/bumptech/glide/load/OptionsTest.java b/library/src/test/java/com/bumptech/glide/load/OptionsTest.java
deleted file mode 100644
index bac793e3b..000000000
--- a/library/src/test/java/com/bumptech/glide/load/OptionsTest.java
+++ /dev/null
@@ -1,35 +0,0 @@
-package com.bumptech.glide.load;
-
-import com.google.common.testing.EqualsTester;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
-public class OptionsTest {
-
-  @Test
-  public void testEquals() {
-    Option<Object> firstOption = Option.memory("firstKey");
-    Object firstValue = new Object();
-    Option<Object> secondOption = Option.memory("secondKey");
-    Object secondValue = new Object();
-    new EqualsTester()
-        .addEqualityGroup(new Options(), new Options())
-        .addEqualityGroup(
-            new Options().set(firstOption, firstValue),
-            new Options().set(firstOption, firstValue)
-        )
-        .addEqualityGroup(
-            new Options().set(secondOption, secondValue),
-            new Options().set(secondOption, secondValue)
-        )
-        .addEqualityGroup(
-            new Options().set(firstOption, firstValue).set(secondOption, secondValue),
-            new Options().set(firstOption, firstValue).set(secondOption, secondValue)
-        ).testEquals();
-  }
-
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java b/library/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java
deleted file mode 100644
index 0e691225f..000000000
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java
+++ /dev/null
@@ -1,153 +0,0 @@
-package com.bumptech.glide.load.engine;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.Option;
-import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.tests.KeyAssertions;
-import com.bumptech.glide.tests.Util;
-import java.io.UnsupportedEncodingException;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-import java.util.Collections;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-/**
- * Tests if {@link EngineKey} {@link Object#hashCode() hashCode} and {@link Object#equals(Object)
- * equals} and SHA-1 disk cache key are different on any difference in ID or existence of a certain
- * workflow part. Also checking whether the equals method is symmetric.
- */
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
-public class EngineKeyTest {
-  private Harness harness;
-
-  @Before
-  public void setUp() {
-    harness = new Harness();
-  }
-
-  private static class Harness {
-    String id = "testId";
-    int width = 1;
-    int height = 2;
-    Class<?> resourceClass = Object.class;
-    Class<?> transcodeClass = Integer.class;
-    Key signature = mock(Key.class);
-    @SuppressWarnings("unchecked")
-    Transformation<Object> transformation = mock(Transformation.class);
-    Options options = new Options();
-
-    public Harness() {
-      doAnswer(new Util.WriteDigest("transformation")).when(transformation)
-          .updateDiskCacheKey(any(MessageDigest.class));
-    }
-
-    public EngineKey build() {
-      return new EngineKey(id, signature, width, height,
-          Collections.<Class<?>, Transformation<?>>singletonMap(Object.class, transformation),
-          resourceClass, transcodeClass, options);
-    }
-  }
-
-  @Test
-  public void testIsIdenticalWithSameArguments() {
-    assertEquals(harness.build(), harness.build());
-  }
-
-  @Test
-  public void testDiffersIfIdDiffers() throws Exception {
-    EngineKey first = harness.build();
-    harness.id = harness.id + "2";
-    EngineKey second = harness.build();
-
-    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
-  }
-
-  @Test
-  public void testDiffersIfHeightDiffers() throws Exception {
-    EngineKey first = harness.build();
-    harness.height += 1;
-    EngineKey second = harness.build();
-
-    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
-  }
-
-  @Test
-  public void testDiffersIfWidthDiffers() throws Exception {
-    EngineKey first = harness.build();
-    harness.width += 1;
-    EngineKey second = harness.build();
-
-    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
-  }
-
-  @Test
-  public void testDiffersIfSignatureDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    EngineKey first = harness.build();
-    Key signature = mock(Key.class);
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        MessageDigest digest = (MessageDigest) invocationOnMock.getArguments()[0];
-        digest.update("signature".getBytes("UTF-8"));
-        return null;
-      }
-    }).when(signature).updateDiskCacheKey(any(MessageDigest.class));
-    harness.signature = signature;
-    EngineKey second = harness.build();
-
-    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
-  }
-
-  @Test
-  public void testDiffersIfResourceClassDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    EngineKey first = harness.build();
-    harness.resourceClass = Long.class;
-    EngineKey second = harness.build();
-    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
-  }
-
-  @Test
-  public void testDiffersIfTranscodeClassDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    EngineKey first = harness.build();
-    harness.transcodeClass = Long.class;
-    EngineKey second = harness.build();
-    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
-  }
-
-  @Test
-  public void testDiffersIfTransformationsDiffer() throws NoSuchAlgorithmException {
-    EngineKey first = harness.build();
-
-    @SuppressWarnings("unchecked") Transformation<Object> other = mock(Transformation.class);
-    doAnswer(new Util.WriteDigest("other")).when(other)
-        .updateDiskCacheKey(any(MessageDigest.class));
-    harness.transformation = other;
-    EngineKey second = harness.build();
-    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
-  }
-
-  @Test
-  public void testDiffersIfOptionsDiffer() throws NoSuchAlgorithmException {
-    EngineKey first = harness.build();
-    harness.options = new Options();
-    harness.options.set(Option.memory("fakeKey"), "someValue");
-    EngineKey second = harness.build();
-    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java b/library/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java
deleted file mode 100644
index b2d467fac..000000000
--- a/library/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java
+++ /dev/null
@@ -1,135 +0,0 @@
-package com.bumptech.glide.load.engine;
-
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.signature.ObjectKey;
-import com.bumptech.glide.tests.KeyAssertions;
-import com.bumptech.glide.tests.Util;
-import java.io.UnsupportedEncodingException;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class ResourceCacheKeyTest {
-
-  private Factory factory;
-
-  @Before
-  public void setUp() {
-    factory = new Factory();
-  }
-
-  @Test
-  public void testIdenticalWithSameArguments()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    KeyAssertions.assertSame(factory.build(), factory.build());
-  }
-
-  @Test
-  public void testDifferIfSourceKeyDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    mutateAndAssertDifferent(new FactoryMutation() {
-      @Override
-      public void mutate(Factory factory) {
-        factory.sourceKey = new ObjectKey("secondKey");
-      }
-    });
-  }
-
-  @Test
-  public void testDiffersIfSignatureDiffers() {
-    mutateAndAssertDifferent(new FactoryMutation() {
-      @Override
-      public void mutate(Factory factory) {
-        factory.signature = new ObjectKey("secondSignature");
-      }
-    });
-  }
-
-  @Test
-  public void testDiffersIfWidthDiffers() {
-    mutateAndAssertDifferent(new FactoryMutation() {
-      @Override
-      public void mutate(Factory factory) {
-        factory.width = factory.width * 2;
-      }
-    });
-  }
-
-  @Test
-  public void testDiffersIfHeightDiffers() {
-    mutateAndAssertDifferent(new FactoryMutation() {
-      @Override
-      public void mutate(Factory factory) {
-        factory.height = factory.height * 2;
-      }
-    });
-  }
-
-  @Test
-  public void tesDiffersIfTransformationDiffers() {
-    mutateAndAssertDifferent(new FactoryMutation() {
-      @Override
-      public void mutate(Factory factory) {
-        factory.transformation = mock(Transformation.class);
-        doAnswer(new Util.WriteDigest("otherTransformation")).when(factory.transformation)
-            .updateDiskCacheKey(any(MessageDigest.class));
-      }
-    });
-  }
-
-  @Test
-  public void testDiffersIfResourceDiffers() {
-    mutateAndAssertDifferent(new FactoryMutation() {
-      @Override
-      public void mutate(Factory factory) {
-        factory.resourceClass = Integer.class;
-      }
-    });
-  }
-
-  interface FactoryMutation {
-    void mutate(Factory factory);
-  }
-
-  private void mutateAndAssertDifferent(FactoryMutation mutation) {
-    ResourceCacheKey original = factory.build();
-    mutation.mutate(factory);
-    ResourceCacheKey mutated = factory.build();
-
-    try {
-      KeyAssertions.assertDifferent(original, mutated);
-    } catch (NoSuchAlgorithmException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  static class Factory {
-    Key sourceKey = new ObjectKey("sourceKey");
-    Key signature = new ObjectKey("signature");
-    int width = 100;
-    int height = 100;
-    Transformation<?> transformation = mock(Transformation.class);
-    Class<?> resourceClass = Object.class;
-    Options options = new Options();
-
-    Factory() {
-      doAnswer(new Util.WriteDigest("transformation")).when(transformation)
-          .updateDiskCacheKey(any(MessageDigest.class));
-    }
-
-    ResourceCacheKey build() {
-      return new ResourceCacheKey(sourceKey, signature, width, height, transformation,
-          resourceClass, options);
-    }
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMapTest.java b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMapTest.java
deleted file mode 100644
index ab9604ddc..000000000
--- a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMapTest.java
+++ /dev/null
@@ -1,121 +0,0 @@
-package com.bumptech.glide.load.engine.bitmap_recycle;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertNull;
-import static org.mockito.Mockito.mock;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
-public class GroupedLinkedMapTest {
-
-    private GroupedLinkedMap<Key, Object> map;
-
-    @Before
-    public void setUp() {
-        map = new GroupedLinkedMap<Key, Object>();
-    }
-
-    @Test
-    public void testReturnsNullForGetWithNoBitmap() {
-        assertNull(map.get(mock(Key.class)));
-    }
-
-    @Test
-    public void testCanAddAndRemoveABitmap() {
-        Key key = new Key("key", 1, 1);
-        Object expected = new Object();
-
-        map.put(key, expected);
-
-        assertThat(map.get(key)).isEqualTo(expected);
-    }
-
-    @Test
-    public void testCanAddAndRemoveMoreThanOneBitmapForAGivenKey() {
-        Key key = new Key("key", 1, 1);
-        Integer value = 20;
-
-        int numToAdd = 10;
-
-        for (int i = 0; i < numToAdd; i++) {
-            map.put(key, new Integer(value));
-        }
-
-        for (int i = 0; i < numToAdd; i++) {
-            assertThat(map.get(key)).isEqualTo(value);
-        }
-    }
-
-    @Test
-    public void testLeastRecentlyRetrievedKeyIsLeastRecentlyUsed() {
-        Key firstKey = new Key("key", 1, 1);
-        Integer firstValue = 10;
-        map.put(firstKey, firstValue);
-        map.put(firstKey, new Integer(firstValue));
-
-        Key secondKey = new Key("key", 2, 2);
-        Integer secondValue = 20;
-        map.put(secondKey, secondValue);
-
-        map.get(firstKey);
-
-        assertThat(map.removeLast()).isEqualTo(secondValue);
-    }
-
-    @Test
-    public void testAddingAnEntryDoesNotMakeItMostRecentlyUsed() {
-        Key firstKey = new Key("key", 1, 1);
-        Integer firstValue = 10;
-
-        map.put(firstKey, firstValue);
-        map.put(firstKey, new Integer(firstValue));
-
-        map.get(firstKey);
-
-        Integer secondValue = 20;
-        map.put(new Key("key", 2, 2), secondValue);
-
-        assertThat(map.removeLast()).isEqualTo(secondValue);
-    }
-
-    private static class Key implements Poolable {
-
-        private final String key;
-        private final int width;
-        private final int height;
-
-        public Key(String key, int width, int height) {
-            this.key = key;
-            this.width = width;
-            this.height = height;
-        }
-
-        @Override
-        public boolean equals(Object o) {
-            if (o instanceof Key) {
-                Key other = (Key) o;
-                return key.equals(other.key) && width == other.width && height == other.height;
-            }
-            return false;
-        }
-
-        @Override
-        public int hashCode() {
-            int result = key != null ? key.hashCode() : 0;
-            result = 31 * result + width;
-            result = 31 * result + height;
-            return result;
-        }
-
-        @Override
-        public void offer() {
-            // Do nothing.
-        }
-    }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java
deleted file mode 100644
index 2242dcf03..000000000
--- a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java
+++ /dev/null
@@ -1,41 +0,0 @@
-package com.bumptech.glide.load.engine.bitmap_recycle;
-
-import android.graphics.Bitmap;
-import com.google.common.testing.EqualsTester;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-
-@RunWith(JUnit4.class)
-public class SizeConfigStrategyTest {
-
-    @Mock SizeConfigStrategy.KeyPool pool;
-
-    @Before
-    public void setUp() {
-        MockitoAnnotations.initMocks(this);
-    }
-
-    @Test
-    public void testKeyEquals() {
-        new EqualsTester()
-                .addEqualityGroup(
-                        new SizeConfigStrategy.Key(pool, 100, Bitmap.Config.ARGB_8888),
-                        new SizeConfigStrategy.Key(pool, 100, Bitmap.Config.ARGB_8888)
-                )
-                .addEqualityGroup(
-                        new SizeConfigStrategy.Key(pool, 101, Bitmap.Config.ARGB_8888)
-                )
-                .addEqualityGroup(
-                        new SizeConfigStrategy.Key(pool, 100, Bitmap.Config.RGB_565)
-                )
-                .addEqualityGroup(
-                        new SizeConfigStrategy.Key(pool, 100, null /*config*/)
-                )
-                .testEquals();
-
-    }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java b/library/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
deleted file mode 100644
index 00ffc8295..000000000
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
+++ /dev/null
@@ -1,120 +0,0 @@
-package com.bumptech.glide.load.engine.cache;
-
-import static com.bumptech.glide.load.engine.cache.MemoryCache.ResourceRemovedListener;
-import static com.bumptech.glide.tests.Util.mockResource;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.annotation.TargetApi;
-import android.content.ComponentCallbacks2;
-import android.os.Build;
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.engine.Resource;
-import java.security.MessageDigest;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-public class LruResourceCacheTest {
-  private static class TrimClearMemoryCacheHarness {
-    LruResourceCache resourceCache = new LruResourceCache(100);
-    Resource<?> first = mockResource();
-    Resource<?> second = mockResource();
-
-    ResourceRemovedListener listener = mock(ResourceRemovedListener.class);
-
-    public TrimClearMemoryCacheHarness() {
-      when(first.getSize()).thenReturn(50);
-      when(second.getSize()).thenReturn(50);
-      resourceCache.put(new MockKey(), first);
-      resourceCache.put(new MockKey(), second);
-      resourceCache.setResourceRemovedListener(listener);
-    }
-  }
-
-  @Test
-  public void testTrimMemoryBackground() {
-    TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
-
-    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
-
-    verify(harness.listener).onResourceRemoved(eq(harness.first));
-    verify(harness.listener).onResourceRemoved(eq(harness.second));
-  }
-
-  @Test
-  public void testTrimMemoryModerate() {
-    TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
-
-    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_MODERATE);
-
-    verify(harness.listener).onResourceRemoved(harness.first);
-    verify(harness.listener).onResourceRemoved(harness.second);
-  }
-
-  @Test
-  public void testTrimMemoryUiHidden() {
-    TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
-
-    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
-
-    verify(harness.listener).onResourceRemoved(harness.first);
-    verify(harness.listener, never()).onResourceRemoved(harness.second);
-  }
-
-  @Test
-  public void testResourceRemovedListenerIsNotifiedWhenResourceIsRemoved() {
-    LruResourceCache resourceCache = new LruResourceCache(100);
-    Resource<?> resource = mockResource();
-    when(resource.getSize()).thenReturn(200);
-
-    ResourceRemovedListener listener = mock(ResourceRemovedListener.class);
-
-    resourceCache.setResourceRemovedListener(listener);
-    resourceCache.put(new MockKey(), resource);
-
-    verify(listener).onResourceRemoved(eq(resource));
-  }
-
-  @Test
-  public void testSizeIsBasedOnResource() {
-    LruResourceCache resourceCache = new LruResourceCache(100);
-    Resource<?> first = getResource(50);
-    MockKey firstKey = new MockKey();
-    resourceCache.put(firstKey, first);
-    Resource<?> second = getResource(50);
-    MockKey secondKey = new MockKey();
-    resourceCache.put(secondKey, second);
-
-    assertTrue(resourceCache.contains(firstKey));
-    assertTrue(resourceCache.contains(secondKey));
-
-    Resource<?> third = getResource(50);
-    MockKey thirdKey = new MockKey();
-    resourceCache.put(thirdKey, third);
-
-    assertFalse(resourceCache.contains(firstKey));
-    assertTrue(resourceCache.contains(secondKey));
-    assertTrue(resourceCache.contains(thirdKey));
-  }
-
-  private Resource<?> getResource(int size) {
-    Resource<?> resource = mockResource();
-    when(resource.getSize()).thenReturn(size);
-    return resource;
-  }
-
-  private static class MockKey implements Key {
-    @Override
-    public void updateDiskCacheKey(MessageDigest messageDigest) {
-      messageDigest.update(toString().getBytes(CHARSET));
-    }
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java b/library/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
deleted file mode 100644
index af0dce220..000000000
--- a/library/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package com.bumptech.glide.load.engine.executor;
-
-/**
- * Creates mock {@link GlideExecutor}s.
- */
-public final class MockGlideExecutor {
-
-  private MockGlideExecutor() { }
-
-  public static GlideExecutor newMainThreadExecutor() {
-    return new GlideExecutor(1 /*poolSize*/, "mock-glide-executor",
-        GlideExecutor.UncaughtThrowableStrategy.THROW, false /*preventNetworkOperations*/,
-        true /*runAllOnMainThread*/);
-  }
-
-  public static GlideExecutor newMainThreadUnlimitedExecutor() {
-    return new GlideExecutor(0 /* corePoolSize */,
-        Integer.MAX_VALUE /* maximumPoolSize */,
-        java.util.concurrent.TimeUnit.SECONDS.toMillis(10) /* keepAliveTimeInMs */,
-        "mock-unlimited-glide-executor",
-        GlideExecutor.UncaughtThrowableStrategy.THROW, false /*preventNetworkOperations*/,
-        true /*runAllOnMainThread*/);
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java
deleted file mode 100644
index 4cbfc7e49..000000000
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java
+++ /dev/null
@@ -1,235 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import static com.google.common.collect.Range.closed;
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-import android.os.Build;
-import android.util.DisplayMetrics;
-import com.bumptech.glide.load.DecodeFormat;
-import com.bumptech.glide.load.ImageHeaderParser;
-import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.resource.bitmap.DownsamplerTest.AllocationSizeBitmap;
-import com.bumptech.glide.tests.Util;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.ArrayList;
-import java.util.List;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Matchers;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
-import org.robolectric.annotation.Config;
-import org.robolectric.annotation.Implementation;
-import org.robolectric.annotation.Implements;
-import org.robolectric.shadows.ShadowBitmap;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 19, shadows = AllocationSizeBitmap.class)
-public class DownsamplerTest {
-  @Mock private BitmapPool bitmapPool;
-  @Mock private ArrayPool byteArrayPool;
-  private Downsampler downsampler;
-  private Options options;
-  private int initialSdkVersion;
-
-  @Before
-  public void setUp() throws Exception {
-    MockitoAnnotations.initMocks(this);
-    options = new Options();
-    DisplayMetrics displayMetrics =
-        RuntimeEnvironment.application.getResources().getDisplayMetrics();
-    when(byteArrayPool.get(anyInt(), Matchers.eq(byte[].class)))
-        .thenReturn(new byte[ArrayPool.STANDARD_BUFFER_SIZE_BYTES]);
-
-    List<ImageHeaderParser> parsers = new ArrayList<ImageHeaderParser>();
-    parsers.add(new DefaultImageHeaderParser());
-
-    downsampler = new Downsampler(parsers, displayMetrics, bitmapPool, byteArrayPool);
-
-    initialSdkVersion = Build.VERSION.SDK_INT;
-  }
-
-  @After
-  public void tearDown() {
-    Util.setSdkVersionInt(initialSdkVersion);
-  }
-
-  @Test
-  public void testAlwaysArgb8888() throws IOException {
-    Bitmap rgb565 = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
-    InputStream stream = compressBitmap(rgb565, Bitmap.CompressFormat.JPEG);
-
-    options.set(Downsampler.DECODE_FORMAT, DecodeFormat.PREFER_ARGB_8888);
-    Resource<Bitmap> result = downsampler.decode(stream, 100, 100, options);
-    assertEquals(Bitmap.Config.ARGB_8888, result.get().getConfig());
-  }
-
-  @Test
-  public void testPreferRgb565() throws IOException {
-    Bitmap rgb565 = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    InputStream stream = compressBitmap(rgb565, Bitmap.CompressFormat.JPEG);
-
-    options.set(Downsampler.DECODE_FORMAT, DecodeFormat.PREFER_RGB_565);
-    Resource<Bitmap> result = downsampler.decode(stream, 100, 100, options);
-    assertEquals(Bitmap.Config.RGB_565, result.get().getConfig());
-  }
-
-  @Test
-  public void testCalculateScaling_withInvalidSourceSizes_doesNotCrash() {
-    runScaleTest(0, 0, 100, 100, DownsampleStrategy.AT_MOST, 0, 0);
-    runScaleTest(-1, -1, 100, 100, DownsampleStrategy.AT_MOST, -1, -1);
-    runScaleTest(0, 0, 100, 100, DownsampleStrategy.AT_LEAST, 0, 0);
-    runScaleTest(-1, -1, 100, 100, DownsampleStrategy.CENTER_OUTSIDE, -1, -1);
-  }
-
-  @Test
-  public void testCalculateScaling_withAtMost() {
-    DownsampleStrategy strategy = DownsampleStrategy.AT_MOST;
-    runScaleTest(100, 100, 100, 100, strategy, 100, 100);
-    runScaleTest(200, 200, 100, 100, strategy, 100, 100);
-    runScaleTest(400, 400, 100, 100, strategy, 100, 100);
-    runScaleTest(300, 300, 100, 100, strategy, 75, 75);
-    runScaleTest(799, 100, 100, 100, strategy, 100, 13);
-    runScaleTest(800, 100, 100, 100, strategy, 100, 13);
-    runScaleTest(801, 100, 100, 100, strategy, 50, 6);
-    runScaleTest(100, 800, 100, 100, strategy, 13, 100);
-    runScaleTest(87, 78, 100, 100, strategy, 87, 78);
-  }
-
-  @Test
-  public void testCalculateScaling_withAtLeast() {
-    DownsampleStrategy strategy = DownsampleStrategy.AT_LEAST;
-    runScaleTest(100, 100, 100, 100, strategy, 100, 100);
-    runScaleTest(200, 200, 100, 100, strategy, 100, 100);
-    runScaleTest(400, 400, 100, 100, strategy, 100, 100);
-    runScaleTest(300, 300, 100, 100, strategy, 150, 150);
-    runScaleTest(799, 100, 100, 100, strategy, 799, 100);
-    runScaleTest(800, 100, 100, 100, strategy, 800, 100);
-    runScaleTest(801, 100, 100, 100, strategy, 801, 100);
-    runScaleTest(100, 800, 100, 100, strategy, 100, 800);
-    runScaleTest(87, 78, 100, 100, strategy, 87, 78);
-  }
-
-  @Test
-  public void testCalculateScaling_withCenterInside() {
-    DownsampleStrategy strategy = DownsampleStrategy.FIT_CENTER;
-    runScaleTest(100, 100, 100, 100, strategy, 100, 100);
-    runScaleTest(200, 200, 100, 100, strategy, 100, 100);
-    runScaleTest(400, 400, 100, 100, strategy, 100, 100);
-    runScaleTest(300, 300, 100, 100, strategy, 100, 100);
-    runScaleTest(799, 100, 100, 100, strategy, 100, 13);
-    runScaleTest(800, 100, 100, 100, strategy, 100, 13);
-    runScaleTest(801, 100, 100, 100, strategy, 100, 13);
-    runScaleTest(100, 800, 100, 100, strategy, 13, 100);
-    runScaleTest(87, 78, 100, 100, strategy, 100, 90);
-  }
-
-  @Test
-  public void testCalculateScaling_withCenterOutside() {
-    DownsampleStrategy strategy = DownsampleStrategy.CENTER_OUTSIDE;
-    runScaleTest(100, 100, 100, 100, strategy, 100, 100);
-    runScaleTest(200, 200, 100, 100, strategy, 100, 100);
-    runScaleTest(400, 400, 100, 100, strategy, 100, 100);
-    runScaleTest(300, 300, 100, 100, strategy, 100, 100);
-    runScaleTest(799, 100, 100, 100, strategy, 799, 100);
-    runScaleTest(800, 100, 100, 100, strategy, 800, 100);
-    runScaleTest(801, 100, 100, 100, strategy, 801, 100);
-    runScaleTest(100, 800, 100, 100, strategy, 100, 800);
-    runScaleTest(87, 78, 100, 100, strategy, 112, 100);
-  }
-
-  @Test
-  public void testCalculateScaling_withNone() {
-    DownsampleStrategy strategy = DownsampleStrategy.NONE;
-    runScaleTest(100, 100, 100, 100, strategy, 100, 100);
-    runScaleTest(200, 200, 100, 100, strategy, 200, 200);
-    runScaleTest(400, 400, 100, 100, strategy, 400, 400);
-    runScaleTest(300, 300, 100, 100, strategy, 300, 300);
-    runScaleTest(799, 100, 100, 100, strategy, 799, 100);
-    runScaleTest(800, 100, 100, 100, strategy, 800, 100);
-    runScaleTest(801, 100, 100, 100, strategy, 801, 100);
-    runScaleTest(100, 800, 100, 100, strategy, 100, 800);
-    runScaleTest(87, 78, 100, 100, strategy, 87, 78);
-  }
-
-  // BitmapFactory does not support downsampling wbmp files on platforms <=M. See b/27305903.
-  @Test
-  public void testCalculateScaling_withWbmp() {
-    Util.setSdkVersionInt(23);
-    DownsampleStrategy strategy = DownsampleStrategy.FIT_CENTER;
-    BitmapFactory.Options options = new BitmapFactory.Options();
-
-    options.outMimeType = "image/vnd.wap.wbmp";
-    runScaleTest(100, 100, 100, 100, strategy, 100, 100, options);
-    runScaleTest(200, 200, 100, 100, strategy, 100, 100, options);
-    runScaleTest(400, 400, 100, 100, strategy, 100, 100, options);
-    runScaleTest(300, 300, 100, 100, strategy, 100, 100, options);
-    runScaleTest(799, 100, 100, 100, strategy, 100, 13, options);
-    runScaleTest(800, 100, 100, 100, strategy, 100, 13, options);
-    runScaleTest(801, 100, 100, 100, strategy, 100, 13, options);
-    runScaleTest(100, 800, 100, 100, strategy, 13, 100, options);
-    runScaleTest(87, 78, 100, 100, strategy, 100, 90, options);
-  }
-
-  private static void runScaleTest(int sourceWidth, int sourceHeight, int targetWidth,
-      int targetHeight, DownsampleStrategy strategy, int expectedWidth, int expectedHeight) {
-    runScaleTest(sourceWidth, sourceHeight, targetWidth, targetHeight, strategy, expectedWidth,
-        expectedHeight, new BitmapFactory.Options());
-  }
-
-  private static void runScaleTest(int sourceWidth, int sourceHeight, int targetWidth,
-      int targetHeight, DownsampleStrategy strategy, int expectedWidth, int expectedHeight,
-      BitmapFactory.Options options) {
-    Downsampler.calculateScaling(strategy, 0, sourceWidth, sourceHeight, targetWidth, targetHeight,
-        options);
-    assertSize(sourceWidth, sourceHeight, expectedWidth, expectedHeight, options);
-  }
-
-  private static void assertSize(int sourceWidth, int sourceHeight, int expectedWidth,
-      int expectedHeight, BitmapFactory.Options options) {
-    float sampleSize = Math.max(1, options.inSampleSize);
-    int downsampledWidth = (int) ((sourceWidth / sampleSize) + 0.5f);
-    int downsampledHeight = (int) ((sourceHeight / sampleSize) + 0.5f);
-
-    float scaleFactor = options.inScaled && options.inTargetDensity > 0 && options.inDensity > 0
-        ? options.inTargetDensity / (float) options.inDensity : 1f;
-    int scaledWidth = (int) Math.ceil(downsampledWidth * scaleFactor);
-    int scaledHeight = (int) Math.ceil(downsampledHeight * scaleFactor);
-
-    assertThat(scaledWidth).isIn(closed(expectedWidth, expectedWidth + 1));
-    assertThat(scaledHeight).isIn(closed(expectedHeight, expectedHeight + 1));
-  }
-
-  private InputStream compressBitmap(Bitmap bitmap, Bitmap.CompressFormat compressFormat)
-      throws FileNotFoundException {
-    ByteArrayOutputStream os = new ByteArrayOutputStream();
-    bitmap.compress(compressFormat, 100, os);
-    return new ByteArrayInputStream(os.toByteArray());
-  }
-
-  // Robolectric doesn't implement getAllocationByteCount correctly.
-  @Implements(Bitmap.class)
-  public static class AllocationSizeBitmap extends ShadowBitmap {
-
-    @Implementation
-    public int getAllocationByteCount() {
-      return getWidth() * getHeight() * (getConfig() == Bitmap.Config.ARGB_8888 ? 4 : 2);
-    }
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoderTest.java
deleted file mode 100644
index 4b034d2fc..000000000
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoderTest.java
+++ /dev/null
@@ -1,97 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.anyLong;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Bitmap;
-import android.media.MediaMetadataRetriever;
-import android.os.ParcelFileDescriptor;
-import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import java.io.FileDescriptor;
-import java.io.IOException;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
-public class VideoBitmapDecoderTest {
-  @Mock private ParcelFileDescriptor resource;
-  @Mock private VideoBitmapDecoder.MediaMetadataRetrieverFactory factory;
-  @Mock private MediaMetadataRetriever retriever;
-  @Mock private BitmapPool bitmapPool;
-  private VideoBitmapDecoder decoder;
-  private Options options;
-
-  @Before
-  public void setup() {
-    MockitoAnnotations.initMocks(this);
-    when(factory.build()).thenReturn(retriever);
-    decoder = new VideoBitmapDecoder(bitmapPool, factory);
-    options = new Options();
-  }
-
-  @Test
-  public void testReturnsRetrievedFrameForResource() throws IOException {
-    Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    when(retriever.getFrameAtTime()).thenReturn(expected);
-
-    FileDescriptor toSet = FileDescriptor.in;
-    when(resource.getFileDescriptor()).thenReturn(toSet);
-    Resource<Bitmap> result = decoder.decode(resource, 100, 100, options);
-
-    verify(retriever).setDataSource(eq(toSet));
-    assertEquals(expected, result.get());
-  }
-
-  @Test
-  public void testReleasesMediaMetadataRetriever() throws IOException {
-    decoder.decode(resource, 1, 2, options);
-
-    verify(retriever).release();
-  }
-
-  @Test
-  public void testClosesResource() throws IOException {
-    decoder.decode(resource, 1, 2, options);
-
-    verify(resource).close();
-  }
-
-  @Test(expected = IllegalArgumentException.class)
-  public void testThrowsExceptionIfCalledWithInvalidFrame() throws IOException {
-    options.set(VideoBitmapDecoder.TARGET_FRAME, -5L);
-    new VideoBitmapDecoder(bitmapPool, factory).decode(resource, 100, 100, options);
-  }
-
-  @Test
-  public void testSpecifiesThumbnailFrameIfICalledWithFrameNumber() throws IOException {
-    long frame = 5;
-    options.set(VideoBitmapDecoder.TARGET_FRAME, frame);
-    decoder = new VideoBitmapDecoder(bitmapPool, factory);
-
-    decoder.decode(resource, 100, 100, options);
-
-    verify(retriever).getFrameAtTime(frame);
-    verify(retriever, never()).getFrameAtTime();
-  }
-
-  @Test
-  public void testDoesNotSpecifyThumbnailFrameIfCalledWithoutFrameNumber() throws IOException {
-    decoder = new VideoBitmapDecoder(bitmapPool, factory);
-    decoder.decode(resource, 100, 100, options);
-
-    verify(retriever).getFrameAtTime();
-    verify(retriever, never()).getFrameAtTime(anyLong());
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java b/library/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
deleted file mode 100644
index 889cd2ba2..000000000
--- a/library/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
+++ /dev/null
@@ -1,357 +0,0 @@
-package com.bumptech.glide.manager;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import com.bumptech.glide.request.Request;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-
-@RunWith(JUnit4.class)
-public class RequestTrackerTest {
-  private RequestTracker tracker;
-
-  @Before
-  public void setUp() {
-    tracker = new RequestTracker();
-  }
-
-  @Test
-  public void testClearsAddedRequestsOnDestroy() {
-    Request request = mock(Request.class);
-    tracker.addRequest(request);
-
-    tracker.clearRequests();
-
-    verify(request).clear();
-    verify(request).recycle();
-  }
-
-  @Test
-  public void testClearRemoveAndRecycle_withNullRequest_doesNothingAndReturnsFalse() {
-    assertThat(tracker.clearRemoveAndRecycle(null)).isFalse();
-  }
-
-  @Test
-  public void testClearRemoveAndRecycle_withUnTrackedRequest_doesNothingAndReturnsFalse() {
-    Request request = mock(Request.class);
-
-    assertThat(tracker.clearRemoveAndRecycle(request)).isFalse();
-
-    verify(request, never()).clear();
-    verify(request, never()).recycle();
-  }
-
-  @Test
-  public void testClearRemoveAndRecycle_withTrackedRequest_clearsRecyclesAndReturnsTrue() {
-    Request request = mock(Request.class);
-    tracker.addRequest(request);
-
-    assertThat(tracker.clearRemoveAndRecycle(request)).isTrue();
-    verify(request).clear();
-    verify(request).recycle();
-  }
-
-  @Test
-  public void testClearRemoveAndRecycle_withAlreadyRemovedRequest_doesNothingAndReturnsFalse() {
-    Request request = mock(Request.class);
-    tracker.addRequest(request);
-    tracker.clearRemoveAndRecycle(request);
-    assertThat(tracker.clearRemoveAndRecycle(request)).isFalse();
-
-    verify(request, times(1)).clear();
-    verify(request, times(1)).recycle();
-  }
-
-  @Test
-  public void testCanAddAndRemoveRequest() {
-    Request request = mock(Request.class);
-    tracker.addRequest(request);
-    tracker.clearRemoveAndRecycle(request);
-
-    tracker.clearRequests();
-
-    verify(request, times(1)).clear();
-  }
-
-  @Test
-  public void testCanAddMultipleRequests() {
-    Request first = mock(Request.class);
-    Request second = mock(Request.class);
-    tracker.addRequest(first);
-    tracker.addRequest(second);
-
-    tracker.clearRequests();
-
-    verify(first).clear();
-    verify(second).clear();
-  }
-
-  @Test
-  public void testPausesInProgressRequestsWhenPaused() {
-    Request request = mock(Request.class);
-    when(request.isRunning()).thenReturn(true);
-    tracker.addRequest(request);
-
-    tracker.pauseRequests();
-
-    verify(request).pause();
-  }
-
-  @Test
-  public void testDoesNotClearCompleteRequestsWhenPaused() {
-    Request request = mock(Request.class);
-    tracker.addRequest(request);
-
-    when(request.isComplete()).thenReturn(true);
-    tracker.pauseRequests();
-
-    verify(request, never()).clear();
-  }
-
-  @Test
-  public void testStartsRequestOnRun() {
-    Request request = mock(Request.class);
-    tracker.runRequest(request);
-
-    verify(request).begin();
-  }
-
-  @Test
-  public void testDoesNotStartRequestOnRunIfPaused() {
-    Request request = mock(Request.class);
-    tracker.pauseRequests();
-    tracker.runRequest(request);
-
-    verify(request, never()).begin();
-  }
-
-  @Test
-  public void testStartsRequestAddedWhenPausedWhenResumed() {
-    Request request = mock(Request.class);
-    tracker.pauseRequests();
-    tracker.runRequest(request);
-    tracker.resumeRequests();
-
-    verify(request).begin();
-  }
-
-  @Test
-  public void testDoesNotClearFailedRequestsWhenPaused() {
-    Request request = mock(Request.class);
-    when(request.isFailed()).thenReturn(true);
-    tracker.addRequest(request);
-
-    tracker.pauseRequests();
-
-    verify(request, never()).clear();
-  }
-
-  @Test
-  public void testRestartsStoppedRequestWhenResumed() {
-    Request request = mock(Request.class);
-    tracker.addRequest(request);
-
-    tracker.resumeRequests();
-
-    verify(request).begin();
-  }
-
-  @Test
-  public void testDoesNotRestartCompletedRequestsWhenResumed() {
-    Request request = mock(Request.class);
-    when(request.isComplete()).thenReturn(true);
-    tracker.addRequest(request);
-
-    tracker.resumeRequests();
-
-    verify(request, never()).begin();
-  }
-
-  @Test
-  public void testDoesRestartFailedRequestsWhenResumed() {
-    Request request = mock(Request.class);
-    when(request.isFailed()).thenReturn(true);
-    tracker.addRequest(request);
-
-    tracker.resumeRequests();
-
-    verify(request).begin();
-  }
-
-  @Test
-  public void testDoesNotStartStartedRequestsWhenResumed() {
-    Request request = mock(Request.class);
-    when(request.isRunning()).thenReturn(true);
-    tracker.addRequest(request);
-
-    tracker.resumeRequests();
-
-    verify(request, never()).begin();
-  }
-
-  @Test
-  public void testAvoidsConcurrentModificationWhenResuming() {
-    Request first = mock(Request.class);
-    Request second = mock(Request.class);
-
-    doAnswer(new ClearAndRemoveRequest(second)).when(first).begin();
-
-    tracker.addRequest(mock(Request.class));
-    tracker.addRequest(first);
-    tracker.addRequest(second);
-
-    tracker.resumeRequests();
-  }
-
-  @Test
-  public void testAvoidsConcurrentModificationWhenPausing() {
-    Request first = mock(Request.class);
-    Request second = mock(Request.class);
-
-    when(first.isRunning()).thenReturn(true);
-    doAnswer(new ClearAndRemoveRequest(second)).when(first).pause();
-
-    tracker.addRequest(mock(Request.class));
-    tracker.addRequest(first);
-    tracker.addRequest(second);
-
-    tracker.pauseRequests();
-  }
-
-  @Test
-  public void testAvoidsConcurrentModificationWhenClearing() {
-    Request first = mock(Request.class);
-    Request second = mock(Request.class);
-
-    doAnswer(new ClearAndRemoveRequest(second)).when(first).clear();
-
-    tracker.addRequest(mock(Request.class));
-    tracker.addRequest(first);
-    tracker.addRequest(second);
-
-    tracker.clearRequests();
-  }
-
-  @Test
-  public void testAvoidsConcurrentModificationWhenRestarting() {
-    Request first = mock(Request.class);
-    Request second = mock(Request.class);
-
-    doAnswer(new ClearAndRemoveRequest(second)).when(first).pause();
-
-    tracker.addRequest(mock(Request.class));
-    tracker.addRequest(first);
-    tracker.addRequest(second);
-
-    tracker.restartRequests();
-  }
-
-  @Test
-  public void testRestartsFailedRequestRestart() {
-    Request request = mock(Request.class);
-    when(request.isFailed()).thenReturn(true);
-    tracker.addRequest(request);
-
-    tracker.restartRequests();
-
-    verify(request).begin();
-  }
-
-  @Test
-  public void testPausesAndRestartsNotYetFinishedRequestsOnRestart() {
-    Request request = mock(Request.class);
-    when(request.isComplete()).thenReturn(false);
-    tracker.addRequest(request);
-
-    tracker.restartRequests();
-
-    verify(request).pause();
-    verify(request).begin();
-  }
-
-  @Test
-  public void testDoesNotBeginFailedRequestOnRestartIfPaused() {
-    Request request = mock(Request.class);
-    when(request.isFailed()).thenReturn(true);
-    tracker.pauseRequests();
-    tracker.addRequest(request);
-
-    tracker.restartRequests();
-
-    verify(request, never()).begin();
-  }
-
-  @Test
-  public void testPausesFailedRequestOnRestartIfPaused() {
-    Request request = mock(Request.class);
-    when(request.isFailed()).thenReturn(true);
-    tracker.pauseRequests();
-    tracker.addRequest(request);
-
-    tracker.restartRequests();
-    verify(request).pause();
-  }
-
-  @Test
-  public void testDoesNotBeginIncompleteRequestsOnRestartIfPaused() {
-    Request request = mock(Request.class);
-    when(request.isFailed()).thenReturn(false);
-    when(request.isComplete()).thenReturn(false);
-    tracker.pauseRequests();
-    tracker.addRequest(request);
-    tracker.restartRequests();
-
-    verify(request, never()).begin();
-  }
-
-  @Test
-  public void testPausesIncompleteRequestsOnRestartIfPaused() {
-    Request request = mock(Request.class);
-    when(request.isFailed()).thenReturn(false);
-    when(request.isComplete()).thenReturn(false);
-    tracker.pauseRequests();
-    tracker.addRequest(request);
-    tracker.restartRequests();
-
-    verify(request).pause();
-  }
-
-  @Test
-  public void testReturnsTrueFromIsPausedWhenPaused() {
-    tracker.pauseRequests();
-    assertTrue(tracker.isPaused());
-  }
-
-  @Test
-  public void testReturnsFalseFromIsPausedWhenResumed() {
-    tracker.resumeRequests();
-    assertFalse(tracker.isPaused());
-  }
-
-  private class ClearAndRemoveRequest implements Answer<Void> {
-
-    private Request toRemove;
-
-    public ClearAndRemoveRequest(Request toRemove) {
-      this.toRemove = toRemove;
-    }
-
-    @Override
-    public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-      tracker.clearRemoveAndRecycle(toRemove);
-      return null;
-    }
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java b/library/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java
deleted file mode 100644
index 2d90667a3..000000000
--- a/library/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java
+++ /dev/null
@@ -1,259 +0,0 @@
-package com.bumptech.glide.request;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import android.app.Application;
-import android.graphics.Bitmap;
-import android.graphics.Color;
-import android.graphics.drawable.ColorDrawable;
-import android.graphics.drawable.Drawable;
-import android.graphics.drawable.GradientDrawable;
-import com.bumptech.glide.Priority;
-import com.bumptech.glide.load.MultiTransformation;
-import com.bumptech.glide.load.Option;
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.engine.DiskCacheStrategy;
-import com.bumptech.glide.load.resource.bitmap.CenterCrop;
-import com.bumptech.glide.load.resource.bitmap.CircleCrop;
-import com.bumptech.glide.signature.ObjectKey;
-import com.bumptech.glide.util.Util;
-import com.google.common.testing.EqualsTester;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE)
-public class RequestOptionsTest {
-
-  private RequestOptions options;
-  @Mock private Transformation<Bitmap> transformation;
-  private Application app;
-
-  @Before
-  public void setUp() {
-    MockitoAnnotations.initMocks(this);
-    options = new RequestOptions();
-
-    app = RuntimeEnvironment.application;
-  }
-
-  @Test
-  public void testIsTransformationRequired_byDefault_isFalse() {
-    assertThat(options.isTransformationRequired()).isFalse();
-  }
-
-  @Test
-  public void testIsTransformationSet_byDefault_isFalse() {
-    assertThat(options.isTransformationSet()).isFalse();
-  }
-
-  @Test
-  public void testIsTransformationAllowed_byDefault_isTrue() {
-    assertThat(options.isTransformationAllowed()).isTrue();
-  }
-
-  @Test
-  public void testIsTransformationSet_afterApplyingOptionsWithTransform_isTrue() {
-    RequestOptions other = new RequestOptions();
-    other.transform(Bitmap.class, transformation);
-    options.apply(other);
-    assertThat(options.isTransformationSet()).isTrue();
-  }
-
-  @Test
-  public void testIsTransformationSet_afterDontTransform_isFalse() {
-    options.dontTransform();
-    assertThat(options.isTransformationSet()).isFalse();
-  }
-
-  @Test
-  public void testIsTransformationAllowed_afterDontTransform_isFalse() {
-    options.dontTransform();
-    assertThat(options.isTransformationAllowed()).isFalse();
-  }
-
-  @Test
-  public void testIsTransformationRequired_afterDontTransform_isFalse() {
-    options.dontTransform();
-    assertThat(options.isTransformationRequired()).isFalse();
-  }
-
-  @Test
-  public void testApplyingDontTransform_overridesTransformations() {
-    options.transform(transformation);
-    options.dontTransform();
-    assertThat(options.isTransformationSet()).isFalse();
-    assertThat(options.isTransformationRequired()).isFalse();
-    assertThat(options.getTransformations()).isEmpty();
-  }
-
-  @Test
-  public void testApplyingTransformation_overridesDontTransform() {
-    options.dontTransform();
-    options.transform(transformation);
-
-    assertThat(options.isTransformationAllowed()).isTrue();
-    assertThat(options.isTransformationRequired()).isTrue();
-    assertThat(options.getTransformations()).containsEntry(Bitmap.class, transformation);
-  }
-
-  @Test
-  public void testApplyingOptions_withDontTransform_overridesTransformations() {
-    options.transform(transformation);
-    RequestOptions other = new RequestOptions();
-    other.dontTransform();
-
-    options.apply(other);
-
-    assertThat(options.isTransformationAllowed()).isFalse();
-    assertThat(options.isTransformationSet()).isFalse();
-    assertThat(options.isTransformationRequired()).isFalse();
-    assertThat(options.getTransformations()).isEmpty();
-  }
-
-  @Test
-  public void testApplyingOptions_withTransformation_overridesDontTransform() {
-    options.dontTransform();
-    RequestOptions other = new RequestOptions();
-    other.transform(transformation);
-
-    options.apply(other);
-
-    assertThat(options.isTransformationAllowed()).isTrue();
-    assertThat(options.isTransformationSet()).isTrue();
-    assertThat(options.isTransformationRequired()).isTrue();
-    assertThat(options.getTransformations()).containsEntry(Bitmap.class, transformation);
-  }
-
-  @Test
-  public void testApplyingDefaultOptions_withDontTransform_retainsDontTransform() {
-    options.dontTransform();
-    options.apply(new RequestOptions());
-
-    assertThat(options.isTransformationAllowed()).isFalse();
-    assertThat(options.isTransformationRequired()).isFalse();
-    assertThat(options.getTransformations()).isEmpty();
-  }
-
-  @Test
-  public void testApplyingDefaultOptions_withTransform_retrainsTransform() {
-    options.transform(transformation);
-    options.apply(new RequestOptions());
-
-    assertThat(options.isTransformationAllowed()).isTrue();
-    assertThat(options.isTransformationRequired()).isTrue();
-    assertThat(options.getTransformations()).containsEntry(Bitmap.class, transformation);
-  }
-
-  @Test
-  public void testApplyMultiTransform() {
-    options.transforms(new CircleCrop(), new CenterCrop());
-    assertThat(options.isTransformationRequired()).isTrue();
-    assertThat(options.getTransformations()).containsKey(Bitmap.class);
-    assertThat(options.getTransformations().get(Bitmap.class))
-      .isInstanceOf(MultiTransformation.class);
-  }
-
-  @Test
-  public void testEqualsHashCode() {
-    Drawable first = new ColorDrawable(Color.RED);
-    Drawable second = new GradientDrawable();
-    assertThat(first).isNotEqualTo(second);
-    assertThat(Util.bothNullOrEqual(first, second)).isFalse();
-    new EqualsTester()
-        .addEqualityGroup(
-            new RequestOptions().sizeMultiplier(.7f),
-            new RequestOptions().sizeMultiplier(.7f))
-        .addEqualityGroup(new RequestOptions().sizeMultiplier(0.8f))
-        .addEqualityGroup(new RequestOptions().error(1), new RequestOptions().error(1))
-        .addEqualityGroup(new RequestOptions().error(2))
-        .addEqualityGroup(new RequestOptions().error(first), new RequestOptions().error(first))
-        .addEqualityGroup(new RequestOptions().error(second))
-        .addEqualityGroup(new RequestOptions().placeholder(1), new RequestOptions().placeholder(1))
-        .addEqualityGroup(new RequestOptions().placeholder(2))
-        .addEqualityGroup(
-            new RequestOptions().placeholder(first),
-            new RequestOptions().placeholder(first))
-        .addEqualityGroup(new RequestOptions().placeholder(second))
-        .addEqualityGroup(new RequestOptions().fallback(1), new RequestOptions().fallback(1))
-        .addEqualityGroup(new RequestOptions().fallback(2))
-        .addEqualityGroup(
-            new RequestOptions().fallback(first),
-            new RequestOptions().fallback(first))
-        .addEqualityGroup(new RequestOptions().fallback(second))
-        .addEqualityGroup(
-            new RequestOptions().skipMemoryCache(true),
-            new RequestOptions().skipMemoryCache(true))
-        .addEqualityGroup(
-            new RequestOptions(),
-            new RequestOptions().skipMemoryCache(false),
-            new RequestOptions().theme(null),
-            new RequestOptions().onlyRetrieveFromCache(false),
-            new RequestOptions().useUnlimitedSourceGeneratorsPool(false))
-        .addEqualityGroup(
-            new RequestOptions().override(100),
-            new RequestOptions().override(100, 100))
-        .addEqualityGroup(
-            new RequestOptions().override(200),
-            new RequestOptions().override(200, 200))
-        .addEqualityGroup(
-            new RequestOptions().override(100, 200),
-            new RequestOptions().override(100, 200))
-        .addEqualityGroup(
-            new RequestOptions().override(200, 100),
-            new RequestOptions().override(200, 100))
-        .addEqualityGroup(
-            new RequestOptions().centerCrop(),
-            new RequestOptions().centerCrop())
-        .addEqualityGroup(
-            new RequestOptions().optionalCenterCrop(),
-            new RequestOptions().optionalCenterCrop())
-        .addEqualityGroup(new RequestOptions().fitCenter())
-        .addEqualityGroup(new RequestOptions().circleCrop())
-        .addEqualityGroup(new RequestOptions().centerInside())
-        .addEqualityGroup(
-            new RequestOptions().useUnlimitedSourceGeneratorsPool(true),
-            new RequestOptions().useUnlimitedSourceGeneratorsPool(true))
-        .addEqualityGroup(
-            new RequestOptions().onlyRetrieveFromCache(true),
-            new RequestOptions().onlyRetrieveFromCache(true))
-        .addEqualityGroup(
-            new RequestOptions().diskCacheStrategy(DiskCacheStrategy.ALL),
-            new RequestOptions().diskCacheStrategy(DiskCacheStrategy.ALL))
-        .addEqualityGroup(
-            new RequestOptions().diskCacheStrategy(DiskCacheStrategy.NONE))
-        .addEqualityGroup(
-            new RequestOptions().priority(Priority.HIGH),
-            new RequestOptions().priority(Priority.HIGH))
-        .addEqualityGroup(
-            new RequestOptions().priority(Priority.LOW))
-        .addEqualityGroup(
-            new RequestOptions().set(Option.<Boolean>memory("test"), true),
-            new RequestOptions().set(Option.<Boolean>memory("test"), true))
-        .addEqualityGroup(
-            new RequestOptions().set(Option.<Boolean>memory("test"), false))
-        .addEqualityGroup(
-            new RequestOptions().set(Option.<Boolean>memory("test2"), true))
-        .addEqualityGroup(
-            new RequestOptions().decode(Integer.class),
-            new RequestOptions().decode(Integer.class))
-        .addEqualityGroup(
-            new RequestOptions().decode(Float.class))
-        .addEqualityGroup(
-            new RequestOptions().signature(new ObjectKey("test")),
-            new RequestOptions().signature(new ObjectKey("test")))
-        .addEqualityGroup(
-            new RequestOptions().signature(new ObjectKey("test2")))
-        .addEqualityGroup(
-            new RequestOptions().theme(app.getTheme()),
-            new RequestOptions().theme(app.getTheme()))
-        .testEquals();
-  }
-
-}
diff --git a/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java b/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
deleted file mode 100644
index dec114f4d..000000000
--- a/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
+++ /dev/null
@@ -1,917 +0,0 @@
-package com.bumptech.glide.request;
-
-import static com.bumptech.glide.tests.Util.isADataSource;
-import static com.bumptech.glide.tests.Util.mockResource;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyBoolean;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Matchers.isA;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Color;
-import android.graphics.drawable.ColorDrawable;
-import android.graphics.drawable.Drawable;
-import com.bumptech.glide.GlideContext;
-import com.bumptech.glide.Priority;
-import com.bumptech.glide.load.DataSource;
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.engine.DiskCacheStrategy;
-import com.bumptech.glide.load.engine.Engine;
-import com.bumptech.glide.load.engine.GlideException;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.request.target.SizeReadyCallback;
-import com.bumptech.glide.request.target.Target;
-import com.bumptech.glide.request.transition.Transition;
-import com.bumptech.glide.request.transition.TransitionFactory;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
-@SuppressWarnings("rawtypes")
-public class SingleRequestTest {
-  private RequestHarness harness = new RequestHarness();
-
-  /**
-   * {@link Number} and {@link List} are arbitrarily chosen types to test some type safety as well.
-   * Both are in the middle of the hierarchy having multiple descendants and ancestors.
-   */
-  private static class RequestHarness {
-    Engine engine = mock(Engine.class);
-    Number model = 123456;
-    @SuppressWarnings("unchecked")
-    Target<List> target = mock(Target.class);
-    Resource<List> resource = mockResource();
-    RequestCoordinator requestCoordinator = mock(RequestCoordinator.class);
-    Drawable placeholderDrawable = null;
-    Drawable errorDrawable = null;
-    Drawable fallbackDrawable = null;
-    @SuppressWarnings("unchecked")
-    RequestListener<List> requestListener = mock(RequestListener.class);
-    @SuppressWarnings("unchecked")
-    TransitionFactory<List> factory = mock(TransitionFactory.class);
-    int overrideWidth = -1;
-    int overrideHeight = -1;
-    List<?> result = new ArrayList<>();
-    GlideContext glideContext = mock(GlideContext.class);
-    Key signature = mock(Key.class);
-    Priority priority = Priority.HIGH;
-    boolean useUnlimitedSourceGeneratorsPool = false;
-    Class<List> transcodeClass = List.class;
-
-    Map<Class<?>, Transformation<?>>  transformations = new HashMap<>();
-
-    public RequestHarness() {
-      when(requestCoordinator.canSetImage(any(Request.class))).thenReturn(true);
-      when(requestCoordinator.canNotifyStatusChanged(any(Request.class))).thenReturn(true);
-      when(resource.get()).thenReturn(result);
-    }
-
-    public SingleRequest<List> getRequest() {
-       RequestOptions requestOptions = new RequestOptions()
-        .error(errorDrawable)
-        .placeholder(placeholderDrawable)
-        .fallback(fallbackDrawable)
-        .override(overrideWidth, overrideHeight)
-        .priority(priority)
-        .signature(signature)
-        .useUnlimitedSourceGeneratorsPool(useUnlimitedSourceGeneratorsPool);
-      return SingleRequest
-          .obtain(glideContext, model, transcodeClass, requestOptions, overrideWidth,
-              overrideHeight, priority, target, requestListener, requestCoordinator, engine,
-              factory);
-    }
-  }
-
-  @Before
-  public void setUp() {
-    harness = new RequestHarness();
-  }
-
-  @Test
-  public void testIsNotCompleteBeforeReceivingResource() {
-    SingleRequest<List> request = harness.getRequest();
-
-    assertFalse(request.isComplete());
-  }
-
-  @Test
-  public void testCanHandleNullResources() {
-    SingleRequest<List> request = harness.getRequest();
-
-    request.onResourceReady(null, DataSource.LOCAL);
-
-    assertTrue(request.isFailed());
-    verify(harness.requestListener).onLoadFailed(isAGlideException(), isA(Number.class),
-        eq(harness.target), anyBoolean());
-  }
-
-  @Test
-  public void testCanHandleEmptyResources() {
-    SingleRequest<List> request = harness.getRequest();
-    when(harness.resource.get()).thenReturn(null);
-
-    request.onResourceReady(harness.resource, DataSource.REMOTE);
-
-    assertTrue(request.isFailed());
-    verify(harness.engine).release(eq(harness.resource));
-    verify(harness.requestListener).onLoadFailed(isAGlideException(), any(Number.class),
-        eq(harness.target), anyBoolean());
-  }
-
-  @Test
-  public void testCanHandleNonConformingResources() {
-    SingleRequest<List> request = harness.getRequest();
-    when(((Resource) (harness.resource)).get())
-        .thenReturn("Invalid mocked String, this should be a List");
-
-    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
-
-    assertTrue(request.isFailed());
-    verify(harness.engine).release(eq(harness.resource));
-    verify(harness.requestListener).onLoadFailed(isAGlideException(), any(Number.class),
-        eq(harness.target), anyBoolean());
-  }
-
-  @Test
-  public void testIsNotFailedAfterClear() {
-    SingleRequest<List> request = harness.getRequest();
-
-    request.onResourceReady(null, DataSource.DATA_DISK_CACHE);
-    request.clear();
-
-    assertFalse(request.isFailed());
-  }
-
-  @Test
-  public void testIsPausedAfterPause() {
-    SingleRequest<List> request = harness.getRequest();
-    request.pause();
-
-    assertTrue(request.isPaused());
-  }
-
-  @Test
-  public void testIsNotCancelledAfterPause() {
-    SingleRequest<List> request = harness.getRequest();
-    request.pause();
-
-    assertFalse(request.isCancelled());
-  }
-
-  @Test
-  public void testIsNotPausedAfterBeginningWhilePaused() {
-    SingleRequest<List> request = harness.getRequest();
-    request.pause();
-    request.begin();
-
-    assertFalse(request.isPaused());
-    assertTrue(request.isRunning());
-  }
-
-  @Test
-  public void testIsNotFailedAfterBegin() {
-    SingleRequest<List> request = harness.getRequest();
-
-    request.onResourceReady(null, DataSource.DATA_DISK_CACHE);
-    request.begin();
-
-    assertFalse(request.isFailed());
-  }
-
-  @Test
-  public void testIsCompleteAfterReceivingResource() {
-    SingleRequest<List> request = harness.getRequest();
-
-    request.onResourceReady(harness.resource, DataSource.LOCAL);
-
-    assertTrue(request.isComplete());
-  }
-
-  @Test
-  public void testIsNotCompleteAfterClear() {
-    SingleRequest<List> request = harness.getRequest();
-    request.onResourceReady(harness.resource, DataSource.REMOTE);
-    request.clear();
-
-    assertFalse(request.isComplete());
-  }
-
-  @Test
-  public void testIsCancelledAfterClear() {
-    SingleRequest<List> request = harness.getRequest();
-    request.clear();
-
-    assertTrue(request.isCancelled());
-  }
-
-  @Test
-  public void testDoesNotNotifyTargetTwiceIfClearedTwiceInARow() {
-    SingleRequest<List> request = harness.getRequest();
-    request.clear();
-    request.clear();
-
-    verify(harness.target, times(1)).onLoadCleared(any(Drawable.class));
-  }
-
-  @Test
-  public void testResourceIsNotCompleteWhenAskingCoordinatorIfCanSetImage() {
-    RequestCoordinator requestCoordinator = mock(RequestCoordinator.class);
-    doAnswer(new Answer() {
-      @Override
-      public Object answer(InvocationOnMock invocation) throws Throwable {
-        Request request = (Request) invocation.getArguments()[0];
-        assertFalse(request.isComplete());
-        return true;
-      }
-    }).when(requestCoordinator).canSetImage(any(Request.class));
-
-    harness.requestCoordinator = requestCoordinator;
-    SingleRequest<List> request = harness.getRequest();
-
-    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
-
-    verify(requestCoordinator).canSetImage(eq(request));
-  }
-
-  @Test
-  public void testIsNotFailedWithoutException() {
-    SingleRequest<List> request = harness.getRequest();
-
-    assertFalse(request.isFailed());
-  }
-
-  @Test
-  public void testIsFailedAfterException() {
-    SingleRequest<List> request = harness.getRequest();
-
-    request.onLoadFailed(new GlideException("test"));
-    assertTrue(request.isFailed());
-  }
-
-  @Test
-  public void testIgnoresOnSizeReadyIfNotWaitingForSize() {
-    SingleRequest<List> request = harness.getRequest();
-    request.begin();
-    request.onSizeReady(100, 100);
-    request.onSizeReady(100, 100);
-
-    verify(harness.engine, times(1))
-        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), eq(100), eq(100),
-            eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),
-            eq(harness.transformations), anyBoolean(), any(Options.class),
-            anyBoolean(), anyBoolean(), anyBoolean(), any(ResourceCallback.class));
-  }
-
-  @Test
-  public void testIsFailedAfterNoResultAndNullException() {
-    SingleRequest<List> request = harness.getRequest();
-
-    request.onLoadFailed(new GlideException("test"));
-    assertTrue(request.isFailed());
-  }
-
-  @Test
-  public void testEngineLoadCancelledOnCancel() {
-    Engine.LoadStatus loadStatus = mock(Engine.LoadStatus.class);
-
-    when(harness.engine
-       .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(), anyInt(),
-          eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),
-          eq(harness.transformations), anyBoolean(), any(Options.class),
-          anyBoolean(), anyBoolean(), anyBoolean(), any(ResourceCallback.class)))
-        .thenReturn(loadStatus);
-
-    SingleRequest<List> request = harness.getRequest();
-    request.begin();
-
-    request.onSizeReady(100, 100);
-    request.cancel();
-
-    verify(loadStatus).cancel();
-  }
-
-  @Test
-  public void testResourceIsRecycledOnClear() {
-    SingleRequest<List> request = harness.getRequest();
-
-    request.onResourceReady(harness.resource, DataSource.REMOTE);
-    request.clear();
-
-    verify(harness.engine).release(eq(harness.resource));
-  }
-
-  @Test
-  public void testPlaceholderDrawableIsSet() {
-    Drawable expected = new ColorDrawable(Color.RED);
-
-    MockTarget target = new MockTarget();
-
-    harness.placeholderDrawable = expected;
-    harness.target = target;
-    SingleRequest<List> request = harness.getRequest();
-    request.begin();
-
-    assertEquals(expected, target.currentPlaceholder);
-  }
-
-  @Test
-  public void testErrorDrawableIsSetOnLoadFailed() {
-    Drawable expected = new ColorDrawable(Color.RED);
-
-    MockTarget target = new MockTarget();
-
-    harness.errorDrawable = expected;
-    harness.target = target;
-    SingleRequest<List> request = harness.getRequest();
-
-    request.onLoadFailed(new GlideException("test"));
-
-    assertEquals(expected, target.currentPlaceholder);
-  }
-
-  @Test
-  public void testPlaceholderDrawableSetOnNullModelWithNoErrorDrawable() {
-    Drawable placeholder = new ColorDrawable(Color.RED);
-
-    MockTarget target = new MockTarget();
-
-    harness.errorDrawable = placeholder;
-    harness.target = target;
-    harness.model = null;
-    SingleRequest<List> request = harness.getRequest();
-
-    request.begin();
-
-    assertEquals(placeholder, target.currentPlaceholder);
-  }
-
-  @Test
-  public void testErrorDrawableSetOnNullModelWithErrorDrawable() {
-    Drawable placeholder = new ColorDrawable(Color.RED);
-    Drawable errorPlaceholder = new ColorDrawable(Color.GREEN);
-
-    MockTarget target = new MockTarget();
-
-    harness.placeholderDrawable = placeholder;
-    harness.errorDrawable = errorPlaceholder;
-    harness.target = target;
-    harness.model = null;
-    SingleRequest<List> request = harness.getRequest();
-
-    request.begin();
-
-    assertEquals(errorPlaceholder, target.currentPlaceholder);
-  }
-
-
-  @Test
-  public void testFallbackDrawableSetOnNullModelWithErrorAndFallbackDrawables() {
-    Drawable placeholder = new ColorDrawable(Color.RED);
-    Drawable errorPlaceholder = new ColorDrawable(Color.GREEN);
-    Drawable fallback = new ColorDrawable(Color.BLUE);
-
-    MockTarget target = new MockTarget();
-    harness.placeholderDrawable = placeholder;
-    harness.errorDrawable = errorPlaceholder;
-    harness.fallbackDrawable = fallback;
-    harness.target = target;
-    harness.model = null;
-    SingleRequest<List> request = harness.getRequest();
-    request.begin();
-    assertEquals(fallback, target.currentPlaceholder);
-  }
-
-
-  @Test
-  public void testIsNotRunningBeforeRunCalled() {
-    assertFalse(harness.getRequest().isRunning());
-  }
-
-  @Test
-  public void testIsRunningAfterRunCalled() {
-    Request request = harness.getRequest();
-    request.begin();
-    assertTrue(request.isRunning());
-  }
-
-  @Test
-  public void testIsNotRunningAfterComplete() {
-    SingleRequest<List> request = harness.getRequest();
-    request.begin();
-    request.onResourceReady(harness.resource, DataSource.REMOTE);
-
-    assertFalse(request.isRunning());
-  }
-
-  @Test
-  public void testIsNotRunningAfterFailing() {
-    SingleRequest<List> request = harness.getRequest();
-    request.begin();
-    request.onLoadFailed(new GlideException("test"));
-
-    assertFalse(request.isRunning());
-  }
-
-  @Test
-  public void testIsNotRunningAfterClear() {
-    SingleRequest<List> request = harness.getRequest();
-    request.begin();
-    request.clear();
-
-    assertFalse(request.isRunning());
-  }
-
-  @Test
-  public void testCallsTargetOnResourceReadyIfNoRequestListener() {
-    harness.requestListener = null;
-    SingleRequest<List> request = harness.getRequest();
-    request.onResourceReady(harness.resource, DataSource.LOCAL);
-
-    verify(harness.target).onResourceReady(eq(harness.result), anyTransition());
-  }
-
-  @Test
-  public void testCallsTargetOnResourceReadyIfRequestListenerReturnsFalse() {
-    SingleRequest<List> request = harness.getRequest();
-    when(harness.requestListener
-        .onResourceReady(any(List.class), any(Number.class), eq(harness.target), isADataSource(),
-            anyBoolean())).thenReturn(false);
-    request.onResourceReady(harness.resource, DataSource.LOCAL);
-
-    verify(harness.target).onResourceReady(eq(harness.result), anyTransition());
-  }
-
-  @Test
-  public void testDoesNotCallTargetOnResourceReadyIfRequestListenerReturnsTrue() {
-    SingleRequest<List> request = harness.getRequest();
-    when(harness.requestListener
-        .onResourceReady(any(List.class), any(Number.class), eq(harness.target), isADataSource(),
-            anyBoolean())).thenReturn(true);
-    request.onResourceReady(harness.resource, DataSource.REMOTE);
-
-    verify(harness.target, never()).onResourceReady(any(List.class), anyTransition());
-  }
-
-  @Test
-  public void testCallsTargetOnExceptionIfNoRequestListener() {
-    harness.requestListener = null;
-    SingleRequest<List> request = harness.getRequest();
-    request.onLoadFailed(new GlideException("test"));
-
-    verify(harness.target).onLoadFailed(eq(harness.errorDrawable));
-  }
-
-  @Test
-  public void testCallsTargetOnExceptionIfRequestListenerReturnsFalse() {
-    SingleRequest<List> request = harness.getRequest();
-    when(harness.requestListener.onLoadFailed(isAGlideException(), any(Number.class),
-        eq(harness.target), anyBoolean()))
-        .thenReturn(false);
-    request.onLoadFailed(new GlideException("test"));
-
-    verify(harness.target).onLoadFailed(eq(harness.errorDrawable));
-  }
-
-  @Test
-  public void testDoesNotCallTargetOnExceptionIfRequestListenerReturnsTrue() {
-    SingleRequest<List> request = harness.getRequest();
-    when(harness.requestListener.onLoadFailed(isAGlideException(), any(Number.class),
-        eq(harness.target), anyBoolean()))
-        .thenReturn(true);
-
-    request.onLoadFailed(new GlideException("test"));
-
-    verify(harness.target, never()).onLoadFailed(any(Drawable.class));
-  }
-
-  @Test
-  public void testRequestListenerIsCalledWithResourceResult() {
-    SingleRequest<List> request = harness.getRequest();
-    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
-
-    verify(harness.requestListener)
-        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(), isADataSource(),
-            anyBoolean());
-  }
-
-  @Test
-  public void testRequestListenerIsCalledWithModel() {
-    SingleRequest<List> request = harness.getRequest();
-    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
-
-    verify(harness.requestListener)
-        .onResourceReady(any(List.class), eq(harness.model), isAListTarget(), isADataSource(),
-            anyBoolean());
-  }
-
-  @Test
-  public void testRequestListenerIsCalledWithTarget() {
-    SingleRequest<List> request = harness.getRequest();
-    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
-
-    verify(harness.requestListener)
-        .onResourceReady(any(List.class), any(Number.class), eq(harness.target), isADataSource(),
-            anyBoolean());
-  }
-
-  @Test
-  public void testRequestListenerIsCalledWithLoadedFromMemoryIfLoadCompletesSynchronously() {
-    final SingleRequest<List> request = harness.getRequest();
-
-    when(harness.engine
-        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
-            anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
-            any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            any(Options.class), anyBoolean(), anyBoolean(), anyBoolean(),
-            any(ResourceCallback.class)))
-        .thenAnswer(new Answer<Object>() {
-          @Override
-          public Object answer(InvocationOnMock invocation) throws Throwable {
-            request.onResourceReady(harness.resource, DataSource.MEMORY_CACHE);
-            return null;
-          }
-        });
-
-    request.begin();
-    request.onSizeReady(100, 100);
-    verify(harness.requestListener)
-        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(),
-            eq(DataSource.MEMORY_CACHE), anyBoolean());
-  }
-
-  @Test
-  public void
-  testRequestListenerIsCalledWithNotLoadedFromMemoryCacheIfLoadCompletesAsynchronously() {
-    SingleRequest<List> request = harness.getRequest();
-    request.onSizeReady(100, 100);
-    request.onResourceReady(harness.resource, DataSource.LOCAL);
-
-    verify(harness.requestListener)
-        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(),
-            eq(DataSource.LOCAL), anyBoolean());
-  }
-
-  @Test
-  public void testRequestListenerIsCalledWithIsFirstResourceIfNoRequestCoordinator() {
-    harness.requestCoordinator = null;
-    SingleRequest<List> request = harness.getRequest();
-    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
-
-    verify(harness.requestListener)
-        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(), isADataSource(),
-            eq(true));
-  }
-
-  @Test
-  public void testRequestListenerIsCalledWithFirstImageIfRequestCoordinatorReturnsNoResourceSet() {
-    SingleRequest<List> request = harness.getRequest();
-    when(harness.requestCoordinator.isAnyResourceSet()).thenReturn(false);
-    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
-
-    verify(harness.requestListener)
-        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(), isADataSource(),
-            eq(true));
-  }
-
-  @Test
-  public void
-  testRequestListenerIsCalledWithNotIsFirstRequestIfRequestCoordinatorReturnsResourceSet() {
-    SingleRequest<List> request = harness.getRequest();
-    when(harness.requestCoordinator.isAnyResourceSet()).thenReturn(true);
-    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
-
-    verify(harness.requestListener)
-        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(),
-            isADataSource(), eq(false));
-  }
-
-  @Test
-  public void testTargetIsCalledWithAnimationFromFactory() {
-    SingleRequest<List> request = harness.getRequest();
-    Transition<List> transition = mockTransition();
-    when(harness.factory.build(any(DataSource.class), anyBoolean())).thenReturn(transition);
-    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
-
-    verify(harness.target).onResourceReady(eq(harness.result), eq(transition));
-  }
-
-  @Test
-  public void testCallsGetSizeIfOverrideWidthIsLessThanZero() {
-    harness.overrideWidth = -1;
-    harness.overrideHeight = 100;
-    SingleRequest<List> request = harness.getRequest();
-    request.begin();
-
-    verify(harness.target).getSize(any(SizeReadyCallback.class));
-  }
-
-  @Test
-  public void testCallsGetSizeIfOverrideHeightIsLessThanZero() {
-    harness.overrideHeight = -1;
-    harness.overrideWidth = 100;
-    SingleRequest<List> request = harness.getRequest();
-    request.begin();
-
-    verify(harness.target).getSize(any(SizeReadyCallback.class));
-  }
-
-  @Test
-  public void testDoesNotCallGetSizeIfOverrideWidthAndHeightAreSet() {
-    harness.overrideWidth = 100;
-    harness.overrideHeight = 100;
-    SingleRequest<List> request = harness.getRequest();
-    request.begin();
-
-    verify(harness.target, never()).getSize(any(SizeReadyCallback.class));
-  }
-
-  @Test
-  public void testCallsEngineWithOverrideWidthAndHeightIfSet() {
-    harness.overrideWidth = 1;
-    harness.overrideHeight = 2;
-
-    SingleRequest<List> request = harness.getRequest();
-    request.begin();
-
-    verify(harness.engine)
-        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
-            anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
-            any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            any(Options.class), anyBoolean(), anyBoolean(), anyBoolean(),
-            any(ResourceCallback.class));
-  }
-
-  @Test
-  public void testDoesNotSetErrorDrawableIfRequestCoordinatorDoesntAllowIt() {
-    harness.errorDrawable = new ColorDrawable(Color.RED);
-    SingleRequest<List> request = harness.getRequest();
-    when(harness.requestCoordinator.canNotifyStatusChanged(any(Request.class))).thenReturn(false);
-    request.onLoadFailed(new GlideException("test"));
-
-    verify(harness.target, never()).onLoadFailed(any(Drawable.class));
-  }
-
-  @Test
-  public void testCanReRunCancelledRequests() {
-    doAnswer(new CallSizeReady(100, 100)).when(harness.target)
-        .getSize(any(SizeReadyCallback.class));
-
-    when(harness.engine
-        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), eq(100), eq(100),
-            eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),
-            eq(harness.transformations), anyBoolean(), any(Options.class),
-            anyBoolean(), anyBoolean(), anyBoolean(), any(ResourceCallback.class)))
-        .thenAnswer(new CallResourceCallback(harness.resource));
-    SingleRequest<List> request = harness.getRequest();
-
-    request.begin();
-    request.cancel();
-    request.begin();
-
-    verify(harness.target, times(2)).onResourceReady(eq(harness.result), anyTransition());
-  }
-
-  @Test
-  public void testResourceOnlyReceivesOneGetOnResourceReady() {
-    SingleRequest<List> request = harness.getRequest();
-    request.onResourceReady(harness.resource, DataSource.LOCAL);
-
-    verify(harness.resource, times(1)).get();
-  }
-
-  @Test
-  public void testDoesNotStartALoadIfOnSizeReadyIsCalledAfterCancel() {
-    SingleRequest<List> request = harness.getRequest();
-    request.cancel();
-    request.onSizeReady(100, 100);
-
-    verify(harness.engine, never())
-        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
-            anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
-            any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            any(Options.class), anyBoolean(), anyBoolean(), anyBoolean(),
-            any(ResourceCallback.class));
-  }
-
-
-  @Test
-  public void testCallsSourceUnlimitedExecutorEngineIfOptionsIsSet() {
-    doAnswer(new CallSizeReady(100, 100)).when(harness.target)
-        .getSize(any(SizeReadyCallback.class));
-
-    harness.useUnlimitedSourceGeneratorsPool = true;
-
-    SingleRequest<List> request = harness.getRequest();
-    request.begin();
-
-    verify(harness.engine)
-        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
-            anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
-            any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            any(Options.class), anyBoolean(), eq(Boolean.TRUE), anyBoolean(),
-            any(ResourceCallback.class));
-  }
-
-  @Test
-  public void testCallsSourceExecutorEngineIfOptionsIsSet() {
-    doAnswer(new CallSizeReady(100, 100)).when(harness.target)
-        .getSize(any(SizeReadyCallback.class));
-
-    harness.useUnlimitedSourceGeneratorsPool = false;
-
-    SingleRequest<List> request = harness.getRequest();
-    request.begin();
-
-    verify(harness.engine)
-        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
-            anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
-            any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            any(Options.class), anyBoolean(), eq(Boolean.FALSE), anyBoolean(),
-            any(ResourceCallback.class));
-  }
-
-  @Test
-  public void testIsEquivalentTo() {
-    SingleRequest<List> originalRequest1 = harness.getRequest();
-    SingleRequest<List> originalRequest2 = harness.getRequest();
-    assertTrue(originalRequest1.isEquivalentTo(originalRequest2));
-
-    harness = new RequestHarness();
-    harness.overrideWidth = harness.overrideWidth * 2;
-    SingleRequest<List> widthRequest = harness.getRequest();
-    assertTrue(widthRequest.isEquivalentTo(widthRequest));
-    assertFalse(widthRequest.isEquivalentTo(originalRequest1));
-    assertFalse(originalRequest1.isEquivalentTo(widthRequest));
-
-    harness = new RequestHarness();
-    harness.overrideHeight = harness.overrideHeight * 2;
-    SingleRequest<List> heightRequest = harness.getRequest();
-    assertTrue(heightRequest.isEquivalentTo(heightRequest));
-    assertFalse(heightRequest.isEquivalentTo(originalRequest1));
-    assertFalse(originalRequest1.isEquivalentTo(heightRequest));
-
-    harness = new RequestHarness();
-    harness.model = 12345679;
-    SingleRequest<List> modelRequest = harness.getRequest();
-    assertTrue(modelRequest.isEquivalentTo(modelRequest));
-    assertFalse(modelRequest.isEquivalentTo(originalRequest1));
-    assertFalse(originalRequest1.isEquivalentTo(modelRequest));
-
-    harness = new RequestHarness();
-    harness.model = null;
-    SingleRequest<List> nullModelRequest = harness.getRequest();
-    assertTrue(nullModelRequest.isEquivalentTo(nullModelRequest));
-    assertFalse(nullModelRequest.isEquivalentTo(originalRequest1));
-    assertFalse(originalRequest1.isEquivalentTo(nullModelRequest));
-
-    harness = new RequestHarness();
-    harness.errorDrawable = new ColorDrawable(Color.GRAY);
-    SingleRequest<List> errorRequest = harness.getRequest();
-    assertTrue(errorRequest.isEquivalentTo(errorRequest));
-    assertFalse(errorRequest.isEquivalentTo(originalRequest1));
-    assertFalse(originalRequest1.isEquivalentTo(errorRequest));
-
-    harness = new RequestHarness();
-    harness.priority = Priority.LOW;
-    SingleRequest<List> priorityRequest = harness.getRequest();
-    assertTrue(priorityRequest.isEquivalentTo(priorityRequest));
-    assertFalse(priorityRequest.isEquivalentTo(originalRequest1));
-    assertFalse(originalRequest1.isEquivalentTo(priorityRequest));
-  }
-
-  // TODO do we want to move these to Util?
-  @SuppressWarnings("unchecked")
-  private static <T> Transition<T> mockTransition() {
-    return mock(Transition.class);
-  }
-
-  @SuppressWarnings("unchecked")
-  private static Target<List> isAListTarget() {
-    return isA(Target.class);
-  }
-
-  private static GlideException isAGlideException() {
-    return isA(GlideException.class);
-  }
-
-  @SuppressWarnings("unchecked")
-  private static <T> Transition<T> anyTransition() {
-    return any(Transition.class);
-  }
-
-  private static class CallResourceCallback implements Answer {
-
-    private Resource resource;
-
-    public CallResourceCallback(Resource resource) {
-      this.resource = resource;
-    }
-
-    @Override
-    public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-      ResourceCallback cb =
-          (ResourceCallback) invocationOnMock.getArguments()[invocationOnMock.getArguments().length
-              - 1];
-      cb.onResourceReady(resource, DataSource.REMOTE);
-      return null;
-    }
-  }
-
-  private static class CallSizeReady implements Answer {
-
-    private int width;
-    private int height;
-
-    public CallSizeReady(int width, int height) {
-      this.width = width;
-      this.height = height;
-    }
-
-    @Override
-    public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-      SizeReadyCallback cb = (SizeReadyCallback) invocationOnMock.getArguments()[0];
-      cb.onSizeReady(width, height);
-      return null;
-    }
-  }
-
-  private static class MockTarget implements Target<List> {
-    private Drawable currentPlaceholder;
-
-    @Override
-    public void onLoadCleared(Drawable placeholder) {
-      currentPlaceholder = placeholder;
-    }
-
-    @Override
-    public void onLoadStarted(Drawable placeholder) {
-      currentPlaceholder = placeholder;
-
-    }
-
-    @Override
-    public void onLoadFailed(Drawable errorDrawable) {
-      currentPlaceholder = errorDrawable;
-
-    }
-
-    @Override
-    public void onResourceReady(List resource, Transition<? super List> transition) {
-      currentPlaceholder = null;
-    }
-
-
-    @Override
-    public void getSize(SizeReadyCallback cb) {
-    }
-
-    @Override
-    public void removeCallback(SizeReadyCallback cb) {
-      // Do nothing.
-    }
-
-    @Override
-    public void setRequest(Request request) {
-    }
-
-    @Override
-    public Request getRequest() {
-      return null;
-    }
-
-    @Override
-    public void onStart() {
-    }
-
-    @Override
-    public void onStop() {
-
-    }
-
-    @Override
-    public void onDestroy() {
-
-    }
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/request/target/CustomViewTargetTest.java b/library/src/test/java/com/bumptech/glide/request/target/CustomViewTargetTest.java
new file mode 100644
index 000000000..899090631
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/request/target/CustomViewTargetTest.java
@@ -0,0 +1,697 @@
+package com.bumptech.glide.request.target;
+
+import static android.view.ViewGroup.LayoutParams;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.app.Activity;
+import android.content.Context;
+import android.graphics.drawable.Drawable;
+import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.view.Display;
+import android.view.View;
+import android.view.View.OnAttachStateChangeListener;
+import android.view.ViewGroup;
+import android.view.ViewTreeObserver;
+import android.view.WindowManager;
+import android.widget.FrameLayout;
+import com.bumptech.glide.request.Request;
+import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.util.Preconditions;
+import com.google.common.truth.Truth;
+import java.util.concurrent.atomic.AtomicInteger;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.Shadows;
+import org.robolectric.android.controller.ActivityController;
+import org.robolectric.annotation.Config;
+import org.robolectric.util.ReflectionHelpers;
+
+/**
+ * Test for {@link CustomViewTarget}.
+ *
+ * TODO: This should really be in the tests subproject, but that causes errors because the R class
+ * referenced in {@link CustomViewTarget} can't be found. This should be fixable with some gradle
+ * changes, but I've so far failed to figure out the right set of commands.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = 19, manifest = "build/intermediates/manifests/full/debug/AndroidManifest.xml")
+public class CustomViewTargetTest {
+  private ActivityController<Activity> activity;
+  private View view;
+  private ViewGroup parent;
+  private CustomViewTarget<View, Object> target;
+  @Mock private SizeReadyCallback cb;
+  @Mock private Request request;
+  private int sdkVersion;
+  private AttachStateTarget attachStateTarget;
+
+  @Before
+  public void setUp() {
+    sdkVersion = Build.VERSION.SDK_INT;
+    MockitoAnnotations.initMocks(this);
+    activity = Robolectric.buildActivity(Activity.class).create().start().postCreate(null).resume();
+    view = new View(activity.get());
+    target = new TestViewTarget(view);
+    attachStateTarget = new AttachStateTarget(view);
+
+    activity.get().setContentView(view);
+    parent = (ViewGroup) view.getParent();
+  }
+
+  @After
+  public void tearDown() {
+    setSdkVersionInt(sdkVersion);
+    CustomViewTarget.SizeDeterminer.maxDisplayLength = null;
+  }
+
+  @Test
+  public void testReturnsWrappedView() {
+    assertEquals(view, target.getView());
+  }
+
+  @Test
+  public void testReturnsNullFromGetRequestIfNoRequestSet() {
+    assertNull(target.getRequest());
+  }
+
+  @Test
+  public void testCanSetAndRetrieveRequest() {
+    target.setRequest(request);
+
+    assertEquals(request, target.getRequest());
+  }
+
+  @Test
+  public void testRetrievesRequestFromPreviousTargetForView() {
+    target.setRequest(request);
+
+    CustomViewTarget<View, Object> second = new TestViewTarget(view);
+
+    assertEquals(request, second.getRequest());
+  }
+
+  @Test
+  public void testSizeCallbackIsCalledSynchronouslyIfViewSizeSet() {
+    int dimens = 333;
+    activity.get().setContentView(view);
+    view.layout(0, 0, dimens, dimens);
+
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(eq(dimens), eq(dimens));
+  }
+
+  @Test
+  public void testSizeCallbackIsCalledSynchronouslyIfLayoutParamsConcreteSizeSet() {
+    int dimens = 444;
+    LayoutParams layoutParams = new FrameLayout.LayoutParams(dimens, dimens);
+    view.setLayoutParams(layoutParams);
+    view.requestLayout();
+
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(eq(dimens), eq(dimens));
+  }
+
+  @Test
+  public void getSize_withBothWrapContent_usesDisplayDimens() {
+    LayoutParams layoutParams =
+        new FrameLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
+    view.setLayoutParams(layoutParams);
+
+    setDisplayDimens(200, 300);
+
+    activity.visible();
+    view.layout(0, 0, 0, 0);
+
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(300, 300);
+  }
+
+  @Test
+  public void getSize_withWrapContentWidthAndValidHeight_usesDisplayDimenAndValidHeight() {
+    int height = 100;
+    LayoutParams params = new FrameLayout.LayoutParams(LayoutParams.WRAP_CONTENT, height);
+    view.setLayoutParams(params);
+
+    setDisplayDimens(100, 200);
+
+    activity.visible();
+    view.setRight(0);
+
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(200, height);
+  }
+
+  @Test
+  public void getSize_withWrapContentHeightAndValidWidth_returnsWidthAndDisplayDimen() {
+    int width = 100;
+    LayoutParams params = new FrameLayout.LayoutParams(width, LayoutParams.WRAP_CONTENT);
+    view.setLayoutParams(params);
+    setDisplayDimens(200, 100);
+    parent.getLayoutParams().height = 200;
+
+    activity.visible();
+
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(width, 200);
+  }
+
+  @Test
+  public void getSize_withWrapContentWidthAndMatchParentHeight_usesDisplayDimenWidthAndHeight() {
+    LayoutParams params =
+        new FrameLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT);
+    view.setLayoutParams(params);
+
+    setDisplayDimens(500, 600);
+
+    target.getSize(cb);
+
+    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+
+    int height = 32;
+    parent.getLayoutParams().height = height;
+    activity.visible();
+
+    view.getViewTreeObserver().dispatchOnPreDraw();
+
+    verify(cb).onSizeReady(600, height);
+  }
+
+  @Test
+  public void getSize_withMatchParentWidthAndWrapContentHeight_usesWidthAndDisplayDimenHeight() {
+    LayoutParams params =
+        new FrameLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
+    view.setLayoutParams(params);
+
+    setDisplayDimens(300, 400);
+
+    target.getSize(cb);
+
+    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+
+    int width = 32;
+    parent.getLayoutParams().width = 32;
+    activity.visible();
+    view.getViewTreeObserver().dispatchOnPreDraw();
+
+    verify(cb).onSizeReady(width, 400);
+  }
+
+  @Test
+  public void testMatchParentWidthAndHeight() {
+    LayoutParams params =
+        new FrameLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
+    view.setLayoutParams(params);
+
+    target.getSize(cb);
+
+    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+
+    int width = 32;
+    int height = 45;
+    parent.getLayoutParams().width = width;
+    parent.getLayoutParams().height = height;
+    activity.visible();
+    view.getViewTreeObserver().dispatchOnPreDraw();
+
+    verify(cb).onSizeReady(eq(width), eq(height));
+  }
+
+  @Test
+  public void testSizeCallbackIsCalledPreDrawIfNoDimensAndNoLayoutParams() {
+    target.getSize(cb);
+
+    int width = 12;
+    int height = 32;
+    parent.getLayoutParams().width = width;
+    parent.getLayoutParams().height = height;
+    activity.visible();
+    view.getViewTreeObserver().dispatchOnPreDraw();
+
+    verify(cb).onSizeReady(eq(width), eq(height));
+  }
+
+  @Test
+  public void testSizeCallbacksAreCalledInOrderPreDraw() {
+    SizeReadyCallback[] cbs = new SizeReadyCallback[25];
+    for (int i = 0; i < cbs.length; i++) {
+      cbs[i] = mock(SizeReadyCallback.class);
+      target.getSize(cbs[i]);
+    }
+
+    int width = 100, height = 111;
+    parent.getLayoutParams().width = width;
+    parent.getLayoutParams().height = height;
+    activity.visible();
+    view.getViewTreeObserver().dispatchOnPreDraw();
+
+    InOrder order = inOrder((Object[]) cbs);
+    for (SizeReadyCallback cb : cbs) {
+      order.verify(cb).onSizeReady(eq(width), eq(height));
+    }
+  }
+
+  @Test
+  public void testDoesNotNotifyCallbackTwiceIfAddedTwice() {
+    target.getSize(cb);
+    target.getSize(cb);
+
+    view.setLayoutParams(new FrameLayout.LayoutParams(100, 100));
+    activity.visible();
+    view.getViewTreeObserver().dispatchOnPreDraw();
+
+    verify(cb, times(1)).onSizeReady(anyInt(), anyInt());
+  }
+
+  @Test
+  public void testDoesNotAddMultipleListenersIfMultipleCallbacksAreAdded() {
+    SizeReadyCallback cb1 = mock(SizeReadyCallback.class);
+    SizeReadyCallback cb2 = mock(SizeReadyCallback.class);
+    target.getSize(cb1);
+    target.getSize(cb2);
+    view.getViewTreeObserver().dispatchOnPreDraw();
+    // assertThat(shadowObserver.getPreDrawListeners()).hasSize(1);
+  }
+
+  @Test
+  public void testDoesAddSecondListenerIfFirstListenerIsRemovedBeforeSecondRequest() {
+    SizeReadyCallback cb1 = mock(SizeReadyCallback.class);
+    target.getSize(cb1);
+
+    view.setLayoutParams(new FrameLayout.LayoutParams(100, 100));
+    activity.visible();
+    view.getViewTreeObserver().dispatchOnPreDraw();
+
+    SizeReadyCallback cb2 = mock(SizeReadyCallback.class);
+    view.setLayoutParams(
+        new FrameLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
+    target.getSize(cb2);
+
+    view.setLayoutParams(new FrameLayout.LayoutParams(100, 100));
+    view.getViewTreeObserver().dispatchOnPreDraw();
+
+    verify(cb2).onSizeReady(anyInt(), anyInt());
+  }
+
+  @Test
+  public void testSizeCallbackIsNotCalledPreDrawIfNoDimensSetOnPreDraw() {
+    target.getSize(cb);
+    view.getViewTreeObserver().dispatchOnPreDraw();
+
+    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+
+    activity.visible();
+    verify(cb).onSizeReady(anyInt(), anyInt());
+  }
+
+  @Test
+  public void testSizeCallbackIsCalledPreDrawIfNoDimensAndNoLayoutParamsButLayoutParamsSetLater() {
+    target.getSize(cb);
+
+    int width = 689;
+    int height = 354;
+    LayoutParams layoutParams = new FrameLayout.LayoutParams(width, height);
+    view.setLayoutParams(layoutParams);
+    view.requestLayout();
+    view.getViewTreeObserver().dispatchOnPreDraw();
+
+    verify(cb).onSizeReady(eq(width), eq(height));
+  }
+
+  @Test
+  public void testCallbackIsNotCalledTwiceIfPreDrawFiresTwice() {
+    activity.visible();
+    target.getSize(cb);
+
+    LayoutParams layoutParams = new FrameLayout.LayoutParams(1234, 4123);
+    view.setLayoutParams(layoutParams);
+    view.requestLayout();
+    view.getViewTreeObserver().dispatchOnPreDraw();
+    view.getViewTreeObserver().dispatchOnPreDraw();
+
+    verify(cb, times(1)).onSizeReady(anyInt(), anyInt());
+  }
+
+  @Test
+  public void testCallbacksFromMultipleRequestsAreNotifiedOnPreDraw() {
+    SizeReadyCallback firstCb = mock(SizeReadyCallback.class);
+    SizeReadyCallback secondCb = mock(SizeReadyCallback.class);
+    target.getSize(firstCb);
+    target.getSize(secondCb);
+
+    int width = 68;
+    int height = 875;
+    LayoutParams layoutParams = new FrameLayout.LayoutParams(width, height);
+    view.setLayoutParams(layoutParams);
+    activity.visible();
+    view.getViewTreeObserver().dispatchOnPreDraw();
+    view.getViewTreeObserver().dispatchOnPreDraw();
+
+    verify(firstCb, times(1)).onSizeReady(eq(width), eq(height));
+    verify(secondCb, times(1)).onSizeReady(eq(width), eq(height));
+  }
+
+  @Test
+  public void testDoesNotThrowOnPreDrawIfViewTreeObserverIsDead() {
+    target.getSize(cb);
+
+    int width = 1;
+    int height = 2;
+    LayoutParams layoutParams = new FrameLayout.LayoutParams(width, height);
+    view.setLayoutParams(layoutParams);
+    ViewTreeObserver vto = view.getViewTreeObserver();
+    view.requestLayout();
+    activity.visible();
+    assertFalse(vto.isAlive());
+    vto.dispatchOnPreDraw();
+
+    verify(cb).onSizeReady(eq(width), eq(height));
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void testThrowsIfGivenNullView() {
+    new TestViewTarget(null);
+  }
+
+  @Test
+  public void testDecreasesDimensionsByViewPadding() {
+    activity.visible();
+    view.setLayoutParams(new FrameLayout.LayoutParams(100, 100));
+    view.setPadding(25, 25, 25, 25);
+    view.requestLayout();
+
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(50, 50);
+  }
+
+  @Test
+  public void getSize_withValidWidthAndHeight_notLaidOut_notLayoutRequested_callsSizeReady() {
+    view.setRight(100);
+    view.setBottom(100);
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(100, 100);
+  }
+
+  @Test
+  public void getSize_withLayoutParams_notLaidOut_doesCallSizeReady() {
+    view.setLayoutParams(new FrameLayout.LayoutParams(10, 10));
+    view.setRight(100);
+    view.setBottom(100);
+    target.getSize(cb);
+
+    verify(cb, times(1)).onSizeReady(anyInt(), anyInt());
+  }
+
+  @Test
+  public void getSize_withLayoutParams_emptyParams_notLaidOutOrLayoutRequested_callsSizeReady() {
+    view.setLayoutParams(new FrameLayout.LayoutParams(0, 0));
+    view.setRight(100);
+    view.setBottom(100);
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(100, 100);
+  }
+
+  @Test
+  public void getSize_withValidWidthAndHeight_preV19_layoutRequested_callsSizeReady() {
+    setSdkVersionInt(18);
+    view.setLayoutParams(new FrameLayout.LayoutParams(100, 100));
+    view.requestLayout();
+
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(100, 100);
+  }
+
+  @Test
+  public void getSize_withWidthAndHeightEqualToPadding_doesNotCallSizeReady() {
+    view.setLayoutParams(new FrameLayout.LayoutParams(100, 100));
+    view.requestLayout();
+    view.setPadding(50, 50, 50, 50);
+
+    target.getSize(cb);
+
+    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+  }
+
+  private void setDisplayDimens(Integer width, Integer height) {
+    WindowManager windowManager =
+        (WindowManager) RuntimeEnvironment.application.getSystemService(Context.WINDOW_SERVICE);
+    Display display = Preconditions.checkNotNull(windowManager).getDefaultDisplay();
+    if (width != null) {
+      Shadows.shadowOf(display).setWidth(width);
+    }
+
+    if (height != null) {
+      Shadows.shadowOf(display).setHeight(height);
+    }
+  }
+
+  @Test
+  public void clearOnDetach_onDetach_withNullRequest_doesNothing() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(null);
+    activity.visible();
+  }
+
+  // This behavior isn't clearly correct, but it doesn't seem like there's any harm to clear an
+  // already cleared request, so we might as well avoid the extra check/complexity in the code.
+  @Test
+  public void clearOnDetach_onDetach_withClearedRequest_clearsRequest() {
+    activity.visible();
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isCleared()).thenReturn(true);
+    parent.removeView(view);
+
+    verify(request).clear();
+  }
+
+  @Test
+  public void clearOnDetach_onDetach_withRunningRequest_pausesRequestOnce() {
+    activity.visible();
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    parent.removeView(view);
+
+    verify(request).clear();
+  }
+
+  @Test
+  public void clearOnDetach_onDetach_afterOnLoadCleared_removesListener() {
+    activity.visible();
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.onLoadCleared(/*placeholder=*/ null);
+    attachStateTarget.setRequest(request);
+    parent.removeView(view);
+
+    verify(request, never()).clear();
+  }
+
+  @Test
+  public void clearOnDetach_moreThanOnce_registersObserverOnce() {
+    activity.visible();
+    attachStateTarget.setRequest(request);
+    attachStateTarget
+        .clearOnDetach()
+        .clearOnDetach();
+    parent.removeView(view);
+
+    verify(request).clear();
+  }
+
+  @Test
+  public void clearOnDetach_onDetach_afterMultipleClearOnDetaches_removesListener() {
+    activity.visible();
+    attachStateTarget
+        .clearOnDetach()
+        .clearOnDetach()
+        .clearOnDetach();
+    attachStateTarget.onLoadCleared(/*placeholder=*/ null);
+    attachStateTarget.setRequest(request);
+    parent.removeView(view);
+
+    verify(request, never()).clear();
+  }
+
+  @Test
+  public void clearOnDetach_onDetach_afterLoadCleared_clearsRequest() {
+    activity.visible();
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isCleared()).thenReturn(true);
+    parent.removeView(view);
+
+    verify(request).clear();
+  }
+
+  @Test
+  public void clearOnDetach_onAttach_withNullRequest_doesNothing() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(null);
+    activity.visible();
+  }
+
+  @Test
+  public void clearOnDetach_onAttach_withRunningRequest_doesNotBeginRequest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isCleared()).thenReturn(false);
+    activity.visible();
+
+    verify(request, never()).begin();
+  }
+
+  @Test
+  public void clearOnDetach_onAttach_withClearedRequest_beginsRequest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isCleared()).thenReturn(true);
+    activity.visible();
+
+    verify(request).begin();
+  }
+
+  @Test
+  public void clearOnDetach_afterLoadClearedAndRestarted_onAttach_beingsREquest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isCleared()).thenReturn(true);
+    attachStateTarget.onLoadCleared(/*placeholder=*/ null);
+    attachStateTarget.onLoadStarted(/*placeholder=*/ null);
+    activity.visible();
+
+    verify(request).begin();
+  }
+
+  @Test
+  public void clearOnDetach_onAttach_afterLoadCleared_doesNotBeingRequest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isCleared()).thenReturn(true);
+    attachStateTarget.onLoadCleared(/*placeholder=*/ null);
+    activity.visible();
+
+    verify(request, never()).begin();
+  }
+
+  @Test
+  public void onLoadStarted_withoutClearOnDetach_doesNotAddListener() {
+    activity.visible();
+    target.setRequest(request);
+    attachStateTarget.onLoadStarted(/*placeholder=*/ null);
+    parent.removeView(view);
+
+    verify(request, never()).clear();
+  }
+
+  @Test
+  public void onLoadCleared_withoutClearOnDetach_doesNotRemoveListeners() {
+    final AtomicInteger count = new AtomicInteger();
+    OnAttachStateChangeListener expected =
+        new OnAttachStateChangeListener() {
+          @Override
+          public void onViewAttachedToWindow(View v) {
+            count.incrementAndGet();
+          }
+
+          @Override
+          public void onViewDetachedFromWindow(View v) {
+            // Intentionally Empty.
+          }
+        };
+    view.addOnAttachStateChangeListener(expected);
+
+    attachStateTarget.onLoadCleared(/*placeholder=*/ null);
+
+    activity.visible();
+
+    Truth.assertThat(count.get()).isEqualTo(1);
+  }
+
+  private static final class AttachStateTarget extends CustomViewTarget<View, Object> {
+    AttachStateTarget(View view) {
+      super(view);
+    }
+
+    @Override
+    protected void onResourceCleared(@Nullable Drawable placeholder) {
+      // Intentionally Empty.
+    }
+
+    @Override
+    public void onLoadFailed(@Nullable Drawable errorDrawable) {
+      // Intentionally Empty.
+    }
+
+    @Override
+    public void onResourceReady(
+        @NonNull Object resource, @Nullable Transition<? super Object> transition) {
+      // Intentionally Empty.
+    }
+  }
+
+  private static final class TestViewTarget extends CustomViewTarget<View, Object> {
+
+    TestViewTarget(View view) {
+      super(view);
+    }
+
+    @Override
+    protected void onResourceCleared(@Nullable Drawable placeholder) {
+      // Intentionally Empty.
+    }
+
+    // We're intentionally avoiding the super call.
+    @SuppressWarnings("MissingSuperCall")
+    @Override
+    public void onResourceReady(
+        @NonNull Object resource, @Nullable Transition<? super Object> transition) {
+      // Avoid calling super.
+    }
+
+    // We're intentionally avoiding the super call.
+    @SuppressWarnings("MissingSuperCall")
+    @Override
+    public void onResourceLoading(@Nullable Drawable placeholder) {
+      // Avoid calling super.
+    }
+
+    // We're intentionally avoiding the super call.
+    @SuppressWarnings("MissingSuperCall")
+    @Override
+    public void onLoadFailed(@Nullable Drawable errorDrawable) {
+      // Avoid calling super.
+    }
+  }
+
+  private static void setSdkVersionInt(int version) {
+    ReflectionHelpers.setStaticField(Build.VERSION.class, "SDK_INT", version);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java b/library/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java
deleted file mode 100644
index 7a55e9990..000000000
--- a/library/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java
+++ /dev/null
@@ -1,38 +0,0 @@
-package com.bumptech.glide.signature;
-
-import static org.junit.Assert.assertNotNull;
-
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.tests.KeyAssertions;
-import java.io.UnsupportedEncodingException;
-import java.security.NoSuchAlgorithmException;
-import org.junit.After;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
-public class ApplicationVersionSignatureTest {
-
-  @After
-  public void tearDown() {
-    ApplicationVersionSignature.reset();
-  }
-
-  @Test
-  public void testCanGetKeyForSignature() {
-    Key key = ApplicationVersionSignature.obtain(RuntimeEnvironment.application);
-    assertNotNull(key);
-  }
-
-  @Test
-  public void testKeyForSignatureIsTheSameAcrossCallsInTheSamePackage()
-      throws NoSuchAlgorithmException, UnsupportedEncodingException {
-    Key first = ApplicationVersionSignature.obtain(RuntimeEnvironment.application);
-    Key second = ApplicationVersionSignature.obtain(RuntimeEnvironment.application);
-    KeyAssertions.assertSame(first, second);
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java b/library/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java
deleted file mode 100644
index 7f465fb23..000000000
--- a/library/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java
+++ /dev/null
@@ -1,48 +0,0 @@
-package com.bumptech.glide.signature;
-
-import com.bumptech.glide.tests.KeyAssertions;
-import java.io.UnsupportedEncodingException;
-import java.security.NoSuchAlgorithmException;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class MediaStoreSignatureTest {
-
-  @Test
-  public void testSignaturesDifferIfMimeTypeDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    MediaStoreSignature first = new MediaStoreSignature("first", 100, 1);
-    MediaStoreSignature second = new MediaStoreSignature("second", 100, 1);
-
-    KeyAssertions.assertDifferent(first, second);
-  }
-
-  @Test
-  public void testSignaturesDifferIfDateModifiedDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    MediaStoreSignature first = new MediaStoreSignature("mimeType", 100, 1);
-    MediaStoreSignature second = new MediaStoreSignature("mimeType", 999, 1);
-
-    KeyAssertions.assertDifferent(first, second);
-  }
-
-  @Test
-  public void testSignaturesDifferIfOrientationDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    MediaStoreSignature first = new MediaStoreSignature("mimeType", 100, 1);
-    MediaStoreSignature second = new MediaStoreSignature("mimeType", 100, 9);
-
-    KeyAssertions.assertDifferent(first, second);
-  }
-
-  @Test
-  public void testSignaturesAreTheSameIfAllArgsAreTheSame()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    MediaStoreSignature first = new MediaStoreSignature("mimeType", 100, 1);
-    MediaStoreSignature second = new MediaStoreSignature("mimeType", 100, 1);
-
-    KeyAssertions.assertSame(first, second);
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/signature/ObjectKeyTest.java b/library/src/test/java/com/bumptech/glide/signature/ObjectKeyTest.java
deleted file mode 100644
index 21570323c..000000000
--- a/library/src/test/java/com/bumptech/glide/signature/ObjectKeyTest.java
+++ /dev/null
@@ -1,18 +0,0 @@
-package com.bumptech.glide.signature;
-
-import com.bumptech.glide.tests.KeyAssertions;
-import java.security.NoSuchAlgorithmException;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class ObjectKeyTest {
-
-  @Test
-  public void testEquals() throws NoSuchAlgorithmException {
-    Object object = new Object();
-    KeyAssertions.assertSame(new ObjectKey(object), new ObjectKey(object));
-    KeyAssertions.assertDifferent(new ObjectKey(object), new ObjectKey(new Object()));
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/tests/KeyAssertions.java b/library/src/test/java/com/bumptech/glide/tests/KeyAssertions.java
deleted file mode 100644
index 5ee17790a..000000000
--- a/library/src/test/java/com/bumptech/glide/tests/KeyAssertions.java
+++ /dev/null
@@ -1,52 +0,0 @@
-package com.bumptech.glide.tests;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import com.bumptech.glide.load.Key;
-import com.google.common.testing.EqualsTester;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-
-public class KeyAssertions {
-
-  public static void assertSame(Key first, Key second) throws NoSuchAlgorithmException {
-    assertSameOrdered(first, second);
-    assertSameOrdered(second, first);
-  }
-
-  private static void assertSameOrdered(Key first, Key second) throws NoSuchAlgorithmException {
-    new EqualsTester()
-        .addEqualityGroup(first, second)
-        .testEquals();
-
-    assertThat(getDigest(first)).isEqualTo(getDigest(second));
-  }
-
-  public static void assertDifferent(Key first, Key second) throws NoSuchAlgorithmException {
-    assertDifferent(first, second, true);
-    assertDifferent(second, first, true);
-  }
-
-  public static void assertDifferent(Key first, Key second, boolean checkDiskCacheKey)
-      throws NoSuchAlgorithmException {
-    new EqualsTester()
-        .addEqualityGroup(first)
-        .addEqualityGroup(second)
-        .testEquals();
-
-    if (checkDiskCacheKey) {
-      MessageDigest firstDigest = MessageDigest.getInstance("SHA-1");
-      first.updateDiskCacheKey(firstDigest);
-      MessageDigest secondDigest = MessageDigest.getInstance("SHA-1");
-      second.updateDiskCacheKey(secondDigest);
-
-      assertThat(getDigest(first)).isNotEqualTo(getDigest(second));
-    }
-  }
-
-  private static byte[] getDigest(Key key) throws NoSuchAlgorithmException {
-    MessageDigest md = MessageDigest.getInstance("SHA-1");
-    key.updateDiskCacheKey(md);
-    return md.digest();
-  }
-}
diff --git a/library/src/test/resources/exif-orientation-examples b/library/src/test/resources/exif-orientation-examples
deleted file mode 160000
index 85c6e142e..000000000
--- a/library/src/test/resources/exif-orientation-examples
+++ /dev/null
@@ -1 +0,0 @@
-Subproject commit 85c6e142ee57d1c5c7a29b2efcd5980a584758e2
diff --git a/library/test/build.gradle b/library/test/build.gradle
new file mode 100644
index 000000000..67c391819
--- /dev/null
+++ b/library/test/build.gradle
@@ -0,0 +1,51 @@
+apply plugin: 'com.android.library'
+
+dependencies {
+    testImplementation "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}"
+    testImplementation project(':library')
+    testImplementation project(':testutil')
+    testImplementation 'com.google.guava:guava-testlib:18.0'
+    testImplementation "com.google.truth:truth:${TRUTH_VERSION}"
+    testImplementation "junit:junit:${JUNIT_VERSION}"
+    testImplementation "org.mockito:mockito-core:${MOCKITO_VERSION}"
+    testImplementation "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
+    testImplementation "com.squareup.okhttp3:mockwebserver:${MOCKWEBSERVER_VERSION}"
+    testImplementation "com.android.support:support-v4:${ANDROID_SUPPORT_VERSION}"
+}
+
+tasks.withType(JavaCompile) {
+    options.fork = true
+}
+
+afterEvaluate {
+    lint.enabled = false
+    compileDebugJavaWithJavac.enabled = false
+}
+
+android.testOptions.unitTests.all { Test testTask ->
+    // configure max heap size of the test JVM
+    testTask.maxHeapSize = TEST_JVM_MEMORY_SIZE as String
+    if (JavaVersion.current() <= JavaVersion.VERSION_1_7) {
+        // Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize=2048m; support was removed in 8.0
+        testTask.jvmArgs "-XX:MaxPermSize=${TEST_JVM_MEMORY_SIZE}"
+    }
+
+    // Initializing Robolectric is expensive, two threads seem to be around the only level where any
+    // improvement is seen.
+    testTask.maxParallelForks = 2
+}
+
+android {
+    compileSdkVersion COMPILE_SDK_VERSION as int
+
+    defaultConfig {
+        minSdkVersion MIN_SDK_VERSION as int
+        targetSdkVersion TARGET_SDK_VERSION as int
+        versionName VERSION_NAME as String
+    }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
+}
diff --git a/library/test/src/main/AndroidManifest.xml b/library/test/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..600ac91f9
--- /dev/null
+++ b/library/test/src/main/AndroidManifest.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest package="com.bumptech.glide.test">
+    <application/>
+</manifest>
diff --git a/library/src/test/java/com/bumptech/glide/GlideContextTest.java b/library/test/src/test/java/com/bumptech/glide/GlideContextTest.java
similarity index 84%
rename from library/src/test/java/com/bumptech/glide/GlideContextTest.java
rename to library/test/src/test/java/com/bumptech/glide/GlideContextTest.java
index 199ecb38e..34dc8de84 100644
--- a/library/src/test/java/com/bumptech/glide/GlideContextTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/GlideContextTest.java
@@ -9,10 +9,13 @@
 import android.graphics.drawable.Drawable;
 import android.util.Log;
 import com.bumptech.glide.load.engine.Engine;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
 import com.bumptech.glide.load.resource.drawable.DrawableTransitionOptions;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
+import com.bumptech.glide.request.RequestListener;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.ImageViewTargetFactory;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
 import org.junit.Before;
@@ -33,9 +36,16 @@ public void setUp() {
     Application app = RuntimeEnvironment.application;
 
     transitionOptions = new HashMap<>();
-    context = new GlideContext(app, new Registry(),
-        new ImageViewTargetFactory(), new RequestOptions(),
-        transitionOptions, mock(Engine.class), Log.DEBUG);
+    context = new GlideContext(
+        app,
+        new LruArrayPool(),
+        new Registry(),
+        new ImageViewTargetFactory(),
+        new RequestOptions(),
+        transitionOptions,
+        /*defaultRequestListeners=*/ Collections.<RequestListener<Object>>emptyList(),
+        mock(Engine.class),
+        Log.DEBUG);
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/GlideTest.java b/library/test/src/test/java/com/bumptech/glide/GlideTest.java
similarity index 66%
rename from library/src/test/java/com/bumptech/glide/GlideTest.java
rename to library/test/src/test/java/com/bumptech/glide/GlideTest.java
index 93f70d040..7efa6b523 100644
--- a/library/src/test/java/com/bumptech/glide/GlideTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/GlideTest.java
@@ -3,7 +3,10 @@
 import static com.bumptech.glide.request.RequestOptions.decodeTypeOf;
 import static com.bumptech.glide.request.RequestOptions.errorOf;
 import static com.bumptech.glide.request.RequestOptions.placeholderOf;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
+import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Matchers.isA;
@@ -13,11 +16,9 @@
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
-import static org.robolectric.Shadows.shadowOf;
 
 import android.content.ContentResolver;
 import android.content.Context;
-import android.content.pm.ApplicationInfo;
 import android.content.res.AssetFileDescriptor;
 import android.graphics.Bitmap;
 import android.graphics.Color;
@@ -26,9 +27,10 @@
 import android.graphics.drawable.Drawable;
 import android.media.MediaMetadataRetriever;
 import android.net.Uri;
-import android.os.Bundle;
 import android.os.Handler;
 import android.os.ParcelFileDescriptor;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.ViewGroup;
 import android.widget.ImageView;
 import com.bumptech.glide.load.DataSource;
@@ -48,28 +50,33 @@
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 import com.bumptech.glide.manager.Lifecycle;
 import com.bumptech.glide.manager.RequestManagerTreeNode;
-import com.bumptech.glide.module.GlideModule;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.RequestOptions;
+import com.bumptech.glide.request.target.SimpleTarget;
 import com.bumptech.glide.request.target.SizeReadyCallback;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.tests.GlideShadowLooper;
+import com.bumptech.glide.tests.TearDownGlide;
 import com.bumptech.glide.tests.Util;
 import com.bumptech.glide.testutil.TestResourceUtil;
+import com.bumptech.glide.util.Preconditions;
 import java.io.ByteArrayInputStream;
 import java.io.File;
-import java.io.IOException;
 import java.io.InputStream;
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.nio.ByteBuffer;
 import java.util.HashMap;
 import java.util.Map;
-import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.RobolectricTestRunner;
@@ -81,7 +88,6 @@
 import org.robolectric.annotation.Resetter;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowBitmap;
-import org.robolectric.shadows.ShadowPackageManager;
 
 /**
  * Tests for the {@link Glide} interface and singleton.
@@ -91,74 +97,135 @@
     GlideTest.ShadowFileDescriptorContentResolver.class,
     GlideTest.ShadowMediaMetadataRetriever.class, GlideShadowLooper.class,
     GlideTest.MutableShadowBitmap.class })
-@SuppressWarnings({"unchecked", "deprecation"})
+@SuppressWarnings("unchecked")
 public class GlideTest {
+  // Fixes method overload confusion.
+  private static final Object NULL = null;
+
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+
   @SuppressWarnings("rawtypes")
-  private Target target = null;
+  @Mock private Target target;
+  @Mock private DiskCache.Factory diskCacheFactory;
+  @Mock private DiskCache diskCache;
+  @Mock private MemoryCache memoryCache;
+  @Mock private Handler bgHandler;
+  @Mock private Lifecycle lifecycle;
+  @Mock private RequestManagerTreeNode treeNode;
+  @Mock private BitmapPool bitmapPool;
+
   private ImageView imageView;
   private RequestManager requestManager;
+  private Context context;
 
   @Before
-  public void setUp() throws Exception {
-    Glide.tearDown();
-
-    ShadowPackageManager pm = shadowOf(RuntimeEnvironment.application.getPackageManager());
-    ApplicationInfo info =
-        pm.getApplicationInfo(RuntimeEnvironment.application.getPackageName(), 0);
-    info.metaData = new Bundle();
-    info.metaData.putString(SetupModule.class.getName(), "GlideModule");
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    context = RuntimeEnvironment.application;
+
+    // Run all tasks on the main thread so they complete synchronously.
+    GlideExecutor executor = MockGlideExecutor.newMainThreadExecutor();
+    when(diskCacheFactory.build()).thenReturn(diskCache);
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setMemoryCache(memoryCache)
+            .setDiskCache(diskCacheFactory)
+            .setSourceExecutor(executor)
+            .setDiskCacheExecutor(executor));
+    Registry registry = Glide.get(context).getRegistry();
+    registerMockModelLoader(
+        GlideUrl.class, InputStream.class, new ByteArrayInputStream(new byte[0]), registry);
+    registerMockModelLoader(
+        File.class, InputStream.class, new ByteArrayInputStream(new byte[0]), registry);
+    registerMockModelLoader(
+        File.class, ParcelFileDescriptor.class, mock(ParcelFileDescriptor.class), registry);
+    registerMockModelLoader(File.class, ByteBuffer.class, ByteBuffer.allocate(10), registry);
 
     // Ensure that target's size ready callback will be called synchronously.
-    target = mock(Target.class);
-    imageView = new ImageView(RuntimeEnvironment.application);
+    imageView = new ImageView(context);
     imageView.setLayoutParams(new ViewGroup.LayoutParams(100, 100));
     imageView.layout(0, 0, 100, 100);
     doAnswer(new CallSizeReady()).when(target).getSize(isA(SizeReadyCallback.class));
 
-    Handler bgHandler = mock(Handler.class);
     when(bgHandler.post(isA(Runnable.class))).thenAnswer(new Answer<Boolean>() {
       @Override
-      public Boolean answer(InvocationOnMock invocation) throws Throwable {
+      public Boolean answer(InvocationOnMock invocation) {
         Runnable runnable = (Runnable) invocation.getArguments()[0];
         runnable.run();
         return true;
       }
     });
 
-    Lifecycle lifecycle = mock(Lifecycle.class);
-    RequestManagerTreeNode treeNode = mock(RequestManagerTreeNode.class);
-    requestManager = new RequestManager(Glide.get(getContext()), lifecycle, treeNode);
+    requestManager = new RequestManager(Glide.get(context), lifecycle, treeNode, context);
     requestManager.resumeRequests();
   }
 
-  @After
-  public void tearDown() {
-    Glide.tearDown();
+  @Test
+  public void testCanSetMemoryCategory() {
+    MemoryCategory memoryCategory = MemoryCategory.NORMAL;
+    Glide glide =
+        new GlideBuilder()
+            .setBitmapPool(bitmapPool)
+            .setMemoryCache(memoryCache)
+            .build(context);
+    glide.setMemoryCategory(memoryCategory);
+
+    verify(memoryCache).setSizeMultiplier(eq(memoryCategory.getMultiplier()));
+    verify(bitmapPool).setSizeMultiplier(eq(memoryCategory.getMultiplier()));
   }
 
   @Test
-  public void testCanSetMemoryCategory() {
-    MemoryCache memoryCache = mock(MemoryCache.class);
-    BitmapPool bitmapPool = mock(BitmapPool.class);
+  public void testCanIncreaseMemoryCategory() {
+    MemoryCategory memoryCategory = MemoryCategory.NORMAL;
+    Glide glide =
+        new GlideBuilder()
+            .setBitmapPool(bitmapPool)
+            .setMemoryCache(memoryCache)
+            .build(context);
+    glide.setMemoryCategory(memoryCategory);
 
+    verify(memoryCache).setSizeMultiplier(eq(memoryCategory.getMultiplier()));
+    verify(bitmapPool).setSizeMultiplier(eq(memoryCategory.getMultiplier()));
+
+    MemoryCategory newMemoryCategory = MemoryCategory.HIGH;
+    MemoryCategory oldMemoryCategory = glide.setMemoryCategory(newMemoryCategory);
+
+    assertEquals(memoryCategory, oldMemoryCategory);
+
+    verify(memoryCache).setSizeMultiplier(eq(newMemoryCategory.getMultiplier()));
+    verify(bitmapPool).setSizeMultiplier(eq(newMemoryCategory.getMultiplier()));
+  }
+
+  @Test
+  public void testCanDecreaseMemoryCategory() {
     MemoryCategory memoryCategory = MemoryCategory.NORMAL;
     Glide glide =
-        new GlideBuilder().setMemoryCache(memoryCache).setBitmapPool(bitmapPool)
-            .build(getContext());
+        new GlideBuilder()
+            .setBitmapPool(bitmapPool)
+            .setMemoryCache(memoryCache)
+            .build(context);
     glide.setMemoryCategory(memoryCategory);
 
     verify(memoryCache).setSizeMultiplier(eq(memoryCategory.getMultiplier()));
     verify(bitmapPool).setSizeMultiplier(eq(memoryCategory.getMultiplier()));
+
+    MemoryCategory newMemoryCategory = MemoryCategory.LOW;
+    MemoryCategory oldMemoryCategory = glide.setMemoryCategory(newMemoryCategory);
+
+    assertEquals(memoryCategory, oldMemoryCategory);
+
+    verify(memoryCache).setSizeMultiplier(eq(newMemoryCategory.getMultiplier()));
+    verify(bitmapPool).setSizeMultiplier(eq(newMemoryCategory.getMultiplier()));
   }
 
   @Test
   public void testClearMemory() {
-    BitmapPool bitmapPool = mock(BitmapPool.class);
-    MemoryCache memoryCache = mock(MemoryCache.class);
-
     Glide glide =
-        new GlideBuilder().setBitmapPool(bitmapPool).setMemoryCache(memoryCache)
-            .build(getContext());
+        new GlideBuilder()
+            .setBitmapPool(bitmapPool)
+            .setMemoryCache(memoryCache)
+            .build(context);
 
     glide.clearMemory();
 
@@ -168,12 +235,11 @@ public void testClearMemory() {
 
   @Test
   public void testTrimMemory() {
-    BitmapPool bitmapPool = mock(BitmapPool.class);
-    MemoryCache memoryCache = mock(MemoryCache.class);
-
     Glide glide =
-        new GlideBuilder().setBitmapPool(bitmapPool).setMemoryCache(memoryCache)
-            .build(getContext());
+        new GlideBuilder()
+            .setBitmapPool(bitmapPool)
+            .setMemoryCache(memoryCache)
+            .build(context);
 
     final int level = 123;
 
@@ -184,13 +250,13 @@ public void testTrimMemory() {
   }
 
   @Test
-  public void testFileDefaultLoaderWithInputStream() throws Exception {
+  public void testFileDefaultLoaderWithInputStream() {
     registerFailFactory(File.class, ParcelFileDescriptor.class);
     runTestFileDefaultLoader();
   }
 
   @Test
-  public void testFileDefaultLoaderWithFileDescriptor() throws Exception {
+  public void testFileDefaultLoaderWithFileDescriptor() {
     registerFailFactory(File.class, InputStream.class);
     runTestFileDefaultLoader();
   }
@@ -213,6 +279,7 @@ private void runTestFileDefaultLoader() {
     assertNotNull(imageView.getDrawable());
   }
 
+  @SuppressWarnings("deprecation")
   @Test
   public void testUrlDefaultLoader() throws MalformedURLException {
     URL url = new URL("http://www.google.com");
@@ -247,13 +314,53 @@ public void testToBytesOption() {
   }
 
   @Test
-  public void testUriDefaultLoaderWithInputStream() throws Exception {
+  public void testLoadColorDrawable_withUnitBitmapTransformation_returnsColorDrawable() {
+    ColorDrawable colorDrawable = new ColorDrawable(Color.RED);
+    requestManager
+        .load(colorDrawable)
+        .apply(new RequestOptions()
+            .override(100, 100)
+            .centerCrop())
+        .into(target);
+
+    ArgumentCaptor<Object> argumentCaptor = ArgumentCaptor.forClass(Object.class);
+    verify(target).onResourceReady(argumentCaptor.capture(), isA(Transition.class));
+
+    Object result = argumentCaptor.getValue();
+
+    assertThat(result).isInstanceOf(ColorDrawable.class);
+    assertThat(((ColorDrawable) result).getColor()).isEqualTo(Color.RED);
+  }
+
+  @Test
+  public void testLoadColorDrawable_withNonUnitBitmapTransformation_returnsBitmapDrawable() {
+    ColorDrawable colorDrawable = new ColorDrawable(Color.RED);
+    requestManager
+        .load(colorDrawable)
+        .apply(new RequestOptions()
+            .override(100, 100)
+            .circleCrop())
+        .into(target);
+
+    ArgumentCaptor<Object> argumentCaptor = ArgumentCaptor.forClass(Object.class);
+    verify(target).onResourceReady(argumentCaptor.capture(), isA(Transition.class));
+
+    Object result = argumentCaptor.getValue();
+
+    assertThat(result).isInstanceOf(BitmapDrawable.class);
+    Bitmap bitmap = ((BitmapDrawable) result).getBitmap();
+    assertThat(bitmap.getWidth()).isEqualTo(100);
+    assertThat(bitmap.getHeight()).isEqualTo(100);
+  }
+
+  @Test
+  public void testUriDefaultLoaderWithInputStream() {
     registerFailFactory(Uri.class, ParcelFileDescriptor.class);
     runTestUriDefaultLoader();
   }
 
   @Test
-  public void testUriDefaultLoaderWithFileDescriptor() throws Exception {
+  public void testUriDefaultLoaderWithFileDescriptor() {
     registerFailFactory(Uri.class, InputStream.class);
     runTestUriDefaultLoader();
   }
@@ -282,13 +389,13 @@ public void testStringDefaultLoaderWithUrl() {
   }
 
   @Test
-  public void testFileStringDefaultLoaderWithInputStream() throws Exception {
+  public void testFileStringDefaultLoaderWithInputStream() {
     registerFailFactory(String.class, ParcelFileDescriptor.class);
     runTestFileStringDefaultLoader();
   }
 
   @Test
-  public void testFileStringDefaultLoaderWithFileDescriptor() throws Exception {
+  public void testFileStringDefaultLoaderWithFileDescriptor() {
     registerFailFactory(String.class, ParcelFileDescriptor.class);
     runTestFileStringDefaultLoader();
   }
@@ -305,13 +412,13 @@ private void runTestFileStringDefaultLoader() {
   }
 
   @Test
-  public void testUriStringDefaultLoaderWithInputStream() throws Exception {
+  public void testUriStringDefaultLoaderWithInputStream() {
     registerFailFactory(String.class, ParcelFileDescriptor.class);
     runTestUriStringDefaultLoader();
   }
 
   @Test
-  public void testUriStringDefaultLoaderWithFileDescriptor() throws Exception {
+  public void testUriStringDefaultLoaderWithFileDescriptor() {
     registerFailFactory(String.class, InputStream.class);
     runTestUriStringDefaultLoader();
   }
@@ -350,13 +457,13 @@ public boolean onResourceReady(Drawable resource, Object model, Target<Drawable>
   }
 
   @Test
-  public void testIntegerDefaultLoaderWithInputStream() throws Exception {
+  public void testIntegerDefaultLoaderWithInputStream() {
     registerFailFactory(Integer.class, ParcelFileDescriptor.class);
     runTestIntegerDefaultLoader();
   }
 
   @Test
-  public void testIntegerDefaultLoaderWithFileDescriptor() throws Exception {
+  public void testIntegerDefaultLoaderWithFileDescriptor() {
     registerFailFactory(Integer.class, InputStream.class);
     runTestIntegerDefaultLoader();
   }
@@ -407,9 +514,9 @@ public void testNonDefaultModelWithRegisteredFactoryDoesNotThrow() {
   }
 
   @Test
-  public void testReceivesGif() throws IOException {
+  public void testReceivesGif() {
     String fakeUri = "content://fake";
-    InputStream testGifData = openResource("test.gif");
+    InputStream testGifData = openGif();
     mockUri(Uri.parse(fakeUri), testGifData);
 
     requestManager.asGif().load(fakeUri).into(target);
@@ -418,9 +525,9 @@ public void testReceivesGif() throws IOException {
   }
 
   @Test
-  public void testReceivesGifBytes() throws IOException {
+  public void testReceivesGifBytes() {
     String fakeUri = "content://fake";
-    InputStream testGifData = openResource("test.gif");
+    InputStream testGifData = openGif();
     mockUri(Uri.parse(fakeUri), testGifData);
 
     requestManager.as(byte[].class).apply(decodeTypeOf(GifDrawable.class)).load(fakeUri)
@@ -470,24 +577,24 @@ public void testReceivesRecursiveThumbnailWithPercentage() {
 
   @Test
   public void testNullModelInGenericImageLoadDoesNotThrow() {
-    requestManager.load(null).into(target);
+    requestManager.load(NULL).into(target);
   }
 
   @Test
   public void testNullModelInGenericVideoLoadDoesNotThrow() {
-    requestManager.load(null).into(target);
+    requestManager.load(NULL).into(target);
   }
 
   @Test
   public void testNullModelInGenericLoadDoesNotThrow() {
-    requestManager.load(null).into(target);
+    requestManager.load(NULL).into(target);
   }
 
   @Test
   public void testNullModelDoesNotThrow() {
     Drawable drawable = new ColorDrawable(Color.RED);
     requestManager
-        .load(null)
+        .load(NULL)
         .apply(errorOf(drawable))
         .into(target);
 
@@ -500,7 +607,7 @@ public void testNullModelPrefersErrorDrawable() {
     Drawable error = new ColorDrawable(Color.RED);
 
     requestManager
-        .load(null)
+        .load(NULL)
         .apply(placeholderOf(placeholder)
             .error(error))
         .into(target);
@@ -508,6 +615,42 @@ public void testNullModelPrefersErrorDrawable() {
     verify(target).onLoadFailed(eq(error));
   }
 
+  @Test
+  public void testLoadBitmap_asBitmap() {
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    requestManager
+        .asBitmap()
+        .load(bitmap)
+        .into(target);
+
+    verify(target).onResourceReady(eq(bitmap), any(Transition.class));
+  }
+
+  @Test
+  public void testLoadBitmap_asDrawable() {
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    requestManager
+        .load(bitmap)
+        .into(target);
+
+    ArgumentCaptor<Object> captor = ArgumentCaptor.forClass(Object.class);
+    verify(target).onResourceReady(captor.capture(), any(Transition.class));
+    BitmapDrawable drawable = (BitmapDrawable) captor.getValue();
+    assertThat(drawable.getBitmap()).isEqualTo(bitmap);
+  }
+
+  @Test
+  public void testLoadDrawable() {
+    Drawable drawable = new ColorDrawable(Color.RED);
+    requestManager
+        .load(drawable)
+        .into(target);
+
+    ArgumentCaptor<Drawable> drawableCaptor = ArgumentCaptor.forClass(Drawable.class);
+    verify(target).onResourceReady(drawableCaptor.capture(), any(Transition.class));
+    assertThat(((ColorDrawable) drawableCaptor.getValue()).getColor()).isEqualTo(Color.RED);
+  }
+
   @Test
   public void testNullModelPrefersFallbackDrawable() {
     Drawable placeholder = new ColorDrawable(Color.GREEN);
@@ -515,7 +658,7 @@ public void testNullModelPrefersFallbackDrawable() {
     Drawable fallback = new ColorDrawable(Color.BLUE);
 
     requestManager
-        .load(null)
+        .load(NULL)
         .apply(placeholderOf(placeholder)
             .error(error)
             .fallback(fallback))
@@ -529,7 +672,7 @@ public void testNullModelResolvesToUsePlaceholder() {
     Drawable placeholder = new ColorDrawable(Color.GREEN);
 
     requestManager
-        .load(null)
+        .load(NULL)
         .apply(placeholderOf(placeholder))
         .into(target);
 
@@ -543,7 +686,25 @@ public void testByteData() {
   }
 
   @Test
-  public void testClone() throws IOException {
+  public void removeFromManagers_afterRequestManagerRemoved_clearsRequest() {
+    target = requestManager.load(mockUri("content://uri")).into(new SimpleTarget<Drawable>() {
+      @Override
+      public void onResourceReady(@NonNull Drawable resource,
+          @Nullable Transition<? super Drawable> transition) {
+        // Do nothing.
+      }
+    });
+    Request request = Preconditions.checkNotNull(target.getRequest());
+
+    requestManager.onDestroy();
+    requestManager.clear(target);
+
+    assertThat(target.getRequest()).isNull();
+    assertThat(request.isCleared()).isTrue();
+  }
+
+  @Test
+  public void testClone() {
     Target<Drawable> firstTarget = mock(Target.class);
     doAnswer(new CallSizeReady(100, 100)).when(firstTarget).getSize(isA(SizeReadyCallback.class));
     Target<Drawable> secondTarget = mock(Target.class);
@@ -562,8 +723,7 @@ public void testClone() throws IOException {
   }
 
   @SuppressWarnings("unchecked")
-  private <T, Z> void registerFailFactory(Class<T> failModel, Class<Z> failResource)
-      throws Exception {
+  private <T, Z> void registerFailFactory(Class<T> failModel, Class<Z> failResource) {
     DataFetcher<Z> failFetcher = mock(DataFetcher.class);
     doAnswer(new Util.CallDataReady<>(null))
         .when(failFetcher)
@@ -576,24 +736,23 @@ public void testClone() throws IOException {
     ModelLoaderFactory<T, Z> failFactory = mock(ModelLoaderFactory.class);
     when(failFactory.build(isA(MultiModelLoaderFactory.class))).thenReturn(failLoader);
 
-    Glide.get(getContext()).getRegistry().prepend(failModel, failResource, failFactory);
+    Glide.get(context).getRegistry().prepend(failModel, failResource, failFactory);
   }
 
   private String mockUri(String uriString) {
     return mockUri(Uri.parse(uriString), null);
   }
 
-  private String mockUri(Uri uri) {
-    return mockUri(uri, null);
+  private void mockUri(Uri uri) {
+    mockUri(uri, null);
   }
 
   private String mockUri(Uri uri, InputStream is) {
     if (is == null) {
       is = new ByteArrayInputStream(new byte[0]);
     }
-    ContentResolver contentResolver = RuntimeEnvironment.application.getContentResolver();
-    ShadowFileDescriptorContentResolver shadowContentResolver =
-        (ShadowFileDescriptorContentResolver) Shadow.extract(contentResolver);
+    ContentResolver contentResolver = context.getContentResolver();
+    ShadowFileDescriptorContentResolver shadowContentResolver = Shadow.extract(contentResolver);
     shadowContentResolver.registerInputStream(uri, is);
 
     AssetFileDescriptor assetFileDescriptor = mock(AssetFileDescriptor.class);
@@ -604,17 +763,13 @@ private String mockUri(Uri uri, InputStream is) {
     return uri.toString();
   }
 
-  private Context getContext() {
-    return RuntimeEnvironment.application;
-  }
-
   @SuppressWarnings("unchecked")
   private <T> void registerMockStreamModelLoader(final Class<T> modelClass) {
     ModelLoader<T, InputStream> modelLoader = mockStreamModelLoader(modelClass);
     ModelLoaderFactory<T, InputStream> modelLoaderFactory = mock(ModelLoaderFactory.class);
     when(modelLoaderFactory.build(isA(MultiModelLoaderFactory.class))).thenReturn(modelLoader);
 
-    Glide.get(RuntimeEnvironment.application).getRegistry()
+    Glide.get(context).getRegistry()
         .prepend(modelClass, InputStream.class, modelLoaderFactory);
   }
 
@@ -636,19 +791,19 @@ private Context getContext() {
     return modelLoader;
   }
 
-  private InputStream openResource(String imageName) throws IOException {
-    return TestResourceUtil.openResource(getClass(), imageName);
+  private InputStream openGif() {
+    return TestResourceUtil.openResource(getClass(), "test.gif");
   }
 
   private static class CallSizeReady implements Answer<Void> {
-    private int width;
-    private int height;
+    private final int width;
+    private final int height;
 
-    public CallSizeReady() {
+    CallSizeReady() {
       this(100, 100);
     }
 
-    public CallSizeReady(int width, int height) {
+    CallSizeReady(int width, int height) {
       this.width = width;
       this.height = height;
     }
@@ -661,53 +816,26 @@ public Void answer(InvocationOnMock invocation) throws Throwable {
     }
   }
 
-  public static class SetupModule implements GlideModule {
-
-    @Override
-    public void applyOptions(Context context, GlideBuilder builder) {
-      // Run all tasks on the main thread so they complete synchronously.
-      GlideExecutor executor = MockGlideExecutor.newMainThreadExecutor();
-
-      DiskCache.Factory diskCacheFactory = mock(DiskCache.Factory.class);
-      when(diskCacheFactory.build()).thenReturn(mock(DiskCache.class));
-
-      builder.setMemoryCache(mock(MemoryCache.class)).setDiskCache(diskCacheFactory)
-          .setResizeExecutor(executor).setDiskCacheExecutor(executor);
-    }
-
-    @Override
-    public void registerComponents(Context context, Glide glide, Registry registry) {
-      registerMockModelLoader(GlideUrl.class, InputStream.class,
-          new ByteArrayInputStream(new byte[0]), registry);
-      registerMockModelLoader(File.class, InputStream.class,
-          new ByteArrayInputStream(new byte[0]), registry);
-      registerMockModelLoader(File.class, ParcelFileDescriptor.class,
-          mock(ParcelFileDescriptor.class), registry);
-      registerMockModelLoader(File.class, ByteBuffer.class,
-          ByteBuffer.allocate(10), registry);
+  private static <X, Y> void registerMockModelLoader(Class<X> modelClass, Class<Y> dataClass,
+      Y loadedData, Registry registry) {
+    DataFetcher<Y> mockStreamFetcher = mock(DataFetcher.class);
+    when(mockStreamFetcher.getDataClass()).thenReturn(dataClass);
+    try {
+      doAnswer(new Util.CallDataReady<>(loadedData))
+          .when(mockStreamFetcher)
+          .loadData(isA(Priority.class), isA(DataFetcher.DataCallback.class));
+    } catch (Exception e) {
+      throw new RuntimeException(e);
     }
+    ModelLoader<X, Y> mockUrlLoader = mock(ModelLoader.class);
+    when(mockUrlLoader.buildLoadData(isA(modelClass), anyInt(), anyInt(), isA(Options.class)))
+        .thenReturn(new ModelLoader.LoadData<>(mock(Key.class), mockStreamFetcher));
+    when(mockUrlLoader.handles(isA(modelClass))).thenReturn(true);
+    ModelLoaderFactory<X, Y> mockUrlLoaderFactory = mock(ModelLoaderFactory.class);
+    when(mockUrlLoaderFactory.build(isA(MultiModelLoaderFactory.class)))
+        .thenReturn(mockUrlLoader);
 
-    private static <X, Y> void registerMockModelLoader(Class<X> modelClass, Class<Y> dataClass,
-          Y loadedData, Registry registry) {
-      DataFetcher<Y> mockStreamFetcher = mock(DataFetcher.class);
-      when(mockStreamFetcher.getDataClass()).thenReturn(dataClass);
-      try {
-        doAnswer(new Util.CallDataReady<>(loadedData))
-            .when(mockStreamFetcher)
-            .loadData(isA(Priority.class), isA(DataFetcher.DataCallback.class));
-      } catch (Exception e) {
-        throw new RuntimeException(e);
-      }
-      ModelLoader<X, Y> mockUrlLoader = mock(ModelLoader.class);
-      when(mockUrlLoader.buildLoadData(isA(modelClass), anyInt(), anyInt(), isA(Options.class)))
-          .thenReturn(new ModelLoader.LoadData<>(mock(Key.class), mockStreamFetcher));
-      when(mockUrlLoader.handles(isA(modelClass))).thenReturn(true);
-      ModelLoaderFactory<X, Y> mockUrlLoaderFactory = mock(ModelLoaderFactory.class);
-      when(mockUrlLoaderFactory.build(isA(MultiModelLoaderFactory.class)))
-          .thenReturn(mockUrlLoader);
-
-      registry.replace(modelClass, dataClass, mockUrlLoaderFactory);
-    }
+    registry.replace(modelClass, dataClass, mockUrlLoaderFactory);
   }
 
   // TODO: Extending ShadowContentResolver results in exceptions because of some state issues
@@ -726,11 +854,11 @@ public static void reset() {
       URI_TO_FILE_DESCRIPTOR.clear();
     }
 
-    public void registerInputStream(Uri uri, InputStream inputStream) {
+    void registerInputStream(Uri uri, InputStream inputStream) {
       URI_TO_INPUT_STREAMS.put(uri, inputStream);
     }
 
-    public void registerAssetFileDescriptor(Uri uri, AssetFileDescriptor assetFileDescriptor) {
+    void registerAssetFileDescriptor(Uri uri, AssetFileDescriptor assetFileDescriptor) {
       URI_TO_FILE_DESCRIPTOR.put(uri, assetFileDescriptor);
     }
 
diff --git a/library/src/test/java/com/bumptech/glide/ListPreloaderTest.java b/library/test/src/test/java/com/bumptech/glide/ListPreloaderTest.java
similarity index 85%
rename from library/src/test/java/com/bumptech/glide/ListPreloaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/ListPreloaderTest.java
index f1b8b51e8..e6c957d27 100644
--- a/library/src/test/java/com/bumptech/glide/ListPreloaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/ListPreloaderTest.java
@@ -8,6 +8,8 @@
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.request.target.SizeReadyCallback;
 import com.bumptech.glide.request.target.Target;
 import java.util.ArrayList;
@@ -35,7 +37,7 @@
   @Mock private RequestManager requestManager;
 
   @Before
-  public void setUp() throws Exception {
+  public void setUp() {
     MockitoAnnotations.initMocks(this);
   }
 
@@ -45,6 +47,7 @@ public void testGetItemsIsCalledIncreasing() {
     final AtomicInteger calledCount = new AtomicInteger();
 
     ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
+      @NonNull
       @Override
       public List<Object> getPreloadItems(int position) {
         called.set(true);
@@ -71,18 +74,20 @@ public void testGetItemsIsCalledInOrderIncreasing() {
       private int expectedPosition;
 
       @Override
-      public int[] getPreloadSize(Object item, int adapterPosition, int itemPosition) {
+      public int[] getPreloadSize(@NonNull Object item, int adapterPosition, int itemPosition) {
         return new int[] { 10, 10 };
       }
 
+      @NonNull
       @Override
       public List<Object> getPreloadItems(int position) {
         return objects.subList(position - 11, position + 1 - 11);
       }
 
+      @Nullable
       @Override
       @SuppressWarnings("unchecked")
-      public RequestBuilder<Object> getPreloadRequestBuilder(Object item) {
+      public RequestBuilder<Object> getPreloadRequestBuilder(@NonNull Object item) {
         assertEquals(objects.get(expectedPosition), item);
         expectedPosition++;
         return mock(RequestBuilder.class);
@@ -98,6 +103,7 @@ public void testGetItemsIsCalledDecreasing() {
     final AtomicBoolean called = new AtomicBoolean(false);
     final AtomicInteger calledCount = new AtomicInteger();
     ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
+      @NonNull
       @Override
       public List<Object> getPreloadItems(int position) {
         // Ignore the preload caused from us starting at the end
@@ -129,21 +135,23 @@ public void testGetItemsIsCalledInOrderDecreasing() {
       private int expectedPosition = toPreload - 1;
 
       @Override
-      public int[] getPreloadSize(Object item, int adapterPosition, int itemPosition) {
+      public int[] getPreloadSize(@NonNull Object item, int adapterPosition, int itemPosition) {
         return new int[] { 10, 10 };
       }
 
+      @NonNull
       @Override
       public List<Object> getPreloadItems(int position) {
         if (position == 40) {
-          return null;
+          return Collections.emptyList();
         }
         return objects.subList(position, position + 1);
       }
 
+      @Nullable
       @Override
       @SuppressWarnings("unchecked")
-      public RequestBuilder<Object> getPreloadRequestBuilder(Object item) {
+      public RequestBuilder<Object> getPreloadRequestBuilder(@NonNull Object item) {
         assertEquals(objects.get(expectedPosition), item);
         expectedPosition--;
         return mock(RequestBuilder.class);
@@ -160,6 +168,7 @@ public void testGetItemsIsNeverCalledWithEndGreaterThanTotalItems() {
     final AtomicBoolean called = new AtomicBoolean(false);
     final AtomicInteger calledCount = new AtomicInteger();
     ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
+      @NonNull
       @Override
       public List<Object> getPreloadItems(int position) {
         called.set(true);
@@ -179,6 +188,7 @@ public void testGetItemsIsNeverCalledWithStartLessThanZero() {
     final AtomicBoolean called = new AtomicBoolean(false);
     final AtomicInteger calledCount = new AtomicInteger();
     ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
+      @NonNull
       @Override
       public List<Object> getPreloadItems(int position) {
         if (position >= 17) {
@@ -202,6 +212,7 @@ public void testGetItemsIsNeverCalledWithStartLessThanZero() {
   public void testDontPreloadItemsRepeatedlyWhileIncreasing() {
     final AtomicInteger called = new AtomicInteger();
     ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
+      @NonNull
       @Override
       public List<Object> getPreloadItems(int position) {
         final int current = called.getAndIncrement();
@@ -222,6 +233,7 @@ public void testDontPreloadItemsRepeatedlyWhileIncreasing() {
   public void testDontPreloadItemsRepeatedlyWhileDecreasing() {
     final AtomicInteger called = new AtomicInteger();
     ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
+      @NonNull
       @Override
       public List<Object> getPreloadItems(int position) {
         if (position >= 20) {
@@ -242,28 +254,30 @@ public void testDontPreloadItemsRepeatedlyWhileDecreasing() {
   }
 
   @Test
-  public void testMultipleItemsForPositionIncreasing() throws NoSuchFieldException {
+  public void testMultipleItemsForPositionIncreasing() {
     final List<Object> objects = new ArrayList<>();
     objects.add(new Object());
     objects.add(new Object());
     ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
       private int expectedPosition = (1 + 10) * 2;
 
+      @NonNull
       @Override
       public List<Object> getPreloadItems(int position) {
         return objects;
       }
 
       @Override
-      public int[] getPreloadSize(Object item, int adapterPosition, int itemPosition) {
+      public int[] getPreloadSize(@NonNull Object item, int adapterPosition, int itemPosition) {
         assertEquals(expectedPosition / 2, adapterPosition);
         assertEquals(expectedPosition % 2, itemPosition);
         expectedPosition++;
         return itemPosition == 0 ? new int[] { 10, 11 } : new int[] { 20, 21 };
       }
 
+      @Nullable
       @Override
-      public RequestBuilder<Object> getPreloadRequestBuilder(Object item) {
+      public RequestBuilder<Object> getPreloadRequestBuilder(@NonNull Object item) {
         return request;
       }
     };
@@ -278,28 +292,30 @@ public void testMultipleItemsForPositionIncreasing() throws NoSuchFieldException
   }
 
   @Test
-  public void testMultipleItemsForPositionDecreasing() throws NoSuchFieldException {
+  public void testMultipleItemsForPositionDecreasing() {
     final List<Object> objects = new ArrayList<>();
     objects.add(new Object());
     objects.add(new Object());
     ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
       private int expectedPosition = objects.size() * 2 - 1;
 
+      @NonNull
       @Override
       public List<Object> getPreloadItems(int position) {
         return objects;
       }
 
       @Override
-      public int[] getPreloadSize(Object item, int adapterPosition, int itemPosition) {
+      public int[] getPreloadSize(@NonNull Object item, int adapterPosition, int itemPosition) {
         assertEquals(expectedPosition / 2, adapterPosition);
         assertEquals(expectedPosition % 2, itemPosition);
         expectedPosition--;
         return itemPosition == 0 ? new int[] { 10, 11 } : new int[] { 20, 21 };
       }
 
+      @Nullable
       @Override
-      public RequestBuilder<Object> getPreloadRequestBuilder(Object item) {
+      public RequestBuilder<Object> getPreloadRequestBuilder(@NonNull Object item) {
         return request;
       }
     };
@@ -314,19 +330,22 @@ public void testMultipleItemsForPositionDecreasing() throws NoSuchFieldException
     assertEquals(expected, allValues);
   }
 
-  private <R> List<Integer> getTargetsSizes(
-      RequestBuilder<R> requestBuilder, VerificationMode mode) {
+  private <Resource> List<Integer> getTargetsSizes(
+      RequestBuilder<Resource> requestBuilder, VerificationMode mode) {
     ArgumentCaptor<Integer> integerArgumentCaptor = ArgumentCaptor.forClass(Integer.class);
-    ArgumentCaptor<Target<R>> targetArgumentCaptor = cast(ArgumentCaptor.forClass(Target.class));
+    ArgumentCaptor<Target<Resource>> targetArgumentCaptor =
+        cast(ArgumentCaptor.forClass(Target.class));
     SizeReadyCallback cb = mock(SizeReadyCallback.class);
     verify(requestBuilder, mode).into(targetArgumentCaptor.capture());
-    for (Target<R> target : targetArgumentCaptor.getAllValues()) {
+    for (Target<Resource> target : targetArgumentCaptor.getAllValues()) {
       target.getSize(cb);
     }
     verify(cb, mode).onSizeReady(integerArgumentCaptor.capture(), integerArgumentCaptor.capture());
     return integerArgumentCaptor.getAllValues();
   }
 
+  // It's safe to ignore the return value of containsAllIn.
+  @SuppressWarnings("ResultOfMethodCallIgnored")
   @Test
   public void testItemsArePreloadedWithGlide() {
     final List<Object> objects = new ArrayList<>();
@@ -334,13 +353,15 @@ public void testItemsArePreloadedWithGlide() {
     objects.add(new Object());
     final HashSet<Object> loadedObjects = new HashSet<>();
     ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
+      @NonNull
       @Override
       public List<Object> getPreloadItems(int position) {
         return objects.subList(position - 11, position - 10);
       }
 
+      @Nullable
       @Override
-      public RequestBuilder<Object> getPreloadRequestBuilder(Object item) {
+      public RequestBuilder<Object> getPreloadRequestBuilder(@NonNull Object item) {
         loadedObjects.add(item);
         return super.getPreloadRequestBuilder(item);
       }
@@ -358,6 +379,7 @@ public void testItemsArePreloadedWithGlide() {
     public ListPreloaderAdapter() {
     }
 
+    @NonNull
     @Override
     public List<Object> getPreloadItems(int position) {
       ArrayList<Object> result = new ArrayList<>(1);
@@ -365,14 +387,16 @@ public ListPreloaderAdapter() {
       return result;
     }
 
+    @Nullable
     @Override
     @SuppressWarnings("unchecked")
-    public RequestBuilder<Object> getPreloadRequestBuilder(Object item) {
+    public RequestBuilder<Object> getPreloadRequestBuilder(@NonNull Object item) {
       return mock(RequestBuilder.class);
     }
 
+    @Nullable
     @Override
-    public int[] getPreloadSize(Object item, int adapterPosition, int itemPosition) {
+    public int[] getPreloadSize(@NonNull Object item, int adapterPosition, int itemPosition) {
       return new int[] { 100, 100 };
     }
   }
diff --git a/library/test/src/test/java/com/bumptech/glide/RegistryTest.java b/library/test/src/test/java/com/bumptech/glide/RegistryTest.java
new file mode 100644
index 000000000..defe8463b
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/RegistryTest.java
@@ -0,0 +1,162 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.model.ModelLoaderFactory;
+import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
+import java.util.List;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class RegistryTest {
+
+  @Mock private ModelLoaderFactory<Model, Data> modelLoaderFactory;
+  @Mock private ResourceDecoder<Data, ResourceOne> resourceOneDecoder;
+  @Mock private ResourceDecoder<Data, ResourceTwo> resourceTwoDecoder;
+  @Mock private ResourceTranscoder<ResourceOne, TranscodeOne> resourceOneTranscodeOneTranscoder;
+  private Registry registry;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    registry = new Registry();
+  }
+
+  @Test
+  public void getRegisteredResourceClasses_withNoResources_isEmpty() {
+    assertThat(getRegisteredResourceClasses()).isEmpty();
+  }
+
+  @Test
+  public void getRegisteredResourceClasses_withOneDataClass_noResourceClasses_isEmpty() {
+    registry.append(Model.class, Data.class, modelLoaderFactory);
+    assertThat(getRegisteredResourceClasses()).isEmpty();
+  }
+
+  @Test
+  public void getRegisteredResourceClasses_withOneDataAndResourceClass_noTranscodeClass_isEmpty() {
+    registry.append(Model.class, Data.class, modelLoaderFactory);
+    registry.append(Data.class, ResourceOne.class, resourceOneDecoder);
+    assertThat(getRegisteredResourceClasses()).isEmpty();
+  }
+
+  @Test
+  public void getRegisteredResourceClasses_withOneDataAndResourceAndTranscodeClass_isNotEmpty() {
+    registry.append(Model.class, Data.class, modelLoaderFactory);
+    registry.append(Data.class, ResourceOne.class, resourceOneDecoder);
+    registry.register(ResourceOne.class, TranscodeOne.class, resourceOneTranscodeOneTranscoder);
+    assertThat(getRegisteredResourceClasses()).containsExactly(ResourceOne.class);
+  }
+
+  @Test
+  public void getRegisteredResourceClasses_withMissingTranscodeForOneOfTwoResources_isNotEmpty() {
+    // The loop allows us to make sure that the order in which we call getRegisteredResourceClasses
+    // doesn't affect the output.
+    for (int i = 0; i < 2; i++) {
+      Registry registry = new Registry();
+      registry.append(Model.class, Data.class, modelLoaderFactory);
+
+      registry.append(Data.class, ResourceOne.class, resourceOneDecoder);
+      registry.append(Data.class, ResourceTwo.class, resourceTwoDecoder);
+
+      registry.register(ResourceOne.class, TranscodeOne.class, resourceOneTranscodeOneTranscoder);
+
+      List<Class<?>> resourceOneClasses;
+      List<Class<?>> resourceTwoClasses;
+      if (i == 0) {
+        resourceOneClasses =
+            registry.getRegisteredResourceClasses(
+                Model.class, ResourceOne.class, TranscodeOne.class);
+        resourceTwoClasses =
+            registry.getRegisteredResourceClasses(
+                Model.class, ResourceTwo.class, TranscodeOne.class);
+      } else {
+        resourceTwoClasses =
+            registry.getRegisteredResourceClasses(
+                Model.class, ResourceTwo.class, TranscodeOne.class);
+        resourceOneClasses =
+            registry.getRegisteredResourceClasses(
+                Model.class, ResourceOne.class, TranscodeOne.class);
+      }
+      // ResourceOne has a corresponding transcode class, so we should return it.
+      assertThat(resourceOneClasses).containsExactly(ResourceOne.class);
+      // ResourceTwo has no matching transcode class, so we shouldn't return it.
+      assertThat(resourceTwoClasses).isEmpty();
+    }
+  }
+
+  @Test
+  public void getRegisteredResourceClasses_withOneOfTwoMissingTranscoders_isNotEmpty() {
+    // The loop allows us to make sure that the order in which we call getRegisteredResourceClasses
+    // doesn't affect the output.
+    for (int i = 0; i < 2; i++) {
+      Registry registry = new Registry();
+      registry.append(Model.class, Data.class, modelLoaderFactory);
+
+      registry.append(Data.class, ResourceOne.class, resourceOneDecoder);
+
+      registry.register(ResourceOne.class, TranscodeOne.class, resourceOneTranscodeOneTranscoder);
+
+      List<Class<?>> transcodeOneClasses;
+      List<Class<?>> transcodeTwoClasses;
+      if (i == 0) {
+        transcodeOneClasses =
+            registry.getRegisteredResourceClasses(
+                Model.class, ResourceOne.class, TranscodeOne.class);
+        transcodeTwoClasses =
+            registry.getRegisteredResourceClasses(
+                Model.class, ResourceOne.class, TranscodeTwo.class);
+      } else {
+        transcodeTwoClasses =
+            registry.getRegisteredResourceClasses(
+                Model.class, ResourceOne.class, TranscodeTwo.class);
+        transcodeOneClasses =
+            registry.getRegisteredResourceClasses(
+                Model.class, ResourceOne.class, TranscodeOne.class);
+      }
+      // TranscodeOne has a corresponding ResourceTranscoder, so we expect to see the resource
+      // class.
+      assertThat(transcodeOneClasses).containsExactly(ResourceOne.class);
+      // TranscodeTwo has no corresponding ResourceTranscoder class, so we shouldn't return the
+      // resource class.
+      assertThat(transcodeTwoClasses).isEmpty();
+    }
+  }
+
+  private List<Class<?>> getRegisteredResourceClasses() {
+    return registry.getRegisteredResourceClasses(
+        Model.class, ResourceOne.class, TranscodeOne.class);
+  }
+
+  private static final class Model {
+    // Empty class to represent model classes for readability.
+  }
+
+  private static final class Data {
+    // Empty class to represent data classes for readability.
+  }
+
+  private static final class ResourceOne {
+    // Empty class to represent resource classes for readability.
+  }
+
+  private static final class ResourceTwo {
+    // Empty class to represent another resource class for readability.
+  }
+
+  private static final class TranscodeOne {
+    // Empty class to represent transcode classes for readability.
+  }
+
+  private static final class TranscodeTwo {
+    // Empty class to represent transcode classes for readability.
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java b/library/test/src/test/java/com/bumptech/glide/RequestBuilderTest.java
similarity index 56%
rename from library/src/test/java/com/bumptech/glide/RequestBuilderTest.java
rename to library/test/src/test/java/com/bumptech/glide/RequestBuilderTest.java
index 22bab0325..140bf5b92 100644
--- a/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/RequestBuilderTest.java
@@ -2,21 +2,32 @@
 
 import static com.bumptech.glide.tests.BackgroundUtil.testInBackground;
 import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyBoolean;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Matchers.isA;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.app.Application;
 import android.widget.ImageView;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.resource.SimpleResource;
 import com.bumptech.glide.request.Request;
+import com.bumptech.glide.request.RequestListener;
 import com.bumptech.glide.request.RequestOptions;
+import com.bumptech.glide.request.SingleRequest;
 import com.bumptech.glide.request.target.Target;
-import com.bumptech.glide.tests.BackgroundUtil;
-import org.junit.After;
+import com.bumptech.glide.request.target.ViewTarget;
+import com.bumptech.glide.tests.BackgroundUtil.BackgroundTester;
+import com.bumptech.glide.tests.TearDownGlide;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Captor;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
@@ -27,24 +38,27 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class RequestBuilderTest {
-  @Mock GlideContext glideContext;
-  @Mock RequestManager requestManager;
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+
+  @Mock private RequestListener<Object> listener1;
+  @Mock private RequestListener<Object> listener2;
+  @Mock private Target<Object> target;
+  @Mock private GlideContext glideContext;
+  @Mock private RequestManager requestManager;
+  @Captor private ArgumentCaptor<SingleRequest<Object>> requestCaptor;
   private Glide glide;
+  private Application context;
 
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
     glide = Glide.get(RuntimeEnvironment.application);
-  }
-
-  @After
-  public void tearDown() {
-    Glide.tearDown();
+    context = RuntimeEnvironment.application;
   }
 
   @Test(expected = NullPointerException.class)
   public void testThrowsIfContextIsNull() {
-    new RequestBuilder<>(null /*context*/, requestManager, Object.class);
+    new RequestBuilder<>(null /*context*/, requestManager, Object.class, context);
   }
 
   @Test(expected = NullPointerException.class)
@@ -55,12 +69,11 @@ public void testThrowsWhenTransitionsOptionsIsNull() {
 
   @Test
   public void testDoesNotThrowWithNullModelWhenRequestIsBuilt() {
-    getNullModelRequest().into(mock(Target.class));
+    getNullModelRequest().into(target);
   }
 
   @Test
   public void testAddsNewRequestToRequestTracker() {
-    Target<Object> target = mock(Target.class);
     getNullModelRequest().into(target);
 
     verify(requestManager).track(eq(target), isA(Request.class));
@@ -69,7 +82,6 @@ public void testAddsNewRequestToRequestTracker() {
   @Test
   public void testRemovesPreviousRequestFromRequestTracker() {
     Request previous = mock(Request.class);
-    Target<Object> target = mock(Target.class);
     when(target.getRequest()).thenReturn(previous);
 
     getNullModelRequest().into(target);
@@ -91,11 +103,10 @@ public void testThrowsIfGivenNullView() {
   @Test(expected = RuntimeException.class)
   public void testThrowsIfIntoViewCalledOnBackgroundThread() throws InterruptedException {
     final ImageView imageView = new ImageView(RuntimeEnvironment.application);
-    testInBackground(new BackgroundUtil.BackgroundTester() {
+    testInBackground(new BackgroundTester() {
       @Override
-      public void runTest() throws Exception {
-        getNullModelRequest().into(imageView);
-
+      public void runTest() {
+       getNullModelRequest().into(imageView);
       }
     });
   }
@@ -103,23 +114,52 @@ public void runTest() throws Exception {
   @Test(expected = RuntimeException.class)
   public void testThrowsIfIntoTargetCalledOnBackgroundThread() throws InterruptedException {
     final Target<Object> target = mock(Target.class);
-    testInBackground(new BackgroundUtil.BackgroundTester() {
+    testInBackground(new BackgroundTester() {
       @Override
-      public void runTest() throws Exception {
-        getNullModelRequest().into(target);
+      public void runTest() {
+         getNullModelRequest().into(target);
       }
     });
   }
 
+  @Test
+  public void testMultipleRequestListeners() {
+    getNullModelRequest().addListener(listener1).addListener(listener2).into(target);
+    verify(requestManager).track(any(Target.class), requestCaptor.capture());
+    requestCaptor.getValue().onResourceReady(new SimpleResource<>(new Object()), DataSource.LOCAL);
+
+    verify(listener1)
+        .onResourceReady(
+            any(), any(), isA(Target.class), isA(DataSource.class), anyBoolean());
+    verify(listener2)
+        .onResourceReady(
+            any(), any(), isA(Target.class), isA(DataSource.class), anyBoolean());
+  }
+
+  @Test
+  public void testListenerApiOverridesListeners() {
+    getNullModelRequest().addListener(listener1).listener(listener2).into(target);
+    verify(requestManager).track(any(Target.class), requestCaptor.capture());
+    requestCaptor.getValue().onResourceReady(new SimpleResource<>(new Object()), DataSource.LOCAL);
+
+    // The #listener API removes any previous listeners, so the first listener should not be called.
+    verify(listener1, never())
+        .onResourceReady(
+            any(), any(), isA(Target.class), isA(DataSource.class), anyBoolean());
+    verify(listener2)
+        .onResourceReady(
+            any(), any(), isA(Target.class), isA(DataSource.class), anyBoolean());
+  }
+
   private RequestBuilder<Object> getNullModelRequest() {
     when(glideContext.buildImageViewTarget(isA(ImageView.class), isA(Class.class)))
-        .thenReturn(mock(Target.class));
+        .thenReturn(mock(ViewTarget.class));
     when(glideContext.getDefaultRequestOptions()).thenReturn(new RequestOptions());
     when(requestManager.getDefaultRequestOptions())
         .thenReturn(new RequestOptions());
     when(requestManager.getDefaultTransitionOptions(any(Class.class)))
         .thenReturn(new GenericTransitionOptions<>());
-    return new RequestBuilder<>(glide, requestManager, Object.class)
+    return new RequestBuilder<>(glide, requestManager, Object.class, context)
         .load((Object) null);
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/RequestManagerTest.java b/library/test/src/test/java/com/bumptech/glide/RequestManagerTest.java
similarity index 53%
rename from library/src/test/java/com/bumptech/glide/RequestManagerTest.java
rename to library/test/src/test/java/com/bumptech/glide/RequestManagerTest.java
index 68551d56d..a7a73ccae 100644
--- a/library/src/test/java/com/bumptech/glide/RequestManagerTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/RequestManagerTest.java
@@ -10,16 +10,29 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.app.Application;
 import android.content.Context;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.manager.ConnectivityMonitor;
 import com.bumptech.glide.manager.ConnectivityMonitor.ConnectivityListener;
 import com.bumptech.glide.manager.ConnectivityMonitorFactory;
 import com.bumptech.glide.manager.Lifecycle;
 import com.bumptech.glide.manager.RequestManagerTreeNode;
 import com.bumptech.glide.manager.RequestTracker;
+import com.bumptech.glide.request.target.BaseTarget;
+import com.bumptech.glide.request.target.SizeReadyCallback;
+import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.tests.BackgroundUtil;
 import com.bumptech.glide.tests.GlideShadowLooper;
+import com.bumptech.glide.tests.TearDownGlide;
+import java.io.File;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
@@ -33,27 +46,51 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = GlideShadowLooper.class)
 public class RequestManagerTest {
-  @Mock Lifecycle lifecycle = mock(Lifecycle.class);
-  @Mock RequestManagerTreeNode treeNode = mock(RequestManagerTreeNode.class);
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+
+  @Mock private Lifecycle lifecycle = mock(Lifecycle.class);
+  @Mock private RequestManagerTreeNode treeNode = mock(RequestManagerTreeNode.class);
 
   private RequestManager manager;
   private ConnectivityMonitor connectivityMonitor;
   private RequestTracker requestTracker;
   private ConnectivityListener connectivityListener;
+  private Application context;
+  private BaseTarget<Drawable> target;
 
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
+    context = RuntimeEnvironment.application;
     connectivityMonitor = mock(ConnectivityMonitor.class);
     ConnectivityMonitorFactory factory = mock(ConnectivityMonitorFactory.class);
     when(factory.build(isA(Context.class), isA(ConnectivityMonitor.ConnectivityListener.class)))
         .thenAnswer(new Answer<ConnectivityMonitor>() {
           @Override
-          public ConnectivityMonitor answer(InvocationOnMock invocation) throws Throwable {
+          public ConnectivityMonitor answer(InvocationOnMock invocation) {
             connectivityListener = (ConnectivityListener) invocation.getArguments()[1];
             return connectivityMonitor;
           }
         });
+
+    target = new BaseTarget<Drawable>() {
+      @Override
+      public void onResourceReady(@NonNull Drawable resource,
+          @Nullable Transition<? super Drawable> transition) {
+        // Empty.
+      }
+
+      @Override
+      public void getSize(@NonNull SizeReadyCallback cb) {
+        // Empty.
+      }
+
+      @Override
+      public void removeCallback(@NonNull SizeReadyCallback cb) {
+        // Empty.
+      }
+    };
+
     requestTracker = mock(RequestTracker.class);
     manager =
         new RequestManager(
@@ -61,7 +98,8 @@ public ConnectivityMonitor answer(InvocationOnMock invocation) throws Throwable
             lifecycle,
             treeNode,
             requestTracker,
-            factory);
+            factory,
+            context);
   }
 
   @Test
@@ -128,7 +166,7 @@ public void testDoesNotRestartRequestsOnDisconnected() {
   public void testThrowsIfResumeCalledOnBackgroundThread() throws InterruptedException {
     testInBackground(new BackgroundUtil.BackgroundTester() {
       @Override
-      public void runTest() throws Exception {
+      public void runTest() {
         manager.resumeRequests();
       }
     });
@@ -138,7 +176,7 @@ public void runTest() throws Exception {
   public void testThrowsIfPauseCalledOnBackgroundThread() throws InterruptedException {
     testInBackground(new BackgroundUtil.BackgroundTester() {
       @Override
-      public void runTest() throws Exception {
+      public void runTest() {
         manager.pauseRequests();
       }
     });
@@ -151,4 +189,85 @@ public void testDelegatesIsPausedToRequestTracker() {
     when(requestTracker.isPaused()).thenReturn(false);
     assertFalse(manager.isPaused());
   }
+
+  @Test
+  public void clear_withRequestStartedInSiblingManager_doesNotThrow() {
+    final RequestManager child1 = new RequestManager(Glide.get(context), lifecycle,
+        new RequestManagerTreeNode() {
+          @NonNull
+          @Override
+          public Set<RequestManager> getDescendants() {
+            return Collections.emptySet();
+          }
+        }, context);
+    final RequestManager child2 = new RequestManager(Glide.get(context), lifecycle,
+        new RequestManagerTreeNode() {
+          @NonNull
+          @Override
+          public Set<RequestManager> getDescendants() {
+            return Collections.emptySet();
+          }
+        }, context);
+    new RequestManager(Glide.get(context), lifecycle,
+        new RequestManagerTreeNode() {
+          @NonNull
+          @Override
+          public Set<RequestManager> getDescendants() {
+            return new HashSet<>(java.util.Arrays.asList(child1, child2));
+          }
+        }, context);
+
+    File file = new File("fake");
+    child1.load(file).into(target);
+    child2.clear(target);
+  }
+
+  @Test
+  public void clear_withRequestStartedInChildManager_doesNotThrow() {
+    final RequestManager child = new RequestManager(Glide.get(context), lifecycle,
+        new RequestManagerTreeNode() {
+          @NonNull
+          @Override
+          public Set<RequestManager> getDescendants() {
+            return Collections.emptySet();
+          }
+        }, context);
+    RequestManager parent = new RequestManager(Glide.get(context), lifecycle,
+        new RequestManagerTreeNode() {
+          @NonNull
+          @Override
+          public Set<RequestManager> getDescendants() {
+            return Collections.singleton(child);
+          }
+        }, context);
+
+    File file = new File("fake");
+    child.load(file).into(target);
+    parent.clear(target);
+  }
+
+  @Test
+  public void clear_withRequestStartedInParentManager_doesNotThrow() {
+    final RequestManager child = new RequestManager(Glide.get(context), lifecycle,
+        new RequestManagerTreeNode() {
+          @NonNull
+          @Override
+          public Set<RequestManager> getDescendants() {
+            return Collections.emptySet();
+          }
+        }, context);
+    RequestManager parent = new RequestManager(Glide.get(context), lifecycle,
+        new RequestManagerTreeNode() {
+          @NonNull
+          @Override
+          public Set<RequestManager> getDescendants() {
+            return Collections.singleton(child);
+          }
+        }, context);
+
+    File file = new File("fake");
+
+    parent.load(file).into(target);
+    child.clear(target);
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java b/library/test/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java
similarity index 80%
rename from library/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java
index 9a23a4680..6f2fc9d50 100644
--- a/library/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java
@@ -14,11 +14,12 @@
 
 import android.app.Application;
 import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.KeyTester;
 import com.bumptech.glide.tests.Util;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -29,12 +30,13 @@
 @RunWith(JUnit4.class)
 @SuppressWarnings("unchecked")
 public class MultiTransformationTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
 
-  @Mock Transformation<Object> first;
-  @Mock Transformation<Object> second;
-  @Mock Resource<Object> initial;
-  @Mock Resource<Object> firstTransformed;
-  @Mock Resource<Object> secondTransformed;
+  @Mock private Transformation<Object> first;
+  @Mock private Transformation<Object> second;
+  @Mock private Resource<Object> initial;
+  @Mock private Resource<Object> firstTransformed;
+  @Mock private Resource<Object> secondTransformed;
   private Application context;
 
   @Before
@@ -42,6 +44,11 @@ public void setUp() {
     MockitoAnnotations.initMocks(this);
 
     context = RuntimeEnvironment.application;
+
+    doAnswer(new Util.WriteDigest("first")).when(first)
+        .updateDiskCacheKey(any(MessageDigest.class));
+    doAnswer(new Util.WriteDigest("second")).when(second)
+        .updateDiskCacheKey(any(MessageDigest.class));
   }
 
   @Test
@@ -123,13 +130,20 @@ public void testIntermediateResourcesAreRecycled() {
 
   @Test
   public void testEquals() throws NoSuchAlgorithmException {
-    doAnswer(new Util.WriteDigest("first")).when(first)
-        .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertSame(new MultiTransformation<>(first), new MultiTransformation<>(first));
+    keyTester
+        .addEquivalenceGroup(
+            new MultiTransformation<>(first),
+            new MultiTransformation<>(first))
+        .addEquivalenceGroup(new MultiTransformation<>(second))
+        .addEquivalenceGroup(new MultiTransformation<>(first, second))
+        .addEquivalenceGroup(new MultiTransformation<>(second, first))
+        .addRegressionTest(
+            new MultiTransformation<>(first),
+            "a7937b64b8caa58f03721bb6bacf5c78cb235febe0e70b1b84cd99541461a08e")
+        .addRegressionTest(
+            new MultiTransformation<>(first, second),
+            "da83f63e1a473003712c18f5afc5a79044221943d1083c7c5a7ac7236d85e8d2")
+        .test();
 
-    doAnswer(new Util.WriteDigest("second")).when(second)
-        .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertDifferent(
-        new MultiTransformation<>(first), new MultiTransformation<>(second));
   }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/OptionsTest.java b/library/test/src/test/java/com/bumptech/glide/load/OptionsTest.java
new file mode 100644
index 000000000..67ee5b193
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/OptionsTest.java
@@ -0,0 +1,78 @@
+package com.bumptech.glide.load;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.load.Option.CacheKeyUpdater;
+import com.bumptech.glide.tests.KeyTester;
+import java.nio.ByteBuffer;
+import java.security.MessageDigest;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class OptionsTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
+
+  @Test
+  public void testEquals() {
+    Option<Object> firstMemoryOption = Option.memory("firstKey");
+    Object firstValue = new Object();
+    Option<Object> secondMemoryOption = Option.memory("secondKey");
+    Object secondValue = new Object();
+
+    CacheKeyUpdater<Integer> updater = new CacheKeyUpdater<Integer>() {
+      @Override
+      public void update(@NonNull byte[] keyBytes, @NonNull Integer value,
+          @NonNull MessageDigest messageDigest) {
+        messageDigest.update(keyBytes);
+        messageDigest.update(ByteBuffer.allocate(4).putInt(value).array());
+
+      }
+    };
+    Option<Integer> firstDiskOption = Option.disk("firstDisk", updater);
+    Option<Integer> secondDiskOption = Option.disk("secondDisk", updater);
+
+    keyTester
+        .addEquivalenceGroup(new Options(), new Options())
+        .addEquivalenceGroup(
+            new Options().set(firstMemoryOption, firstValue),
+            new Options().set(firstMemoryOption, firstValue))
+        .addEquivalenceGroup(
+            new Options().set(secondMemoryOption, secondValue),
+            new Options().set(secondMemoryOption, secondValue))
+        .addEquivalenceGroup(
+            new Options().set(firstMemoryOption, firstValue).set(secondMemoryOption, secondValue),
+            new Options().set(firstMemoryOption, firstValue).set(secondMemoryOption, secondValue),
+            new Options().set(secondMemoryOption, secondValue).set(firstMemoryOption, firstValue))
+        .addEquivalenceGroup(
+            new Options().set(firstMemoryOption, secondValue))
+        .addEquivalenceGroup(
+            new Options().set(secondMemoryOption, firstValue))
+        .addEquivalenceGroup(
+            new Options().set(firstDiskOption, 1),
+            new Options().set(firstDiskOption, 1))
+        .addEquivalenceGroup(
+            new Options().set(secondDiskOption, 1),
+            new Options().set(secondDiskOption, 1))
+        .addEquivalenceGroup(
+            new Options().set(firstDiskOption, 2))
+        .addEquivalenceGroup(
+            new Options().set(secondDiskOption, 2))
+        .addEquivalenceGroup(
+            new Options().set(firstDiskOption, 1).set(secondDiskOption, 2),
+            new Options().set(secondDiskOption, 2).set(firstDiskOption, 1))
+        .addEmptyDigestRegressionTest(new Options().set(firstMemoryOption, firstValue))
+        .addEmptyDigestRegressionTest(
+            new Options().set(firstMemoryOption, firstValue).set(secondMemoryOption, secondValue))
+        .addRegressionTest(
+            new Options().set(firstDiskOption, 123),
+            "3c87124d1a765dc3d566f947d536ef140a4aca645c0947f702356714855b4a8e")
+        .addRegressionTest(
+            new Options().set(firstDiskOption, 123).set(secondDiskOption, 123),
+            "6697f654686c9a925905db3840e9c99944642c2b91d6200360d77639c1754d51")
+        .test();
+  }
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/load/data/BufferedOutputStreamFuzzTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/BufferedOutputStreamFuzzTest.java
new file mode 100644
index 000000000..21e6120a1
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/BufferedOutputStreamFuzzTest.java
@@ -0,0 +1,172 @@
+package com.bumptech.glide.load.data;
+
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.when;
+
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Random;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+
+/**
+ * Runs some tests based on a random seed that asserts the output of writing to our buffered stream
+ * matches the output of writing to {@link java.io.ByteArrayOutputStream}.
+ */
+@RunWith(JUnit4.class)
+public class BufferedOutputStreamFuzzTest {
+  private static final int TESTS = 500;
+  private static final int BUFFER_SIZE = 10;
+  private static final int WRITES_PER_TEST = 50;
+  private static final int MAX_BYTES_PER_WRITE = BUFFER_SIZE * 6;
+  private static final Random RANDOM = new Random(-3207167907493985134L);
+
+  @Mock private ArrayPool arrayPool;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
+    when(arrayPool.get(anyInt(), eq(byte[].class)))
+        .thenAnswer(new Answer<byte[]>() {
+          @Override
+          public byte[] answer(InvocationOnMock invocation) throws Throwable {
+            int size = (Integer) invocation.getArguments()[0];
+            return new byte[size];
+          }
+        });
+  }
+
+  @Test
+  public void runFuzzTest() throws IOException {
+    for (int i = 0; i < TESTS; i++) {
+      runTest(RANDOM);
+    }
+  }
+
+  private void runTest(Random random) throws IOException {
+    List<Write> writes = new ArrayList<>(WRITES_PER_TEST);
+    for (int i = 0; i < WRITES_PER_TEST; i++) {
+      WriteType writeType = getType(random);
+      writes.add(getWrite(random, writeType));
+    }
+
+    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
+
+    ByteArrayOutputStream wrapped = new ByteArrayOutputStream();
+    BufferedOutputStream bufferedOutputStream =
+        new BufferedOutputStream(wrapped, arrayPool, BUFFER_SIZE);
+
+    for (Write write : writes) {
+      switch (write.writeType) {
+        case BYTE:
+          byteArrayOutputStream.write(write.data[0]);
+          bufferedOutputStream.write(write.data[0]);
+          break;
+        case BUFFER:
+          byteArrayOutputStream.write(write.data);
+          bufferedOutputStream.write(write.data);
+          break;
+        case OFFSET_BUFFER:
+          byteArrayOutputStream.write(write.data, write.offset, write.length);
+          bufferedOutputStream.write(write.data, write.offset, write.length);
+          break;
+        default:
+            throw new IllegalArgumentException();
+      }
+    }
+
+    byte[] fromByteArrayStream = byteArrayOutputStream.toByteArray();
+    bufferedOutputStream.close();
+    byte[] fromWrappedStream = wrapped.toByteArray();
+    if (!Arrays.equals(fromWrappedStream, fromByteArrayStream)) {
+      StringBuilder writesBuilder = new StringBuilder();
+      for (Write write : writes) {
+        writesBuilder.append(write).append("\n");
+      }
+      fail("Expected: " + Arrays.toString(fromByteArrayStream) + "\n"
+          + "but got: " + Arrays.toString(fromWrappedStream) + "\n"
+          + writesBuilder.toString());
+    }
+  }
+
+  private Write getWrite(Random random, WriteType type) {
+    switch (type) {
+      case BYTE:
+        return getByteWrite(random);
+      case BUFFER:
+        return getBufferWrite(random);
+      case OFFSET_BUFFER:
+        return getOffsetBufferWrite(random);
+      default:
+        throw new IllegalArgumentException("Unrecognized type: " + type);
+    }
+  }
+
+  private Write getOffsetBufferWrite(Random random) {
+    int dataSize = random.nextInt(MAX_BYTES_PER_WRITE * 2);
+    byte[] data = new byte[dataSize];
+    int length = dataSize == 0 ? 0 : random.nextInt(dataSize);
+    int offset = dataSize - length <= 0 ? 0 : random.nextInt(dataSize - length);
+    random.nextBytes(data);
+    return new Write(data, length, offset, WriteType.OFFSET_BUFFER);
+  }
+
+  private Write getBufferWrite(Random random) {
+    byte[] data = new byte[random.nextInt(MAX_BYTES_PER_WRITE)];
+    random.nextBytes(data);
+    return new Write(data, /*length=*/ data.length, /*offset=*/ 0, WriteType.BUFFER);
+  }
+
+  private Write getByteWrite(Random random) {
+    byte[] data = new byte[1];
+    random.nextBytes(data);
+    return new Write(data, /*length=*/ 1, /*offset=*/ 0, WriteType.BYTE);
+  }
+
+  private WriteType getType(Random random) {
+    return WriteType.values()[random.nextInt(WriteType.values().length)];
+  }
+
+  private static final class Write {
+    private final byte[] data;
+    private final int length;
+    private final int offset;
+    private final WriteType writeType;
+
+    @Override
+    public String toString() {
+      return "Write{"
+          + "data=" + Arrays.toString(data)
+          + ", length=" + length
+          + ", offset=" + offset
+          + ", writeType=" + writeType
+          + '}';
+    }
+
+    Write(byte[] data, int length, int offset, WriteType writeType) {
+      this.data = data;
+      this.length = length;
+      this.offset = offset;
+      this.writeType = writeType;
+    }
+  }
+
+  private enum WriteType {
+    BYTE,
+    BUFFER,
+    OFFSET_BUFFER
+  }
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/load/data/BufferedOutputStreamTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/BufferedOutputStreamTest.java
new file mode 100644
index 000000000..ab32ce4a5
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/BufferedOutputStreamTest.java
@@ -0,0 +1,940 @@
+package com.bumptech.glide.load.data;
+
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertThrows;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.function.ThrowingRunnable;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(JUnit4.class)
+public class BufferedOutputStreamTest {
+  @Mock private ArrayPool arrayPool;
+  @Mock private OutputStream mockOutputStream;
+
+  private final int bufferSize = 10;
+  private final ByteArrayOutputStream inner = new ByteArrayOutputStream();
+  private int currentValue = 0;
+  private BufferedOutputStream os;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
+    when(arrayPool.get(bufferSize, byte[].class)).thenReturn(new byte[bufferSize]);
+    os = new BufferedOutputStream(inner, arrayPool, bufferSize);
+  }
+
+  @Test
+  public void constructor_obtainsBufferFromArrayPool() {
+    verify(arrayPool).get(bufferSize, byte[].class);
+  }
+
+  @Test
+  public void close_returnsBufferObtainedFromConstructor() throws IOException {
+    byte[] data = new byte[bufferSize];
+    when(arrayPool.get(bufferSize, byte[].class)).thenReturn(data);
+    os = new BufferedOutputStream(inner, arrayPool, bufferSize);
+
+    os.close();
+    verify(arrayPool).put(data);
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andSingleByte_doesNotWriteToStream() throws IOException {
+    os.write(next());
+
+    assertThat(inner.toByteArray()).isEmpty();
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andDataSmallerThanBuffer_doesNotWriteToStream()
+      throws IOException {
+    os.write(next(bufferSize - 1));
+
+    assertThat(inner.toByteArray()).isEmpty();
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andDataWithOffsetSizeSmallerThanBuffer_doesNotWriteToStream()
+    throws IOException {
+    int offset = 1;
+    int length = bufferSize - offset;
+    byte[] data = nextWithOffset(offset, length);
+    os.write(data, offset, length);
+
+    assertThat(inner.toByteArray()).isEmpty();
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andDataWithPaddingSizeSmallerThanBuffer_doesNotWriteToStream()
+    throws IOException {
+    int padding = 1;
+    int length = bufferSize - padding;
+    byte[] data = nextWithPadding(length, padding);
+    os.write(data, 0, length);
+
+    assertThat(inner.toByteArray()).isEmpty();
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andDataEqualToBufferSize_writesDataToStream()
+      throws IOException {
+    os.write(next(bufferSize));
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andDataGreaterThanBufferSize_writesDataToStream()
+      throws IOException {
+    os.write(next(bufferSize + 1));
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andDataWithOffsetAndLengthEqualToBufferSize_writesDataToStream()
+      throws IOException {
+    int offset = 5;
+    int length = bufferSize;
+    byte[] data = nextWithOffset(offset, length);
+    os.write(data, offset, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andDataWithPaddingAndLengthEqualToBufferSize_writesData()
+      throws IOException {
+    int padding = 5;
+    int length = bufferSize;
+    byte[] data = nextWithPadding(length, padding);
+    os.write(data, 0, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andDataWithOffsetAndLengthGreaterThanBuffer_writesDataToStream()
+      throws IOException {
+    int offset = 5;
+    int length = bufferSize + 1;
+    byte[] data = nextWithOffset(offset, length);
+    os.write(data, offset, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andDataWithPaddingAndLengthGreaterThanBuffer_writesData()
+      throws IOException {
+    int padding = 5;
+    int length = bufferSize + 1;
+    byte[] data = nextWithPadding(length, padding);
+    os.write(data, 0, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void writeSingleByte_whenBufferAlmostFull_writesBufferToStream() throws IOException {
+    for (int i = 0; i < bufferSize; i++) {
+      os.write(next());
+    }
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flush_withSingleByteInBuffer_writesBufferToStream() throws IOException {
+    os.write(next());
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flush_afterWritingByteAfterBufferFull_writesByteToStream() throws IOException {
+    for (int i = 0; i < bufferSize; i++) {
+      os.write(next());
+    }
+
+    os.write(next());
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flushAfterPreviousFlush_withSingleByte_writesOnlySingleByte() throws IOException {
+    os.write(next());
+    os.flush();
+    os.write(next());
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_withSingleByteInBuffer_writesBufferToStream() throws IOException {
+    os.write(next());
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWritingByteAfterBufferFull_writesByteToStream() throws IOException {
+    for (int i = 0; i < bufferSize; i++) {
+      os.write(next());
+    }
+
+    os.write(next());
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void closeAfterPreviousFlush_withSingleByte_writesOnlySingleByte() throws IOException {
+    os.write(next());
+    os.flush();
+    os.write(next());
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withDataInBuffer_bufferLessThanRemaining_doesNotWriteToStream()
+      throws IOException {
+    os.write(next());
+    os.write(next(remaining() - 1));
+
+    assertThat(inner.toByteArray()).isEmpty();
+  }
+
+  @Test
+  public void flush_afterWriteWithDataInBuffer_bufferLessThanRemaining_writesToStream()
+      throws IOException {
+    os.write(next());
+    byte[] data = next(remaining() - 1);
+
+    os.write(data);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteWithDataInBuffer_bufferLessThanRemaining_writesToStream()
+      throws IOException {
+    os.write(next());
+    byte[] data = next(remaining());
+
+    os.write(data);
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withBufferEqualToRemaining_lessThanLength_writesToStream() throws IOException {
+    os.write(next());
+    os.write(next(remaining()));
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flush_afterWriteBufferEqualToRemaining_doesNothing() throws IOException {
+    os.write(next());
+    os.write(next(remaining()));
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteBufferEqualToRemaining_doesNothing() throws IOException {
+    os.write(next());
+    os.write(next(remaining()));
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withOffsetBufferEqualToRemaining_lessThanLength_writesToStream()
+      throws IOException {
+    os.write(next());
+    int offset = 5;
+    int length = remaining();
+    os.write(nextWithOffset(offset, length), offset, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flush_afterWriteOffsetBufferEqualToRemaining_lessThanLength_writesToStream()
+      throws IOException {
+    os.write(next());
+    int offset = 5;
+    int length = remaining();
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteOffsetBufferEqualToRemaining_lessThanLength_writesToStream()
+      throws IOException {
+    os.write(next());
+    int offset = 5;
+    int length = remaining();
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withPaddedBufferEqualToRemaining_lessThanLength_writesToStream()
+      throws IOException {
+    os.write(next());
+    int padding = 5;
+    int length = remaining();
+    os.write(nextWithPadding(length, padding), 0, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flush_afterWritePaddedBufferEqualToRemaining_lessThanLength_writesToStream()
+      throws IOException {
+    os.write(next());
+    int padding = 5;
+    int length = remaining();
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWritePaddedBufferEqualToRemaining_lessThanLength_writesToStream()
+      throws IOException {
+    os.write(next());
+    int padding = 5;
+    int length = remaining();
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withBufferGreaterThanRemaining_lessThanLength_writesUpToBufferToStream()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize - 1));
+
+    assertThat(inner.toByteArray()).isEqualTo(upTo(bufferSize));
+  }
+
+  @Test
+  public void flush_afterWriteBufferGreaterThanRemaining_lessThanLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize - 1));
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteBufferGreaterThanRemaining_lessThanLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize - 1));
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withOffsetBufferGreaterThanRemaining_lessThanLength_writesUpToBuffer()
+      throws IOException {
+    os.write(next(2));
+    int offset = 5;
+    int length = bufferSize - 1;
+    os.write(nextWithOffset(offset, length), offset, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(upTo(bufferSize));
+  }
+
+  @Test
+  public void flush_afterWriteOffsetBufferGreaterThanRemaining_lessThanLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int offset = 5;
+    int length = bufferSize - 1;
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteOffsetBufferGreaterThanRemaining_lessThanLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int offset = 5;
+    int length = bufferSize - 1;
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withPaddedBufferGreaterThanRemaining_lessThanLength_writesUpToBuffer()
+      throws IOException {
+    os.write(next(2));
+    int padding = 5;
+    int length = bufferSize - 1;
+    os.write(nextWithPadding(length, padding), 0, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(upTo(bufferSize));
+  }
+
+  @Test
+  public void flush_afterWritePaddedBufferGreaterThanRemaining_lessThanLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int padding = 5;
+    int length = bufferSize - 1;
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWritePaddedBufferGreaterThanRemaining_lessThanLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int padding = 5;
+    int length = bufferSize - 1;
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withBufferGreaterThanRemaining_equalToLength_writesUpToBufferToStream()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize));
+
+    assertThat(inner.toByteArray()).isEqualTo(upTo(bufferSize));
+  }
+
+  @Test
+  public void flush_afterWriteBufferGreaterThanRemaining_equalToLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize));
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteBufferGreaterThanRemaining_equalToLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize));
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withOffsetBufferGreaterThanRemaining_equalToLength_writesUpToBufferToStream()
+      throws IOException {
+    os.write(next(2));
+    int offset = 6;
+    int length = bufferSize;
+    os.write(nextWithOffset(offset, length), offset, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(upTo(bufferSize));
+  }
+
+  @Test
+  public void flush_afterWriteOffsetBufferGreaterThanRemaining_equalToLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int offset = 6;
+    int length = bufferSize;
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteOffsetBufferGreaterThanRemaining_equalToLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int offset = 6;
+    int length = bufferSize;
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withPaddedBufferGreaterThanRemaining_equalToLength_writesUpToBufferToStream()
+      throws IOException {
+    os.write(next(2));
+    int padding = 6;
+    int length = bufferSize;
+    os.write(nextWithPadding(length, padding), 0, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(upTo(bufferSize));
+  }
+
+  @Test
+  public void flush_afterWritePaddedBufferGreaterThanRemaining_equalToLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int padding = 6;
+    int length = bufferSize;
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWritePaddedBufferGreaterThanRemaining_equalToLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int padding = 6;
+    int length = bufferSize;
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withBufferGreaterThanRemaining_greaterThanLength_writesUpToBufferToStream()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize + 1));
+
+    assertThat(inner.toByteArray()).isEqualTo(upTo(bufferSize));
+  }
+
+  @Test
+  public void flush_afterWriteBufferGreaterThanRemaining_greaterThanLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize + 1));
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteBufferGreaterThanRemaining_greaterThanLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize + 1));
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withOffsetBufferGreaterThanRemaining_greaterThanLength_writesUpToBuffer()
+      throws IOException {
+    os.write(next(2));
+    int offset = 2;
+    int length = bufferSize + 1;
+    os.write(nextWithOffset(offset, length), offset, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(upTo(bufferSize));
+  }
+
+  @Test
+  public void flush_afterWriteOffsetBufferGreaterThanRemaining_greaterThanLength_writesAllToStream()
+      throws IOException {
+    os.write(next(2));
+    int offset = 2;
+    int length = bufferSize + 1;
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteOffsetBufferGreaterThanRemaining_greaterThanLength_writesAllToStream()
+      throws IOException {
+    os.write(next(2));
+    int offset = 2;
+    int length = bufferSize + 1;
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withPaddedBufferGreaterThanRemaining_greaterThanLength_writesUpToBuffer()
+      throws IOException {
+    os.write(next(2));
+    int padding = 2;
+    int length = bufferSize + 1;
+    os.write(nextWithPadding(length, padding), 0, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(upTo(bufferSize));
+  }
+
+  @Test
+  public void flush_afterWritePaddedBufferGreaterThanRemaining_greaterThanLength_writesAllToStream()
+      throws IOException {
+    os.write(next(2));
+    int padding = 2;
+    int length = bufferSize + 1;
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWritePaddedBufferGreaterThanRemaining_greaterThanLength_writesAllToStream()
+      throws IOException {
+    os.write(next(2));
+    int padding = 2;
+    int length = bufferSize + 1;
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withBufferMoreThanRemains_greaterThanTwiceLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize * 2 + 1));
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flush_afterWriteBufferMoreThanRemains_greaterThanTwiceLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize * 2 + 1));
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteBufferMoreThanRemains_greaterThanTwiceLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize * 2 + 1));
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withOffsetBufferMoreThanRemains_greaterThanTwiceLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int offset = bufferSize + 1;
+    int length = bufferSize * 2 + 2;
+    os.write(nextWithOffset(offset, length), offset, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flush_afterWriteOffsetBufferMoreThanRemains_greaterThanTwiceLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int offset = bufferSize + 1;
+    int length = bufferSize * 2 + 2;
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteOffsetBufferMoreThanRemains_greaterThanTwiceLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int offset = bufferSize + 1;
+    int length = bufferSize * 2 + 2;
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withPaddedBufferMoreThanRemains_greaterThanTwiceLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int padding = bufferSize + 1;
+    int length = bufferSize * 2 + 2;
+    os.write(nextWithPadding(length, padding), 0, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flush_afterWritePaddedBufferMoreThanRemains_greaterThanTwiceLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int padding = bufferSize + 1;
+    int length = bufferSize * 2 + 2;
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWritePaddedBufferMoreThanRemains_greaterThanTwiceLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int padding = bufferSize + 1;
+    int length = bufferSize * 2 + 2;
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flush_flushesUnderlyingStream() throws IOException {
+    os = new BufferedOutputStream(mockOutputStream, arrayPool, bufferSize);
+    os.flush();
+
+    verify(mockOutputStream).flush();
+  }
+
+  @Test
+  public void overflowBuffer_doesNotFlushUnderlyingStream() throws IOException {
+    os = new BufferedOutputStream(mockOutputStream, arrayPool, bufferSize);
+    os.write(1);
+    os.write(next(remaining() + 1));
+
+    verify(mockOutputStream, never()).flush();
+  }
+
+  @Test
+  public void close_closesUnderlyingStream() throws IOException {
+    os = new BufferedOutputStream(mockOutputStream, arrayPool, bufferSize);
+    os.close();
+
+    verify(mockOutputStream).close();
+  }
+
+  @Test
+  public void close_whenUnderlyingStreamThrows_closesStream() throws IOException {
+    os = new BufferedOutputStream(mockOutputStream, arrayPool, bufferSize);
+    doThrow(new IOException()).when(mockOutputStream).write(any(byte[].class), anyInt(), anyInt());
+
+    os.write(1);
+    try {
+      os.close();
+      fail("Failed to receive expected exception");
+    } catch (IOException e) {
+      // Expected.
+    }
+
+    verify(mockOutputStream).close();
+  }
+
+  @Test
+  public void flush_withZeroBytesWritten_doesNotWriteToStream() throws IOException {
+    os = new BufferedOutputStream(mockOutputStream, arrayPool, bufferSize);
+    os.flush();
+
+    verify(mockOutputStream, never()).write(anyInt());
+    verify(mockOutputStream, never()).write(any(byte[].class));
+    verify(mockOutputStream, never()).write(any(byte[].class), anyInt(), anyInt());
+  }
+
+  @Test
+  public void write_throwsIfOffsetIsLessThanZero() {
+    assertThrows(IndexOutOfBoundsException.class, new ThrowingRunnable() {
+      @Override
+      public void run() throws Throwable {
+        os.write(new byte[0], /*initialOffset=*/ -1, /*length=*/ 0);
+      }
+    });
+  }
+
+  @Test
+  public void write_throwsIfLengthIsLessThanZero() {
+    assertThrows(IndexOutOfBoundsException.class, new ThrowingRunnable() {
+      @Override
+      public void run() throws Throwable {
+        os.write(new byte[0], /*initialOffset=*/ 0, /*length=*/ -1);
+      }
+    });
+  }
+
+  @Test
+  public void write_throwsIfOffsetIsGreaterThanLength() {
+    assertThrows(IndexOutOfBoundsException.class, new ThrowingRunnable() {
+      @Override
+      public void run() throws Throwable {
+        os.write(new byte[0], /*initialOffset=*/ 1, /*length=*/ 0);
+      }
+    });
+  }
+
+  @Test
+  public void write_throwsIfLengthsIsGreaterThanLength() {
+    assertThrows(IndexOutOfBoundsException.class, new ThrowingRunnable() {
+      @Override
+      public void run() throws Throwable {
+        os.write(new byte[0], /*initialOffset=*/ 0, /*length=*/ 1);
+      }
+    });
+  }
+
+
+  @Test
+  public void write_throwsIfLengthAndOffsetsIsGreaterThanLength() {
+    assertThrows(IndexOutOfBoundsException.class, new ThrowingRunnable() {
+      @Override
+      public void run() throws Throwable {
+        os.write(new byte[1], /*initialOffset=*/ 1, /*length=*/ 1);
+      }
+    });
+  }
+
+  @Test
+  public void write_withZeroLengthBuffer_doesNothing() throws IOException {
+    os.write(new byte[0]);
+
+    assertThat(inner.toByteArray()).hasLength(0);
+  }
+
+  @Test
+  public void write_withZeroLengthBufferAndZeroOffsetAndLength_doesNothing() throws IOException {
+    os.write(new byte[0], 0, 0);
+
+    assertThat(inner.toByteArray()).hasLength(0);
+  }
+
+
+  @Test
+  public void write_afterWriteWithZeroLengthBuffer_writesExpected() throws IOException {
+    os.write(new byte[0]);
+    os.write(next());
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_afterWriteZeroLengthBufferAndZeroOffsetAndLength_writesExpected()
+      throws IOException {
+    os.write(new byte[0], 0, 0);
+    os.write(next());
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  private int soFar() {
+    return currentValue;
+  }
+
+  private int remaining() {
+    return bufferSize - soFar();
+  }
+
+  private int next() {
+    return nextWithOffset(0, 1)[0];
+  }
+
+  private byte[] next(int count) {
+    return nextWithOffset(0, count);
+  }
+
+  private byte[] nextWithPadding(int count, int padding) {
+    byte[] result = new byte[count + padding];
+    for (int i = 0; i < count; i++) {
+      result[i] = (byte) ++currentValue;
+    }
+    for (int i = count; i < count + padding; i++) {
+      result[i] = (byte) (i + currentValue);
+    }
+    return result;
+  }
+
+  private byte[] nextWithOffset(int offset, int count) {
+    byte[] result = new byte[offset + count];
+    for (int i = offset - 1; i >= 0; i--) {
+      result[i] = (byte) -offset;
+    }
+    for (int i = offset; i < offset + count; i++) {
+      result[i] = (byte) ++currentValue;
+    }
+    return result;
+  }
+
+  private byte[] upTo(int size) {
+    assertThat(size).isLessThan(currentValue);
+    byte[] result = new byte[size];
+    for (int i = 0; i < size; i++) {
+      result[i] = (byte) (i + 1);
+    }
+    return result;
+  }
+
+  private byte[] all() {
+    byte[] result = new byte[currentValue];
+    for (int i = 0; i < currentValue; i++) {
+      result[i] = (byte) (i + 1);
+    }
+    return result;
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
diff --git a/library/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java
similarity index 90%
rename from library/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java
index ae3982203..ef1bad28b 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java
@@ -23,18 +23,17 @@
 @Config(manifest = Config.NONE, sdk = 18)
 public class FileDescriptorAssetPathFetcherTest {
 
-  @Mock AssetManager assetManager;
-  @Mock AssetFileDescriptor assetFileDescriptor;
-  @Mock DataFetcher.DataCallback<ParcelFileDescriptor> callback;
+  @Mock private AssetManager assetManager;
+  @Mock private AssetFileDescriptor assetFileDescriptor;
+  @Mock private DataFetcher.DataCallback<ParcelFileDescriptor> callback;
 
   private FileDescriptorAssetPathFetcher fetcher;
   private ParcelFileDescriptor expected;
-  private String assetPath;
 
   @Before
   public void setUp() throws IOException {
     MockitoAnnotations.initMocks(this);
-    assetPath = "/some/asset/path";
+    String assetPath = "/some/asset/path";
     fetcher = new FileDescriptorAssetPathFetcher(assetManager, assetPath);
     expected = mock(ParcelFileDescriptor.class);
     when(assetFileDescriptor.getParcelFileDescriptor()).thenReturn(expected);
diff --git a/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
similarity index 90%
rename from library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
index 94fd216bf..044bf30e8 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
@@ -41,7 +41,7 @@
   private static final String DEFAULT_PATH = "/fakepath";
   private static final int TIMEOUT_TIME_MS = 300;
 
-  @Mock DataFetcher.DataCallback<InputStream> callback;
+  @Mock private DataFetcher.DataCallback<InputStream> callback;
 
   private MockWebServer mockWebServer;
   private boolean defaultFollowRedirects;
@@ -72,6 +72,7 @@ public void testReturnsInputStreamOnStatusOk() throws Exception {
     fetcher.loadData(Priority.HIGH, callback);
     verify(callback).onDataReady(streamCaptor.capture());
     TestUtil.assertStreamOf(expected, streamCaptor.getValue());
+    assertThat(mockWebServer.takeRequest().getMethod()).isEqualTo("GET");
   }
 
   @Test
@@ -83,6 +84,8 @@ public void testHandlesRedirect301s() throws Exception {
     getFetcher().loadData(Priority.LOW, callback);
     verify(callback).onDataReady(streamCaptor.capture());
     TestUtil.assertStreamOf(expected, streamCaptor.getValue());
+    assertThat(mockWebServer.takeRequest().getMethod()).isEqualTo("GET");
+    assertThat(mockWebServer.takeRequest().getMethod()).isEqualTo("GET");
   }
 
   @Test
@@ -94,6 +97,8 @@ public void testHandlesRedirect302s() throws Exception {
     getFetcher().loadData(Priority.LOW, callback);
     verify(callback).onDataReady(streamCaptor.capture());
     TestUtil.assertStreamOf(expected, streamCaptor.getValue());
+    assertThat(mockWebServer.takeRequest().getMethod()).isEqualTo("GET");
+    assertThat(mockWebServer.takeRequest().getMethod()).isEqualTo("GET");
   }
 
   @Test
@@ -106,9 +111,11 @@ public void testHandlesRelativeRedirects() throws Exception {
     verify(callback).onDataReady(streamCaptor.capture());
     TestUtil.assertStreamOf(expected, streamCaptor.getValue());
 
-    mockWebServer.takeRequest();
+    RecordedRequest first = mockWebServer.takeRequest();
+    assertThat(first.getMethod()).isEqualTo("GET");
     RecordedRequest second = mockWebServer.takeRequest();
     assertThat(second.getPath()).endsWith("/redirect");
+    assertThat(second.getMethod()).isEqualTo("GET");
   }
 
   @Test
@@ -126,9 +133,13 @@ public void testHandlesUpToFiveRedirects() throws Exception {
     verify(callback).onDataReady(streamCaptor.capture());
     TestUtil.assertStreamOf(expected, streamCaptor.getValue());
 
-    assertThat(mockWebServer.takeRequest().getPath()).contains(DEFAULT_PATH);
+    RecordedRequest request = mockWebServer.takeRequest();
+    assertThat(request.getPath()).contains(DEFAULT_PATH);
+    assertThat(request.getMethod()).isEqualTo("GET");
     for (int i = 0; i < numRedirects; i++) {
-      assertThat(mockWebServer.takeRequest().getPath()).contains(redirectBase + i);
+      RecordedRequest current = mockWebServer.takeRequest();
+      assertThat(current.getPath()).contains(redirectBase + i);
+      assertThat(current.getMethod()).isEqualTo("GET");
     }
   }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
similarity index 92%
rename from library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
index 7ad707409..9cd87e418 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
@@ -26,11 +26,11 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class HttpUrlFetcherTest {
-  @Mock HttpURLConnection urlConnection;
-  @Mock HttpUrlFetcher.HttpUrlConnectionFactory connectionFactory;
-  @Mock GlideUrl glideUrl;
-  @Mock InputStream stream;
-  @Mock DataFetcher.DataCallback<InputStream> callback;
+  @Mock private HttpURLConnection urlConnection;
+  @Mock private HttpUrlFetcher.HttpUrlConnectionFactory connectionFactory;
+  @Mock private GlideUrl glideUrl;
+  @Mock private InputStream stream;
+  @Mock private DataFetcher.DataCallback<InputStream> callback;
 
   private static final int TIMEOUT_MS = 100;
   private HttpUrlFetcher fetcher;
diff --git a/library/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
similarity index 95%
rename from library/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
index 71f98a7f2..9ca7a2924 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
@@ -9,7 +9,6 @@
 import android.content.Context;
 import android.net.Uri;
 import android.support.annotation.NonNull;
-
 import com.bumptech.glide.Priority;
 import java.io.Closeable;
 import java.io.FileNotFoundException;
@@ -27,7 +26,7 @@
 @Config(manifest = Config.NONE, sdk = 18)
 public class LocalUriFetcherTest {
   private TestLocalUriFetcher fetcher;
-  @Mock DataFetcher.DataCallback<Closeable> callback;
+  @Mock private DataFetcher.DataCallback<Closeable> callback;
 
   @Before
   public void setUp() {
@@ -62,7 +61,7 @@ public void testHandlesExceptionOnClose() throws Exception {
   private static class TestLocalUriFetcher extends LocalUriFetcher<Closeable> {
     final Closeable closeable = mock(Closeable.class);
 
-    public TestLocalUriFetcher(Context context, Uri uri) {
+    TestLocalUriFetcher(Context context, Uri uri) {
       super(context.getContentResolver(), uri);
     }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java
similarity index 89%
rename from library/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java
index 5b03e0f83..fb7e125ac 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java
@@ -20,17 +20,16 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class StreamAssetPathFetcherTest {
-  @Mock AssetManager assetManager;
-  @Mock InputStream expected;
-  @Mock DataFetcher.DataCallback<InputStream> callback;
+  @Mock private AssetManager assetManager;
+  @Mock private InputStream expected;
+  @Mock private DataFetcher.DataCallback<InputStream> callback;
 
   private StreamAssetPathFetcher fetcher;
-  private String assetPath;
 
   @Before
   public void setUp() throws IOException {
     MockitoAnnotations.initMocks(this);
-    assetPath = "/some/asset/path";
+    String assetPath = "/some/asset/path";
     fetcher = new StreamAssetPathFetcher(assetManager, assetPath);
     when(assetManager.open(eq(assetPath))).thenReturn(expected);
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java
similarity index 91%
rename from library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java
index 4ceec4c8f..0b59d74b1 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java
@@ -22,9 +22,9 @@
 @Config(manifest = Config.NONE, sdk = 18)
 public class ThumbFetcherTest {
 
-  @Mock ThumbnailStreamOpener opener;
-  @Mock DataFetcher.DataCallback<InputStream> callback;
-  @Mock InputStream expected;
+  @Mock private ThumbnailStreamOpener opener;
+  @Mock private DataFetcher.DataCallback<InputStream> callback;
+  @Mock private InputStream expected;
 
   private ThumbFetcher fetcher;
   private Uri uri;
diff --git a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
similarity index 92%
rename from library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
index 50535836c..7c25a0580 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
@@ -116,12 +116,12 @@ private static ContentResolver getContentResolver() {
   }
 
   private static class Harness {
-    MatrixCursor cursor = new MatrixCursor(new String[1]);
-    File file = new File("fake/uri");
-    Uri uri = Uri.fromFile(file);
-    ThumbnailQuery query = mock(ThumbnailQuery.class);
-    FileService service = mock(FileService.class);
-    ArrayPool byteArrayPool = new LruArrayPool();
+    final MatrixCursor cursor = new MatrixCursor(new String[1]);
+    final File file = new File("fake/uri");
+    final Uri uri = Uri.fromFile(file);
+    final ThumbnailQuery query = mock(ThumbnailQuery.class);
+    final FileService service = mock(FileService.class);
+    final ArrayPool byteArrayPool = new LruArrayPool();
 
     public Harness() {
       cursor.addRow(new String[] { file.getAbsolutePath() });
@@ -132,7 +132,7 @@ public Harness() {
     }
 
     public ThumbnailStreamOpener get() {
-      List<ImageHeaderParser> parsers = new ArrayList<ImageHeaderParser>();
+      List<ImageHeaderParser> parsers = new ArrayList<>();
       parsers.add(new DefaultImageHeaderParser());
       return new ThumbnailStreamOpener(
           parsers, service, query, byteArrayPool, getContentResolver());
diff --git a/library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
similarity index 91%
rename from library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
index 81687fa35..b4f8e7721 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
@@ -30,7 +30,8 @@
 @Config(manifest = Config.NONE, sdk = 18, shadows = { ContentResolverShadow.class })
 public class FileDescriptorLocalUriFetcherTest {
 
-  @Mock DataFetcher.DataCallback<ParcelFileDescriptor> callback;
+  @Mock
+  private DataFetcher.DataCallback<ParcelFileDescriptor> callback;
 
   @Before
   public void setUp() {
@@ -43,7 +44,7 @@ public void testLoadResource_returnsFileDescriptor() throws Exception {
     Uri uri = Uri.parse("file://nothing");
 
     ContentResolver contentResolver = context.getContentResolver();
-    ContentResolverShadow shadow = (ContentResolverShadow) Shadow.extract(contentResolver);
+    ContentResolverShadow shadow = Shadow.extract(contentResolver);
 
     AssetFileDescriptor assetFileDescriptor = mock(AssetFileDescriptor.class);
     ParcelFileDescriptor parcelFileDescriptor = mock(ParcelFileDescriptor.class);
@@ -62,7 +63,7 @@ public void testLoadResource_withNullFileDescriptor_callsLoadFailed() {
     Uri uri = Uri.parse("file://nothing");
 
     ContentResolver contentResolver = context.getContentResolver();
-    ContentResolverShadow shadow = (ContentResolverShadow) Shadow.extract(contentResolver);
+    ContentResolverShadow shadow = Shadow.extract(contentResolver);
     shadow.registerFileDescriptor(uri, null /*fileDescriptor*/);
 
     FileDescriptorLocalUriFetcher fetcher =
diff --git a/library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
similarity index 90%
rename from library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
index a7fb2d580..a1d83a5f6 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
@@ -27,7 +27,8 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = { ContentResolverShadow.class })
 public class StreamLocalUriFetcherTest {
-  @Mock DataFetcher.DataCallback<InputStream> callback;
+  @Mock
+  private DataFetcher.DataCallback<InputStream> callback;
 
   @Before
   public void setUp() {
@@ -40,7 +41,7 @@ public void testLoadResource_returnsInputStream() throws Exception {
     Uri uri = Uri.parse("file://nothing");
 
     ContentResolver contentResolver = context.getContentResolver();
-    ContentResolverShadow shadow = (ContentResolverShadow) Shadow.extract(contentResolver);
+    ContentResolverShadow shadow = Shadow.extract(contentResolver);
     shadow.registerInputStream(uri, new ByteArrayInputStream(new byte[0]));
 
     StreamLocalUriFetcher fetcher = new StreamLocalUriFetcher(context.getContentResolver(), uri);
@@ -54,7 +55,7 @@ public void testLoadResource_withNullInputStream_callsLoadFailed() {
     Uri uri = Uri.parse("file://nothing");
 
     ContentResolver contentResolver = context.getContentResolver();
-    ContentResolverShadow shadow = (ContentResolverShadow) Shadow.extract(contentResolver);
+    ContentResolverShadow shadow = Shadow.extract(contentResolver);
 
     shadow.registerInputStream(uri, null /*inputStream*/);
 
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/ActiveResourcesTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/ActiveResourcesTest.java
new file mode 100644
index 000000000..288ac29d5
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/ActiveResourcesTest.java
@@ -0,0 +1,395 @@
+package com.bumptech.glide.load.engine;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.verify;
+
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.engine.ActiveResources.DequeuedResourceCallback;
+import com.bumptech.glide.load.engine.ActiveResources.ResourceWeakReference;
+import com.bumptech.glide.load.engine.EngineResource.ResourceListener;
+import com.bumptech.glide.tests.GlideShadowLooper;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLooper;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(shadows = GlideShadowLooper.class)
+public class ActiveResourcesTest {
+
+  @Mock private ResourceListener listener;
+  @Mock private Key key;
+  @Mock private Resource<Object> resource;
+
+  private ActiveResources resources;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    resources = new ActiveResources(/*isActiveResourceRetentionAllowed=*/ true);
+    resources.setListener(listener);
+
+    reset(GlideShadowLooper.queue);
+  }
+
+  @After
+  public void tearDown() {
+    resources.shutdown();
+  }
+
+  @Test
+  public void get_withMissingKey_returnsNull() {
+    assertThat(resources.get(key)).isNull();
+  }
+
+  @Test
+  public void get_withActiveKey_returnsResource() {
+    EngineResource<Object> expected =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, expected);
+    assertThat(resources.get(key)).isEqualTo(expected);
+  }
+
+  @Test
+  public void get_withDeactivatedKey_returnsNull() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+    resources.deactivate(key);
+    assertThat(resources.get(key)).isNull();
+  }
+
+  @Test
+  public void deactivate_withNotActiveKey_doesNotThrow() {
+    resources.deactivate(key);
+  }
+
+  @Test
+  public void get_withActiveAndClearedKey_returnsNull() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+    resources.activeEngineResources.get(key).clear();
+    assertThat(resources.get(key)).isNull();
+  }
+
+  @Test
+  public void get_withActiveAndClearedKey_andCacheableResource_callsListenerWithWrappedResource() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+    resources.activeEngineResources.get(key).clear();
+    resources.get(key);
+
+    ArgumentCaptor<EngineResource<?>> captor = getEngineResourceCaptor();
+
+    verify(listener).onResourceReleased(eq(key), captor.capture());
+
+    assertThat(captor.getValue().getResource()).isEqualTo(resource);
+  }
+
+  @Test
+  public void get_withActiveAndClearedKey_andCacheableResource_callsListenerWithNotRecycleable() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+    resources.activeEngineResources.get(key).clear();
+    resources.get(key);
+
+    ArgumentCaptor<EngineResource<?>> captor = getEngineResourceCaptor();
+
+    verify(listener).onResourceReleased(eq(key), captor.capture());
+
+    captor.getValue().recycle();
+    verify(resource, never()).recycle();
+  }
+
+  @Test
+  public void get_withActiveAndClearedKey_andCacheableResource_callsListenerWithCacheable() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+    resources.activeEngineResources.get(key).clear();
+    resources.get(key);
+
+    ArgumentCaptor<EngineResource<?>> captor = getEngineResourceCaptor();
+
+    verify(listener).onResourceReleased(eq(key), captor.capture());
+
+    assertThat(captor.getValue().isCacheable()).isTrue();
+  }
+
+  @Test
+  public void get_withActiveAndClearedKey_andNotCacheableResource_doesNotCallListener() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ false, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+    resources.activeEngineResources.get(key).clear();
+    resources.get(key);
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  @Test
+  public void queueIdle_afterResourceRemovedFromActive_doesNotCallListener() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    resources.deactivate(key);
+
+    enqueueAndWaitForRef(weakRef);
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  @Test
+  public void queueIdle_withCacheableResourceInActive_callListener() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    enqueueAndWaitForRef(weakRef);
+
+    ArgumentCaptor<EngineResource<?>> captor = getEngineResourceCaptor();
+
+    verify(listener).onResourceReleased(eq(key), captor.capture());
+
+    EngineResource<?> released = captor.getValue();
+    assertThat(released.getResource()).isEqualTo(resource);
+    assertThat(released.isCacheable()).isTrue();
+
+    released.recycle();
+    verify(resource, never()).recycle();
+  }
+
+  @Test
+  public void queueIdle_withNotCacheableResourceInActive_doesNotCallListener() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ false, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    weakRef.enqueue();
+    enqueueAndWaitForRef(weakRef);
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  @Test
+  public void queueIdle_withCacheableResourceInActive_removesResourceFromActive()
+      throws InterruptedException {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    enqueueAndWaitForRef(weakRef);
+
+    assertThat(resources.get(key)).isNull();
+  }
+
+  @Test
+  public void queueIdle_withNotCacheableResourceInActive_removesResourceFromActive() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ false, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    enqueueAndWaitForRef(weakRef);
+
+    assertThat(resources.get(key)).isNull();
+  }
+
+  @Test
+  public void get_withQueuedReference_returnsResource() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    weakRef.enqueue();
+
+    assertThat(resources.get(key)).isEqualTo(engineResource);
+  }
+
+  @Test
+  public void get_withQueuedReference_doesNotNotifyListener() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    weakRef.enqueue();
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  @Test
+  public void queueIdle_withQueuedReferenceRetrievedFromGet_notifiesListener() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+
+    resources.get(key);
+
+    enqueueAndWaitForRef(weakRef);
+
+    ArgumentCaptor<EngineResource<?>> captor = getEngineResourceCaptor();
+    verify(listener).onResourceReleased(eq(key), captor.capture());
+    assertThat(captor.getValue().getResource()).isEqualTo(resource);
+  }
+
+  @Test
+  public void queueIdle_withQueuedReferenceRetrievedFromGetAndNotCacheable_doesNotNotifyListener() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ false, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    CountDownLatch latch = getLatchForClearedRef();
+    weakRef.enqueue();
+
+    resources.get(key);
+
+    waitForLatch(latch);
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  @Test
+  public void queueIdle_withQueuedReferenceDeactivated_doesNotNotifyListener() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    CountDownLatch latch = getLatchForClearedRef();
+    weakRef.enqueue();
+
+    resources.deactivate(key);
+
+    waitForLatch(latch);
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  @Test
+  public void queueIdle_afterReferenceQueuedThenReactivated_doesNotNotifyListener() {
+    EngineResource<Object> first =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, first);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    CountDownLatch latch = getLatchForClearedRef();
+    weakRef.enqueue();
+
+    EngineResource<Object> second =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, second);
+
+    waitForLatch(latch);
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  @Test
+  public void activate_withNonCacheableResource_doesNotSaveResource() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ false, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    assertThat(resources.activeEngineResources.get(key).resource).isNull();
+  }
+
+  @Test
+  public void get_withActiveClearedKey_cacheableResource_retentionDisabled_doesNotCallListener() {
+    resources = new ActiveResources(/*isActiveResourceRetentionAllowed=*/ false);
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+    resources.activeEngineResources.get(key).clear();
+    resources.get(key);
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  @Test
+  public void get_withQueuedReference_retentionDisabled_returnsResource() {
+    resources = new ActiveResources(/*isActiveResourceRetentionAllowed=*/ false);
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    weakRef.enqueue();
+
+    assertThat(resources.get(key)).isEqualTo(engineResource);
+  }
+
+  @Test
+  public void queueIdle_withQueuedReferenceRetrievedFromGet_retentionDisabled_doesNotNotify() {
+    resources = new ActiveResources(/*isActiveResourceRetentionAllowed=*/ false);
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    CountDownLatch latch = getLatchForClearedRef();
+    weakRef.enqueue();
+
+    resources.get(key);
+
+    waitForLatch(latch);
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  private void enqueueAndWaitForRef(ResourceWeakReference ref) {
+    CountDownLatch latch = getLatchForClearedRef();
+    ref.enqueue();
+    waitForLatch(latch);
+  }
+
+  private void waitForLatch(CountDownLatch latch) {
+     try {
+      latch.await(10, TimeUnit.SECONDS);
+    } catch (InterruptedException e) {
+      throw new RuntimeException(e);
+    }
+    ShadowLooper.getShadowMainLooper().runToEndOfTasks();
+  }
+
+  private CountDownLatch getLatchForClearedRef() {
+    final CountDownLatch toWait = new CountDownLatch(1);
+    resources.setDequeuedResourceCallback(new DequeuedResourceCallback() {
+      @Override
+      public void onResourceDequeued() {
+        toWait.countDown();
+      }
+    });
+    return toWait;
+  }
+
+  @SuppressWarnings("unchecked")
+  private static ArgumentCaptor<EngineResource<?>> getEngineResourceCaptor() {
+    return (ArgumentCaptor<EngineResource<?>>) (ArgumentCaptor<?>)
+        ArgumentCaptor.forClass(EngineResource.class);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java
similarity index 52%
rename from library/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java
index 01c767634..2bbc3ad67 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java
@@ -4,12 +4,13 @@
 import static org.mockito.Mockito.doAnswer;
 
 import com.bumptech.glide.load.Key;
-import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.KeyTester;
 import com.bumptech.glide.tests.Util.WriteDigest;
 import java.io.UnsupportedEncodingException;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -18,11 +19,12 @@
 
 @RunWith(JUnit4.class)
 public class DataCacheKeyTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
 
-  @Mock Key firstKey;
-  @Mock Key firstSignature;
-  @Mock Key secondKey;
-  @Mock Key secondSignature;
+  @Mock private Key firstKey;
+  @Mock private Key firstSignature;
+  @Mock private Key secondKey;
+  @Mock private Key secondSignature;
 
   @Before
   public void setUp() throws UnsupportedEncodingException {
@@ -38,29 +40,17 @@ public void setUp() throws UnsupportedEncodingException {
   }
 
   @Test
-  public void testDiffersIfIdDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    DataCacheKey first = new DataCacheKey(firstKey, firstSignature);
-    DataCacheKey second = new DataCacheKey(secondKey, firstSignature);
-
-    KeyAssertions.assertDifferent(first, second);
-  }
-
-  @Test
-  public void testDiffersIfSignatureDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    DataCacheKey first = new DataCacheKey(firstKey, firstSignature);
-    DataCacheKey second = new DataCacheKey(firstKey, secondSignature);
-
-    KeyAssertions.assertDifferent(first, second);
-  }
-
-  @Test
-  public void testSameIfIdAndSignatureAreTheSame()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    DataCacheKey first = new DataCacheKey(firstKey, firstSignature);
-    DataCacheKey second = new DataCacheKey(firstKey, firstSignature);
-
-    KeyAssertions.assertSame(first, second);
+  public void testEqualsHashCodeDigest() throws NoSuchAlgorithmException {
+    keyTester
+        .addEquivalenceGroup(
+            new DataCacheKey(firstKey, firstSignature),
+            new DataCacheKey(firstKey, firstSignature))
+        .addEquivalenceGroup(new DataCacheKey(firstKey, secondSignature))
+        .addEquivalenceGroup(new DataCacheKey(secondKey, firstSignature))
+        .addEquivalenceGroup(new DataCacheKey(secondKey, secondSignature))
+        .addRegressionTest(
+            new DataCacheKey(firstKey, firstSignature),
+            "801d7440d65a0e7c9ad0097d417f346dac4d4c4d5630724110fa3f3fe66236d9")
+        .test();
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
similarity index 80%
rename from library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
index 6a740e638..7734cd208 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
@@ -17,6 +17,7 @@
 import static org.mockito.Mockito.when;
 
 import android.os.Handler;
+import android.os.Looper;
 import android.support.v4.util.Pools;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
@@ -64,7 +65,8 @@ public void testListenerNotifiedJobCompleteOnOnResourceReady() {
 
     ShadowLooper.runUiThreadTasks();
 
-    verify(harness.listener).onEngineJobComplete(eq(harness.key), eq(harness.engineResource));
+    verify(harness.listener)
+        .onEngineJobComplete(eq(job), eq(harness.key), eq(harness.engineResource));
   }
 
   @Test
@@ -107,7 +109,8 @@ public void testListenerNotifiedJobCompleteOnException() {
     job.start(harness.decodeJob);
     job.onLoadFailed(new GlideException("test"));
     ShadowLooper.runUiThreadTasks();
-    verify(harness.listener).onEngineJobComplete(eq(harness.key), isNull(EngineResource.class));
+    verify(harness.listener)
+        .onEngineJobComplete(eq(job), eq(harness.key), isNull(EngineResource.class));
   }
 
   @Test
@@ -220,20 +223,21 @@ public void testDoesNotNotifyCancelledIfReceivedException() {
     job.start(harness.decodeJob);
     job.onLoadFailed(new GlideException("test"));
 
-    verify(harness.listener).onEngineJobComplete(eq(harness.key), isNull(EngineResource.class));
+    verify(harness.listener)
+        .onEngineJobComplete(eq(job), eq(harness.key), isNull(EngineResource.class));
     verify(harness.listener, never()).onEngineJobCancelled(any(EngineJob.class), any(Key.class));
   }
 
   @Test
   public void testReleasesResourceIfCancelledOnReady() {
-    ShadowLooper shadowLooper = Shadows.shadowOf(harness.mainHandler.getLooper());
-    shadowLooper.pause();
+    Looper looper = harness.mainHandler.getLooper();
+    Shadows.shadowOf(looper).pause();
 
     EngineJob<Object> job = harness.getJob();
     job.start(harness.decodeJob);
     job.onResourceReady(harness.resource, harness.dataSource);
     job.cancel();
-    shadowLooper.runOneTask();
+    Shadows.shadowOf(looper).runOneTask();
 
     verify(harness.resource).recycle();
   }
@@ -423,7 +427,7 @@ public void testSubmitsDecodeJobToSourceServiceOnSubmitForSource() {
   public void testSubmitsDecodeJobToDiskCacheServiceWhenDecodingFromCacheOnStart() {
     EngineJob<Object> job = harness.getJob();
     when(harness.decodeJob.willDecodeFromCache()).thenReturn(true);
-    harness.diskCacheService.shutdownNow();
+    harness.sourceService.shutdownNow();
     job.start(harness.decodeJob);
 
     verify(harness.decodeJob).run();
@@ -453,27 +457,43 @@ public void testSubmitsDecodeJobToUnlimitedSourceServiceWhenDecodingFromSourceOn
 
   @SuppressWarnings("unchecked")
   private static class MultiCbHarness {
-    Key key = mock(Key.class);
-    Resource<Object> resource = mockResource();
-    EngineResource<Object> engineResource = mock(EngineResource.class);
-    EngineJobListener listener = mock(EngineJobListener.class);
-    boolean isCacheable = true;
-    boolean useUnlimitedSourceGeneratorPool = false;
-    int numCbs = 10;
-    List<ResourceCallback> cbs = new ArrayList<>();
-    EngineJob.EngineResourceFactory factory = mock(EngineJob.EngineResourceFactory.class);
-    EngineJob<Object> job;
-    GlideExecutor diskCacheService = MockGlideExecutor.newMainThreadExecutor();
-    GlideExecutor sourceService = MockGlideExecutor.newMainThreadExecutor();
-    GlideExecutor sourceUnlimitedService = MockGlideExecutor.newMainThreadUnlimitedExecutor();
-    Pools.Pool<EngineJob<?>> pool = new Pools.SimplePool<>(1);
-    DecodeJob<Object> decodeJob = mock(DecodeJob.class);
-    DataSource dataSource = DataSource.LOCAL;
+    final Key key = mock(Key.class);
+    final Resource<Object> resource = mockResource();
+    final EngineResource<Object> engineResource = mock(EngineResource.class);
+    final EngineJobListener listener = mock(EngineJobListener.class);
+    final boolean isCacheable = true;
+    final boolean useUnlimitedSourceGeneratorPool = false;
+    final boolean useAnimationPool = false;
+    final boolean onlyRetrieveFromCache = false;
+    final int numCbs = 10;
+    final List<ResourceCallback> cbs = new ArrayList<>();
+    final EngineJob.EngineResourceFactory factory = mock(EngineJob.EngineResourceFactory.class);
+    final EngineJob<Object> job;
+    final GlideExecutor diskCacheService = MockGlideExecutor.newMainThreadExecutor();
+    final GlideExecutor sourceService = MockGlideExecutor.newMainThreadExecutor();
+    final GlideExecutor sourceUnlimitedService = MockGlideExecutor.newMainThreadExecutor();
+    final GlideExecutor animationService = MockGlideExecutor.newMainThreadExecutor();
+    final Pools.Pool<EngineJob<?>> pool = new Pools.SimplePool<>(1);
+    final DecodeJob<Object> decodeJob = mock(DecodeJob.class);
+    final DataSource dataSource = DataSource.LOCAL;
 
     public MultiCbHarness() {
       when(factory.build(eq(resource), eq(isCacheable))).thenReturn(engineResource);
-      job = new EngineJob<>(diskCacheService, sourceService, sourceUnlimitedService, listener, pool,
-          factory).init(key, isCacheable, useUnlimitedSourceGeneratorPool);
+      job =
+          new EngineJob<>(
+              diskCacheService,
+              sourceService,
+              sourceUnlimitedService,
+              animationService,
+              listener,
+              pool,
+              factory);
+      job.init(
+          key,
+          isCacheable,
+          useUnlimitedSourceGeneratorPool,
+          useAnimationPool,
+          onlyRetrieveFromCache);
       for (int i = 0; i < numCbs; i++) {
         cbs.add(mock(ResourceCallback.class));
       }
@@ -485,27 +505,42 @@ public MultiCbHarness() {
 
   @SuppressWarnings("unchecked")
   private static class EngineJobHarness {
-    EngineJob.EngineResourceFactory factory = mock(EngineJob.EngineResourceFactory.class);
-    Key key = mock(Key.class);
-    Handler mainHandler = new Handler();
-    ResourceCallback cb = mock(ResourceCallback.class);
-    Resource<Object> resource = mockResource();
-    EngineResource<Object> engineResource = mock(EngineResource.class);
-    EngineJobListener listener = mock(EngineJobListener.class);
-    GlideExecutor diskCacheService = MockGlideExecutor.newMainThreadExecutor();
-    GlideExecutor sourceService = MockGlideExecutor.newMainThreadExecutor();
-    GlideExecutor sourceUnlimitedService = MockGlideExecutor.newMainThreadUnlimitedExecutor();
+    final EngineJob.EngineResourceFactory factory = mock(EngineJob.EngineResourceFactory.class);
+    final Key key = mock(Key.class);
+    final Handler mainHandler = new Handler();
+    final ResourceCallback cb = mock(ResourceCallback.class);
+    final Resource<Object> resource = mockResource();
+    final EngineResource<Object> engineResource = mock(EngineResource.class);
+    final EngineJobListener listener = mock(EngineJobListener.class);
+    final GlideExecutor diskCacheService = MockGlideExecutor.newMainThreadExecutor();
+    final GlideExecutor sourceService = MockGlideExecutor.newMainThreadExecutor();
+    final GlideExecutor sourceUnlimitedService = MockGlideExecutor.newMainThreadExecutor();
+    final GlideExecutor animationService = MockGlideExecutor.newMainThreadExecutor();
     boolean isCacheable = true;
     boolean useUnlimitedSourceGeneratorPool = false;
-    DecodeJob<Object> decodeJob = mock(DecodeJob.class);
-    Pools.Pool<EngineJob<?>> pool = new Pools.SimplePool<>(1);
-    DataSource dataSource = DataSource.DATA_DISK_CACHE;
+    final boolean useAnimationPool = false;
+    final boolean onlyRetrieveFromCache = false;
+    final DecodeJob<Object> decodeJob = mock(DecodeJob.class);
+    final Pools.Pool<EngineJob<?>> pool = new Pools.SimplePool<>(1);
+    final DataSource dataSource = DataSource.DATA_DISK_CACHE;
 
-    public EngineJob<Object> getJob() {
+    EngineJob<Object> getJob() {
       when(factory.build(eq(resource), eq(isCacheable))).thenReturn(engineResource);
-      EngineJob<Object> result = new EngineJob<>(
-          diskCacheService, sourceService, sourceUnlimitedService, listener, pool, factory)
-          .init(key, isCacheable, useUnlimitedSourceGeneratorPool);
+      EngineJob<Object> result =
+          new EngineJob<>(
+              diskCacheService,
+              sourceService,
+              sourceUnlimitedService,
+              animationService,
+              listener,
+              pool,
+              factory);
+      result.init(
+          key,
+          isCacheable,
+          useUnlimitedSourceGeneratorPool,
+          useAnimationPool,
+          onlyRetrieveFromCache);
       result.addCallback(cb);
       return result;
     }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java
new file mode 100644
index 000000000..b6a469d8b
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java
@@ -0,0 +1,185 @@
+package com.bumptech.glide.load.engine;
+
+import static org.junit.Assert.assertThrows;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Option.CacheKeyUpdater;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.signature.ObjectKey;
+import com.google.common.testing.EqualsTester;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.Collections;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.function.ThrowingRunnable;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class EngineKeyTest {
+  @Mock private Transformation<Object> transformation;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+  }
+
+  @Test
+  public void updateDiskCacheKey_throwsException() throws NoSuchAlgorithmException {
+    // If this test fails, update testEqualsAndHashcode to use KeyTester including regression tests.
+    final EngineKey key = new EngineKey(
+        "id",
+        new ObjectKey("signature"),
+        100,
+        100,
+        Collections.<Class<?>, Transformation<?>>emptyMap(),
+        Object.class,
+        Object.class,
+        new Options());
+    assertThrows(
+        UnsupportedOperationException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() throws NoSuchAlgorithmException {
+            key.updateDiskCacheKey(MessageDigest.getInstance("SHA-1"));
+          }
+        });
+  }
+
+  @Test
+  public void testEqualsAndHashCode() {
+    Options memoryOptions = new Options();
+    memoryOptions.set(Option.memory("key", new Object()), new Object());
+
+    Options diskOptions = new Options();
+    diskOptions.set(Option.disk("key", new CacheKeyUpdater<String>() {
+      @Override
+      public void update(@NonNull byte[] keyBytes, @NonNull String value,
+          @NonNull MessageDigest messageDigest) {
+        messageDigest.update(keyBytes);
+        messageDigest.update(value.getBytes(Key.CHARSET));
+
+      }
+    }), "value");
+
+    new EqualsTester()
+        .addEqualityGroup(
+            new EngineKey(
+                "id",
+                new ObjectKey("signature"),
+                100,
+                100,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Object.class,
+                Object.class,
+                new Options()),
+            new EngineKey(
+                "id",
+                new ObjectKey("signature"),
+                100,
+                100,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Object.class,
+                Object.class,
+                new Options()))
+        .addEqualityGroup(
+            new EngineKey(
+                "otherId",
+                new ObjectKey("signature"),
+                100,
+                100,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Object.class,
+                Object.class,
+                new Options()))
+        .addEqualityGroup(
+            new EngineKey(
+                "id",
+                new ObjectKey("otherSignature"),
+                100,
+                100,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Object.class,
+                Object.class,
+                new Options()))
+        .addEqualityGroup(
+            new EngineKey(
+                "id",
+                new ObjectKey("signature"),
+                200,
+                100,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Object.class,
+                Object.class,
+                new Options()))
+        .addEqualityGroup(
+            new EngineKey(
+                "id",
+                new ObjectKey("signature"),
+                100,
+                200,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Object.class,
+                Object.class,
+                new Options()))
+        .addEqualityGroup(
+            new EngineKey(
+                "id",
+                new ObjectKey("signature"),
+                100,
+                100,
+                Collections.<Class<?>, Transformation<?>>singletonMap(Object.class, transformation),
+                Object.class,
+                Object.class,
+                new Options()))
+        .addEqualityGroup(
+            new EngineKey(
+                "id",
+                new ObjectKey("signature"),
+                100,
+                100,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Integer.class,
+                Object.class,
+                new Options()))
+        .addEqualityGroup(
+            new EngineKey(
+                "id",
+                new ObjectKey("signature"),
+                100,
+                100,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Object.class,
+                Integer.class,
+                new Options()))
+        .addEqualityGroup(
+            new EngineKey(
+                "id",
+                new ObjectKey("signature"),
+                100,
+                100,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Object.class,
+                Object.class,
+                memoryOptions))
+        .addEqualityGroup(
+            new EngineKey(
+                "id",
+                new ObjectKey("signature"),
+                100,
+                100,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Object.class,
+                Object.class,
+                diskOptions))
+        .testEquals();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java
similarity index 77%
rename from library/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java
index c4a05be94..3468931eb 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java
@@ -5,8 +5,9 @@
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
@@ -14,6 +15,8 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
@@ -21,15 +24,15 @@
 @Config(manifest = Config.NONE, sdk = 18)
 public class EngineResourceTest {
   private EngineResource<Object> engineResource;
-  private EngineResource.ResourceListener listener;
-  private Key cacheKey = mock(Key.class);
-  private Resource<Object> resource;
+  @Mock private EngineResource.ResourceListener listener;
+  @Mock private Key cacheKey;
+  @Mock private Resource<Object> resource;
 
   @Before
   public void setUp() {
-    resource = mockResource();
-    engineResource = new EngineResource<>(resource, true /*isMemoryCacheable*/);
-    listener = mock(EngineResource.ResourceListener.class);
+    MockitoAnnotations.initMocks(this);
+    engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
     engineResource.setResourceListener(cacheKey, listener);
   }
 
@@ -140,14 +143,27 @@ public void testThrowsIfReleasedMoreThanAcquired() {
 
   @Test(expected = NullPointerException.class)
   public void testThrowsIfWrappedResourceIsNull() {
-    new EngineResource<>(null, false);
+    new EngineResource<>(/*toWrap=*/ null, /*isCacheable=*/ false, /*isRecyclable=*/ true);
   }
 
   @Test
   public void testCanSetAndGetIsCacheable() {
-    engineResource = new EngineResource<>(mockResource(), true);
+    engineResource =
+        new EngineResource<>(mockResource(), /*isCacheable=*/ true, /*isRecyclable=*/ true);
     assertTrue(engineResource.isCacheable());
-    engineResource = new EngineResource<>(mockResource(), false);
+    engineResource =
+        new EngineResource<>(mockResource(), /*isCacheable=*/ false, /*isRecyclable=*/ true);
     assertFalse(engineResource.isCacheable());
   }
+
+  @Test
+  public void release_whenNotRecycleable_doesNotRecycleResource() {
+    resource = mockResource();
+    engineResource = new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ false);
+    engineResource.setResourceListener(cacheKey, listener);
+    engineResource.recycle();
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+    verify(resource, never()).recycle();
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
similarity index 51%
rename from library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
index 6a5cb537c..4decb9a07 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
@@ -11,7 +11,6 @@
 import static org.mockito.Matchers.anyBoolean;
 import static org.mockito.Matchers.anyInt;
 import static org.mockito.Matchers.eq;
-import static org.mockito.Matchers.isNull;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
@@ -26,13 +25,13 @@
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.cache.DiskCache;
+import com.bumptech.glide.load.engine.cache.LruResourceCache;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
 import com.bumptech.glide.load.engine.executor.MockGlideExecutor;
 import com.bumptech.glide.request.ResourceCallback;
 import com.bumptech.glide.tests.BackgroundUtil;
 import com.bumptech.glide.tests.GlideShadowLooper;
-import java.lang.ref.WeakReference;
 import java.util.HashMap;
 import java.util.Map;
 import org.junit.Before;
@@ -58,7 +57,7 @@ public void setUp() {
   public void testNewRunnerIsCreatedAndPostedWithNoExistingLoad() {
     harness.doLoad();
 
-    verify(harness.job).start(any(DecodeJob.class));
+    verify(harness.job).start((DecodeJob) any());
   }
 
   @Test
@@ -85,7 +84,7 @@ public void testEngineJobReceivesRemoveCallbackFromLoadStatus() {
   public void testNewRunnerIsAddedToRunnersMap() {
     harness.doLoad();
 
-    assertThat(harness.jobs).containsKey(harness.cacheKey);
+    assertThat(harness.jobs.getAll()).containsKey(harness.cacheKey);
   }
 
   @Test
@@ -93,7 +92,7 @@ public void testNewRunnerIsNotCreatedAndPostedWithExistingLoad() {
     harness.doLoad();
     harness.doLoad();
 
-    verify(harness.job, times(1)).start(any(DecodeJob.class));
+    verify(harness.job, times(1)).start((DecodeJob) any());
   }
 
   @Test
@@ -117,36 +116,16 @@ public void testLoadStatusIsReturnedForExistingJob() {
 
   @Test
   public void testResourceIsReturnedFromActiveResourcesIfPresent() {
-    harness.activeResources
-        .put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
+    harness.activeResources.activate(harness.cacheKey, harness.resource);
 
     harness.doLoad();
 
     verify(harness.cb).onResourceReady(eq(harness.resource), eq(DataSource.MEMORY_CACHE));
   }
 
-  @Test
-  public void testResourceIsNotReturnedFromActiveResourcesIfRefIsCleared() {
-    harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(null));
-
-    harness.doLoad();
-
-    verify(harness.cb, never()).onResourceReady(isNull(Resource.class), isADataSource());
-  }
-
-  @Test
-  public void testKeyIsRemovedFromActiveResourcesIfRefIsCleared() {
-    harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(null));
-
-    harness.doLoad();
-
-    assertThat(harness.activeResources).doesNotContainKey(harness.cacheKey);
-  }
-
   @Test
   public void testResourceIsAcquiredIfReturnedFromActiveResources() {
-    harness.activeResources
-        .put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
+    harness.activeResources.activate(harness.cacheKey, harness.resource);
 
     harness.doLoad();
 
@@ -155,8 +134,7 @@ public void testResourceIsAcquiredIfReturnedFromActiveResources() {
 
   @Test
   public void testNewLoadIsNotStartedIfResourceIsActive() {
-    harness.activeResources
-        .put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
+    harness.activeResources.activate(harness.cacheKey, harness.resource);
 
     harness.doLoad();
 
@@ -165,34 +143,30 @@ public void testNewLoadIsNotStartedIfResourceIsActive() {
 
   @Test
   public void testNullLoadStatusIsReturnedIfResourceIsActive() {
-    harness.activeResources
-        .put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
+    harness.activeResources.activate(harness.cacheKey, harness.resource);
 
     assertNull(harness.doLoad());
   }
 
   @Test
-  public void testActiveResourcesIsNotCheckedIfReturnedFromCache() {
-    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
-    EngineResource<?> other = mock(EngineResource.class);
-    harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(other));
+  public void load_withResourceInActiveResources_doesNotCheckMemoryCache() {
+    harness.activeResources.activate(harness.cacheKey, harness.resource);
 
     harness.doLoad();
 
     verify(harness.cb).onResourceReady(eq(harness.resource), eq(DataSource.MEMORY_CACHE));
-    verify(harness.cb, never()).onResourceReady(eq(other), isADataSource());
+    verify(harness.cache, never()).remove(any(Key.class));
   }
 
   @Test
   public void testActiveResourcesIsNotCheckedIfNotMemoryCacheable() {
-    harness.activeResources
-        .put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
+    harness.activeResources.activate(harness.cacheKey, harness.resource);
 
     harness.isMemoryCacheable = false;
     harness.doLoad();
 
     verify(harness.resource, never()).acquire();
-    verify(harness.job).start(any(DecodeJob.class));
+    verify(harness.job).start((DecodeJob) any());
   }
 
   @Test
@@ -211,7 +185,7 @@ public void testCacheIsNotCheckedIfNotMemoryCacheable() {
     harness.isMemoryCacheable = false;
     harness.doLoad();
 
-    verify(harness.job).start(any(DecodeJob.class));
+    verify(harness.job).start((DecodeJob) any());
   }
 
   @Test
@@ -249,8 +223,8 @@ public void testResourceIsAddedToActiveResourceIfReturnedFromCache() {
     when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
 
     harness.doLoad();
-
-    assertEquals(harness.resource, harness.activeResources.get(harness.cacheKey).get());
+    EngineResource<?> activeResource = harness.activeResources.get(harness.cacheKey);
+    assertThat(activeResource).isEqualTo(harness.resource);
   }
 
   @Test
@@ -264,7 +238,7 @@ public void testResourceIsAcquiredIfReturnedFromCache() {
 
   @Test
   public void testNewLoadIsNotStartedIfResourceIsCached() {
-    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(mock(EngineResource.class));
+    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
 
     harness.doLoad();
 
@@ -273,7 +247,7 @@ public void testNewLoadIsNotStartedIfResourceIsCached() {
 
   @Test
   public void testNullLoadStatusIsReturnedForCachedResource() {
-    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(mock(EngineResource.class));
+    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
 
     Engine.LoadStatus loadStatus = harness.doLoad();
     assertNull(loadStatus);
@@ -283,65 +257,65 @@ public void testNullLoadStatusIsReturnedForCachedResource() {
   public void testRunnerIsRemovedFromRunnersOnEngineNotifiedJobComplete() {
     harness.doLoad();
 
-    harness.engine.onEngineJobComplete(harness.cacheKey, harness.resource);
+    harness.callOnEngineJobComplete();
 
-    assertThat(harness.jobs).doesNotContainKey(harness.cacheKey);
+    assertThat(harness.jobs.getAll()).doesNotContainKey(harness.cacheKey);
   }
 
   @Test
   public void testEngineIsSetAsResourceListenerOnJobComplete() {
     harness.doLoad();
 
-    harness.engine.onEngineJobComplete(harness.cacheKey, harness.resource);
+    harness.callOnEngineJobComplete();
 
-    verify(harness.resource).setResourceListener(eq(harness.cacheKey), eq(harness.engine));
+    verify(harness.resource).setResourceListener(eq(harness.cacheKey), eq(harness.getEngine()));
   }
 
   @Test
   public void testEngineIsNotSetAsResourceListenerIfResourceIsNullOnJobComplete() {
     harness.doLoad();
 
-    harness.engine.onEngineJobComplete(harness.cacheKey, null);
+    harness.getEngine().onEngineJobComplete(harness.job, harness.cacheKey, /*resource=*/ null);
   }
 
   @Test
   public void testResourceIsAddedToActiveResourcesOnEngineComplete() {
     when(harness.resource.isCacheable()).thenReturn(true);
-    harness.engine.onEngineJobComplete(harness.cacheKey, harness.resource);
+    harness.callOnEngineJobComplete();
 
-    WeakReference<EngineResource<?>> resourceRef = harness.activeResources.get(harness.cacheKey);
-    assertThat(harness.resource).isEqualTo(resourceRef.get());
+    EngineResource<?> resource = harness.activeResources.get(harness.cacheKey);
+    assertThat(harness.resource).isEqualTo(resource);
   }
 
   @Test
   public void testDoesNotPutNullResourceInActiveResourcesOnEngineComplete() {
-    harness.engine.onEngineJobComplete(harness.cacheKey, null);
-    assertThat(harness.activeResources).doesNotContainKey(harness.cacheKey);
+    harness.getEngine().onEngineJobComplete(harness.job, harness.cacheKey, /*resource=*/ null);
+    assertThat(harness.activeResources.get(harness.cacheKey)).isNull();
   }
 
   @Test
   public void testDoesNotPutResourceThatIsNotCacheableInActiveResourcesOnEngineComplete() {
     when(harness.resource.isCacheable()).thenReturn(false);
-    harness.engine.onEngineJobComplete(harness.cacheKey, harness.resource);
-    assertThat(harness.activeResources).doesNotContainKey(harness.cacheKey);
+    harness.callOnEngineJobComplete();
+    assertThat(harness.activeResources.get(harness.cacheKey)).isNull();
   }
 
   @Test
   public void testRunnerIsRemovedFromRunnersOnEngineNotifiedJobCancel() {
     harness.doLoad();
 
-    harness.engine.onEngineJobCancelled(harness.job, harness.cacheKey);
+    harness.getEngine().onEngineJobCancelled(harness.job, harness.cacheKey);
 
-    assertThat(harness.jobs).doesNotContainKey(harness.cacheKey);
+    assertThat(harness.jobs.getAll()).doesNotContainKey(harness.cacheKey);
   }
 
   @Test
   public void testJobIsNotRemovedFromJobsIfOldJobIsCancelled() {
     harness.doLoad();
 
-    harness.engine.onEngineJobCancelled(mock(EngineJob.class), harness.cacheKey);
+    harness.getEngine().onEngineJobCancelled(mock(EngineJob.class), harness.cacheKey);
 
-    assertEquals(harness.job, harness.jobs.get(harness.cacheKey));
+    assertEquals(harness.job, harness.jobs.get(harness.cacheKey, harness.onlyRetrieveFromCache));
   }
 
   @Test
@@ -358,7 +332,7 @@ public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
       }
     }).when(harness.cache).put(eq(harness.cacheKey), anyResource());
 
-    harness.engine.onResourceReleased(harness.cacheKey, harness.resource);
+    harness.getEngine().onResourceReleased(harness.cacheKey, harness.resource);
 
     verify(harness.cache).put(eq(harness.cacheKey), anyResource());
   }
@@ -366,7 +340,7 @@ public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
   @Test
   public void testResourceIsNotAddedToCacheOnReleasedIfNotCacheable() {
     when(harness.resource.isCacheable()).thenReturn(false);
-    harness.engine.onResourceReleased(harness.cacheKey, harness.resource);
+    harness.getEngine().onResourceReleased(harness.cacheKey, harness.resource);
 
     verify(harness.cache, never()).put(eq(harness.cacheKey), eq(harness.resource));
   }
@@ -374,28 +348,28 @@ public void testResourceIsNotAddedToCacheOnReleasedIfNotCacheable() {
   @Test
   public void testResourceIsRecycledIfNotCacheableWhenReleased() {
     when(harness.resource.isCacheable()).thenReturn(false);
-    harness.engine.onResourceReleased(harness.cacheKey, harness.resource);
+    harness.getEngine().onResourceReleased(harness.cacheKey, harness.resource);
     verify(harness.resourceRecycler).recycle(eq(harness.resource));
   }
 
   @Test
   public void testResourceIsRemovedFromActiveResourcesWhenReleased() {
-    harness.activeResources
-        .put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
+    harness.activeResources.activate(harness.cacheKey, harness.resource);
 
-    harness.engine.onResourceReleased(harness.cacheKey, harness.resource);
+    harness.getEngine().onResourceReleased(harness.cacheKey, harness.resource);
 
-    assertThat(harness.activeResources).doesNotContainKey(harness.cacheKey);
+    assertThat(harness.activeResources.get(harness.cacheKey)).isNull();
   }
 
   @Test
   public void testEngineAddedAsListenerToMemoryCache() {
-    verify(harness.cache).setResourceRemovedListener(eq(harness.engine));
+    harness.getEngine();
+    verify(harness.cache).setResourceRemovedListener(eq(harness.getEngine()));
   }
 
   @Test
   public void testResourceIsRecycledWhenRemovedFromCache() {
-    harness.engine.onResourceRemoved(harness.resource);
+    harness.getEngine().onResourceRemoved(harness.resource);
     verify(harness.resourceRecycler).recycle(eq(harness.resource));
   }
 
@@ -403,7 +377,7 @@ public void testResourceIsRecycledWhenRemovedFromCache() {
   public void testJobIsPutInJobWithCacheKeyWithRelevantIds() {
     harness.doLoad();
 
-    assertThat(harness.jobs).containsEntry(harness.cacheKey, harness.job);
+    assertThat(harness.jobs.getAll()).containsEntry(harness.cacheKey, harness.job);
   }
 
   @Test
@@ -422,7 +396,9 @@ public void testFactoryIsGivenNecessaryArguments() {
     verify(harness.engineJobFactory).build(
         eq(harness.cacheKey),
         eq(true) /*isMemoryCacheable*/,
-        eq(false) /*useUnlimitedSourceGeneratorPool*/);
+        eq(false) /*useUnlimitedSourceGeneratorPool*/,
+        /*useAnimationPool=*/ eq(false),
+        /*onlyRetrieveFromCache=*/ eq(false));
   }
 
   @Test
@@ -433,76 +409,268 @@ public void testFactoryIsGivenNecessaryArgumentsWithUnlimitedPool() {
     verify(harness.engineJobFactory).build(
         eq(harness.cacheKey),
         eq(true) /*isMemoryCacheable*/,
-        eq(true) /*useUnlimitedSourceGeneratorPool*/);
+        eq(true) /*useUnlimitedSourceGeneratorPool*/,
+        /*useAnimationPool=*/ eq(false),
+        /*onlyRetrieveFromCache=*/ eq(false));
   }
 
   @Test
   public void testReleaseReleasesEngineResource() {
     EngineResource<Object> engineResource = mock(EngineResource.class);
-    harness.engine.release(engineResource);
+    harness.getEngine().release(engineResource);
     verify(engineResource).release();
   }
 
   @Test(expected = IllegalArgumentException.class)
   public void testThrowsIfAskedToReleaseNonEngineResource() {
-    harness.engine.release(mockResource());
+    harness.getEngine().release(mockResource());
   }
 
   @Test(expected = RuntimeException.class)
   public void testThrowsIfLoadCalledOnBackgroundThread() throws InterruptedException {
     BackgroundUtil.testInBackground(new BackgroundUtil.BackgroundTester() {
       @Override
-      public void runTest() throws Exception {
+      public void runTest() {
         harness.doLoad();
       }
     });
   }
 
+  @Test
+  public void load_afterResourceIsLoadedInActiveResources_returnsFromMemoryCache() {
+    when(harness.resource.isCacheable()).thenReturn(true);
+    doAnswer(new Answer<Object>() {
+      @Override
+      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+        harness.callOnEngineJobComplete();
+        return null;
+      }
+    }).when(harness.job).start(any(DecodeJob.class));
+    harness.doLoad();
+    harness.doLoad();
+    verify(harness.cb).onResourceReady(any(Resource.class), eq(DataSource.MEMORY_CACHE));
+  }
+
+  @Test
+  public void load_afterResourceIsLoadedAndReleased_returnsFromMemoryCache() {
+    harness.cache = new LruResourceCache(100);
+    when(harness.resource.isCacheable()).thenReturn(true);
+    doAnswer(new Answer<Object>() {
+      @Override
+      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+        harness.callOnEngineJobComplete();
+        return null;
+      }
+    }).when(harness.job).start(any(DecodeJob.class));
+    harness.doLoad();
+    harness.getEngine().onResourceReleased(harness.cacheKey, harness.resource);
+    harness.doLoad();
+    verify(harness.cb).onResourceReady(any(Resource.class), eq(DataSource.MEMORY_CACHE));
+  }
+
+  @Test
+  public void load_withOnlyRetrieveFromCache_andPreviousNormalLoad_startsNewLoad() {
+    EngineJob<?> first = harness.job;
+    harness.doLoad();
+    EngineJob<?> second = mock(EngineJob.class);
+    harness.job = second;
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+
+    verify(first).start(any(DecodeJob.class));
+    verify(second).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void load_withNormalLoad_afterPreviousRetrieveFromCache_startsNewLoad() {
+    EngineJob<?> first = harness.job;
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+    EngineJob<?> second = mock(EngineJob.class);
+    harness.job = second;
+    harness.onlyRetrieveFromCache = false;
+    harness.doLoad();
+
+    verify(first).start(any(DecodeJob.class));
+    verify(second).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void load_afterFinishedOnlyRetrieveFromCache_withPendingNormal_doesNotStartNewLoad() {
+    EngineJob<?> firstNormal = harness.job;
+    harness.doLoad();
+
+    harness.job = mock(EngineJob.class);
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+    harness.callOnEngineJobComplete();
+
+    EngineJob<?> secondNormal = mock(EngineJob.class);
+    harness.job = secondNormal;
+    harness.onlyRetrieveFromCache = false;
+    harness.doLoad();
+
+    verify(firstNormal).start(any(DecodeJob.class));
+    verify(secondNormal, never()).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void load_afterCancelledOnlyRetrieveFromCache_withPendingNormal_doesNotStartNewLoad() {
+    EngineJob<?> firstNormal = harness.job;
+    harness.doLoad();
+
+    harness.job = mock(EngineJob.class);
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+    harness.getEngine().onEngineJobCancelled(harness.job, harness.cacheKey);
+
+    EngineJob<?> secondNormal = mock(EngineJob.class);
+    harness.job = secondNormal;
+    harness.onlyRetrieveFromCache = false;
+    harness.doLoad();
+
+    verify(firstNormal).start(any(DecodeJob.class));
+    verify(secondNormal, never()).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void load_withOnlyRetrieveFromCache_withOtherRetrieveFromCachePending_doesNotStartNew() {
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+
+    EngineJob<?> second = mock(EngineJob.class);
+    harness.job = second;
+    harness.doLoad();
+
+    verify(second, never()).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void load_withOnlyRetrieveFromCache_afterPreviousFinishedOnlyFromCacheLoad_startsNew() {
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+    harness.callOnEngineJobComplete();
+
+    EngineJob<?> second = mock(EngineJob.class);
+    harness.job = second;
+    harness.doLoad();
+
+    verify(second).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void load_withOnlyRetrieveFromCache_afterPreviousCancelledOnlyFromCacheLoad_startsNew() {
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+    harness.getEngine().onEngineJobCancelled(harness.job, harness.cacheKey);
+
+    EngineJob<?> second = mock(EngineJob.class);
+    harness.job = second;
+    harness.doLoad();
+
+    verify(second).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void onEngineJobComplete_withOldJobForKey_doesNotRemoveJob() {
+    harness.doLoad();
+    harness.getEngine()
+        .onEngineJobComplete(mock(EngineJob.class), harness.cacheKey, harness.resource);
+
+    harness.job = mock(EngineJob.class);
+    harness.doLoad();
+
+    verify(harness.job, never()).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void onEngineJobCancelled_withOldJobForKey_doesNotRemoveJob() {
+    harness.doLoad();
+    harness.getEngine()
+        .onEngineJobCancelled(mock(EngineJob.class), harness.cacheKey);
+
+    harness.job = mock(EngineJob.class);
+    harness.doLoad();
+
+    verify(harness.job, never()).start(any(DecodeJob.class));
+  }
+
+
+  @Test
+  public void onEngineJobComplete_withOnlyRetrieveFromCacheAndOldJobForKey_doesNotRemoveJob() {
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+    harness.getEngine()
+        .onEngineJobComplete(mock(EngineJob.class), harness.cacheKey, harness.resource);
+
+    harness.job = mock(EngineJob.class);
+    harness.doLoad();
+
+    verify(harness.job, never()).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void onEngineJobCancelled_withOnlyRetrieveFromCacheAndOldJobForKey_doesNotRemoveJob() {
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+    harness.getEngine()
+        .onEngineJobCancelled(mock(EngineJob.class), harness.cacheKey);
+
+    harness.job = mock(EngineJob.class);
+    harness.doLoad();
+
+    verify(harness.job, never()).start(any(DecodeJob.class));
+  }
+
   private static class EngineTestHarness {
-    EngineKey cacheKey = mock(EngineKey.class);
-    EngineKeyFactory keyFactory = mock(EngineKeyFactory.class);
+    final EngineKey cacheKey = mock(EngineKey.class);
+    final EngineKeyFactory keyFactory = mock(EngineKeyFactory.class);
     ResourceCallback cb = mock(ResourceCallback.class);
     @SuppressWarnings("rawtypes")
-    EngineResource resource = mock(EngineResource.class);
-    Map<Key, EngineJob<?>> jobs = new HashMap<>();
-    Map<Key, WeakReference<EngineResource<?>>> activeResources = new HashMap<>();
+    final EngineResource resource = mock(EngineResource.class);
+    final Jobs jobs = new Jobs();
+    final ActiveResources activeResources =
+        new ActiveResources(/*isActiveResourceRetentionAllowed=*/ true);
 
-    int width = 100;
-    int height = 100;
+    final int width = 100;
+    final int height = 100;
 
-    Object model = new Object();
+    final Object model = new Object();
     MemoryCache cache = mock(MemoryCache.class);
     EngineJob<?> job;
-    Engine engine;
-    Engine.EngineJobFactory engineJobFactory = mock(Engine.EngineJobFactory.class);
-    Engine.DecodeJobFactory decodeJobFactory = mock(Engine.DecodeJobFactory.class);
-    ResourceRecycler resourceRecycler = mock(ResourceRecycler.class);
-    Key signature = mock(Key.class);
-    Map<Class<?>, Transformation<?>> transformations = new HashMap<>();
-    Options options = new Options();
-    GlideContext glideContext = mock(GlideContext.class);
+    private Engine engine;
+    final Engine.EngineJobFactory engineJobFactory = mock(Engine.EngineJobFactory.class);
+    final Engine.DecodeJobFactory decodeJobFactory = mock(Engine.DecodeJobFactory.class);
+    final ResourceRecycler resourceRecycler = mock(ResourceRecycler.class);
+    final Key signature = mock(Key.class);
+    final Map<Class<?>, Transformation<?>> transformations = new HashMap<>();
+    final Options options = new Options();
+    final GlideContext glideContext = mock(GlideContext.class);
     boolean isMemoryCacheable = true;
     boolean useUnlimitedSourceGeneratorPool = false;
     boolean onlyRetrieveFromCache = false;
+    final boolean isScaleOnlyOrNoTransform = true;
 
-    public EngineTestHarness() {
+    EngineTestHarness() {
       when(keyFactory.buildKey(eq(model), eq(signature), anyInt(), anyInt(), eq(transformations),
           eq(Object.class), eq(Object.class), eq(options))).thenReturn(cacheKey);
+      when(resource.getResource()).thenReturn(mock(Resource.class));
 
       job = mock(EngineJob.class);
+    }
 
-      engine = new Engine(cache, mock(DiskCache.Factory.class),
-          GlideExecutor.newDiskCacheExecutor(),
-          MockGlideExecutor.newMainThreadExecutor(),
-          MockGlideExecutor.newMainThreadUnlimitedExecutor(),
-          jobs, keyFactory, activeResources,
-          engineJobFactory, decodeJobFactory, resourceRecycler);
+    void callOnEngineJobComplete() {
+      getEngine().onEngineJobComplete(job, cacheKey, resource);
     }
 
-    public Engine.LoadStatus doLoad() {
-      when(engineJobFactory.build(eq(cacheKey), anyBoolean(), anyBoolean()))
+
+    Engine.LoadStatus doLoad() {
+      when(
+          engineJobFactory.build(
+              eq(cacheKey), anyBoolean(), anyBoolean(), anyBoolean(), anyBoolean()))
           .thenReturn((EngineJob<Object>) job);
-      return engine.load(glideContext,
+      when(job.onlyRetrieveFromCache()).thenReturn(onlyRetrieveFromCache);
+      return getEngine().load(glideContext,
           model,
           signature,
           width,
@@ -513,11 +681,35 @@ public EngineTestHarness() {
           DiskCacheStrategy.ALL,
           transformations,
           false /*isTransformationRequired*/,
+          isScaleOnlyOrNoTransform,
           options,
           isMemoryCacheable,
           useUnlimitedSourceGeneratorPool,
+          /*useAnimationPool=*/ false,
           onlyRetrieveFromCache,
           cb);
     }
+
+    Engine getEngine() {
+      if (engine == null) {
+        engine =
+            new Engine(
+                cache,
+                mock(DiskCache.Factory.class),
+                GlideExecutor.newDiskCacheExecutor(),
+                MockGlideExecutor.newMainThreadExecutor(),
+                MockGlideExecutor.newMainThreadExecutor(),
+                MockGlideExecutor.newMainThreadExecutor(),
+                jobs,
+                keyFactory,
+                activeResources,
+                engineJobFactory,
+                decodeJobFactory,
+                resourceRecycler,
+                /*isActiveResourceRetentionAllowed=*/ true);
+      }
+      return engine;
+    }
   }
+
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java
new file mode 100644
index 000000000..bcefcbb1a
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java
@@ -0,0 +1,193 @@
+package com.bumptech.glide.load.engine;
+
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doAnswer;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Option.CacheKeyUpdater;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
+import com.bumptech.glide.signature.ObjectKey;
+import com.bumptech.glide.tests.KeyTester;
+import com.bumptech.glide.tests.Util;
+import java.security.MessageDigest;
+import java.util.Arrays;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class ResourceCacheKeyTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
+
+  @Mock private Transformation<Object> transformation1;
+  @Mock private Transformation<Object> transformation2;
+  private LruArrayPool arrayPool;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
+    arrayPool = new LruArrayPool();
+    doAnswer(new Util.WriteDigest("transformation1")).when(transformation1)
+        .updateDiskCacheKey(any(MessageDigest.class));
+    doAnswer(new Util.WriteDigest("transformation1")).when(transformation2)
+        .updateDiskCacheKey(any(MessageDigest.class));
+  }
+
+  @Test
+  public void testEqualsAndHashCode() {
+    Options memoryOptions = new Options();
+    memoryOptions.set(Option.memory("key", new Object()), new Object());
+
+    Options diskOptions = new Options();
+    diskOptions.set(Option.disk("key", new CacheKeyUpdater<String>() {
+      @Override
+      public void update(@NonNull byte[] keyBytes, @NonNull String value,
+          @NonNull MessageDigest messageDigest) {
+        messageDigest.update(keyBytes);
+        messageDigest.update(value.getBytes(Key.CHARSET));
+
+      }
+    }), "value");
+
+    for (int i = 0; i < 20; i++) {
+      byte[] array = new byte[9];
+      Arrays.fill(array, (byte) 2);
+      arrayPool.put(array);
+    }
+
+    keyTester
+        .addEquivalenceGroup(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                100,
+                100,
+                transformation1,
+                Object.class,
+                new Options()),
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                100,
+                100,
+                transformation1,
+                Object.class,
+                new Options()))
+        .addEquivalenceGroup(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("otherSource"),
+                new ObjectKey("signature"),
+                100,
+                100,
+                transformation1,
+                Object.class,
+                new Options()))
+        .addEquivalenceGroup(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("otherSignature"),
+                100,
+                100,
+                transformation1,
+                Object.class,
+                new Options()))
+        .addEquivalenceGroup(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                200,
+                100,
+                transformation1,
+                Object.class,
+                new Options()))
+        .addEquivalenceGroup(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                100,
+                200,
+                transformation1,
+                Object.class,
+                new Options()))
+        .addEquivalenceGroup(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                100,
+                100,
+                transformation2,
+                Object.class,
+                new Options()))
+        .addEquivalenceGroup(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                100,
+                100,
+                transformation1,
+                Integer.class,
+                new Options()))
+        .addEquivalenceGroup(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                100,
+                100,
+                transformation1,
+                Object.class,
+                memoryOptions))
+        .addEquivalenceGroup(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                100,
+                100,
+                transformation1,
+                Object.class,
+                diskOptions))
+        .addRegressionTest(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                100,
+                100,
+                transformation1,
+                Object.class,
+                new Options()),
+            "04d632bfe8e588544909fc44edb7328fa28bea6831b96927ade22b44818654e2")
+        .addRegressionTest(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                100,
+                100,
+                transformation1,
+                Object.class,
+                diskOptions),
+            "781ff8cd30aaaf248134580004ea6d63a1b87ae20ea0f769caf379d7d84986d0")
+        .test();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java
similarity index 72%
rename from library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java
index 234b0f0e3..fe3f959f1 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java
@@ -9,7 +9,6 @@
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
-import org.robolectric.shadows.ShadowBitmap;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
@@ -29,7 +28,7 @@ public void testIGetNullIfNoMatchingBitmapExists() {
 
   @Test
   public void testICanAddAndGetABitmapOfTheSameSizeAndDimensions() {
-    Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
     strategy.put(bitmap);
     assertEquals(bitmap,
         strategy.get(bitmap.getWidth(), bitmap.getHeight(), Bitmap.Config.ARGB_8888));
@@ -37,44 +36,44 @@ public void testICanAddAndGetABitmapOfTheSameSizeAndDimensions() {
 
   @Test
   public void testICantGetABitmapOfTheSameDimensionsButDifferentConfigs() {
-    Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
     strategy.put(bitmap);
     assertNull(strategy.get(100, 100, Bitmap.Config.RGB_565));
   }
 
   @Test
   public void testICantGetABitmapOfTheSameDimensionsAndSizeButDifferentConfigs() {
-    Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
     strategy.put(bitmap);
     assertNull(strategy.get(100, 100, Bitmap.Config.RGB_565));
   }
 
   @Test
   public void testICantGetABitmapOfDifferentWidths() {
-    Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
     strategy.put(bitmap);
     assertNull(strategy.get(99, 100, Bitmap.Config.ARGB_8888));
   }
 
   @Test
   public void testICantGetABitmapOfDifferentHeights() {
-    Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
     strategy.put(bitmap);
     assertNull(strategy.get(100, 99, Bitmap.Config.ARGB_8888));
   }
 
   @Test
   public void testICantGetABitmapOfDifferentDimensionsButTheSameSize() {
-    Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
     strategy.put(bitmap);
     assertNull(strategy.get(50, 200, Bitmap.Config.ARGB_8888));
   }
 
   @Test
   public void testMultipleBitmapsOfDifferentAttributesCanBeAddedAtOnce() {
-    Bitmap first = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
-    Bitmap second = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    Bitmap third = ShadowBitmap.createBitmap(120, 120, Bitmap.Config.RGB_565);
+    Bitmap first = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
+    Bitmap second = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    Bitmap third = Bitmap.createBitmap(120, 120, Bitmap.Config.RGB_565);
 
     strategy.put(first);
     strategy.put(second);
@@ -87,9 +86,9 @@ public void testMultipleBitmapsOfDifferentAttributesCanBeAddedAtOnce() {
 
   @Test
   public void testLeastRecentlyUsedAttributeSetIsRemovedFirst() {
-    final Bitmap leastRecentlyUsed = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ALPHA_8);
-    final Bitmap other = ShadowBitmap.createBitmap(1000, 1000, Bitmap.Config.RGB_565);
-    final Bitmap mostRecentlyUsed = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    final Bitmap leastRecentlyUsed = Bitmap.createBitmap(100, 100, Bitmap.Config.ALPHA_8);
+    final Bitmap other = Bitmap.createBitmap(1000, 1000, Bitmap.Config.RGB_565);
+    final Bitmap mostRecentlyUsed = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
 
     strategy.get(100, 100, Bitmap.Config.ALPHA_8);
     strategy.get(1000, 1000, Bitmap.Config.RGB_565);
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMapTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMapTest.java
new file mode 100644
index 000000000..3139df1a8
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMapTest.java
@@ -0,0 +1,121 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertNull;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class GroupedLinkedMapTest {
+
+  private GroupedLinkedMap<Key, Object> map;
+
+  @Before
+  public void setUp() {
+    map = new GroupedLinkedMap<>();
+  }
+
+  @Test
+  public void testReturnsNullForGetWithNoBitmap() {
+    Key key =  new Key("key", /*width=*/ 1, /*height=*/ 1);
+    assertNull(map.get(key));
+  }
+
+  @Test
+  public void testCanAddAndRemoveABitmap() {
+    Key key = new Key("key", 1, 1);
+    Object expected = new Object();
+
+    map.put(key, expected);
+
+    assertThat(map.get(key)).isEqualTo(expected);
+  }
+
+  @Test
+  public void testCanAddAndRemoveMoreThanOneBitmapForAGivenKey() {
+    Key key = new Key("key", 1, 1);
+    Integer value = 20;
+
+    int numToAdd = 10;
+
+    for (int i = 0; i < numToAdd; i++) {
+      map.put(key, value);
+    }
+
+    for (int i = 0; i < numToAdd; i++) {
+      assertThat(map.get(key)).isEqualTo(value);
+    }
+  }
+
+  @Test
+  public void testLeastRecentlyRetrievedKeyIsLeastRecentlyUsed() {
+    Key firstKey = new Key("key", 1, 1);
+    Integer firstValue = 10;
+    map.put(firstKey, firstValue);
+    map.put(firstKey, firstValue);
+
+    Key secondKey = new Key("key", 2, 2);
+    Integer secondValue = 20;
+    map.put(secondKey, secondValue);
+
+    map.get(firstKey);
+
+    assertThat(map.removeLast()).isEqualTo(secondValue);
+  }
+
+  @Test
+  public void testAddingAnEntryDoesNotMakeItMostRecentlyUsed() {
+    Key firstKey = new Key("key", 1, 1);
+    Integer firstValue = 10;
+
+    map.put(firstKey, firstValue);
+    map.put(firstKey, firstValue);
+
+    map.get(firstKey);
+
+    Integer secondValue = 20;
+    map.put(new Key("key", 2, 2), secondValue);
+
+    assertThat(map.removeLast()).isEqualTo(secondValue);
+  }
+
+  private static final class Key implements Poolable {
+
+    private final String key;
+    private final int width;
+    private final int height;
+
+    Key(String key, int width, int height) {
+      this.key = key;
+      this.width = width;
+      this.height = height;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (o instanceof Key) {
+        Key other = (Key) o;
+        return key.equals(other.key) && width == other.width && height == other.height;
+      }
+      return false;
+    }
+
+    @Override
+    public int hashCode() {
+      int result = key != null ? key.hashCode() : 0;
+      result = 31 * result + width;
+      result = 31 * result + height;
+      return result;
+    }
+
+    @Override
+    public void offer() {
+      // Do nothing.
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java
similarity index 50%
rename from library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java
index 4f6016cf3..6b7be90f6 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java
@@ -2,14 +2,16 @@
 
 import static android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
 import static android.content.ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;
 import static android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
-import android.annotation.TargetApi;
-import android.os.Build;
 import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Set;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -18,15 +20,15 @@
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
-@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
 public class LruArrayPoolTest {
   private static final int MAX_SIZE = 10;
+  private static final int MAX_PUT_SIZE = MAX_SIZE / 2;
   private static final Class<byte[]> ARRAY_CLASS = byte[].class;
   private static final ArrayAdapterInterface<byte[]> ADAPTER = new ByteArrayAdapter();
   private LruArrayPool pool;
 
   @Before
-  public void setUp() throws Exception {
+  public void setUp() {
     pool = new LruArrayPool(MAX_SIZE);
   }
 
@@ -40,7 +42,7 @@ public void testICanAddAndGetValidArray() {
     int size = 758;
     int value = 564;
     fillPool(pool, size - 1, value);
-    pool.put(createArray(ARRAY_CLASS, size, value), ARRAY_CLASS);
+    pool.put(createArray(ARRAY_CLASS, size, value));
     Object array = pool.get(size, ARRAY_CLASS);
     assertNotNull(array);
     assertTrue(array.getClass() == ARRAY_CLASS);
@@ -57,8 +59,7 @@ public void testItIsSizeLimited() {
   @Test
   public void testArrayLargerThanPoolIsNotAdded() {
     pool = new LruArrayPool(MAX_SIZE);
-    pool.put(createArray(ARRAY_CLASS, MAX_SIZE / ADAPTER.getElementSizeInBytes() + 1, 0),
-        ARRAY_CLASS);
+    pool.put(createArray(ARRAY_CLASS, MAX_SIZE / ADAPTER.getElementSizeInBytes() + 1, 0));
     assertEquals(0, pool.getCurrentSize());
   }
 
@@ -74,6 +75,11 @@ public void testTrimMemoryUiHiddenOrLessRemovesHalfOfArrays() {
     testTrimMemory(MAX_SIZE, TRIM_MEMORY_UI_HIDDEN, MAX_SIZE / 2);
   }
 
+  @Test
+  public void testTrimMemoryRunningCriticalRemovesHalfOfBitmaps() {
+    testTrimMemory(MAX_SIZE, TRIM_MEMORY_RUNNING_CRITICAL, MAX_SIZE / 2);
+  }
+
   @Test
   public void testTrimMemoryUiHiddenOrLessRemovesNoArraysIfPoolLessThanHalfFull() {
     testTrimMemory(MAX_SIZE / 2, TRIM_MEMORY_UI_HIDDEN, MAX_SIZE / 2);
@@ -86,6 +92,91 @@ public void testTrimMemoryBackgroundOrGreaterRemovesAllArrays() {
     }
   }
 
+  @Test
+  public void get_withEmptyPool_returnsExactArray() {
+    assertThat(pool.get(MAX_PUT_SIZE, byte[].class)).hasLength(MAX_PUT_SIZE);
+  }
+
+  @Test
+  public void get_withPoolContainingLargerArray_returnsLargerArray() {
+    byte[] expected = new byte[MAX_PUT_SIZE];
+    pool.put(expected);
+    assertThat(pool.get(MAX_PUT_SIZE - 1, byte[].class)).isSameAs(expected);
+  }
+
+  @Test
+  public void get_withPoolContainingSmallerArray_returnsExactArray() {
+    pool.put(new byte[MAX_PUT_SIZE - 1]);
+    assertThat(pool.get(MAX_PUT_SIZE, byte[].class)).hasLength(MAX_PUT_SIZE);
+  }
+
+  @Test
+  public void get_withPoolLessThanHalfFull_returnsFromPools() {
+    int size = MAX_SIZE / 2;
+    byte[] expected = new byte[size];
+    pool.put(expected);
+    assertThat(pool.get(1, byte[].class)).isSameAs(expected);
+  }
+
+  @Test
+  public void get_withPoolMoreThanHalfFull_sizeMoreThanHalfArrayInPool_returnsArray() {
+    Set<byte[]> expected = new HashSet<>();
+    for (int i = 0; i < 3; i++) {
+      byte[] toPut = new byte[MAX_SIZE / 3];
+      expected.add(toPut);
+      pool.put(toPut);
+    }
+    byte[] received = pool.get(2, byte[].class);
+    assertThat(expected).contains(received);
+  }
+
+  @Test
+  public void get_withPoolMoreThanHalfFull_sizeLessThanHalfArrayInPool_returnsNewArray() {
+    pool = new LruArrayPool(100);
+    for (int i = 0; i < 3; i++) {
+      byte[] toPut = new byte[100 / 3];
+      pool.put(toPut);
+    }
+    int requestedSize = 100 / 3 / LruArrayPool.MAX_OVER_SIZE_MULTIPLE;
+    byte[] received = pool.get(requestedSize, byte[].class);
+    assertThat(received).hasLength(requestedSize);
+  }
+
+  @Test
+  public void getExact_withEmptyPool_returnsExactArray() {
+    byte[] result = pool.getExact(MAX_PUT_SIZE, byte[].class);
+    assertThat(result).hasLength(MAX_PUT_SIZE);
+  }
+
+  @Test
+  public void getExact_withPoolContainingLargerArray_returnsExactArray() {
+    pool.put(new byte[MAX_PUT_SIZE]);
+    int expectedSize = MAX_PUT_SIZE - 1;
+    assertThat(pool.getExact(expectedSize, byte[].class)).hasLength(expectedSize);
+  }
+
+  @Test
+  public void getExact_withPoolContainingSmallerArray_returnsExactArray() {
+    pool.put(new byte[MAX_PUT_SIZE - 1]);
+    assertThat(pool.getExact(MAX_PUT_SIZE, byte[].class)).hasLength(MAX_PUT_SIZE);
+  }
+
+  @Test
+  public void getExact_withPoolContainingExactArray_returnsArray() {
+    byte[] expected = new byte[MAX_PUT_SIZE];
+    pool.put(expected);
+    assertThat(pool.getExact(MAX_PUT_SIZE, byte[].class)).isSameAs(expected);
+  }
+
+  @Test
+  public void put_withArrayMoreThanHalfPoolSize_doesNotRetainArray() {
+    int targetSize = (MAX_SIZE / 2) + 1;
+    byte[] toPut = new byte[targetSize];
+    pool.put(toPut);
+    assertThat(pool.getCurrentSize()).isEqualTo(0);
+    assertThat(pool.get(targetSize, byte[].class)).isNotSameAs(toPut);
+  }
+
   private void testTrimMemory(int fillSize, int trimLevel, int expectedSize) {
     pool = new LruArrayPool(MAX_SIZE);
     fillPool(pool, fillSize / ADAPTER.getElementSizeInBytes(), 1);
@@ -95,7 +186,7 @@ private void testTrimMemory(int fillSize, int trimLevel, int expectedSize) {
 
   private void fillPool(LruArrayPool pool, int arrayCount, int arrayLength) {
     for (int i = 0; i < arrayCount; i++) {
-      pool.put(createArray(ARRAY_CLASS, arrayLength, 10), ARRAY_CLASS);
+      pool.put(createArray(ARRAY_CLASS, arrayLength, 10));
     }
   }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
similarity index 87%
rename from library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
index 2b515c771..ab73d11e3 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
@@ -2,6 +2,7 @@
 
 import static android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
 import static android.content.ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;
 import static android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
@@ -13,9 +14,9 @@
 import static org.mockito.Mockito.when;
 
 import android.graphics.Bitmap;
+import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.LinkedList;
 import java.util.List;
 import java.util.Set;
 import org.junit.Before;
@@ -24,7 +25,6 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
-import org.robolectric.shadows.ShadowBitmap;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
@@ -88,9 +88,7 @@ public void testClearMemoryRemovesAllBitmaps() {
   public void testEvictedBitmapsAreRecycled() {
     fillPool(pool, MAX_SIZE);
     List<Bitmap> bitmaps = new ArrayList<>(MAX_SIZE);
-    for (Bitmap b : strategy.bitmaps) {
-      bitmaps.add(b);
-    }
+    bitmaps.addAll(strategy.bitmaps);
 
     pool.clearMemory();
 
@@ -104,6 +102,11 @@ public void testTrimMemoryUiHiddenOrLessRemovesHalfOfBitmaps() {
     testTrimMemory(MAX_SIZE, TRIM_MEMORY_UI_HIDDEN, MAX_SIZE / 2);
   }
 
+  @Test
+  public void testTrimMemoryRunningCriticalRemovesHalfOfBitmaps() {
+    testTrimMemory(MAX_SIZE, TRIM_MEMORY_RUNNING_CRITICAL, MAX_SIZE / 2);
+  }
+
   @Test
   public void testTrimMemoryUiHiddenOrLessRemovesNoBitmapsIfPoolLessThanHalfFull() {
     testTrimMemory(MAX_SIZE / 2, TRIM_MEMORY_UI_HIDDEN, 0);
@@ -140,6 +143,18 @@ public void testPassesArgb8888ToStrategyAsConfigForRequestsWithNullConfigsOnGetD
     assertEquals(expected, result);
   }
 
+  @Test
+  public void get_withNullConfig_andEmptyPool_returnsNewArgb8888Bitmap() {
+    Bitmap result = pool.get(100, 100, /*config=*/ null);
+    assertThat(result.getConfig()).isEqualTo(Bitmap.Config.ARGB_8888);
+  }
+
+  @Test
+  public void getDirty_withNullConfig_andEmptyPool_returnsNewArgb8888Bitmap() {
+    Bitmap result = pool.getDirty(100, 100, /*config=*/ null);
+    assertThat(result.getConfig()).isEqualTo(Bitmap.Config.ARGB_8888);
+  }
+
   private void testTrimMemory(int fillSize, int trimLevel, int expectedSize) {
     MockStrategy strategy = new MockStrategy();
     LruBitmapPool pool = new LruBitmapPool(MAX_SIZE, strategy, ALLOWED_CONFIGS);
@@ -176,7 +191,7 @@ public void testCanResetSizeDynamically() {
 
     pool.setSizeMultiplier(1);
 
-    assertEquals(Math.round(MAX_SIZE * sizeMultiplier) - MAX_SIZE, strategy.numRemoves);
+    assertEquals(MAX_SIZE * sizeMultiplier - MAX_SIZE, strategy.numRemoves);
   }
 
   @Test
@@ -223,14 +238,14 @@ private Bitmap createMutableBitmap() {
   }
 
   private Bitmap createMutableBitmap(Bitmap.Config config) {
-    Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, config);
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, config);
     Shadows.shadowOf(bitmap).setMutable(true);
     return bitmap;
 
   }
 
   private static class MockStrategy implements LruPoolStrategy {
-    private LinkedList<Bitmap> bitmaps = new LinkedList<>();
+    private final ArrayDeque<Bitmap> bitmaps = new ArrayDeque<>();
     private int numRemoves;
     private int numPuts;
 
@@ -242,7 +257,7 @@ public void put(Bitmap bitmap) {
 
     @Override
     public Bitmap get(int width, int height, Bitmap.Config config) {
-      return bitmaps.removeLast();
+      return bitmaps.isEmpty() ? null : bitmaps.removeLast();
     }
 
     @Override
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java
new file mode 100644
index 000000000..c37b5946a
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java
@@ -0,0 +1,35 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import android.graphics.Bitmap;
+import com.google.common.testing.EqualsTester;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(JUnit4.class)
+public class SizeConfigStrategyTest {
+
+  @Mock
+  private SizeConfigStrategy.KeyPool pool;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+  }
+
+  @Test
+  public void testKeyEquals() {
+    new EqualsTester()
+        .addEqualityGroup(
+            new SizeConfigStrategy.Key(pool, 100, Bitmap.Config.ARGB_8888),
+            new SizeConfigStrategy.Key(pool, 100, Bitmap.Config.ARGB_8888)
+        )
+        .addEqualityGroup(new SizeConfigStrategy.Key(pool, 101, Bitmap.Config.ARGB_8888))
+        .addEqualityGroup(new SizeConfigStrategy.Key(pool, 100, Bitmap.Config.RGB_565))
+        .addEqualityGroup(new SizeConfigStrategy.Key(pool, 100, null /*config*/))
+        .testEquals();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategyKeyTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategyKeyTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategyKeyTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategyKeyTest.java
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
similarity index 53%
rename from library/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
index 29b03a1ec..24a1098e7 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
@@ -3,12 +3,16 @@
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeTrue;
+import static org.mockito.Mockito.mock;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Key;
+import com.bumptech.glide.signature.ObjectKey;
 import com.bumptech.glide.tests.Util;
 import java.io.File;
 import java.io.IOException;
-import java.security.MessageDigest;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -19,23 +23,49 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class DiskLruCacheWrapperTest {
-  private DiskLruCacheWrapper cache;
+  private DiskCache cache;
   private byte[] data;
-  private StringKey key;
+  private ObjectKey key;
+  private File dir;
 
   @Before
   public void setUp() {
-    File dir = RuntimeEnvironment.application.getCacheDir();
-    cache = new DiskLruCacheWrapper(dir, 10 * 1024 * 1024);
-    key = new StringKey("test" + Math.random());
+    dir = RuntimeEnvironment.application.getCacheDir();
+    cache = DiskLruCacheWrapper.create(dir, 10 * 1024 * 1024);
+    key = new ObjectKey("test" + Math.random());
     data = new byte[] { 1, 2, 3, 4, 5, 6 };
   }
 
+  @After
+  public void tearDown() {
+    try {
+      cache.clear();
+    } finally {
+      deleteRecursive(dir);
+    }
+  }
+
+  private static void deleteRecursive(File file) {
+    if (file.isDirectory()) {
+      File[] files = file.listFiles();
+      if (files != null) {
+        for (File f : files) {
+          deleteRecursive(f);
+        }
+      }
+    }
+    // GC before delete() to release files on Windows (https://stackoverflow.com/a/4213208/253468)
+    System.gc();
+    if (!file.delete() && file.exists()) {
+      throw new RuntimeException("Failed to delete: " + file);
+    }
+  }
+
   @Test
   public void testCanInsertAndGet() throws IOException {
     cache.put(key, new DiskCache.Writer() {
       @Override
-      public boolean write(File file) {
+      public boolean write(@NonNull File file) {
         try {
           Util.writeFile(file, data);
         } catch (IOException e) {
@@ -54,7 +84,7 @@ public boolean write(File file) {
   public void testDoesNotCommitIfWriterReturnsFalse() {
     cache.put(key, new DiskCache.Writer() {
       @Override
-      public boolean write(File file) {
+      public boolean write(@NonNull File file) {
         return false;
       }
     });
@@ -66,7 +96,7 @@ public boolean write(File file) {
   public void testDoesNotCommitIfWriterWritesButReturnsFalse() {
     cache.put(key, new DiskCache.Writer() {
       @Override
-      public boolean write(File file) {
+      public boolean write(@NonNull File file) {
         try {
           Util.writeFile(file, data);
         } catch (IOException e) {
@@ -84,7 +114,7 @@ public void testEditIsAbortedIfWriterThrows() throws IOException {
     try {
       cache.put(key, new DiskCache.Writer() {
         @Override
-        public boolean write(File file) {
+        public boolean write(@NonNull File file) {
           throw new RuntimeException("test");
         }
       });
@@ -94,7 +124,7 @@ public boolean write(File file) {
 
     cache.put(key, new DiskCache.Writer() {
       @Override
-      public boolean write(File file) {
+      public boolean write(@NonNull File file) {
         try {
           Util.writeFile(file, data);
         } catch (IOException e) {
@@ -109,16 +139,25 @@ public boolean write(File file) {
     assertArrayEquals(data, received);
   }
 
-  private static class StringKey implements Key {
-    private final String key;
-
-    public StringKey(String key) {
-      this.key = key;
-    }
+  // Tests #2465.
+  @Test
+  public void clearDiskCache_afterOpeningDiskCache_andDeleteDirectoryOutsideGlide_doesNotThrow() {
+    assumeTrue("A file handle is likely open, so cannot delete dir", !Util.isWindows());
+    DiskCache cache = DiskLruCacheWrapper.create(dir, 1024 * 1024);
+    cache.get(mock(Key.class));
+    deleteRecursive(dir);
+    cache.clear();
+  }
 
-    @Override
-    public void updateDiskCacheKey(MessageDigest messageDigest) {
-      messageDigest.update(key.getBytes());
-    }
+  // Tests #2465.
+  @Test
+  public void get_afterDeleteDirectoryOutsideGlideAndClose_doesNotThrow() {
+    assumeTrue("A file handle is likely open, so cannot delete dir", !Util.isWindows());
+    DiskCache cache = DiskLruCacheWrapper.create(dir, 1024 * 1024);
+    cache.get(mock(Key.class));
+    deleteRecursive(dir);
+    cache.clear();
+
+    cache.get(mock(Key.class));
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java
similarity index 86%
rename from library/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java
index 3e3451e81..a1c3f2d55 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java
@@ -4,6 +4,7 @@
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
+import static org.mockito.AdditionalMatchers.not;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyObject;
 import static org.mockito.Matchers.eq;
@@ -13,6 +14,8 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.util.LruCache;
 import org.junit.Before;
 import org.junit.Test;
@@ -28,7 +31,7 @@
   private String currentKey;
 
   @Before
-  public void setUp() throws Exception {
+  public void setUp() {
     currentKey = "";
     listener = mock(CacheListener.class);
     cache = new TestLruCache(SIZE, listener);
@@ -60,14 +63,15 @@ public void testCanPutNullItemWithoutChangingSize() {
   @Test
   public void testReplacingNonNullItemWithNullItemDecreasesSize() {
     String key = getKey();
-    cache.put(key, new Object());
+    Object initialValue = new Object();
+    cache.put(key, initialValue);
     cache.put(key, null);
 
     for (int i = 0; i < SIZE; i++) {
       cache.put(getKey(), new Object());
     }
 
-    verify(listener, never()).onItemRemoved(anyObject());
+    verify(listener).onItemRemoved(initialValue);
   }
 
   @Test
@@ -86,14 +90,16 @@ public void testReplacingNullItemWIthNullItemIncreasesSize() {
   @Test
   public void testReplacingNonNullItemWithNonNullItemUpdatesSize() {
     String key = getKey();
-    cache.put(key, new Object());
+    Object initialValue = new Object();
+    cache.put(key, initialValue);
     cache.put(key, new Object());
 
-    for (int i = 0; i < SIZE; i++) {
+    for (int i = 0; i < SIZE - 1; i++) {
       cache.put(getKey(), new Object());
     }
 
-    verify(listener).onItemRemoved(anyObject());
+    verify(listener).onItemRemoved(initialValue);
+    verify(listener, never()).onItemRemoved(not(eq(initialValue)));
   }
 
   @Test
@@ -191,6 +197,34 @@ public void testCanPutSameItemMultipleTimes() {
     verify(listener, never()).onItemRemoved(anyObject());
   }
 
+  @Test
+  public void put_withSameValueTwice_doesNotEvictItems() {
+    String key = getKey();
+    Object value = new Object();
+    cache.put(key, value);
+    cache.put(key, value);
+
+    verify(listener, never()).onItemRemoved(anyObject());
+  }
+
+  @Test
+  public void put_withExistingNullValue_doesNotNotifyListener() {
+    String key = getKey();
+    cache.put(key, /* item= */ null);
+    cache.put(key, new Object());
+
+    verify(listener, never()).onItemRemoved(anyObject());
+  }
+
+  @Test
+  public void put_withNullValue_withSizeGreaterThanMaximum_notifiesListener() {
+    String key = getKey();
+    when(listener.getSize(null)).thenReturn((int) (cache.getMaxSize() * 2));
+    cache.put(key, null);
+
+    verify(listener).onItemRemoved(anyObject());
+  }
+
   @Test
   public void testCanIncreaseSizeDynamically() {
     int sizeMultiplier = 2;
@@ -259,7 +293,7 @@ public void testDecreasesSizeWhenRemovesKey() {
     Object value = new Object();
     cache.put(key, value);
     for (int i = 0; i < SIZE - 1; i++) {
-      cache.put(key, value);
+      cache.put(getKey(), value);
     }
     cache.remove(key);
     cache.put(key, value);
@@ -326,26 +360,26 @@ private String getKey() {
   }
 
   private interface CacheListener {
-    public void onItemRemoved(Object item);
+    void onItemRemoved(Object item);
 
-    public int getSize(Object item);
+    int getSize(Object item);
   }
 
   private static class TestLruCache extends LruCache<String, Object> {
     private final CacheListener listener;
 
-    public TestLruCache(int size, CacheListener listener) {
+    TestLruCache(int size, CacheListener listener) {
       super(size);
       this.listener = listener;
     }
 
     @Override
-    protected void onItemEvicted(String key, Object item) {
+    protected void onItemEvicted(@NonNull String key, @Nullable Object item) {
       listener.onItemRemoved(item);
     }
 
     @Override
-    protected int getSize(Object item) {
+    protected int getSize(@Nullable Object item) {
       return listener.getSize(item);
     }
   }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
new file mode 100644
index 000000000..22b76cfc1
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
@@ -0,0 +1,227 @@
+package com.bumptech.glide.load.engine.cache;
+
+import static com.bumptech.glide.load.engine.cache.MemoryCache.ResourceRemovedListener;
+import static com.bumptech.glide.tests.Util.anyResource;
+import static com.bumptech.glide.tests.Util.mockResource;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.content.ComponentCallbacks2;
+import android.support.annotation.NonNull;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.util.LruCache;
+import java.security.MessageDigest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class LruResourceCacheTest {
+
+  @Test
+  public void put_withExistingItem_updatesSizeCorrectly() {
+    PutWithExistingEntryHarness harness = new PutWithExistingEntryHarness();
+    harness.cache.put(harness.key, harness.first);
+    harness.cache.put(harness.key, harness.second);
+
+    assertThat(harness.cache.getCurrentSize()).isEqualTo(harness.second.getSize());
+  }
+
+  @Test
+  public void put_withExistingItem_evictsExistingItem() {
+    PutWithExistingEntryHarness harness = new PutWithExistingEntryHarness();
+    harness.cache.put(harness.key, harness.first);
+    harness.cache.put(harness.key, harness.second);
+
+    verify(harness.listener).onResourceRemoved(harness.first);
+  }
+
+  @Test
+  public void get_afterPutWithExistingItem_returnsNewItem() {
+    PutWithExistingEntryHarness harness = new PutWithExistingEntryHarness();
+    harness.cache.put(harness.key, harness.first);
+    harness.cache.put(harness.key, harness.second);
+
+    assertThat(harness.cache.get(harness.key)).isEqualTo(harness.second);
+  }
+
+  @Test
+  public void onItemEvicted_withNullValue_doesNotNotifyListener() {
+    PutWithExistingEntryHarness harness = new PutWithExistingEntryHarness();
+    harness.cache.onItemEvicted(new MockKey(), null);
+    verify(harness.listener, never()).onResourceRemoved(anyResource());
+  }
+
+  @Test
+  public void clearMemory_afterPutWithExistingItem_evictsOnlyNewItem() {
+    PutWithExistingEntryHarness harness = new PutWithExistingEntryHarness();
+    harness.cache.put(harness.key, harness.first);
+    harness.cache.put(harness.key, harness.second);
+
+    verify(harness.listener).onResourceRemoved(harness.first);
+    verify(harness.listener, never()).onResourceRemoved(harness.second);
+
+    harness.cache.clearMemory();
+
+    verify(harness.listener, times(1)).onResourceRemoved(harness.first);
+    verify(harness.listener).onResourceRemoved(harness.second);
+  }
+
+  @Test
+  public void testTrimMemoryBackground() {
+    TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
+
+    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
+
+    verify(harness.listener).onResourceRemoved(eq(harness.first));
+    verify(harness.listener).onResourceRemoved(eq(harness.second));
+  }
+
+  @Test
+  public void testTrimMemoryModerate() {
+    TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
+
+    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_MODERATE);
+
+    verify(harness.listener).onResourceRemoved(harness.first);
+    verify(harness.listener).onResourceRemoved(harness.second);
+  }
+
+  @Test
+  public void testTrimMemoryUiHidden() {
+    TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
+
+    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
+
+    verify(harness.listener).onResourceRemoved(harness.first);
+    verify(harness.listener, never()).onResourceRemoved(harness.second);
+  }
+
+  @Test
+  public void testTrimMemoryRunningCritical() {
+    TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
+
+    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL);
+
+    verify(harness.listener).onResourceRemoved(harness.first);
+    verify(harness.listener, never()).onResourceRemoved(harness.second);
+  }
+
+  @Test
+  public void testResourceRemovedListenerIsNotifiedWhenResourceIsRemoved() {
+    LruResourceCache resourceCache = new LruResourceCache(100);
+    Resource<?> resource = mockResource();
+    when(resource.getSize()).thenReturn(200);
+
+    ResourceRemovedListener listener = mock(ResourceRemovedListener.class);
+
+    resourceCache.setResourceRemovedListener(listener);
+    resourceCache.put(new MockKey(), resource);
+
+    verify(listener).onResourceRemoved(eq(resource));
+  }
+
+  @Test
+  public void testSizeIsBasedOnResource() {
+    LruResourceCache resourceCache = new LruResourceCache(100);
+    Resource<?> first = getResource(50);
+    MockKey firstKey = new MockKey();
+    resourceCache.put(firstKey, first);
+    Resource<?> second = getResource(50);
+    MockKey secondKey = new MockKey();
+    resourceCache.put(secondKey, second);
+
+    assertTrue(resourceCache.contains(firstKey));
+    assertTrue(resourceCache.contains(secondKey));
+
+    Resource<?> third = getResource(50);
+    MockKey thirdKey = new MockKey();
+    resourceCache.put(thirdKey, third);
+
+    assertFalse(resourceCache.contains(firstKey));
+    assertTrue(resourceCache.contains(secondKey));
+    assertTrue(resourceCache.contains(thirdKey));
+  }
+
+  @Test
+  public void testPreventEviction() {
+    final MemoryCache cache = new LruResourceCache(100);
+    final Resource<?> first = getResource(30);
+    final Key firstKey = new MockKey();
+    cache.put(firstKey, first);
+    Resource<?> second = getResource(30);
+    Key secondKey = new MockKey();
+    cache.put(secondKey, second);
+    Resource<?> third = getResource(30);
+    Key thirdKey = new MockKey();
+    cache.put(thirdKey, third);
+    cache.setResourceRemovedListener(new ResourceRemovedListener() {
+      @Override
+      public void onResourceRemoved(@NonNull Resource<?> removed) {
+        if (removed == first) {
+          cache.put(firstKey, first);
+        }
+      }
+    });
+
+    // trims from 100 to 50, having 30+30+30 items, it should trim to 1 item
+    cache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
+
+    // and that 1 item must be first, because it's forced to return to cache in the listener
+    @SuppressWarnings("unchecked")
+    LruCache<Key, Resource<?>> lruCache = (LruCache<Key, Resource<?>>) cache;
+    assertTrue(lruCache.contains(firstKey));
+    assertFalse(lruCache.contains(secondKey));
+    assertFalse(lruCache.contains(thirdKey));
+  }
+
+  private Resource<?> getResource(int size) {
+    Resource<?> resource = mockResource();
+    when(resource.getSize()).thenReturn(size);
+    return resource;
+  }
+
+  private static class MockKey implements Key {
+    @Override
+    public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
+      messageDigest.update(toString().getBytes(CHARSET));
+    }
+  }
+
+  private static class PutWithExistingEntryHarness {
+    final LruResourceCache cache = new LruResourceCache(100);
+    final Resource<?> first = mockResource();
+    final Resource<?> second = mockResource();
+    final ResourceRemovedListener listener = mock(ResourceRemovedListener.class);
+    final Key key = new MockKey();
+
+    PutWithExistingEntryHarness() {
+      when(first.getSize()).thenReturn(50);
+      when(second.getSize()).thenReturn(50);
+      cache.setResourceRemovedListener(listener);
+    }
+  }
+
+  private static class TrimClearMemoryCacheHarness {
+    final LruResourceCache resourceCache = new LruResourceCache(100);
+    final Resource<?> first = mockResource();
+    final Resource<?> second = mockResource();
+    final ResourceRemovedListener listener = mock(ResourceRemovedListener.class);
+
+    TrimClearMemoryCacheHarness() {
+      when(first.getSize()).thenReturn(50);
+      when(second.getSize()).thenReturn(50);
+      resourceCache.put(new MockKey(), first);
+      resourceCache.put(new MockKey(), second);
+      resourceCache.setResourceRemovedListener(listener);
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
similarity index 91%
rename from library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
index 98c4b8371..ae2eb4bd6 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
@@ -32,7 +32,6 @@
   @Before
   public void setUp() {
     initialSdkVersion = Build.VERSION.SDK_INT;
-    Util.setSdkVersionInt(18);
     harness = new MemorySizeHarness();
   }
 
@@ -138,11 +137,9 @@ public void testCumulativePoolAndMemoryCacheSizesAreSmallerOnLowMemoryDevices()
 
   @Test
   public void testByteArrayPoolSize_withLowRamDevice_isHalfTheSpecifiedBytes() {
-    LowRamActivityManager activityManager =
-        (LowRamActivityManager) Shadow.extract(harness.activityManager);
-    Util.setSdkVersionInt(19);
+    LowRamActivityManager activityManager = Shadow.extract(harness.activityManager);
     activityManager.setMemoryClass(getLargeEnoughMemoryClass());
-    activityManager.setIsLowRam(true);
+    activityManager.setIsLowRam();
 
     int byteArrayPoolSize = harness.getCalculator().getArrayPoolSizeInBytes();
     assertThat(byteArrayPoolSize).isEqualTo(harness.byteArrayPoolSizeBytes / 2);
@@ -159,18 +156,18 @@ private int getLargeEnoughMemoryClass() {
   }
 
   private static class MemorySizeHarness {
-    int pixelSize = 500;
-    int bytesPerPixel = MemorySizeCalculator.BYTES_PER_ARGB_8888_PIXEL;
+    final int pixelSize = 500;
+    final int bytesPerPixel = MemorySizeCalculator.BYTES_PER_ARGB_8888_PIXEL;
     float memoryCacheScreens = MemorySizeCalculator.Builder.MEMORY_CACHE_TARGET_SCREENS;
     float bitmapPoolScreens = MemorySizeCalculator.Builder.BITMAP_POOL_TARGET_SCREENS;
-    float sizeMultiplier = MemorySizeCalculator.Builder.MAX_SIZE_MULTIPLIER;
+    final float sizeMultiplier = MemorySizeCalculator.Builder.MAX_SIZE_MULTIPLIER;
     int byteArrayPoolSizeBytes = MemorySizeCalculator.Builder.ARRAY_POOL_SIZE_BYTES;
-    ActivityManager activityManager =
+    final ActivityManager activityManager =
         (ActivityManager) RuntimeEnvironment.application.getSystemService(Context.ACTIVITY_SERVICE);
-    MemorySizeCalculator.ScreenDimensions screenDimensions =
+    final MemorySizeCalculator.ScreenDimensions screenDimensions =
         mock(MemorySizeCalculator.ScreenDimensions.class);
 
-    public MemorySizeCalculator getCalculator() {
+    MemorySizeCalculator getCalculator() {
       when(screenDimensions.getWidthPixels()).thenReturn(pixelSize);
       when(screenDimensions.getHeightPixels()).thenReturn(pixelSize);
       return new MemorySizeCalculator.Builder(RuntimeEnvironment.application)
@@ -183,7 +180,7 @@ public MemorySizeCalculator getCalculator() {
           .build();
     }
 
-    public int getScreenSize() {
+    int getScreenSize() {
       return pixelSize * pixelSize * bytesPerPixel;
     }
   }
@@ -193,11 +190,12 @@ public int getScreenSize() {
 
     private boolean isLowRam;
 
-    void setIsLowRam(boolean isLowRam) {
-      this.isLowRam = isLowRam;
+    void setIsLowRam() {
+      this.isLowRam = true;
     }
 
     @Implementation
+    @Override
     public boolean isLowRamDevice() {
       return isLowRam;
     }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/SafeKeyGeneratorTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/SafeKeyGeneratorTest.java
similarity index 83%
rename from library/src/test/java/com/bumptech/glide/load/engine/cache/SafeKeyGeneratorTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/cache/SafeKeyGeneratorTest.java
index 207ccaf9b..f48c56eaa 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/SafeKeyGeneratorTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/SafeKeyGeneratorTest.java
@@ -2,6 +2,7 @@
 
 import static org.junit.Assert.assertTrue;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Key;
 import java.security.MessageDigest;
 import java.util.regex.Matcher;
@@ -19,7 +20,7 @@
   private int nextId;
 
   @Before
-  public void setUp() throws Exception {
+  public void setUp() {
     nextId = 0;
     keyGenerator = new SafeKeyGenerator();
   }
@@ -42,15 +43,15 @@ private String getNextId() {
     return String.valueOf(nextId++);
   }
 
-  private static class MockKey implements Key {
-    private String id;
+  private static final class MockKey implements Key {
+    private final String id;
 
-    public MockKey(String id) {
+    MockKey(String id) {
       this.id = id;
     }
 
     @Override
-    public void updateDiskCacheKey(MessageDigest messageDigest) {
+    public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
       messageDigest.update(id.getBytes(CHARSET));
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java
similarity index 87%
rename from library/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java
index fa9dba251..7a9e74be1 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java
@@ -2,6 +2,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import android.support.annotation.NonNull;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -36,21 +37,21 @@ public void onRun(int priority) {
     assertThat(resultPriorities).containsExactly(5, 1, 2, 3, 4).inOrder();
   }
 
-  private static class MockRunnable implements Runnable,
+  private static final class MockRunnable implements Runnable,
       Comparable<MockRunnable> {
     private final int priority;
     private final OnRun onRun;
 
     @Override
-    public int compareTo(MockRunnable another) {
+    public int compareTo(@NonNull MockRunnable another) {
       return priority - another.priority;
     }
 
-    public interface OnRun {
+    interface OnRun {
       void onRun(int priority);
     }
 
-    public MockRunnable(int priority, OnRun onRun) {
+    MockRunnable(int priority, OnRun onRun) {
       this.priority = priority;
       this.onRun = onRun;
     }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java b/library/test/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
new file mode 100644
index 000000000..94ef1782c
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
@@ -0,0 +1,116 @@
+package com.bumptech.glide.load.engine.executor;
+
+import android.os.StrictMode;
+import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
+import com.google.common.util.concurrent.ForwardingExecutorService;
+import com.google.common.util.concurrent.MoreExecutors;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Future;
+
+/**
+ * Creates mock {@link GlideExecutor}s.
+ */
+@VisibleForTesting
+public final class MockGlideExecutor {
+  private MockGlideExecutor() {
+    // Utility class.
+  }
+
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public static GlideExecutor newTestExecutor(ExecutorService executorService) {
+    return new GlideExecutor(executorService);
+  }
+
+  public static GlideExecutor newMainThreadExecutor() {
+    return newTestExecutor(new DirectExecutorService());
+  }
+
+  /**
+   * @deprecated Use {@link #newMainThreadExecutor} instead.
+   */
+  @Deprecated
+  public static GlideExecutor newMainThreadUnlimitedExecutor() {
+    return newMainThreadExecutor();
+  }
+
+  /**
+   * DirectExecutorService that enforces StrictMode and converts ExecutionExceptions into
+   * RuntimeExceptions.
+   */
+  private static final class DirectExecutorService extends ForwardingExecutorService {
+    private static final StrictMode.ThreadPolicy THREAD_POLICY =
+        new StrictMode.ThreadPolicy.Builder()
+            .detectNetwork()
+            .penaltyDeath()
+            .build();
+
+    private final ExecutorService delegate;
+
+    DirectExecutorService() {
+      delegate = MoreExecutors.newDirectExecutorService();
+    }
+
+    @Override
+    protected ExecutorService delegate() {
+      return delegate;
+    }
+
+    @NonNull
+    @Override
+    public <T> Future<T> submit(@NonNull Runnable task, @NonNull T result) {
+      return getUninterruptibly(super.submit(task, result));
+    }
+
+    @NonNull
+    @Override
+    public <T> Future<T> submit(@NonNull Callable<T> task) {
+      return getUninterruptibly(super.submit(task));
+    }
+
+    @NonNull
+    @Override
+    public Future<?> submit(@NonNull Runnable task) {
+      return getUninterruptibly(super.submit(task));
+    }
+
+    @Override
+    public void execute(@NonNull final Runnable command) {
+      delegate.execute(new Runnable() {
+        @Override
+        public void run() {
+          StrictMode.ThreadPolicy oldPolicy = StrictMode.getThreadPolicy();
+          StrictMode.setThreadPolicy(THREAD_POLICY);
+          try {
+            command.run();
+          } finally {
+            StrictMode.setThreadPolicy(oldPolicy);
+          }
+        }
+      });
+    }
+
+    private <T> Future<T> getUninterruptibly(Future<T> future) {
+      boolean interrupted = false;
+      try {
+        while (!future.isDone()) {
+          try {
+            future.get();
+          } catch (ExecutionException e) {
+            throw new RuntimeException(e);
+          } catch (InterruptedException e) {
+            interrupted = true;
+          }
+        }
+      } finally {
+        if (interrupted) {
+          Thread.currentThread().interrupt();
+        }
+      }
+      return future;
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
similarity index 87%
rename from library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
index d00b03193..7680c43a7 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
@@ -16,10 +16,13 @@
 
 import android.graphics.Bitmap;
 import android.os.Handler;
+import android.util.Log;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruBitmapPool;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
+import com.bumptech.glide.load.engine.cache.MemoryCacheAdapter;
 import com.bumptech.glide.load.resource.bitmap.BitmapResource;
 import com.bumptech.glide.tests.Util.CreateBitmap;
 import com.bumptech.glide.util.Util;
@@ -37,15 +40,16 @@
 import org.mockito.stubbing.Answer;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLog;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class BitmapPreFillRunnerTest {
-  @Mock BitmapPreFillRunner.Clock clock;
-  @Mock BitmapPool pool;
-  @Mock MemoryCache cache;
-  @Mock Handler mainHandler;
-  private List<Bitmap> addedBitmaps = new ArrayList<>();
+  @Mock private BitmapPreFillRunner.Clock clock;
+  @Mock private BitmapPool pool;
+  @Mock private MemoryCache cache;
+  @Mock private Handler mainHandler;
+  private final List<Bitmap> addedBitmaps = new ArrayList<>();
 
   @Before
   public void setUp() {
@@ -195,7 +199,7 @@ public void testPreFillHandlerDoesNotPostIfHasBitmapsButIsCancelled() {
   @Test
   public void testAddsBitmapsToMemoryCacheIfMemoryCacheHasEnoughSpaceRemaining() {
     Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    when(cache.getMaxSize()).thenReturn(Util.getBitmapByteSize(bitmap));
+    when(cache.getMaxSize()).thenReturn(Long.valueOf(Util.getBitmapByteSize(bitmap)));
 
     PreFillType size =
         new PreFillType.Builder(bitmap.getWidth(), bitmap.getHeight()).setConfig(bitmap.getConfig())
@@ -214,7 +218,7 @@ public void testAddsBitmapsToMemoryCacheIfMemoryCacheHasEnoughSpaceRemaining() {
   @Test
   public void testAddsBitmapsToBitmapPoolIfMemoryCacheIsFull() {
     Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    when(cache.getMaxSize()).thenReturn(0);
+    when(cache.getMaxSize()).thenReturn(0L);
 
     PreFillType size =
         new PreFillType.Builder(bitmap.getWidth(), bitmap.getHeight()).setConfig(bitmap.getConfig())
@@ -233,7 +237,7 @@ public void testAddsBitmapsToBitmapPoolIfMemoryCacheIsFull() {
   @Test
   public void testAddsBitmapsToPoolIfMemoryCacheIsNotFullButCannotFitBitmap() {
     Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    when(cache.getMaxSize()).thenReturn(Util.getBitmapByteSize(bitmap) / 2);
+    when(cache.getMaxSize()).thenReturn((long) Util.getBitmapByteSize(bitmap) / 2);
 
     PreFillType size =
         new PreFillType.Builder(bitmap.getWidth(), bitmap.getHeight()).setConfig(bitmap.getConfig())
@@ -300,10 +304,28 @@ public void testDoesNotGetMoreThanOncePerSize() {
     // order.verify(pool, times(numBitmaps)).put(eq(bitmap));
   }
 
-  private static class AddBitmapPoolAnswer implements Answer<Void> {
-    private List<Bitmap> bitmaps;
+  @Test
+  public void allocate_whenBitmapPoolIsAtCapacity_doesNotLogWithRecycledBitmap() {
+    ShadowLog.setLoggable(BitmapPreFillRunner.TAG, Log.VERBOSE);
+
+    int dimensions = 10;
+    Bitmap.Config config = Bitmap.Config.ARGB_8888;
+    int bitmapByteSize = Util.getBitmapByteSize(dimensions, dimensions, config);
+    PreFillType preFillType = new PreFillType.Builder(dimensions).setConfig(config).build();
+    Map<PreFillType, Integer> allocationOrder = new HashMap<>();
+    allocationOrder.put(preFillType, 1);
+    PreFillQueue queue = new PreFillQueue(allocationOrder);
+    BitmapPreFillRunner runner =
+        new BitmapPreFillRunner(
+            new LruBitmapPool(bitmapByteSize - 1), new MemoryCacheAdapter(), queue);
+
+    runner.allocate();
+  }
+
+  private static final class AddBitmapPoolAnswer implements Answer<Void> {
+    private final List<Bitmap> bitmaps;
 
-    public AddBitmapPoolAnswer(List<Bitmap> bitmaps) {
+    AddBitmapPoolAnswer(List<Bitmap> bitmaps) {
       this.bitmaps = bitmaps;
     }
 
@@ -315,10 +337,10 @@ public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
     }
   }
 
-  private static class AddBitmapCacheAnswer implements Answer<Resource<?>> {
-    private List<Bitmap> bitmaps;
+  private static final class AddBitmapCacheAnswer implements Answer<Resource<?>> {
+    private final List<Bitmap> bitmaps;
 
-    public AddBitmapCacheAnswer(List<Bitmap> bitmaps) {
+    AddBitmapCacheAnswer(List<Bitmap> bitmaps) {
       this.bitmaps = bitmaps;
     }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
similarity index 87%
rename from library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
index 6349da7e1..d5a777f69 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
@@ -41,12 +41,12 @@
   private final Bitmap.Config defaultBitmapConfig = PreFillType.DEFAULT_CONFIG;
   private final Bitmap defaultBitmap =
       Bitmap.createBitmap(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT, defaultBitmapConfig);
-  private final int defaultBitmapSize = Util.getBitmapByteSize(defaultBitmap);
-  private final int poolSize = BITMAPS_IN_CACHE * defaultBitmapSize;
-  private final int cacheSize = BITMAPS_IN_POOL * defaultBitmapSize;
+  private final long defaultBitmapSize = Util.getBitmapByteSize(defaultBitmap);
+  private final long poolSize = BITMAPS_IN_CACHE * defaultBitmapSize;
+  private final long cacheSize = BITMAPS_IN_POOL * defaultBitmapSize;
 
-  @Mock BitmapPool pool;
-  @Mock MemoryCache cache;
+  @Mock private BitmapPool pool;
+  @Mock private MemoryCache cache;
   private BitmapPreFiller bitmapPreFiller;
 
   @Before
@@ -62,9 +62,11 @@ public void setUp() {
 
   @Test
   public void testAllocationOrderContainsEnoughSizesToFillPoolAndMemoryCache() {
-    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(new PreFillType[] {
-        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
-            .setConfig(defaultBitmapConfig).build() });
+    PreFillQueue allocationOrder =
+        bitmapPreFiller.generateAllocationOrder(
+            new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
+                .setConfig(defaultBitmapConfig)
+                .build());
 
     assertEquals(BITMAPS_IN_POOL + BITMAPS_IN_CACHE, allocationOrder.getSize());
   }
@@ -88,11 +90,12 @@ public void testAllocationOrderThatDoesNotFitExactlyIntoGivenSizeRoundsDown() {
     }
 
     int expectedSize = 0;
-    int maxSize = poolSize + cacheSize;
+    long maxSize = poolSize + cacheSize;
     for (PreFillType current : sizes) {
       int currentSize =
           Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());
-      expectedSize += currentSize * (maxSize / (3 * currentSize));
+      // See https://errorprone.info/bugpattern/NarrowingCompoundAssignment.
+      expectedSize = (int) (expectedSize + (currentSize * (maxSize / (3 * currentSize))));
     }
 
     assertEquals(expectedSize, byteSize);
@@ -100,15 +103,15 @@ public void testAllocationOrderThatDoesNotFitExactlyIntoGivenSizeRoundsDown() {
 
   @Test
   public void testAllocationOrderDoesNotOverFillWithMultipleSizes() {
-    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(new PreFillType[] {
+    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(
         new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
             .setConfig(defaultBitmapConfig).build(),
         new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
             .setConfig(defaultBitmapConfig).build(),
         new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
-            .setConfig(defaultBitmapConfig).build() });
+            .setConfig(defaultBitmapConfig).build());
 
-    int byteSize = 0;
+    long byteSize = 0;
     while (!allocationOrder.isEmpty()) {
       PreFillType current = allocationOrder.remove();
       byteSize +=
@@ -120,15 +123,15 @@ public void testAllocationOrderDoesNotOverFillWithMultipleSizes() {
 
   @Test
   public void testAllocationOrderDoesNotOverFillWithMultipleSizesAndWeights() {
-    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(new PreFillType[] {
+    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(
         new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
             .setConfig(defaultBitmapConfig).setWeight(4).build(),
         new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
             .setConfig(defaultBitmapConfig).build(),
         new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 3)
-            .setConfig(defaultBitmapConfig).setWeight(3).build() });
+            .setConfig(defaultBitmapConfig).setWeight(3).build());
 
-    int byteSize = 0;
+    long byteSize = 0;
     while (!allocationOrder.isEmpty()) {
       PreFillType current = allocationOrder.remove();
       byteSize +=
@@ -140,9 +143,11 @@ public void testAllocationOrderDoesNotOverFillWithMultipleSizesAndWeights() {
 
   @Test
   public void testAllocationOrderContainsSingleSizeIfSingleSizeIsProvided() {
-    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(new PreFillType[] {
-        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
-            .setConfig(defaultBitmapConfig).build() });
+    PreFillQueue allocationOrder =
+        bitmapPreFiller.generateAllocationOrder(
+            new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
+                .setConfig(defaultBitmapConfig)
+                .build());
 
     while (!allocationOrder.isEmpty()) {
       PreFillType size = allocationOrder.remove();
@@ -161,7 +166,7 @@ public void testAllocationOrderSplitsEvenlyBetweenEqualSizesWithEqualWeights() {
         new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
             .setConfig(defaultBitmapConfig).build();
     PreFillQueue allocationOrder =
-        bitmapPreFiller.generateAllocationOrder(new PreFillType[] { smallWidth, smallHeight, });
+        bitmapPreFiller.generateAllocationOrder(smallWidth, smallHeight);
 
     int numSmallWidth = 0, numSmallHeight = 0;
     while (!allocationOrder.isEmpty()) {
@@ -185,8 +190,7 @@ public void testAllocationOrderSplitsByteSizeEvenlyBetweenUnEqualSizesWithEqualW
             .setConfig(defaultBitmapConfig).build();
     PreFillType normal = new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
         .setConfig(defaultBitmapConfig).build();
-    PreFillQueue allocationOrder =
-        bitmapPreFiller.generateAllocationOrder(new PreFillType[] { smallWidth, normal });
+    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(smallWidth, normal);
 
     int numSmallWidth = 0, numNormal = 0;
     while (!allocationOrder.isEmpty()) {
@@ -210,8 +214,7 @@ public void testAllocationOrderSplitsByteSizeUnevenlyBetweenEqualSizesWithUnequa
             .setConfig(defaultBitmapConfig).setWeight(2).build();
     PreFillType normal = new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
         .setConfig(defaultBitmapConfig).build();
-    PreFillQueue allocationOrder =
-        bitmapPreFiller.generateAllocationOrder(new PreFillType[] { doubleWeight, normal });
+    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(doubleWeight, normal);
 
     int numDoubleWeight = 0, numNormal = 0;
     while (!allocationOrder.isEmpty()) {
@@ -239,8 +242,7 @@ public void testAllocationOrderRoundRobinsDifferentSizes() {
         new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
             .setConfig(defaultBitmapConfig).build();
 
-    PreFillQueue allocationOrder =
-        bitmapPreFiller.generateAllocationOrder(new PreFillType[] { smallWidth, smallHeight, });
+    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(smallWidth, smallHeight);
 
     List<PreFillType> attributes = new ArrayList<>();
     while (!allocationOrder.isEmpty()) {
@@ -258,6 +260,7 @@ public void testAllocationOrderRoundRobinsDifferentSizes() {
   }
 
   @Test
+  @SuppressWarnings("deprecation")
   public void testSetsConfigOnBuildersToDefaultIfNotSet() {
     PreFillType.Builder builder = mock(PreFillType.Builder.class);
     when(builder.build())
@@ -266,7 +269,8 @@ public void testSetsConfigOnBuildersToDefaultIfNotSet() {
     bitmapPreFiller.preFill(builder);
 
     InOrder order = inOrder(builder);
-    order.verify(builder).setConfig(DecodeFormat.DEFAULT == DecodeFormat.PREFER_ARGB_8888
+    order.verify(builder).setConfig(
+        DecodeFormat.DEFAULT == DecodeFormat.PREFER_ARGB_8888
         ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565);
     order.verify(builder).build();
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java
diff --git a/library/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java
similarity index 80%
rename from library/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java
index 1dd269502..d1670029e 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java
@@ -10,6 +10,7 @@
 import android.net.Uri;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.util.Preconditions;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -24,8 +25,8 @@
 public class AssetUriLoaderTest {
   private static final int IMAGE_SIDE = 10;
 
-  @Mock AssetUriLoader.AssetFetcherFactory<Object> factory;
-  @Mock DataFetcher<Object> fetcher;
+  @Mock private AssetUriLoader.AssetFetcherFactory<Object> factory;
+  @Mock private DataFetcher<Object> fetcher;
   private AssetUriLoader<Object> loader;
 
   @Before
@@ -39,7 +40,9 @@ public void testHandlesAssetUris() {
     Uri assetUri = Uri.parse("file:///android_asset/assetName");
     when(factory.buildFetcher(any(AssetManager.class), eq("assetName"))).thenReturn(fetcher);
     assertTrue(loader.handles(assetUri));
-    assertEquals(fetcher, loader.buildLoadData(assetUri, IMAGE_SIDE, IMAGE_SIDE,
-        new Options()).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(
+            loader.buildLoadData(assetUri, IMAGE_SIDE, IMAGE_SIDE, new Options())).fetcher);
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java
similarity index 68%
rename from library/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java
index e17ecc6b9..80eb81666 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java
@@ -9,6 +9,7 @@
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.util.Preconditions;
 import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
@@ -20,8 +21,8 @@
 @RunWith(JUnit4.class)
 public class ByteArrayLoaderTest {
 
-  @Mock ByteArrayLoader.Converter<Object> converter;
-  @Mock DataFetcher.DataCallback<Object> callback;
+  @Mock private ByteArrayLoader.Converter<Object> converter;
+  @Mock private DataFetcher.DataCallback<Object> callback;
   private ByteArrayLoader<Object> loader;
   private Options options;
 
@@ -35,24 +36,28 @@ public void setUp() {
   @Test
   public void testCanHandleByteArray() {
     byte[] data = new byte[10];
-    DataFetcher<Object> fetcher = loader.buildLoadData(data, -1, -1, options).fetcher;
+    DataFetcher<Object> fetcher =
+        Preconditions.checkNotNull(loader.buildLoadData(data, -1, -1, options)).fetcher;
     assertNotNull(fetcher);
   }
 
   @Test
   public void testFetcherReturnsObjectReceivedFromConverter() throws IOException {
-    byte[] data = "fake".getBytes();
+    byte[] data = "fake".getBytes("UTF-8");
     Object expected = new Object();
     when(converter.convert(eq(data))).thenReturn(expected);
 
-    loader.buildLoadData(data, 10, 10, options).fetcher.loadData(Priority.HIGH, callback);
+    Preconditions.checkNotNull(loader.buildLoadData(data, 10, 10, options)).fetcher
+        .loadData(Priority.HIGH, callback);
     verify(callback).onDataReady(eq(expected));
   }
 
   @Test
   public void testFetcherReturnsDataClassFromConverter() {
     when(converter.getDataClass()).thenReturn(Object.class);
-    assertEquals(Object.class,
-        loader.buildLoadData(new byte[10], 10, 10, options).fetcher.getDataClass());
+    assertEquals(
+        Object.class,
+        Preconditions.checkNotNull(loader.buildLoadData(new byte[10], 10, 10, options)).fetcher
+            .getDataClass());
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java
similarity index 89%
rename from library/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java
index 6665f0720..440516b26 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java
@@ -6,6 +6,7 @@
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.util.Base64;
 import com.bumptech.glide.Priority;
@@ -55,18 +56,17 @@
 
   @Mock
   private MultiModelLoaderFactory multiFactory;
-  private DataUrlLoader<InputStream> dataUrlLoader;
+  private DataUrlLoader<String, InputStream> dataUrlLoader;
   private DataFetcher<InputStream> fetcher;
   private Options options;
 
   @Before
-  public void setUp() throws Exception {
+  public void setUp() {
     MockitoAnnotations.initMocks(this);
-    DataUrlLoader.StreamFactory factory = new DataUrlLoader.StreamFactory();
+    DataUrlLoader.StreamFactory<String> factory = new DataUrlLoader.StreamFactory<>();
     options = new Options();
-    dataUrlLoader = (DataUrlLoader<InputStream>) factory.build(multiFactory);
+    dataUrlLoader = (DataUrlLoader<String, InputStream>) factory.build(multiFactory);
     fetcher = dataUrlLoader.buildLoadData(VALID_PNG, -1, -1, options).fetcher;
-
   }
 
   @Test
@@ -94,7 +94,7 @@ public void testDecode() throws IOException {
   }
 
   @Test
-  public void testDecodeInvalidScheme() throws IOException {
+  public void testDecodeInvalidScheme() {
     fetcher = dataUrlLoader.buildLoadData(INVALID_URL_WRONG_SCHEME1, -1, -1, options).fetcher;
     CallBack callback = new CallBack();
     fetcher.loadData(Priority.HIGH, callback);
@@ -102,7 +102,7 @@ public void testDecodeInvalidScheme() throws IOException {
   }
 
   @Test
-  public void testDecodeMissingComma() throws IOException {
+  public void testDecodeMissingComma() {
     fetcher = dataUrlLoader.buildLoadData(INVALID_URL_MISSING_COMMA, -1, -1, options).fetcher;
     CallBack callback = new CallBack();
     fetcher.loadData(Priority.HIGH, callback);
@@ -110,14 +110,14 @@ public void testDecodeMissingComma() throws IOException {
   }
 
   @Test
-  public void testDecodeWrongEncoding() throws IOException {
+  public void testDecodeWrongEncoding() {
     fetcher = dataUrlLoader.buildLoadData(INVALID_URL_WRONG_ENCODING, -1, -1, options).fetcher;
     CallBack callback = new CallBack();
     fetcher.loadData(Priority.HIGH, callback);
     assertNotNull(callback.exception);
   }
 
-  private class CallBack implements DataFetcher.DataCallback<Object> {
+  private static final class CallBack implements DataFetcher.DataCallback<Object> {
 
     public Object data;
     public Exception exception;
@@ -128,7 +128,7 @@ public void onDataReady(@Nullable Object data) {
     }
 
     @Override
-    public void onLoadFailed(Exception e) {
+    public void onLoadFailed(@NonNull Exception e) {
       this.exception = e;
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java
similarity index 90%
rename from library/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java
index 2548b0e59..6bc1ddd29 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.model;
 
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.mockito.Mockito.mock;
 
@@ -87,6 +88,16 @@ public void testIssue133() throws MalformedURLException {
     assertEquals(escaped, glideUrlFromEscapedUrl.toURL().toString());
   }
 
+  @Test
+  public void issue_2583() throws MalformedURLException {
+    String original =
+        "http://api.met.no/weatherapi/weathericon/1.1/?symbol=9;content_type=image/png";
+
+    GlideUrl glideUrl = new GlideUrl(original);
+    assertThat(glideUrl.toURL().toString()).isEqualTo(original);
+    assertThat(glideUrl.toStringUrl()).isEqualTo(original);
+  }
+
   @Test
   public void testEquals() throws MalformedURLException {
     Headers headers = mock(Headers.class);
diff --git a/library/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
similarity index 88%
rename from library/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
index 907acb6ae..b0e2d1402 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
@@ -35,6 +35,43 @@ public void tearDown() {
     }
   }
 
+  // Tests for #2331.
+  @Test
+  public void getSanitizedUserAgent_withInvalidAgent_returnsAgentWithInvalidCharactersRemoved() {
+    String invalidUserAgent =
+        "Dalvik/2.1.0 (Linux; U; Android 5.0; P98 4G八核版(A8H8) Build/LRX21M)";
+    String validUserAgent = "Dalvik/2.1.0 (Linux; U; Android 5.0; P98 4G???(A8H8) Build/LRX21M)";
+    System.setProperty(DEFAULT_USER_AGENT_PROPERTY, invalidUserAgent);
+    assertThat(LazyHeaders.Builder.getSanitizedUserAgent()).isEqualTo(validUserAgent);
+  }
+
+  @Test
+  public void getSanitizedUserAgent_withValidAgent_returnsUnmodifiedAgent() {
+    String validUserAgent = "Dalvik/2.1.0 (Linux; U; Android 5.0; P98 4G(A8H8) Build/LRX21M)";
+    System.setProperty(DEFAULT_USER_AGENT_PROPERTY, validUserAgent);
+    assertThat(LazyHeaders.Builder.getSanitizedUserAgent()).isEqualTo(validUserAgent);
+  }
+
+  @Test
+  public void getSanitizedUserAgent_withMissingAgent_returnsNull() {
+    System.clearProperty(DEFAULT_USER_AGENT_PROPERTY);
+    assertThat(LazyHeaders.Builder.getSanitizedUserAgent()).isNull();
+  }
+
+  @Test
+  public void getSanitizedUserAgent_withEmptyStringAgent_returnsEmptyString() {
+    String userAgent = "";
+    System.setProperty(DEFAULT_USER_AGENT_PROPERTY, userAgent);
+    assertThat(LazyHeaders.Builder.getSanitizedUserAgent()).isEqualTo(userAgent);
+  }
+
+  @Test
+  public void getSanitizedUserAgent_withWhitespace_returnsWhitespaceString() {
+    String userAgent = "  \t";
+    System.setProperty(DEFAULT_USER_AGENT_PROPERTY, userAgent);
+    assertThat(LazyHeaders.Builder.getSanitizedUserAgent()).isEqualTo(userAgent);
+  }
+
   @Test
   public void testIncludesEagerHeaders() {
     Map<String, String> headers = new Builder()
diff --git a/library/src/test/java/com/bumptech/glide/load/model/ModelCacheTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/ModelCacheTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/load/model/ModelCacheTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/ModelCacheTest.java
diff --git a/library/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java
similarity index 85%
rename from library/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java
index b6acd775c..36f3f3480 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.model;
 
 import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertThrows;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
@@ -13,9 +14,8 @@
 import java.util.ArrayList;
 import java.util.List;
 import org.junit.Before;
-import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.ExpectedException;
+import org.junit.function.ThrowingRunnable;
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
 import org.mockito.Mock;
@@ -23,28 +23,27 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
+// containsExactly produces a spurious warning.
+@SuppressWarnings("ResultOfMethodCallIgnored")
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class MultiModelLoaderFactoryTest {
+  @Mock private ModelLoaderFactory<String, String> firstFactory;
+  @Mock private ModelLoader<String, String> firstModelLoader;
+  @Mock private MultiModelLoaderFactory.Factory multiModelLoaderFactory;
+  @Mock private ModelLoaderFactory<String, String> secondFactory;
+  @Mock private ModelLoader<String, String> secondModelLoader;
 
-  @Mock ModelLoaderFactory<String, String> firstFactory;
-  @Mock ModelLoader<String, String> firstModelLoader;
-  @Mock MultiModelLoaderFactory.Factory multiModelLoaderFactory;
-  @Mock ModelLoaderFactory<String, String> secondFactory;
-  @Mock ModelLoader<String, String> secondModelLoader;
-
-  @Rule public ExpectedException exception = ExpectedException.none();
-
-  private Pool<List<Exception>> exceptionListPool;
+  private Pool<List<Throwable>> throwableListPool;
   private MultiModelLoaderFactory multiFactory;
 
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
-    exceptionListPool = FactoryPools.threadSafeList();
+    throwableListPool = FactoryPools.threadSafeList();
 
-    multiFactory = new MultiModelLoaderFactory(exceptionListPool,
-        multiModelLoaderFactory);
+    multiFactory =
+        new MultiModelLoaderFactory(throwableListPool, multiModelLoaderFactory);
     when(firstFactory.build(eq(multiFactory))).thenReturn(firstModelLoader);
     when(secondFactory.build(eq(multiFactory))).thenReturn(secondModelLoader);
   }
@@ -104,7 +103,7 @@ public void testReplace_returnsPreviouslyRegisteredFactories_withModelAndDataCla
     multiFactory.append(String.class, String.class, firstOtherFactory);
     multiFactory.append(String.class, String.class, secondOtherFactory);
 
-    List<ModelLoaderFactory<String, String>> removed =
+    List<ModelLoaderFactory<? extends String, ? extends String>> removed =
         multiFactory.replace(String.class, String.class, firstFactory);
     assertThat(removed).containsExactly(firstOtherFactory, secondOtherFactory);
   }
@@ -126,7 +125,7 @@ public void testRemove_returnsPreviouslyRegisteredFactories_withModelAndDataClas
     multiFactory.append(String.class, String.class, other);
     multiFactory.append(String.class, String.class, firstFactory);
 
-    List<ModelLoaderFactory<String, String>> removed =
+    List<ModelLoaderFactory<? extends String, ? extends String>> removed =
         multiFactory.remove(String.class, String.class);
     assertThat(removed).containsExactly(firstFactory, other);
   }
@@ -182,16 +181,28 @@ public void testBuild_withModelClass_excludesModelLoadersForOtherModelClasses()
   public void testBuild_withModelAndDataClasses_excludesModelLoadersForOtherDataClasses() {
     multiFactory.append(String.class, String.class, firstFactory);
 
-    exception.expect(NoModelLoaderAvailableException.class);
-    multiFactory.build(String.class, Integer.class);
+    assertThrows(
+        NoModelLoaderAvailableException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() throws Throwable {
+            multiFactory.build(String.class, Integer.class);
+          }
+        });
   }
 
   @Test
   public void testBuild_withModelAndDataClasses_excludesModelLoadersForOtherModelClasses() {
     multiFactory.append(String.class, String.class, firstFactory);
 
-    exception.expect(NoModelLoaderAvailableException.class);
-    multiFactory.build(Integer.class, String.class);
+    assertThrows(
+        NoModelLoaderAvailableException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() throws Throwable {
+            multiFactory.build(Integer.class, String.class);
+          }
+        });
   }
 
   @Test
@@ -211,15 +222,28 @@ public void testBuild_withModelClass_matchesSuperclassesOfModelClass() {
   @Test
   public void testBuild_withModelAndDataClass_doesNotMatchSubclassesOfModelClass() {
     appendFactoryFor(String.class, Object.class);
-    exception.expect(NoModelLoaderAvailableException.class);
-    multiFactory.build(Object.class, Object.class);
+
+    assertThrows(
+        NoModelLoaderAvailableException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() throws Throwable {
+            multiFactory.build(Object.class, Object.class);
+          }
+        });
   }
 
   @Test
   public void testBuild_withModelAndDataClass_doesNotMatchSubclassesOfDataClass() {
     appendFactoryFor(Object.class, String.class);
-    exception.expect(NoModelLoaderAvailableException.class);
-    multiFactory.build(Object.class, Object.class);
+    assertThrows(
+        NoModelLoaderAvailableException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() throws Throwable {
+            multiFactory.build(Object.class, Object.class);
+          }
+        });
   }
 
   @Test
@@ -268,13 +292,11 @@ public void testBuild_respectsPrependOrder() {
       Class<Y> dataClass) {
     ArgumentCaptor<List<ModelLoader<X, Y>>> captor = Util.cast(ArgumentCaptor.forClass(List.class));
     multiFactory.build(modelClass, dataClass);
-    verify(multiModelLoaderFactory).build(captor.capture(), eq(exceptionListPool));
+    verify(multiModelLoaderFactory).build(captor.capture(), eq(throwableListPool));
 
     List<ModelLoader<X, Y>> captured = captor.getValue();
     List<ModelLoader<X, Y>> result = new ArrayList<>(captured.size());
-    for (ModelLoader<X, Y> modelLoader : captured) {
-      result.add(modelLoader);
-    }
+    result.addAll(captured);
     return result;
   }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java
similarity index 86%
rename from library/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java
index a5038c23a..ec2c1831e 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java
@@ -14,6 +14,7 @@
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.util.Preconditions;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -30,9 +31,9 @@
 @Config(manifest = Config.NONE, sdk = 18)
 public class ResourceLoaderTest {
 
-  @Mock ModelLoader<Uri, Object> uriLoader;
-  @Mock DataFetcher<Object> fetcher;
-  @Mock Key key;
+  @Mock private ModelLoader<Uri, Object> uriLoader;
+  @Mock private DataFetcher<Object> fetcher;
+  @Mock private Key key;
   private Options options;
 
   private ResourceLoader<Object> loader;
@@ -53,7 +54,9 @@ public void testCanHandleId() {
         .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
 
     assertTrue(loader.handles(id));
-    assertEquals(fetcher, loader.buildLoadData(id, 100, 100, new Options()).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(loader.buildLoadData(id, 100, 100, new Options())).fetcher);
   }
 
     @Test
diff --git a/library/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java
similarity index 81%
rename from library/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java
index 3eecb3718..07dd655dc 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java
@@ -30,17 +30,21 @@ public void setUp() {
 
   @After
   public void tearDown() {
-    file.delete();
+    // GC before delete() to release files on Windows (https://stackoverflow.com/a/4213208/253468)
+    System.gc();
+    if (!file.delete()) {
+      throw new IllegalStateException("Failed to delete: " + file);
+    }
   }
 
   @Test
   public void testWritesDataFromInputStreamToOutputStream() throws IOException {
     String fakeData = "SomeRandomFakeData";
-    ByteArrayInputStream is = new ByteArrayInputStream(fakeData.getBytes());
+    ByteArrayInputStream is = new ByteArrayInputStream(fakeData.getBytes("UTF-8"));
     encoder.encode(is, file, new Options());
 
     byte[] data = ByteBufferUtil.toBytes(ByteBufferUtil.fromFile(file));
 
-    assertEquals(fakeData, new String(data));
+    assertEquals(fakeData, new String(data, "UTF-8"));
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java
similarity index 72%
rename from library/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java
index 42bc40545..b6554eabf 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java
@@ -13,8 +13,8 @@
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.tests.Util;
+import com.bumptech.glide.util.Preconditions;
 import java.io.File;
-import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -33,15 +33,15 @@
   // Not a magic number, just an arbitrary non zero value.
   private static final int IMAGE_SIDE = 100;
 
-  @Mock ModelLoader<Uri, Object> uriLoader;
-  @Mock DataFetcher<Object> fetcher;
-  @Mock Key key;
+  @Mock private ModelLoader<Uri, Object> uriLoader;
+  @Mock private DataFetcher<Object> fetcher;
+  @Mock private Key key;
 
   private StringLoader<Object> loader;
   private Options options;
 
   @Before
-  public void setUp() throws Exception {
+  public void setUp() {
     MockitoAnnotations.initMocks(this);
 
     options = new Options();
@@ -50,9 +50,9 @@ public void setUp() throws Exception {
   }
 
   @Test
-  public void testHandlesPaths() throws IOException {
-    // TODO on windows it will fail with schema being the drive letter (C:\... -> C)
-    assumeTrue(!Util.isWindows());
+  public void testHandlesPaths() {
+    // TODO fix drive letter parsing somehow
+    assumeTrue("it will fail with schema being the drive letter (C:\\... -> C)", !Util.isWindows());
 
     File f = RuntimeEnvironment.application.getCacheDir();
     Uri expected = Uri.fromFile(f);
@@ -60,14 +60,14 @@ public void testHandlesPaths() throws IOException {
         .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
 
     assertTrue(loader.handles(f.getAbsolutePath()));
-    assertEquals(fetcher,
-        loader.buildLoadData(f.getAbsolutePath(), IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(
+            loader.buildLoadData(f.getAbsolutePath(), IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
   }
 
   @Test
   public void testCanHandleComplexFilePaths() {
-    assumeTrue(!Util.isWindows());
-
     String testPath =
         "/storage/emulated/0/DCIM/Camera/IMG_20140520_100001:nopm:.jpg,mimeType=image/jpeg,"
             + "2448x3264,orientation=0,date=Tue";
@@ -76,11 +76,14 @@ public void testCanHandleComplexFilePaths() {
         .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
 
     assertTrue(loader.handles(testPath));
-    assertEquals(fetcher, loader.buildLoadData(testPath, IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(
+            loader.buildLoadData(testPath, IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
   }
 
   @Test
-  public void testHandlesFileUris() throws IOException {
+  public void testHandlesFileUris() {
     File f = RuntimeEnvironment.application.getCacheDir();
 
     Uri expected = Uri.fromFile(f);
@@ -88,20 +91,24 @@ public void testHandlesFileUris() throws IOException {
         .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
 
     assertTrue(loader.handles(f.getAbsolutePath()));
-    assertEquals(fetcher,
-        loader.buildLoadData(expected.toString(), IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(
+            loader.buildLoadData(expected.toString(), IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
   }
 
   @Test
-  public void testHandlesResourceUris() throws IOException {
+  public void testHandlesResourceUris() {
     Uri resourceUri = Uri.parse("android.resource://com.bumptech.glide.tests/raw/ic_launcher");
 
     when(uriLoader.buildLoadData(eq(resourceUri), eq(IMAGE_SIDE), eq(IMAGE_SIDE), eq(options)))
         .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
 
     assertTrue(loader.handles(resourceUri.toString()));
-    assertEquals(fetcher,
-        loader.buildLoadData(resourceUri.toString(), IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(
+            loader.buildLoadData(resourceUri.toString(), IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
   }
 
   @Test
@@ -113,7 +120,10 @@ public void testHandlesHttp() {
         .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
 
     assertTrue(loader.handles(url));
-    assertEquals(fetcher, loader.buildLoadData(url, IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(
+            loader.buildLoadData(url, IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
   }
 
   @Test
@@ -125,7 +135,10 @@ public void testHandlesHttps() {
         .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
 
     assertTrue(loader.handles(url));
-    assertEquals(fetcher, loader.buildLoadData(url, IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(
+            loader.buildLoadData(url, IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
   }
 
   @Test
@@ -137,7 +150,10 @@ public void testHandlesContent() {
         .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
 
     assertTrue(loader.handles(content));
-    assertEquals(fetcher, loader.buildLoadData(content, IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(
+            loader.buildLoadData(content, IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java
similarity index 73%
rename from library/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java
index 846ed783c..b7a4f3859 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java
@@ -8,6 +8,7 @@
 import android.net.Uri;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.util.Preconditions;
 import java.io.File;
 import java.io.IOException;
 import org.junit.Before;
@@ -27,8 +28,8 @@
   // Not a magic number, just arbitrary non zero.
   private static final int IMAGE_SIDE = 120;
 
-  @Mock DataFetcher<Object> localUriFetcher;
-  @Mock UriLoader.LocalUriFetcherFactory<Object> factory;
+  @Mock private DataFetcher<Object> localUriFetcher;
+  @Mock private UriLoader.LocalUriFetcherFactory<Object> factory;
   private UriLoader<Object> loader;
   private Options options;
 
@@ -46,8 +47,10 @@ public void testHandlesFileUris() throws IOException {
     when(factory.build(eq(fileUri))).thenReturn(localUriFetcher);
 
     assertTrue(loader.handles(fileUri));
-    assertEquals(localUriFetcher,
-        loader.buildLoadData(fileUri, IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+    assertEquals(
+        localUriFetcher,
+        Preconditions.checkNotNull(
+            loader.buildLoadData(fileUri, IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
   }
 
   @Test
@@ -56,8 +59,10 @@ public void testHandlesResourceUris() throws IOException {
     when(factory.build(eq(resourceUri))).thenReturn(localUriFetcher);
 
     assertTrue(loader.handles(resourceUri));
-    assertEquals(localUriFetcher,
-        loader.buildLoadData(resourceUri, IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+    assertEquals(
+        localUriFetcher,
+        Preconditions.checkNotNull(
+            loader.buildLoadData(resourceUri, IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
   }
 
   @Test
@@ -66,7 +71,9 @@ public void testHandlesContentUris() {
     when(factory.build(eq(contentUri))).thenReturn(localUriFetcher);
 
     assertTrue(loader.handles(contentUri));
-    assertEquals(localUriFetcher, loader.buildLoadData(contentUri, IMAGE_SIDE, IMAGE_SIDE,
-        options).fetcher);
+    assertEquals(
+        localUriFetcher,
+        Preconditions.checkNotNull(
+            loader.buildLoadData(contentUri, IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java
similarity index 79%
rename from library/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java
index 0c87d5f1b..e635b01a2 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java
@@ -9,12 +9,14 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelCache;
 import com.bumptech.glide.load.model.ModelLoader;
+import com.bumptech.glide.util.Preconditions;
 import java.io.InputStream;
 import org.junit.Before;
 import org.junit.Test;
@@ -30,9 +32,9 @@
 @Config(manifest = Config.NONE, sdk = 18)
 public class BaseGlideUrlLoaderTest {
 
-  @Mock ModelCache<Object, GlideUrl> modelCache;
-  @Mock ModelLoader<GlideUrl, InputStream> wrapped;
-  @Mock DataFetcher<InputStream> fetcher;
+  @Mock private ModelCache<Object, GlideUrl> modelCache;
+  @Mock private ModelLoader<GlideUrl, InputStream> wrapped;
+  @Mock private DataFetcher<InputStream> fetcher;
   private TestLoader urlLoader;
   private Options options;
 
@@ -68,7 +70,9 @@ public void testReturnsUrlFromCacheIfPresent() {
     when(wrapped.buildLoadData(eq(expectedUrl), eq(width), eq(height), eq(options)))
         .thenReturn(new ModelLoader.LoadData<>(mock(Key.class), fetcher));
 
-    assertEquals(fetcher, urlLoader.buildLoadData(model, width, height, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(urlLoader.buildLoadData(model, width, height, options)).fetcher);
   }
 
   @Test
@@ -80,16 +84,18 @@ public void testBuildsNewUrlIfNotPresentInCache() {
     when(wrapped.buildLoadData(any(GlideUrl.class), eq(width), eq(height), eq(options)))
         .thenAnswer(new Answer<ModelLoader.LoadData<InputStream>>() {
           @Override
-          public ModelLoader.LoadData<InputStream> answer(InvocationOnMock invocationOnMock)
-              throws Throwable {
+          public ModelLoader.LoadData<InputStream> answer(InvocationOnMock invocationOnMock) {
             GlideUrl glideUrl = (GlideUrl) invocationOnMock.getArguments()[0];
             assertEquals(urlLoader.resultUrl, glideUrl.toStringUrl());
             return new ModelLoader.LoadData<>(mock(Key.class), fetcher);
 
           }
         });
-    assertEquals(fetcher,
-        urlLoader.buildLoadData(new GlideUrl(urlLoader.resultUrl), width, height, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(
+            urlLoader.buildLoadData(
+                new GlideUrl(urlLoader.resultUrl), width, height, options)).fetcher);
   }
 
   @Test
@@ -101,7 +107,7 @@ public void testAddsNewUrlToCacheIfNotPresentInCache() {
 
     doAnswer(new Answer<Void>() {
       @Override
-      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) {
         GlideUrl glideUrl = (GlideUrl) invocationOnMock.getArguments()[3];
         assertEquals(urlLoader.resultUrl, glideUrl.toStringUrl());
         return null;
@@ -124,13 +130,16 @@ public void testDoesNotInteractWithModelCacheIfNull() {
     when(wrapped.buildLoadData(any(GlideUrl.class), eq(width), eq(height), eq(options)))
         .thenReturn(new ModelLoader.LoadData<>(mock(Key.class), fetcher));
 
-    assertEquals(fetcher, urlLoader.buildLoadData(new Object(), width, height, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(
+            urlLoader.buildLoadData(new Object(), width, height, options)).fetcher);
   }
 
-  private class TestLoader extends BaseGlideUrlLoader<Object> {
-    public String resultUrl;
+  private static final class TestLoader extends BaseGlideUrlLoader<Object> {
+    String resultUrl;
 
-    public TestLoader(ModelLoader<GlideUrl, InputStream> concreteLoader,
+    TestLoader(ModelLoader<GlideUrl, InputStream> concreteLoader,
         ModelCache<Object, GlideUrl> modelCache) {
       super(concreteLoader, modelCache);
     }
@@ -141,7 +150,7 @@ protected String getUrl(Object model, int width, int height, Options options) {
     }
 
     @Override
-    public boolean handles(Object model) {
+    public boolean handles(@NonNull Object model) {
       return true;
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java
similarity index 84%
rename from library/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java
index 92efc86ce..e46c95fcd 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java
@@ -7,6 +7,7 @@
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.HttpUrlFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.util.Preconditions;
 import java.io.InputStream;
 import org.junit.Before;
 import org.junit.Test;
@@ -29,7 +30,8 @@ public void setUp() {
 
   @Test
   public void testReturnsValidFetcher() {
-    DataFetcher<InputStream> result = loader.buildLoadData(model, 100, 100, new Options()).fetcher;
+    DataFetcher<InputStream> result =
+        Preconditions.checkNotNull(loader.buildLoadData(model, 100, 100, new Options())).fetcher;
     assertThat(result).isInstanceOf(HttpUrlFetcher.class);
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java
similarity index 97%
rename from library/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java
index 92dae6dbb..5abc0b23d 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java
@@ -24,7 +24,7 @@
   private static final int IMAGE_SIDE = 100;
   private static final Options OPTIONS = new Options();
 
-  @Mock ModelLoader<GlideUrl, InputStream> urlLoader;
+  @Mock private ModelLoader<GlideUrl, InputStream> urlLoader;
   private HttpUriLoader loader;
 
   @Before
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/SimpleResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/SimpleResourceTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/load/resource/SimpleResourceTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/SimpleResourceTest.java
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
similarity index 75%
rename from library/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
index d5dc77761..087c606d3 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
@@ -9,11 +9,12 @@
 import android.app.Application;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.KeyTester;
 import com.bumptech.glide.tests.Util;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -21,6 +22,7 @@
 
 @RunWith(JUnit4.class)
 public class UnitTransformationTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
 
   private Application app;
 
@@ -37,12 +39,17 @@ public void testReturnsGivenResource() {
   }
 
   @Test
-  public void testEquals() throws NoSuchAlgorithmException {
-    KeyAssertions.assertSame(UnitTransformation.get(), UnitTransformation.get());
-
+  public void testEqualsHashCodeDigest() throws NoSuchAlgorithmException {
     @SuppressWarnings("unchecked") Transformation<Object> other = mock(Transformation.class);
     doAnswer(new Util.WriteDigest("other")).when(other)
         .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertDifferent(UnitTransformation.get(), other);
+
+    keyTester
+        .addEquivalenceGroup(
+            UnitTransformation.get(),
+            UnitTransformation.get())
+        .addEquivalenceGroup(other)
+        .addEmptyDigestRegressionTest(UnitTransformation.get())
+        .test();
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java
similarity index 90%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java
index c65b03707..7fdd33f3c 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java
@@ -54,10 +54,10 @@ public void testBitmapIsReturnedToPoolOnRecycle() {
   }
 
   private static class BitmapDrawableResourceHarness {
-    BitmapPool bitmapPool = mock(BitmapPool.class);
-    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    final BitmapPool bitmapPool = mock(BitmapPool.class);
+    final Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
 
-    public BitmapDrawableResource create() {
+    BitmapDrawableResource create() {
       return new BitmapDrawableResource(
           new BitmapDrawable(RuntimeEnvironment.application.getResources(), bitmap), bitmapPool);
     }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java
similarity index 84%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java
index b5fa17830..2daa5979b 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java
@@ -18,12 +18,13 @@
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.KeyTester;
 import com.bumptech.glide.tests.Util;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
@@ -37,12 +38,13 @@
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
+@SuppressWarnings("deprecation")
 public class BitmapDrawableTransformationTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
 
-  @Mock BitmapPool bitmapPool;
-  @Mock Transformation<Bitmap> wrapped;
-  @Mock Resource<BitmapDrawable> drawableResourceToTransform;
-  @Mock BitmapDrawable drawableToTransform;
+  @Mock private BitmapPool bitmapPool;
+  @Mock private Transformation<Bitmap> wrapped;
+  @Mock private Resource<BitmapDrawable> drawableResourceToTransform;
 
   private BitmapDrawableTransformation transformation;
   private Bitmap bitmapToTransform;
@@ -52,11 +54,11 @@
   public void setUp() {
     MockitoAnnotations.initMocks(this);
     bitmapToTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    BitmapDrawable drawableToTransform = new BitmapDrawable(bitmapToTransform);
 
     context = RuntimeEnvironment.application;
-    Glide.init(new GlideBuilder().setBitmapPool(bitmapPool).build(context));
+    Glide.init(context, new GlideBuilder().setBitmapPool(bitmapPool));
     when(drawableResourceToTransform.get()).thenReturn(drawableToTransform);
-    when(drawableToTransform.getBitmap()).thenReturn(bitmapToTransform);
     transformation = new BitmapDrawableTransformation(wrapped);
   }
 
@@ -124,11 +126,18 @@ public void testProvidesBitmapFromGivenResourceToWrappedTransformation() {
   public void testEquals() throws NoSuchAlgorithmException {
     doAnswer(new Util.WriteDigest("wrapped")).when(wrapped)
         .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertSame(transformation, new BitmapDrawableTransformation(wrapped));
-
     @SuppressWarnings("unchecked") Transformation<Bitmap> other = mock(Transformation.class);
     doAnswer(new Util.WriteDigest("other")).when(other)
         .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertDifferent(transformation, new BitmapDrawableTransformation(other));
+
+    keyTester
+        .addEquivalenceGroup(
+            transformation,
+            new BitmapDrawableTransformation(wrapped))
+        .addEquivalenceGroup(new BitmapDrawableTransformation(other))
+        .addEquivalenceGroup(wrapped)
+        .addRegressionTest(
+            transformation, "adbf45b08ad6468aa147e5b2a23758ef56ab631a2b70ad52501ca358441a34f3")
+        .test();
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
similarity index 74%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
index 876a2bdef..68d4a56c3 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
@@ -6,12 +6,12 @@
 import static org.junit.Assert.assertTrue;
 import static org.mockito.Mockito.when;
 
-import android.annotation.TargetApi;
 import android.graphics.Bitmap;
-import android.os.Build;
 import com.bumptech.glide.load.EncodeStrategy;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
 import com.bumptech.glide.util.ByteBufferUtil;
 import java.io.File;
 import java.io.IOException;
@@ -57,7 +57,6 @@ public void testBitmapIsEncodedWithGivenQuality() throws IOException {
   }
 
   @Test
-  @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
   public void testEncoderObeysNonNullCompressFormat() throws IOException {
     Bitmap.CompressFormat format = Bitmap.CompressFormat.WEBP;
     harness.setFormat(format);
@@ -89,13 +88,13 @@ public void testEncoderEncodesPngWithNullFormatAndBitmapWithAlpha() throws IOExc
 
   @Test
   public void testReturnsTrueFromWrite() {
-    BitmapEncoder encoder = new BitmapEncoder();
+    BitmapEncoder encoder = new BitmapEncoder(harness.arrayPool);
     assertTrue(encoder.encode(harness.resource, harness.file, harness.options));
   }
 
   @Test
   public void testEncodeStrategy_alwaysReturnsTransformed() {
-    BitmapEncoder encoder = new BitmapEncoder();
+    BitmapEncoder encoder = new BitmapEncoder(harness.arrayPool);
     assertEquals(EncodeStrategy.TRANSFORMED, encoder.getEncodeStrategy(harness.options));
   }
 
@@ -104,32 +103,37 @@ private static void assertContains(String string, String expected) {
   }
 
   private static class EncoderHarness {
-    Resource<Bitmap> resource = mockResource();
-    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    Options options = new Options();
-    File file = new File(RuntimeEnvironment.application.getCacheDir(), "test");
+    final Resource<Bitmap> resource = mockResource();
+    final Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    final Options options = new Options();
+    final File file = new File(RuntimeEnvironment.application.getCacheDir(), "test");
+    final ArrayPool arrayPool = new LruArrayPool();
 
-    public EncoderHarness() {
+    EncoderHarness() {
       when(resource.get()).thenReturn(bitmap);
     }
 
-    public void setQuality(int quality) {
+    void setQuality(int quality) {
       options.set(BitmapEncoder.COMPRESSION_QUALITY, quality);
     }
 
-    public void setFormat(Bitmap.CompressFormat format) {
+    void setFormat(Bitmap.CompressFormat format) {
       options.set(BitmapEncoder.COMPRESSION_FORMAT, format);
     }
 
-    public String encode() throws IOException {
-      BitmapEncoder encoder = new BitmapEncoder();
+    String encode() throws IOException {
+      BitmapEncoder encoder = new BitmapEncoder(arrayPool);
       encoder.encode(resource, file, options);
       byte[] data = ByteBufferUtil.toBytes(ByteBufferUtil.fromFile(file));
-      return new String(data);
+      return new String(data, "UTF-8");
     }
 
-    public void tearDown() {
-      file.delete();
+    void tearDown() {
+      // GC before delete() to release files on Windows (https://stackoverflow.com/a/4213208/253468)
+      System.gc();
+      if (file.exists() && !file.delete()) {
+        throw new IllegalStateException("Failed to delete: " + file);
+      }
     }
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java
similarity index 90%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java
index cb567b21f..60f360b16 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java
@@ -69,8 +69,8 @@ public void testThrowsIfBitmapAndBitmapPoolAreNull() {
   }
 
   private static class BitmapResourceHarness {
-    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    BitmapPool bitmapPool = mock(BitmapPool.class);
-    BitmapResource resource = new BitmapResource(bitmap, bitmapPool);
+    final Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    final BitmapPool bitmapPool = mock(BitmapPool.class);
+    final BitmapResource resource = new BitmapResource(bitmap, bitmapPool);
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
similarity index 89%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
index d7d22f0c3..cb7bd2e99 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
@@ -38,7 +38,7 @@ public void setUp() {
     MockitoAnnotations.initMocks(this);
     context = RuntimeEnvironment.application;
 
-    Glide.init(new GlideBuilder().setBitmapPool(bitmapPool).build(context));
+    Glide.init(context, new GlideBuilder().setBitmapPool(bitmapPool));
   }
 
   @After
@@ -50,7 +50,7 @@ public void tearDown() {
   public void testReturnsGivenResourceWhenBitmapNotTransformed() {
     BitmapTransformation transformation = new BitmapTransformation() {
       @Override
-      public void updateDiskCacheKey(MessageDigest messageDigest) { }
+      public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) { }
 
       @Override
       protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform,
@@ -68,7 +68,7 @@ public void testReturnsNewResourceWhenBitmapTransformed() {
     final Bitmap transformed = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
     BitmapTransformation transformation = new BitmapTransformation() {
       @Override
-      public void updateDiskCacheKey(MessageDigest messageDigest) { }
+      public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) { }
 
       @Override
       protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap bitmap, int outWidth,
@@ -88,7 +88,7 @@ public void testPassesGivenArgumentsToTransform() {
     final Resource<Bitmap> resource = mockResource(223, 4123);
     BitmapTransformation transformation = new BitmapTransformation() {
       @Override
-      public void updateDiskCacheKey(MessageDigest messageDigest) { }
+      public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) { }
 
       @Override
       protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform,
@@ -109,7 +109,7 @@ public void testThrowsIfGivenInvalidWidth() {
     BitmapTransformation transformation = new BitmapTransformation() {
 
       @Override
-      public void updateDiskCacheKey(MessageDigest messageDigest) { }
+      public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) { }
 
       @Override
       protected Bitmap transform(@NonNull BitmapPool bitmapPool, @NonNull Bitmap toTransform,
@@ -125,7 +125,7 @@ public void testThrowsIfGivenInvalidHeight() {
     BitmapTransformation transformation = new BitmapTransformation() {
 
       @Override
-      public void updateDiskCacheKey(MessageDigest messageDigest) { }
+      public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) { }
 
       @Override
       protected Bitmap transform(@NonNull BitmapPool bitmapPool, @NonNull Bitmap toTransform,
@@ -142,7 +142,7 @@ public void testReturnsNullIfTransformReturnsNull() {
     BitmapTransformation transform = new BitmapTransformation() {
 
       @Override
-      public void updateDiskCacheKey(MessageDigest messageDigest) {  }
+      public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {  }
 
       @Override
       protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform,
@@ -184,7 +184,7 @@ public void testCallsTransformWithGivenBitmapHeightIfHeightIsSizeOriginal() {
     return resource;
   }
 
-  private class SizeTrackingTransform extends BitmapTransformation {
+  private static final class SizeTrackingTransform extends BitmapTransformation {
     int givenWidth;
     int givenHeight;
 
@@ -197,6 +197,6 @@ protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform
     }
 
     @Override
-    public void updateDiskCacheKey(MessageDigest messageDigest) { }
+    public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) { }
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
similarity index 88%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
index a421660e0..d36b44ebd 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
@@ -18,12 +18,13 @@
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.KeyTester;
 import com.bumptech.glide.tests.Util;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
@@ -36,9 +37,10 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class CenterCropTest {
-  @Mock Resource<Bitmap> resource;
-  @Mock BitmapPool pool;
-  @Mock Transformation<Bitmap> transformation;
+  @Rule public final KeyTester keyTester = new KeyTester();
+  @Mock private Resource<Bitmap> resource;
+  @Mock private BitmapPool pool;
+  @Mock private Transformation<Bitmap> transformation;
 
   private CenterCrop centerCrop;
   private int bitmapWidth;
@@ -57,7 +59,7 @@ public void setUp() {
     when(pool.get(anyInt(), anyInt(), any(Bitmap.Config.class)))
         .thenAnswer(new Util.CreateBitmap());
     context = RuntimeEnvironment.application;
-    Glide.init(new GlideBuilder().setBitmapPool(pool).build(context));
+    Glide.init(context, new GlideBuilder().setBitmapPool(pool));
 
     centerCrop = new CenterCrop();
   }
@@ -147,10 +149,16 @@ public void testReturnsBitmapWithExactlyGivenDimensionsIfBitmapIsSmallerThanTarg
 
   @Test
   public void testEquals() throws NoSuchAlgorithmException {
-    KeyAssertions.assertSame(centerCrop, new CenterCrop());
-
     doAnswer(new Util.WriteDigest("other")).when(transformation)
         .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertDifferent(centerCrop, transformation);
+    keyTester
+        .addEquivalenceGroup(
+            new CenterCrop(),
+            new CenterCrop())
+        .addEquivalenceGroup(
+            transformation)
+        .addRegressionTest(
+            new CenterCrop(), "68bd5819c42b37efbe7124bb851443a6388ee3e2e9034213da6eaa15381d3457")
+        .test();
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java
similarity index 85%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java
index ebb4129a8..ba0f059f1 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java
@@ -19,12 +19,13 @@
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
-import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.KeyTester;
 import com.bumptech.glide.tests.Util;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
@@ -39,9 +40,10 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = { CenterInsideTest.DrawNothingCanvas.class })
 public class CenterInsideTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
 
-  @Mock Resource<Bitmap> resource;
-  @Mock Transformation<Bitmap> transformation;
+  @Mock private Resource<Bitmap> resource;
+  @Mock private Transformation<Bitmap> transformation;
   private CenterInside centerInside;
   private int bitmapWidth;
   private int bitmapHeight;
@@ -57,7 +59,7 @@ public void setUp() {
 
     context = RuntimeEnvironment.application;
     BitmapPool pool = new BitmapPoolAdapter();
-    Glide.init(new GlideBuilder().setBitmapPool(pool).build(context));
+    Glide.init(context, new GlideBuilder().setBitmapPool(pool));
 
     centerInside = new CenterInside();
   }
@@ -108,11 +110,18 @@ public void testDoesNotRecycleGivenResource() {
 
   @Test
   public void testEquals() throws NoSuchAlgorithmException {
-    KeyAssertions.assertSame(centerInside, new CenterInside());
-
     doAnswer(new Util.WriteDigest("other")).when(transformation)
         .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertDifferent(centerInside, transformation);
+
+    keyTester
+        .addEquivalenceGroup(
+            new CenterInside(),
+            new CenterInside(),
+            centerInside)
+        .addEquivalenceGroup(transformation)
+        .addRegressionTest(
+            new CenterInside(), "acf83850a2e8e9e809c8bfb999e2aede9e932cb897a15367fac9856b96f3ba33")
+    .test();
   }
 
   @Implements(Canvas.class)
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java
similarity index 86%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java
index 740472103..d93bc231c 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java
@@ -3,6 +3,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
+import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
 import android.content.Context;
@@ -13,10 +14,13 @@
 import android.graphics.Rect;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.GlideBuilder;
+import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.tests.KeyTester;
 import com.bumptech.glide.tests.Util;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
@@ -28,6 +32,7 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE)
 public class CircleCropTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
   @Mock private BitmapPool bitmapPool;
 
   private CircleCrop circleCrop;
@@ -38,7 +43,7 @@ public void setup() {
     when(bitmapPool.get(anyInt(), anyInt(), any(Bitmap.Config.class)))
         .thenAnswer(new Util.CreateBitmap());
     Context context = RuntimeEnvironment.application;
-    Glide.init(new GlideBuilder().setBitmapPool(bitmapPool).build(context));
+    Glide.init(context, new GlideBuilder().setBitmapPool(bitmapPool));
     circleCrop = new CircleCrop();
   }
 
@@ -85,6 +90,16 @@ public void testTransform_withNarrowRectangle() {
     assertSamePixels(expected, result);
   }
 
+  @Test
+  public void testEquals() {
+    keyTester
+        .addEquivalenceGroup(circleCrop, new CircleCrop())
+        .addEquivalenceGroup(mock(Transformation.class))
+        .addRegressionTest(
+            new CircleCrop(), "1442365bcc658f89310e39844ef4be58f4b16e52c283254e5a458020f56acb90")
+        .test();
+  }
+
   private void assertSamePixels(Bitmap expected, Bitmap actual) {
     assertEquals(expected.getWidth(), actual.getWidth());
     assertEquals(expected.getHeight(), actual.getHeight());
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java
similarity index 98%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java
index 40b9bfb7a..4b39cf880 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java
@@ -3,6 +3,7 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.ImageHeaderParser.ImageType;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
@@ -351,7 +352,7 @@ private static void runTest(byte[] data, ParserTestCase test) throws IOException
   private static class SometimesZeroSkipInputStream extends FilterInputStream {
     boolean returnZeroFlag = true;
 
-    protected SometimesZeroSkipInputStream(InputStream in) {
+    SometimesZeroSkipInputStream(InputStream in) {
         super(in);
     }
 
@@ -370,7 +371,7 @@ public long skip(long byteCount) throws IOException {
 
   private static class PartialSkipInputStream extends FilterInputStream {
 
-    protected PartialSkipInputStream(InputStream in) {
+    PartialSkipInputStream(InputStream in) {
         super(in);
     }
 
@@ -386,12 +387,12 @@ public long skip(long byteCount) throws IOException {
 
   private static class PartialReadInputStream extends FilterInputStream {
 
-    protected PartialReadInputStream(InputStream in) {
+    PartialReadInputStream(InputStream in) {
         super(in);
     }
 
     @Override
-    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
+    public int read(@NonNull byte[] buffer, int byteOffset, int byteCount) throws IOException {
         int toActuallyRead = byteCount / 2;
         if (byteCount == 1) {
             toActuallyRead = 1;
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategyTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategyTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategyTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategyTest.java
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformationTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformationTest.java
new file mode 100644
index 000000000..b95fee2ba
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformationTest.java
@@ -0,0 +1,183 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.isA;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Color;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.ColorDrawable;
+import android.graphics.drawable.Drawable;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
+import com.bumptech.glide.load.resource.SimpleResource;
+import com.bumptech.glide.tests.KeyTester;
+import com.bumptech.glide.tests.Util;
+import java.security.MessageDigest;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class DrawableTransformationTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
+  @Mock private Transformation<Bitmap> bitmapTransformation;
+  private BitmapPool bitmapPool;
+  private DrawableTransformation transformation;
+  private Context context;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    transformation = new DrawableTransformation(bitmapTransformation, /*isRequired=*/ true);
+    context = RuntimeEnvironment.application;
+    bitmapPool = new BitmapPoolAdapter();
+    Glide.init(context, new GlideBuilder().setBitmapPool(bitmapPool));
+  }
+
+  @After
+  public void tearDown() {
+    Glide.tearDown();
+  }
+
+  @Test
+  public void transform_withBitmapDrawable_andUnitBitmapTransformation_doesNotRecycle() {
+    when(
+        bitmapTransformation
+            .transform(
+                any(Context.class), anyBitmapResource(), anyInt(), anyInt()))
+        .thenAnswer(new ReturnGivenResource());
+
+    Bitmap bitmap = Bitmap.createBitmap(100, 200, Bitmap.Config.ARGB_8888);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+    @SuppressWarnings("unchecked")
+    Resource<Drawable> input =
+        (Resource<Drawable>) (Resource<?>) new BitmapDrawableResource(drawable, bitmapPool);
+    transformation.transform(context, input, /*outWidth=*/ 100, /*outHeight=*/ 200);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void transform_withBitmapDrawable_andFunctionalBitmapTransformation_doesNotRecycle() {
+    when(bitmapTransformation.transform(
+        any(Context.class), anyBitmapResource(), anyInt(), anyInt()))
+        .thenAnswer(new Answer<Resource<Bitmap>>() {
+          @Override
+          public Resource<Bitmap> answer(InvocationOnMock invocationOnMock) throws Throwable {
+            return BitmapResource.obtain(
+                Bitmap.createBitmap(200, 200, Bitmap.Config.ARGB_8888), bitmapPool);
+          }
+        });
+    Bitmap bitmap = Bitmap.createBitmap(100, 200, Bitmap.Config.ARGB_8888);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+    @SuppressWarnings("unchecked")
+    Resource<Drawable> input =
+        (Resource<Drawable>) (Resource<?>) new BitmapDrawableResource(drawable, bitmapPool);
+    transformation.transform(context, input, /*outWidth=*/ 100, /*outHeight=*/ 200);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void transform_withColorDrawable_andUnitBitmapTransformation_recycles() {
+    bitmapPool = mock(BitmapPool.class);
+    Glide.tearDown();
+    Glide.init(context, new GlideBuilder().setBitmapPool(bitmapPool));
+    when(
+        bitmapTransformation
+            .transform(
+                any(Context.class), anyBitmapResource(), anyInt(), anyInt()))
+        .thenAnswer(new ReturnGivenResource());
+
+    ColorDrawable colorDrawable = new ColorDrawable(Color.RED);
+    final Resource<Drawable> input = new SimpleResource<Drawable>(colorDrawable);
+
+    doAnswer(new Answer<Void>() {
+      @Override
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
+        Bitmap bitmap = (Bitmap) invocationOnMock.getArguments()[0];
+        assertThat(bitmap.getWidth()).isEqualTo(100);
+        assertThat(bitmap.getHeight()).isEqualTo(200);
+        return null;
+      }
+    }).when(bitmapPool).put(any(Bitmap.class));
+    when(bitmapPool.get(anyInt(), anyInt(), any(Bitmap.Config.class)))
+        .thenAnswer(new Answer<Bitmap>() {
+          @Override
+          public Bitmap answer(InvocationOnMock invocationOnMock) throws Throwable {
+            int width = (Integer) invocationOnMock.getArguments()[0];
+            int height = (Integer) invocationOnMock.getArguments()[1];
+            Bitmap.Config config = (Bitmap.Config) invocationOnMock.getArguments()[2];
+            return Bitmap.createBitmap(width, height, config);
+          }
+        });
+
+    transformation.transform(context, input, /*outWidth=*/ 100, /*outHeight=*/ 200);
+
+    verify(bitmapPool).put(isA(Bitmap.class));
+  }
+
+  @Test
+  public void testEquals() {
+    BitmapTransformation otherBitmapTransformation = mock(BitmapTransformation.class);
+    doAnswer(new Util.WriteDigest("bitmapTransformation"))
+        .when(bitmapTransformation).updateDiskCacheKey(any(MessageDigest.class));
+    doAnswer(new Util.WriteDigest("otherBitmapTransformation"))
+        .when(otherBitmapTransformation).updateDiskCacheKey(any(MessageDigest.class));
+
+    keyTester
+        .addEquivalenceGroup(
+            transformation,
+            new DrawableTransformation(bitmapTransformation, /*isRequired=*/ true),
+            new DrawableTransformation(bitmapTransformation, /*isRequired=*/ false))
+        .addEquivalenceGroup(bitmapTransformation)
+        .addEquivalenceGroup(otherBitmapTransformation)
+        .addEquivalenceGroup(
+            new DrawableTransformation(otherBitmapTransformation, /*isRequired=*/ true),
+            new DrawableTransformation(otherBitmapTransformation, /*isRequired=*/ false))
+        .addRegressionTest(
+            new DrawableTransformation(bitmapTransformation, /*isRequired=*/ true),
+            "eddf60c557a6315a489b8a3a19b12439a90381256289fbe9a503afa726230bd9")
+        .addRegressionTest(
+            new DrawableTransformation(otherBitmapTransformation, /*isRequired=*/ false),
+            "40931536ed0ec97c39d4be10c44f5b69a86030ec575317f5a0f17e15a0ea9be8")
+        .test();
+  }
+
+  @SuppressWarnings("unchecked")
+  private static Resource<Bitmap> anyBitmapResource() {
+    return any(Resource.class);
+  }
+
+  private static final class ReturnGivenResource implements Answer<Resource<Bitmap>> {
+
+    @Override
+    public Resource<Bitmap> answer(InvocationOnMock invocationOnMock) throws Throwable {
+      @SuppressWarnings("unchecked")
+      Resource<Bitmap> input = (Resource<Bitmap>) invocationOnMock.getArguments()[1];
+      return input;
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
similarity index 84%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
index 65b073205..39a7bce42 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
@@ -18,12 +18,13 @@
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
-import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.KeyTester;
 import com.bumptech.glide.tests.Util;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
@@ -38,9 +39,10 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = { FitCenterTest.DrawNothingCanvas.class })
 public class FitCenterTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
 
-  @Mock Resource<Bitmap> resource;
-  @Mock Transformation<Bitmap> transformation;
+  @Mock private Resource<Bitmap> resource;
+  @Mock private Transformation<Bitmap> transformation;
   private FitCenter fitCenter;
   private int bitmapWidth;
   private int bitmapHeight;
@@ -56,7 +58,7 @@ public void setUp() {
 
     BitmapPool pool = new BitmapPoolAdapter();
     context = RuntimeEnvironment.application;
-    Glide.init(new GlideBuilder().setBitmapPool(pool).build(context));
+    Glide.init(context, new GlideBuilder().setBitmapPool(pool));
 
 
     fitCenter = new FitCenter();
@@ -91,11 +93,14 @@ public void testDoesNotRecycleGivenResource() {
 
   @Test
   public void testEquals() throws NoSuchAlgorithmException {
-    KeyAssertions.assertSame(fitCenter, new FitCenter());
-
     doAnswer(new Util.WriteDigest("other")).when(transformation)
         .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertDifferent(fitCenter, transformation);
+    keyTester
+        .addEquivalenceGroup(fitCenter, new FitCenter(), new FitCenter())
+        .addEquivalenceGroup(transformation)
+        .addRegressionTest(
+            new FitCenter(), "eda03bc6969032145110add4bfe399915897406f4ca3a1a7512d07750e60f90d")
+        .test();
   }
 
   @Implements(Canvas.class)
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResourceTest.java
new file mode 100644
index 000000000..1ad62cac2
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResourceTest.java
@@ -0,0 +1,90 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import com.bumptech.glide.load.engine.Initializable;
+import com.bumptech.glide.load.engine.Resource;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class LazyBitmapDrawableResourceTest {
+  @Mock private Resource<Bitmap> bitmapResource;
+  private LazyBitmapDrawableResource resource;
+  private Resources resources;
+  private Bitmap bitmap;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
+    bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    when(bitmapResource.get()).thenReturn(bitmap);
+
+    resources = RuntimeEnvironment.application.getResources();
+    resource =
+        (LazyBitmapDrawableResource) LazyBitmapDrawableResource.obtain(resources, bitmapResource);
+  }
+
+  @Test
+  public void obtain_withNullBitmapResource_returnsNull() {
+    assertThat(LazyBitmapDrawableResource.obtain(resources, null)).isNull();
+  }
+
+  @Test
+  public void getSize_returnsSizeOfWrappedResource() {
+    when(bitmapResource.getSize()).thenReturn(100);
+    assertThat(resource.getSize()).isEqualTo(100);
+  }
+
+  @Test
+  public void recycle_callsRecycleOnWrappedResource() {
+    resource.recycle();
+    verify(bitmapResource).recycle();
+  }
+
+  @Test
+  public void recycle_doesNotRecycleWrappedBitmap() {
+    resource.recycle();
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void get_returnsDrawableContainingWrappedBitmap() {
+    BitmapDrawable drawable = resource.get();
+    assertThat(drawable.getBitmap()).isSameAs(bitmap);
+  }
+
+  @Test
+  public void initialize_withNonInitializableResource_doesNothing() {
+    resource.initialize();
+  }
+
+  @Test
+  public void initialize_withWrappedInitializableResource_callsInitializeOnWrapped() {
+    InitializableBitmapResource bitmapResource = mock(InitializableBitmapResource.class);
+    resource =
+        (LazyBitmapDrawableResource) LazyBitmapDrawableResource.obtain(resources, bitmapResource);
+    resource.initialize();
+
+    verify(bitmapResource).initialize();
+  }
+
+  private interface InitializableBitmapResource extends Initializable,
+      Resource<Bitmap> {
+    // Intentionally empty.
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java
similarity index 99%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java
index 3260f51ae..f3dfea93a 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java
@@ -19,6 +19,8 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
+// Not required in tests.
+@SuppressWarnings("ResultOfMethodCallIgnored")
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class RecyclableBufferedInputStreamTest {
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
similarity index 99%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
index ae6264663..effaae7bf 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
@@ -36,7 +36,7 @@
     TransformationUtilsTest.AlphaShadowBitmap.class })
 public class TransformationUtilsTest {
 
-  @Mock BitmapPool bitmapPool;
+  @Mock private BitmapPool bitmapPool;
 
   @Before
   public void setUp() {
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoDecoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoDecoderTest.java
new file mode 100644
index 000000000..58b6557f6
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoDecoderTest.java
@@ -0,0 +1,160 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.anyLong;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.graphics.Bitmap;
+import android.media.MediaMetadataRetriever;
+import android.os.Build;
+import android.os.ParcelFileDescriptor;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.tests.Util;
+import com.bumptech.glide.util.Preconditions;
+import java.io.IOException;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 27)
+public class VideoDecoderTest {
+  @Mock private ParcelFileDescriptor resource;
+  @Mock private VideoDecoder.MediaMetadataRetrieverFactory factory;
+  @Mock private VideoDecoder.MediaMetadataRetrieverInitializer<ParcelFileDescriptor> initializer;
+  @Mock private MediaMetadataRetriever retriever;
+  @Mock private BitmapPool bitmapPool;
+  private VideoDecoder<ParcelFileDescriptor> decoder;
+  private Options options;
+  private int initialSdkVersion;
+
+  @Before
+  public void setup() {
+    MockitoAnnotations.initMocks(this);
+    when(factory.build()).thenReturn(retriever);
+    decoder = new VideoDecoder<>(bitmapPool, initializer, factory);
+    options = new Options();
+
+    initialSdkVersion = Build.VERSION.SDK_INT;
+  }
+
+  @After
+  public void tearDown() {
+    Util.setSdkVersionInt(initialSdkVersion);
+  }
+
+  @Test
+  public void testReturnsRetrievedFrameForResource() throws IOException {
+    Util.setSdkVersionInt(19);
+    Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    when(retriever.getFrameAtTime(VideoDecoder.DEFAULT_FRAME, VideoDecoder.DEFAULT_FRAME_OPTION))
+        .thenReturn(expected);
+
+    Resource<Bitmap> result =
+        Preconditions.checkNotNull(decoder.decode(resource, 100, 100, options));
+
+    verify(initializer).initialize(retriever, resource);
+    assertEquals(expected, result.get());
+  }
+
+  @Test
+  public void testReleasesMediaMetadataRetriever() throws IOException {
+    Util.setSdkVersionInt(19);
+    decoder.decode(resource, 1, 2, options);
+
+    verify(retriever).release();
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testThrowsExceptionIfCalledWithInvalidFrame() throws IOException {
+    Util.setSdkVersionInt(19);
+    options.set(VideoDecoder.TARGET_FRAME, -5L);
+    new VideoDecoder<>(bitmapPool, initializer, factory).decode(resource, 100, 100, options);
+  }
+
+  @Test
+  public void testSpecifiesThumbnailFrameIfICalledWithFrameNumber() throws IOException {
+    Util.setSdkVersionInt(19);
+    long frame = 5;
+    options.set(VideoDecoder.TARGET_FRAME, frame);
+    decoder = new VideoDecoder<>(bitmapPool, initializer, factory);
+
+    decoder.decode(resource, 100, 100, options);
+
+    verify(retriever).getFrameAtTime(frame, VideoDecoder.DEFAULT_FRAME_OPTION);
+  }
+
+  @Test
+  public void testDoesNotSpecifyThumbnailFrameIfCalledWithoutFrameNumber() throws IOException {
+    Util.setSdkVersionInt(19);
+    decoder = new VideoDecoder<>(bitmapPool, initializer, factory);
+    decoder.decode(resource, 100, 100, options);
+
+    verify(retriever).getFrameAtTime(VideoDecoder.DEFAULT_FRAME, VideoDecoder.DEFAULT_FRAME_OPTION);
+  }
+
+  @Test
+  public void getScaledFrameAtTime() throws IOException {
+    // Anything other than NONE.
+    options.set(DownsampleStrategy.OPTION, DownsampleStrategy.AT_LEAST);
+
+    Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    when(retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_VIDEO_WIDTH))
+        .thenReturn("100");
+    when(retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_VIDEO_HEIGHT))
+        .thenReturn("100");
+    when(retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_VIDEO_ROTATION))
+        .thenReturn("0");
+    when(retriever.getScaledFrameAtTime(-1, MediaMetadataRetriever.OPTION_CLOSEST_SYNC, 100, 100))
+        .thenReturn(expected);
+
+    assertThat(decoder.decode(resource, 100, 100, options).get()).isSameAs(expected);
+  }
+
+  @Test
+  public void decodeFrame_withTargetSizeOriginal_onApi27_doesNotThrow() throws IOException {
+    Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    when(retriever.getFrameAtTime(-1, MediaMetadataRetriever.OPTION_CLOSEST_SYNC))
+        .thenReturn(expected);
+
+    verify(retriever, never()).getScaledFrameAtTime(anyLong(), anyInt(), anyInt(), anyInt());
+    assertThat(decoder.decode(resource, Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL, options).get())
+        .isSameAs(expected);
+  }
+
+  @Test
+  public void decodeFrame_withTargetSizeOriginalWidthOnly_onApi27_doesNotThrow()
+      throws IOException {
+    Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    when(retriever.getFrameAtTime(-1, MediaMetadataRetriever.OPTION_CLOSEST_SYNC))
+        .thenReturn(expected);
+
+    verify(retriever, never()).getScaledFrameAtTime(anyLong(), anyInt(), anyInt(), anyInt());
+    assertThat(decoder.decode(resource, Target.SIZE_ORIGINAL, 100, options).get())
+        .isSameAs(expected);
+  }
+
+  @Test
+  public void decodeFrame_withTargetSizeOriginalHeightOnly_onApi27_doesNotThrow()
+      throws IOException {
+    Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    when(retriever.getFrameAtTime(-1, MediaMetadataRetriever.OPTION_CLOSEST_SYNC))
+        .thenReturn(expected);
+
+    verify(retriever, never()).getScaledFrameAtTime(anyLong(), anyInt(), anyInt(), anyInt());
+    assertThat(decoder.decode(resource, 100, Target.SIZE_ORIGINAL, options).get())
+        .isSameAs(expected);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bytes/BytesResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bytes/BytesResourceTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/load/resource/bytes/BytesResourceTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bytes/BytesResourceTest.java
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java
similarity index 85%
rename from library/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java
index 6537c6d43..50af60a7a 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java
@@ -1,6 +1,6 @@
 package com.bumptech.glide.load.resource.drawable;
 
-import static org.junit.Assert.assertEquals;
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertNotEquals;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
@@ -9,6 +9,7 @@
 import android.graphics.Canvas;
 import android.graphics.ColorFilter;
 import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 import org.junit.Before;
 import org.junit.Test;
@@ -26,6 +27,7 @@
   public void setUp() {
     drawable = mock(TestDrawable.class);
     resource = new DrawableResource<TestDrawable>(drawable) {
+      @NonNull
       @Override
       public Class<TestDrawable> getResourceClass() {
         return TestDrawable.class;
@@ -55,15 +57,23 @@ public void testReturnsNewDrawableOnGet() {
     when(constantState.newDrawable()).thenReturn(expected);
     when(drawable.getConstantState()).thenReturn(constantState);
 
-    assertEquals(expected, resource.get());
+    assertThat(resource.get()).isEqualTo(expected);
 
     verify(drawable).getConstantState();
     verify(constantState).newDrawable();
   }
 
+  @Test
+  public void get_withNullState_returnsOriginalDrawable() {
+    when(drawable.getConstantState()).thenReturn(null);
+
+    assertThat(resource.get()).isEqualTo(drawable);
+  }
+
   @Test(expected = NullPointerException.class)
   public void testThrowsIfDrawableIsNull() {
     new DrawableResource<TestDrawable>(null) {
+      @NonNull
       @Override
       public Class<TestDrawable> getResourceClass() {
         return TestDrawable.class;
@@ -86,7 +96,7 @@ public void recycle() {
    */
   private static class TestDrawable extends Drawable {
     @Override
-    public void draw(Canvas canvas) {
+    public void draw(@NonNull Canvas canvas) {
 
     }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java
similarity index 83%
rename from library/src/test/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java
index b1b5f3130..5e2c76048 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java
@@ -4,6 +4,7 @@
 
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.util.Preconditions;
 import java.io.File;
 import java.io.IOException;
 import org.junit.Before;
@@ -26,7 +27,7 @@ public void setUp() {
   @Test
   public void testReturnsGivenFileAsResource() throws IOException {
     File expected = new File("testFile");
-    Resource<File> decoded = decoder.decode(expected, 1, 1, options);
+    Resource<File> decoded = Preconditions.checkNotNull(decoder.decode(expected, 1, 1, options));
 
     assertEquals(expected, decoded.get());
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/file/FileResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/file/FileResourceTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/load/resource/file/FileResourceTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/file/FileResourceTest.java
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
similarity index 90%
rename from library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
index 8c78f1de1..d440630cd 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
@@ -36,17 +36,17 @@
 @Config(manifest = Config.NONE, sdk = 18, shadows = GlideShadowLooper.class)
 public class ByteBufferGifDecoderTest {
   private static final byte[] GIF_HEADER = new byte[] { 0x47, 0x49, 0x46 };
-  static final int ARRAY_POOL_SIZE_BYTES = 4 * 1024 * 1024;
+  private static final int ARRAY_POOL_SIZE_BYTES = 4 * 1024 * 1024;
 
   private ByteBufferGifDecoder decoder;
   private GifHeader gifHeader;
   private Options options;
 
-  @Mock BitmapPool bitmapPool;
-  @Mock GifHeaderParser parser;
-  @Mock GifDecoder gifDecoder;
-  @Mock ByteBufferGifDecoder.GifHeaderParserPool parserPool;
-  @Mock ByteBufferGifDecoder.GifDecoderFactory decoderFactory;
+  @Mock private BitmapPool bitmapPool;
+  @Mock private GifHeaderParser parser;
+  @Mock private GifDecoder gifDecoder;
+  @Mock private ByteBufferGifDecoder.GifHeaderParserPool parserPool;
+  @Mock private ByteBufferGifDecoder.GifDecoderFactory decoderFactory;
 
   @Before
   public void setUp() {
@@ -60,7 +60,7 @@ public void setUp() {
         eq(gifHeader), isA(ByteBuffer.class), anyInt()))
         .thenReturn(gifDecoder);
 
-    List<ImageHeaderParser> parsers = new ArrayList<ImageHeaderParser>();
+    List<ImageHeaderParser> parsers = new ArrayList<>();
     parsers.add(new DefaultImageHeaderParser());
 
     options = new Options();
@@ -86,13 +86,13 @@ public void testHandlesStreamIfContainsGifHeaderAndDisabledIsNotSet() throws IOE
 
   @Test
   public void testHandlesStreamIfContainsGifHeaderAndDisabledIsFalse() throws IOException {
-    options.set(ByteBufferGifDecoder.DISABLE_ANIMATION, false);
+    options.set(GifOptions.DISABLE_ANIMATION, false);
     assertThat(decoder.handles(ByteBuffer.wrap(GIF_HEADER), options)).isTrue();
   }
 
   @Test
   public void testDoesNotHandleStreamIfDisabled() throws IOException {
-    options.set(ByteBufferGifDecoder.DISABLE_ANIMATION, true);
+    options.set(GifOptions.DISABLE_ANIMATION, true);
     assertThat(decoder.handles(ByteBuffer.wrap(GIF_HEADER), options)).isFalse();
   }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
similarity index 87%
rename from library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
index 3d764e22d..1fae53bbc 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
@@ -14,26 +14,35 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.app.Application;
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
+import android.graphics.Color;
 import android.graphics.ColorFilter;
 import android.graphics.Paint;
 import android.graphics.PixelFormat;
+import android.graphics.PorterDuff.Mode;
+import android.graphics.PorterDuffColorFilter;
 import android.graphics.Rect;
 import android.graphics.drawable.Drawable;
+import android.graphics.drawable.TransitionDrawable;
 import android.os.Build;
+import android.view.View;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.gif.GifDrawableTest.BitmapTrackingShadowCanvas;
 import com.bumptech.glide.tests.GlideShadowLooper;
+import com.bumptech.glide.tests.TearDownGlide;
 import com.bumptech.glide.tests.Util;
+import com.bumptech.glide.util.Preconditions;
 import java.util.HashSet;
 import java.util.Set;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
@@ -48,6 +57,8 @@
 @Config(manifest = Config.NONE, sdk = 18,
     shadows = { GlideShadowLooper.class, BitmapTrackingShadowCanvas.class })
 public class GifDrawableTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+
   private GifDrawable drawable;
   private int frameHeight;
   private int frameWidth;
@@ -55,10 +66,10 @@
   private int initialSdkVersion;
 
   @Mock private Drawable.Callback cb;
-  @Mock private BitmapPool bitmapPool;
   @Mock private GifFrameLoader frameLoader;
   @Mock private Paint paint;
   @Mock private Transformation<Bitmap> transformation;
+  private Application context;
 
   private static Paint isAPaint() {
     return isA(Paint.class);
@@ -71,10 +82,11 @@ private static Rect isARect() {
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
+    context = RuntimeEnvironment.application;
     frameWidth = 120;
     frameHeight = 450;
     firstFrame = Bitmap.createBitmap(frameWidth, frameHeight, Bitmap.Config.RGB_565);
-    drawable = new GifDrawable(frameLoader, bitmapPool, paint);
+    drawable = new GifDrawable(frameLoader, paint);
     when(frameLoader.getWidth()).thenReturn(frameWidth);
     when(frameLoader.getHeight()).thenReturn(frameHeight);
     when(frameLoader.getCurrentFrame()).thenReturn(firstFrame);
@@ -88,13 +100,14 @@ public void tearDown() {
     Util.setSdkVersionInt(initialSdkVersion);
   }
 
+  // containsExactly doesn't need its return value checked.
+  @SuppressWarnings("ResultOfMethodCallIgnored")
   @Test
   public void testShouldDrawFirstFrameBeforeAnyFrameRead() {
     Canvas canvas = new Canvas();
     drawable.draw(canvas);
 
-    BitmapTrackingShadowCanvas shadowCanvas =
-        (BitmapTrackingShadowCanvas) Shadow.extract(canvas);
+    BitmapTrackingShadowCanvas shadowCanvas = Shadow.extract(canvas);
     assertThat(shadowCanvas.getDrawnBitmaps()).containsExactly(firstFrame);
   }
 
@@ -332,10 +345,15 @@ public void testReturnsSizeFromFrameLoader() {
   public void testReturnsNewDrawableFromConstantState() {
     Bitmap firstFrame = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
     drawable =
-        new GifDrawable(RuntimeEnvironment.application, mock(GifDecoder.class), bitmapPool,
-            transformation, 100, 100, firstFrame);
-
-    assertNotNull(drawable.getConstantState().newDrawable());
+        new GifDrawable(
+            RuntimeEnvironment.application,
+            mock(GifDecoder.class),
+            transformation,
+            100,
+            100,
+            firstFrame);
+
+    assertNotNull(Preconditions.checkNotNull(drawable.getConstantState()).newDrawable());
     assertNotNull(
         drawable.getConstantState().newDrawable(RuntimeEnvironment.application.getResources()));
   }
@@ -520,8 +538,8 @@ public void testSetsFrameTransformationOnFrameManager() {
 
   @Test(expected = NullPointerException.class)
   public void testThrowsIfConstructedWithNullFirstFrame() {
-    new GifDrawable(RuntimeEnvironment.application, mock(GifDecoder.class), bitmapPool,
-        transformation, 100, 100, null);
+    new GifDrawable(
+        RuntimeEnvironment.application, mock(GifDecoder.class), transformation, 100, 100, null);
   }
 
   @Test
@@ -544,9 +562,14 @@ public void testSetAlphaSetsAlphaOnPaint() {
 
   @Test
   public void testSetColorFilterSetsColorFilterOnPaint() {
-    ColorFilter colorFilter = new ColorFilter();
+    ColorFilter colorFilter = new PorterDuffColorFilter(Color.RED, Mode.ADD);
     drawable.setColorFilter(colorFilter);
-    verify(paint).setColorFilter(eq(colorFilter));
+
+    // Use ArgumentCaptor instead of eq() due to b/73121412 where ShadowPorterDuffColorFilter.equals
+    // uses a method that can't be found (PorterDuffColorFilter.getColor).
+    ArgumentCaptor<ColorFilter> captor = ArgumentCaptor.forClass(ColorFilter.class);
+    verify(paint).setColorFilter(captor.capture());
+    assertThat(captor.getValue()).isSameAs(colorFilter);
   }
 
   @Test
@@ -564,6 +587,30 @@ public void testThrowsIfCreatedWithNullState() {
     new GifDrawable(null);
   }
 
+  @Test
+  public void onFrameReady_whenAttachedToDrawableCallbackButNotViewCallback_stops() {
+    TransitionDrawable topLevel = new TransitionDrawable(new Drawable[] { drawable });
+    drawable.setCallback(topLevel);
+    topLevel.setCallback(null);
+
+    drawable.start();
+    drawable.onFrameReady();
+
+    assertThat(drawable.isRunning()).isFalse();
+  }
+
+  @Test
+  public void onFrameReady_whenAttachedtoDrawableCallbackWithViewCallbackParent_doesNotStop() {
+      TransitionDrawable topLevel = new TransitionDrawable(new Drawable[] { drawable });
+    drawable.setCallback(topLevel);
+    topLevel.setCallback(new View(context));
+
+    drawable.start();
+    drawable.onFrameReady();
+
+    assertThat(drawable.isRunning()).isTrue();
+  }
+
   private void verifyRanLoops(int loopCount, int frameCount) {
     // 1 for invalidate in start().
     verify(cb, times(1 + loopCount * frameCount)).invalidateDrawable(eq(drawable));
@@ -584,15 +631,16 @@ private void runLoops(int loopCount, int frameCount) {
    * Keeps track of the set of Bitmaps drawn to the canvas.
    */
   @Implements(Canvas.class)
-  public static class BitmapTrackingShadowCanvas extends ShadowCanvas {
+  public static final class BitmapTrackingShadowCanvas extends ShadowCanvas {
     private final Set<Bitmap> drawnBitmaps = new HashSet<>();
 
     @Implementation
+    @Override
     public void drawBitmap(Bitmap bitmap, Rect src, Rect dst, Paint paint) {
       drawnBitmaps.add(bitmap);
     }
 
-    public Iterable<Bitmap> getDrawnBitmaps() {
+    private Iterable<Bitmap> getDrawnBitmaps() {
       return drawnBitmaps;
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
similarity index 81%
rename from library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
index f73dc91a5..f31857b81 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
@@ -18,12 +18,13 @@
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.UnitTransformation;
-import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.KeyTester;
 import com.bumptech.glide.tests.Util;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
@@ -35,8 +36,9 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class GifDrawableTransformationTest {
-  @Mock Transformation<Bitmap> wrapped;
-  @Mock BitmapPool bitmapPool;
+  @Rule public final KeyTester keyTester = new KeyTester();
+  @Mock private Transformation<Bitmap> wrapped;
+  @Mock private BitmapPool bitmapPool;
 
   private GifDrawableTransformation transformation;
   private Context context;
@@ -46,7 +48,7 @@ public void setUp() {
     MockitoAnnotations.initMocks(this);
     context = RuntimeEnvironment.application;
 
-    Glide.init(new GlideBuilder().setBitmapPool(bitmapPool).build(context));
+    Glide.init(context, new GlideBuilder().setBitmapPool(bitmapPool));
     transformation = new GifDrawableTransformation(wrapped);
   }
 
@@ -86,11 +88,19 @@ public void testSetsTransformationAsFrameTransformation() {
   public void testEquals() throws NoSuchAlgorithmException {
     doAnswer(new Util.WriteDigest("first")).when(wrapped)
         .updateDiskCacheKey(isA(MessageDigest.class));
-    KeyAssertions.assertSame(transformation, new GifDrawableTransformation(wrapped));
-
     @SuppressWarnings("unchecked") Transformation<Bitmap> other = mock(Transformation.class);
     doAnswer(new Util.WriteDigest("other")).when(other)
         .updateDiskCacheKey(isA(MessageDigest.class));
-    KeyAssertions.assertDifferent(transformation, new GifDrawableTransformation(other));
+    keyTester
+        .addEquivalenceGroup(
+            transformation,
+            new GifDrawableTransformation(wrapped),
+            new GifDrawableTransformation(wrapped))
+        .addEquivalenceGroup(wrapped)
+        .addEquivalenceGroup(new GifDrawableTransformation(other))
+        .addRegressionTest(
+            new GifDrawableTransformation(wrapped),
+            "a7937b64b8caa58f03721bb6bacf5c78cb235febe0e70b1b84cd99541461a08e")
+        .test();
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
similarity index 68%
rename from library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
index 0ad477634..c7a77bcfd 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
@@ -27,13 +27,12 @@
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.tests.TearDownGlide;
 import com.bumptech.glide.tests.Util.ReturnsSelfAnswer;
 import com.bumptech.glide.util.Util;
-import com.google.common.testing.EqualsTester;
 import java.nio.ByteBuffer;
-import java.util.UUID;
-import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.InOrder;
@@ -46,12 +45,13 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class GifFrameLoaderTest {
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
 
-  @Mock GifFrameLoader.FrameCallback callback;
-  @Mock GifDecoder gifDecoder;
-  @Mock Handler handler;
-  @Mock Transformation<Bitmap> transformation;
-  @Mock RequestManager requestManager;
+  @Mock private GifFrameLoader.FrameCallback callback;
+  @Mock private GifDecoder gifDecoder;
+  @Mock private Handler handler;
+  @Mock private Transformation<Bitmap> transformation;
+  @Mock private RequestManager requestManager;
   private GifFrameLoader loader;
   private RequestBuilder<Bitmap> requestBuilder;
   private Bitmap firstFrame;
@@ -72,15 +72,10 @@ public void setUp() {
     loader = createGifFrameLoader(handler);
   }
 
-  @After
-  public void tearDown() {
-    Glide.tearDown();
-  }
-
   @NonNull
   private GifFrameLoader createGifFrameLoader(Handler handler) {
     Glide glide = getGlideSingleton();
-    return new GifFrameLoader(
+    GifFrameLoader result = new GifFrameLoader(
         glide.getBitmapPool(),
         requestManager,
         gifDecoder,
@@ -88,6 +83,8 @@ private GifFrameLoader createGifFrameLoader(Handler handler) {
         requestBuilder,
         transformation,
         firstFrame);
+    result.subscribe(callback);
+    return result;
   }
 
   private static Glide getGlideSingleton() {
@@ -97,10 +94,11 @@ private static Glide getGlideSingleton() {
   @SuppressWarnings("unchecked")
   @Test
   public void testSetFrameTransformationSetsTransformationOnRequestBuilder() {
+    verify(requestBuilder, times(2)).apply(isA(RequestOptions.class));
     Transformation<Bitmap> transformation = mock(Transformation.class);
     loader.setFrameTransformation(transformation, firstFrame);
 
-    verify(requestBuilder, times(2)).apply(isA(RequestOptions.class));
+    verify(requestBuilder, times(3)).apply(isA(RequestOptions.class));
   }
 
   @Test(expected = NullPointerException.class)
@@ -117,15 +115,11 @@ public void testReturnsSizeFromGifDecoderAndCurrentFrame() {
 
   @Test
   public void testStartGetsNextFrameIfNotStartedAndWithNoLoadPending() {
-    loader.subscribe(callback);
-
     verify(requestBuilder).into(aTarget());
   }
 
   @Test
   public void testGetNextFrameIncrementsSignatureAndAdvancesDecoderBeforeStartingLoad() {
-    loader.subscribe(callback);
-
     InOrder order = inOrder(gifDecoder, requestBuilder);
     order.verify(gifDecoder).advance();
     order.verify(requestBuilder).apply(isA(RequestOptions.class));
@@ -149,7 +143,6 @@ public void testGetCurrentFrameReturnsCurrentBitmapAfterLoadHasCompleted() {
 
   @Test
   public void testStartDoesNotStartIfAlreadyRunning() {
-    loader.subscribe(callback);
     loader.subscribe(mock(FrameCallback.class));
 
     verify(requestBuilder, times(1)).into(aTarget());
@@ -157,14 +150,15 @@ public void testStartDoesNotStartIfAlreadyRunning() {
 
   @Test
   public void testGetNextFrameDoesNotStartLoadIfLoaderIsNotRunning() {
+    verify(requestBuilder, times(1)).into(aTarget());
+    loader.unsubscribe(callback);
     loader.onFrameReady(mock(DelayTarget.class));
 
-    verify(requestBuilder, never()).into(aTarget());
+    verify(requestBuilder, times(1)).into(aTarget());
   }
 
   @Test
   public void testGetNextFrameDoesNotStartLoadIfLoadIsInProgress() {
-    loader.subscribe(callback);
     loader.unsubscribe(callback);
     loader.subscribe(callback);
 
@@ -173,7 +167,6 @@ public void testGetNextFrameDoesNotStartLoadIfLoadIsInProgress() {
 
   @Test
   public void testGetNextFrameDoesStartLoadIfRestartedAndNoLoadIsInProgress() {
-    loader.subscribe(callback);
     loader.unsubscribe(callback);
 
     loader.onFrameReady(mock(DelayTarget.class));
@@ -184,7 +177,6 @@ public void testGetNextFrameDoesStartLoadIfRestartedAndNoLoadIsInProgress() {
 
   @Test
   public void testGetNextFrameDoesStartLoadAfterLoadCompletesIfStarted() {
-    loader.subscribe(callback);
     loader.onFrameReady(mock(DelayTarget.class));
 
     verify(requestBuilder, times(2)).into(aTarget());
@@ -272,11 +264,94 @@ public void testClearsCompletedLoadOnFrameReadyIfCleared() {
   }
 
   @Test
-  public void testFrameSignatureEquality() {
-    UUID first = UUID.randomUUID();
-    new EqualsTester().addEqualityGroup(new GifFrameLoader.FrameSignature(first),
-        new GifFrameLoader.FrameSignature(first))
-        .addEqualityGroup(new GifFrameLoader.FrameSignature()).testEquals();
+  public void onFrameReady_whenNotRunning_doesNotClearPreviouslyLoadedImage() {
+    loader = createGifFrameLoader(/*handler=*/ null);
+    DelayTarget loaded = mock(DelayTarget.class);
+    when(loaded.getResource()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    loader.onFrameReady(loaded);
+    loader.unsubscribe(callback);
+
+    DelayTarget nextFrame = mock(DelayTarget.class);
+    when(nextFrame.getResource())
+        .thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    loader.onFrameReady(nextFrame);
+    verify(requestManager, never()).clear(loaded);
+  }
+
+  @Test
+  public void onFrameReady_whenNotRunning_clearsPendingFrameOnClear() {
+    loader = createGifFrameLoader(/*handler=*/ null);
+    DelayTarget loaded = mock(DelayTarget.class);
+    when(loaded.getResource()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    loader.onFrameReady(loaded);
+    loader.unsubscribe(callback);
+
+    DelayTarget nextFrame = mock(DelayTarget.class);
+    when(nextFrame.getResource())
+        .thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    loader.onFrameReady(nextFrame);
+
+    loader.clear();
+    verify(requestManager).clear(loaded);
+    verify(requestManager).clear(nextFrame);
+  }
+
+  @Test
+  public void onFrameReady_whenNotRunning_clearsOldFrameOnStart() {
+    loader = createGifFrameLoader(/*handler=*/ null);
+    DelayTarget loaded = mock(DelayTarget.class);
+    when(loaded.getResource()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    loader.onFrameReady(loaded);
+    loader.unsubscribe(callback);
+
+    DelayTarget nextFrame = mock(DelayTarget.class);
+    when(nextFrame.getResource())
+        .thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    loader.onFrameReady(nextFrame);
+
+    loader.subscribe(callback);
+    verify(requestManager).clear(loaded);
+  }
+
+  @Test
+  public void onFrameReady_whenNotRunning_callsFrameReadyWithNewFrameOnStart() {
+    loader = createGifFrameLoader(/*handler=*/ null);
+    DelayTarget loaded = mock(DelayTarget.class);
+    when(loaded.getResource()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    loader.onFrameReady(loaded);
+    loader.unsubscribe(callback);
+
+    DelayTarget nextFrame = mock(DelayTarget.class);
+    Bitmap expected = Bitmap.createBitmap(200, 200, Bitmap.Config.ARGB_8888);
+    when(nextFrame.getResource())
+        .thenReturn(expected);
+    loader.onFrameReady(nextFrame);
+
+    verify(callback, times(1)).onFrameReady();
+    loader.subscribe(callback);
+    verify(callback, times(2)).onFrameReady();
+    assertThat(loader.getCurrentFrame()).isEqualTo(expected);
+  }
+
+  @Test
+  public void startFromFirstFrame_withPendingFrame_clearsPendingFrame() {
+    loader = createGifFrameLoader(/*handler=*/ null);
+    DelayTarget loaded = mock(DelayTarget.class);
+    when(loaded.getResource()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    loader.onFrameReady(loaded);
+    loader.unsubscribe(callback);
+
+    DelayTarget nextFrame = mock(DelayTarget.class);
+    Bitmap expected = Bitmap.createBitmap(200, 200, Bitmap.Config.ARGB_8888);
+    when(nextFrame.getResource())
+        .thenReturn(expected);
+    loader.onFrameReady(nextFrame);
+
+    loader.setNextStartFromFirstFrame();
+    verify(requestManager).clear(nextFrame);
+
+    loader.subscribe(callback);
+    verify(callback, times(1)).onFrameReady();
   }
 
   @SuppressWarnings("unchecked")
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java
similarity index 88%
rename from library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java
index 18c379433..59d3cfb09 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java
@@ -9,6 +9,7 @@
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.util.Preconditions;
 import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
@@ -35,7 +36,9 @@ public void testReturnsFrameFromGifDecoder() throws IOException {
     Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
     when(gifDecoder.getNextFrame()).thenReturn(expected);
 
-    assertEquals(expected, resourceDecoder.decode(gifDecoder, 100, 100, options).get());
+    assertEquals(
+        expected,
+        Preconditions.checkNotNull(resourceDecoder.decode(gifDecoder, 100, 100, options)).get());
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
similarity index 88%
rename from library/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
index f6d4eba4c..f50eaf075 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
@@ -25,8 +25,7 @@
 public class StreamGifDecoderTest {
   private static final byte[] GIF_HEADER = new byte[] { 0x47, 0x49, 0x46 };
 
-  @Mock
-  ResourceDecoder<ByteBuffer, GifDrawable> byteBufferDecoder;
+  @Mock private ResourceDecoder<ByteBuffer, GifDrawable> byteBufferDecoder;
   private StreamGifDecoder decoder;
   private Options options;
 
@@ -34,7 +33,7 @@
   public void setUp() {
     MockitoAnnotations.initMocks(this);
 
-    List<ImageHeaderParser> parsers = new ArrayList<ImageHeaderParser>();
+    List<ImageHeaderParser> parsers = new ArrayList<>();
     parsers.add(new DefaultImageHeaderParser());
 
     decoder = new StreamGifDecoder(parsers, byteBufferDecoder, new LruArrayPool());
@@ -53,13 +52,13 @@ public void testHandlesStreamIfContainsGifHeaderAndDisabledIsNotSet() throws IOE
 
   @Test
   public void testHandlesStreamIfContainsGifHeaderAndDisabledIsFalse() throws IOException {
-    options.set(StreamGifDecoder.DISABLE_ANIMATION, false);
+    options.set(GifOptions.DISABLE_ANIMATION, false);
     assertThat(decoder.handles(new ByteArrayInputStream(GIF_HEADER), options)).isTrue();
   }
 
   @Test
   public void testDoesNotHandleStreamIfDisabled() throws IOException {
-    options.set(StreamGifDecoder.DISABLE_ANIMATION, true);
+    options.set(GifOptions.DISABLE_ANIMATION, true);
     assertThat(decoder.handles(new ByteArrayInputStream(GIF_HEADER), options)).isFalse();
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
similarity index 83%
rename from library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
index 9d8e2b1b1..866b3ff70 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
@@ -6,7 +6,9 @@
 import static org.mockito.Mockito.when;
 
 import android.graphics.Bitmap;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
+import java.nio.charset.Charset;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -57,19 +59,20 @@ public void testBitmapResourceIsRecycled() {
     Bitmap.CompressFormat compressFormat = Bitmap.CompressFormat.JPEG;
     int quality = 100;
     final String description = "TestDescription";
-    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ALPHA_8);
-    Resource<Bitmap> bitmapResource = mockResource();
+    final Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ALPHA_8);
+    final Resource<Bitmap> bitmapResource = mockResource();
+    final Options options = new Options();
 
-    public BitmapBytesTranscoderHarness() {
+    BitmapBytesTranscoderHarness() {
       when(bitmapResource.get()).thenReturn(bitmap);
       Shadows.shadowOf(bitmap).setDescription(description);
     }
 
-    public String getTranscodedDescription() {
+    String getTranscodedDescription() {
       BitmapBytesTranscoder transcoder = new BitmapBytesTranscoder(compressFormat, quality);
-      Resource<byte[]> bytesResource = transcoder.transcode(bitmapResource);
+      Resource<byte[]> bytesResource = transcoder.transcode(bitmapResource, options);
 
-      return new String(bytesResource.get());
+      return new String(bytesResource.get(), Charset.defaultCharset());
     }
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java
similarity index 87%
rename from library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java
index 62689518a..b3c195657 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java
@@ -2,13 +2,12 @@
 
 import static com.bumptech.glide.tests.Util.mockResource;
 import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -23,8 +22,7 @@
 
   @Before
   public void setUp() {
-    transcoder = new BitmapDrawableTranscoder(RuntimeEnvironment.application.getResources(),
-        mock(BitmapPool.class));
+    transcoder = new BitmapDrawableTranscoder(RuntimeEnvironment.application.getResources());
   }
 
   @Test
@@ -33,7 +31,7 @@ public void testReturnsBitmapDrawableResourceContainingGivenBitmap() {
     Resource<Bitmap> resource = mockResource();
     when(resource.get()).thenReturn(expected);
 
-    Resource<BitmapDrawable> transcoded = transcoder.transcode(resource);
+    Resource<BitmapDrawable> transcoded = transcoder.transcode(resource, new Options());
 
     assertEquals(expected, transcoded.get().getBitmap());
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
similarity index 87%
rename from library/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
index 1f6d4fd8f..fc1c7777c 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
@@ -5,9 +5,11 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 import java.nio.ByteBuffer;
+import java.nio.charset.Charset;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -30,10 +32,10 @@ public void setUp() {
   @Test
   public void testReturnsBytesOfGivenGifDrawable() {
     for (String fakeData : new String[] { "test", "1235asfklaw3", "@$@#" }) {
-      ByteBuffer expected = ByteBuffer.wrap(fakeData.getBytes());
+      ByteBuffer expected = ByteBuffer.wrap(fakeData.getBytes(Charset.defaultCharset()));
       when(gifDrawable.getBuffer()).thenReturn(expected);
 
-      Resource<byte[]> transcoded = transcoder.transcode(resource);
+      Resource<byte[]> transcoded = transcoder.transcode(resource, new Options());
 
       assertArrayEquals(expected.array(), transcoded.get());
     }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java
similarity index 81%
rename from library/src/test/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java
index a1d8eb507..0c8713cf2 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java
@@ -3,6 +3,7 @@
 import static com.bumptech.glide.tests.Util.mockResource;
 import static org.junit.Assert.assertEquals;
 
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -16,6 +17,6 @@ public void testReturnsTheGivenResource() {
     Resource<Object> resource = mockResource();
     ResourceTranscoder<Object, Object> unitTranscoder = UnitTranscoder.get();
 
-    assertEquals(resource, unitTranscoder.transcode(resource));
+    assertEquals(resource, unitTranscoder.transcode(resource, new Options()));
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactoryTest.java b/library/test/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactoryTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactoryTest.java
rename to library/test/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactoryTest.java
diff --git a/library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java b/library/test/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
similarity index 61%
rename from library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
rename to library/test/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
index 32fa7111b..930a9f34e 100644
--- a/library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
@@ -3,7 +3,6 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.mockito.Matchers.anyBoolean;
 import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 
@@ -12,28 +11,36 @@
 import android.content.Intent;
 import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
+import com.bumptech.glide.manager.DefaultConnectivityMonitorTest.PermissionConnectivityManager;
 import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
-import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowApplication;
 import org.robolectric.shadows.ShadowConnectivityManager;
 import org.robolectric.shadows.ShadowNetworkInfo;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(manifest = Config.NONE, sdk = 18, shadows = PermissionConnectivityManager.class)
 public class DefaultConnectivityMonitorTest {
-  private ConnectivityMonitor.ConnectivityListener listener;
+  @Mock private ConnectivityMonitor.ConnectivityListener listener;
   private DefaultConnectivityMonitor monitor;
+  private ConnectivityHarness harness;
+
 
   @Before
   public void setUp() {
-    listener = mock(ConnectivityMonitor.ConnectivityListener.class);
+    MockitoAnnotations.initMocks(this);
     monitor = new DefaultConnectivityMonitor(RuntimeEnvironment.application, listener);
+    harness = new ConnectivityHarness();
   }
 
   @Test
@@ -69,7 +76,6 @@ public void testHandlesUnregisteringTwiceInARow() {
 
   @Test
   public void testDoesNotNotifyListenerIfConnectedAndBecomesConnected() {
-    ConnectivityHarness harness = new ConnectivityHarness();
     harness.connect();
 
     monitor.onStart();
@@ -80,7 +86,6 @@ public void testDoesNotNotifyListenerIfConnectedAndBecomesConnected() {
 
   @Test
   public void testNotifiesListenerIfConnectedAndBecomesDisconnected() {
-    ConnectivityHarness harness = new ConnectivityHarness();
     harness.connect();
 
     monitor.onStart();
@@ -92,7 +97,6 @@ public void testNotifiesListenerIfConnectedAndBecomesDisconnected() {
 
   @Test
   public void testNotifiesListenerIfDisconnectedAndBecomesConnected() {
-    ConnectivityHarness harness = new ConnectivityHarness();
     harness.disconnect();
 
     monitor.onStart();
@@ -104,7 +108,6 @@ public void testNotifiesListenerIfDisconnectedAndBecomesConnected() {
 
   @Test
   public void testDoesNotNotifyListenerWhenNotRegistered() {
-    ConnectivityHarness harness = new ConnectivityHarness();
     harness.disconnect();
 
     monitor.onStart();
@@ -115,33 +118,81 @@ public void testDoesNotNotifyListenerWhenNotRegistered() {
     verify(listener, never()).onConnectivityChanged(anyBoolean());
   }
 
+  @Test
+  public void register_withMissingPermission_doesNotThrow() {
+    harness.shadowConnectivityManager.isNetworkPermissionGranted = false;
+
+    monitor.onStart();
+  }
+
+  @Test
+  public void onReceive_withMissingPermission_doesNotThrow() {
+    monitor.onStart();
+    harness.shadowConnectivityManager.isNetworkPermissionGranted = false;
+    harness.broadcast();
+  }
+
+  @Test
+  public void onReceive_withMissingPermission_previouslyDisconnected_notifiesListenersConnected() {
+    harness.disconnect();
+    monitor.onStart();
+    harness.shadowConnectivityManager.isNetworkPermissionGranted = false;
+    harness.broadcast();
+
+    verify(listener).onConnectivityChanged(true);
+  }
+
+  @Test
+  public void onReceive_withMissingPermission_previouslyConnected_doesNotNotifyListeners() {
+    harness.connect();
+    monitor.onStart();
+    harness.shadowConnectivityManager.isNetworkPermissionGranted = false;
+    harness.broadcast();
+
+    verify(listener, never()).onConnectivityChanged(anyBoolean());
+  }
+
   private List<BroadcastReceiver> getConnectivityReceivers() {
     Intent connectivity = new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
     return ShadowApplication.getInstance().getReceiversForIntent(connectivity);
   }
 
   private static class ConnectivityHarness {
-    private final ShadowConnectivityManager shadowConnectivityManager;
+    private final PermissionConnectivityManager shadowConnectivityManager;
 
     public ConnectivityHarness() {
       ConnectivityManager connectivityManager = (ConnectivityManager) RuntimeEnvironment.application
           .getSystemService(Context.CONNECTIVITY_SERVICE);
-      shadowConnectivityManager = Shadows.shadowOf(connectivityManager);
+      shadowConnectivityManager = Shadow.extract(connectivityManager);
     }
 
-    public void disconnect() {
+    void disconnect() {
       shadowConnectivityManager.setActiveNetworkInfo(null);
     }
 
-    public void connect() {
+    void connect() {
       NetworkInfo networkInfo =
           ShadowNetworkInfo.newInstance(NetworkInfo.DetailedState.CONNECTED, 0, 0, true, true);
       shadowConnectivityManager.setActiveNetworkInfo(networkInfo);
     }
 
-    public void broadcast() {
+    void broadcast() {
       Intent connected = new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
       ShadowApplication.getInstance().sendBroadcast(connected);
     }
   }
+
+  @Implements(ConnectivityManager.class)
+  public static final class PermissionConnectivityManager extends ShadowConnectivityManager {
+    private boolean isNetworkPermissionGranted = true;
+
+    @Implementation
+    @Override
+    public NetworkInfo getActiveNetworkInfo() {
+      if (!isNetworkPermissionGranted) {
+        throw new SecurityException();
+      }
+      return super.getActiveNetworkInfo();
+    }
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/manager/Issue117Activity.java b/library/test/src/test/java/com/bumptech/glide/manager/Issue117Activity.java
similarity index 85%
rename from library/src/test/java/com/bumptech/glide/manager/Issue117Activity.java
rename to library/test/src/test/java/com/bumptech/glide/manager/Issue117Activity.java
index 570026f5d..60c59027d 100644
--- a/library/src/test/java/com/bumptech/glide/manager/Issue117Activity.java
+++ b/library/test/src/test/java/com/bumptech/glide/manager/Issue117Activity.java
@@ -2,10 +2,11 @@
 
 import static android.view.ViewGroup.LayoutParams.MATCH_PARENT;
 
-import android.annotation.TargetApi;
 import android.content.Context;
 import android.os.Build;
 import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.RequiresApi;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
 import android.support.v4.app.FragmentManager;
@@ -20,7 +21,7 @@
 /**
  * A test activity to reproduce Issue #117: https://github.com/bumptech/glide/issues/117.
  */
-@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+@RequiresApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
 class Issue117Activity extends FragmentActivity {
   @Override
   protected void onCreate(Bundle savedInstanceState) {
@@ -33,7 +34,7 @@ protected void onCreate(Bundle savedInstanceState) {
 
   private static class Issue117Adapter extends FragmentPagerAdapter {
 
-    public Issue117Adapter(FragmentManager fm) {
+    Issue117Adapter(FragmentManager fm) {
       super(fm);
     }
 
@@ -50,8 +51,8 @@ public int getCount() {
 
   public static class Issue117Fragment extends Fragment {
     @Override
-    public View onCreateView(LayoutInflater inflater, ViewGroup container,
-        Bundle savedInstanceState) {
+    public View onCreateView(
+        @NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
       return new Issue117ImageView(getActivity());
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/manager/LifecycleTest.java b/library/test/src/test/java/com/bumptech/glide/manager/LifecycleTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/manager/LifecycleTest.java
rename to library/test/src/test/java/com/bumptech/glide/manager/LifecycleTest.java
diff --git a/library/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java b/library/test/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
similarity index 97%
rename from library/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
rename to library/test/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
index 709573fed..191f02309 100644
--- a/library/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
@@ -129,7 +129,7 @@ private void runTest(TestCase testCase) {
   }
 
   private interface TestCase {
-    public void runTest(Harness harness);
+    void runTest(Harness harness);
   }
 
   private interface Harness {
@@ -145,9 +145,10 @@ private void runTest(TestCase testCase) {
 
     void onLowMemory();
 
-    void onTrimMemory(int level);
+    void onTrimMemory(@SuppressWarnings("SameParameterValue") int level);
   }
 
+  @SuppressWarnings("deprecation")
   private static class RequestManagerHarness implements Harness {
     private final ActivityController<Activity> controller;
     private final RequestManagerFragment fragment;
diff --git a/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java b/library/test/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
similarity index 95%
rename from library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
rename to library/test/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
index 97884942a..dd07da813 100644
--- a/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
@@ -9,20 +9,22 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
-import android.annotation.TargetApi;
 import android.app.Activity;
 import android.content.Context;
 import android.content.ContextWrapper;
 import android.os.Build;
 import android.os.Looper;
+import android.support.annotation.RequiresApi;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
 import com.bumptech.glide.RequestManager;
-import com.bumptech.glide.tests.BackgroundUtil;
+import com.bumptech.glide.tests.BackgroundUtil.BackgroundTester;
 import com.bumptech.glide.tests.GlideShadowLooper;
+import com.bumptech.glide.tests.TearDownGlide;
 import com.bumptech.glide.tests.Util;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mockito;
@@ -36,6 +38,8 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = GlideShadowLooper.class)
 public class RequestManagerRetrieverTest {
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+
   private static final String PARENT_TAG = "parent";
   private RetrieverHarness[] harnesses;
   private RequestManagerRetriever retriever;
@@ -130,6 +134,7 @@ public void testSupportCanGetRequestManagerFromActivity() {
     assertEquals(manager, retriever.get(fragmentActivity));
   }
 
+  @SuppressWarnings("deprecation")
   @Test
   public void testCanGetRequestManagerFromFragment() {
     Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
@@ -164,6 +169,7 @@ public void testCanGetRequestManagerFromDetachedFragment_PreJellyBeanMr1() {
     helpTestCanGetRequestManagerFromDetachedFragment();
   }
 
+  @SuppressWarnings("deprecation")
   private void helpTestCanGetRequestManagerFromDetachedFragment() {
     Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
     android.app.Fragment fragment = new android.app.Fragment();
@@ -198,6 +204,7 @@ private void helpTestSupportCanGetRequestManagerFromDetachedFragment() {
     retriever.get(fragment);
   }
 
+  @SuppressWarnings("deprecation")
   @Test(expected = IllegalArgumentException.class)
   public void testThrowsIfFragmentNotAttached() {
     android.app.Fragment fragment = new android.app.Fragment();
@@ -284,9 +291,9 @@ public void testApplicationRequestManagerIsNotReResumedAfterFirstRetrieval() {
   @Test
   public void testDoesNotThrowWhenGetWithContextCalledFromBackgroundThread()
       throws InterruptedException {
-    testInBackground(new BackgroundUtil.BackgroundTester() {
+    testInBackground(new BackgroundTester() {
       @Override
-      public void runTest() throws Exception {
+      public void runTest() {
         retriever.get(RuntimeEnvironment.application);
       }
     });
@@ -305,7 +312,7 @@ public void testCanCallGetInOnAttachToWindowInFragmentInViewPager() {
   }
 
   @Test
-  @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+  @RequiresApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
   public void testDoesNotThrowIfAskedToGetManagerForActivityPreJellYBeanMr1() {
     Util.setSdkVersionInt(Build.VERSION_CODES.JELLY_BEAN);
     Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
@@ -315,8 +322,9 @@ public void testDoesNotThrowIfAskedToGetManagerForActivityPreJellYBeanMr1() {
     assertNotNull(retriever.get(spyActivity));
   }
 
+  @SuppressWarnings("deprecation")
   @Test
-  @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+  @RequiresApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
   public void testDoesNotThrowIfAskedToGetManagerForFragmentPreJellyBeanMr1() {
     Util.setSdkVersionInt(Build.VERSION_CODES.JELLY_BEAN);
     Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
@@ -339,12 +347,12 @@ public void testDoesNotThrowIfAskedToGetManagerForFragmentPreJellyBeanMr1() {
     void addFragmentWithTag(String tag, RequestManager manager);
   }
 
-  public class DefaultRetrieverHarness implements RetrieverHarness {
+  final class DefaultRetrieverHarness implements RetrieverHarness {
     private final ActivityController<Activity> controller =
         Robolectric.buildActivity(Activity.class);
     private final android.app.Fragment parent;
 
-    public DefaultRetrieverHarness() {
+    DefaultRetrieverHarness() {
       this.parent = new android.app.Fragment();
 
       controller.create();
@@ -372,6 +380,7 @@ public boolean hasFragmentWithTag(String tag) {
           .findFragmentByTag(RequestManagerRetriever.FRAGMENT_TAG);
     }
 
+    @SuppressWarnings("deprecation")
     @Override
     public void addFragmentWithTag(String tag, RequestManager requestManager) {
       RequestManagerFragment fragment = new RequestManagerFragment();
diff --git a/library/test/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java b/library/test/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
new file mode 100644
index 000000000..605683c8a
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
@@ -0,0 +1,483 @@
+package com.bumptech.glide.manager;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import com.bumptech.glide.request.Request;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.MockitoAnnotations;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class RequestTrackerTest {
+  private RequestTracker tracker;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    tracker = new RequestTracker();
+  }
+
+  @Test
+  public void clearRequests_doesNotRecycleRequests() {
+    FakeRequest request = new FakeRequest();
+    tracker.addRequest(request);
+
+    tracker.clearRequests();
+
+    assertThat(request.isCleared()).isTrue();
+    assertThat(request.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void clearRemoveAndRecycle_withRequestPreviouslyClearedInClearRequests_doesNothing() {
+    FakeRequest request = new FakeRequest();
+    tracker.addRequest(request);
+
+    tracker.clearRequests();
+    tracker.clearRemoveAndRecycle(request);
+
+    assertThat(request.isCleared()).isTrue();
+    assertThat(request.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void clearRemoveAndRecycle_withNullRequest_doesNothingAndReturnsTrue() {
+    assertThat(tracker.clearRemoveAndRecycle(null)).isTrue();
+  }
+
+  @Test
+  public void clearRemoveAndRecycle_withUnTrackedRequest_doesNothingAndReturnsFalse() {
+    FakeRequest request = new FakeRequest();
+
+    assertThat(tracker.clearRemoveAndRecycle(request)).isFalse();
+
+    assertThat(request.isCleared()).isFalse();
+    assertThat(request.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void clearRemoveAndRecycle_withTrackedRequest_clearsRecyclesAndReturnsTrue() {
+    FakeRequest request = new FakeRequest();
+    tracker.addRequest(request);
+
+    assertThat(tracker.clearRemoveAndRecycle(request)).isTrue();
+    assertThat(request.isCleared()).isTrue();
+    assertThat(request.isRecycled()).isTrue();
+  }
+
+  @Test
+  public void clearRemoveAndRecycle_withAlreadyRemovedRequest_doesNothingAndReturnsFalse() {
+    FakeRequest request = new FakeRequest();
+    tracker.addRequest(request);
+    tracker.clearRemoveAndRecycle(request);
+    assertThat(tracker.clearRemoveAndRecycle(request)).isFalse();
+
+    assertThat(request.isCleared()).isTrue();
+    assertThat(request.isRecycled()).isTrue();
+  }
+
+  @Test
+  public void clearRequests_withPreviouslyClearedRequest_doesNotClearRequestAgain() {
+    FakeRequest request = new FakeRequest();
+    tracker.addRequest(request);
+    tracker.clearRemoveAndRecycle(request);
+
+    tracker.clearRequests();
+
+    assertThat(request.isCleared()).isTrue();
+  }
+
+  @Test
+  public void clearRequests_withMultipleRequests_clearsAllRequests() {
+    FakeRequest first = new FakeRequest();
+    FakeRequest second = new FakeRequest();
+    tracker.addRequest(first);
+    tracker.addRequest(second);
+
+    tracker.clearRequests();
+
+    assertThat(first.isCleared()).isTrue();
+    assertThat(second.isCleared()).isTrue();
+  }
+
+  @Test
+  public void pauseRequest_withRunningRequest_pausesRequest() {
+    FakeRequest request = new FakeRequest();
+    request.setIsRunning();
+    tracker.addRequest(request);
+
+    tracker.pauseRequests();
+
+    assertThat(request.isCleared()).isTrue();
+  }
+
+  @Test
+  public void pauseRequests_withCompletedRequest_doesNotClearRequest() {
+    FakeRequest request = new FakeRequest();
+    tracker.addRequest(request);
+
+    request.setIsComplete();
+    tracker.pauseRequests();
+
+    assertThat(request.isCleared()).isFalse();
+  }
+
+  @Test
+  public void runRequest_startsRequest() {
+    FakeRequest request = new FakeRequest();
+    tracker.runRequest(request);
+
+    assertThat(request.isRunning()).isTrue();
+  }
+
+  @Test
+  public void runRequest_whenPaused_doesNotStartRequest() {
+    FakeRequest request = new FakeRequest();
+    tracker.pauseRequests();
+    tracker.runRequest(request);
+
+    assertThat(request.isRunning()).isFalse();
+  }
+
+  @Test
+  public void runRequest_withAllRequestsPaused_doesNotStartRequest() {
+    FakeRequest request = new FakeRequest();
+    tracker.pauseAllRequests();
+    tracker.runRequest(request);
+
+    assertThat(request.isRunning()).isFalse();
+  }
+
+  @Test
+  public void runRequest_afterPausingAndResuming_startsRequest() {
+    FakeRequest request = new FakeRequest();
+    tracker.pauseRequests();
+    tracker.runRequest(request);
+    tracker.resumeRequests();
+
+    assertThat(request.isRunning()).isTrue();
+  }
+
+  @Test
+  public void pauseRequests_withFailedRequest_doesNotClearRequest() {
+    FakeRequest request = new FakeRequest();
+    request.setIsFailed();
+    tracker.addRequest(request);
+
+    tracker.pauseRequests();
+
+    assertThat(request.isCleared()).isFalse();
+  }
+
+  @Test
+  public void resumeRequests_withRequestAddedWhilePaused_startsRequest() {
+    FakeRequest request = new FakeRequest();
+    tracker.addRequest(request);
+
+    tracker.resumeRequests();
+
+    assertThat(request.isRunning()).isTrue();
+  }
+
+  @Test
+  public void resumeRequests_withCompletedRequest_doesNotRestartCompletedRequest() {
+    FakeRequest request = new FakeRequest();
+    request.setIsComplete();
+    tracker.addRequest(request);
+
+    tracker.resumeRequests();
+
+    assertThat(request.isRunning()).isFalse();
+  }
+
+  @Test
+  public void resumeRequests_withFailedRequest_restartsRequest() {
+    FakeRequest request = new FakeRequest();
+    request.setIsFailed();
+    tracker.addRequest(request);
+
+    tracker.resumeRequests();
+
+    assertThat(request.isRunning()).isTrue();
+  }
+
+  @Test
+  public void addRequest_withRunningRequest_doesNotRestartRequest() {
+    FakeRequest request = new FakeRequest();
+    request.setIsRunning();
+    tracker.addRequest(request);
+
+    tracker.resumeRequests();
+
+    assertThat(request.isRunning()).isTrue();
+  }
+
+  @Test
+  public void resumeRequests_withRequestThatClearsAnotherRequest_avoidsConcurrentModifications() {
+    Request first = mock(Request.class);
+    Request second = mock(Request.class);
+
+    doAnswer(new ClearAndRemoveRequest(second)).when(first).begin();
+
+    tracker.addRequest(mock(Request.class));
+    tracker.addRequest(first);
+    tracker.addRequest(second);
+
+    tracker.resumeRequests();
+  }
+
+  @Test
+  public void pauseRequests_withRequestThatClearsAnother_avoidsConcurrentModifications() {
+    Request first = mock(Request.class);
+    Request second = mock(Request.class);
+
+    when(first.isRunning()).thenReturn(true);
+    doAnswer(new ClearAndRemoveRequest(second)).when(first).clear();
+
+    tracker.addRequest(mock(Request.class));
+    tracker.addRequest(first);
+    tracker.addRequest(second);
+
+    tracker.pauseRequests();
+  }
+
+  @Test
+  public void clearRequests_withRequestThatClearsAnother_avoidsConcurrentModifications() {
+    Request first = mock(Request.class);
+    Request second = mock(Request.class);
+
+    doAnswer(new ClearAndRemoveRequest(second)).when(first).clear();
+
+    tracker.addRequest(mock(Request.class));
+    tracker.addRequest(first);
+    tracker.addRequest(second);
+
+    tracker.clearRequests();
+  }
+
+  @Test
+  public void restartRequests_withRequestThatClearsAnother_avoidsConcurrentModifications() {
+    Request first = mock(Request.class);
+    Request second = mock(Request.class);
+
+    doAnswer(new ClearAndRemoveRequest(second)).when(first).clear();
+
+    tracker.addRequest(mock(Request.class));
+    tracker.addRequest(first);
+    tracker.addRequest(second);
+
+    tracker.restartRequests();
+  }
+
+  @Test
+  public void restartRequests_withFailedRequest_restartsRequest() {
+    FakeRequest request = new FakeRequest();
+    request.setIsFailed();
+    tracker.addRequest(request);
+
+    tracker.restartRequests();
+
+    assertThat(request.isRunning()).isTrue();
+  }
+
+  @Test
+  public void restartRequests_withIncompleteRequest_restartsRequest() {
+    FakeRequest request = new FakeRequest();
+    tracker.addRequest(request);
+
+    tracker.restartRequests();
+
+    assertThat(request.isRunning()).isTrue();
+  }
+
+  @Test
+  public void restartRequests_whenPaused_doesNotRestartRequests() {
+    FakeRequest request = new FakeRequest();
+    request.setIsFailed();
+    tracker.pauseRequests();
+    tracker.addRequest(request);
+
+    tracker.restartRequests();
+
+    assertThat(request.isRunning()).isFalse();
+  }
+
+  @Test
+  public void restartRequests_withFailedRequestAddedWhilePaused_clearsFailedRequest() {
+    FakeRequest request = new FakeRequest();
+    request.setIsFailed();
+
+    tracker.pauseRequests();
+    tracker.addRequest(request);
+
+    tracker.restartRequests();
+    assertThat(request.isCleared()).isTrue();
+  }
+
+  @Test
+  public void restartRequests_withIncompleteRequestAddedWhilePaused_doesNotRestartRequest() {
+    FakeRequest request = new FakeRequest();
+
+    tracker.pauseRequests();
+    tracker.addRequest(request);
+    tracker.restartRequests();
+
+    assertThat(request.isRunning()).isFalse();
+  }
+
+  @Test
+  public void restartRequests_withIncompleteRequestAddedWhilePaused_clearsRequestOnRestart() {
+    FakeRequest request = new FakeRequest();
+
+    tracker.pauseRequests();
+    tracker.addRequest(request);
+    tracker.restartRequests();
+
+    assertThat(request.isCleared()).isTrue();
+  }
+
+  @Test
+  public void testReturnsTrueFromIsPausedWhenPaused() {
+    tracker.pauseRequests();
+    assertTrue(tracker.isPaused());
+  }
+
+  @Test
+  public void testReturnsFalseFromIsPausedWhenResumed() {
+    tracker.resumeRequests();
+    assertFalse(tracker.isPaused());
+  }
+
+  @Test
+  public void testPauseAllRequests_returnsTrueFromIsPaused() {
+    tracker.pauseAllRequests();
+    assertTrue(tracker.isPaused());
+  }
+
+  @Test
+  public void resumeRequests_afterRequestIsPausedViaPauseAllRequests_resumesRequest() {
+    FakeRequest request = new FakeRequest();
+    request.setIsComplete();
+
+    tracker.addRequest(request);
+    tracker.pauseAllRequests();
+
+    assertThat(request.isCleared()).isTrue();
+
+    // reset complete status.
+    request.setIsComplete(false);
+    tracker.resumeRequests();
+
+    assertThat(request.isRunning()).isTrue();
+  }
+
+  private static final class FakeRequest implements Request {
+    private boolean isRunning;
+    private boolean isFailed;
+    private boolean isCleared;
+    private boolean isComplete;
+    private boolean isRecycled;
+
+    void setIsComplete() {
+      setIsComplete(true);
+    }
+
+    void setIsComplete(boolean isComplete) {
+      this.isComplete = isComplete;
+    }
+
+    void setIsFailed() {
+      isFailed = true;
+    }
+
+    void setIsRunning() {
+      isRunning = true;
+    }
+
+    boolean isRecycled() {
+      return isRecycled;
+    }
+
+    @Override
+    public void begin() {
+      if (isRunning) {
+        throw new IllegalStateException();
+      }
+      isRunning = true;
+    }
+
+    @Override
+    public void clear() {
+      if (isCleared) {
+        throw new IllegalStateException();
+      }
+      isRunning = false;
+      isFailed = false;
+      isCleared = true;
+    }
+
+    @Override
+    public boolean isRunning() {
+      return isRunning;
+    }
+
+    @Override
+    public boolean isComplete() {
+      return isComplete;
+    }
+
+    @Override
+    public boolean isResourceSet() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean isCleared() {
+      return isCleared;
+    }
+
+    @Override
+    public boolean isFailed() {
+      return isFailed;
+    }
+
+    @Override
+    public void recycle() {
+      if (isRecycled) {
+        throw new IllegalStateException();
+      }
+      isRecycled = true;
+    }
+
+    @Override
+    public boolean isEquivalentTo(Request other) {
+      throw new UnsupportedOperationException();
+    }
+  }
+
+  private class ClearAndRemoveRequest implements Answer<Void> {
+
+    private final Request toRemove;
+
+    ClearAndRemoveRequest(Request toRemove) {
+      this.toRemove = toRemove;
+    }
+
+    @Override
+    public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
+      tracker.clearRemoveAndRecycle(toRemove);
+      return null;
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/module/ManifestParserTest.java b/library/test/src/test/java/com/bumptech/glide/module/ManifestParserTest.java
similarity index 93%
rename from library/src/test/java/com/bumptech/glide/module/ManifestParserTest.java
rename to library/test/src/test/java/com/bumptech/glide/module/ManifestParserTest.java
index 8725e85b7..698425e22 100644
--- a/library/src/test/java/com/bumptech/glide/module/ManifestParserTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/module/ManifestParserTest.java
@@ -9,6 +9,7 @@
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
 import android.os.Bundle;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
@@ -27,8 +28,7 @@
 public class ManifestParserTest {
   private static final String MODULE_VALUE = "GlideModule";
 
-  @Mock
-  Context context;
+  @Mock private Context context;
   private ManifestParser parser;
   private ApplicationInfo applicationInfo;
 
@@ -111,12 +111,11 @@ private void addToManifest(String key) {
     applicationInfo.metaData.putString(key, MODULE_VALUE);
   }
 
-  public static class InvalidClass {
-  }
+  private static class InvalidClass { }
 
   public static class TestModule1 implements GlideModule {
     @Override
-    public void applyOptions(Context context, GlideBuilder builder) {
+    public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
     }
 
     @Override
@@ -137,7 +136,7 @@ public int hashCode() {
   public static class TestModule2 implements GlideModule {
 
     @Override
-    public void applyOptions(Context context, GlideBuilder builder) {
+    public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
     }
 
     @Override
diff --git a/library/test/src/test/java/com/bumptech/glide/request/ErrorRequestCoordinatorTest.java b/library/test/src/test/java/com/bumptech/glide/request/ErrorRequestCoordinatorTest.java
new file mode 100644
index 000000000..1c8602fad
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/request/ErrorRequestCoordinatorTest.java
@@ -0,0 +1,579 @@
+package com.bumptech.glide.request;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(JUnit4.class)
+public class ErrorRequestCoordinatorTest {
+
+  @Mock private Request primary;
+  @Mock private Request error;
+  @Mock private RequestCoordinator parent;
+  private ErrorRequestCoordinator coordinator;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    coordinator = new ErrorRequestCoordinator(/*parent=*/ null);
+    coordinator.setRequests(primary, error);
+  }
+
+  @Test
+  public void begin_startsPrimary() {
+    coordinator.begin();
+    verify(primary).begin();
+  }
+
+  @Test
+  public void begin_whenPrimaryIsAlreadyRunning_doesNotStartPrimaryAgain() {
+    when(primary.isRunning()).thenReturn(true);
+    coordinator.begin();
+    verify(primary, never()).begin();
+  }
+
+  @Test
+  public void clear_whenPrimaryHasNotFailed_clearsPrimary() {
+    coordinator.clear();
+    verify(primary).clear();
+  }
+
+  @Test
+  public void clear_whenPrimaryHasNotFailed_doesNotClearError() {
+    coordinator.clear();
+    verify(error, never()).clear();
+  }
+
+  @Test
+  public void clear_whenPrimaryHasFailed_errorIsRunning_clearsError() {
+    when(primary.isFailed()).thenReturn(true);
+    when(error.isRunning()).thenReturn(true);
+    coordinator.clear();
+    verify(error).clear();
+  }
+
+  @Test
+  public void clear_whenPrimaryHasFailed_clearsPrimary() {
+    when(primary.isFailed()).thenReturn(true);
+    coordinator.clear();
+    verify(primary).clear();
+  }
+
+  @Test
+  public void clear_whenErrorIsRunning_clearsError() {
+    when(error.isRunning()).thenReturn(true);
+    coordinator.clear();
+
+    verify(error).clear();
+  }
+
+  @Test
+  public void isRunning_primaryNotFailed_primaryNotRunning_returnsFalse() {
+    assertThat(coordinator.isRunning()).isFalse();
+  }
+
+  @Test
+  public void isRunning_primaryNotFailed_primaryRunning_returnsTrue() {
+    when(primary.isRunning()).thenReturn(true);
+    assertThat(coordinator.isRunning()).isTrue();
+  }
+
+  @Test
+  public void isRunning_primaryFailed_errorNotRunning_returnsFalse() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.isRunning()).isFalse();
+  }
+
+  @Test
+  public void isRunning_primaryFailed_errorRunning_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    when(error.isRunning()).thenReturn(true);
+    assertThat(coordinator.isRunning()).isTrue();
+  }
+
+  @Test
+  public void isComplete_primaryNotFailed_primaryNotComplete_returnsFalse() {
+    assertThat(coordinator.isComplete()).isFalse();
+  }
+
+  @Test
+  public void isComplete_primaryNotFailed_primaryComplete_returnsTrue() {
+    when(primary.isComplete()).thenReturn(true);
+    assertThat(coordinator.isComplete()).isTrue();
+  }
+
+  @Test
+  public void isComplete_primaryFailed_errorNotComplete_returnsFalse() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.isComplete()).isFalse();
+  }
+
+  @Test
+  public void isComplete_primaryFailed_errorComplete_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    when(error.isComplete()).thenReturn(true);
+    assertThat(coordinator.isComplete()).isTrue();
+  }
+
+  @Test
+  public void isResourceSet_primaryNotFailed_primaryNotResourceSet_returnsFalse() {
+    assertThat(coordinator.isResourceSet()).isFalse();
+  }
+
+  @Test
+  public void isResourceSet_primaryNotFailed_primaryResourceSet_returnsTrue() {
+    when(primary.isResourceSet()).thenReturn(true);
+    assertThat(coordinator.isResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isResourceSet_primaryFailed_errorNotResourceSet_returnsFalse() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.isResourceSet()).isFalse();
+  }
+
+  @Test
+  public void isResourceSet_primaryFailed_errorResourceSet_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    when(error.isResourceSet()).thenReturn(true);
+    assertThat(coordinator.isResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isCancelled_primaryNotFailed_primaryNotCancelled_returnsFalse() {
+    assertThat(coordinator.isCleared()).isFalse();
+  }
+
+  @Test
+  public void isCancelled_primaryNotFailed_primaryCancelled_returnsTrue() {
+    when(primary.isCleared()).thenReturn(true);
+    assertThat(coordinator.isCleared()).isTrue();
+  }
+
+  @Test
+  public void isCancelled_primaryFailed_errorNotCancelled_returnsFalse() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.isCleared()).isFalse();
+  }
+
+  @Test
+  public void isCancelled_primaryFailed_errorCancelled_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    when(error.isCleared()).thenReturn(true);
+    assertThat(coordinator.isCleared()).isTrue();
+  }
+
+  @Test
+  public void isFailed_primaryNotFailed_errorNotFailed_returnsFalse() {
+    assertThat(coordinator.isFailed()).isFalse();
+  }
+
+  @Test
+  public void isFailed_primaryFailed_errorNotFailed_returnsFalse() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.isFailed()).isFalse();
+  }
+
+  @Test
+  public void isFailed_primaryNotFailed_errorFailed_returnsFalse() {
+    when(error.isFailed()).thenReturn(true);
+    assertThat(coordinator.isFailed()).isFalse();
+  }
+
+  @Test
+  public void isFailed_primaryFailed_andErrorFailed_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    when(error.isFailed()).thenReturn(true);
+    assertThat(coordinator.isFailed()).isTrue();
+  }
+
+  @Test
+  public void recycle_recyclesPrimaryAndError() {
+    coordinator.recycle();
+    verify(primary).recycle();
+    verify(error).recycle();
+  }
+
+  @Test
+  public void isEquivalentTo() {
+    assertThat(coordinator.isEquivalentTo(primary)).isFalse();
+
+    ErrorRequestCoordinator other = new ErrorRequestCoordinator(/*parent=*/ null);
+    assertThat(coordinator.isEquivalentTo(other)).isFalse();
+
+    other.setRequests(primary, primary);
+    assertThat(coordinator.isEquivalentTo(other)).isFalse();
+
+    other.setRequests(error, error);
+    assertThat(coordinator.isEquivalentTo(other)).isFalse();
+
+    when(primary.isEquivalentTo(primary)).thenReturn(true);
+    when(error.isEquivalentTo(error)).thenReturn(true);
+    other.setRequests(primary, error);
+    assertThat(coordinator.isEquivalentTo(other)).isTrue();
+
+    other = new ErrorRequestCoordinator(parent);
+    other.setRequests(primary, error);
+    assertThat(coordinator.isEquivalentTo(other)).isTrue();
+
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    other = new ErrorRequestCoordinator(parent);
+    other.setRequests(primary, error);
+    assertThat(coordinator.isEquivalentTo(other)).isTrue();
+  }
+
+  @Test
+  public void canSetImage_withNotFailedPrimary_andNullParent_returnsTrue() {
+    assertThat(coordinator.canSetImage(primary)).isTrue();
+  }
+
+  @Test
+  public void canSetImage_withError_andNullParent_andNotFailedPrimary_returnsFalse() {
+    assertThat(coordinator.canSetImage(error)).isFalse();
+  }
+
+  @Test
+  public void canSetImage_withNotFailedPrimary_parentCanSetImage_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.canSetImage(coordinator)).thenReturn(true);
+
+    assertThat(coordinator.canSetImage(primary)).isTrue();
+  }
+
+  @Test
+  public void canSetImage_withNotFailedPrimary_parentCanNotSetImage_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+
+    assertThat(coordinator.canSetImage(primary)).isFalse();
+  }
+
+  @Test
+  public void canSetImage_withError_andFailedPrimary_nullParent_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.canSetImage(error)).isTrue();
+  }
+
+  @Test
+  public void canSetImage_withError_andFailedPrimary_nonNullParentCanSetImage_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.canSetImage(coordinator)).thenReturn(true);
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canSetImage(error)).isTrue();
+  }
+
+  @Test
+  public void canSetImage_withError_andFailedPrimary_nonNullParentCanNotSetImage_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canSetImage(error)).isFalse();
+  }
+
+  @Test
+  public void canNotifyStatusChanged_withNotFailedPrimary_nullParent_returnsTrue() {
+    assertThat(coordinator.canNotifyStatusChanged(primary)).isTrue();
+  }
+
+  @Test
+  public void canNotifyStatusChanged_withNotFailedPrimary_nonNullParentCantNotify_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+
+    assertThat(coordinator.canNotifyStatusChanged(primary)).isFalse();
+  }
+
+  @Test
+  public void canNotifyStatusChanged_withNotFailedPrimary_nonNullParentCanNotify_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.canNotifyStatusChanged(coordinator)).thenReturn(true);
+
+    assertThat(coordinator.canNotifyStatusChanged(primary)).isTrue();
+  }
+
+  @Test
+  public void canNotifyStatusChanged_withError_notFailedPrimary_nullParent_returnsFalse() {
+    assertThat(coordinator.canNotifyStatusChanged(error)).isFalse();
+  }
+
+  @Test
+  public void canNotifyStatusChanged_withError_failedPrimary_nullParent_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canNotifyStatusChanged(error)).isTrue();
+  }
+
+  @Test
+  public void canNotifyStatusChanged_withError_failedPrimary_nonNullParentCantNotify_false() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canNotifyStatusChanged(error)).isFalse();
+  }
+
+  @Test
+  public void canNotifyStatusChanged_withError_failedPrimary_nonNullParentCanNotify_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(primary.isFailed()).thenReturn(true);
+    when(parent.canNotifyStatusChanged(coordinator)).thenReturn(true);
+
+    assertThat(coordinator.canNotifyStatusChanged(primary)).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_primaryNotSet_nullParent_returnsFalse() {
+    assertThat(coordinator.isAnyResourceSet()).isFalse();
+  }
+
+  @Test
+  public void isAnyResourceSet_primarySet_nullParent_returnsTrue() {
+    when(primary.isResourceSet()).thenReturn(true);
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_primarySet_parentResourceNotSet_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(primary.isResourceSet()).thenReturn(true);
+
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_primarySet_parentSet_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(primary.isResourceSet()).thenReturn(true);
+    when(parent.isAnyResourceSet()).thenReturn(true);
+
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_parentSet_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.isAnyResourceSet()).thenReturn(true);
+
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_errorSet_notFailedPrimary_nullParent_returnsFalse() {
+    when(error.isResourceSet()).thenReturn(true);
+    assertThat(coordinator.isAnyResourceSet()).isFalse();
+  }
+
+  @Test
+  public void isAnyResourceSet_errorSet_failedPrimary_nullParent_returnsTrue() {
+    when(error.isResourceSet()).thenReturn(true);
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_errorSet_notFailedPrimary_nonNullParentNotSet_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(error.isResourceSet()).thenReturn(true);
+
+    assertThat(coordinator.isAnyResourceSet()).isFalse();
+  }
+
+  @Test
+  public void isAnyResourceSet_errorSet_failedPrimary_nonNullParentNotSet_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(primary.isFailed()).thenReturn(true);
+    when(error.isResourceSet()).thenReturn(true);
+
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_errorSet_nonNullParentSet_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.isAnyResourceSet()).thenReturn(true);
+    when(error.isResourceSet()).thenReturn(true);
+
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_primaryNotSet_errorNotSet_nonNullParentNotSet_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+
+    assertThat(coordinator.isAnyResourceSet()).isFalse();
+  }
+
+  @Test
+  public void isAnyResourceSet_primaryNotSet_errorNotSet_nonNullParentSet_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+
+    when(parent.isAnyResourceSet()).thenReturn(true);
+
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void onRequestSuccess_nullParent_doesNotThrow() {
+    coordinator.onRequestSuccess(primary);
+  }
+
+  @Test
+  public void onRequestSuccess_nonNullParent_callsParent() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.onRequestSuccess(primary);
+    verify(parent).onRequestSuccess(coordinator);
+  }
+
+  @Test
+  public void onRequestFailed_primaryRequest_notRunningError_beingsError() {
+    coordinator.onRequestFailed(primary);
+    verify(error).begin();
+  }
+
+  @Test
+  public void onRequestFailed_primaryRequest_runningError_doesNotBeginError() {
+    when(error.isRunning()).thenReturn(true);
+    coordinator.onRequestFailed(primary);
+
+    verify(error, never()).begin();
+  }
+
+  @Test
+  public void onRequestFailed_errorRequest_doesNotBeginError() {
+    coordinator.onRequestFailed(error);
+    verify(error, never()).begin();
+  }
+
+  @Test
+  public void onRequestFailed_primaryRequest_notRunningError_nonNullParent_doesNotNotifyParent() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+
+    coordinator.onRequestFailed(primary);
+    verify(parent, never()).onRequestFailed(any(Request.class));
+  }
+
+  @Test
+  public void onRequestFailed_errorRequest_nonNullParent_notifiesParent() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+
+    coordinator.onRequestFailed(error);
+
+    verify(parent).onRequestFailed(coordinator);
+  }
+
+  @Test
+  public void onRequestFailed_primaryRequest_runningError_nonNullParent_doesNotNotifyParent() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(error.isRunning()).thenReturn(true);
+
+    coordinator.onRequestFailed(primary);
+
+    verify(parent, never()).onRequestFailed(any(Request.class));
+  }
+
+  @Test
+  public void canNotifyCleared_primaryRequest_nullParent_returnsTrue() {
+    assertThat(coordinator.canNotifyCleared(primary)).isTrue();
+  }
+
+  @Test
+  public void canNotifyCleared_primaryRequest_parentCanNotNotify_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+
+    assertThat(coordinator.canNotifyCleared(primary)).isFalse();
+  }
+
+  @Test
+  public void canNotifyCleared_primaryRequest_parentCanNotify_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.canNotifyCleared(coordinator)).thenReturn(true);
+
+    assertThat(coordinator.canNotifyCleared(primary)).isTrue();
+  }
+
+  @Test
+  public void canNotifyCleared_primaryRequestFailed_parentCanNotify_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.canNotifyCleared(coordinator)).thenReturn(true);
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canNotifyCleared(primary)).isTrue();
+  }
+
+  @Test
+  public void canNotifyCleared_primaryRequestFailed_parentCanNotNotify_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(primary.isFailed()).thenReturn(false);
+
+    assertThat(coordinator.canNotifyCleared(primary)).isFalse();
+  }
+
+  @Test
+  public void canNotifyCleared_primaryRequestFailed_nullParent_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canNotifyCleared(primary)).isTrue();
+  }
+
+  @Test
+  public void canNotifyCleared_errorRequest_nullParent_returnsFalse() {
+    assertThat(coordinator.canNotifyCleared(error)).isFalse();
+  }
+
+  @Test
+  public void canNotifyCleared_errorRequest_primaryFailed_nullParent_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.canNotifyCleared(error)).isTrue();
+  }
+
+  @Test
+  public void canNotifyCleared_errorRequest_primaryFailed_nonNullParentCanNotNotify_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.canNotifyCleared(coordinator)).thenReturn(false);
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canNotifyCleared(error)).isFalse();
+  }
+
+  @Test
+  public void canNotifyCleared_errorRequest_primaryFailed_nonNullParentCanNotify_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.canNotifyCleared(coordinator)).thenReturn(true);
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canNotifyCleared(error)).isTrue();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
similarity index 78%
rename from library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
index cc3c11cd0..c7b48a83d 100644
--- a/library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
@@ -6,6 +6,7 @@
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyLong;
 import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.atLeastOnce;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
@@ -13,6 +14,7 @@
 import static org.mockito.Mockito.verify;
 
 import android.os.Handler;
+import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.request.target.SizeReadyCallback;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.ExecutionException;
@@ -61,7 +63,12 @@ public void testReturnsFalseForDoneBeforeDone() {
 
   @Test
   public void testReturnsTrueFromIsDoneIfDone() {
-    future.onResourceReady(new Object(), null);
+    future.onResourceReady(
+        /*resource=*/ new Object(),
+        /*model=*/ null,
+        /*target=*/future,
+        DataSource.DATA_DISK_CACHE,
+        true /*isFirstResource*/);
     assertTrue(future.isDone());
   }
 
@@ -106,7 +113,12 @@ public void testClearsRequestOnRun() {
 
   @Test
   public void testDoesNotClearRequestIfCancelledAfterDone() {
-    future.onResourceReady(new Object(), null);
+    future.onResourceReady(
+        /*resource=*/ new Object(),
+        /*model=*/ null,
+        /*target=*/future,
+        DataSource.DATA_DISK_CACHE,
+        true /*isFirstResource*/);
     future.cancel(true);
 
     verify(request, never()).clear();
@@ -120,7 +132,12 @@ public void testReturnsTrueFromDoneIfCancelled() {
 
   @Test
   public void testReturnsFalseFromIsCancelledIfCancelledAfterDone() {
-    future.onResourceReady(new Object(), null);
+    future.onResourceReady(
+        /*resource=*/ new Object(),
+        /*model=*/ null,
+        /*target=*/future,
+        DataSource.DATA_DISK_CACHE,
+        true /*isFirstResource*/);
     future.cancel(true);
 
     assertFalse(future.isCancelled());
@@ -134,7 +151,12 @@ public void testReturnsTrueFromCancelIfCancelled() {
 
   @Test
   public void testReturnsFalseFromCancelIfDone() {
-    future.onResourceReady(new Object(), null);
+    future.onResourceReady(
+        /*resource=*/ new Object(),
+        /*model=*/ null,
+        /*target=*/future,
+        DataSource.DATA_DISK_CACHE,
+        true /*isFirstResource*/);
     assertFalse(future.cancel(true));
   }
 
@@ -142,7 +164,12 @@ public void testReturnsFalseFromCancelIfDone() {
   public void testReturnsResourceOnGetIfAlreadyDone()
       throws ExecutionException, InterruptedException {
     Object expected = new Object();
-    future.onResourceReady(expected, null);
+    future.onResourceReady(
+        /*resource=*/ expected,
+        /*model=*/ null,
+        /*target=*/future,
+        DataSource.DATA_DISK_CACHE,
+        true /*isFirstResource*/);
 
     assertEquals(expected, future.get());
   }
@@ -151,9 +178,14 @@ public void testReturnsResourceOnGetIfAlreadyDone()
   public void testReturnsResourceOnGetWithTimeoutIfAlreadyDone()
       throws InterruptedException, ExecutionException, TimeoutException {
     Object expected = new Object();
-    future.onResourceReady(expected, null);
+    future.onResourceReady(
+        /*resource=*/ expected,
+        /*model=*/ null,
+        /*target=*/future,
+        DataSource.DATA_DISK_CACHE,
+        true /*isFirstResource*/);
 
-    assertEquals(expected, future.get(100, TimeUnit.MILLISECONDS));
+    assertEquals(expected, future.get(1, TimeUnit.MILLISECONDS));
   }
 
   @Test(expected = CancellationException.class)
@@ -173,21 +205,21 @@ public void testThrowsCancellationExceptionIfCancelledBeforeGetWithTimeout()
   @Test(expected = ExecutionException.class)
   public void testThrowsExecutionExceptionOnGetIfExceptionBeforeGet()
       throws ExecutionException, InterruptedException {
-    future.onLoadFailed(null);
+    future.onLoadFailed(/*e=*/ null, /*model=*/ null, future, /*isFirstResource=*/ true);
     future.get();
   }
 
   @Test(expected = ExecutionException.class)
   public void testThrowsExecutionExceptionOnGetIfExceptionWithNullValueBeforeGet()
       throws ExecutionException, InterruptedException, TimeoutException {
-    future.onLoadFailed(null);
+    future.onLoadFailed(/*e=*/ null, /*model=*/ null, future, /*isFirstResource=*/ true);
     future.get(100, TimeUnit.MILLISECONDS);
   }
 
   @Test(expected = ExecutionException.class)
   public void testThrowsExecutionExceptionOnGetIfExceptionBeforeGetWithTimeout()
       throws ExecutionException, InterruptedException, TimeoutException {
-    future.onLoadFailed(null);
+    future.onLoadFailed(/*e=*/ null, /*model=*/ null, future, /*isFirstResource=*/ true);
     future.get(100, TimeUnit.MILLISECONDS);
   }
 
@@ -208,7 +240,12 @@ public void testThrowsExceptionIfGetCalledOnMainThread()
   public void testGetSucceedsOnMainThreadIfDone()
       throws ExecutionException, InterruptedException {
     future = new RequestFutureTarget<>(handler, width, height, true, waiter);
-    future.onResourceReady(new Object(), null);
+    future.onResourceReady(
+        /*resource=*/ new Object(),
+        /*model=*/ null,
+        /*target=*/future,
+        DataSource.DATA_DISK_CACHE,
+        true /*isFirstResource*/);
     future.get();
   }
 
@@ -232,7 +269,7 @@ public void testThrowsExecutionExceptionIfLoadFailsWhileWaiting()
     doAnswer(new Answer<Void>() {
       @Override
       public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        future.onLoadFailed(null);
+        future.onLoadFailed(/*e=*/ null, /*model=*/ null, future, /*isFirstResource=*/ true);
         return null;
       }
     }).when(waiter).waitForTimeout(eq(future), anyLong());
@@ -266,13 +303,18 @@ public void testThrowsAssertionErrorIfFinishesWaitingWithoutTimeoutAndDoesNotRec
 
   @Test
   public void testNotifiesAllWhenLoadFails() {
-    future.onLoadFailed(null);
+    future.onLoadFailed(/*e=*/ null, /*model=*/ null, future, /*isFirstResource=*/ true);
     verify(waiter).notifyAll(eq(future));
   }
 
   @Test
   public void testNotifiesAllWhenResourceReady() {
-    future.onResourceReady(null, null);
+    future.onResourceReady(
+        /*resource=*/ new Object(),
+        /*model=*/ null,
+        /*target=*/future,
+        DataSource.DATA_DISK_CACHE,
+        true /*isFirstResource*/);
     verify(waiter).notifyAll(eq(future));
   }
 
@@ -297,7 +339,12 @@ public void testReturnsResourceIfReceivedWhileWaiting()
     doAnswer(new Answer<Void>() {
       @Override
       public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        future.onResourceReady(expected, null);
+        future.onResourceReady(
+            /*resource=*/ expected,
+            /*model=*/ null,
+            /*target=*/future,
+            DataSource.DATA_DISK_CACHE,
+            true /*isFirstResource*/);
         return null;
       }
     }).when(waiter).waitForTimeout(eq(future), anyLong());
@@ -318,30 +365,31 @@ public void testWaitsForeverIfNoTimeoutSet() throws InterruptedException {
 
   @Test
   public void testWaitsForGivenTimeoutMillisIfTimeoutSet() throws InterruptedException {
-    long timeout = 1234;
+    long timeout = 2;
     try {
-      future.get(1234, TimeUnit.MILLISECONDS);
+      future.get(timeout, TimeUnit.MILLISECONDS);
     } catch (InterruptedException | ExecutionException e) {
       throw new RuntimeException(e);
     } catch (TimeoutException e) {
       // Expected.
     }
 
-    verify(waiter).waitForTimeout(eq(future), eq(timeout));
+    verify(waiter, atLeastOnce()).waitForTimeout(eq(future), eq(timeout));
   }
 
   @Test
   public void testConvertsOtherTimeUnitsToMillisForWaiter() throws InterruptedException {
-    long timeoutSeconds = 10;
+    long timeoutMicros = 1000;
     try {
-      future.get(timeoutSeconds, TimeUnit.SECONDS);
+      future.get(timeoutMicros, TimeUnit.MICROSECONDS);
     } catch (InterruptedException | ExecutionException e) {
       throw new RuntimeException(e);
     } catch (TimeoutException e) {
       // Expected.
     }
 
-    verify(waiter).waitForTimeout(eq(future), eq(TimeUnit.SECONDS.toMillis(timeoutSeconds)));
+    verify(waiter, atLeastOnce())
+        .waitForTimeout(eq(future), eq(TimeUnit.MICROSECONDS.toMillis(timeoutMicros)));
   }
 
   @Test
diff --git a/library/test/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java b/library/test/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java
new file mode 100644
index 000000000..1f5536b3a
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java
@@ -0,0 +1,703 @@
+package com.bumptech.glide.request;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.app.Application;
+import android.graphics.Bitmap;
+import android.graphics.Color;
+import android.graphics.drawable.ColorDrawable;
+import android.graphics.drawable.Drawable;
+import android.graphics.drawable.GradientDrawable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.MultiTransformation;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.CenterCrop;
+import com.bumptech.glide.load.resource.bitmap.CircleCrop;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.signature.ObjectKey;
+import com.bumptech.glide.util.Util;
+import com.google.common.testing.EqualsTester;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class RequestOptionsTest {
+
+  private RequestOptions options;
+  @Mock private Transformation<Bitmap> transformation;
+  private Application app;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    options = new RequestOptions();
+
+    app = RuntimeEnvironment.application;
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_byDefault_isTrue() {
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withFitCenter_isTrue() {
+    options.fitCenter();
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+    options.optionalFitCenter();
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withCenterInside_isTrue() {
+    options.centerInside();
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+    options.optionalCenterInside();
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withCenterCrop_isFalse() {
+    options.centerCrop();
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+    options.optionalCenterCrop();
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withCircleCrop_isFalse() {
+    options.circleCrop();
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+    options.circleCrop();
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withBitmapTransformation_isFalse() {
+    options.transform(transformation);
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+    options.optionalTransform(transformation);
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withCustomTransformation_isFalse() {
+    options.transform(Bitmap.class, transformation);
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+    options.optionalTransform(Bitmap.class, transformation);
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withDownsampleStrategy_isTrue() {
+    options.downsample(DownsampleStrategy.CENTER_OUTSIDE);
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withNonScaleAndThenDontTransform_isTrue() {
+    options.circleCrop().dontTransform();
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withNonScaleAndAppliedDontTransform_isTrue() {
+    options.circleCrop();
+    options.apply(new RequestOptions().dontTransform());
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withDontTransformAndAppliedNonScaleTransform_isFalse() {
+    options.fitCenter();
+    options.apply(new RequestOptions().circleCrop());
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withNonScaleOnly_andAppliedWithScaleOnly_isTrue() {
+    options.circleCrop();
+    options.apply(new RequestOptions().fitCenter());
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withScaleOnlyAndAppliedWithoutTransform_isTrue() {
+    options.fitCenter();
+    options.apply(new RequestOptions().dontAnimate());
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withNonScaleOnlyAndAppliedWithoutTransform_isFalse() {
+    options.circleCrop();
+    options.apply(new RequestOptions().dontAnimate());
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+  }
+
+  @Test
+  public void testIsTransformationRequired_byDefault_isFalse() {
+    assertThat(options.isTransformationRequired()).isFalse();
+  }
+
+  @Test
+  public void testIsTransformationSet_byDefault_isFalse() {
+    assertThat(options.isTransformationSet()).isFalse();
+  }
+
+  @Test
+  public void testIsTransformationAllowed_byDefault_isTrue() {
+    assertThat(options.isTransformationAllowed()).isTrue();
+  }
+
+  @Test
+  public void testIsTransformationSet_afterApplyingOptionsWithTransform_isTrue() {
+    RequestOptions other = new RequestOptions();
+    other.transform(Bitmap.class, transformation);
+    options.apply(other);
+    assertThat(options.isTransformationSet()).isTrue();
+  }
+
+  @Test
+  public void testIsTransformationSet_afterDontTransform_isFalse() {
+    options.dontTransform();
+    assertThat(options.isTransformationSet()).isFalse();
+  }
+
+  @Test
+  public void testIsTransformationAllowed_afterDontTransform_isFalse() {
+    options.dontTransform();
+    assertThat(options.isTransformationAllowed()).isFalse();
+  }
+
+  @Test
+  public void testIsTransformationRequired_afterDontTransform_isFalse() {
+    options.dontTransform();
+    assertThat(options.isTransformationRequired()).isFalse();
+  }
+
+  @Test
+  public void testApplyingDontTransform_overridesTransformations() {
+    options.transform(transformation);
+    options.dontTransform();
+    assertThat(options.isTransformationSet()).isFalse();
+    assertThat(options.isTransformationRequired()).isFalse();
+    assertThat(options.getTransformations()).isEmpty();
+  }
+
+  @Test
+  public void testApplyingTransformation_overridesDontTransform() {
+    options.dontTransform();
+    options.transform(transformation);
+
+    assertThat(options.isTransformationAllowed()).isTrue();
+    assertThat(options.isTransformationRequired()).isTrue();
+    assertThat(options.getTransformations()).containsEntry(Bitmap.class, transformation);
+  }
+
+  @Test
+  public void testApplyingOptions_withDontTransform_overridesTransformations() {
+    options.transform(transformation);
+    RequestOptions other = new RequestOptions();
+    other.dontTransform();
+
+    options.apply(other);
+
+    assertThat(options.isTransformationAllowed()).isFalse();
+    assertThat(options.isTransformationSet()).isFalse();
+    assertThat(options.isTransformationRequired()).isFalse();
+    assertThat(options.getTransformations()).isEmpty();
+  }
+
+  @Test
+  public void testApplyingOptions_withTransformation_overridesDontTransform() {
+    options.dontTransform();
+    RequestOptions other = new RequestOptions();
+    other.transform(transformation);
+
+    options.apply(other);
+
+    assertThat(options.isTransformationAllowed()).isTrue();
+    assertThat(options.isTransformationSet()).isTrue();
+    assertThat(options.isTransformationRequired()).isTrue();
+    assertThat(options.getTransformations()).containsEntry(Bitmap.class, transformation);
+  }
+
+  @Test
+  public void testApplyingDefaultOptions_withDontTransform_retainsDontTransform() {
+    options.dontTransform();
+    options.apply(new RequestOptions());
+
+    assertThat(options.isTransformationAllowed()).isFalse();
+    assertThat(options.isTransformationRequired()).isFalse();
+    assertThat(options.getTransformations()).isEmpty();
+  }
+
+  @Test
+  public void testApplyingDefaultOptions_withTransform_retrainsTransform() {
+    options.transform(transformation);
+    options.apply(new RequestOptions());
+
+    assertThat(options.isTransformationAllowed()).isTrue();
+    assertThat(options.isTransformationRequired()).isTrue();
+    assertThat(options.getTransformations()).containsEntry(Bitmap.class, transformation);
+  }
+
+  @Test
+  @SuppressWarnings({"unchecked", "varargs"})
+  public void testApplyMultiTransform() {
+    options.transforms(new CircleCrop(), new CenterCrop());
+    assertThat(options.isTransformationRequired()).isTrue();
+    assertThat(options.getTransformations()).containsKey(Bitmap.class);
+    assertThat(options.getTransformations().get(Bitmap.class))
+      .isInstanceOf(MultiTransformation.class);
+  }
+
+  @Test
+  public void isSkipMemoryCacheSet_withoutSkipMemoryCache_isFalse() {
+    assertThat(options.isSkipMemoryCacheSet()).isFalse();
+  }
+
+  @Test
+  public void isSkipMemoryCacheSet_withSkipMemoryCacheTrue_isTrue() {
+    assertThat(options.skipMemoryCache(true).isSkipMemoryCacheSet()).isTrue();
+  }
+
+  @Test
+  public void isSkipMemoryCacheSet_withSkipMemoryCacheFalse_isTrue() {
+    assertThat(options.skipMemoryCache(false).isSkipMemoryCacheSet()).isTrue();
+  }
+
+  @Test
+  public void isDiskCacheStrategySet_withoutDiskCacheStrategy_isFalse() {
+    assertThat(options.isDiskCacheStrategySet()).isFalse();
+  }
+
+  @Test
+  public void isDiskCacheStrategySet_withDiskCacheStrategyDefault_isTrue() {
+    assertThat(options.diskCacheStrategy(DiskCacheStrategy.AUTOMATIC).isDiskCacheStrategySet())
+        .isTrue();
+  }
+
+  @Test
+  public void isDiskCacheStrategySet_withDiskCacheStrategyNonDefault_isTrue() {
+    assertThat(options.diskCacheStrategy(DiskCacheStrategy.ALL).isDiskCacheStrategySet())
+        .isTrue();
+  }
+
+  @Test
+  public void getPlaceholder_afterSettingPlaceholderId_returnsNul() {
+    assertThat(
+        options
+            .placeholder(new ColorDrawable(Color.RED))
+            .placeholder(android.R.drawable.star_on)
+            .getPlaceholderDrawable())
+        .isNull();
+  }
+
+  @Test
+  public void getPlaceholder_afterApplyingOptionsWithPlaceholderId_returnsNull() {
+    RequestOptions toApply = new RequestOptions().placeholder(android.R.drawable.star_on);
+
+    assertThat(
+        options
+            .placeholder(new ColorDrawable(Color.RED))
+            .apply(toApply)
+            .getPlaceholderDrawable())
+        .isNull();
+  }
+
+  @Test
+  public void getPlaceholder_afterApplyingOptionsWithPlaceholderDrawable_returnsNewDrawable() {
+    Drawable expected = new ColorDrawable(Color.GREEN);
+    RequestOptions toApply = new RequestOptions().placeholder(expected);
+
+    assertThat(
+        options
+          .placeholder(new ColorDrawable(Color.RED))
+          .apply(toApply)
+          .getPlaceholderDrawable())
+        .isEqualTo(expected);
+  }
+
+  /**
+   * Verifies that we set the flags for placeholder id correctly when applying a placeholder id via
+   * another RequestOptions.
+   */
+  @Test
+  public void placeholderIdFlag_afterApplyingIdViaOtherRequestOptions_isSet() {
+    assertThat(
+        options
+            .placeholder(new ColorDrawable(Color.RED))
+            .apply(
+                new RequestOptions()
+                    .apply(
+                        new RequestOptions()
+                            .placeholder(android.R.drawable.star_on)))
+            .getPlaceholderDrawable())
+        .isNull();
+  }
+
+
+  @Test
+  public void getPlaceholderId_afterSettingPlaceholderDrawable_returnsZero() {
+    assertThat(
+        options
+            .placeholder(android.R.drawable.star_on)
+            .placeholder(new ColorDrawable(Color.RED))
+            .getPlaceholderId())
+        .isEqualTo(0);
+  }
+
+  @Test
+  public void getPlaceholderId_afterApplyingOptionsWithPlaceholderDrawable_returnsZero() {
+    RequestOptions toApply = new RequestOptions().placeholder(new ColorDrawable(Color.RED));
+
+    assertThat(
+        options
+            .placeholder(android.R.drawable.star_on)
+            .apply(toApply)
+            .getPlaceholderId())
+        .isEqualTo(0);
+  }
+
+  @Test
+  public void getPlaceholderId_afterApplyingOptionsWithId_returnsNewId() {
+    int expectedId = android.R.drawable.star_off;
+    RequestOptions toApply = new RequestOptions().placeholder(expectedId);
+
+    assertThat(
+        options
+            .placeholder(android.R.drawable.star_on)
+            .apply(toApply)
+            .getPlaceholderId())
+        .isEqualTo(expectedId);
+  }
+
+  /**
+   * Verifies that we set the flags for placeholder correctly when applying a placeholder via
+   * another RequestOptions.
+   */
+  @Test
+  public void placeholderFlag_afterApplyingViaOtherRequestOptions_isSet() {
+    assertThat(
+        options
+            .placeholder(android.R.drawable.star_on)
+            .apply(
+                new RequestOptions()
+                    .apply(
+                        new RequestOptions()
+                            .placeholder(new ColorDrawable(Color.RED))))
+            .getPlaceholderId())
+        .isEqualTo(0);
+  }
+
+  @Test
+  public void getFallback_afterSettingFallbackId_returnsNull() {
+    assertThat(
+        options
+            .fallback(new ColorDrawable(Color.RED))
+            .fallback(android.R.drawable.star_on)
+            .getFallbackDrawable())
+        .isNull();
+  }
+
+  @Test
+  public void getFallback_afterApplyingOptionsWithFallbackId_returnsNull() {
+    RequestOptions toApply = new RequestOptions().fallback(android.R.drawable.star_on);
+
+    assertThat(
+        options
+            .fallback(new ColorDrawable(Color.RED))
+            .apply(toApply)
+            .getFallbackDrawable())
+        .isNull();
+  }
+
+  @Test
+  public void getFallback_afterApplyingOptionsWithFallbackDrawable_returnsNewDrawable() {
+    RequestOptions toApply = new RequestOptions();
+
+    RequestOptions apply = options.fallback(new ColorDrawable(Color.RED)).apply(toApply);
+    assertThat(((ColorDrawable) apply.getFallbackDrawable()).getColor()).isEqualTo(Color.RED);
+  }
+
+  /**
+   * Verifies that we set the flags for fallback correctly when applying a fallback via
+   * another RequestOptions.
+   */
+  @Test
+  public void fallbackFlag_afterApplyingViaOtherRequestOptions_isSet() {
+    assertThat(
+        options
+            .fallback(android.R.drawable.star_on)
+            .apply(
+                new RequestOptions()
+                    .apply(
+                        new RequestOptions()
+                            .fallback(new ColorDrawable(Color.RED))))
+            .getFallbackId())
+        .isEqualTo(0);
+  }
+
+  @Test
+  public void getFallbackId_afterSettingFallbackDrawable_returnsZero() {
+    assertThat(
+        options
+            .fallback(android.R.drawable.star_on)
+            .fallback(new ColorDrawable(Color.RED))
+            .getFallbackId())
+        .isEqualTo(0);
+  }
+
+  @Test
+  public void getFallbackId_afterApplyingOptionsWithFallbackDrawable_returnsZero() {
+    RequestOptions toApply = new RequestOptions().fallback(new ColorDrawable(Color.RED));
+
+    assertThat(
+        options
+            .fallback(android.R.drawable.star_on)
+            .apply(toApply)
+            .getFallbackId())
+        .isEqualTo(0);
+  }
+
+  @Test
+  public void getFallbackId_afterApplyingOptionsWithFallbackId_returnsNewFallbackId() {
+    RequestOptions toApply = new RequestOptions().fallback(android.R.drawable.star_off);
+
+    assertThat(
+        options
+          .fallback(android.R.drawable.star_on)
+          .apply(toApply)
+          .getFallbackId())
+        .isEqualTo(android.R.drawable.star_off);
+  }
+
+  /**
+   * Verifies that we set the flags for fallback id correctly when applying a fallback id via
+   * another RequestOptions.
+   */
+  @Test
+  public void fallbackIdFlag_afterApplyingViaOtherRequestOptions_isSet() {
+    assertThat(
+        options
+            .fallback(new ColorDrawable(Color.RED))
+            .apply(
+                new RequestOptions()
+                    .apply(
+                        new RequestOptions()
+                            .fallback(android.R.drawable.star_on)))
+            .getFallbackDrawable())
+        .isNull();
+  }
+
+  @Test
+  public void getError_afterSettingErrorId_returnsNull() {
+    assertThat(
+        options
+            .error(new ColorDrawable(Color.RED))
+            .error(android.R.drawable.star_on)
+            .getErrorPlaceholder())
+        .isNull();
+  }
+
+  @Test
+  public void getError_afterApplyingOptionsWithErrorId_returnsNull() {
+    RequestOptions toApply = new RequestOptions().error(android.R.drawable.star_on);
+
+    assertThat(
+        options
+            .error(new ColorDrawable(Color.RED))
+            .apply(toApply)
+            .getErrorPlaceholder())
+        .isNull();
+  }
+
+  @Test
+  public void getError_afterApplyingOptionsWithErrorDrawable_returnsNewErrorDrawable() {
+    Drawable expected = new ColorDrawable(Color.GREEN);
+    RequestOptions toApply = new RequestOptions().error(expected);
+
+    assertThat(
+        options
+          .error(new ColorDrawable(Color.RED))
+          .apply(toApply)
+          .getErrorPlaceholder())
+        .isEqualTo(expected);
+  }
+
+  /**
+   * Verifies that we set the flags for error correctly when applying an error via
+   * another RequestOptions.
+   */
+  @Test
+  public void errorFlag_afterApplyingViaOtherRequestOptions_isSet() {
+    assertThat(
+        options
+            .error(android.R.drawable.star_on)
+            .apply(
+                new RequestOptions()
+                    .apply(
+                        new RequestOptions()
+                            .error(new ColorDrawable(Color.RED))))
+            .getErrorId())
+        .isEqualTo(0);
+  }
+
+  @Test
+  public void getErrorId_afterSettingErrorDrawable_returnsZero() {
+    assertThat(
+        options
+            .error(android.R.drawable.star_on)
+            .error(new ColorDrawable(Color.RED))
+            .getErrorId())
+        .isEqualTo(0);
+  }
+
+  @Test
+  public void getErrorId_afterApplyingOptionsWithErrorDrawable_returnsZero() {
+    RequestOptions toApply = new RequestOptions().error(new ColorDrawable(Color.RED));
+
+    assertThat(
+        options.error(android.R.drawable.star_on)
+            .apply(toApply)
+            .getErrorId())
+        .isEqualTo(0);
+  }
+
+  @Test
+  public void getErrorId_afterApplyingOptionsWithErrorId_returnsNewErrorId() {
+    RequestOptions toApply = new RequestOptions().error(android.R.drawable.star_off);
+
+    assertThat(
+        options.error(android.R.drawable.star_on)
+            .apply(toApply)
+            .getErrorId())
+        .isEqualTo(android.R.drawable.star_off);
+  }
+
+  /**
+   * Verifies that we set the flags for error id correctly when applying a fallback id via
+   * another RequestOptions.
+   */
+  @Test
+  public void errorIdFlag_afterApplyingViaOtherRequestOptions_isSet() {
+    assertThat(
+        options
+            .error(new ColorDrawable(Color.RED))
+            .apply(
+                new RequestOptions()
+                    .apply(
+                        new RequestOptions()
+                            .error(android.R.drawable.star_on)))
+            .getErrorPlaceholder())
+        .isNull();
+  }
+
+  @Test
+  public void testEqualsHashCode() {
+    Drawable first = new ColorDrawable(Color.RED);
+    Drawable second = new GradientDrawable();
+    assertThat(first).isNotEqualTo(second);
+    assertThat(Util.bothNullOrEqual(first, second)).isFalse();
+    new EqualsTester()
+        .addEqualityGroup(
+            new RequestOptions().sizeMultiplier(.7f),
+            new RequestOptions().sizeMultiplier(.7f))
+        .addEqualityGroup(new RequestOptions().sizeMultiplier(0.8f))
+        .addEqualityGroup(new RequestOptions().error(1), new RequestOptions().error(1))
+        .addEqualityGroup(new RequestOptions().error(2))
+        .addEqualityGroup(new RequestOptions().error(first), new RequestOptions().error(first))
+        .addEqualityGroup(new RequestOptions().error(second))
+        .addEqualityGroup(new RequestOptions().placeholder(1), new RequestOptions().placeholder(1))
+        .addEqualityGroup(new RequestOptions().placeholder(2))
+        .addEqualityGroup(
+            new RequestOptions().placeholder(first),
+            new RequestOptions().placeholder(first))
+        .addEqualityGroup(new RequestOptions().placeholder(second))
+        .addEqualityGroup(new RequestOptions().fallback(1), new RequestOptions().fallback(1))
+        .addEqualityGroup(new RequestOptions().fallback(2))
+        .addEqualityGroup(
+            new RequestOptions().fallback(first),
+            new RequestOptions().fallback(first))
+        .addEqualityGroup(new RequestOptions().fallback(second))
+        .addEqualityGroup(
+            new RequestOptions().skipMemoryCache(true),
+            new RequestOptions().skipMemoryCache(true))
+        .addEqualityGroup(
+            new RequestOptions(),
+            new RequestOptions().skipMemoryCache(false),
+            new RequestOptions().theme(null),
+            new RequestOptions().onlyRetrieveFromCache(false),
+            new RequestOptions().useUnlimitedSourceGeneratorsPool(false))
+        .addEqualityGroup(
+            new RequestOptions().override(100),
+            new RequestOptions().override(100, 100))
+        .addEqualityGroup(
+            new RequestOptions().override(200),
+            new RequestOptions().override(200, 200))
+        .addEqualityGroup(
+            new RequestOptions().override(100, 200),
+            new RequestOptions().override(100, 200))
+        .addEqualityGroup(
+            new RequestOptions().override(200, 100),
+            new RequestOptions().override(200, 100))
+        .addEqualityGroup(
+            new RequestOptions().centerCrop(),
+            new RequestOptions().centerCrop())
+        .addEqualityGroup(
+            new RequestOptions().optionalCenterCrop(),
+            new RequestOptions().optionalCenterCrop())
+        .addEqualityGroup(new RequestOptions().fitCenter())
+        .addEqualityGroup(new RequestOptions().circleCrop())
+        .addEqualityGroup(new RequestOptions().centerInside())
+        .addEqualityGroup(
+            new RequestOptions().useUnlimitedSourceGeneratorsPool(true),
+            new RequestOptions().useUnlimitedSourceGeneratorsPool(true))
+        .addEqualityGroup(
+            new RequestOptions().onlyRetrieveFromCache(true),
+            new RequestOptions().onlyRetrieveFromCache(true))
+        .addEqualityGroup(
+            new RequestOptions().diskCacheStrategy(DiskCacheStrategy.ALL),
+            new RequestOptions().diskCacheStrategy(DiskCacheStrategy.ALL))
+        .addEqualityGroup(
+            new RequestOptions().diskCacheStrategy(DiskCacheStrategy.NONE))
+        .addEqualityGroup(
+            new RequestOptions().priority(Priority.HIGH),
+            new RequestOptions().priority(Priority.HIGH))
+        .addEqualityGroup(
+            new RequestOptions().priority(Priority.LOW))
+        .addEqualityGroup(
+            new RequestOptions().set(Option.memory("test"), true),
+            new RequestOptions().set(Option.memory("test"), true))
+        .addEqualityGroup(
+            new RequestOptions().set(Option.memory("test"), false))
+        .addEqualityGroup(
+            new RequestOptions().set(Option.memory("test2"), true))
+        .addEqualityGroup(
+            new RequestOptions().decode(Integer.class),
+            new RequestOptions().decode(Integer.class))
+        .addEqualityGroup(
+            new RequestOptions().decode(Float.class))
+        .addEqualityGroup(
+            new RequestOptions().signature(new ObjectKey("test")),
+            new RequestOptions().signature(new ObjectKey("test")))
+        .addEqualityGroup(
+            new RequestOptions().signature(new ObjectKey("test2")))
+        .addEqualityGroup(
+            new RequestOptions().theme(app.getTheme()),
+            new RequestOptions().theme(app.getTheme()))
+        .testEquals();
+  }
+
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/request/SingleRequestTest.java b/library/test/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
new file mode 100644
index 000000000..8341cd3c7
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
@@ -0,0 +1,1139 @@
+package com.bumptech.glide.request;
+
+import static com.bumptech.glide.tests.Util.isADataSource;
+import static com.bumptech.glide.tests.Util.mockResource;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyBoolean;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Matchers.isA;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.graphics.Color;
+import android.graphics.drawable.ColorDrawable;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.GlideContext;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.engine.Engine;
+import com.bumptech.glide.load.engine.GlideException;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.request.target.SizeReadyCallback;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.request.transition.TransitionFactory;
+import com.bumptech.glide.signature.ObjectKey;
+import com.google.common.base.Equivalence;
+import com.google.common.testing.EquivalenceTester;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+@SuppressWarnings("rawtypes")
+public class SingleRequestTest {
+
+  private SingleRequestBuilder builder;
+  @Mock private RequestListener<List> listener1;
+  @Mock private RequestListener<List> listener2;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    builder = new SingleRequestBuilder();
+  }
+
+  @Test
+  public void testIsNotCompleteBeforeReceivingResource() {
+    SingleRequest<List> request = builder.build();
+
+    assertFalse(request.isComplete());
+  }
+
+  @Test
+  public void testCanHandleNullResources() {
+    SingleRequest<List> request = builder.addRequestListener(listener1).build();
+
+    request.onResourceReady(null, DataSource.LOCAL);
+
+    assertTrue(request.isFailed());
+    verify(listener1).onLoadFailed(isAGlideException(), isA(Number.class),
+        eq(builder.target), anyBoolean());
+  }
+
+  @Test
+  public void testCanHandleEmptyResources() {
+    SingleRequest<List> request = builder.addRequestListener(listener1).build();
+    when(builder.resource.get()).thenReturn(null);
+
+    request.onResourceReady(builder.resource, DataSource.REMOTE);
+
+    assertTrue(request.isFailed());
+    verify(builder.engine).release(eq(builder.resource));
+    verify(listener1).onLoadFailed(isAGlideException(), any(Number.class),
+        eq(builder.target), anyBoolean());
+  }
+
+  @Test
+  public void testCanHandleNonConformingResources() {
+    SingleRequest<List> request = builder.addRequestListener(listener1).build();
+    when(((Resource) (builder.resource)).get())
+        .thenReturn("Invalid mocked String, this should be a List");
+
+    request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
+
+    assertTrue(request.isFailed());
+    verify(builder.engine).release(eq(builder.resource));
+    verify(listener1).onLoadFailed(isAGlideException(), any(Number.class),
+        eq(builder.target), anyBoolean());
+  }
+
+  @Test
+  public void testIsNotFailedAfterClear() {
+    SingleRequest<List> request = builder.build();
+
+    request.onResourceReady(null, DataSource.DATA_DISK_CACHE);
+    request.clear();
+
+    assertFalse(request.isFailed());
+  }
+
+  @Test
+  public void testIsNotFailedAfterBegin() {
+    SingleRequest<List> request = builder.build();
+
+    request.onResourceReady(null, DataSource.DATA_DISK_CACHE);
+    request.begin();
+
+    assertFalse(request.isFailed());
+  }
+
+  @Test
+  public void testIsCompleteAfterReceivingResource() {
+    SingleRequest<List> request = builder.build();
+
+    request.onResourceReady(builder.resource, DataSource.LOCAL);
+
+    assertTrue(request.isComplete());
+  }
+
+  @Test
+  public void testIsNotCompleteAfterClear() {
+    SingleRequest<List> request = builder.build();
+    request.onResourceReady(builder.resource, DataSource.REMOTE);
+    request.clear();
+
+    assertFalse(request.isComplete());
+  }
+
+  @Test
+  public void testIsCancelledAfterClear() {
+    SingleRequest<List> request = builder.build();
+    request.clear();
+
+    assertTrue(request.isCleared());
+  }
+
+  @Test
+  public void clear_notifiesTarget() {
+    SingleRequest<List> request = builder.build();
+    request.clear();
+
+    verify(builder.target).onLoadCleared(any(Drawable.class));
+  }
+
+  @Test
+  public void testDoesNotNotifyTargetTwiceIfClearedTwiceInARow() {
+    SingleRequest<List> request = builder.build();
+    request.clear();
+    request.clear();
+
+    verify(builder.target, times(1)).onLoadCleared(any(Drawable.class));
+  }
+
+  @Test
+  public void clear_doesNotNotifyTarget_ifRequestCoordinatorReturnsFalseForCanClear() {
+    when(builder.requestCoordinator.canNotifyCleared(any(Request.class))).thenReturn(false);
+    SingleRequest<List> request = builder.build();
+    request.clear();
+
+    verify(builder.target, never()).onLoadCleared(any(Drawable.class));
+  }
+
+  @Test
+  public void testResourceIsNotCompleteWhenAskingCoordinatorIfCanSetImage() {
+    RequestCoordinator requestCoordinator = mock(RequestCoordinator.class);
+    doAnswer(new Answer() {
+      @Override
+      public Object answer(InvocationOnMock invocation) {
+        Request request = (Request) invocation.getArguments()[0];
+        assertFalse(request.isComplete());
+        return true;
+      }
+    }).when(requestCoordinator).canSetImage(any(Request.class));
+
+    SingleRequest<List> request = builder
+        .setRequestCoordinator(requestCoordinator)
+        .build();
+
+    request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
+
+    verify(requestCoordinator).canSetImage(eq(request));
+  }
+
+  @Test
+  public void testIsNotFailedWithoutException() {
+    SingleRequest<List> request = builder.build();
+
+    assertFalse(request.isFailed());
+  }
+
+  @Test
+  public void testIsFailedAfterException() {
+    SingleRequest<List> request = builder.build();
+
+    request.onLoadFailed(new GlideException("test"));
+    assertTrue(request.isFailed());
+  }
+
+  @Test
+  public void testIgnoresOnSizeReadyIfNotWaitingForSize() {
+    SingleRequest<List> request = builder.build();
+    request.begin();
+    request.onSizeReady(100, 100);
+    request.onSizeReady(100, 100);
+
+    verify(builder.engine, times(1))
+        .load(
+            eq(builder.glideContext),
+            eq(builder.model),
+            eq(builder.signature),
+            eq(100),
+            eq(100),
+            eq(Object.class),
+            eq(List.class),
+            any(Priority.class),
+            any(DiskCacheStrategy.class),
+            eq(builder.transformations),
+            anyBoolean(),
+            anyBoolean(),
+            any(Options.class),
+            anyBoolean(),
+            anyBoolean(),
+            /*useAnimationPool=*/ anyBoolean(),
+            anyBoolean(),
+            any(ResourceCallback.class));
+  }
+
+  @Test
+  public void testIsFailedAfterNoResultAndNullException() {
+    SingleRequest<List> request = builder.build();
+
+    request.onLoadFailed(new GlideException("test"));
+    assertTrue(request.isFailed());
+  }
+
+  @Test
+  public void testEngineLoadCancelledOnCancel() {
+    Engine.LoadStatus loadStatus = mock(Engine.LoadStatus.class);
+
+    when(builder.engine
+        .load(
+            eq(builder.glideContext),
+            eq(builder.model),
+            eq(builder.signature),
+            anyInt(),
+            anyInt(),
+            eq(Object.class),
+            eq(List.class),
+            any(Priority.class),
+            any(DiskCacheStrategy.class),
+            eq(builder.transformations),
+            anyBoolean(),
+            anyBoolean(),
+            any(Options.class),
+            anyBoolean(),
+            anyBoolean(),
+            anyBoolean(),
+            anyBoolean(),
+            any(ResourceCallback.class)))
+        .thenReturn(loadStatus);
+
+    SingleRequest<List> request = builder.build();
+    request.begin();
+
+    request.onSizeReady(100, 100);
+    request.clear();
+
+    verify(loadStatus).cancel();
+  }
+
+  @Test
+  public void testResourceIsRecycledOnClear() {
+    SingleRequest<List> request = builder.build();
+
+    request.onResourceReady(builder.resource, DataSource.REMOTE);
+    request.clear();
+
+    verify(builder.engine).release(eq(builder.resource));
+  }
+
+  @Test
+  public void testPlaceholderDrawableIsSet() {
+    Drawable expected = new ColorDrawable(Color.RED);
+
+    MockTarget target = new MockTarget();
+
+    SingleRequest<List> request = builder
+        .setPlaceholderDrawable(expected)
+        .setTarget(target)
+        .build();
+    request.begin();
+
+    assertThat(target.currentPlaceholder).isEqualTo(expected);
+  }
+
+  @Test
+  public void testErrorDrawableIsSetOnLoadFailed() {
+    Drawable expected = new ColorDrawable(Color.RED);
+
+    MockTarget target = new MockTarget();
+
+    SingleRequest<List> request = builder
+        .setErrorDrawable(expected)
+        .setTarget(target)
+        .build();
+
+    request.onLoadFailed(new GlideException("test"));
+
+    assertThat(target.currentPlaceholder).isEqualTo(expected);
+  }
+
+  @Test
+  public void testPlaceholderDrawableSetOnNullModelWithNoErrorDrawable() {
+    Drawable placeholder = new ColorDrawable(Color.RED);
+
+    MockTarget target = new MockTarget();
+
+    SingleRequest<List> request = builder
+        .setErrorDrawable(placeholder)
+        .setTarget(target)
+        .setModel(null)
+        .build();
+
+    request.begin();
+
+    assertThat(target.currentPlaceholder).isEqualTo(placeholder);
+  }
+
+  @Test
+  public void testErrorDrawableSetOnNullModelWithErrorDrawable() {
+    Drawable placeholder = new ColorDrawable(Color.RED);
+    Drawable errorPlaceholder = new ColorDrawable(Color.GREEN);
+
+    MockTarget target = new MockTarget();
+
+    SingleRequest<List> request = builder
+        .setPlaceholderDrawable(placeholder)
+        .setErrorDrawable(errorPlaceholder)
+        .setTarget(target)
+        .setModel(null)
+        .build();
+
+    request.begin();
+
+    assertThat(target.currentPlaceholder).isEqualTo(errorPlaceholder);
+  }
+
+
+  @Test
+  public void testFallbackDrawableSetOnNullModelWithErrorAndFallbackDrawables() {
+    Drawable placeholder = new ColorDrawable(Color.RED);
+    Drawable errorPlaceholder = new ColorDrawable(Color.GREEN);
+    Drawable fallback = new ColorDrawable(Color.BLUE);
+
+    MockTarget target = new MockTarget();
+    SingleRequest<List> request = builder
+        .setPlaceholderDrawable(placeholder)
+        .setErrorDrawable(errorPlaceholder)
+        .setFallbackDrawable(fallback)
+        .setTarget(target)
+        .setModel(null)
+        .build();
+    request.begin();
+
+    assertThat(target.currentPlaceholder).isEqualTo(fallback);
+  }
+
+
+  @Test
+  public void testIsNotRunningBeforeRunCalled() {
+    assertFalse(builder.build().isRunning());
+  }
+
+  @Test
+  public void testIsRunningAfterRunCalled() {
+    Request request = builder.build();
+    request.begin();
+    assertTrue(request.isRunning());
+  }
+
+  @Test
+  public void testIsNotRunningAfterComplete() {
+    SingleRequest<List> request = builder.build();
+    request.begin();
+    request.onResourceReady(builder.resource, DataSource.REMOTE);
+
+    assertFalse(request.isRunning());
+  }
+
+  @Test
+  public void testIsNotRunningAfterFailing() {
+    SingleRequest<List> request = builder.build();
+    request.begin();
+    request.onLoadFailed(new GlideException("test"));
+
+    assertFalse(request.isRunning());
+  }
+
+  @Test
+  public void testIsNotRunningAfterClear() {
+    SingleRequest<List> request = builder.build();
+    request.begin();
+    request.clear();
+
+    assertFalse(request.isRunning());
+  }
+
+  @Test
+  public void testCallsTargetOnResourceReadyIfNoRequestListener() {
+    SingleRequest<List> request = builder.build();
+    request.onResourceReady(builder.resource, DataSource.LOCAL);
+
+    verify(builder.target).onResourceReady(eq(builder.result), anyTransition());
+  }
+
+  @Test
+  public void testCallsTargetOnResourceReadyIfAllRequestListenersReturnFalse() {
+    SingleRequest<List> request =
+        builder.addRequestListener(listener1).addRequestListener(listener2).build();
+
+    when(listener1
+        .onResourceReady(any(List.class), any(Number.class), eq(builder.target), isADataSource(),
+            anyBoolean())).thenReturn(false);
+    when(listener2
+        .onResourceReady(any(List.class), any(Number.class), eq(builder.target), isADataSource(),
+            anyBoolean())).thenReturn(false);
+    request.onResourceReady(builder.resource, DataSource.LOCAL);
+
+    verify(builder.target).onResourceReady(eq(builder.result), anyTransition());
+  }
+
+  @Test
+  public void testDoesNotCallTargetOnResourceReadyIfAnyRequestListenerReturnsTrue() {
+    SingleRequest<List> request =
+        builder.addRequestListener(listener1).addRequestListener(listener2).build();
+
+    when(listener1
+        .onResourceReady(any(List.class), any(Number.class), eq(builder.target), isADataSource(),
+            anyBoolean())).thenReturn(false);
+    when(listener1
+        .onResourceReady(any(List.class), any(Number.class), eq(builder.target), isADataSource(),
+            anyBoolean())).thenReturn(true);
+    request.onResourceReady(builder.resource, DataSource.REMOTE);
+
+    verify(builder.target, never()).onResourceReady(any(List.class), anyTransition());
+  }
+
+  @Test
+  public void testCallsTargetOnExceptionIfNoRequestListener() {
+    SingleRequest<List> request = builder.build();
+    request.onLoadFailed(new GlideException("test"));
+
+    verify(builder.target).onLoadFailed(eq(builder.errorDrawable));
+  }
+
+  @Test
+  public void testCallsTargetOnExceptionIfAllRequestListenersReturnFalse() {
+    SingleRequest<List> request =
+        builder.addRequestListener(listener1).addRequestListener(listener2).build();
+
+    when(listener1.onLoadFailed(isAGlideException(), any(Number.class),
+        eq(builder.target), anyBoolean()))
+        .thenReturn(false);
+    when(listener2.onLoadFailed(isAGlideException(), any(Number.class),
+        eq(builder.target), anyBoolean()))
+        .thenReturn(false);
+    request.onLoadFailed(new GlideException("test"));
+
+    verify(builder.target).onLoadFailed(eq(builder.errorDrawable));
+  }
+
+  @Test
+  public void testDoesNotCallTargetOnExceptionIfAnyRequestListenerReturnsTrue() {
+    SingleRequest<List> request =
+        builder.addRequestListener(listener1).addRequestListener(listener2).build();
+
+    when(listener1.onLoadFailed(isAGlideException(), any(Number.class),
+        eq(builder.target), anyBoolean()))
+        .thenReturn(false);
+    when(listener2.onLoadFailed(isAGlideException(), any(Number.class),
+        eq(builder.target), anyBoolean()))
+        .thenReturn(true);
+
+    request.onLoadFailed(new GlideException("test"));
+
+    verify(builder.target, never()).onLoadFailed(any(Drawable.class));
+  }
+
+  @Test
+  public void testRequestListenerIsCalledWithResourceResult() {
+    SingleRequest<List> request = builder.addRequestListener(listener1).build();
+    request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
+
+    verify(listener1)
+        .onResourceReady(eq(builder.result), any(Number.class), isAListTarget(), isADataSource(),
+            anyBoolean());
+  }
+
+  @Test
+  public void testRequestListenerIsCalledWithModel() {
+    SingleRequest<List> request = builder.addRequestListener(listener1).build();
+    request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
+
+    verify(listener1)
+        .onResourceReady(any(List.class), eq(builder.model), isAListTarget(), isADataSource(),
+            anyBoolean());
+  }
+
+  @Test
+  public void testRequestListenerIsCalledWithTarget() {
+    SingleRequest<List> request = builder.addRequestListener(listener1).build();
+    request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
+
+    verify(listener1)
+        .onResourceReady(any(List.class), any(Number.class), eq(builder.target), isADataSource(),
+            anyBoolean());
+  }
+
+  @Test
+  public void testRequestListenerIsCalledWithLoadedFromMemoryIfLoadCompletesSynchronously() {
+    final SingleRequest<List> request = builder.addRequestListener(listener1).build();
+
+    when(builder.engine
+        .load(
+            eq(builder.glideContext),
+            eq(builder.model),
+            eq(builder.signature),
+            anyInt(),
+            anyInt(),
+            eq(Object.class),
+            eq(List.class),
+            any(Priority.class),
+            any(DiskCacheStrategy.class),
+            eq(builder.transformations),
+            anyBoolean(),
+            anyBoolean(),
+            any(Options.class),
+            anyBoolean(),
+            anyBoolean(),
+            /*useAnimationPool=*/ anyBoolean(),
+            anyBoolean(),
+            any(ResourceCallback.class)))
+        .thenAnswer(new Answer<Object>() {
+          @Override
+          public Object answer(InvocationOnMock invocation) {
+            request.onResourceReady(builder.resource, DataSource.MEMORY_CACHE);
+            return null;
+          }
+        });
+
+    request.begin();
+    request.onSizeReady(100, 100);
+    verify(listener1)
+        .onResourceReady(eq(builder.result), any(Number.class), isAListTarget(),
+            eq(DataSource.MEMORY_CACHE), anyBoolean());
+  }
+
+  @Test
+  public void
+  testRequestListenerIsCalledWithNotLoadedFromMemoryCacheIfLoadCompletesAsynchronously() {
+    SingleRequest<List> request = builder.addRequestListener(listener1).build();
+    request.onSizeReady(100, 100);
+    request.onResourceReady(builder.resource, DataSource.LOCAL);
+
+    verify(listener1)
+        .onResourceReady(eq(builder.result), any(Number.class), isAListTarget(),
+            eq(DataSource.LOCAL), anyBoolean());
+  }
+
+  @Test
+  public void testRequestListenerIsCalledWithIsFirstResourceIfNoRequestCoordinator() {
+    SingleRequest<List> request = builder
+        .setRequestCoordinator(null)
+        .addRequestListener(listener1)
+        .build();
+    request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
+
+    verify(listener1)
+        .onResourceReady(eq(builder.result), any(Number.class), isAListTarget(), isADataSource(),
+            eq(true));
+  }
+
+  @Test
+  public void testRequestListenerIsCalledWithFirstImageIfRequestCoordinatorReturnsNoResourceSet() {
+    SingleRequest<List> request = builder.addRequestListener(listener1).build();
+    when(builder.requestCoordinator.isAnyResourceSet()).thenReturn(false);
+    request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
+
+    verify(listener1)
+        .onResourceReady(eq(builder.result), any(Number.class), isAListTarget(), isADataSource(),
+            eq(true));
+  }
+
+  @Test
+  public void
+  testRequestListenerIsCalledWithNotIsFirstRequestIfRequestCoordinatorReturnsResourceSet() {
+    SingleRequest<List> request = builder.addRequestListener(listener1).build();
+    when(builder.requestCoordinator.isAnyResourceSet()).thenReturn(true);
+    request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
+
+    verify(listener1)
+        .onResourceReady(eq(builder.result), any(Number.class), isAListTarget(),
+            isADataSource(), eq(false));
+  }
+
+  @Test
+  public void testTargetIsCalledWithAnimationFromFactory() {
+    SingleRequest<List> request = builder.build();
+    Transition<List> transition = mockTransition();
+    when(builder.transitionFactory.build(any(DataSource.class), anyBoolean()))
+        .thenReturn(transition);
+    request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
+
+    verify(builder.target).onResourceReady(eq(builder.result), eq(transition));
+  }
+
+  @Test
+  public void testCallsGetSizeIfOverrideWidthIsLessThanZero() {
+    SingleRequest<List> request = builder
+        .setOverrideWidth(-1)
+        .setOverrideHeight(100)
+        .build();
+    request.begin();
+
+    verify(builder.target).getSize(any(SizeReadyCallback.class));
+  }
+
+  @Test
+  public void testCallsGetSizeIfOverrideHeightIsLessThanZero() {
+    SingleRequest<List> request = builder
+        .setOverrideWidth(100)
+        .setOverrideHeight(-1)
+        .build();
+    request.begin();
+
+    verify(builder.target).getSize(any(SizeReadyCallback.class));
+  }
+
+  @Test
+  public void testDoesNotCallGetSizeIfOverrideWidthAndHeightAreSet() {
+    SingleRequest<List> request = builder
+        .setOverrideWidth(100)
+        .setOverrideHeight(100)
+        .build();
+    request.begin();
+
+    verify(builder.target, never()).getSize(any(SizeReadyCallback.class));
+  }
+
+  @Test
+  public void testCallsEngineWithOverrideWidthAndHeightIfSet() {
+    SingleRequest<List> request = builder
+        .setOverrideWidth(1)
+        .setOverrideHeight(2)
+        .build();
+    request.begin();
+
+    verify(builder.engine)
+        .load(
+            eq(builder.glideContext),
+            eq(builder.model),
+            eq(builder.signature),
+            anyInt(),
+            anyInt(),
+            eq(Object.class),
+            eq(List.class),
+            any(Priority.class),
+            any(DiskCacheStrategy.class),
+            eq(builder.transformations),
+            anyBoolean(),
+            anyBoolean(),
+            any(Options.class),
+            anyBoolean(),
+            anyBoolean(),
+            /*useAnimationPool=*/ anyBoolean(),
+            anyBoolean(),
+            any(ResourceCallback.class));
+  }
+
+  @Test
+  public void testDoesNotSetErrorDrawableIfRequestCoordinatorDoesntAllowIt() {
+    SingleRequest<List> request = builder
+        .setErrorDrawable(new ColorDrawable(Color.RED))
+        .build();
+    when(builder.requestCoordinator.canNotifyStatusChanged(any(Request.class))).thenReturn(false);
+    request.onLoadFailed(new GlideException("test"));
+
+    verify(builder.target, never()).onLoadFailed(any(Drawable.class));
+  }
+
+  @Test
+  public void testCanReRunClearedRequests() {
+    doAnswer(new CallSizeReady(100, 100)).when(builder.target)
+        .getSize(any(SizeReadyCallback.class));
+
+    when(builder.engine
+        .load(
+            eq(builder.glideContext),
+            eq(builder.model),
+            eq(builder.signature),
+            eq(100),
+            eq(100),
+            eq(Object.class),
+            eq(List.class),
+            any(Priority.class),
+            any(DiskCacheStrategy.class),
+            eq(builder.transformations),
+            anyBoolean(),
+            anyBoolean(),
+            any(Options.class),
+            anyBoolean(),
+            anyBoolean(),
+            /*useAnimationPool=*/ anyBoolean(),
+            anyBoolean(),
+            any(ResourceCallback.class)))
+        .thenAnswer(new CallResourceCallback(builder.resource));
+    SingleRequest<List> request = builder.build();
+
+    request.begin();
+    request.clear();
+    request.begin();
+
+    verify(builder.target, times(2)).onResourceReady(eq(builder.result), anyTransition());
+  }
+
+  @Test
+  public void testResourceOnlyReceivesOneGetOnResourceReady() {
+    SingleRequest<List> request = builder.build();
+    request.onResourceReady(builder.resource, DataSource.LOCAL);
+
+    verify(builder.resource, times(1)).get();
+  }
+
+  @Test
+  public void testDoesNotStartALoadIfOnSizeReadyIsCalledAfterClear() {
+    SingleRequest<List> request = builder.build();
+    request.clear();
+    request.onSizeReady(100, 100);
+
+    verify(builder.engine, never())
+        .load(
+            eq(builder.glideContext),
+            eq(builder.model),
+            eq(builder.signature),
+            anyInt(),
+            anyInt(),
+            eq(Object.class),
+            eq(List.class),
+            any(Priority.class),
+            any(DiskCacheStrategy.class),
+            eq(builder.transformations),
+            anyBoolean(),
+            anyBoolean(),
+            any(Options.class),
+            anyBoolean(),
+            anyBoolean(),
+            /*useAnimationPool=*/ anyBoolean(),
+            anyBoolean(),
+            any(ResourceCallback.class));
+  }
+
+
+  @Test
+  public void testCallsSourceUnlimitedExecutorEngineIfOptionsIsSet() {
+    doAnswer(new CallSizeReady(100, 100)).when(builder.target)
+        .getSize(any(SizeReadyCallback.class));
+
+    SingleRequest<List> request = builder
+        .setUseUnlimitedSourceGeneratorsPool(true)
+        .build();
+    request.begin();
+
+    verify(builder.engine)
+        .load(
+            eq(builder.glideContext),
+            eq(builder.model),
+            eq(builder.signature),
+            anyInt(),
+            anyInt(),
+            eq(Object.class),
+            eq(List.class),
+            any(Priority.class),
+            any(DiskCacheStrategy.class),
+            eq(builder.transformations),
+            anyBoolean(),
+            anyBoolean(),
+            any(Options.class),
+            anyBoolean(),
+            eq(true),
+            /*useAnimationPool=*/ anyBoolean(),
+            anyBoolean(),
+            any(ResourceCallback.class));
+  }
+
+  @Test
+  public void testCallsSourceExecutorEngineIfOptionsIsSet() {
+    doAnswer(new CallSizeReady(100, 100)).when(builder.target)
+        .getSize(any(SizeReadyCallback.class));
+
+    SingleRequest<List> request = builder
+        .setUseUnlimitedSourceGeneratorsPool(false)
+        .build();
+    request.begin();
+
+    verify(builder.engine)
+        .load(
+            eq(builder.glideContext),
+            eq(builder.model),
+            eq(builder.signature),
+            anyInt(),
+            anyInt(),
+            eq(Object.class),
+            eq(List.class),
+            any(Priority.class),
+            any(DiskCacheStrategy.class),
+            eq(builder.transformations),
+            anyBoolean(),
+            anyBoolean(),
+            any(Options.class),
+            anyBoolean(),
+            eq(false),
+            /*useAnimationPool=*/ anyBoolean(),
+            anyBoolean(),
+            any(ResourceCallback.class));
+  }
+
+  @Test
+  // Varargs
+  @SuppressWarnings("unchecked")
+  public void testIsEquivalentTo() {
+    EquivalenceTester<SingleRequestBuilder> tester = EquivalenceTester
+        .of(new Equivalence<SingleRequestBuilder>() {
+          @Override
+          protected boolean doEquivalent(
+              @NonNull SingleRequestBuilder a, @NonNull SingleRequestBuilder b) {
+            return a.build().isEquivalentTo(b.build()) && b.build().isEquivalentTo(a.build());
+          }
+
+          @Override
+          protected int doHash(@NonNull SingleRequestBuilder listSingleRequest) {
+            return 0;
+          }
+        });
+    tester
+        .addEquivalenceGroup(
+            // Non-null request listeners are treated as equivalent, even if they're not equal.
+            new SingleRequestBuilder().addRequestListener(listener1),
+            new SingleRequestBuilder().addRequestListener(listener2))
+        .addEquivalenceGroup(
+            new SingleRequestBuilder().setOverrideHeight(500),
+            new SingleRequestBuilder().setOverrideHeight(500))
+        .addEquivalenceGroup(
+            new SingleRequestBuilder().setOverrideWidth(500),
+            new SingleRequestBuilder().setOverrideWidth(500))
+        .addEquivalenceGroup(
+            new SingleRequestBuilder().setModel(12345),
+            new SingleRequestBuilder().setModel(12345))
+        .addEquivalenceGroup(
+            new SingleRequestBuilder().setModel(null),
+            new SingleRequestBuilder().setModel(null))
+        .addEquivalenceGroup(
+            new SingleRequestBuilder().setPriority(Priority.LOW),
+            new SingleRequestBuilder().setPriority(Priority.LOW))
+        .test();
+  }
+
+  static final class SingleRequestBuilder {
+    private Engine engine = mock(Engine.class);
+    private Number model = 123456;
+    @SuppressWarnings("unchecked")
+    private Target<List> target = mock(Target.class);
+    private Resource<List> resource = mockResource();
+    private RequestCoordinator requestCoordinator = mock(RequestCoordinator.class);
+    private Drawable placeholderDrawable = null;
+    private Drawable errorDrawable = null;
+    private Drawable fallbackDrawable = null;
+    @SuppressWarnings("unchecked")
+    private List<RequestListener<List>> requestListeners = new ArrayList<>();
+    @SuppressWarnings("unchecked")
+    private final TransitionFactory<List> transitionFactory = mock(TransitionFactory.class);
+    private int overrideWidth = -1;
+    private int overrideHeight = -1;
+    private List<?> result = new ArrayList<>();
+    private final GlideContext glideContext = mock(GlideContext.class);
+    private final Key signature = new ObjectKey(12345);
+    private Priority priority = Priority.HIGH;
+    private boolean useUnlimitedSourceGeneratorsPool = false;
+    private final Class<List> transcodeClass = List.class;
+    private final Map<Class<?>, Transformation<?>> transformations = new HashMap<>();
+
+    SingleRequestBuilder() {
+      when(requestCoordinator.canSetImage(any(Request.class))).thenReturn(true);
+      when(requestCoordinator.canNotifyCleared(any(Request.class))).thenReturn(true);
+      when(requestCoordinator.canNotifyStatusChanged(any(Request.class))).thenReturn(true);
+      when(resource.get()).thenReturn(result);
+    }
+
+    SingleRequestBuilder setEngine(Engine engine) {
+      this.engine = engine;
+      return this;
+    }
+
+    SingleRequestBuilder setModel(Number model) {
+      this.model = model;
+      return this;
+    }
+
+    SingleRequestBuilder setTarget(Target<List> target) {
+      this.target = target;
+      return this;
+    }
+
+    SingleRequestBuilder setResource(Resource<List> resource) {
+      this.resource = resource;
+      return this;
+    }
+
+    SingleRequestBuilder setRequestCoordinator(RequestCoordinator requestCoordinator) {
+      this.requestCoordinator = requestCoordinator;
+      return this;
+    }
+
+    SingleRequestBuilder setPlaceholderDrawable(Drawable placeholderDrawable) {
+      this.placeholderDrawable = placeholderDrawable;
+      return this;
+    }
+
+    SingleRequestBuilder setErrorDrawable(Drawable errorDrawable) {
+      this.errorDrawable = errorDrawable;
+      return this;
+    }
+
+    SingleRequestBuilder setFallbackDrawable(Drawable fallbackDrawable) {
+      this.fallbackDrawable = fallbackDrawable;
+      return this;
+    }
+
+    SingleRequestBuilder addRequestListener(RequestListener<List> requestListener) {
+      this.requestListeners.add(requestListener);
+      return this;
+    }
+
+    SingleRequestBuilder setOverrideWidth(int overrideWidth) {
+      this.overrideWidth = overrideWidth;
+      return this;
+    }
+
+    SingleRequestBuilder setOverrideHeight(int overrideHeight) {
+      this.overrideHeight = overrideHeight;
+      return this;
+    }
+
+    SingleRequestBuilder setResult(List<?> result) {
+      this.result = result;
+      return this;
+    }
+
+    SingleRequestBuilder setPriority(Priority priority) {
+      this.priority = priority;
+      return this;
+    }
+
+    SingleRequestBuilder setUseUnlimitedSourceGeneratorsPool(
+        boolean useUnlimitedSourceGeneratorsPool) {
+      this.useUnlimitedSourceGeneratorsPool = useUnlimitedSourceGeneratorsPool;
+      return this;
+    }
+
+    SingleRequest<List> build() {
+      RequestOptions requestOptions = new RequestOptions()
+          .error(errorDrawable)
+          .placeholder(placeholderDrawable)
+          .fallback(fallbackDrawable)
+          .override(overrideWidth, overrideHeight)
+          .priority(priority)
+          .signature(signature)
+          .useUnlimitedSourceGeneratorsPool(useUnlimitedSourceGeneratorsPool);
+      return SingleRequest.obtain(
+          /*context=*/glideContext,
+          /*glideContext=*/glideContext,
+          model,
+          transcodeClass,
+          requestOptions,
+          overrideWidth,
+          overrideHeight,
+          priority,
+          target,
+          /*targetListener=*/ null,
+          requestListeners,
+          requestCoordinator,
+          engine,
+          transitionFactory);
+    }
+  }
+
+  // TODO do we want to move these to Util?
+  @SuppressWarnings("unchecked")
+  private static <T> Transition<T> mockTransition() {
+    return mock(Transition.class);
+  }
+
+  @SuppressWarnings("unchecked")
+  private static Target<List> isAListTarget() {
+    return isA(Target.class);
+  }
+
+  private static GlideException isAGlideException() {
+    return isA(GlideException.class);
+  }
+
+  @SuppressWarnings("unchecked")
+  private static <T> Transition<T> anyTransition() {
+    return any(Transition.class);
+  }
+
+  private static class CallResourceCallback implements Answer {
+
+    private final Resource resource;
+
+    CallResourceCallback(Resource resource) {
+      this.resource = resource;
+    }
+
+    @Override
+    public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      ResourceCallback cb =
+          (ResourceCallback) invocationOnMock.getArguments()[
+              invocationOnMock.getArguments().length
+                  - 1];
+      cb.onResourceReady(resource, DataSource.REMOTE);
+      return null;
+    }
+  }
+
+  private static class CallSizeReady implements Answer {
+
+    private final int width;
+    private final int height;
+
+    CallSizeReady(int width, int height) {
+      this.width = width;
+      this.height = height;
+    }
+
+    @Override
+    public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      SizeReadyCallback cb = (SizeReadyCallback) invocationOnMock.getArguments()[0];
+      cb.onSizeReady(width, height);
+      return null;
+    }
+  }
+
+  private static class MockTarget implements Target<List> {
+
+    private Drawable currentPlaceholder;
+
+    @Override
+    public void onLoadCleared(@Nullable Drawable placeholder) {
+      currentPlaceholder = placeholder;
+    }
+
+    @Override
+    public void onLoadStarted(@Nullable Drawable placeholder) {
+      currentPlaceholder = placeholder;
+
+    }
+
+    @Override
+    public void onLoadFailed(@Nullable Drawable errorDrawable) {
+      currentPlaceholder = errorDrawable;
+
+    }
+
+    @Override
+    public void onResourceReady(@NonNull List resource,
+        @Nullable Transition<? super List> transition) {
+      currentPlaceholder = null;
+    }
+
+
+    @Override
+    public void getSize(@NonNull SizeReadyCallback cb) {
+    }
+
+    @Override
+    public void removeCallback(@NonNull SizeReadyCallback cb) {
+      // Do nothing.
+    }
+
+    @Override
+    public void setRequest(@Nullable Request request) {
+    }
+
+    @Nullable
+    @Override
+    public Request getRequest() {
+      return null;
+    }
+
+    @Override
+    public void onStart() {
+    }
+
+    @Override
+    public void onStop() {
+
+    }
+
+    @Override
+    public void onDestroy() {
+
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java b/library/test/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
similarity index 84%
rename from library/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
index cf2087c8c..5bab9738a 100644
--- a/library/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
@@ -1,12 +1,12 @@
 package com.bumptech.glide.request;
 
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
@@ -16,21 +16,21 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 
 @RunWith(JUnit4.class)
 public class ThumbnailRequestCoordinatorTest {
-  private Request full;
-  private Request thumb;
+  @Mock private Request full;
+  @Mock private Request thumb;
+  @Mock private RequestCoordinator parent;
   private ThumbnailRequestCoordinator coordinator;
-  private RequestCoordinator parent;
 
   @Before
   public void setUp() {
-    full = mock(Request.class);
-    thumb = mock(Request.class);
-    parent = mock(RequestCoordinator.class);
+    MockitoAnnotations.initMocks(this);
     coordinator = new ThumbnailRequestCoordinator();
     coordinator.setRequests(full, thumb);
   }
@@ -85,6 +85,33 @@ public void testDoesNotStartThumbOnRunIfRunning() {
     verify(thumb, never()).begin();
   }
 
+  @Test
+  public void begin_whenFullIsComplete_startsFull() {
+    when(full.isComplete()).thenReturn(true);
+
+    coordinator.begin();
+
+    verify(full).begin();
+  }
+
+  @Test
+  public void begin_whenFullIsComplete_doesNotBeginThumb() {
+    when(full.isComplete()).thenReturn(true);
+
+    coordinator.begin();
+
+    verify(thumb, never()).begin();
+  }
+
+  @Test
+  public void begin_whenFullIsComplete_doesNotSetRunning() {
+    when(full.isComplete()).thenReturn(true);
+
+    coordinator.begin();
+
+    assertThat(coordinator.isRunning()).isFalse();
+  }
+
   @Test
   public void testDoesNotStartFullIfClearedByThumb() {
     doAnswer(new Answer<Void>() {
@@ -116,19 +143,6 @@ public void testRecyclesRequestsWhenRecycled() {
     verify(full).recycle();
   }
 
-  @Test
-  public void testIsPausedWhenFullIsPaused() {
-    when(full.isPaused()).thenReturn(true);
-    assertTrue(coordinator.isPaused());
-  }
-
-  @Test
-  public void testPausesBothRequestsWhenPaused() {
-    coordinator.pause();
-    verify(full).pause();
-    verify(thumb).pause();
-  }
-
   @Test
   public void testCanSetImageReturnsTrueForFullRequestIfCoordinatorIsNull() {
     coordinator = new ThumbnailRequestCoordinator();
@@ -317,9 +331,9 @@ public void testDoesNotClearThumbOnThumbRequestComplete() {
 
   @Test
   public void testDoesNotClearThumbOnFullComplete_whenThumbIsComplete() {
-      when(thumb.isComplete()).thenReturn(true);
-      coordinator.onRequestSuccess(full);
-      verify(thumb, never()).clear();
+    when(thumb.isComplete()).thenReturn(true);
+    coordinator.onRequestSuccess(full);
+    verify(thumb, never()).clear();
   }
 
   @Test
@@ -331,6 +345,32 @@ public void testDoesNotNotifyParentOnThumbRequestComplete() {
     verify(parent, never()).onRequestSuccess(any(Request.class));
   }
 
+  @Test
+  public void canNotifyCleared_withThumbRequest_returnsFalse() {
+    assertThat(coordinator.canNotifyCleared(thumb)).isFalse();
+  }
+
+  @Test
+  public void canNotifyCleared_withFullRequest_andNullParent_returnsTrue() {
+    assertThat(coordinator.canNotifyCleared(full)).isTrue();
+  }
+
+  @Test
+  public void canNotifyCleared_withFullRequest_nonNullParent_parentCanClear_returnsTrue() {
+    coordinator = new ThumbnailRequestCoordinator(parent);
+    coordinator.setRequests(full, thumb);
+    when(parent.canNotifyCleared(coordinator)).thenReturn(true);
+    assertThat(coordinator.canNotifyCleared(full)).isTrue();
+  }
+
+  @Test
+  public void canNotifyCleared_withFullRequest_nonNullParent_parentCanNotClear_returnsFalse() {
+    coordinator = new ThumbnailRequestCoordinator(parent);
+    coordinator.setRequests(full, thumb);
+    when(parent.canNotifyCleared(coordinator)).thenReturn(false);
+    assertThat(coordinator.canNotifyCleared(full)).isFalse();
+  }
+
   @Test
   public void testIsEquivalentTo() {
     ThumbnailRequestCoordinator first = new ThumbnailRequestCoordinator();
diff --git a/library/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
similarity index 95%
rename from library/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
index 4ec3ed752..a9a8ffe6e 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
@@ -31,8 +31,7 @@
 
   @Before
   public void setUp() {
-    shadowManager = (UpdateShadowAppWidgetManager) Shadow
-        .extract(AppWidgetManager.getInstance(RuntimeEnvironment.application));
+    shadowManager = Shadow.extract(AppWidgetManager.getInstance(RuntimeEnvironment.application));
     viewId = 1234;
     views = mock(RemoteViews.class);
   }
@@ -126,11 +125,12 @@ public void testThrowsWhenGivenNullComponentName() {
 
   @Implements(AppWidgetManager.class)
   public static class UpdateShadowAppWidgetManager extends ShadowAppWidgetManager {
-    public int[] updatedWidgetIds;
-    public RemoteViews updatedRemoteViews;
-    public ComponentName updatedComponentName;
+    int[] updatedWidgetIds;
+    RemoteViews updatedRemoteViews;
+    ComponentName updatedComponentName;
 
     @Implementation
+    @Override
     public void updateAppWidget(int[] appWidgetIds, RemoteViews views) {
       updatedWidgetIds = appWidgetIds;
       updatedRemoteViews = views;
diff --git a/library/src/test/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java
diff --git a/library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java
diff --git a/library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
similarity index 65%
rename from library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
index eeb0b1fcf..9fd3f101d 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
@@ -1,14 +1,18 @@
 package com.bumptech.glide.request.target;
 
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.inOrder;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import android.graphics.Color;
+import android.graphics.drawable.Animatable;
 import android.graphics.drawable.ColorDrawable;
 import android.graphics.drawable.Drawable;
 import android.widget.ImageView;
@@ -16,6 +20,10 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
@@ -24,12 +32,15 @@
 @Config(manifest = Config.NONE, sdk = 18)
 public class ImageViewTargetTest {
 
+  @Mock private AnimatedDrawable animatedDrawable;
   private ImageView view;
   private TestTarget target;
   private ColorDrawable drawable;
 
   @Before
   public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
     view = new ImageView(RuntimeEnvironment.application);
     target = new TestTarget(view);
     drawable = new ColorDrawable(Color.RED);
@@ -99,19 +110,49 @@ public void testProvidesCurrentPlaceholderToAnimationIfPresent() {
 
     target.onResourceReady(new ColorDrawable(Color.GREEN), animation);
 
-    verify(animation).transition(eq(placeholder), eq(target));
+    ArgumentCaptor<Drawable> drawableCaptor = ArgumentCaptor.forClass(Drawable.class);
+    verify(animation).transition(drawableCaptor.capture(), eq(target));
+    assertThat(((ColorDrawable) drawableCaptor.getValue()).getColor()).isEqualTo(Color.GREEN);
+  }
+
+  @Test
+  public void onResourceReady_withAnimatableResource_startsAnimatableAfterSetResource() {
+    AnimatedDrawable drawable = mock(AnimatedDrawable.class);
+    ImageView view = mock(ImageView.class);
+    target = new TestTarget(view);
+    target.onResourceReady(drawable, /*transition=*/ null);
+
+    InOrder order = inOrder(view, drawable);
+    order.verify(view).setImageDrawable(drawable);
+    order.verify(drawable).start();
+  }
+
+  @Test
+  public void onLoadCleared_withAnimatableDrawable_stopsDrawable() {
+    target.onResourceReady(animatedDrawable, /*transition=*/ null);
+    verify(animatedDrawable).start();
+    verify(animatedDrawable, never()).stop();
+
+    target.onLoadCleared(/*placeholder=*/ null);
+
+    verify(animatedDrawable).stop();
+  }
+
+  private abstract static class AnimatedDrawable extends Drawable implements Animatable {
+    // Intentionally empty.
   }
 
-  private static class TestTarget extends ImageViewTarget<Drawable> {
+  private static final class TestTarget extends ImageViewTarget<Drawable> {
     public Drawable resource;
 
-    public TestTarget(ImageView view) {
+    TestTarget(ImageView view) {
       super(view);
     }
 
     @Override
     protected void setResource(Drawable resource) {
       this.resource = resource;
+      view.setImageDrawable(resource);
     }
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
similarity index 93%
rename from library/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
index eae33c7e4..d1c51da32 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
@@ -35,9 +35,10 @@
 
   @Before
   public void setUp() {
-    NotificationManager notificationManager = (NotificationManager) RuntimeEnvironment.application
-        .getSystemService(Context.NOTIFICATION_SERVICE);
-    shadowManager = (UpdateShadowNotificationManager) Shadow.extract(notificationManager);
+    NotificationManager notificationManager =
+        (NotificationManager)
+            RuntimeEnvironment.application.getSystemService(Context.NOTIFICATION_SERVICE);
+    shadowManager = Shadow.extract(notificationManager);
 
     remoteViews = mock(RemoteViews.class);
     viewId = 123;
@@ -97,6 +98,7 @@ public void testThrowsIfRemoteViewsIsNull() {
     Notification updatedNotification;
 
     @Implementation
+    @Override
     public void notify(String notificationTag, int notificationId, Notification notification) {
       updatedNotificationTag = notificationTag;
       updatedNotificationId = notificationId;
diff --git a/library/src/test/java/com/bumptech/glide/request/target/PreloadTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/PreloadTargetTest.java
similarity index 96%
rename from library/src/test/java/com/bumptech/glide/request/target/PreloadTargetTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/target/PreloadTargetTest.java
index e5e397f41..c3435319f 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/PreloadTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/target/PreloadTargetTest.java
@@ -18,7 +18,7 @@
 @Config(manifest = Config.NONE, sdk = 18)
 public class PreloadTargetTest {
 
-  @Mock RequestManager requestManager;
+  @Mock private RequestManager requestManager;
 
   @Before
   public void setUp() {
diff --git a/library/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java
similarity index 81%
rename from library/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java
index 14e1362f7..3093df1fb 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java
@@ -2,6 +2,8 @@
 
 import static org.mockito.Mockito.mock;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.request.transition.Transition;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -32,7 +34,13 @@ public void testThrowsOnGetSizeIfGivenHeightIsEqualToZero() {
 
   @Test
   public void testCanBeConstructedWithoutDimensions() {
-    getTarget();
+    new SimpleTarget<Object>() {
+      @Override
+      public void onResourceReady(@NonNull Object resource,
+          @Nullable Transition<? super Object> transition) {
+        // Do nothing.
+      }
+    };
   }
 
   @Test
@@ -45,19 +53,11 @@ public void testGetSizeDoesNotThrowWithSizeOriginal() {
     getTarget(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL).getSize(mock(SizeReadyCallback.class));
   }
 
-  private SimpleTarget<Object> getTarget() {
-    return new SimpleTarget<Object>() {
-      @Override
-      public void onResourceReady(Object resource, Transition<? super Object> transition) {
-        // Do nothing.
-      }
-    };
-  }
-
   private SimpleTarget<Object> getTarget(int width, int height) {
     return new SimpleTarget<Object>(width, height) {
       @Override
-      public void onResourceReady(Object resource, Transition<? super Object> transition) {
+      public void onResourceReady(@NonNull Object resource,
+          @Nullable Transition<? super Object> transition) {
         // Do nothing.
       }
     };
diff --git a/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
similarity index 60%
rename from library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
index 1d0dd6e81..f6ae534f4 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
@@ -12,15 +12,25 @@
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
 
+import android.content.Context;
 import android.graphics.drawable.Drawable;
 import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.view.Display;
 import android.view.View;
+import android.view.View.OnAttachStateChangeListener;
 import android.view.ViewTreeObserver;
+import android.view.WindowManager;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.tests.Util;
+import com.bumptech.glide.util.Preconditions;
+import java.util.HashSet;
 import java.util.List;
+import java.util.Set;
 import java.util.concurrent.CopyOnWriteArrayList;
 import org.junit.After;
 import org.junit.Before;
@@ -31,9 +41,11 @@
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.RealObject;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowView;
 
@@ -48,6 +60,7 @@
   @Mock private SizeReadyCallback cb;
   @Mock private Request request;
   private int sdkVersion;
+  private AttachStateTarget attachStateTarget;
 
   @Before
   public void setUp() {
@@ -55,6 +68,7 @@ public void setUp() {
     MockitoAnnotations.initMocks(this);
     view = new View(RuntimeEnvironment.application);
     target = new TestViewTarget(view);
+    attachStateTarget = new AttachStateTarget(view);
 
     shadowView = Shadow.extract(view);
     shadowObserver = Shadow.extract(view.getViewTreeObserver());
@@ -63,6 +77,7 @@ public void setUp() {
   @After
   public void tearDown() {
     Util.setSdkVersionInt(sdkVersion);
+    ViewTarget.SizeDeterminer.maxDisplayLength = null;
   }
 
   @Test
@@ -123,46 +138,54 @@ public void testSizeCallbackIsCalledSynchronouslyIfLayoutParamsConcreteSizeSet()
   }
 
   @Test
-  public void getSize_withBothWrapContent_returnsSizeOriginal() {
+  public void getSize_withBothWrapContent_usesDisplayDimens() {
     LayoutParams layoutParams =
         new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
     view.setLayoutParams(layoutParams);
     shadowView.setIsLaidOut(true);
 
+    setDisplayDimens(200, 300);
+
     target.getSize(cb);
 
-    verify(cb).onSizeReady(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
+    verify(cb).onSizeReady(300, 300);
   }
 
   @Test
-  public void getSize_withWrapContentWidthAndValidHeight_usesSizeOriginalWidthValidHeight() {
+  public void getSize_withWrapContentWidthAndValidHeight_usesDisplayDimenAndValidHeight() {
     int height = 100;
     LayoutParams params = new LayoutParams(LayoutParams.WRAP_CONTENT, height);
     view.setLayoutParams(params);
     shadowView.setIsLaidOut(true);
 
+    setDisplayDimens(100, 200);
+
     target.getSize(cb);
 
-    verify(cb).onSizeReady(Target.SIZE_ORIGINAL, height);
+    verify(cb).onSizeReady(200, height);
   }
 
   @Test
-  public void getSize_withWrapContentHeightAndValidWidth_returnsWidthAndSizeOriginalHeight() {
+  public void getSize_withWrapContentHeightAndValidWidth_returnsWidthAndDisplayDimen() {
     int width = 100;
     LayoutParams params = new LayoutParams(width, LayoutParams.WRAP_CONTENT);
     view.setLayoutParams(params);
     shadowView.setIsLaidOut(true);
 
+    setDisplayDimens(200, 100);
+
     target.getSize(cb);
 
-    verify(cb).onSizeReady(width, Target.SIZE_ORIGINAL);
+    verify(cb).onSizeReady(width, 200);
   }
 
   @Test
-  public void getSize_withWrapContentWidthAndMatchParentHeight_usesSizeOriginalWidthAndHeight() {
+  public void getSize_withWrapContentWidthAndMatchParentHeight_usesDisplayDimenWidthAndHeight() {
     LayoutParams params = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT);
     view.setLayoutParams(params);
 
+    setDisplayDimens(500, 600);
+
     target.getSize(cb);
 
     verify(cb, never()).onSizeReady(anyInt(), anyInt());
@@ -174,25 +197,28 @@ public void getSize_withWrapContentWidthAndMatchParentHeight_usesSizeOriginalWid
 
     shadowObserver.fireOnPreDrawListeners();
 
-    verify(cb).onSizeReady(Target.SIZE_ORIGINAL, height);
+    verify(cb).onSizeReady(600, height);
   }
 
   @Test
-  public void getSize_withMatchParentWidthAndWrapContentHeight_usesWidthAndSizeOriginalHeight() {
+  public void getSize_withMatchParentWidthAndWrapContentHeight_usesWidthAndDisplayDimenHeight() {
     LayoutParams params = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
     view.setLayoutParams(params);
 
+    setDisplayDimens(300, 400);
+
     target.getSize(cb);
 
     verify(cb, never()).onSizeReady(anyInt(), anyInt());
 
+
     int width = 32;
     shadowView
         .setWidth(width)
         .setIsLaidOut(true);
     shadowObserver.fireOnPreDrawListeners();
 
-    verify(cb).onSizeReady(width, Target.SIZE_ORIGINAL);
+    verify(cb).onSizeReady(width, 400);
   }
 
   @Test
@@ -415,7 +441,7 @@ public void getSize_withLayoutParams_emptyParams_notLaidOutOrLayoutRequested_cal
   }
 
   @Test
-  public void getSize_withValidWidthAndHeight_preV19_layoutRequested_doesNotCallSizeReady() {
+  public void getSize_withValidWidthAndHeight_preV19_layoutRequested_callsSizeReady() {
     Util.setSdkVersionInt(18);
     shadowView
         .setWidth(100)
@@ -424,7 +450,7 @@ public void getSize_withValidWidthAndHeight_preV19_layoutRequested_doesNotCallSi
 
     target.getSize(cb);
 
-    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+    verify(cb).onSizeReady(100, 100);
   }
 
   @Test
@@ -441,9 +467,172 @@ public void getSize_withWidthAndHeightEqualToPadding_doesNotCallSizeReady() {
     verify(cb, never()).onSizeReady(anyInt(), anyInt());
   }
 
+  private void setDisplayDimens(Integer width, Integer height) {
+    WindowManager windowManager =
+        (WindowManager) RuntimeEnvironment.application.getSystemService(Context.WINDOW_SERVICE);
+    Display display = Preconditions.checkNotNull(windowManager).getDefaultDisplay();
+    if (width != null) {
+      Shadows.shadowOf(display).setWidth(width);
+    }
+
+    if (height != null) {
+      Shadows.shadowOf(display).setHeight(height);
+    }
+  }
+
+  @Test
+  public void clearOnDetach_onDetach_withNullRequest_doesNothing() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(null);
+    shadowView.callOnAttachedToWindow();
+  }
+
+  // This behavior isn't clearly correct, but it doesn't seem like there's any harm to clear an
+  // already cleared request, so we might as well avoid the extra check/complexity in the code.
+  @Test
+  public void clearOnDetach_onDetach_withClearedRequest_clearsRequest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isCleared()).thenReturn(true);
+    shadowView.callOnDetachedFromWindow();
+
+    verify(request).clear();
+  }
+
+  @Test
+  public void clearOnDetach_onDetach_withRunningRequest_pausesRequestOnce() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    shadowView.callOnDetachedFromWindow();
+
+    verify(request).clear();
+  }
+
+  @Test
+  public void clearOnDetach_onDetach_afterOnLoadCleared_removesListener() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.onLoadCleared(/*placeholder=*/ null);
+    attachStateTarget.setRequest(request);
+    shadowView.callOnDetachedFromWindow();
+
+    verify(request, never()).clear();
+  }
+
+  @Test
+  public void clearOnDetach_moreThanOnce_registersObserverOnce() {
+    attachStateTarget
+        .clearOnDetach()
+        .clearOnDetach();
+
+    assertThat(shadowView.attachStateListeners).hasSize(1);
+  }
+
+  @Test
+  public void clearOnDetach_onDetach_afterMultipleClearOnDetaches_removesListener() {
+    attachStateTarget
+        .clearOnDetach()
+        .clearOnDetach()
+        .clearOnDetach();
+    attachStateTarget.onLoadCleared(/*placeholder=*/ null);
+    attachStateTarget.setRequest(request);
+    shadowView.callOnDetachedFromWindow();
+
+    verify(request, never()).clear();
+  }
+
+  // This behavior isn't clearly correct, but it doesn't seem like there's any harm to clear an
+  // already cleared request, so we might as well avoid the extra check/complexity in the code.
+  @Test
+  public void clearOnDetach_onDetach_afterLoadCleared_clearsRequest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isCleared()).thenReturn(true);
+    shadowView.callOnDetachedFromWindow();
+
+    verify(request).clear();
+  }
+
+  @Test
+  public void clearOnDetach_onAttach_withNullRequest_doesNothing() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(null);
+    shadowView.callOnAttachedToWindow();
+  }
+
+  @Test
+  public void clearOnDetach_onAttach_withRunningRequest_doesNotBeginRequest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isCleared()).thenReturn(false);
+    shadowView.callOnAttachedToWindow();
+
+    verify(request, never()).begin();
+  }
+
+  @Test
+  public void clearOnDetach_onAttach_withClearedRequest_beginsRequest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isCleared()).thenReturn(true);
+    shadowView.callOnAttachedToWindow();
+
+    verify(request).begin();
+  }
+
+  @Test
+  public void clearOnDetach_afterLoadClearedAndRestarted_onAttach_beingsRequest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isCleared()).thenReturn(true);
+    attachStateTarget.onLoadCleared(/*placeholder=*/ null);
+    attachStateTarget.onLoadStarted(/*placeholder=*/ null);
+    shadowView.callOnAttachedToWindow();
+
+    verify(request).begin();
+  }
+
+  @Test
+  public void clearOnDetach_onAttach_afterLoadCleared_doesNotBeingRequest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isCleared()).thenReturn(true);
+    attachStateTarget.onLoadCleared(/*placeholder=*/ null);
+    shadowView.callOnAttachedToWindow();
+
+    verify(request, never()).begin();
+  }
+
+  @Test
+  public void onLoadStarted_withoutClearOnDetach_doesNotAddListener() {
+    attachStateTarget.onLoadStarted(/*placeholder=*/ null);
+
+    assertThat(shadowView.attachStateListeners).isEmpty();
+  }
+
+  // containsExactly does not need its result checked.
+  @SuppressWarnings("ResultOfMethodCallIgnored")
+  @Test
+  public void onLoadCleared_withoutClearOnDetach_doesNotRemoveListeners() {
+    OnAttachStateChangeListener expected = new OnAttachStateChangeListener() {
+      @Override
+      public void onViewAttachedToWindow(View v) {
+      }
+
+      @Override
+      public void onViewDetachedFromWindow(View v) {
+      }
+    };
+    shadowView.addOnAttachStateChangeListener(expected);
+
+    attachStateTarget.onLoadCleared(/*placeholder=*/ null);
+
+    assertThat(shadowView.attachStateListeners).containsExactly(expected);
+  }
+
   @Implements(ViewTreeObserver.class)
-  public static class PreDrawShadowViewTreeObserver {
-    private CopyOnWriteArrayList<OnPreDrawListener> preDrawListeners = new CopyOnWriteArrayList<>();
+  public static final class PreDrawShadowViewTreeObserver {
+    private final CopyOnWriteArrayList<OnPreDrawListener> preDrawListeners =
+        new CopyOnWriteArrayList<>();
     private boolean isAlive = true;
 
     @SuppressWarnings("unused")
@@ -461,6 +650,7 @@ public void removeOnPreDrawListener(OnPreDrawListener listener) {
     }
 
     @Implementation
+    @SuppressWarnings("WeakerAccess")
     public boolean isAlive() {
       return isAlive;
     }
@@ -471,28 +661,32 @@ private void checkIsAlive() {
       }
     }
 
-    public void setIsAlive(boolean isAlive) {
+    void setIsAlive(@SuppressWarnings("SameParameterValue") boolean isAlive) {
       this.isAlive = isAlive;
     }
 
-    public void fireOnPreDrawListeners() {
+    void fireOnPreDrawListeners() {
       for (OnPreDrawListener listener : preDrawListeners) {
         listener.onPreDraw();
       }
     }
 
-    public List<OnPreDrawListener> getPreDrawListeners() {
+    List<OnPreDrawListener> getPreDrawListeners() {
       return preDrawListeners;
     }
   }
 
+  // Shadows require stronger access and unused values.
+  @SuppressWarnings({"UnusedReturnValue", "WeakerAccess", "unused"})
   @Implements(View.class)
-  public static class SizedShadowView extends ShadowView {
+  public static final class SizedShadowView extends ShadowView {
+    @RealObject private View view;
     private int width;
     private int height;
     private LayoutParams layoutParams;
     private boolean isLaidOut;
     private boolean isLayoutRequested;
+    final Set<OnAttachStateChangeListener> attachStateListeners = new HashSet<>();
 
     public SizedShadowView setWidth(int width) {
       this.width = width;
@@ -504,17 +698,54 @@ public SizedShadowView setHeight(int height) {
       return this;
     }
 
+    @Implementation
+    public void addOnAttachStateChangeListener(OnAttachStateChangeListener listener) {
+      attachStateListeners.add(listener);
+    }
+
+    @Implementation
+    public void removeOnAttachStateChangeListener(OnAttachStateChangeListener listener) {
+      attachStateListeners.remove(listener);
+    }
+
+    @Implementation
+    public void onAttachedToWindow() {
+      for (OnAttachStateChangeListener listener : attachStateListeners) {
+        listener.onViewAttachedToWindow(view);
+      }
+    }
+
+    @Implementation
+    public void onDetachedFromWindow() {
+      for (OnAttachStateChangeListener listener : attachStateListeners) {
+        listener.onViewDetachedFromWindow(view);
+      }
+    }
+
+    @Override
+    public void callOnAttachedToWindow() {
+      super.callOnAttachedToWindow();
+    }
+
+    @Override
+    public void callOnDetachedFromWindow() {
+      super.callOnDetachedFromWindow();
+    }
+
+    @Implementation
     public SizedShadowView setLayoutParams(LayoutParams layoutParams) {
       this.layoutParams = layoutParams;
       return this;
     }
 
+    @Implementation
     public SizedShadowView setIsLaidOut(boolean isLaidOut) {
       this.isLaidOut = isLaidOut;
       return this;
     }
 
     @Implementation
+    @Override
     public void requestLayout() {
       isLayoutRequested = true;
     }
@@ -545,30 +776,49 @@ public LayoutParams getLayoutParams() {
     }
   }
 
-  private static class TestViewTarget extends ViewTarget<View, Object> {
-
-    public TestViewTarget(View view) {
+  private static final class AttachStateTarget extends ViewTarget<View, Object> {
+    AttachStateTarget(View view) {
       super(view);
     }
 
     @Override
-    public void onLoadStarted(Drawable placeholder) {
+    public void onResourceReady(@NonNull Object resource,
+        @Nullable Transition<? super Object> transition) { }
+  }
 
+  private static final class TestViewTarget extends ViewTarget<View, Object> {
+
+    TestViewTarget(View view) {
+      super(view);
     }
 
+    // We're intentionally avoiding the super call.
+    @SuppressWarnings("MissingSuperCall")
     @Override
-    public void onLoadFailed(Drawable errorDrawable) {
-
+    public void onResourceReady(@NonNull Object resource,
+        @Nullable Transition<? super Object> transition) {
+      // Avoid calling super.
     }
 
+    // We're intentionally avoiding the super call.
+    @SuppressWarnings("MissingSuperCall")
     @Override
-    public void onResourceReady(Object resource, Transition<? super Object> transition) {
-
+    public void onLoadCleared(@Nullable Drawable placeholder) {
+      // Avoid calling super.
     }
 
+    // We're intentionally avoiding the super call.
+    @SuppressWarnings("MissingSuperCall")
     @Override
-    public void onLoadCleared(Drawable placeholder) {
+    public void onLoadStarted(@Nullable Drawable placeholder) {
+      // Avoid calling super.
+    }
 
+    // We're intentionally avoiding the super call.
+    @SuppressWarnings("MissingSuperCall")
+    @Override
+    public void onLoadFailed(@Nullable Drawable errorDrawable) {
+      // Avoid calling super.
     }
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java b/library/test/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java b/library/test/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
similarity index 92%
rename from library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
index 022277447..e89b6f8bc 100644
--- a/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
@@ -63,10 +63,10 @@ public void transition_withCurrentDrawable_returnsTrue() {
 
   @SuppressWarnings("unchecked")
   private static class CrossFadeHarness {
-    Drawable current = new ColorDrawable(Color.GRAY);
-    ViewAdapter adapter = mock(ViewAdapter.class);
-    int duration = 200;
-    DrawableCrossFadeTransition animation =
+    final Drawable current = new ColorDrawable(Color.GRAY);
+    final ViewAdapter adapter = mock(ViewAdapter.class);
+    final int duration = 200;
+    final DrawableCrossFadeTransition animation =
         new DrawableCrossFadeTransition(duration, true /*isCrossFadeEnabled*/);
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/ViewAnimationTest.java b/library/test/src/test/java/com/bumptech/glide/request/transition/ViewAnimationTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/request/transition/ViewAnimationTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/transition/ViewAnimationTest.java
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyAnimationTest.java b/library/test/src/test/java/com/bumptech/glide/request/transition/ViewPropertyAnimationTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyAnimationTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/transition/ViewPropertyAnimationTest.java
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyViewTransitionAnimationFactoryTest.java b/library/test/src/test/java/com/bumptech/glide/request/transition/ViewPropertyViewTransitionAnimationFactoryTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyViewTransitionAnimationFactoryTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/transition/ViewPropertyViewTransitionAnimationFactoryTest.java
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/ViewTransitionAnimationFactoryTest.java b/library/test/src/test/java/com/bumptech/glide/request/transition/ViewTransitionAnimationFactoryTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/request/transition/ViewTransitionAnimationFactoryTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/transition/ViewTransitionAnimationFactoryTest.java
diff --git a/library/src/test/java/com/bumptech/glide/resize/load/ExifTest.java b/library/test/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
similarity index 95%
rename from library/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
rename to library/test/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
index 95eaca505..1efd9b736 100644
--- a/library/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
@@ -21,7 +21,7 @@
 
   private ArrayPool byteArrayPool;
 
-  private InputStream open(String imageName) throws IOException {
+  private InputStream open(String imageName) {
     return TestResourceUtil.openResource(getClass(), "exif-orientation-examples/" + imageName);
   }
 
@@ -72,11 +72,11 @@ public void testPortrait() throws IOException {
   @Test
   public void testHandlesInexactSizesInByteArrayPools() {
     for (int i = 1; i <= 8; i++) {
-      byteArrayPool.put(new byte[ArrayPool.STANDARD_BUFFER_SIZE_BYTES], byte[].class);
+      byteArrayPool.put(new byte[ArrayPool.STANDARD_BUFFER_SIZE_BYTES]);
       assertOrientation("Portrait", i);
     }
     for (int i = 1; i <= 8; i++) {
-      byteArrayPool.put(new byte[ArrayPool.STANDARD_BUFFER_SIZE_BYTES], byte[].class);
+      byteArrayPool.put(new byte[ArrayPool.STANDARD_BUFFER_SIZE_BYTES]);
       assertOrientation("Landscape", i);
     }
   }
diff --git a/library/test/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java b/library/test/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java
new file mode 100644
index 000000000..0d2c90bb8
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java
@@ -0,0 +1,83 @@
+package com.bumptech.glide.signature;
+
+import static org.junit.Assert.assertNotNull;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import android.content.Context;
+import android.content.pm.PackageManager.NameNotFoundException;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.tests.KeyTester;
+import java.io.UnsupportedEncodingException;
+import java.security.NoSuchAlgorithmException;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Answers;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class ApplicationVersionSignatureTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
+  private Context context;
+
+  @Before
+  public void setUp() {
+    context = RuntimeEnvironment.application;
+  }
+
+  @After
+  public void tearDown() {
+    ApplicationVersionSignature.reset();
+  }
+
+  @Test
+  public void testCanGetKeyForSignature() {
+    Key key = ApplicationVersionSignature.obtain(context);
+    assertNotNull(key);
+  }
+
+  @Test
+  public void testKeyForSignatureIsTheSameAcrossCallsInTheSamePackage()
+      throws NoSuchAlgorithmException, UnsupportedEncodingException {
+    keyTester
+        .addEquivalenceGroup(
+            ApplicationVersionSignature.obtain(context),
+            ApplicationVersionSignature.obtain(context))
+        .addEquivalenceGroup(new ObjectKey("test"))
+        .addRegressionTest(
+            ApplicationVersionSignature.obtain(context),
+            "5feceb66ffc86f38d952786c6d696c79c2dbc239dd4e91b46729d73a27fb57e9")
+        .test();
+  }
+
+  @Test
+  public void testUnresolvablePackageInfo() throws NameNotFoundException {
+    Context context = mock(Context.class, Answers.RETURNS_DEEP_STUBS.get());
+    String packageName = "my.package";
+    when(context.getPackageName()).thenReturn(packageName);
+    when(context.getPackageManager().getPackageInfo(packageName, 0))
+        .thenThrow(new NameNotFoundException("test"));
+
+    Key key = ApplicationVersionSignature.obtain(context);
+
+    assertNotNull(key);
+  }
+
+  @Test
+  public void testMissingPackageInfo() throws NameNotFoundException {
+    Context context = mock(Context.class, Answers.RETURNS_DEEP_STUBS.get());
+    String packageName = "my.package";
+    when(context.getPackageName()).thenReturn(packageName);
+    when(context.getPackageManager().getPackageInfo(packageName, 0)).thenReturn(null);
+
+    Key key = ApplicationVersionSignature.obtain(context);
+
+    assertNotNull(key);
+  }
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/signature/EmptySignatureTest.java b/library/test/src/test/java/com/bumptech/glide/signature/EmptySignatureTest.java
new file mode 100644
index 000000000..a10b26cd7
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/signature/EmptySignatureTest.java
@@ -0,0 +1,27 @@
+package com.bumptech.glide.signature;
+
+
+import static org.mockito.Mockito.mock;
+
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.tests.KeyTester;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class EmptySignatureTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
+
+  @Test
+  public void testEquals() {
+    keyTester
+        .addEquivalenceGroup(
+            EmptySignature.obtain(),
+            EmptySignature.obtain())
+        .addEquivalenceGroup(mock(Key.class))
+        .addEmptyDigestRegressionTest(EmptySignature.obtain())
+        .test();
+  }
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java b/library/test/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java
new file mode 100644
index 000000000..e972c3e2e
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java
@@ -0,0 +1,27 @@
+package com.bumptech.glide.signature;
+
+import com.bumptech.glide.tests.KeyTester;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class MediaStoreSignatureTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
+
+  @Test
+  public void equalsHashCodeAndDigest() {
+    keyTester
+        .addEquivalenceGroup(
+            new MediaStoreSignature("first", 100, 1),
+            new MediaStoreSignature("first", 100, 1))
+        .addEquivalenceGroup(new MediaStoreSignature("second", 100, 1))
+        .addEquivalenceGroup(new MediaStoreSignature("first", 200, 1))
+        .addEquivalenceGroup(new MediaStoreSignature("first", 100, 2))
+        .addRegressionTest(
+            new MediaStoreSignature("first", 100, 1),
+            "04959925006b21081000fd10835cc376343c0e922df0bd7346897ede6f958adf")
+        .test();
+  }
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/signature/ObjectKeyTest.java b/library/test/src/test/java/com/bumptech/glide/signature/ObjectKeyTest.java
new file mode 100644
index 000000000..f5656d4a0
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/signature/ObjectKeyTest.java
@@ -0,0 +1,26 @@
+package com.bumptech.glide.signature;
+
+import com.bumptech.glide.tests.KeyTester;
+import java.security.NoSuchAlgorithmException;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class ObjectKeyTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
+
+  @Test
+  public void testEqualsHashCodeAndDigest() throws NoSuchAlgorithmException {
+    Object object = new Object();
+    keyTester
+        .addEquivalenceGroup(new ObjectKey(object), new ObjectKey(object))
+        .addEquivalenceGroup(new ObjectKey(new Object()))
+        .addEquivalenceGroup(new ObjectKey("test"), new ObjectKey("test"))
+        .addRegressionTest(
+            new ObjectKey("test"),
+            "9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08")
+        .test();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/tests/BackgroundUtil.java b/library/test/src/test/java/com/bumptech/glide/tests/BackgroundUtil.java
similarity index 69%
rename from library/src/test/java/com/bumptech/glide/tests/BackgroundUtil.java
rename to library/test/src/test/java/com/bumptech/glide/tests/BackgroundUtil.java
index 796a09240..3800e8b77 100644
--- a/library/src/test/java/com/bumptech/glide/tests/BackgroundUtil.java
+++ b/library/test/src/test/java/com/bumptech/glide/tests/BackgroundUtil.java
@@ -1,8 +1,9 @@
 package com.bumptech.glide.tests;
 
-public class BackgroundUtil {
-  public interface BackgroundTester {
-    public void runTest() throws Exception;
+public final class BackgroundUtil {
+
+  private BackgroundUtil() {
+    // Utility class.
   }
 
   public static void testInBackground(BackgroundTester test) throws InterruptedException {
@@ -14,11 +15,11 @@ public static void testInBackground(BackgroundTester test) throws InterruptedExc
     }
   }
 
-  private static class TestThread extends Thread {
+  private static final class TestThread extends Thread {
+    private final BackgroundTester test;
     private Exception exception;
-    private BackgroundTester test;
 
-    public TestThread(BackgroundTester test) {
+    private TestThread(BackgroundTester test) {
       this.test = test;
     }
 
@@ -32,4 +33,8 @@ public void run() {
       }
     }
   }
+
+  public interface BackgroundTester {
+    void runTest();
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/tests/ContentResolverShadow.java b/library/test/src/test/java/com/bumptech/glide/tests/ContentResolverShadow.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/tests/ContentResolverShadow.java
rename to library/test/src/test/java/com/bumptech/glide/tests/ContentResolverShadow.java
diff --git a/library/src/test/java/com/bumptech/glide/tests/GlideShadowLog.java b/library/test/src/test/java/com/bumptech/glide/tests/GlideShadowLog.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/tests/GlideShadowLog.java
rename to library/test/src/test/java/com/bumptech/glide/tests/GlideShadowLog.java
diff --git a/library/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java b/library/test/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java
similarity index 66%
rename from library/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java
rename to library/test/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java
index 7b94a888c..fede54a45 100644
--- a/library/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java
+++ b/library/test/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java
@@ -6,13 +6,21 @@
 import android.os.MessageQueue;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
 import org.robolectric.shadows.ShadowLooper;
 
 @Implements(Looper.class)
 public class GlideShadowLooper extends ShadowLooper {
+  public static MessageQueue queue = mock(MessageQueue.class);
 
   @Implementation
   public static MessageQueue myQueue() {
-    return mock(MessageQueue.class);
+    return queue;
+  }
+
+  @Resetter
+  @Override
+  public void reset() {
+    queue = mock(MessageQueue.class);
   }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/tests/KeyTester.java b/library/test/src/test/java/com/bumptech/glide/tests/KeyTester.java
new file mode 100644
index 000000000..8a064db54
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/tests/KeyTester.java
@@ -0,0 +1,153 @@
+package com.bumptech.glide.tests;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assert_;
+import static org.junit.Assert.fail;
+
+import android.support.annotation.CheckResult;
+import android.support.annotation.NonNull;
+import com.bumptech.glide.load.Key;
+import com.google.common.base.Equivalence;
+import com.google.common.testing.EquivalenceTester;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.Arrays;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Map.Entry;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+public final class KeyTester implements TestRule {
+  private static final String EMPTY_DIGEST_STRING =
+      "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
+  // Use LinkedHashMap to keep iteration based on insertion order.
+  private final Map<Key, String> regressionTests = new LinkedHashMap<>();
+  private final Sha256 sha256 = new Sha256();
+  private final EquivalenceTester<Key> tester = EquivalenceTester.of(new KeyEquivalence(sha256));
+  private boolean isUsedWithoutCallingTest;
+  private boolean isUsedAsRule;
+
+  @Override
+  public Statement apply(final Statement base, Description description) {
+    return new Statement() {
+
+      @Override
+      public void evaluate() throws Throwable {
+          isUsedAsRule = true;
+          base.evaluate();
+          if (isUsedWithoutCallingTest) {
+            fail("You used KeyTester but failed to call test()!");
+          }
+      }
+    };
+  }
+
+  private void assertUsedAsRule() {
+    if (!isUsedAsRule) {
+      fail("You must use KeyTester as an @Rule");
+    }
+  }
+
+  @CheckResult
+  public KeyTester addEquivalenceGroup(Key first, Key... rest) {
+    assertUsedAsRule();
+    isUsedWithoutCallingTest = true;
+    tester.addEquivalenceGroup(first, rest);
+    return this;
+  }
+
+  @CheckResult
+  public KeyTester addRegressionTest(Key key, String expectedDigest) {
+    assertUsedAsRule();
+    if (EMPTY_DIGEST_STRING.equals(expectedDigest)) {
+      throw new IllegalArgumentException("Expected digest is empty, if this is intended use "
+          + "addEmptyDigestRegressionTest instead");
+    }
+    return addRegressionTestInternal(key, expectedDigest);
+  }
+
+  @CheckResult
+  public KeyTester addEmptyDigestRegressionTest(Key key) {
+    assertUsedAsRule();
+    return addRegressionTestInternal(key, EMPTY_DIGEST_STRING);
+  }
+
+  private KeyTester addRegressionTestInternal(Key key, String expectedDigest) {
+    isUsedWithoutCallingTest = true;
+    String oldValue = regressionTests.put(key, expectedDigest);
+    if (oldValue != null) {
+      throw new IllegalArgumentException(
+          "Given multiple values for: " + key + " old: " + oldValue + " new: " + expectedDigest);
+    }
+    return this;
+  }
+
+  public void test() {
+    assertUsedAsRule();
+    isUsedWithoutCallingTest = false;
+    tester.test();
+
+    assertThat(regressionTests).isNotEmpty();
+    int i = 1;
+    for (Entry<Key, String> entry : regressionTests.entrySet()) {
+      assert_()
+          .withMessage(
+              "Unexpected digest for regression test [" + i + "]: with key: " + entry.getKey())
+          .that(sha256.getStringDigest(entry.getKey())).isEqualTo(entry.getValue());
+      i++;
+    }
+  }
+
+  private static final class Sha256 {
+
+    private final MessageDigest digest;
+
+    Sha256() {
+      try {
+        digest = MessageDigest.getInstance("SHA-256");
+      } catch (NoSuchAlgorithmException e) {
+        throw new RuntimeException(e);
+      }
+    }
+
+    private byte[] getDigest(Key key) {
+      try {
+        key.updateDiskCacheKey(digest);
+        return digest.digest();
+      } finally {
+        digest.reset();
+      }
+    }
+
+
+    String getStringDigest(Key key) {
+      return com.bumptech.glide.util.Util.sha256BytesToHex(getDigest(key));
+    }
+  }
+
+  /**
+   * Tests equals, hashcode and digest methods of {@link Key}s.
+   */
+  private static final class KeyEquivalence extends Equivalence<Key> {
+
+    private final Sha256 sha256;
+
+    KeyEquivalence(Sha256 sha256) {
+      this.sha256 = sha256;
+    }
+
+    @Override
+    protected boolean doEquivalent(@NonNull Key a, @NonNull Key b) {
+      byte[] aDigest = sha256.getDigest(a);
+      byte[] bDigest = sha256.getDigest(b);
+      return a.equals(b) && Arrays.equals(aDigest, bDigest);
+    }
+
+    @Override
+    protected int doHash(@NonNull Key key) {
+      return key.hashCode();
+    }
+  }
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/tests/TearDownGlide.java b/library/test/src/test/java/com/bumptech/glide/tests/TearDownGlide.java
new file mode 100644
index 000000000..d1814f48f
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/tests/TearDownGlide.java
@@ -0,0 +1,26 @@
+package com.bumptech.glide.tests;
+
+import com.bumptech.glide.Glide;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+/**
+ * Clears out Glide's disk cache and the Glide singleton after every test method.
+ */
+public final class TearDownGlide implements TestRule {
+  @Override
+  public Statement apply(final Statement base, Description description) {
+    return new Statement() {
+      @Override
+      public void evaluate() throws Throwable {
+        try {
+          base.evaluate();
+        } finally {
+          Glide.tearDown();
+
+        }
+      }
+    };
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/tests/Util.java b/library/test/src/test/java/com/bumptech/glide/tests/Util.java
similarity index 89%
rename from library/src/test/java/com/bumptech/glide/tests/Util.java
rename to library/test/src/test/java/com/bumptech/glide/tests/Util.java
index e80796ba2..bcd5d34f4 100644
--- a/library/src/test/java/com/bumptech/glide/tests/Util.java
+++ b/library/test/src/test/java/com/bumptech/glide/tests/Util.java
@@ -27,10 +27,6 @@
 // FIXME move to testutil module
 public class Util {
 
-  public static String getExpectedClassId(Class<?> clazz) {
-    return clazz.getSimpleName() + "." + clazz.getPackage().getName();
-  }
-
   /**
    * Gives the proper generic type to the {@link ArgumentCaptor}.
    * Only useful when the captor's {@code T} is also a generic type.
@@ -46,7 +42,7 @@ public static DataSource isADataSource() {
   }
 
   public static Context anyContext() {
-    return any(Context.class);
+    return any();
   }
 
   /**
@@ -106,8 +102,8 @@ public static void setSdkVersionInt(int version) {
     ReflectionHelpers.setStaticField(Build.VERSION.class, "SDK_INT", version);
   }
 
-  public static class WriteDigest implements Answer<Void> {
-    private String toWrite;
+  public static final class WriteDigest implements Answer<Void> {
+    private final String toWrite;
 
     public WriteDigest(String toWrite) {
       this.toWrite = toWrite;
@@ -116,13 +112,14 @@ public WriteDigest(String toWrite) {
     @Override
     public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
       MessageDigest md = (MessageDigest) invocationOnMock.getArguments()[0];
-      md.update(toWrite.getBytes());
+      md.update(toWrite.getBytes("UTF-8"));
       return null;
     }
   }
 
-  public static class ReturnsSelfAnswer implements Answer<Object> {
+  public static final class ReturnsSelfAnswer implements Answer<Object> {
 
+    @Override
     public Object answer(InvocationOnMock invocation) throws Throwable {
       Object mock = invocation.getMock();
       if (invocation.getMethod().getReturnType().isInstance(mock)) {
@@ -133,9 +130,9 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
     }
   }
 
-  public static class CallDataReady<T> implements Answer<Void> {
+  public static final class CallDataReady<T> implements Answer<Void> {
 
-    private T data;
+    private final T data;
 
     public CallDataReady(T data) {
       this.data = data;
@@ -151,7 +148,7 @@ public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
     }
   }
 
-  public static class CreateBitmap implements Answer<Bitmap> {
+  public static final class CreateBitmap implements Answer<Bitmap> {
 
     @Override
     public Bitmap answer(InvocationOnMock invocation) throws Throwable {
diff --git a/library/src/test/java/com/bumptech/glide/util/ByteBufferUtilTest.java b/library/test/src/test/java/com/bumptech/glide/util/ByteBufferUtilTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/util/ByteBufferUtilTest.java
rename to library/test/src/test/java/com/bumptech/glide/util/ByteBufferUtilTest.java
diff --git a/library/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java b/library/test/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java
similarity index 95%
rename from library/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java
rename to library/test/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java
index 848321fe1..a9a912613 100644
--- a/library/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java
@@ -20,7 +20,7 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class ContentLengthInputStreamTest {
-  @Mock InputStream wrapped;
+  @Mock private InputStream wrapped;
 
   @Before
   public void setUp() {
@@ -95,6 +95,7 @@ public void testRead_whenReturnsLessThanZeroWithoutReadingAllContent_throwsIOExc
     when(wrapped.read()).thenReturn(-1);
 
     try {
+      //noinspection ResultOfMethodCallIgnored
       is.read();
       fail("Failed to throw expected exception");
     } catch (IOException e) {
@@ -110,6 +111,7 @@ public void testReadBytes_whenReturnsLessThanZeroWithoutReadingAllContent_throws
     when(wrapped.read(any(byte[].class), anyInt(), anyInt())).thenReturn(-1);
 
     try {
+      //noinspection ResultOfMethodCallIgnored
       is.read(new byte[10], 0, 0);
       fail("Failed to throw expected exception");
     } catch (IOException e) {
@@ -121,6 +123,7 @@ public void testReadBytes_whenReturnsLessThanZeroWithoutReadingAllContent_throws
   public void testRead_whenReturnsLessThanZeroWithInvalidLength_doesNotThrow() throws IOException {
     InputStream is = ContentLengthInputStream.obtain(wrapped, "invalid_length");
     when(wrapped.read()).thenReturn(-1);
+    //noinspection ResultOfMethodCallIgnored
     is.read();
   }
 
@@ -129,6 +132,7 @@ public void testReadBytes_whenReturnsLessThanZeroWithInvalidLength_doesNotThrow(
       throws IOException {
     InputStream is = ContentLengthInputStream.obtain(wrapped, "invalid_length");
     when(wrapped.read(any(byte[].class), anyInt(), anyInt())).thenReturn(-1);
+    //noinspection ResultOfMethodCallIgnored
     is.read(new byte[10], 0, 0);
   }
 
diff --git a/library/src/test/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java b/library/test/src/test/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java
rename to library/test/src/test/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java
diff --git a/library/src/test/java/com/bumptech/glide/util/FixedPreloadSizeProviderTest.java b/library/test/src/test/java/com/bumptech/glide/util/FixedPreloadSizeProviderTest.java
similarity index 86%
rename from library/src/test/java/com/bumptech/glide/util/FixedPreloadSizeProviderTest.java
rename to library/test/src/test/java/com/bumptech/glide/util/FixedPreloadSizeProviderTest.java
index 89cab6985..8418cc85d 100644
--- a/library/src/test/java/com/bumptech/glide/util/FixedPreloadSizeProviderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/util/FixedPreloadSizeProviderTest.java
@@ -11,6 +11,8 @@
 @Config(manifest = Config.NONE, sdk = 18)
 public class FixedPreloadSizeProviderTest {
 
+  // containsExactly doesn't need a return value check.
+  @SuppressWarnings("ResultOfMethodCallIgnored")
   @Test
   public void testReturnsGivenSize() {
     int width = 500;
diff --git a/library/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java b/library/test/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java
similarity index 99%
rename from library/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java
rename to library/test/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java
index 1e18b4203..5684e3c13 100644
--- a/library/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java
@@ -135,7 +135,7 @@ public void testReturnsEndOfStream_whenSkipping_withZeroBytesRemainingInMarkLimi
     is.mark(MARK_LIMIT);
 
     assertEquals(MARK_LIMIT, is.skip(DATA_SIZE));
-    assertEquals(-1, is.skip(1));
+    assertEquals(0, is.skip(1));
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/util/UtilTest.java b/library/test/src/test/java/com/bumptech/glide/util/UtilTest.java
similarity index 85%
rename from library/src/test/java/com/bumptech/glide/util/UtilTest.java
rename to library/test/src/test/java/com/bumptech/glide/util/UtilTest.java
index 92d16e95b..416095784 100644
--- a/library/src/test/java/com/bumptech/glide/util/UtilTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/util/UtilTest.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.util;
 
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 
 import android.graphics.Bitmap;
@@ -9,7 +10,7 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(manifest = Config.NONE, sdk = 27)
 public class UtilTest {
 
   @Test
@@ -70,4 +71,12 @@ public void testReturnsLargestSizeForNullConfig() {
     int size = Util.getBitmapByteSize(width, height, null);
     assertEquals(width * height * 4, size);
   }
+
+  @Test
+  public void getBitmapByteSize_withRGBA_F16_returnsCorrectSize() {
+    int width = 100;
+    int height = 200;
+    assertThat(Util.getBitmapByteSize(width, height, Bitmap.Config.RGBA_F16))
+        .isEqualTo(width * height * 8);
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java b/library/test/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java
similarity index 96%
rename from library/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java
rename to library/test/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java
index 014cdaa19..5cc8f12ff 100644
--- a/library/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java
@@ -12,6 +12,8 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
+// containsExactly does not need its return value checked.
+@SuppressWarnings("ResultOfMethodCallIgnored")
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class ViewPreloadSizeProviderTest {
diff --git a/library/src/test/java/javax/microedition/khronos/opengles/GL.java b/library/test/src/test/java/opengles/GL.java
similarity index 100%
rename from library/src/test/java/javax/microedition/khronos/opengles/GL.java
rename to library/test/src/test/java/opengles/GL.java
diff --git a/library/test/src/test/resources/exif-orientation-examples b/library/test/src/test/resources/exif-orientation-examples
new file mode 160000
index 000000000..9c4ccfaea
--- /dev/null
+++ b/library/test/src/test/resources/exif-orientation-examples
@@ -0,0 +1 @@
+Subproject commit 9c4ccfaea6bfd434ac1c4bb0750ac6fc5848a5f4
diff --git a/library/src/test/resources/issue387_rotated_jpeg.jpg b/library/test/src/test/resources/issue387_rotated_jpeg.jpg
similarity index 100%
rename from library/src/test/resources/issue387_rotated_jpeg.jpg
rename to library/test/src/test/resources/issue387_rotated_jpeg.jpg
diff --git a/library/src/test/resources/org.robolectric.Config.properties b/library/test/src/test/resources/org.robolectric.Config.properties
similarity index 100%
rename from library/src/test/resources/org.robolectric.Config.properties
rename to library/test/src/test/resources/org.robolectric.Config.properties
diff --git a/library/src/test/resources/short_exif_sample.jpg b/library/test/src/test/resources/short_exif_sample.jpg
similarity index 100%
rename from library/src/test/resources/short_exif_sample.jpg
rename to library/test/src/test/resources/short_exif_sample.jpg
diff --git a/library/src/test/resources/test.gif b/library/test/src/test/resources/test.gif
similarity index 100%
rename from library/src/test/resources/test.gif
rename to library/test/src/test/resources/test.gif
diff --git a/samples/contacturi/build.gradle b/samples/contacturi/build.gradle
index 94799a5c2..d1f2480ea 100644
--- a/samples/contacturi/build.gradle
+++ b/samples/contacturi/build.gradle
@@ -1,15 +1,13 @@
 apply plugin: 'com.android.application'
 
 dependencies {
-    compile project(':library')
-    compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
-    compile "com.android.support:appcompat-v7:${SUPPORT_V7_VERSION}"
+    implementation project(':library')
+    implementation "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}"
     annotationProcessor project(':annotation:compiler')
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         applicationId 'com.bumptech.glide.samples.contacturi'
diff --git a/samples/contacturi/lint.xml b/samples/contacturi/lint.xml
new file mode 100644
index 000000000..bd2bae772
--- /dev/null
+++ b/samples/contacturi/lint.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+    <issue id="GoogleAppIndexingWarning" severity="ignore"/>
+    <issue id="GradleDependency" severity="ignore"/>
+</lint>
diff --git a/samples/contacturi/src/main/AndroidManifest.xml b/samples/contacturi/src/main/AndroidManifest.xml
index ecfd4c859..50cd63461 100644
--- a/samples/contacturi/src/main/AndroidManifest.xml
+++ b/samples/contacturi/src/main/AndroidManifest.xml
@@ -5,7 +5,7 @@
     <uses-permission android:name="android.permission.READ_CONTACTS" />
 
     <application
-        android:allowBackup="true"
+        android:allowBackup="false"
         android:icon="@android:drawable/sym_def_app_icon"
         android:label="@string/app_name"
         android:theme="@style/Theme.AppCompat" >
diff --git a/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java
index c928f9fd5..c072483df 100644
--- a/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java
+++ b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java
@@ -1,10 +1,6 @@
 package com.bumptech.glide.samples.contacturi;
 
-import static android.os.Build.VERSION;
-import static android.os.Build.VERSION_CODES;
-
 import android.Manifest;
-import android.annotation.TargetApi;
 import android.app.Activity;
 import android.content.ContentUris;
 import android.content.Intent;
@@ -21,6 +17,7 @@
 import android.widget.ImageView;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.util.Preconditions;
 
 /**
  * An activity that demonstrates loading photos using
@@ -44,11 +41,11 @@ protected void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
     setContentView(R.layout.activity_main);
 
-    imageViewContact = (ImageView) findViewById(R.id.image_contact);
-    imageViewLookup = (ImageView) findViewById(R.id.image_lookup);
-    imageViewPhoto = (ImageView) findViewById(R.id.image_photo);
-    imageViewDisplayPhoto = (ImageView) findViewById(R.id.image_display_photo);
-    numberEntry = (EditText) findViewById(R.id.number_entry);
+    imageViewContact = findViewById(R.id.image_contact);
+    imageViewLookup = findViewById(R.id.image_lookup);
+    imageViewPhoto = findViewById(R.id.image_photo);
+    imageViewDisplayPhoto = findViewById(R.id.image_display_photo);
+    numberEntry = findViewById(R.id.number_entry);
     // Make sure that user gives application required permissions
     if (ContextCompat.checkSelfPermission(
         getApplication(),
@@ -83,7 +80,8 @@ public void onClick(View v) {
   @Override
   protected void onActivityResult(int requestCode, int resultCode, Intent data) {
     if (requestCode == REQUEST_CONTACT && resultCode == RESULT_OK) {
-      final Cursor cursor = getContentResolver().query(data.getData(), null, null, null, null);
+      Uri uri = Preconditions.checkNotNull(data.getData());
+      final Cursor cursor = getContentResolver().query(uri, null, null, null, null);
       try {
         if (cursor != null && cursor.moveToFirst()) {
           final long contactId = cursor.getLong(cursor.getColumnIndex(Contacts._ID));
@@ -99,7 +97,6 @@ protected void onActivityResult(int requestCode, int resultCode, Intent data) {
     super.onActivityResult(requestCode, resultCode, data);
   }
 
-  @TargetApi(VERSION_CODES.ICE_CREAM_SANDWICH)
   private void showContact(long id) {
     GlideRequests glideRequests = GlideApp.with(this);
     RequestOptions originalSize = new RequestOptions().override(Target.SIZE_ORIGINAL);
@@ -113,9 +110,7 @@ private void showContact(long id) {
     Uri photoUri = Uri.withAppendedPath(contactUri, Contacts.Photo.CONTENT_DIRECTORY);
     glideRequests.load(photoUri).apply(originalSize).into(imageViewPhoto);
 
-    if (VERSION.SDK_INT >= VERSION_CODES.ICE_CREAM_SANDWICH) {
-      Uri displayPhotoUri = Uri.withAppendedPath(contactUri, Contacts.Photo.DISPLAY_PHOTO);
-      glideRequests.load(displayPhotoUri).apply(originalSize).into(imageViewDisplayPhoto);
-    }
+    Uri displayPhotoUri = Uri.withAppendedPath(contactUri, Contacts.Photo.DISPLAY_PHOTO);
+    glideRequests.load(displayPhotoUri).apply(originalSize).into(imageViewDisplayPhoto);
   }
 }
diff --git a/samples/flickr/build.gradle b/samples/flickr/build.gradle
index a0233b7a8..37ec1e3b8 100644
--- a/samples/flickr/build.gradle
+++ b/samples/flickr/build.gradle
@@ -1,21 +1,19 @@
 apply plugin: 'com.android.application'
 
 dependencies {
-    compile project(':library')
-    compile(project(':integration:recyclerview')) {
+    implementation project(':library')
+    implementation(project(':integration:recyclerview')) {
         transitive = false
     }
     annotationProcessor project(':annotation:compiler')
 
-    compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
-    compile "com.android.support:appcompat-v7:${SUPPORT_V7_VERSION}"
-    compile "com.mcxiaoke.volley:library:${VOLLEY_VERSION}"
-    compile "com.android.support:recyclerview-v7:${SUPPORT_V7_VERSION}"
+    implementation "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}"
+    implementation "com.android.volley:volley:${VOLLEY_VERSION}"
+    implementation "com.android.support:recyclerview-v7:${ANDROID_SUPPORT_VERSION}"
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         applicationId 'com.bumptech.glide.samples.flickr'
diff --git a/samples/flickr/lint.xml b/samples/flickr/lint.xml
index 5c710c8c7..0808ec2c6 100644
--- a/samples/flickr/lint.xml
+++ b/samples/flickr/lint.xml
@@ -3,4 +3,6 @@
     <!-- Not supported by all build systems -->
     <issue id="GradleOverrides" severity="ignore" />
     <issue id="IconMissingDensityFolder" severity="ignore"/>
+    <issue id="GoogleAppIndexingWarning" severity="ignore"/>
+    <issue id="GradleDependency" severity="ignore" />
 </lint>
diff --git a/samples/flickr/src/main/AndroidManifest.xml b/samples/flickr/src/main/AndroidManifest.xml
index 9be7824f6..191c38149 100644
--- a/samples/flickr/src/main/AndroidManifest.xml
+++ b/samples/flickr/src/main/AndroidManifest.xml
@@ -3,8 +3,11 @@
           package="com.bumptech.glide.samples.flickr">
 
     <uses-permission android:name="android.permission.INTERNET"/>
+    <!--
+    Allows Glide to monitor connectivity status and restart failed requests if users go from a
+    a disconnected to a connected network state.
+    -->
     <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
-    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
 
     <application
         android:label="@string/app_name"
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideExtension.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideExtension.java
new file mode 100644
index 000000000..57c9ee173
--- /dev/null
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideExtension.java
@@ -0,0 +1,32 @@
+package com.bumptech.glide.samples.flickr;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.samples.flickr.api.Api;
+
+/**
+ * Extension methods for the Flickr sample's generated API.
+ */
+// Required by Glide's annotation processor.
+@SuppressWarnings({"WeakerAccess", "unused"})
+@GlideExtension
+public final class FlickrGlideExtension {
+
+  private FlickrGlideExtension() {
+    // Utility class.
+  }
+
+  @NonNull
+  @GlideOption
+  public static BaseRequestOptions<?> squareThumb(BaseRequestOptions<?> requestOptions) {
+    return requestOptions.centerCrop();
+  }
+
+  @NonNull
+  @GlideOption
+  public static BaseRequestOptions<?> squareMiniThumb(BaseRequestOptions<?> requestOptions) {
+    return requestOptions.centerCrop().override(Api.SQUARE_THUMB_SIZE);
+  }
+}
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java
index 9a9be21e1..c0a1bce18 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java
@@ -1,10 +1,14 @@
 package com.bumptech.glide.samples.flickr;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
 import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.module.AppGlideModule;
+import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.samples.flickr.api.Photo;
 import java.io.InputStream;
 
@@ -13,8 +17,16 @@
  */
 @GlideModule
 public class FlickrGlideModule extends AppGlideModule {
+
+  @Override
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
+    super.applyOptions(context, builder);
+    builder.setDefaultRequestOptions(new RequestOptions().format(DecodeFormat.PREFER_ARGB_8888));
+  }
+
   @Override
-  public void registerComponents(Context context, Glide glide, Registry registry) {
+  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry) {
     registry.append(Photo.class, InputStream.class, new FlickrModelLoader.Factory());
   }
 
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java
index cf7ea32c0..a2b3d2f6e 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.samples.flickr;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelCache;
@@ -17,18 +18,19 @@
  * ExecutorService backing the Engine to download the image and resize it in memory before saving
  * the resized version directly to the disk cache.
  */
-public class FlickrModelLoader extends BaseGlideUrlLoader<Photo> {
+public final class FlickrModelLoader extends BaseGlideUrlLoader<Photo> {
 
   /**
    * The default factory for {@link com.bumptech.glide.samples.flickr.FlickrModelLoader}s.
    */
   public static class Factory implements ModelLoaderFactory<Photo, InputStream> {
-    private final ModelCache<Photo, GlideUrl> modelCache = new ModelCache<Photo, GlideUrl>(500);
+    private final ModelCache<Photo, GlideUrl> modelCache = new ModelCache<>(500);
 
+    @NonNull
     @Override
     public ModelLoader<Photo, InputStream> build(MultiModelLoaderFactory multiFactory) {
-      return new FlickrModelLoader(multiFactory.build(GlideUrl.class, InputStream.class),
-          modelCache);
+      return new FlickrModelLoader(
+          multiFactory.build(GlideUrl.class, InputStream.class), modelCache);
     }
 
     @Override
@@ -36,13 +38,13 @@ public void teardown() {
     }
   }
 
-  public FlickrModelLoader(ModelLoader<GlideUrl, InputStream> urlLoader,
-      ModelCache<Photo, GlideUrl> modelCache) {
+  private FlickrModelLoader(
+      ModelLoader<GlideUrl, InputStream> urlLoader, ModelCache<Photo, GlideUrl> modelCache) {
     super(urlLoader, modelCache);
   }
 
   @Override
-  public boolean handles(Photo model) {
+  public boolean handles(@NonNull Photo model) {
     return true;
   }
 
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
index 534caa298..65bc1ceab 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
@@ -4,6 +4,8 @@
 import android.graphics.Rect;
 import android.graphics.drawable.Drawable;
 import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.support.v4.app.Fragment;
 import android.support.v7.widget.GridLayoutManager;
 import android.support.v7.widget.RecyclerView;
@@ -16,10 +18,10 @@
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.integration.recyclerview.RecyclerViewPreloader;
-import com.bumptech.glide.load.engine.DiskCacheStrategy;
 import com.bumptech.glide.samples.flickr.api.Api;
 import com.bumptech.glide.samples.flickr.api.Photo;
 import com.bumptech.glide.util.FixedPreloadSizeProvider;
+import com.bumptech.glide.util.Preconditions;
 import java.util.Collections;
 import java.util.List;
 
@@ -55,9 +57,9 @@ public static FlickrPhotoGrid newInstance(int size, int preloadCount, boolean th
   }
 
   @Override
-  public View onCreateView(LayoutInflater inflater, ViewGroup container,
-      Bundle savedInstanceState) {
-    Bundle args = getArguments();
+  public View onCreateView(
+      @NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+    Bundle args = Preconditions.checkNotNull(getArguments());
     photoSize = args.getInt(IMAGE_SIZE_KEY);
     thumbnail = args.getBoolean(THUMBNAIL_KEY);
 
@@ -67,7 +69,6 @@ public View onCreateView(LayoutInflater inflater, ViewGroup container,
 
     thumbnailRequest = GlideApp.with(this)
         .asDrawable()
-        .diskCacheStrategy(DiskCacheStrategy.DATA)
         .centerCrop()
         .override(Api.SQUARE_THUMB_SIZE);
 
@@ -78,7 +79,7 @@ public View onCreateView(LayoutInflater inflater, ViewGroup container,
 
     final int gridMargin = getResources().getDimensionPixelOffset(R.dimen.grid_margin);
     int spanCount = getResources().getDisplayMetrics().widthPixels / (photoSize + (2 * gridMargin));
-    grid = (RecyclerView) result.findViewById(R.id.flickr_photo_grid);
+    grid = result.findViewById(R.id.flickr_photo_grid);
     layoutManager = new GridLayoutManager(getActivity(), spanCount);
     grid.setLayoutManager(layoutManager);
 
@@ -122,7 +123,7 @@ public void onViewRecycled(RecyclerView.ViewHolder holder) {
   }
 
   @Override
-  public void onSaveInstanceState(Bundle outState) {
+  public void onSaveInstanceState(@NonNull Bundle outState) {
     super.onSaveInstanceState(outState);
     if (grid != null) {
       int index = layoutManager.findFirstVisibleItemPosition();
@@ -143,11 +144,11 @@ public void onPhotosUpdated(List<Photo> photos) {
     private final LayoutInflater inflater;
     private List<Photo> photos = Collections.emptyList();
 
-    public PhotoAdapter() {
+    PhotoAdapter() {
       this.inflater = LayoutInflater.from(getActivity());
     }
 
-    public void setPhotos(List<Photo> photos) {
+    void setPhotos(List<Photo> photos) {
       this.photos = photos;
       notifyDataSetChanged();
     }
@@ -193,21 +194,23 @@ public int getItemCount() {
       return photos.size();
     }
 
+    @NonNull
     @Override
     public List<Photo> getPreloadItems(int position) {
       return photos.subList(position, position + 1);
     }
 
+    @Nullable
     @Override
-    public RequestBuilder<Drawable> getPreloadRequestBuilder(Photo item) {
+    public RequestBuilder<Drawable> getPreloadRequestBuilder(@NonNull Photo item) {
       return preloadRequest.load(item);
     }
   }
 
-  private static class PhotoViewHolder extends RecyclerView.ViewHolder {
+  private static final class PhotoViewHolder extends RecyclerView.ViewHolder {
     private final ImageView imageView;
 
-    public PhotoViewHolder(View itemView) {
+    PhotoViewHolder(View itemView) {
       super(itemView);
       imageView = (ImageView) itemView;
     }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java
index 701710e04..a9423c091 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java
@@ -7,6 +7,8 @@
 import android.graphics.drawable.ColorDrawable;
 import android.graphics.drawable.Drawable;
 import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.support.v4.app.Fragment;
 import android.support.v7.widget.LinearLayoutManager;
 import android.support.v7.widget.RecyclerView;
@@ -53,11 +55,11 @@ public void onPhotosUpdated(List<Photo> photos) {
   }
 
   @Override
-  public View onCreateView(LayoutInflater inflater, ViewGroup container,
-      Bundle savedInstanceState) {
+  public View onCreateView(
+      @NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
     final View result = inflater.inflate(R.layout.flickr_photo_list, container, false);
 
-    list = (RecyclerView) result.findViewById(R.id.flickr_photo_list);
+    list = result.findViewById(R.id.flickr_photo_list);
     layoutManager = new LinearLayoutManager(getActivity());
     list.setLayoutManager(layoutManager);
     adapter = new FlickrPhotoListAdapter();
@@ -104,7 +106,7 @@ public void onViewRecycled(RecyclerView.ViewHolder holder) {
   }
 
   @Override
-  public void onSaveInstanceState(Bundle outState) {
+  public void onSaveInstanceState(@NonNull Bundle outState) {
     super.onSaveInstanceState(outState);
     if (list != null) {
       int index = layoutManager.findFirstVisibleItemPosition();
@@ -115,16 +117,16 @@ public void onSaveInstanceState(Bundle outState) {
     }
   }
 
-  private class FlickrPhotoListAdapter extends RecyclerView.Adapter<PhotoTitleViewHolder>
+  private final class FlickrPhotoListAdapter extends RecyclerView.Adapter<PhotoTitleViewHolder>
       implements ListPreloader.PreloadModelProvider<Photo> {
     private final LayoutInflater inflater;
     private List<Photo> photos = Collections.emptyList();
 
-    public FlickrPhotoListAdapter() {
+    FlickrPhotoListAdapter() {
       this.inflater = LayoutInflater.from(getActivity());
     }
 
-    public void setPhotos(List<Photo> photos) {
+    void setPhotos(List<Photo> photos) {
       this.photos = photos;
       notifyDataSetChanged();
     }
@@ -165,25 +167,27 @@ public int getItemCount() {
       return photos.size();
     }
 
+    @NonNull
     @Override
     public List<Photo> getPreloadItems(int position) {
       return photos.subList(position, position + 1);
     }
 
+    @Nullable
     @Override
-    public RequestBuilder<Drawable> getPreloadRequestBuilder(Photo item) {
+    public RequestBuilder<Drawable> getPreloadRequestBuilder(@NonNull Photo item) {
       return fullRequest.thumbnail(thumbRequest.load(item)).load(item);
     }
   }
 
-  private static class PhotoTitleViewHolder extends RecyclerView.ViewHolder {
+  private static final class PhotoTitleViewHolder extends RecyclerView.ViewHolder {
     private final TextView titleView;
     private final ImageView imageView;
 
-    public PhotoTitleViewHolder(View itemView) {
+    PhotoTitleViewHolder(View itemView) {
       super(itemView);
-      imageView = (ImageView) itemView.findViewById(R.id.photo_view);
-      titleView = (TextView) itemView.findViewById(R.id.title_view);
+      imageView = itemView.findViewById(R.id.photo_view);
+      titleView = itemView.findViewById(R.id.title_view);
     }
   }
 }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
index 0ac5810e6..d1b57740e 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
@@ -10,7 +10,6 @@
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentManager;
 import android.support.v4.app.FragmentPagerAdapter;
-import android.support.v4.view.MenuItemCompat;
 import android.support.v4.view.ViewPager;
 import android.support.v7.app.AppCompatActivity;
 import android.text.TextUtils;
@@ -26,7 +25,6 @@
 import com.bumptech.glide.samples.flickr.api.Api;
 import com.bumptech.glide.samples.flickr.api.Photo;
 import com.bumptech.glide.samples.flickr.api.Query;
-import com.bumptech.glide.samples.flickr.api.RecentQuery;
 import com.bumptech.glide.samples.flickr.api.SearchQuery;
 import java.io.File;
 import java.util.ArrayList;
@@ -46,12 +44,14 @@
     implements SearchView.OnQueryTextListener {
   private static final String TAG = "FlickrSearchActivity";
   private static final String STATE_QUERY = "state_search_string";
+  private static final Query DEFAULT_QUERY = new SearchQuery("kitten");
 
   private final QueryListener queryListener = new QueryListener();
+  private final Set<PhotoViewer> photoViewers = new HashSet<>();
+
+  private List<Photo> currentPhotos = new ArrayList<>();
   private View searching;
   private TextView searchTerm;
-  private Set<PhotoViewer> photoViewers = new HashSet<>();
-  private List<Photo> currentPhotos = new ArrayList<>();
   private View searchLoading;
   private BackgroundThumbnailFetcher backgroundThumbnailFetcher;
   private HandlerThread backgroundThread;
@@ -65,13 +65,14 @@
     LIST
   }
 
-  private static final Map<Page, Integer> PAGE_TO_TITLE = new HashMap<Page, Integer>() {
-    {
-      put(Page.SMALL, R.string.small);
-      put(Page.MEDIUM, R.string.medium);
-      put(Page.LIST, R.string.list);
-    }
-  };
+  private static final Map<Page, Integer> PAGE_TO_TITLE;
+  static {
+    Map<Page, Integer> temp = new HashMap<>();
+    temp.put(Page.SMALL, R.string.small);
+    temp.put(Page.MEDIUM, R.string.medium);
+    temp.put(Page.LIST, R.string.list);
+    PAGE_TO_TITLE = Collections.unmodifiableMap(temp);
+  }
 
   @Override
   public void onAttachFragment(Fragment fragment) {
@@ -90,8 +91,7 @@ public boolean onCreateOptionsMenu(Menu menu) {
     MenuInflater menuInflater = getMenuInflater();
     menuInflater.inflate(R.menu.search_activity, menu);
 
-    searchView =
-        (SearchView) MenuItemCompat.getActionView(menu.findItem(R.id.search));
+    searchView = (SearchView) menu.findItem(R.id.search).getActionView();
     searchView.setSubmitButtonEnabled(true);
     searchView.setIconified(false);
     searchView.setOnQueryTextListener(this);
@@ -143,7 +143,7 @@ public void onCreate(Bundle savedInstanceState) {
         executeQuery(savedQuery);
       }
     } else {
-      executeQuery(RecentQuery.get());
+      executeQuery(DEFAULT_QUERY);
     }
 
     int smallGridSize = res.getDimensionPixelSize(R.dimen.small_photo_side);
@@ -250,12 +250,12 @@ public void onSearchFailed(Query query, Exception e) {
     }
   }
 
-  private class FlickrPagerAdapter extends FragmentPagerAdapter {
+  private final class FlickrPagerAdapter extends FragmentPagerAdapter {
 
     private int mLastPosition = -1;
     private Fragment mLastFragment;
 
-    public FlickrPagerAdapter(FragmentManager fm) {
+    FlickrPagerAdapter(FragmentManager fm) {
       super(fm);
     }
 
@@ -313,16 +313,17 @@ private int getPageSize(int id) {
   }
 
   private static class BackgroundThumbnailFetcher implements Runnable {
+    private final Context context;
+    private final List<Photo> photos;
+
     private boolean isCancelled;
-    private Context context;
-    private List<Photo> photos;
 
-    public BackgroundThumbnailFetcher(Context context, List<Photo> photos) {
+    BackgroundThumbnailFetcher(Context context, List<Photo> photos) {
       this.context = context;
       this.photos = photos;
     }
 
-    public void cancel() {
+    void cancel() {
       isCancelled = true;
     }
 
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/PhotoViewer.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/PhotoViewer.java
index 19776b359..28e88ecb5 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/PhotoViewer.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/PhotoViewer.java
@@ -7,11 +7,11 @@
  * An interface for an object that displays {@link com.bumptech.glide.samples.flickr.api.Photo}
  * objects.
  */
-public interface PhotoViewer {
+interface PhotoViewer {
   /**
    * Called whenever new {@link com.bumptech.glide.samples.flickr.api.Photo}s are loaded.
    *
    * @param photos The loaded photos.
    */
-  public void onPhotosUpdated(List<Photo> photos);
+  void onPhotosUpdated(List<Photo> photos);
 }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/SquareImageView.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/SquareImageView.java
index 5988e6bf8..e6cce5ec7 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/SquareImageView.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/SquareImageView.java
@@ -22,6 +22,8 @@ public SquareImageView(Context context, AttributeSet attrs, int defStyleAttr) {
     super(context, attrs, defStyleAttr);
   }
 
+  // We want a square view.
+  @SuppressWarnings("SuspiciousNameCombination")
   @Override
   protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
     super.onMeasure(widthMeasureSpec, widthMeasureSpec);
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Api.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Api.java
index 4ef7f0bde..6fa99de2c 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Api.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Api.java
@@ -17,9 +17,8 @@
 /**
  * A class for interfacing with Flickr's http API.
  */
-public class Api {
+public final class Api {
   private static Api api;
-  private static final String TAG = "FlickrApi";
   private static final String API_KEY = "f0e6fbb5fdf1f3842294a1d21f84e8a6";
   private static final String SIGNED_API_URL =
       "https://api.flickr.com/services/rest/?method=%s&format=json&api_key=" + API_KEY;
@@ -73,7 +72,9 @@ private static String getSizeKey(int width, int height) {
 
     boolean isFirstLargest = true;
     List<String> result = new ArrayList<>();
-    for (int edge : SORTED_SIZE_KEYS) {
+    int size = result.size();
+    for (int i = 0; i < size; i++) {
+      int edge = SORTED_SIZE_KEYS.get(i);
       if (largestEdge <= edge) {
         if (isFirstLargest) {
           isFirstLargest = false;
@@ -86,7 +87,7 @@ private static String getSizeKey(int width, int height) {
 
   }
 
-  public static String getCacheableUrl(Photo photo) {
+  static String getCacheableUrl(Photo photo) {
     return String.format(CACHEABLE_PHOTO_URL, photo.getFarm(), photo.getServer(), photo.getId(),
         photo.getSecret());
   }
@@ -154,10 +155,10 @@ public static Api get(Context context) {
   }
 
   private final RequestQueue requestQueue;
-  private final Set<QueryListener> queryListeners = new HashSet<QueryListener>();
+  private final Set<QueryListener> queryListeners = new HashSet<>();
   private QueryResult lastQueryResult;
 
-  protected Api(Context context) {
+  private Api(Context context) {
     this.requestQueue = Volley.newRequestQueue(context.getApplicationContext());
     QueryListener queryListener = new QueryListener() {
       @Override
@@ -202,7 +203,7 @@ public void query(Query query) {
     private final Query query;
     private final List<Photo> results;
 
-    public QueryResult(Query query, List<Photo> results) {
+    QueryResult(Query query, List<Photo> results) {
       this.query = query;
       this.results = results;
     }
diff --git a/samples/flickr/src/main/res/layout/flickr_photo_grid_item.xml b/samples/flickr/src/main/res/layout/flickr_photo_grid_item.xml
index 5a53ad9fd..d21744355 100644
--- a/samples/flickr/src/main/res/layout/flickr_photo_grid_item.xml
+++ b/samples/flickr/src/main/res/layout/flickr_photo_grid_item.xml
@@ -2,6 +2,6 @@
 <com.bumptech.glide.samples.flickr.SquareImageView
        xmlns:android="http://schemas.android.com/apk/res/android"
        android:scaleType="centerCrop"
-       android:layout_width="fill_parent"
-       android:layout_height="fill_parent"
+       android:layout_width="match_parent"
+       android:layout_height="match_parent"
        android:contentDescription="@string/image_description"/>
diff --git a/samples/gallery/build.gradle b/samples/gallery/build.gradle
index 9f1cce8bc..7b40050cb 100644
--- a/samples/gallery/build.gradle
+++ b/samples/gallery/build.gradle
@@ -1,18 +1,17 @@
 apply plugin: 'com.android.application'
 
 dependencies {
-    compile project(':library')
-    compile(project(':integration:recyclerview')) {
+    implementation project(':library')
+    implementation(project(':integration:recyclerview')) {
         transitive = false
     }
-    compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
-    compile "com.android.support:recyclerview-v7:${SUPPORT_V7_VERSION}"
+    implementation "com.android.support:recyclerview-v7:${ANDROID_SUPPORT_VERSION}"
+    implementation "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
     annotationProcessor project(':annotation:compiler')
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         applicationId 'com.bumptech.glide.samples.gallery'
diff --git a/samples/gallery/lint.xml b/samples/gallery/lint.xml
index 5c710c8c7..0808ec2c6 100644
--- a/samples/gallery/lint.xml
+++ b/samples/gallery/lint.xml
@@ -3,4 +3,6 @@
     <!-- Not supported by all build systems -->
     <issue id="GradleOverrides" severity="ignore" />
     <issue id="IconMissingDensityFolder" severity="ignore"/>
+    <issue id="GoogleAppIndexingWarning" severity="ignore"/>
+    <issue id="GradleDependency" severity="ignore" />
 </lint>
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java
index 30933931c..46ac3d232 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.samples.gallery;
 
 import android.os.Bundle;
+import android.support.annotation.NonNull;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.LoaderManager;
 import android.support.v4.content.Loader;
@@ -27,8 +28,8 @@ public void onCreate(Bundle savedInstanceState) {
   }
 
   @Override
-  public View onCreateView(LayoutInflater inflater, ViewGroup container,
-      Bundle savedInstanceState) {
+  public View onCreateView(
+      @NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
     View result = inflater.inflate(R.layout.recycler_view, container, false);
     recyclerView = (RecyclerView) result.findViewById(R.id.recycler_view);
     GridLayoutManager layoutManager = new GridLayoutManager(getActivity(), 1);
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java
index f600840b1..1206230ff 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java
@@ -1,18 +1,70 @@
 package com.bumptech.glide.samples.gallery;
 
+import android.Manifest.permission;
+import android.content.pm.PackageManager;
+import android.os.Build;
 import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.RequiresApi;
+import android.support.v4.app.ActivityCompat;
+import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
+import android.support.v4.content.ContextCompat;
+import android.widget.Toast;
 import com.bumptech.glide.MemoryCategory;
 
 /**
  * Displays a {@link HorizontalGalleryFragment}.
  */
+@RequiresApi(Build.VERSION_CODES.JELLY_BEAN)
 public class MainActivity extends FragmentActivity {
 
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.main_activity);
-        GlideApp.get(this).setMemoryCategory(MemoryCategory.HIGH);
+  private static final int REQUEST_READ_STORAGE = 0;
+
+  @Override
+  protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    setContentView(R.layout.main_activity);
+    GlideApp.get(this).setMemoryCategory(MemoryCategory.HIGH);
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M
+        && ContextCompat.checkSelfPermission(this, permission.READ_EXTERNAL_STORAGE)
+        != PackageManager.PERMISSION_GRANTED) {
+      requestStoragePermission();
+    } else {
+      replaceFragment();
+    }
+  }
+
+  private void requestStoragePermission() {
+     ActivityCompat.requestPermissions(this,
+        new String[]{permission.READ_EXTERNAL_STORAGE},
+        REQUEST_READ_STORAGE);
+  }
+
+  private void replaceFragment() {
+    Fragment fragment = new HorizontalGalleryFragment();
+    getSupportFragmentManager()
+        .beginTransaction()
+        .replace(R.id.fragment_container, fragment)
+        .commit();
+  }
+
+  @Override
+  public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,
+      @NonNull int[] grantResults) {
+    super.onRequestPermissionsResult(requestCode, permissions, grantResults);
+    switch (requestCode) {
+      case REQUEST_READ_STORAGE: {
+        // If request is cancelled, the result arrays are empty.
+        if (grantResults.length > 0
+            && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
+          replaceFragment();
+        } else {
+          Toast.makeText(this, "Storage permission is required", Toast.LENGTH_LONG)
+              .show();
+          requestStoragePermission();
+        }
+      }
     }
+  }
 }
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreData.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreData.java
index 8663eafdd..c0c924e15 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreData.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreData.java
@@ -25,15 +25,15 @@ public int describeContents() {
     return 0;
   }
 
-  public final long rowId;
-  public final Uri uri;
-  public final String mimeType;
-  public final long dateModified;
-  public final int orientation;
-  public final Type type;
-  public final long dateTaken;
+  final long rowId;
+  final Uri uri;
+  final String mimeType;
+  final long dateModified;
+  final int orientation;
+  private final Type type;
+  final long dateTaken;
 
-  public MediaStoreData(long rowId, Uri uri, String mimeType, long dateTaken, long dateModified,
+  MediaStoreData(long rowId, Uri uri, String mimeType, long dateTaken, long dateModified,
       int orientation, Type type) {
     this.rowId = rowId;
     this.uri = uri;
@@ -44,7 +44,7 @@ public MediaStoreData(long rowId, Uri uri, String mimeType, long dateTaken, long
     this.dateTaken = dateTaken;
   }
 
-  MediaStoreData(Parcel in) {
+  private MediaStoreData(Parcel in) {
     rowId = in.readLong();
     uri = Uri.parse(in.readString());
     mimeType = in.readString();
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreDataLoader.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreDataLoader.java
index efe2366d5..372e9dbe8 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreDataLoader.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreDataLoader.java
@@ -37,7 +37,7 @@
   private boolean observerRegistered = false;
   private final ForceLoadContentObserver forceLoadContentObserver = new ForceLoadContentObserver();
 
-  public MediaStoreDataLoader(Context context) {
+  MediaStoreDataLoader(Context context) {
     super(context);
   }
 
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java
index 2486badfd..665cccffe 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java
@@ -3,6 +3,8 @@
 import android.content.Context;
 import android.graphics.Point;
 import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.support.v7.widget.RecyclerView;
 import android.view.Display;
 import android.view.LayoutInflater;
@@ -15,6 +17,7 @@
 import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.signature.MediaStoreSignature;
+import com.bumptech.glide.util.Preconditions;
 import java.util.Collections;
 import java.util.List;
 
@@ -91,13 +94,15 @@ public int getItemViewType(int position) {
     return 0;
   }
 
+  @NonNull
   @Override
   public List<MediaStoreData> getPreloadItems(int position) {
     return Collections.singletonList(data.get(position));
   }
 
+  @Nullable
   @Override
-  public RequestBuilder<Drawable> getPreloadRequestBuilder(MediaStoreData item) {
+  public RequestBuilder<Drawable> getPreloadRequestBuilder(@NonNull MediaStoreData item) {
     MediaStoreSignature signature =
         new MediaStoreSignature(item.mimeType, item.dateModified, item.orientation);
     return requestBuilder
@@ -106,8 +111,10 @@ public int getItemViewType(int position) {
         .load(item.uri);
   }
 
+  @Nullable
   @Override
-  public int[] getPreloadSize(MediaStoreData item, int adapterPosition, int perItemPosition) {
+  public int[] getPreloadSize(@NonNull MediaStoreData item, int adapterPosition,
+      int perItemPosition) {
     return actualDimensions;
   }
 
@@ -115,7 +122,7 @@ public int getItemViewType(int position) {
   @SuppressWarnings("deprecation")
   private static int getScreenWidth(Context context) {
     WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
-    Display display = wm.getDefaultDisplay();
+    Display display = Preconditions.checkNotNull(wm).getDefaultDisplay();
     Point size = new Point();
     display.getSize(size);
     return size.x;
@@ -125,13 +132,13 @@ private static int getScreenWidth(Context context) {
    * ViewHolder containing views to display individual {@link
    * com.bumptech.glide.samples.gallery.MediaStoreData}.
    */
-  public static final class ListViewHolder extends RecyclerView.ViewHolder {
+  static final class ListViewHolder extends RecyclerView.ViewHolder {
 
     private final ImageView image;
 
-    public ListViewHolder(View itemView) {
+    ListViewHolder(View itemView) {
       super(itemView);
-      image = (ImageView) itemView.findViewById(R.id.image);
+      image = itemView.findViewById(R.id.image);
     }
   }
 }
diff --git a/samples/gallery/src/main/res/layout/main_activity.xml b/samples/gallery/src/main/res/layout/main_activity.xml
index 18c1a634f..26fd8b6a8 100644
--- a/samples/gallery/src/main/res/layout/main_activity.xml
+++ b/samples/gallery/src/main/res/layout/main_activity.xml
@@ -1,8 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
-<merge xmlns:android="http://schemas.android.com/apk/res/android">
-    <fragment
-            android:name="com.bumptech.glide.samples.gallery.HorizontalGalleryFragment"
-            android:layout_width="match_parent"
-            android:layout_height="match_parent"
-            android:id="@+id/horizontal_gallery_fragment"/>
-</merge>
+<FrameLayout
+  xmlns:android="http://schemas.android.com/apk/res/android"
+  xmlns:tools="http://schemas.android.com/tools"
+  tools:ignore="MergeRootFrame"
+  android:id="@+id/fragment_container"
+  android:layout_width="match_parent"
+  android:layout_height="match_parent" />
diff --git a/samples/giphy/build.gradle b/samples/giphy/build.gradle
index e2931ad27..f224a53a9 100644
--- a/samples/giphy/build.gradle
+++ b/samples/giphy/build.gradle
@@ -1,18 +1,18 @@
 apply plugin: 'com.android.application'
 
 dependencies {
-    compile project(':library')
-    compile(project(':integration:recyclerview')) {
+    implementation project(':library')
+    implementation(project(':integration:recyclerview')) {
         transitive = false
     }
-    compile 'com.google.code.gson:gson:2.4'
-    compile "com.android.support:recyclerview-v7:${SUPPORT_V7_VERSION}"
+    implementation 'com.google.code.gson:gson:2.8.2'
+    implementation "com.android.support:recyclerview-v7:${ANDROID_SUPPORT_VERSION}"
+    implementation "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
     annotationProcessor project(':annotation:compiler')
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         applicationId 'com.bumptech.glide.samples.giphy'
diff --git a/samples/giphy/lint.xml b/samples/giphy/lint.xml
index 95a2ab036..c02d95c38 100644
--- a/samples/giphy/lint.xml
+++ b/samples/giphy/lint.xml
@@ -2,4 +2,6 @@
 <lint>
     <!-- Not supported by all build systems -->
     <issue id="GradleOverrides" severity="ignore" />
+    <issue id="GoogleAppIndexingWarning" severity="ignore"/>
+    <issue id="GradleDependency" severity="ignore" />
 </lint>
diff --git a/samples/giphy/src/main/AndroidManifest.xml b/samples/giphy/src/main/AndroidManifest.xml
index 8d3ac29ac..469e1295a 100644
--- a/samples/giphy/src/main/AndroidManifest.xml
+++ b/samples/giphy/src/main/AndroidManifest.xml
@@ -3,9 +3,14 @@
           package="com.bumptech.glide.samples.giphy">
 
     <uses-permission android:name="android.permission.INTERNET"/>
+    <!--
+    Allows Glide to monitor connectivity status and restart failed requests if users go from a
+    a disconnected to a connected network state.
+    -->
+    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
 
     <application
-        android:allowBackup="true"
+        android:allowBackup="false"
         android:icon="@android:drawable/sym_def_app_icon"
         android:largeHeap="true"
         android:label="@string/app_name"
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java
index 921dc0db6..4f78d2d69 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java
@@ -3,6 +3,7 @@
 import android.os.Handler;
 import android.os.HandlerThread;
 import android.os.Looper;
+import com.bumptech.glide.util.Util;
 import com.google.gson.Gson;
 import java.io.IOException;
 import java.io.InputStream;
@@ -20,8 +21,9 @@
   private static volatile Api api = null;
   private static final String BETA_KEY = "dc6zaTOxFJmzC";
   private static final String BASE_URL = "https://api.giphy.com/";
-  private static final String SEARCH_PATH = "v1/gifs/search";
   private static final String TRENDING_PATH = "v1/gifs/trending";
+  private static final int LIMIT = 100;
+  private static final int OFFSET = 0;
   private final Handler bgHandler;
   private final Handler mainHandler;
   private final HashSet<Monitor> monitors = new HashSet<>();
@@ -30,13 +32,8 @@ private static String signUrl(String url) {
     return url + "&api_key=" + BETA_KEY;
   }
 
-  private static String getSearchUrl(String query, int limit, int offset) {
-    return signUrl(
-        BASE_URL + SEARCH_PATH + "?q=" + query + "&limit=" + limit + "&offset=" + offset);
-  }
-
-  private static String getTrendingUrl(int limit, int offset) {
-    return signUrl(BASE_URL + TRENDING_PATH + "?limit=" + limit + "&offset=" + offset);
+  private static String getTrendingUrl() {
+    return signUrl(BASE_URL + TRENDING_PATH + "?limit=" + LIMIT + "&offset=" + OFFSET);
   }
 
   /**
@@ -51,7 +48,7 @@ private static String getTrendingUrl(int limit, int offset) {
     void onSearchComplete(SearchResult result);
   }
 
-  public static Api get() {
+  static Api get() {
     if (api == null) {
       synchronized (Api.class) {
         if (api == null) {
@@ -70,21 +67,16 @@ private Api() {
     // Do nothing.
   }
 
-  public void addMonitor(Monitor monitor) {
+  void addMonitor(Monitor monitor) {
     monitors.add(monitor);
   }
 
-  public void removeMonitor(Monitor monitor) {
+  void removeMonitor(Monitor monitor) {
     monitors.remove(monitor);
   }
 
-  public void search(String searchTerm) {
-    String searchUrl = getSearchUrl(searchTerm, 100, 0);
-    query(searchUrl);
-  }
-
-  public void getTrending() {
-    String trendingUrl = getTrendingUrl(100, 0);
+  void getTrending() {
+    String trendingUrl = getTrendingUrl();
     query(trendingUrl);
   }
 
@@ -138,7 +130,7 @@ public void run() {
   /**
    * A POJO mirroring the top level result JSON object returned from Giphy's api.
    */
-  public static class SearchResult {
+  public static final class SearchResult {
     public GifResult[] data;
 
     @Override
@@ -149,16 +141,34 @@ public String toString() {
 
   /**
    * A POJO mirroring an individual GIF image returned from Giphy's api.
+   *
+   * <p>Implements equals and hashcode so that in memory caching will work when this object is used
+   * as a model for loading Glide's images.
    */
-  public static class GifResult {
+  public static final class GifResult {
     public String id;
-    // Page url not GIF url
-    public String url;
-    public GifUrlSet images;
+    GifUrlSet images;
+
+    @Override
+    public int hashCode() {
+      int result = id != null ? id.hashCode() : 17;
+      result = 31 * result + (images != null ? images.hashCode() : 17);
+      return result;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+      if (obj instanceof GifResult) {
+        GifResult other = (GifResult) obj;
+        return Util.bothNullOrEqual(id, other.id)
+            && Util.bothNullOrEqual(images, other.images);
+      }
+      return false;
+    }
 
     @Override
     public String toString() {
-      return "GifResult{" + "id='" + id + '\'' + ", url='" + url + '\'' + ", images=" + images
+      return "GifResult{" + "id='" + id + '\'' + ", images=" + images
           + '}';
     }
   }
@@ -167,10 +177,29 @@ public String toString() {
    * A POJO mirroring a JSON object with a put of urls of different sizes and dimensions returned
    * for a single image from Giphy's api.
    */
-  public static class GifUrlSet {
-    public GifImage original;
-    public GifImage fixed_width;
-    public GifImage fixed_height;
+  public static final class GifUrlSet {
+    GifImage original;
+    GifImage fixed_width;
+    GifImage fixed_height;
+
+    @Override
+    public int hashCode() {
+      int result = original != null ? original.hashCode() : 17;
+      result = 31 * result + (fixed_width != null ? fixed_width.hashCode() : 17);
+      result = 31 * result + (fixed_height != null ? fixed_height.hashCode() : 17);
+      return result;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+      if (obj instanceof GifUrlSet) {
+        GifUrlSet other = (GifUrlSet) obj;
+        return Util.bothNullOrEqual(original, other.original)
+            && Util.bothNullOrEqual(fixed_width, other.fixed_width)
+            && Util.bothNullOrEqual(fixed_height, other.fixed_height);
+      }
+      return false;
+    }
 
     @Override
     public String toString() {
@@ -184,17 +213,32 @@ public String toString() {
    * A POJO mirroring a JSON object for an image with one particular url, size and dimension
    * returned from Giphy's api.
    */
-  public static class GifImage {
-    public String url;
-    public int width;
-    public int height;
-    public int frames;
-    public int size;
+  public static final class GifImage {
+    String url;
+    int width;
+    int height;
 
     @Override
+    public int hashCode() {
+      int result = url != null ? url.hashCode() : 17;
+      result = 31 * result + width;
+      result = 31 * result + height;
+      return result;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+      if (obj instanceof GifImage) {
+        GifImage other = (GifImage) obj;
+        return other.width == width
+            && other.height == height
+            && Util.bothNullOrEqual(url, other.url);
+      }
+      return false;
+    }
+
     public String toString() {
-      return "GifImage{" + "url='" + url + '\'' + ", width=" + width + ", height=" + height
-          + ", frames=" + frames + ", size=" + size + '}';
+      return "GifImage{" + "url='" + url + '\'' + ", width=" + width + ", height=" + height + '}';
     }
   }
 }
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java
index 5381e1f22..6fbca3826 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.samples.giphy;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.Registry;
 import com.bumptech.glide.annotation.GlideModule;
@@ -13,7 +14,8 @@
 @GlideModule
 public class GiphyGlideModule extends AppGlideModule {
   @Override
-  public void registerComponents(Context context, Glide glide, Registry registry) {
+  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry) {
     registry.append(Api.GifResult.class, InputStream.class, new GiphyModelLoader.Factory());
   }
 
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java
index 184e976ea..a0163074e 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.samples.giphy;
 
+import android.support.annotation.NonNull;
 import android.text.TextUtils;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
@@ -7,6 +8,7 @@
 import com.bumptech.glide.load.model.ModelLoaderFactory;
 import com.bumptech.glide.load.model.MultiModelLoaderFactory;
 import com.bumptech.glide.load.model.stream.BaseGlideUrlLoader;
+import com.bumptech.glide.samples.giphy.Api.GifResult;
 import java.io.InputStream;
 
 /**
@@ -14,31 +16,14 @@
  * Giphy's api into an {@link java.io.InputStream} that can be decoded into an
  * {@link android.graphics.drawable.Drawable}.
  */
-public class GiphyModelLoader extends BaseGlideUrlLoader<Api.GifResult> {
+public final class GiphyModelLoader extends BaseGlideUrlLoader<Api.GifResult> {
 
   @Override
-  public boolean handles(Api.GifResult model) {
+  public boolean handles(@NonNull Api.GifResult model) {
     return true;
   }
 
-  /**
-   * The default factory for {@link com.bumptech.glide.samples.giphy.GiphyModelLoader}s.
-   */
-  public static class Factory implements ModelLoaderFactory<Api.GifResult, InputStream> {
-
-
-    @Override
-    public ModelLoader<Api.GifResult, InputStream> build(MultiModelLoaderFactory multiFactory) {
-      return new GiphyModelLoader(multiFactory.build(GlideUrl.class, InputStream.class));
-    }
-
-    @Override
-    public void teardown() {
-      // Do nothing.
-    }
-  }
-
-  public GiphyModelLoader(ModelLoader<GlideUrl, InputStream> urlLoader) {
+  private GiphyModelLoader(ModelLoader<GlideUrl, InputStream> urlLoader) {
     super(urlLoader);
   }
 
@@ -62,4 +47,20 @@ protected String getUrl(Api.GifResult model, int width, int height, Options opti
   private static int getDifference(Api.GifImage gifImage, int width, int height) {
     return Math.abs(width - gifImage.width) + Math.abs(height - gifImage.height);
   }
+
+  /**
+   * The default factory for {@link com.bumptech.glide.samples.giphy.GiphyModelLoader}s.
+   */
+  public static final class Factory implements ModelLoaderFactory<GifResult, InputStream> {
+    @NonNull
+    @Override
+    public ModelLoader<Api.GifResult, InputStream> build(MultiModelLoaderFactory multiFactory) {
+      return new GiphyModelLoader(multiFactory.build(GlideUrl.class, InputStream.class));
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+  }
 }
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java
index 5501c236c..947518cca 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java
@@ -7,14 +7,19 @@
 import android.content.Intent;
 import android.graphics.drawable.Drawable;
 import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.support.v7.widget.LinearLayoutManager;
 import android.support.v7.widget.RecyclerView;
+import android.support.v7.widget.RecyclerView.RecyclerListener;
+import android.support.v7.widget.RecyclerView.ViewHolder;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.ImageView;
 import com.bumptech.glide.ListPreloader;
 import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.integration.recyclerview.RecyclerViewPreloader;
+import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.ViewPreloadSizeProvider;
 import java.util.Collections;
 import java.util.List;
@@ -31,13 +36,13 @@ protected void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
     setContentView(R.layout.activity_main);
 
-    ImageView giphyLogoView = (ImageView) findViewById(R.id.giphy_logo_view);
+    ImageView giphyLogoView = findViewById(R.id.giphy_logo_view);
 
     GlideApp.with(this)
         .load(R.raw.large_giphy_logo)
         .into(giphyLogoView);
 
-    RecyclerView gifList = (RecyclerView) findViewById(R.id.gif_list);
+    RecyclerView gifList = findViewById(R.id.gif_list);
     LinearLayoutManager layoutManager = new LinearLayoutManager(this);
     gifList.setLayoutManager(layoutManager);
 
@@ -51,6 +56,15 @@ protected void onCreate(Bundle savedInstanceState) {
     RecyclerViewPreloader<Api.GifResult> preloader =
         new RecyclerViewPreloader<>(GlideApp.with(this), adapter, preloadSizeProvider, 4);
     gifList.addOnScrollListener(preloader);
+    gifList.setRecyclerListener(new RecyclerListener() {
+      @Override
+      public void onViewRecycled(ViewHolder holder) {
+        // This is an optimization to reduce the memory usage of RecyclerView's recycled view pool
+        // and good practice when using Glide with RecyclerView.
+        GifViewHolder gifViewHolder = (GifViewHolder) holder;
+        GlideApp.with(MainActivity.this).clear(gifViewHolder.gifView);
+      }
+    });
   }
 
   @Override
@@ -78,8 +92,8 @@ public void onSearchComplete(Api.SearchResult result) {
     private static final Api.GifResult[] EMPTY_RESULTS = new Api.GifResult[0];
 
     private final Activity activity;
-    private RequestBuilder<Drawable> requestBuilder;
-    private ViewPreloadSizeProvider<Api.GifResult> preloadSizeProvider;
+    private final RequestBuilder<Drawable> requestBuilder;
+    private final ViewPreloadSizeProvider<Api.GifResult> preloadSizeProvider;
 
     private Api.GifResult[] results = EMPTY_RESULTS;
 
@@ -115,14 +129,16 @@ public void onClick(View view) {
               (ClipboardManager) activity.getSystemService(Context.CLIPBOARD_SERVICE);
           ClipData clip =
               ClipData.newPlainText("giphy_url", result.images.fixed_height.url);
-          clipboard.setPrimaryClip(clip);
+          Preconditions.checkNotNull(clipboard).setPrimaryClip(clip);
 
           Intent fullscreenIntent = FullscreenActivity.getIntent(activity, result);
           activity.startActivity(fullscreenIntent);
         }
       });
 
-      requestBuilder.load(result).into(holder.gifView);
+      // clearOnDetach let's us stop animating GifDrawables that RecyclerView hasn't yet recycled
+      // but that are currently off screen.
+      requestBuilder.load(result).into(holder.gifView).clearOnDetach();
 
       preloadSizeProvider.setView(holder.gifView);
     }
@@ -137,13 +153,15 @@ public int getItemCount() {
       return results.length;
     }
 
+    @NonNull
     @Override
     public List<Api.GifResult> getPreloadItems(int position) {
       return Collections.singletonList(results[position]);
     }
 
+    @Nullable
     @Override
-    public RequestBuilder<Drawable> getPreloadRequestBuilder(Api.GifResult item) {
+    public RequestBuilder<Drawable> getPreloadRequestBuilder(@NonNull Api.GifResult item) {
       return requestBuilder.load(item);
     }
   }
@@ -153,7 +171,7 @@ public int getItemCount() {
 
     GifViewHolder(View itemView) {
       super(itemView);
-      gifView = (ImageView) itemView.findViewById(R.id.gif_view);
+      gifView = itemView.findViewById(R.id.gif_view);
     }
   }
 }
diff --git a/samples/imgur/.gitignore b/samples/imgur/.gitignore
new file mode 100644
index 000000000..796b96d1c
--- /dev/null
+++ b/samples/imgur/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/samples/imgur/build.gradle b/samples/imgur/build.gradle
new file mode 100644
index 000000000..825ea2f16
--- /dev/null
+++ b/samples/imgur/build.gradle
@@ -0,0 +1,59 @@
+apply plugin: 'com.android.application'
+
+android {
+    compileSdkVersion COMPILE_SDK_VERSION as int
+
+    defaultConfig {
+        applicationId "com.bumptech.glide.samples.imgur"
+        minSdkVersion MIN_SDK_VERSION as int
+        targetSdkVersion TARGET_SDK_VERSION as int
+        versionCode 1
+        versionName "1.0"
+
+        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+
+    }
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
+    buildTypes {
+        release {
+            minifyEnabled false
+        }
+    }
+}
+
+dependencies {
+    implementation project(':library')
+    annotationProcessor project(':annotation:compiler')
+
+    implementation "com.google.dagger:dagger:${DAGGER_VERSION}"
+    annotationProcessor "com.google.dagger:dagger-compiler:${DAGGER_VERSION}"
+    implementation "com.google.dagger:dagger-android:${DAGGER_VERSION}"
+    implementation ("com.google.dagger:dagger-android-support:${DAGGER_VERSION}") {
+        exclude group: "com.android.support"
+    }
+    annotationProcessor "com.google.dagger:dagger-android-processor:${DAGGER_VERSION}"
+
+    implementation "com.squareup.okhttp3:okhttp:${OK_HTTP_VERSION}"
+    implementation 'com.squareup.retrofit2:retrofit:2.3.0'
+    implementation 'com.squareup.retrofit2:converter-gson:2.3.0'
+    implementation 'com.squareup.retrofit2:adapter-rxjava:2.3.0'
+
+    implementation 'io.reactivex:rxandroid:1.2.1'
+    implementation 'io.reactivex:rxjava:1.3.4'
+
+    implementation "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}"
+    implementation "com.android.support:cardview-v7:${ANDROID_SUPPORT_VERSION}"
+    implementation "com.android.support:recyclerview-v7:${ANDROID_SUPPORT_VERSION}"
+
+    // Fixes a compilation warning related to dagger, see
+    // https://github.com/google/guava/issues/2721.
+    compileOnly "com.google.errorprone:error_prone_annotations:${ERROR_PRONE_VERSION}"
+}
+
+task run(type: Exec, dependsOn: 'installDebug') {
+    description 'Installs the APK and runs the main activity: "gradlew :samples:???:run"'
+    commandLine "${android.sdkDirectory}/platform-tools/adb", 'shell', 'am', 'start', '-n', 'com.bumptech.glide.samples.card/.MainActivity'
+}
diff --git a/samples/imgur/lint.xml b/samples/imgur/lint.xml
new file mode 100644
index 000000000..0808ec2c6
--- /dev/null
+++ b/samples/imgur/lint.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+    <!-- Not supported by all build systems -->
+    <issue id="GradleOverrides" severity="ignore" />
+    <issue id="IconMissingDensityFolder" severity="ignore"/>
+    <issue id="GoogleAppIndexingWarning" severity="ignore"/>
+    <issue id="GradleDependency" severity="ignore" />
+</lint>
diff --git a/samples/imgur/src/main/AndroidManifest.xml b/samples/imgur/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..854c9930f
--- /dev/null
+++ b/samples/imgur/src/main/AndroidManifest.xml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+  package="com.bumptech.glide.samples.imgur">
+  <uses-permission android:name="android.permission.INTERNET" />
+  <!--
+  Allows Glide to monitor connectivity status and restart failed requests if users go from a
+  a disconnected to a connected network state.
+  -->
+  <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
+  <application
+    android:allowBackup="false"
+    android:icon="@mipmap/ic_launcher"
+    android:label="@string/app_name"
+    android:roundIcon="@mipmap/ic_launcher_round"
+    android:supportsRtl="true"
+    android:theme="@style/AppTheme"
+    android:name="com.bumptech.glide.samples.imgur.ImgurApplication">
+    <activity android:name="com.bumptech.glide.samples.imgur.MainActivity">
+      <intent-filter>
+        <action android:name="android.intent.action.MAIN"/>
+        <category android:name="android.intent.category.LAUNCHER"/>
+      </intent-filter>
+    </activity>
+  </application>
+
+</manifest>
\ No newline at end of file
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ApplicationModule.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ApplicationModule.java
new file mode 100644
index 000000000..f64d72143
--- /dev/null
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ApplicationModule.java
@@ -0,0 +1,16 @@
+package com.bumptech.glide.samples.imgur;
+
+import dagger.Module;
+import dagger.Provides;
+import okhttp3.OkHttpClient;
+
+/**
+ * The Application Dagger module for the Imgur sample.
+ */
+@Module
+class ApplicationModule {
+  @Provides
+  OkHttpClient okHttpClient() {
+    return new OkHttpClient();
+  }
+}
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplication.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplication.java
new file mode 100644
index 000000000..c2b788e2b
--- /dev/null
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplication.java
@@ -0,0 +1,14 @@
+package com.bumptech.glide.samples.imgur;
+
+import dagger.android.AndroidInjector;
+import dagger.android.support.DaggerApplication;
+
+/**
+ * Runs Dagger injection in the Imgur sample.
+ */
+public final class ImgurApplication extends DaggerApplication {
+  @Override
+  protected AndroidInjector<? extends DaggerApplication> applicationInjector() {
+    return DaggerImgurApplicationComponent.create();
+  }
+}
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplicationComponent.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplicationComponent.java
new file mode 100644
index 000000000..7b9d639aa
--- /dev/null
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplicationComponent.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.samples.imgur;
+
+import com.bumptech.glide.samples.imgur.api.ApiModule;
+import dagger.Component;
+import dagger.android.AndroidInjector;
+import dagger.android.support.AndroidSupportInjectionModule;
+import javax.inject.Singleton;
+
+/**
+ * Specifies Dagger modules for {@link ImgurApplication}.
+ */
+@Singleton
+@Component(modules = {
+    AndroidSupportInjectionModule.class,
+    MainActivityModule.class,
+    ApplicationModule.class,
+    ApiModule.class
+})
+public interface ImgurApplicationComponent extends AndroidInjector<ImgurApplication> {
+}
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurGlideModule.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurGlideModule.java
new file mode 100644
index 000000000..c673ad244
--- /dev/null
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurGlideModule.java
@@ -0,0 +1,12 @@
+package com.bumptech.glide.samples.imgur;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
+
+/**
+ * Generates a Glide API for the Imgur sample.
+ */
+@GlideModule(glideName = "ImgurGlide")
+public class ImgurGlideModule extends AppGlideModule {
+  // Intentionally Empty.
+}
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/MainActivity.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/MainActivity.java
new file mode 100644
index 000000000..384543997
--- /dev/null
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/MainActivity.java
@@ -0,0 +1,114 @@
+package com.bumptech.glide.samples.imgur;
+
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.v7.app.AppCompatActivity;
+import android.support.v7.widget.LinearLayoutManager;
+import android.support.v7.widget.RecyclerView;
+import android.support.v7.widget.RecyclerView.ViewHolder;
+import android.text.TextUtils;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ImageView;
+import android.widget.TextView;
+import com.bumptech.glide.samples.imgur.api.Image;
+import dagger.android.AndroidInjection;
+import java.util.Collections;
+import java.util.List;
+import javax.inject.Inject;
+import javax.inject.Named;
+import rx.Observable;
+import rx.Observer;
+import rx.android.schedulers.AndroidSchedulers;
+import rx.schedulers.Schedulers;
+
+/**
+ * Displays images and GIFs from Imgur in a scrollable list of cards.
+ */
+public final class MainActivity extends AppCompatActivity {
+
+  @Inject @Named("hotViralImages") Observable<List<Image>> fetchImagesObservable;
+  private ImgurImageAdapter adapter;
+
+  @Override
+  protected void onCreate(Bundle savedInstanceState) {
+    AndroidInjection.inject(this);
+    super.onCreate(savedInstanceState);
+    setContentView(R.layout.activity_main);
+    RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view);
+
+    recyclerView.setHasFixedSize(true);
+    LinearLayoutManager layoutManager = new LinearLayoutManager(this);
+    recyclerView.setLayoutManager(layoutManager);
+    adapter = new ImgurImageAdapter();
+    recyclerView.setAdapter(adapter);
+
+    fetchImagesObservable
+        .subscribeOn(Schedulers.newThread())
+        .observeOn(AndroidSchedulers.mainThread())
+        .subscribe(new Observer<List<Image>>() {
+          @Override
+          public void onCompleted() { }
+
+          @Override
+          public void onError(Throwable e) { }
+
+          @Override
+          public void onNext(List<Image> images) {
+            adapter.setData(images);
+          }
+        });
+  }
+
+  @Override
+  protected void onDestroy() {
+    super.onDestroy();
+    fetchImagesObservable.unsubscribeOn(AndroidSchedulers.mainThread());
+  }
+
+  private final class ImgurImageAdapter extends RecyclerView.Adapter<ViewHolder> {
+
+    private List<Image> images = Collections.emptyList();
+
+    public void setData(@NonNull List<Image> images) {
+      this.images = images;
+      notifyDataSetChanged();
+    }
+
+    @Override
+    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
+      return new ViewHolder(LayoutInflater.from(parent.getContext())
+          .inflate(R.layout.image_card, parent, false));
+    }
+
+    @Override
+    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {
+      ViewHolder vh = (ViewHolder) holder;
+      Image image = images.get(position);
+      vh.title.setText(
+          TextUtils.isEmpty(image.title) ? image.description : image.title);
+
+      ImgurGlide.with(vh.imageView)
+          .load(image.link)
+          .into(vh.imageView);
+    }
+
+    @Override
+    public int getItemCount() {
+      return images.size();
+    }
+
+    private final class ViewHolder extends RecyclerView.ViewHolder {
+
+      private final ImageView imageView;
+      private final TextView title;
+
+      ViewHolder(View itemView) {
+        super(itemView);
+        imageView = (ImageView) itemView.findViewById(R.id.image);
+        title = (TextView) itemView.findViewById(R.id.title);
+      }
+    }
+  }
+}
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/MainActivityModule.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/MainActivityModule.java
new file mode 100644
index 000000000..cef304fb2
--- /dev/null
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/MainActivityModule.java
@@ -0,0 +1,10 @@
+package com.bumptech.glide.samples.imgur;
+
+import dagger.Module;
+import dagger.android.ContributesAndroidInjector;
+
+@Module
+abstract class MainActivityModule {
+  @ContributesAndroidInjector
+  abstract MainActivity contributeMainActivityInjector();
+}
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ApiModule.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ApiModule.java
new file mode 100644
index 000000000..7a70c6dc3
--- /dev/null
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ApiModule.java
@@ -0,0 +1,56 @@
+package com.bumptech.glide.samples.imgur.api;
+
+import dagger.Module;
+import dagger.Provides;
+import java.io.IOException;
+import java.util.List;
+import javax.inject.Named;
+import javax.inject.Singleton;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Response;
+import retrofit2.Retrofit;
+import retrofit2.adapter.rxjava.RxJavaCallAdapterFactory;
+import retrofit2.converter.gson.GsonConverterFactory;
+import rx.Observable;
+
+/** Provides classes related to the Imgur API via Dagger. */
+@Module
+public final class ApiModule {
+
+  @Singleton
+  @Named("hotViralImages")
+  @Provides
+  Observable<List<Image>> provideHotViralImages(ImgurObservables imgurObservables) {
+    return imgurObservables.getHotViralImages(5 /*maxPages*/);
+  }
+
+  @Provides ImgurObservables imgurObservables(ImgurService imgurService) {
+    return new ImgurObservables(imgurService);
+  }
+
+  @Provides ImgurService getImgurService(Retrofit retrofit) {
+    return retrofit.create(ImgurService.class);
+  }
+
+  @Provides Retrofit retrofit() {
+    OkHttpClient client = new OkHttpClient.Builder()
+        .addInterceptor(new Interceptor() {
+          @Override
+          public Response intercept(Chain chain) throws IOException {
+            return chain.proceed(
+                chain.request()
+                    .newBuilder()
+                    .addHeader("Authorization", "Client-ID " + ImgurService.CLIENT_ID)
+                    .build());
+          }
+        })
+        .build();
+    return new Retrofit.Builder()
+        .client(client)
+        .addConverterFactory(GsonConverterFactory.create())
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+        .baseUrl("https://api.imgur.com/3/")
+        .build();
+  }
+}
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Gallery.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Gallery.java
new file mode 100644
index 000000000..199752239
--- /dev/null
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Gallery.java
@@ -0,0 +1,19 @@
+package com.bumptech.glide.samples.imgur.api;
+
+import java.util.List;
+
+/**
+ * Represents Imgur's Gallery resource.
+ *
+ * <p>Populated automatically by GSON.
+ */
+final class Gallery {
+  public List<Image> data;
+
+  @Override
+  public String toString() {
+    return "Gallery{"
+        + "data=" + data
+        + '}';
+  }
+}
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Image.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Image.java
new file mode 100644
index 000000000..af157f8cd
--- /dev/null
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Image.java
@@ -0,0 +1,25 @@
+package com.bumptech.glide.samples.imgur.api;
+
+/**
+ * Represents Imgur's Image resource.
+ *
+ * <p>Populated automatically by GSON
+ */
+public final class Image {
+  private String id;
+  public String title;
+  public String description;
+  public String link;
+  boolean is_album;
+
+  @Override
+  public String toString() {
+    return "Image{"
+        + "id='" + id + '\''
+        + ", title='" + title + '\''
+        + ", description='" + description + '\''
+        + ", link='" + link + '\''
+        + ", is_album='" + is_album + '\''
+        + '}';
+  }
+}
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurObservables.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurObservables.java
new file mode 100644
index 000000000..478465160
--- /dev/null
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurObservables.java
@@ -0,0 +1,64 @@
+package com.bumptech.glide.samples.imgur.api;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import rx.Observable;
+import rx.functions.Func1;
+import rx.functions.Func2;
+
+/**
+ * Observables for retrieving metadata from Imgur's API.
+ */
+final class ImgurObservables {
+
+  private final ImgurService imgurService;
+
+  ImgurObservables(ImgurService imgurService) {
+    this.imgurService = imgurService;
+  }
+
+  Observable<List<Image>> getHotViralImages(@SuppressWarnings("SameParameterValue") int maxPages) {
+    return Observable.range(0, maxPages)
+        .flatMap(new Func1<Integer, Observable<List<Image>>>() {
+          @Override
+          public Observable<List<Image>> call(Integer integer) {
+            return imgurService.getHotViral(integer).map(new GetData()).flatMap(
+                new Func1<List<Image>, Observable<List<Image>>>() {
+                  @Override
+                  public Observable<List<Image>> call(List<Image> images) {
+                    for (Iterator<Image> iterator = images.iterator(); iterator.hasNext();) {
+                      if (iterator.next().is_album) {
+                        iterator.remove();
+                      }
+                    }
+                    return Observable.just(images);
+                  }
+                });
+          }
+        })
+        .takeWhile(new Func1<List<Image>, Boolean>() {
+          @Override
+          public Boolean call(List<Image> images) {
+            return !images.isEmpty();
+          }
+        })
+        .scan(new Func2<List<Image>, List<Image>, List<Image>>() {
+          @Override
+          public List<Image> call(List<Image> images, List<Image> images2) {
+            List<Image> result = new ArrayList<>(images.size() + images2.size());
+            result.addAll(images);
+            result.addAll(images2);
+            return result;
+          }
+        })
+        .cache();
+  }
+
+  private static class GetData implements Func1<Gallery, List<Image>> {
+    @Override
+    public List<Image> call(Gallery gallery) {
+      return gallery.data;
+    }
+  }
+}
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurService.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurService.java
new file mode 100644
index 000000000..ddab15062
--- /dev/null
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurService.java
@@ -0,0 +1,41 @@
+package com.bumptech.glide.samples.imgur.api;
+
+import retrofit2.http.GET;
+import retrofit2.http.Path;
+import rx.Observable;
+
+/**
+ * Define's Imgur's API for Retrofit.
+ */
+public interface ImgurService {
+  String CLIENT_ID = "36d1f6bef16370c";
+
+  @GET("gallery/hot/viral/{page}")
+  Observable<Gallery> getHotViral(@Path("page") int page);
+
+  @GET("gallery/hot/{sort}/{page}.json")
+  Observable<Gallery> getHot(@Path("sort") Sort sort, @Path("page") int page);
+
+  @GET("gallery/{section}/{sort}/{page}.json")
+  Observable<Gallery> getGallery(@Path("section") Section section,
+      @Path("sort") Sort sort, @Path("page") int page);
+
+  /**
+   * Sections that Imgur's API allows us to query from.
+   */
+  enum Section {
+    hot,
+    top,
+    user
+  }
+
+  /**
+   * The sort order for content within a particular section.
+   */
+  enum Sort {
+    viral,
+    top,
+    time,
+    rising
+  }
+}
diff --git a/samples/imgur/src/main/res/layout/activity_main.xml b/samples/imgur/src/main/res/layout/activity_main.xml
new file mode 100644
index 000000000..4e7309f0a
--- /dev/null
+++ b/samples/imgur/src/main/res/layout/activity_main.xml
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?>
+<merge
+  xmlns:android="http://schemas.android.com/apk/res/android"
+  xmlns:tools="http://schemas.android.com/tools"
+  tools:context="com.bumptech.glide.samples.imgur.MainActivity">
+
+  <android.support.v7.widget.RecyclerView
+    android:id="@+id/recycler_view"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:scrollbars="vertical"
+    />
+</merge>
diff --git a/samples/imgur/src/main/res/layout/image_card.xml b/samples/imgur/src/main/res/layout/image_card.xml
new file mode 100644
index 000000000..92f2cbb76
--- /dev/null
+++ b/samples/imgur/src/main/res/layout/image_card.xml
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="utf-8"?>
+<FrameLayout
+  xmlns:android="http://schemas.android.com/apk/res/android"
+  xmlns:card_view="http://schemas.android.com/apk/res-auto"
+  android:layout_width="match_parent"
+  android:layout_height="wrap_content"
+  android:padding="16dp">
+
+  <android.support.v7.widget.CardView
+    android:id="@+id/card_view"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    card_view:cardCornerRadius="4dp">
+    <LinearLayout
+      android:orientation="vertical"
+      android:padding="16dp"
+      android:gravity="center"
+      android:layout_width="match_parent"
+      android:layout_height="wrap_content">
+      <ImageView
+        android:id="@+id/image"
+        android:scaleType="fitCenter"
+        android:layout_width="match_parent"
+        android:layout_height="150dp"
+        android:contentDescription="@null"/>
+      <TextView
+        android:id="@+id/title"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:gravity="center"
+        android:paddingTop="16dp"
+        />
+    </LinearLayout>
+  </android.support.v7.widget.CardView>
+</FrameLayout>
diff --git a/samples/imgur/src/main/res/mipmap-hdpi/ic_launcher.png b/samples/imgur/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100644
index 000000000..cde69bccc
Binary files /dev/null and b/samples/imgur/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/samples/imgur/src/main/res/mipmap-hdpi/ic_launcher_round.png b/samples/imgur/src/main/res/mipmap-hdpi/ic_launcher_round.png
new file mode 100644
index 000000000..9a078e3e1
Binary files /dev/null and b/samples/imgur/src/main/res/mipmap-hdpi/ic_launcher_round.png differ
diff --git a/samples/imgur/src/main/res/mipmap-mdpi/ic_launcher.png b/samples/imgur/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100644
index 000000000..c133a0cbd
Binary files /dev/null and b/samples/imgur/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/samples/imgur/src/main/res/mipmap-mdpi/ic_launcher_round.png b/samples/imgur/src/main/res/mipmap-mdpi/ic_launcher_round.png
new file mode 100644
index 000000000..efc028a63
Binary files /dev/null and b/samples/imgur/src/main/res/mipmap-mdpi/ic_launcher_round.png differ
diff --git a/samples/imgur/src/main/res/mipmap-xhdpi/ic_launcher.png b/samples/imgur/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100644
index 000000000..bfa42f0e7
Binary files /dev/null and b/samples/imgur/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/samples/imgur/src/main/res/mipmap-xhdpi/ic_launcher_round.png b/samples/imgur/src/main/res/mipmap-xhdpi/ic_launcher_round.png
new file mode 100644
index 000000000..3af2608a4
Binary files /dev/null and b/samples/imgur/src/main/res/mipmap-xhdpi/ic_launcher_round.png differ
diff --git a/samples/imgur/src/main/res/mipmap-xxhdpi/ic_launcher.png b/samples/imgur/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100644
index 000000000..324e72cdd
Binary files /dev/null and b/samples/imgur/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/samples/imgur/src/main/res/mipmap-xxhdpi/ic_launcher_round.png b/samples/imgur/src/main/res/mipmap-xxhdpi/ic_launcher_round.png
new file mode 100644
index 000000000..9bec2e623
Binary files /dev/null and b/samples/imgur/src/main/res/mipmap-xxhdpi/ic_launcher_round.png differ
diff --git a/samples/imgur/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/samples/imgur/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100644
index 000000000..aee44e138
Binary files /dev/null and b/samples/imgur/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/samples/imgur/src/main/res/mipmap-xxxhdpi/ic_launcher_round.png b/samples/imgur/src/main/res/mipmap-xxxhdpi/ic_launcher_round.png
new file mode 100644
index 000000000..34947cd6b
Binary files /dev/null and b/samples/imgur/src/main/res/mipmap-xxxhdpi/ic_launcher_round.png differ
diff --git a/samples/imgur/src/main/res/values/colors.xml b/samples/imgur/src/main/res/values/colors.xml
new file mode 100644
index 000000000..5a077b3a7
--- /dev/null
+++ b/samples/imgur/src/main/res/values/colors.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+  <color name="colorPrimary">#3F51B5</color>
+  <color name="colorPrimaryDark">#303F9F</color>
+  <color name="colorAccent">#FF4081</color>
+</resources>
diff --git a/samples/imgur/src/main/res/values/strings.xml b/samples/imgur/src/main/res/values/strings.xml
new file mode 100644
index 000000000..73f9f0e5a
--- /dev/null
+++ b/samples/imgur/src/main/res/values/strings.xml
@@ -0,0 +1,3 @@
+<resources>
+  <string name="app_name">Imgur</string>
+</resources>
diff --git a/samples/imgur/src/main/res/values/styles.xml b/samples/imgur/src/main/res/values/styles.xml
new file mode 100644
index 000000000..ccfe4e02e
--- /dev/null
+++ b/samples/imgur/src/main/res/values/styles.xml
@@ -0,0 +1,11 @@
+<resources>
+
+  <!-- Base application theme. -->
+  <style name="AppTheme" parent="Theme.AppCompat">
+    <!-- Customize your theme here. -->
+    <item name="colorPrimary">@color/colorPrimary</item>
+    <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
+    <item name="colorAccent">@color/colorAccent</item>
+  </style>
+
+</resources>
diff --git a/samples/svg/build.gradle b/samples/svg/build.gradle
index e244935ea..e6a204650 100644
--- a/samples/svg/build.gradle
+++ b/samples/svg/build.gradle
@@ -1,14 +1,14 @@
 apply plugin: 'com.android.application'
 
 dependencies {
-    compile project(':library')
+    implementation project(':library')
     annotationProcessor project(':annotation:compiler')
-    compile 'com.caverock:androidsvg:1.2.1'
+    implementation 'com.caverock:androidsvg:1.2.1'
+    implementation "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         applicationId 'com.bumptech.glide.samples.svg'
diff --git a/samples/svg/lint.xml b/samples/svg/lint.xml
index 95a2ab036..11fca2666 100644
--- a/samples/svg/lint.xml
+++ b/samples/svg/lint.xml
@@ -2,4 +2,6 @@
 <lint>
     <!-- Not supported by all build systems -->
     <issue id="GradleOverrides" severity="ignore" />
+    <issue id="GoogleAppIndexingWarning" severity="ignore"/>
+    <issue id="GradleDependency" severity="ignore"/>
 </lint>
diff --git a/samples/svg/proguard-rules.pro b/samples/svg/proguard-rules.pro
deleted file mode 100644
index 95c847b91..000000000
--- a/samples/svg/proguard-rules.pro
+++ /dev/null
@@ -1,17 +0,0 @@
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in /Users/judds/dev/adt-bundle-mac-x86_64-20131030/sdk/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the proguardFiles
-# directive in build.gradle.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
diff --git a/samples/svg/src/main/AndroidManifest.xml b/samples/svg/src/main/AndroidManifest.xml
index 7328e723d..bb5888e5e 100644
--- a/samples/svg/src/main/AndroidManifest.xml
+++ b/samples/svg/src/main/AndroidManifest.xml
@@ -5,7 +5,7 @@
     <uses-permission android:name="android.permission.INTERNET"/>
 
     <application
-        android:allowBackup="true"
+        android:allowBackup="false"
         android:icon="@android:drawable/sym_def_app_icon"
         android:label="@string/app_name">
         <activity
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/MainActivity.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/MainActivity.java
index f60b46461..d91a9f665 100644
--- a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/MainActivity.java
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/MainActivity.java
@@ -13,6 +13,7 @@
 import android.widget.TextView;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.util.Preconditions;
 import java.io.File;
 
 /**
@@ -53,7 +54,7 @@ public void clearCache(View v) {
     glideRequests.clear(imageViewRes);
     glideRequests.clear(imageViewNet);
     GlideApp.get(this).clearMemory();
-    File cacheDir = Glide.getPhotoCacheDir(this);
+    File cacheDir = Preconditions.checkNotNull(Glide.getPhotoCacheDir(this));
     if (cacheDir.isDirectory()) {
       for (File child : cacheDir.listFiles()) {
         if (!child.delete()) {
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDecoder.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDecoder.java
index 3fdd91ad5..ad2212227 100644
--- a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDecoder.java
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDecoder.java
@@ -1,12 +1,12 @@
 package com.bumptech.glide.samples.svg;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.SimpleResource;
 import com.caverock.androidsvg.SVG;
 import com.caverock.androidsvg.SVGParseException;
-
 import java.io.IOException;
 import java.io.InputStream;
 
@@ -16,16 +16,17 @@
 public class SvgDecoder implements ResourceDecoder<InputStream, SVG> {
 
   @Override
-  public boolean handles(InputStream source, Options options) throws IOException {
+  public boolean handles(@NonNull InputStream source, @NonNull Options options) {
     // TODO: Can we tell?
     return true;
   }
 
-  public Resource<SVG> decode(InputStream source, int width, int height, Options options)
+  public Resource<SVG> decode(@NonNull InputStream source, int width, int height,
+      @NonNull Options options)
       throws IOException {
     try {
       SVG svg = SVG.getFromInputStream(source);
-      return new SimpleResource<SVG>(svg);
+      return new SimpleResource<>(svg);
     } catch (SVGParseException ex) {
       throw new IOException("Cannot load SVG from stream", ex);
     }
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDrawableTranscoder.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDrawableTranscoder.java
index 43352acd8..a3fd80abf 100644
--- a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDrawableTranscoder.java
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDrawableTranscoder.java
@@ -2,7 +2,9 @@
 
 import android.graphics.Picture;
 import android.graphics.drawable.PictureDrawable;
-
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.SimpleResource;
 import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
@@ -13,12 +15,13 @@
  * ({@link Picture}).
  */
 public class SvgDrawableTranscoder implements ResourceTranscoder<SVG, PictureDrawable> {
+  @Nullable
   @Override
-  public Resource<PictureDrawable> transcode(Resource<SVG> toTranscode) {
+  public Resource<PictureDrawable> transcode(@NonNull Resource<SVG> toTranscode,
+      @NonNull Options options) {
     SVG svg = toTranscode.get();
     Picture picture = svg.renderToPicture();
     PictureDrawable drawable = new PictureDrawable(picture);
-    return new SimpleResource<PictureDrawable>(drawable);
+    return new SimpleResource<>(drawable);
   }
 }
-
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java
index 798d0f07f..fdd14df98 100644
--- a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java
@@ -2,6 +2,7 @@
 
 import android.content.Context;
 import android.graphics.drawable.PictureDrawable;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.Registry;
 import com.bumptech.glide.annotation.GlideModule;
@@ -15,7 +16,8 @@
 @GlideModule
 public class SvgModule extends AppGlideModule {
   @Override
-  public void registerComponents(Context context, Glide glide, Registry registry) {
+  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry) {
     registry.register(SVG.class, PictureDrawable.class, new SvgDrawableTranscoder())
         .append(InputStream.class, SVG.class, new SvgDecoder());
   }
diff --git a/samples/svg/src/main/res/drawable/image_loading.xml b/samples/svg/src/main/res/drawable/image_loading.xml
index ad1bddfad..762e38664 100644
--- a/samples/svg/src/main/res/drawable/image_loading.xml
+++ b/samples/svg/src/main/res/drawable/image_loading.xml
@@ -2,7 +2,7 @@
 <layer-list xmlns:android="http://schemas.android.com/apk/res/android">
     <item>
         <bitmap
-            android:src="@android:drawable/sym_def_app_icon"
+            android:src="@mipmap/ic_launcher"
             android:gravity="center" />
     </item>
     <item
diff --git a/samples/svg/src/main/res/layout/activity_main.xml b/samples/svg/src/main/res/layout/activity_main.xml
index 704faa1f9..bff58690a 100644
--- a/samples/svg/src/main/res/layout/activity_main.xml
+++ b/samples/svg/src/main/res/layout/activity_main.xml
@@ -16,7 +16,7 @@
         android:onClick="clearCache"
         android:clickable="true"
         android:text="@string/hello_world"
-        />
+        android:focusable="true"/>
 
     <Button
         android:id="@+id/button"
diff --git a/samples/svg/src/main/res/mipmap-hdpi/ic_launcher.png b/samples/svg/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100644
index 000000000..cde69bccc
Binary files /dev/null and b/samples/svg/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/samples/svg/src/main/res/mipmap-mdpi/ic_launcher.png b/samples/svg/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100644
index 000000000..c133a0cbd
Binary files /dev/null and b/samples/svg/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/samples/svg/src/main/res/mipmap-xhdpi/ic_launcher.png b/samples/svg/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100644
index 000000000..bfa42f0e7
Binary files /dev/null and b/samples/svg/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/samples/svg/src/main/res/mipmap-xxhdpi/ic_launcher.png b/samples/svg/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100644
index 000000000..324e72cdd
Binary files /dev/null and b/samples/svg/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/samples/svg/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/samples/svg/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100644
index 000000000..aee44e138
Binary files /dev/null and b/samples/svg/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/scripts/android-wait-for-emulator.sh b/scripts/android-wait-for-emulator.sh
new file mode 100755
index 000000000..aa6345d8b
--- /dev/null
+++ b/scripts/android-wait-for-emulator.sh
@@ -0,0 +1,25 @@
+#!/bin/bash
+
+# Originally written by Ralf Kistner <ralf@embarkmobile.com>, but placed in the public domain
+
+set +e
+
+bootanim=""
+failcounter=0
+timeout_in_sec=360
+
+until [[ "$bootanim" =~ "stopped" ]]; do
+  bootanim=`adb -e shell getprop init.svc.bootanim 2>&1 &`
+  if [[ "$bootanim" =~ "device not found" || "$bootanim" =~ "device offline"
+    || "$bootanim" =~ "running" ]]; then
+    let "failcounter += 1"
+    echo "Waiting for emulator to start"
+    if [[ $failcounter -gt timeout_in_sec ]]; then
+      echo "Timeout ($timeout_in_sec seconds) reached; failed to start emulator"
+      exit 1
+    fi
+  fi
+  sleep 1
+done
+
+echo "Emulator is ready"
diff --git a/scripts/install_firebase.sh b/scripts/install_firebase.sh
new file mode 100755
index 000000000..594d16e87
--- /dev/null
+++ b/scripts/install_firebase.sh
@@ -0,0 +1,10 @@
+#!/usr/bin/env bash
+
+set -e
+
+openssl aes-256-cbc -K $encrypted_ad2664a1c4dd_key -iv $encrypted_ad2664a1c4dd_iv -in $GCLOUD_FILE -out gcloud.json -d
+
+wget https://dl.google.com/dl/cloudsdk/channels/rapid/downloads/google-cloud-sdk-176.0.0-linux-x86_64.tar.gz
+tar xf google-cloud-sdk-176.0.0-linux-x86_64.tar.gz
+echo "y" | ./google-cloud-sdk/bin/gcloud components update beta
+./google-cloud-sdk/bin/gcloud auth activate-service-account --key-file gcloud.json
diff --git a/scripts/regenerate_resources.sh b/scripts/regenerate_resources.sh
new file mode 100755
index 000000000..4536c8da9
--- /dev/null
+++ b/scripts/regenerate_resources.sh
@@ -0,0 +1,76 @@
+#!/usr/bin/env bash
+#
+# Generates or regenerates canonical resources for Glide's emulator tests with the cooperation
+# of the BitmapRegressionTester class.
+#
+# Usage:
+# ./scripts/regenerate_resources.sh <com.bumptech.glide.instrumentation.class_name>
+#
+# The class name is optional. If not specified all tests will be run (including those that
+# do not generate resources).
+
+# The signal file that tells BitmapRegressionTester to generate the resource files.
+REGENERATE_FILE_NAME="regenerate"
+# The name of the subfolder on the sdcard where resources are stored on the device/emulator.
+DIRECTORY_NAME="test_files"
+# The full path to a place where the app is able to write resources and we're able to read them.
+DIRECTORY="/sdcard/DCIM/${DIRECTORY_NAME}"
+
+set -e
+
+if [ "$#" -eq 1 ]; then
+  test_restriction="-Pandroid.testInstrumentationRunnerArguments.class=${1}"
+fi
+
+exec 3>&1
+exec 4>&2
+if !(($VERBOSE)); then
+  exec 1>/dev/null
+  exec 2>/dev/null
+fi
+
+echo "Setting up environment..."  1>&3 2>&4
+adb devices | grep -v "List of devices" | grep device \
+  || echo "No devices found, try starting an emulator" 1>&3 2>&4
+
+adb root || true 
+# In case there are any old artifacts from an old or failed test, clean them up.
+adb shell rm -r $DIRECTORY || true
+# Create the signal file.
+# On some emulators touch fails if the directory isn't created first.
+adb shell mkdir /sdcard/DCIM || true
+adb shell mkdir $DIRECTORY || true
+# This actually has to work, previous steps may fail if the directories already exist.
+adb shell touch "${DIRECTORY}/${REGENERATE_FILE_NAME}"
+
+# On APIs > 22 we need to grant the appropriate runtime permissions so our test APK can write
+# resource files to the public sdcard. Cache and internal cache directories aren't consistently
+# available across all versions of Android. So far this is the best cross SDK solution I've 
+# found
+sdk_version=`adb shell getprop ro.build.version.sdk`
+sdk_version=`echo $sdk_version | tr -d '\r'`
+if [[ $sdk_version -gt 22 ]]; then
+  echo "Installing apks and granting runtime permissions..." 1>&3 2>&4
+  ./gradlew :instrumentation:installDebug :instrumentation:installDebugAndroidTest 
+  adb shell pm grant com.bumptech.glide.instrumentation android.permission.WRITE_EXTERNAL_STORAGE
+  adb shell pm grant com.bumptech.glide.instrumentation android.permission.READ_EXTERNAL_STORAGE
+  adb shell pm grant com.bumptech.glide.instrumentation.test android.permission.WRITE_EXTERNAL_STORAGE
+  adb shell pm grant com.bumptech.glide.instrumentation.test android.permission.READ_EXTERNAL_STORAGE
+fi
+
+echo "Generating updated resource files..." 1>&3 2>&4
+./gradlew :instrumentation:connectedDebugAndroidTest $test_restriction --parallel || true 
+
+echo "Copying updated resource files to res directory..." 1>&3 2>&4
+adb pull $DIRECTORY
+rm "${DIRECTORY_NAME}/${REGENERATE_FILE_NAME}" 
+cp $DIRECTORY_NAME/raw/* instrumentation/src/main/res/raw 
+rm -rf $DIRECTORY_NAME
+adb shell rm -r $DIRECTORY
+ 
+echo "Verifying all tests pass..." 1>&3 2>&4
+
+./gradlew :instrumentation:clean
+./gradlew :instrumentation:connectedDebugAndroidTest $test_restriction --parallel
+
+echo "Complete!" 1>&3 2>&4
diff --git a/scripts/release_checks.sh b/scripts/release_checks.sh
new file mode 100755
index 000000000..e25412f51
--- /dev/null
+++ b/scripts/release_checks.sh
@@ -0,0 +1,87 @@
+#!/usr/bin/env bash
+
+set -e
+
+if [ "$#" -ne 1 ]; then
+  echo "Usage: ./release_checks.sh <major.minor.patch[-SNAPSHOT]>"
+  exit 1
+fi
+
+if [[ $(git status -uno --porcelain) ]]; then
+  echo "One or more changes, commit or revert first."
+  git status -uno --porcelain
+  exit 1
+fi
+if [[ $(git rev-list master...bump/master --count) -ne 0 ]]; then
+  echo "Bump and master are not up to date"
+  git rev-list master...bump/master --pretty
+  exit 1
+fi
+if [[ $(git rev-list master...origin/master --count) -ne 0 ]]; then
+  echo "Origin and master are not up to date"
+  git rev-list master...origin/master --pretty
+  exit 1
+fi
+if [[ $(git ls-files --exclude-standard --others) ]]; then
+  echo "Untracked files, aborting"
+  exit 1
+fi
+
+version=$1
+echo "Setting version to $version"
+echo -n "Is this a correct? (y/n)? "
+read answer
+if echo "$answer" | grep -iq "^y" ; then
+  echo "Updating gradle.properties..."
+else
+  echo "Cancelling"
+  exit 1
+fi
+
+sed -i '' "s/VERSION_NAME=.*/VERSION_NAME=${version}/g" gradle.properties
+sed -i '' "s/VERSION_MAJOR=.*/VERSION_MAJOR=$(echo $version | cut -d '.' -f 1)/" gradle.properties
+sed -i '' "s/VERSION_MINOR=.*/VERSION_MINOR=$(echo $version | cut -d '.' -f 2)/" gradle.properties
+sed -i '' "s/VERSION_PATCH=.*/VERSION_PATCH=$(echo $version | cut -d '.' -f 3 | sed 's/-.*//')/" gradle.properties
+
+git diff
+
+echo "Updated gradle.properties, is this correct? (y/n)?"
+read answer
+if echo "$answer" | grep -iq "^y" ; then
+  echo "Committing..."
+else
+  echo "Cancelling"
+  exit 1
+fi
+
+version_tag="v${version}"
+git add gradle.properties
+git commit -m "Bump version to ${version}"
+if [[ $version != *"SNAPSHOT"* ]]; then
+  echo "Found release version, adding tag, building and uploading"
+  git tag $version_tag
+
+  echo "Building... and uploading"
+  ./gradlew clean build --parallel
+  ./gradlew uploadArchives 
+
+  echo "Upload complete, please verify the output and upload the jars to the GitHub release."
+fi
+
+echo -n "Ready to push, continue? (y/n)? "
+read answer
+if echo "$answer" | grep -iq "^y" ; then
+  echo "Pushing commits"
+else
+  echo "Cancelling"
+  exit 1
+fi
+
+git push origin master
+git push bump master
+if [[ $version != *"SNAPSHOT"* ]]; then
+  echo "Found release version, pushing tags"
+  git push origin $version_tag
+  git push bump $version_tag
+fi
+
diff --git a/scripts/run_instrumentation_tests.sh b/scripts/run_instrumentation_tests.sh
new file mode 100755
index 000000000..412690a8a
--- /dev/null
+++ b/scripts/run_instrumentation_tests.sh
@@ -0,0 +1,20 @@
+#!/usr/bin/env bash
+# Runs instrumentation tests on firebase. Must be run locally, not on travis.
+#
+# Usage: 
+# ./scripts/run_instrumentation_test.sh
+
+./gradlew :instrumentation:assembleDebug :instrumentation:assembleDebugAndroidTest --parallel
+
+apk_dir=instrumentation/build/outputs/apk
+gcloud firebase test android run \
+  --type instrumentation \
+  --app $apk_dir/instrumentation-debug.apk \
+  --test $apk_dir/instrumentation-debug-androidTest.apk \
+  --device model=Nexus6P,version=26,locale=en,orientation=portrait  \
+  --device model=Nexus6P,version=25,locale=en,orientation=portrait \
+  --device model=Nexus6P,version=23,locale=en,orientation=portrait \
+  --device model=Nexus6,version=22,locale=en,orientation=portrait \
+  --device model=Nexus5,version=19,locale=en,orientation=portrait \
+  --project android-glide \
+  --no-auto-google-login \
diff --git a/scripts/run_sample_robo_tests.sh b/scripts/run_sample_robo_tests.sh
new file mode 100755
index 000000000..d7c9cc23d
--- /dev/null
+++ b/scripts/run_sample_robo_tests.sh
@@ -0,0 +1,44 @@
+#!/usr/bin/env bash
+# Runs Firebases' robo tests (monkeyrunner) on Glide's sample apps
+#
+# Usage: 
+# ./scripts/run_sample_robo_tests.sh
+
+set -e
+
+./gradlew :samples:flickr:build \
+  :samples:giphy:build \
+  :samples:contacturi:build \
+  :samples:gallery:build \
+  :samples:imgur:build \
+  :samples:svg:build \
+  --parallel
+
+declare -a samples=("flickr" 
+                "giphy" 
+                "contacturi"
+                "gallery"
+                "imgur"
+                "svg")
+pids=()
+
+for sample in "${samples[@]}"
+do
+  sample_dir="samples/${sample}/build/outputs/apk/"
+  sample_apk="${sample_dir}/${sample}-debug.apk"
+  gcloud firebase test android run \
+    --type robo \
+    --app $sample_apk \
+    --device model=Nexus6P,version=26,locale=en,orientation=portrait  \
+    --project android-glide \
+    --no-auto-google-login &
+  pids+=("$!")
+done
+
+for current in "${pids[@]}"
+do
+  wait $current
+done
+       
+
+
diff --git a/scripts/split_by_sdk.sh b/scripts/split_by_sdk.sh
new file mode 100755
index 000000000..8e700ba8a
--- /dev/null
+++ b/scripts/split_by_sdk.sh
@@ -0,0 +1,169 @@
+#!/usr/bin/env bash
+#
+# Loops through all Android API levels that Glide supports (and that 
+# functioning emulators exist for) and runs a particular emulator test file
+# to generate canonical assets. If assets start to fail on a particular sdk
+# level, the test file is updated with the new API level to split on and 
+# assets for that particular api level are added to the test resources 
+# directory.
+#
+# Usage:
+#   ./scripts/split_by_sdk.sh [--abis x86,armeabi-v7a] [--apis 16,17] \
+#      [-v/--verbose] [--tests com.bumptech.glide.TestName1,com.bumptech.glide.TestName2]
+#
+# apis: The Android SDK version(s) you want to run against.
+# abis: The Android CPU types you want to run against
+# v/verbose: Enable verbose logging.
+
+POSITIONAL=()
+while [[ $# -gt 0 ]]
+do
+key="$1"
+
+case $key in
+    --tests)
+    test_classes_string="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    --apis)
+    apis_string="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    --abis)
+    abis_string="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    -v|--verbose)
+    verbose="1"
+    shift # past argument
+    ;;
+    *)    # unknown option
+    POSITIONAL+=("$1") # save it in an array for later
+    shift # past argument
+    ;;
+esac
+done
+set -- "${POSITIONAL[@]}" # restore positional parameters
+
+if [ -z "$test_classes_string" ]; then
+  test_classes_string=`grep -rwl instrumentation/src/androidTest -e RegressionTest \
+    | grep -v "/test/" \
+    | grep -v ".bak" \
+    | tr '\n' ',' \
+    | sed 's/instrumentation\/src\/androidTest\/java\///g' \
+    | sed 's/\//\./g' \
+    | sed 's/\.java//g' \
+    | sed 's/,*$//g'` 
+fi
+
+if [ -z "$apis_string" ]; then
+  declare -a apis=(
+                  "16" 
+                  #"17" API 17 emulator seems to have trouble starting and I haven't yet found a case where behaviors changed at that API level.
+                  "18"
+                  "19"
+                  # "20" Android Wear, missing x86 emulators.
+                  "21"
+                  "22"
+                  "23"
+                  "24"
+                  "25"
+                  "26")
+else 
+  IFS=',' read -ra apis <<< "$apis_string"
+fi
+
+if [ -z "$abis_string" ]; then
+  declare -a abis=(
+  "x86"
+  "armeabi-v7a"
+  )
+else 
+  IFS=',' read -ra abis <<< "$abis_string"
+fi
+
+IFS=',' read -ra test_classes <<< "$test_classes_string"
+for test_class in "${test_classes[@]}"
+do
+  test_path=`echo $test_class | sed 's/\./\//g' | sed -e 's/^/instrumentation\/src\/androidTest\/java\//' | sed -e 's/$/\.java/'`
+  if [ ! -f "${test_path}" ]; then
+    echo "Missing test $test_class at expected path: $test_path"
+    exit 1
+  fi
+done
+
+if (($verbose)); then
+  printf "tests: "
+  printf '%s,' "${test_classes[@]}"
+  printf "\nabis:"
+  printf '%s,' "${abis[@]}"
+  printf "\napis:"
+  printf '%s,' "${apis[@]}"
+  printf "\n"
+fi
+
+adb devices | grep -v "List of devices" | grep device > /dev/null 2>&1 \
+  && \
+  { \
+    echo "Emulators are already running, kill them before running this script: "; \
+    echo "e.g.: adb -s emulator-5554 emu kill"; \
+    adb devices; \
+    exit 1; \
+  }
+
+exec 3>&1
+exec 4>&2
+if !(($verbose)); then
+  exec 1>/dev/null
+  exec 2>/dev/null
+fi
+
+for abi in "${abis[@]}"
+do
+  if [ "${abi}" == "armeabi-v7a" ]; then
+    emulator_type="default"
+    emulator_script=$ANDROID_HOME/emulator/emulator
+  else 
+    emulator_type="google_apis"
+    emulator_script=$ANDROID_HOME/tools/emulator
+  fi
+
+  for api in "${apis[@]}"
+  do
+    if [ "${abi}" == "armeabi-v7a" ] && [ "${api}" -gt 22 ]; then
+      echo "armeabi-v7a emulators beyond API 22 are unreliable, ignoring ${api}"
+      continue
+    fi
+
+    echo "Checking on API ${api} and ${abi}" 1>&3 2>&4
+    target="system-images;android-${api};${emulator_type};${abi}"
+    sdkmanager --install $target
+    avdmanager create avd --force -n test -k $target --device "Nexus 5X" -c 2000M 
+    QEMU_AUDIO_DRV=none $emulator_script -avd test -no-window &
+    pid=$!
+    ./scripts/android-wait-for-emulator.sh
+    for test_class in "${test_classes[@]}"
+    do
+      test_path=`echo $test_class | sed 's/\./\//g' | sed -e 's/^/instrumentation\/src\/androidTest\/java\//' | sed -e 's/$/\.java/'`
+      ./gradlew :instrumentation:connectedCheck \
+        -Pandroid.testInstrumentationRunnerArguments.class=$test_class
+      if [ $? -ne 0 ]; then
+        echo "Tests for API ${api} failed, updating SplitBySdk and generating resources..." 1>&3 2>&4
+        if [ -z $(grep "@SplitBySdk" $test_path | grep "${api}") ]; then
+          sed -i.bak s/@SplitBySdk\(\{/@SplitBySdk\(\{$api,/ $test_path
+          rm "${test_path}.bak"
+        fi
+        ./scripts/regenerate_resources.sh $test_class #|| { echo "Tests still fail with new resources, aborting";  exit 1; }
+      fi
+    done
+    adb -s emulator-5554 emu kill
+    sleep 1
+    kill -9 $pid
+    pkill emulator64-crash-service
+    pkill emulator-crash-service
+    echo "Finished API ${api}" 1>&3 2>&4
+  done
+done
diff --git a/scripts/travis_after_success.sh b/scripts/travis_after_success.sh
new file mode 100755
index 000000000..d9c2a3042
--- /dev/null
+++ b/scripts/travis_after_success.sh
@@ -0,0 +1,7 @@
+#!/usr/bin/env bash
+
+set -e
+
+if [ "$COMPONENT" == "unit" ]; then
+  ./scripts/travis_sonatype_publish.sh
+fi
diff --git a/scripts/travis_before_script.sh b/scripts/travis_before_script.sh
new file mode 100755
index 000000000..e45e901af
--- /dev/null
+++ b/scripts/travis_before_script.sh
@@ -0,0 +1,7 @@
+#!/usr/bin/env bash
+# Copies our debug.keystore file to its expected location to avoid a bug
+# where the Android build system seems to occasionally fail to generate it.
+
+set -e
+
+cp debug.keystore ~/.android/debug.keystore
diff --git a/scripts/travis_create_emulator.sh b/scripts/travis_create_emulator.sh
new file mode 100755
index 000000000..997ffcdcc
--- /dev/null
+++ b/scripts/travis_create_emulator.sh
@@ -0,0 +1,11 @@
+#!/usr/bin/env bash
+
+set -e
+
+target="system-images;android-${ANDROID_TARGET};default;armeabi-v7a"
+echo y | sdkmanager --update
+echo y | sdkmanager --install $target
+avdmanager create avd --force -n test -k $target --device "Nexus 4" -c 2048M
+QEMU_AUDIO_DRV=none $ANDROID_HOME/emulator/emulator -avd test -no-window -memory 2048 &
+
+exit 0
diff --git a/scripts/travis_firebase.sh b/scripts/travis_firebase.sh
new file mode 100755
index 000000000..e405462a5
--- /dev/null
+++ b/scripts/travis_firebase.sh
@@ -0,0 +1,32 @@
+#!/usr/bin/env bash
+
+set -e
+
+if [ ! "$firebase_enabled" == "true" ]; then
+  echo "Unable to run Firebase tests for pull requests, exiting"
+  exit 0
+fi
+
+./gradlew :instrumentation:assembleDebug \
+  :instrumentation:assembleDebugAndroidTest \
+  --parallel \
+  -PDISABLE_ERROR_PRONE &
+pid=$!
+./scripts/install_firebase.sh
+wait $pid
+
+apk_dir=instrumentation/build/outputs/apk
+./google-cloud-sdk/bin/gcloud firebase test android run \
+  --type instrumentation \
+  --app $apk_dir/debug/instrumentation-debug.apk \
+  --test $apk_dir/androidTest/debug/instrumentation-debug-androidTest.apk \
+  --device model=Nexus6P,version=27,locale=en,orientation=portrait \
+  --device model=Nexus6P,version=26,locale=en,orientation=portrait \
+  --device model=Nexus6P,version=25,locale=en,orientation=portrait \
+  --device model=Nexus6P,version=24,locale=en,orientation=portrait \
+  --device model=Nexus6P,version=23,locale=en,orientation=portrait \
+  --device model=Nexus6,version=22,locale=en,orientation=portrait \
+  --device model=Nexus5,version=21,locale=en,orientation=portrait \
+  --device model=Nexus5,version=19,locale=en,orientation=portrait \
+  --project android-glide \
+  --no-auto-google-login \
diff --git a/scripts/travis_instrumentation.sh b/scripts/travis_instrumentation.sh
new file mode 100755
index 000000000..d365034bf
--- /dev/null
+++ b/scripts/travis_instrumentation.sh
@@ -0,0 +1,17 @@
+#!/usr/bin/env bash
+
+set -e
+
+echo "Starting emulator for $COMPONENT tests"
+./scripts/travis_create_emulator.sh &
+
+./gradlew :instrumentation:assembleDebug \
+  :instrumentation:assembleDebugAndroidTest \
+  --parallel \
+  -PDISABLE_ERROR_PRONE
+
+echo "Waiting for emulator..."
+android-wait-for-emulator
+
+for i in {1..3}; do ./gradlew :instrumentation:connectedDebugAndroidTest && break; done
+
diff --git a/scripts/travis_samples.sh b/scripts/travis_samples.sh
new file mode 100755
index 000000000..45fe59827
--- /dev/null
+++ b/scripts/travis_samples.sh
@@ -0,0 +1,53 @@
+#!/usr/bin/env bash
+
+set -e
+
+./gradlew :samples:flickr:build \
+  :samples:giphy:build \
+  :samples:contacturi:build \
+  :samples:gallery:build \
+  :samples:imgur:build \
+  :samples:svg:build \
+  --parallel \
+  -PERROR_PRONE="false" &
+pid=$!
+
+if [ ! "$firebase_enabled" == "true" ]; then
+  wait $pid
+  echo "Unable to run Firebase tests for pull requests, exiting"
+  exit 0
+else
+  ./scripts/install_firebase.sh
+  wait $pid
+fi
+
+
+declare -a samples=("flickr"
+                "giphy"
+                "contacturi"
+                "gallery"
+                "imgur"
+                "svg")
+pids=()
+
+for sample in "${samples[@]}"
+do
+  sample_dir="samples/${sample}/build/outputs/apk/debug"
+  sample_apk="${sample_dir}/${sample}-debug.apk"
+  ./google-cloud-sdk/bin/gcloud firebase test android run \
+    --type robo \
+    --app $sample_apk \
+    --device model=Nexus6P,version=26,locale=en,orientation=portrait  \
+    --project android-glide \
+    --no-auto-google-login \
+    --timeout 5m \
+    &
+  pids+=("$!")
+done
+
+for current in "${pids[@]}"
+do
+  wait $current
+done
+
+
diff --git a/scripts/travis_script.sh b/scripts/travis_script.sh
new file mode 100755
index 000000000..ab103e875
--- /dev/null
+++ b/scripts/travis_script.sh
@@ -0,0 +1,23 @@
+#!/usr/bin/env bash
+
+set -e
+
+if [ -z ${encrypted_ad2664a1c4dd_key+x} ] || [ -z ${encrypted_ad2664a1c4dd_iv+x} ] || [ -z ${GCLOUD_FILE} ]; then
+  export firebase_enabled="false"
+else
+  export firebase_enabled="true"
+fi
+
+
+if [ "$COMPONENT" == "unit" ]; then
+  ./scripts/travis_unit.sh
+elif [ "$COMPONENT" == "instrumentation" ]; then
+  ./scripts/travis_instrumentation.sh
+elif [ "$COMPONENT" == "samples" ]; then
+  ./scripts/travis_samples.sh
+elif [ "$COMPONENT" == "firebase" ]; then
+  ./scripts/travis_firebase.sh
+else
+  echo "Unrecognized component: $COMPONENT"
+  exit 1
+fi
diff --git a/scripts/travis-sonatype-publish.sh b/scripts/travis_sonatype_publish.sh
similarity index 100%
rename from scripts/travis-sonatype-publish.sh
rename to scripts/travis_sonatype_publish.sh
diff --git a/scripts/travis_unit.sh b/scripts/travis_unit.sh
new file mode 100755
index 000000000..ec19192f6
--- /dev/null
+++ b/scripts/travis_unit.sh
@@ -0,0 +1,12 @@
+#!/usr/bin/env bash
+
+set -e
+
+./gradlew build \
+  -x :samples:flickr:build \
+  -x :samples:giphy:build \
+  -x :samples:contacturi:build \
+  -x :samples:gallery:build \
+  -x :samples:imgur:build \
+  -x :samples:svg:build \
+  --parallel
diff --git a/scripts/update_javadocs.sh b/scripts/update_javadocs.sh
index a8646613b..95238183c 100755
--- a/scripts/update_javadocs.sh
+++ b/scripts/update_javadocs.sh
@@ -1,54 +1,61 @@
 #!/bin/bash
+#
+# Usage: ./scripts/update_javadocs.sh
+#
+# The version name is pulled automatically from gradle.properties.
 set -e
 set -o pipefail
 
 TEMP_DIR="/tmp/tmp_glide_javadoc"
 JAVADOC_GH_PAGES_DIR="javadocs"
 
-if [[ -z "$1" ]]; 
-then
-  echo "You must supply a target version"
-  echo "Usage ./scripts/update_javadocs.sh <400>"
-  exit 1
-fi
+major_version=$(fgrep VERSION_MAJOR gradle.properties | cut -d '=' -f 2)
+minor_version=$(fgrep VERSION_MINOR gradle.properties | cut -d '=' -f 2)
+version="${major_version}${minor_version}0"
+
+echo "Updating javadocs for ${version}"
 
 if [[ $(git status -uno --porcelain) ]];
-then 
+then
   echo "One or more changes, commit or revert first."
   git status -uno --porcelain
   exit 1
 fi
 
 if [ -e "$JAVADOC_GH_PAGES_DIR" ];
-then 
+then
   echo "javadocs directory exists locally, remove first."
   exit 1
 fi
 
-if [[ $(git rev-list master...origin/master --count) -ne 0 ]]; 
-then 
+if [[ $(git rev-list master...origin/master --count) -ne 0 ]];
+then
   echo "Origin and master are not up to date"
   git rev-list master...origin/master --pretty
   exit 1
 fi
-if [[ $(git rev-list gh-pages...origin/gh-pages --count) -ne 0 ]]; 
-then 
+if [[ $(git rev-list gh-pages...origin/gh-pages --count) -ne 0 ]];
+then
   echo "Origin and gh-pages are not up to date"
   git rev-list gh-pages...origin/gh-pages --pretty
   exit 1
 fi
 
 git checkout master
-GIT_COMMIT_SHA="$(git rev-parse HEAD)"   
-./gradlew clean releaseJavadocJar javadoc
+GIT_COMMIT_SHA="$(git rev-parse HEAD)"
+./gradlew clean debugJavadocJar javadoc
 rm -rf $TEMP_DIR
 cp -r glide/build/docs/javadoc $TEMP_DIR
+
+# Add the favicon to the javadocs pages.
+find $TEMP_DIR -name '*.html' -exec sed -i '' -e 's#<head>#<head><link rel="apple-touch-icon" sizes="180x180" href="/glide/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/glide/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/glide/favicon-16x16.png"><link rel="manifest" href="/glide/manifest.json">#' {} \;
+
 git checkout gh-pages
-rm -rf "${JAVADOC_GH_PAGES_DIR}/${1}"
-cp -r $TEMP_DIR $JAVADOC_GH_PAGES_DIR/$1
+rm -rf "${JAVADOC_GH_PAGES_DIR}/${version}"
+cp -r $TEMP_DIR $JAVADOC_GH_PAGES_DIR/$version
 rm -rf $TEMP_DIR
-git add "${JAVADOC_GH_PAGES_DIR}/$1" 
-git commit -m "Update javadocs for version $1" -m "Generated from commit on master branch: ${GIT_COMMIT_SHA}"
-echo "Copied javadoc into ${JAVADOC_GH_PAGES_DIR}/${1} and committed"
+git add "${JAVADOC_GH_PAGES_DIR}/$version"
+git commit -m "Update javadocs for version $version" -m "Generated from commit on master branch: ${GIT_COMMIT_SHA}"
+echo "Copied javadoc into ${JAVADOC_GH_PAGES_DIR}/${version} and committed"
 git log -1 --pretty=%B
 echo "Ready to push"
diff --git a/scripts/upload.gradle b/scripts/upload.gradle
index b0d8f7259..8f8d18b7b 100644
--- a/scripts/upload.gradle
+++ b/scripts/upload.gradle
@@ -15,10 +15,12 @@
  *
  *
  * Based on: https://github.com/mcxiaoke/gradle-mvn-push/blob/master/gradle-mvn-push.gradle.
- * Local test with (..._REPOSITORY_URL properties must be full paths):
- * gradlew clean buildArchives uploadArchives --stacktrace --info -PSNAPSHOT_REPOSITORY_URL=file://p:\projects\contrib\github-glide\repo-snapshot -PRELEASE_REPOSITORY_URL=file://p:\projects\contrib\github-glide\repo-release
- * For faster runs add: -x check
- * 
+ *
+ * To install in a local maven repo:
+ * 1. In the project you want to test (not Glide), add mavenLocal() to the repositories list.
+ * 2. In Glide, run: ./gradlew uploadArchives -PLOCAL
+ *
+ * For faster runs add: -x check when building Glide.
  */
 
 apply plugin: 'maven'
@@ -27,17 +29,24 @@ apply plugin: 'signing'
 version = VERSION_NAME
 group = GROUP
 
+static def localMavenRepo() {
+    'file://' + new File(System.getProperty('user.home'), '.m2/repository').absolutePath
+}
+
+@SuppressWarnings("GrMethodMayBeStatic")
 def isReleaseBuild() {
-    return VERSION_NAME.contains("SNAPSHOT") == false
+    return !VERSION_NAME.contains("SNAPSHOT")
 }
 
 def getReleaseRepositoryUrl() {
-    return hasProperty('RELEASE_REPOSITORY_URL') ? RELEASE_REPOSITORY_URL
+    return hasProperty('LOCAL') ? localMavenRepo()
+            : hasProperty('RELEASE_REPOSITORY_URL') ? RELEASE_REPOSITORY_URL
             : 'https://oss.sonatype.org/service/local/staging/deploy/maven2/'
 }
 
 def getSnapshotRepositoryUrl() {
-    return hasProperty('SNAPSHOT_REPOSITORY_URL') ? SNAPSHOT_REPOSITORY_URL
+    return hasProperty('LOCAL') ? localMavenRepo()
+            : hasProperty('SNAPSHOT_REPOSITORY_URL') ? SNAPSHOT_REPOSITORY_URL
             : 'https://oss.sonatype.org/content/repositories/snapshots/'
 }
 
@@ -50,6 +59,7 @@ def getRepositoryPassword() {
 }
 
 afterEvaluate { project ->
+    def isAndroidProject = project.plugins.hasPlugin('com.android.application') || project.plugins.hasPlugin('com.android.library')
     // To avoid uploading the default empty jar artifact in the project root directory, we use a custom
     // configuration to specify which artifacts we want to upload.
     uploadArchives {
@@ -73,9 +83,40 @@ afterEvaluate { project ->
                     authentication(userName: getRepositoryUsername(), password: getRepositoryPassword())
                 }
 
+                pom.whenConfigured { pom ->
+                    pom.packaging = POM_PACKAGING
+                }
+
+                // Dependencies are only automatically included by the release plugin if the release
+                // variant is built. Since we've disabled the release variant to improve build
+                // times, we need to add the dependencies to the pom file explicitly.
+                if (isAndroidProject) {
+                    pom.withXml {
+                        def dependenciesNode = asNode().appendNode('dependencies')
+
+                        project.configurations.implementation.allDependencies.each {
+                            def groupId = it.group
+                            def artifactId = it.name
+                            // If we specify an artifact id that differs from the project name, it won't
+                            // match. To avoid that, we look up the artifact id (and group) by property
+                            // for any project dependencies.
+                            // TODO: there must be a neater way to do this.
+                            if (it instanceof ProjectDependency) {
+                                def properties = it.getDependencyProject().getProperties()
+                                groupId = properties.get("GROUP")
+                                artifactId = properties.get("POM_ARTIFACT_ID")
+                            }
+                            def dependencyNode = dependenciesNode.appendNode('dependency')
+                            dependencyNode.appendNode('groupId', groupId)
+                            dependencyNode.appendNode('artifactId', artifactId)
+                            dependencyNode.appendNode('version', it.version)
+                            dependencyNode.appendNode('scope', 'compile')
+                        }
+                    }
+                }
+
                 pom.project {
                     name = POM_NAME
-                    packaging = POM_PACKAGING
                     description = POM_DESCRIPTION
                     url = POM_URL
 
@@ -115,32 +156,29 @@ afterEvaluate { project ->
         sign configurations.archives
     }
 
-    def isAndroidProject = project.plugins.hasPlugin('com.android.application') || project.plugins.hasPlugin('com.android.library')
 
     if (isAndroidProject) {
-        def releaseVariants = project.android.libraryVariants.findAll {
-            it.buildType.name.equalsIgnoreCase('release')
+        def variants = project.android.libraryVariants.findAll {
+            it.buildType.name.equalsIgnoreCase('debug')
         }
 
-        def getAndroidCompileSdkVersion = project.android.compileSdkVersion
-
         def getAndroidSdkDirectory = project.android.sdkDirectory
 
-        def getAndroidJar = "${getAndroidSdkDirectory}/platforms/${getAndroidCompileSdkVersion}/android.jar"
-
-        def getSupportJar = "${getAndroidSdkDirectory}/extras/android/support/v4/android-support-v4.jar"
-
-        task androidJavadocs(type: Javadoc, dependsOn: assembleRelease) {
-            source = releaseVariants.collect { it.javaCompile.source }
-            classpath = files(releaseVariants.collect {
-                files(it.javaCompile.classpath.files, getAndroidJar, getSupportJar)
-            })
-            classpath += files("${project.projectDir}/build/intermediates/classes/release")
+        def getAndroidJar = "${getAndroidSdkDirectory}/platforms/${project.android.compileSdkVersion}/android.jar"
 
+        task androidJavadocs(type: Javadoc, dependsOn: assembleDebug) {
+            source = variants.collect { it.javaCompile.source }
+            classpath = files(
+                    getAndroidJar,
+                    project.file("build/intermediates/classes/debug")
+            )
+            doFirst {
+                classpath += files(variants.collect { it.javaCompile.classpath.files })
+            }
             options {
                 links("http://docs.oracle.com/javase/7/docs/api/")
                 linksOffline("http://d.android.com/reference",
-                    "${getAndroidSdkDirectory}/docs/reference")
+                        "${getAndroidSdkDirectory}/docs/reference")
             }
 
             exclude '**/BuildConfig.java'
@@ -164,14 +202,11 @@ afterEvaluate { project ->
             baseName "${JAR_PREFIX}${project.name}${JAR_POSTFIX}"
         }
 
-        task androidLibraryJar(type: Jar, dependsOn: compileReleaseJavaWithJavac /* == variant.javaCompile */) {
-            from compileReleaseJavaWithJavac.destinationDir
+        task androidLibraryJar(type: Jar, dependsOn: compileDebugJavaWithJavac /* == variant.javaCompile */) {
+            from compileDebugJavaWithJavac.destinationDir
             exclude '**/R.class'
             exclude '**/BuildConfig.class'
-            exclude '**/R$attr.class'
-            exclude '**/R$dimen.class'
-            exclude '**/R$id.class'
-            exclude '**/R$styleable.class'
+            exclude '**/R$*.class'
             baseName "${JAR_PREFIX}${project.name}${JAR_POSTFIX}"
         }
 
@@ -179,6 +214,11 @@ afterEvaluate { project ->
             archives androidLibraryJar
             archives androidSourcesJar
             archives androidJavadocsJar
+            // This is unnecessary with a release variant because by default the release variant
+            // includes the release aar in archives. Since we've disabled our release variants and
+            // want to include an aar, we need to manually specify the task that produces the aar
+            // here.
+            archives project.tasks.bundleDebug
         }
     } else if (project.plugins.hasPlugin('java')) {
         task sourcesJar(type: Jar, dependsOn: classes) {
@@ -197,5 +237,5 @@ afterEvaluate { project ->
         }
     }
     logger.info("Published artifacts in ${configurations.archives}:")
-    configurations.archives.artifacts.files.files.each { logger.info("\t$it"); }
+    configurations.archives.artifacts.files.files.each { logger.info("\t$it") }
 }
diff --git a/settings.gradle b/settings.gradle
index 650b0e229..360b59b47 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1,9 +1,15 @@
 exec {
     commandLine "git", "submodule", "update", "--init", "--recursive"
+    ignoreExitValue true
 }
 include ':library'
+include ':library:pmd'
+include ':library:findbugs'
+include ':library:test'
+include ':instrumentation'
 include ':annotation'
 include ':annotation:compiler'
+include ':annotation:compiler:test'
 include ':glide'
 include ':third_party:gif_decoder'
 include ':third_party:disklrucache'
@@ -12,6 +18,7 @@ include ':samples:giphy'
 include ':samples:svg'
 include ':samples:gallery'
 include ':samples:contacturi'
+include ':samples:imgur'
 include ':integration'
 include ':integration:volley'
 include ':integration:okhttp'
diff --git a/testutil/src/main/java/com/bumptech/glide/testutil/TestUtil.java b/testutil/src/main/java/com/bumptech/glide/testutil/TestUtil.java
index 9c93de9e5..f39342c94 100644
--- a/testutil/src/main/java/com/bumptech/glide/testutil/TestUtil.java
+++ b/testutil/src/main/java/com/bumptech/glide/testutil/TestUtil.java
@@ -9,6 +9,8 @@
 /**
  * Shared utility classes for tests.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public final class TestUtil {
   private TestUtil() {
     // Utility class.
diff --git a/third_party/gif_decoder/build.gradle b/third_party/gif_decoder/build.gradle
index 16e6d54fb..301fd7c7e 100644
--- a/third_party/gif_decoder/build.gradle
+++ b/third_party/gif_decoder/build.gradle
@@ -1,19 +1,18 @@
 apply plugin: 'com.android.library'
 
 dependencies {
-    compile "com.android.support:support-annotations:${SUPPORT_V4_VERSION}"
+    implementation "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}"
 
-    testCompile project(':testutil')
-    testCompile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
-    testCompile "com.google.truth:truth:${TRUTH_VERSION}"
-    testCompile "junit:junit:${JUNIT_VERSION}"
-    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}"
-    testCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
+    testImplementation project(':testutil')
+    testImplementation "com.android.support:support-v4:${ANDROID_SUPPORT_VERSION}"
+    testImplementation "com.google.truth:truth:${TRUTH_VERSION}"
+    testImplementation "junit:junit:${JUNIT_VERSION}"
+    testImplementation "org.mockito:mockito-core:${MOCKITO_VERSION}"
+    testImplementation "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         minSdkVersion MIN_SDK_VERSION as int
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
index 257cd98f0..8aeaa634d 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
@@ -3,6 +3,7 @@
 import android.graphics.Bitmap;
 import android.support.annotation.IntDef;
 import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import java.io.InputStream;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -12,6 +13,7 @@
  * Shared interface for GIF decoders.
  */
 public interface GifDecoder {
+
   /** File read status: No errors. */
   int STATUS_OK = 0;
   /** File read status: Error decoding file (may be partially decoded). */
@@ -33,7 +35,7 @@
    * An interface that can be used to provide reused {@link android.graphics.Bitmap}s to avoid GCs
    * from constantly allocating {@link android.graphics.Bitmap}s for every frame.
    */
-  public interface BitmapProvider {
+  interface BitmapProvider {
     /**
      * Returns an {@link Bitmap} with exactly the given dimensions and config.
      *
@@ -43,40 +45,43 @@
      *               android.graphics.Bitmap}.
      */
     @NonNull
-    Bitmap obtain(int width, int height, Bitmap.Config config);
+    Bitmap obtain(int width, int height, @NonNull Bitmap.Config config);
 
     /**
      * Releases the given Bitmap back to the pool.
      */
-    void release(Bitmap bitmap);
+    void release(@NonNull Bitmap bitmap);
 
     /**
      * Returns a byte array used for decoding and generating the frame bitmap.
      *
      * @param size the size of the byte array to obtain
      */
+    @NonNull
     byte[] obtainByteArray(int size);
 
     /**
      * Releases the given byte array back to the pool.
      */
-    void release(byte[] bytes);
+    void release(@NonNull byte[] bytes);
 
     /**
      * Returns an int array used for decoding/generating the frame bitmaps.
      */
+    @NonNull
     int[] obtainIntArray(int size);
 
     /**
      * Release the given array back to the pool.
      */
-    void release(int[] array);
+    void release(@NonNull int[] array);
   }
 
   int getWidth();
 
   int getHeight();
 
+  @NonNull
   ByteBuffer getData();
 
   /**
@@ -188,6 +193,7 @@
    *
    * @return Bitmap representation of frame.
    */
+  @Nullable
   Bitmap getNextFrame();
 
   /**
@@ -197,15 +203,15 @@
    * @return read status code (0 = no errors).
    */
   @GifDecodeStatus
-  int read(InputStream is, int contentLength);
+  int read(@Nullable InputStream is, int contentLength);
 
   void clear();
 
-  void setData(GifHeader header, byte[] data);
+  void setData(@NonNull GifHeader header, @NonNull byte[] data);
 
-  void setData(GifHeader header, ByteBuffer buffer);
+  void setData(@NonNull GifHeader header, @NonNull ByteBuffer buffer);
 
-  void setData(GifHeader header, ByteBuffer buffer, int sampleSize);
+  void setData(@NonNull GifHeader header, @NonNull ByteBuffer buffer, int sampleSize);
 
   /**
    * Reads GIF image from byte array.
@@ -214,6 +220,23 @@
    * @return read status code (0 = no errors).
    */
   @GifDecodeStatus
-  int read(byte[] data);
+  int read(@Nullable byte[] data);
 
+
+  /**
+   * Sets the default {@link android.graphics.Bitmap.Config} to use when decoding frames of a GIF.
+   *
+   * <p>Valid options are {@link android.graphics.Bitmap.Config#ARGB_8888} and
+   * {@link android.graphics.Bitmap.Config#RGB_565}.
+   * {@link android.graphics.Bitmap.Config#ARGB_8888} will produce higher quality frames, but will
+   * also use 2x the memory of {@link android.graphics.Bitmap.Config#RGB_565}.
+   *
+   * <p>Defaults to {@link android.graphics.Bitmap.Config#ARGB_8888}
+   *
+   * <p>This value is not a guarantee. For example if set to
+   * {@link android.graphics.Bitmap.Config#RGB_565} and the GIF contains transparent pixels,
+   * {@link android.graphics.Bitmap.Config#ARGB_8888} will be used anyway to support the
+   * transparency.
+   */
+  void setDefaultBitmapConfig(@NonNull Bitmap.Config format);
 }
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifFrame.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifFrame.java
index 0a26cb756..a4d980d3e 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifFrame.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifFrame.java
@@ -16,26 +16,26 @@
    * <p><b>GIF89a</b>: <i>No disposal specified.
    * The decoder is not required to take any action.</i></p>
    */
-  public static final int DISPOSAL_UNSPECIFIED = 0;
+  static final int DISPOSAL_UNSPECIFIED = 0;
   /**
    * GIF Disposal Method meaning leave canvas from previous frame.
    * <p><b>GIF89a</b>: <i>Do not dispose.
    * The graphic is to be left in place.</i></p>
    */
-  public static final int DISPOSAL_NONE = 1;
+  static final int DISPOSAL_NONE = 1;
   /**
    * GIF Disposal Method meaning clear canvas to background color.
    * <p><b>GIF89a</b>: <i>Restore to background color.
    * The area used by the graphic must be restored to the background color.</i></p>
    */
-  public static final int DISPOSAL_BACKGROUND = 2;
+  static final int DISPOSAL_BACKGROUND = 2;
   /**
    * GIF Disposal Method meaning clear canvas to frame before last.
    * <p><b>GIF89a</b>: <i>Restore to previous.
    * The decoder is required to restore the area overwritten by the graphic
    * with what was there prior to rendering the graphic.</i></p>
    */
-  public static final int DISPOSAL_PREVIOUS = 3;
+  static final int DISPOSAL_PREVIOUS = 3;
 
   /**
    * <p><b>GIF89a</b>:
@@ -49,7 +49,7 @@
    */
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(value = {DISPOSAL_UNSPECIFIED, DISPOSAL_NONE, DISPOSAL_BACKGROUND, DISPOSAL_PREVIOUS})
-  @interface GifDisposalMethod {
+  private @interface GifDisposalMethod {
   }
 
   int ix, iy, iw, ih;
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java
index d43f7cca7..7a60b5f46 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java
@@ -26,7 +26,7 @@
   int frameCount = 0;
 
   GifFrame currentFrame;
-  List<GifFrame> frames = new ArrayList<>();
+  final List<GifFrame> frames = new ArrayList<>();
   /** Logical screen size: Full image width. */
   int width;
   /** Logical screen size: Full image height. */
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java
index 05662c04e..47f6e25df 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java
@@ -4,6 +4,8 @@
 import static com.bumptech.glide.gifdecoder.GifFrame.DISPOSAL_NONE;
 import static com.bumptech.glide.gifdecoder.GifFrame.DISPOSAL_UNSPECIFIED;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.util.Log;
 import java.nio.BufferUnderflowException;
 import java.nio.ByteBuffer;
@@ -17,7 +19,7 @@
  * @see <a href="https://www.w3.org/Graphics/GIF/spec-gif89a.txt">GIF 89a Specification</a>
  */
 public class GifHeaderParser {
-  public static final String TAG = "GifHeaderParser";
+  private static final String TAG = "GifHeaderParser";
 
   private static final int MASK_INT_LOWEST_BYTE = 0x000000FF;
 
@@ -35,7 +37,6 @@
 
   // Graphic Control Extension packed field masks
 
-  private static final int GCE_MASK_RESERVED_BITS = 0b11100000;
   /**
    * Mask (bits 4-2) to extract Disposal Method of the current frame.
    *
@@ -46,7 +47,6 @@
    * Shift so the Disposal Method extracted from the packed value is on the least significant bit.
    */
   private static final int GCE_DISPOSAL_METHOD_SHIFT = 2;
-  private static final int GCE_MASK_USER_INPUT_FLAG = 0b00000010;
   /**
    * Mask (bit 0) to extract Transparent Color Flag of the current frame.
    * <p><b>GIF89a</b>: <i>Indicates whether a transparency index is given
@@ -76,8 +76,6 @@
    * </ul>
    */
   private static final int DESCRIPTOR_MASK_INTERLACE_FLAG = 0b01000000;
-  private static final int DESCRIPTOR_MASK_SORT_FLAG = 0b00100000;
-  private static final int DESCRIPTOR_MASK_RESERVED = 0b00011000;
   /**
    * Mask (bits 2-0) to extract Size of the Local Color Table of the current image.
    * <p><b>GIF89a</b>: <i>If the Local Color Table Flag is set to 1, the value in this
@@ -100,8 +98,6 @@
    * </ul>
    */
   private static final int LSD_MASK_GCT_FLAG = 0b10000000;
-  private static final int LSD_MASK_COLOR_RESOLUTION = 0b01110000;
-  private static final int LSD_MASK_SORT_FLAG = 0b00001000;
   /**
    * Mask (bits 2-0) to extract Size of the Global Color Table of the current image.
    * <p><b>GIF89a</b>: <i>If the Global Color Table Flag is set to 1, the value in this
@@ -128,7 +124,7 @@
   private GifHeader header;
   private int blockSize = 0;
 
-  public GifHeaderParser setData(ByteBuffer data) {
+  public GifHeaderParser setData(@NonNull ByteBuffer data) {
     reset();
     rawData = data.asReadOnlyBuffer();
     rawData.position(0);
@@ -136,7 +132,7 @@ public GifHeaderParser setData(ByteBuffer data) {
     return this;
   }
 
-  public GifHeaderParser setData(byte[] data) {
+  public GifHeaderParser setData(@Nullable byte[] data) {
     if (data != null) {
       setData(ByteBuffer.wrap(data));
     } else {
@@ -158,6 +154,7 @@ private void reset() {
     blockSize = 0;
   }
 
+  @NonNull
   public GifHeader parseHeader() {
     if (rawData == null) {
       throw new IllegalStateException("You must call setData() before parseHeader()");
@@ -225,11 +222,11 @@ private void readContents(int maxFrames) {
               break;
             case LABEL_APPLICATION_EXTENSION:
               readBlock();
-              String app = "";
+              StringBuilder app = new StringBuilder();
               for (int i = 0; i < 11; i++) {
-                app += (char) block[i];
+                app.append((char) block[i]);
               }
-              if (app.equals("NETSCAPE2.0")) {
+              if (app.toString().equals("NETSCAPE2.0")) {
                 readNetscapeExt();
               } else {
                 // Don't care.
@@ -366,11 +363,11 @@ private void readNetscapeExt() {
    * Reads GIF file header information.
    */
   private void readHeader() {
-    String id = "";
+    StringBuilder id = new StringBuilder();
     for (int i = 0; i < 6; i++) {
-      id += (char) read();
+      id.append((char) read());
     }
-    if (!id.startsWith("GIF")) {
+    if (!id.toString().startsWith("GIF")) {
       header.status = STATUS_FORMAT_ERROR;
       return;
     }
@@ -414,6 +411,7 @@ private void readLSD() {
    * @param nColors int number of colors to read.
    * @return int array containing 256 colors (packed ARGB with full alpha).
    */
+  @Nullable
   private int[] readColorTable(int nColors) {
     int nBytes = 3 * nColors;
     int[] tab = null;
@@ -467,10 +465,8 @@ private void skip() {
 
   /**
    * Reads next variable length block from input.
-   *
-   * @return number of bytes stored in "buffer"
    */
-  private int readBlock() {
+  private void readBlock() {
     blockSize = read();
     int n = 0;
     if (blockSize > 0) {
@@ -490,7 +486,6 @@ private int readBlock() {
         header.status = STATUS_FORMAT_ERROR;
       }
     }
-    return n;
   }
 
   /**
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java
index 80825fb09..9256943d9 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java
@@ -29,7 +29,9 @@
 import static com.bumptech.glide.gifdecoder.GifFrame.DISPOSAL_UNSPECIFIED;
 
 import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
 import android.support.annotation.ColorInt;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.util.Log;
 import java.io.ByteArrayOutputStream;
@@ -85,21 +87,14 @@
   @ColorInt
   private final int[] pct = new int[256];
 
+  private final GifDecoder.BitmapProvider bitmapProvider;
+
   /** Raw GIF data from input source. */
   private ByteBuffer rawData;
 
   /** Raw data read working array. */
   private byte[] block;
 
-  private static final int WORK_BUFFER_SIZE = 16 * 1024;
-  /**
-   * Temporary buffer for block reading.
-   * Reads 16k chunks from the native buffer for processing, to greatly reduce JNI overhead.
-   */
-  @Nullable private byte[] workBuffer;
-  private int workBufferSize = 0;
-  private int workBufferPosition = 0;
-
   private GifHeaderParser parser;
 
   // LZW decoder working arrays.
@@ -112,7 +107,6 @@
 
   private int framePointer;
   private GifHeader header;
-  private GifDecoder.BitmapProvider bitmapProvider;
   private Bitmap previousImage;
   private boolean savePrevious;
   @GifDecodeStatus
@@ -120,22 +114,27 @@
   private int sampleSize;
   private int downsampledHeight;
   private int downsampledWidth;
-  private boolean isFirstFrameTransparent;
+  @Nullable
+  private Boolean isFirstFrameTransparent;
+  @NonNull
+  private Bitmap.Config bitmapConfig = Config.ARGB_8888;
 
+  // Public API.
+  @SuppressWarnings("unused")
   public StandardGifDecoder(
-      GifDecoder.BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData) {
+      @NonNull GifDecoder.BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData) {
     this(provider, gifHeader, rawData, 1 /*sampleSize*/);
   }
 
   public StandardGifDecoder(
-      GifDecoder.BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData,
+      @NonNull GifDecoder.BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData,
       int sampleSize) {
     this(provider);
     setData(gifHeader, rawData, sampleSize);
   }
 
   public StandardGifDecoder(
-      GifDecoder.BitmapProvider provider) {
+      @NonNull GifDecoder.BitmapProvider provider) {
     this.bitmapProvider = provider;
     header = new GifHeader();
   }
@@ -150,6 +149,7 @@ public int getHeight() {
     return header.height;
   }
 
+  @NonNull
   @Override
   public ByteBuffer getData() {
     return rawData;
@@ -198,6 +198,7 @@ public void resetFrameIndex() {
     framePointer = INITIAL_FRAME_POINTER;
   }
 
+  @Deprecated
   @Override
   public int getLoopCount() {
     if (header.loopCount == GifHeader.NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST) {
@@ -227,6 +228,7 @@ public int getByteSize() {
     return rawData.limit() + mainPixels.length + (mainScratch.length * BYTES_PER_INTEGER);
   }
 
+  @Nullable
   @Override
   public synchronized Bitmap getNextFrame() {
     if (header.frameCount <= 0 || framePointer < 0) {
@@ -246,6 +248,10 @@ public synchronized Bitmap getNextFrame() {
     }
     status = STATUS_OK;
 
+    if (block == null) {
+      block = bitmapProvider.obtainByteArray(255);
+    }
+
     GifFrame currentFrame = header.frames.get(framePointer);
     GifFrame previousFrame = null;
     int previousIndex = framePointer - 1;
@@ -279,7 +285,7 @@ public synchronized Bitmap getNextFrame() {
   }
 
   @Override
-  public int read(InputStream is, int contentLength) {
+  public int read(@Nullable InputStream is, int contentLength) {
     if (is != null) {
       try {
         int capacity = (contentLength > 0) ? (contentLength + 4 * 1024) : 16 * 1024;
@@ -324,27 +330,25 @@ public void clear() {
     }
     previousImage = null;
     rawData = null;
-    isFirstFrameTransparent = false;
+    isFirstFrameTransparent = null;
     if (block != null) {
       bitmapProvider.release(block);
     }
-    if (workBuffer != null) {
-      bitmapProvider.release(workBuffer);
-    }
   }
 
   @Override
-  public synchronized void setData(GifHeader header, byte[] data) {
+  public synchronized void setData(@NonNull GifHeader header, @NonNull byte[] data) {
     setData(header, ByteBuffer.wrap(data));
   }
 
   @Override
-  public synchronized void setData(GifHeader header, ByteBuffer buffer) {
+  public synchronized void setData(@NonNull GifHeader header, @NonNull ByteBuffer buffer) {
     setData(header, buffer, 1);
   }
 
   @Override
-  public synchronized void setData(GifHeader header, ByteBuffer buffer, int sampleSize) {
+  public synchronized void setData(@NonNull GifHeader header, @NonNull ByteBuffer buffer,
+      int sampleSize) {
     if (sampleSize <= 0) {
       throw new IllegalArgumentException("Sample size must be >=0, not: " + sampleSize);
     }
@@ -352,7 +356,6 @@ public synchronized void setData(GifHeader header, ByteBuffer buffer, int sample
     sampleSize = Integer.highestOneBit(sampleSize);
     this.status = STATUS_OK;
     this.header = header;
-    isFirstFrameTransparent = false;
     framePointer = INITIAL_FRAME_POINTER;
     // Initialize the raw data buffer.
     rawData = buffer.asReadOnlyBuffer();
@@ -377,6 +380,7 @@ public synchronized void setData(GifHeader header, ByteBuffer buffer, int sample
     mainScratch = bitmapProvider.obtainIntArray(downsampledWidth * downsampledHeight);
   }
 
+  @NonNull
   private GifHeaderParser getHeaderParser() {
     if (parser == null) {
       parser = new GifHeaderParser();
@@ -386,7 +390,7 @@ private GifHeaderParser getHeaderParser() {
 
   @Override
   @GifDecodeStatus
-  public synchronized int read(byte[] data) {
+  public synchronized int read(@Nullable byte[] data) {
     this.header = getHeaderParser().setData(data).parseHeader();
     if (data != null) {
       setData(header, data);
@@ -395,6 +399,16 @@ public synchronized int read(byte[] data) {
     return status;
   }
 
+  @Override
+  public void setDefaultBitmapConfig(@NonNull Bitmap.Config config) {
+    if (config != Bitmap.Config.ARGB_8888 && config != Bitmap.Config.RGB_565) {
+      throw new IllegalArgumentException("Unsupported format: " + config
+          + ", must be one of " + Bitmap.Config.ARGB_8888 + " or " + Bitmap.Config.RGB_565);
+    }
+
+    bitmapConfig = config;
+  }
+
   /**
    * Creates new frame image from current data (and previous frames as specified by their
    * disposition codes).
@@ -403,8 +417,20 @@ private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {
     // Final location of blended pixels.
     final int[] dest = mainScratch;
 
-    // clear all pixels when meet first frame
+    // clear all pixels when meet first frame and drop prev image from last loop
     if (previousFrame == null) {
+      if (previousImage != null) {
+        bitmapProvider.release(previousImage);
+      }
+      previousImage = null;
+      Arrays.fill(dest, COLOR_TRANSPARENT_BLACK);
+    }
+
+    // clear all pixels when dispose is 3 but previousImage is null.
+    // When DISPOSAL_PREVIOUS and previousImage didn't be set, new frame should draw on
+    // a empty image
+    if (previousFrame != null && previousFrame.dispose == DISPOSAL_PREVIOUS
+            && previousImage == null) {
       Arrays.fill(dest, COLOR_TRANSPARENT_BLACK);
     }
 
@@ -449,6 +475,76 @@ private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {
     // Decode pixels for this frame into the global pixels[] scratch.
     decodeBitmapData(currentFrame);
 
+    if (currentFrame.interlace || sampleSize != 1) {
+      copyCopyIntoScratchRobust(currentFrame);
+    } else {
+      copyIntoScratchFast(currentFrame);
+    }
+
+    // Copy pixels into previous image
+    if (savePrevious && (currentFrame.dispose == DISPOSAL_UNSPECIFIED
+        || currentFrame.dispose == DISPOSAL_NONE)) {
+      if (previousImage == null) {
+        previousImage = getNextBitmap();
+      }
+      previousImage.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth,
+          downsampledHeight);
+    }
+
+    // Set pixels for current image.
+    Bitmap result = getNextBitmap();
+    result.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth, downsampledHeight);
+    return result;
+  }
+
+  private void copyIntoScratchFast(GifFrame currentFrame) {
+    int[] dest = mainScratch;
+    int downsampledIH = currentFrame.ih;
+    int downsampledIY = currentFrame.iy;
+    int downsampledIW = currentFrame.iw;
+    int downsampledIX = currentFrame.ix;
+    // Copy each source line to the appropriate place in the destination.
+    boolean isFirstFrame = framePointer == 0;
+    int width = this.downsampledWidth;
+    byte[] mainPixels = this.mainPixels;
+    int[] act = this.act;
+    byte transparentColorIndex = -1;
+    for (int i = 0; i < downsampledIH; i++) {
+      int line = i + downsampledIY;
+      int k = line * width;
+      // Start of line in dest.
+      int dx = k + downsampledIX;
+      // End of dest line.
+      int dlim = dx + downsampledIW;
+      if (k + width < dlim) {
+        // Past dest edge.
+        dlim = k + width;
+      }
+      // Start of line in source.
+      int sx = i * currentFrame.iw;
+
+      while (dx < dlim) {
+        byte byteCurrentColorIndex = mainPixels[sx];
+        int currentColorIndex = ((int) byteCurrentColorIndex) & MASK_INT_LOWEST_BYTE;
+        if (currentColorIndex != transparentColorIndex) {
+          int color = act[currentColorIndex];
+          if (color != COLOR_TRANSPARENT_BLACK) {
+            dest[dx] = color;
+          } else {
+            transparentColorIndex = byteCurrentColorIndex;
+          }
+        }
+        ++sx;
+        ++dx;
+      }
+    }
+
+    isFirstFrameTransparent =
+        isFirstFrameTransparent == null && isFirstFrame && transparentColorIndex != -1;
+  }
+
+  private void copyCopyIntoScratchRobust(GifFrame currentFrame) {
+    int[] dest = mainScratch;
     int downsampledIH = currentFrame.ih / sampleSize;
     int downsampledIY = currentFrame.iy / sampleSize;
     int downsampledIW = currentFrame.iw / sampleSize;
@@ -458,6 +554,13 @@ private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {
     int inc = 8;
     int iline = 0;
     boolean isFirstFrame = framePointer == 0;
+    int sampleSize = this.sampleSize;
+    int downsampledWidth = this.downsampledWidth;
+    int downsampledHeight = this.downsampledHeight;
+    byte[] mainPixels = this.mainPixels;
+    int[] act = this.act;
+    @Nullable
+    Boolean isFirstFrameTransparent = this.isFirstFrameTransparent;
     for (int i = 0; i < downsampledIH; i++) {
       int line = i;
       if (currentFrame.interlace) {
@@ -483,6 +586,7 @@ private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {
         iline += inc;
       }
       line += downsampledIY;
+      boolean isNotDownsampling = sampleSize == 1;
       if (line < downsampledHeight) {
         int k = line * downsampledWidth;
         // Start of line in dest.
@@ -495,43 +599,43 @@ private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {
         }
         // Start of line in source.
         int sx = i * sampleSize * currentFrame.iw;
-        int maxPositionInSource = sx + ((dlim - dx) * sampleSize);
-        while (dx < dlim) {
-          // Map color and insert in destination.
-          @ColorInt int averageColor;
-          if (sampleSize == 1) {
+        if (isNotDownsampling) {
+          int averageColor;
+          while (dx < dlim) {
             int currentColorIndex = ((int) mainPixels[sx]) & MASK_INT_LOWEST_BYTE;
             averageColor = act[currentColorIndex];
-          } else {
+            if (averageColor != COLOR_TRANSPARENT_BLACK) {
+              dest[dx] = averageColor;
+            } else if (isFirstFrame && isFirstFrameTransparent == null) {
+              isFirstFrameTransparent = true;
+            }
+            sx += sampleSize;
+            dx++;
+          }
+        } else {
+          int averageColor;
+          int maxPositionInSource = sx + ((dlim - dx) * sampleSize);
+          while (dx < dlim) {
+            // Map color and insert in destination.
             // TODO: This is substantially slower (up to 50ms per frame) than just grabbing the
             // current color index above, even with a sample size of 1.
             averageColor = averageColorsNear(sx, maxPositionInSource, currentFrame.iw);
+            if (averageColor != COLOR_TRANSPARENT_BLACK) {
+              dest[dx] = averageColor;
+            } else if (isFirstFrame && isFirstFrameTransparent == null) {
+              isFirstFrameTransparent = true;
+            }
+            sx += sampleSize;
+            dx++;
           }
-          if (averageColor != COLOR_TRANSPARENT_BLACK) {
-            dest[dx] = averageColor;
-          } else if (!isFirstFrameTransparent && isFirstFrame) {
-            isFirstFrameTransparent = true;
-          }
-          sx += sampleSize;
-          dx++;
         }
       }
     }
 
-    // Copy pixels into previous image
-    if (savePrevious && (currentFrame.dispose == DISPOSAL_UNSPECIFIED
-        || currentFrame.dispose == DISPOSAL_NONE)) {
-      if (previousImage == null) {
-        previousImage = getNextBitmap();
-      }
-      previousImage.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth,
-          downsampledHeight);
+    if (this.isFirstFrameTransparent == null) {
+      this.isFirstFrameTransparent = isFirstFrameTransparent == null
+          ? false : isFirstFrameTransparent;
     }
-
-    // Set pixels for current image.
-    Bitmap result = getNextBitmap();
-    result.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth, downsampledHeight);
-    return result;
   }
 
   @ColorInt
@@ -585,8 +689,6 @@ private int averageColorsNear(int positionInMainPixels, int maxPositionInMainPix
    * Decodes LZW image data into pixel array. Adapted from John Cristy's BitmapMagick.
    */
   private void decodeBitmapData(GifFrame frame) {
-    workBufferSize = 0;
-    workBufferPosition = 0;
     if (frame != null) {
       // Jump to the frame start position.
       rawData.position(frame.bufferFrameStart);
@@ -600,15 +702,19 @@ private void decodeBitmapData(GifFrame frame) {
       // Allocate new pixel array.
       mainPixels = bitmapProvider.obtainByteArray(npix);
     }
+    byte[] mainPixels = this.mainPixels;
     if (prefix == null) {
       prefix = new short[MAX_STACK_SIZE];
     }
+    short[] prefix = this.prefix;
     if (suffix == null) {
       suffix = new byte[MAX_STACK_SIZE];
     }
+    byte[] suffix = this.suffix;
     if (pixelStack == null) {
       pixelStack = new byte[MAX_STACK_SIZE + 1];
     }
+    byte[] pixelStack = this.pixelStack;
 
     // Initialize GIF data stream decoder.
     dataSize = readByte();
@@ -618,18 +724,18 @@ private void decodeBitmapData(GifFrame frame) {
     oldCode = NULL_CODE;
     codeSize = dataSize + 1;
     codeMask = (1 << codeSize) - 1;
+
     for (code = 0; code < clear; code++) {
       // XXX ArrayIndexOutOfBoundsException.
       prefix[code] = 0;
       suffix[code] = (byte) code;
     }
-
+    byte[] block = this.block;
     // Decode GIF pixel stream.
-    datum = bits = count = first = top = pi = bi = 0;
-    for (i = 0; i < npix; ) {
-      // Load bytes until there are enough bits for a code.
+    i = datum = bits = count = first = top = pi = bi = 0;
+    while (i < npix) {
+      // Read a new data block.
       if (count == 0) {
-        // Read a new data block.
         count = readBlock();
         if (count <= 0) {
           status = STATUS_PARTIAL_DECODE;
@@ -640,8 +746,8 @@ private void decodeBitmapData(GifFrame frame) {
 
       datum += (((int) block[bi]) & MASK_INT_LOWEST_BYTE) << bits;
       bits += 8;
-      bi++;
-      count--;
+      ++bi;
+      --count;
 
       while (bits >= codeSize) {
         // Get the next code.
@@ -657,87 +763,65 @@ private void decodeBitmapData(GifFrame frame) {
           available = clear + 2;
           oldCode = NULL_CODE;
           continue;
-        }
-
-        if (code > available) {
-          status = STATUS_PARTIAL_DECODE;
+        } else if (code == endOfInformation) {
           break;
-        }
-
-        if (code == endOfInformation) {
-          break;
-        }
-
-        if (oldCode == NULL_CODE) {
-          pixelStack[top++] = suffix[code];
+        } else if (oldCode == NULL_CODE) {
+          mainPixels[pi] = suffix[code];
+          ++pi;
+          ++i;
           oldCode = code;
           first = code;
           continue;
         }
+
         inCode = code;
         if (code >= available) {
-          pixelStack[top++] = (byte) first;
+          pixelStack[top] = (byte) first;
+          ++top;
           code = oldCode;
         }
+
         while (code >= clear) {
-          pixelStack[top++] = suffix[code];
+          pixelStack[top] = suffix[code];
+          ++top;
           code = prefix[code];
         }
         first = ((int) suffix[code]) & MASK_INT_LOWEST_BYTE;
-        pixelStack[top++] = (byte) first;
+
+        mainPixels[pi] = (byte) first;
+        ++pi;
+        ++i;
+
+        while (top > 0) {
+          // Pop a pixel off the pixel stack.
+          mainPixels[pi] = pixelStack[--top];
+          ++pi;
+          ++i;
+        }
 
         // Add a new string to the string table.
         if (available < MAX_STACK_SIZE) {
           prefix[available] = (short) oldCode;
           suffix[available] = (byte) first;
-          available++;
+          ++available;
           if (((available & codeMask) == 0) && (available < MAX_STACK_SIZE)) {
-            codeSize++;
+            ++codeSize;
             codeMask += available;
           }
         }
         oldCode = inCode;
-
-        while (top > 0) {
-          // Pop a pixel off the pixel stack.
-          mainPixels[pi++] = pixelStack[--top];
-          i++;
-        }
       }
     }
 
     // Clear missing pixels.
-    for (i = pi; i < npix; i++) {
-      mainPixels[i] = COLOR_TRANSPARENT_BLACK;
-    }
-  }
-
-  /**
-   * Reads the next chunk for the intermediate work buffer.
-   */
-  private void readChunkIfNeeded() {
-    if (workBufferSize > workBufferPosition) {
-      return;
-    }
-    if (workBuffer == null) {
-      workBuffer = bitmapProvider.obtainByteArray(WORK_BUFFER_SIZE);
-    }
-    workBufferPosition = 0;
-    workBufferSize = Math.min(rawData.remaining(), WORK_BUFFER_SIZE);
-    rawData.get(workBuffer, 0, workBufferSize);
+    Arrays.fill(mainPixels, pi, npix, (byte) COLOR_TRANSPARENT_BLACK);
   }
 
   /**
    * Reads a single byte from the input stream.
    */
   private int readByte() {
-    try {
-      readChunkIfNeeded();
-      return workBuffer[workBufferPosition++] & MASK_INT_LOWEST_BYTE;
-    } catch (Exception e) {
-      status = STATUS_FORMAT_ERROR;
-      return 0;
-    }
+    return rawData.get() & MASK_INT_LOWEST_BYTE;
   }
 
   /**
@@ -747,38 +831,16 @@ private int readByte() {
    */
   private int readBlock() {
     int blockSize = readByte();
-    if (blockSize > 0) {
-      try {
-        if (block == null) {
-          block = bitmapProvider.obtainByteArray(255);
-        }
-        final int remaining = workBufferSize - workBufferPosition;
-        if (remaining >= blockSize) {
-          // Block can be read from the current work buffer.
-          System.arraycopy(workBuffer, workBufferPosition, block, 0, blockSize);
-          workBufferPosition += blockSize;
-        } else if (rawData.remaining() + remaining >= blockSize) {
-          // Block can be read in two passes.
-          System.arraycopy(workBuffer, workBufferPosition, block, 0, remaining);
-          workBufferPosition = workBufferSize;
-          readChunkIfNeeded();
-          final int secondHalfRemaining = blockSize - remaining;
-          System.arraycopy(workBuffer, 0, block, remaining, secondHalfRemaining);
-          workBufferPosition += secondHalfRemaining;
-        } else {
-          status = STATUS_FORMAT_ERROR;
-        }
-      } catch (Exception e) {
-        Log.w(TAG, "Error Reading Block", e);
-        status = STATUS_FORMAT_ERROR;
-      }
+    if (blockSize <= 0) {
+      return blockSize;
     }
+    rawData.get(block, 0, Math.min(blockSize, rawData.remaining()));
     return blockSize;
   }
 
   private Bitmap getNextBitmap() {
-    Bitmap.Config config = isFirstFrameTransparent
-        ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
+    Bitmap.Config config = isFirstFrameTransparent == null || isFirstFrameTransparent
+        ? Bitmap.Config.ARGB_8888 : bitmapConfig;
     Bitmap result = bitmapProvider.obtain(downsampledWidth, downsampledHeight, config);
     result.setHasAlpha(true);
     return result;
diff --git a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
index 13a581303..9e19f98ab 100644
--- a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
+++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
@@ -34,6 +34,21 @@ public void setUp() {
     provider = new MockProvider();
   }
 
+  @Test
+  public void testCorrectPixelsDecoded() throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "white_black_row.gif");
+    GifHeaderParser headerParser = new GifHeaderParser();
+    headerParser.setData(data);
+    GifHeader header = headerParser.parseHeader();
+    GifDecoder decoder = new StandardGifDecoder(provider);
+    decoder.setData(header, data);
+    decoder.advance();
+    Bitmap bitmap = decoder.getNextFrame();
+    assertNotNull(bitmap);
+    assertEquals(bitmap.getPixel(2, 0), bitmap.getPixel(0, 0));
+    assertEquals(bitmap.getPixel(3, 0), bitmap.getPixel(1, 0));
+  }
+
   @Test
   public void testCanDecodeFramesFromTestGif() throws IOException {
     byte[] data = TestUtil.resourceToBytes(getClass(), "partial_gif_decode.gif");
@@ -197,27 +212,29 @@ public Bitmap obtain(int width, int height, Bitmap.Config config) {
     }
 
     @Override
-    public void release(Bitmap bitmap) {
+    public void release(@NonNull Bitmap bitmap) {
       // Do nothing.
     }
 
+    @NonNull
     @Override
     public byte[] obtainByteArray(int size) {
       return new byte[size];
     }
 
     @Override
-    public void release(byte[] bytes) {
+    public void release(@NonNull byte[] bytes) {
       // Do nothing.
     }
 
+    @NonNull
     @Override
     public int[] obtainIntArray(int size) {
       return new int[size];
     }
 
     @Override
-    public void release(int[] array) {
+    public void release(@NonNull int[] array) {
       // Do Nothing
     }
 
diff --git a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
index 55dfa41a4..8fc2efa9e 100644
--- a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
+++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
@@ -122,7 +122,7 @@ public void testCanReadImageDescriptorWithoutGraphicalExtension() {
     final int lzwMinCodeSize = 2;
     ByteBuffer buffer = ByteBuffer.allocate(
         GifBytesTestUtil.HEADER_LENGTH + GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH + GifBytesTestUtil
-            .getImageDataSize(lzwMinCodeSize)).order(ByteOrder.LITTLE_ENDIAN);
+            .getImageDataSize()).order(ByteOrder.LITTLE_ENDIAN);
     GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
     GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0);
     GifBytesTestUtil.writeFakeImageData(buffer, lzwMinCodeSize);
@@ -140,7 +140,7 @@ private static ByteBuffer writeHeaderWithGceAndFrameDelay(short frameDelay) {
     ByteBuffer buffer = ByteBuffer.allocate(
         GifBytesTestUtil.HEADER_LENGTH + GifBytesTestUtil.GRAPHICS_CONTROL_EXTENSION_LENGTH
             + GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH + GifBytesTestUtil
-            .getImageDataSize(lzwMinCodeSize)).order(ByteOrder.LITTLE_ENDIAN);
+            .getImageDataSize()).order(ByteOrder.LITTLE_ENDIAN);
     GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
     GifBytesTestUtil.writeGraphicsControlExtension(buffer, frameDelay);
     GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0);
@@ -204,7 +204,7 @@ public void testSetsFrameLocalColorTableToNullIfNoColorTable() {
     final int lzwMinCodeSize = 2;
     ByteBuffer buffer = ByteBuffer.allocate(
         GifBytesTestUtil.HEADER_LENGTH + GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH + GifBytesTestUtil
-            .getImageDataSize(lzwMinCodeSize)).order(ByteOrder.LITTLE_ENDIAN);
+            .getImageDataSize()).order(ByteOrder.LITTLE_ENDIAN);
     GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
     GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0);
     GifBytesTestUtil.writeFakeImageData(buffer, lzwMinCodeSize);
@@ -224,7 +224,7 @@ public void testSetsFrameLocalColorTableIfHasColorTable() {
     final int numColors = 4;
     ByteBuffer buffer = ByteBuffer.allocate(
         GifBytesTestUtil.HEADER_LENGTH + GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH + GifBytesTestUtil
-            .getImageDataSize(lzwMinCodeSize) + GifBytesTestUtil.getColorTableLength(numColors))
+            .getImageDataSize() + GifBytesTestUtil.getColorTableLength(numColors))
         .order(ByteOrder.LITTLE_ENDIAN);
     GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
     GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, true /*hasLct*/, numColors);
@@ -248,7 +248,7 @@ public void testCanParseMultipleFrames() {
     final int expectedFrames = 3;
 
     final int frameSize = GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH + GifBytesTestUtil
-        .getImageDataSize(lzwMinCodeSize);
+        .getImageDataSize();
     ByteBuffer buffer =
         ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH + expectedFrames * frameSize)
             .order(ByteOrder.LITTLE_ENDIAN);
@@ -272,7 +272,7 @@ public void testIsAnimatedMultipleFrames() {
 
     final int frameSize =
         GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH
-            + GifBytesTestUtil.getImageDataSize(lzwMinCodeSize);
+            + GifBytesTestUtil.getImageDataSize();
     ByteBuffer buffer =
         ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH + numFrames * frameSize)
             .order(ByteOrder.LITTLE_ENDIAN);
@@ -293,7 +293,7 @@ public void testIsNotAnimatedOneFrame() {
 
     final int frameSize =
         GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH
-            + GifBytesTestUtil.getImageDataSize(lzwMinCodeSize);
+            + GifBytesTestUtil.getImageDataSize();
 
     ByteBuffer buffer =
         ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH + frameSize)
diff --git a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtil.java b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtil.java
index 7a32733a6..4752afc3c 100644
--- a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtil.java
+++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtil.java
@@ -17,7 +17,7 @@ public static int getColorTableLength(int numColors) {
     return 3 * numColors;
   }
 
-  public static int getImageDataSize(int lzwMinCodeSize) {
+  public static int getImageDataSize() {
     // TODO: fill this out.
     return 4;
   }
@@ -78,7 +78,7 @@ public static void writeHeaderAndLsd(ByteBuffer out, int width, int height, bool
     // Version - 89a.
     out.put((byte) 0x38).put((byte) 0x39).put((byte) 0x61);
 
-    /** LSD (Logical Screen Descriptor) **/
+    /* LSD (Logical Screen Descriptor) **/
     // Width.
     out.putShort((short) width);
     // Height.
@@ -89,7 +89,7 @@ public static void writeHeaderAndLsd(ByteBuffer out, int width, int height, bool
     // Color resolution - next three bits.
     byte colorResolution = 1 << 5;
     // Sort flag - next bit;
-    byte sortFlag = 0 << 4;
+    byte sortFlag = 0;
     // exponent of size of color table, size = 2^(1 + exponent) - least significant 3 bits.
     byte size = (byte) gctSize;
 
diff --git a/third_party/gif_decoder/src/test/resources/white_black_row.gif b/third_party/gif_decoder/src/test/resources/white_black_row.gif
new file mode 100644
index 000000000..ca7f1cb96
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/white_black_row.gif differ
diff --git a/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java b/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java
index 7bb25acab..f05bd08b8 100644
--- a/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java
+++ b/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java
@@ -4,6 +4,8 @@
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.Color;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.util.Log;
 import java.io.BufferedOutputStream;
 import java.io.FileOutputStream;
@@ -152,7 +154,7 @@ public void setTransparent(int color) {
      *          BufferedImage containing frame to write.
      * @return true if successful.
      */
-    public boolean addFrame(Bitmap im) {
+    public boolean addFrame(@Nullable Bitmap im) {
         return addFrame(im, 0, 0);
     }
 
@@ -175,7 +177,7 @@ public boolean addFrame(Bitmap im) {
      *          the Logical Screen.
      * @return true if successful.
      */
-    public boolean addFrame(Bitmap im, int x, int y) {
+    public boolean addFrame(@Nullable Bitmap im, int x, int y) {
         if ((im == null) || !started) {
             return false;
         }
@@ -318,7 +320,7 @@ private void setFrameSize(int w, int h) {
      *          OutputStream on which GIF images are written.
      * @return false if initial write failed.
      */
-    public boolean start(OutputStream os) {
+    public boolean start(@Nullable OutputStream os) {
         if (os == null)
             return false;
         boolean ok = true;
@@ -339,8 +341,8 @@ public boolean start(OutputStream os) {
      *          String containing output file name.
      * @return false if open or initial write failed.
      */
-    public boolean start(String file) {
-        boolean ok = true;
+    public boolean start(@NonNull String file) {
+        boolean ok;
         try {
             out = new BufferedOutputStream(new FileOutputStream(file));
             ok = start(out);
