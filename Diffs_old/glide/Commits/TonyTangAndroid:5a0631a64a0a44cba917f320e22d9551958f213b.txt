diff --git a/.github/stale.yml b/.github/stale.yml
new file mode 100644
index 000000000..d20444829
--- /dev/null
+++ b/.github/stale.yml
@@ -0,0 +1,21 @@
+# Number of days of inactivity before an issue becomes stale
+daysUntilStale: 7
+# Number of days of inactivity before a stale issue is closed
+daysUntilClose: 7
+# Issues with these labels will never be considered stale
+exemptLabels:
+  - bug
+  - enhancement
+  - feature
+  - documentation
+  - build stability
+# Label to use when marking an issue as stale
+staleLabel: stale
+# Comment to post when marking an issue as stale. Set to `false` to disable
+markComment: >
+  This issue has been automatically marked as stale because it has not had
+  activity in the last seven days. It will be closed if no further activity
+  occurs within the next seven days. Thank you for your contributions.
+# Comment to post when closing a stale issue. Set to `false` to disable
+closeComment: false
+unmarkComment: false
diff --git a/.gitignore b/.gitignore
index 6a64b1779..0fdd65869 100644
--- a/.gitignore
+++ b/.gitignore
@@ -2,12 +2,11 @@
 local.properties
 *.keystore
 *.DS_Store
-proguard-project.txt
 
 # Gradle
-**/.gradle
-**/.settings
-**/build
+.gradle
+build
+jacoco.exec
 
 # gh-pages
 doc/**
@@ -19,24 +18,15 @@ docs/**/*
 *.swp
 *.swo
 
-# Intellij 
-*.ipr
+# sed
+*.bak
+
+# Intellij
 *.iml
+*.ipr
 *.iws
-**/.idea/.name
-**/.idea/compiler.xml
-**/.idea/copyright/profiles_settings.xml
-**/.idea/encodings.xml
-**/.idea/misc.xml
-**/.idea/modules.xml
-**/.idea/scopes/scope_settings.xml
-**/.idea/vcs.xml
-**/.idea/libraries
-**/.idea/workspace.xml
-**/.idea/tasks.xml
-**/.idea/gradle.xml
-**/.idea/dictionaries
-**/.idea/dataSources.ids
-**/.idea/datasources.xml
-**/.idea/uiDesigner.xml
-**/.idea/runConfigurations.xml
+.idea/**
+!.idea/codeStyleSettings.xml
+!.idea/inspectionProfiles
+!.idea/inspectionProfiles/Project_Default.xml
+
diff --git a/.gitmodules b/.gitmodules
index 525eef67a..d9d405d51 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,12 +1,6 @@
-[submodule "third_party/volley/volley"]
-	path = third_party/volley/volley
-	url = https://android.googlesource.com/platform/frameworks/volley
 [submodule "third_party/disklrucache"]
 	path = third_party/disklrucache
 	url = https://github.com/sjudd/DiskLruCache.git
-[submodule "library/src/androidTest/resources/exif-orientation-examples"]
-	path = library/src/androidTest/resources/exif-orientation-examples
+[submodule "library/test/src/test/resources/exif-orientation-examples"]
+	path = library/test/src/test/resources/exif-orientation-examples
 	url = https://github.com/recurser/exif-orientation-examples.git
-[submodule "library/src/test/resources/exif-orientation-examples"]
-	path = library/src/test/resources/exif-orientation-examples
-	url = https://github.com/recurser/exif-orientation-examples
diff --git a/.idea/codeStyleSettings.xml b/.idea/codeStyleSettings.xml
index fe060621a..ebd90ff05 100644
--- a/.idea/codeStyleSettings.xml
+++ b/.idea/codeStyleSettings.xml
@@ -15,245 +15,17 @@
             <option name="USE_RELATIVE_INDENTS" value="false" />
           </value>
         </option>
-        <option name="CLASS_COUNT_TO_USE_IMPORT_ON_DEMAND" value="99" />
-        <option name="NAMES_COUNT_TO_USE_IMPORT_ON_DEMAND" value="99" />
+        <option name="INSERT_INNER_CLASS_IMPORTS" value="true" />
+        <option name="CLASS_COUNT_TO_USE_IMPORT_ON_DEMAND" value="999" />
+        <option name="NAMES_COUNT_TO_USE_IMPORT_ON_DEMAND" value="999" />
+        <option name="PACKAGES_TO_USE_IMPORT_ON_DEMAND">
+          <value />
+        </option>
         <option name="IMPORT_LAYOUT_TABLE">
           <value>
             <package name="" withSubpackages="true" static="true" />
             <emptyLine />
-            <package name="com.google" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="android" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="antenna" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="antlr" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="ar" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="asposewobfuscated" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="asquare" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="atg" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="au" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="beaver" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="bibtex" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="bmsi" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="bsh" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="ccl" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="cern" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="ChartDirector" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="checkers" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="com" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="COM" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="common" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="contribs" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="corejava" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="cryptix" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="cybervillains" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="dalvik" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="danbikel" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="de" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="EDU" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="eg" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="eu" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="examples" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="fat" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="fit" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="fitlibrary" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="fmpp" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="freemarker" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="gnu" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="groovy" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="groovyjarjarantlr" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="groovyjarjarasm" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="hak" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="hep" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="ie" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="imageinfo" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="info" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="it" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jal" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="Jama" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="japa" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="japacheckers" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jas" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jasmin" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="javancss" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="javanet" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="javassist" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="javazoom" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="java_cup" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jcifs" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jetty" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="JFlex" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jj2000" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jline" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jp" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="JSci" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jsr166y" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="junit" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jxl" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jxxload_help" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="kawa" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="kea" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="libcore" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="libsvm" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="lti" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="memetic" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="mt" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="mx4j" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="net" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="netscape" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="nl" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="nu" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="oauth" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="ognl" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="opennlp" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="oracle" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="org" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="penn2dg" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="pennconverter" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="pl" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="prefuse" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="proguard" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="repackage" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="scm" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="se" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="serp" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="simple" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="soot" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="sqlj" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="src" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="ssa" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="sun" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="sunlabs" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="tcl" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="testdata" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="testshell" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="testsuite" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="twitter4j" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="uk" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="ViolinStrings" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="weka" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="wet" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="winstone" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="woolfel" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="wowza" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="java" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="javax" withSubpackages="true" static="false" />
-            <emptyLine />
             <package name="" withSubpackages="true" static="false" />
-            <emptyLine />
-            <emptyLine />
           </value>
         </option>
         <option name="RIGHT_MARGIN" value="100" />
@@ -263,20 +35,13 @@
         <option name="JD_KEEP_EMPTY_RETURN" value="false" />
         <option name="KEEP_CONTROL_STATEMENT_IN_ONE_LINE" value="false" />
         <option name="KEEP_BLANK_LINES_IN_CODE" value="1" />
-        <option name="BLANK_LINES_AFTER_CLASS_HEADER" value="1" />
-        <option name="ALIGN_MULTILINE_PARAMETERS_IN_CALLS" value="true" />
-        <option name="ALIGN_MULTILINE_BINARY_OPERATION" value="true" />
-        <option name="ALIGN_MULTILINE_ASSIGNMENT" value="true" />
-        <option name="ALIGN_MULTILINE_TERNARY_OPERATION" value="true" />
-        <option name="ALIGN_MULTILINE_THROWS_LIST" value="true" />
-        <option name="ALIGN_MULTILINE_EXTENDS_LIST" value="true" />
-        <option name="ALIGN_MULTILINE_PARENTHESIZED_EXPRESSION" value="true" />
-        <option name="ALIGN_MULTILINE_ARRAY_INITIALIZER_EXPRESSION" value="true" />
+        <option name="KEEP_BLANK_LINES_BEFORE_RBRACE" value="0" />
+        <option name="ALIGN_MULTILINE_PARAMETERS" value="false" />
+        <option name="ALIGN_MULTILINE_FOR" value="false" />
+        <option name="SPACE_BEFORE_ARRAY_INITIALIZER_LBRACE" value="true" />
         <option name="CALL_PARAMETERS_WRAP" value="1" />
         <option name="METHOD_PARAMETERS_WRAP" value="1" />
         <option name="EXTENDS_LIST_WRAP" value="1" />
-        <option name="THROWS_LIST_WRAP" value="1" />
-        <option name="EXTENDS_KEYWORD_WRAP" value="1" />
         <option name="THROWS_KEYWORD_WRAP" value="1" />
         <option name="METHOD_CALL_CHAIN_WRAP" value="1" />
         <option name="BINARY_OPERATION_WRAP" value="1" />
@@ -285,70 +50,515 @@
         <option name="TERNARY_OPERATION_SIGNS_ON_NEXT_LINE" value="true" />
         <option name="FOR_STATEMENT_WRAP" value="1" />
         <option name="ARRAY_INITIALIZER_WRAP" value="1" />
-        <option name="ASSIGNMENT_WRAP" value="5" />
         <option name="WRAP_COMMENTS" value="true" />
         <option name="IF_BRACE_FORCE" value="3" />
         <option name="DOWHILE_BRACE_FORCE" value="3" />
         <option name="WHILE_BRACE_FORCE" value="3" />
         <option name="FOR_BRACE_FORCE" value="3" />
-        <Objective-C-extensions>
-          <option name="GENERATE_INSTANCE_VARIABLES_FOR_PROPERTIES" value="ASK" />
-          <option name="RELEASE_STYLE" value="IVAR" />
-          <option name="TYPE_QUALIFIERS_PLACEMENT" value="BEFORE" />
-          <file>
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Import" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Macro" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Typedef" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Enum" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Constant" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Global" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Struct" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="FunctionPredecl" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Function" />
-          </file>
-          <class>
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Property" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Synthesize" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="InitMethod" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="StaticMethod" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="InstanceMethod" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="DeallocMethod" />
-          </class>
-          <extensions>
-            <pair source="cpp" header="h" />
-            <pair source="c" header="h" />
-          </extensions>
-        </Objective-C-extensions>
+        <AndroidXmlCodeStyleSettings>
+          <option name="USE_CUSTOM_SETTINGS" value="true" />
+          <option name="LAYOUT_SETTINGS">
+            <value>
+              <option name="INSERT_BLANK_LINE_BEFORE_TAG" value="false" />
+            </value>
+          </option>
+        </AndroidXmlCodeStyleSettings>
+        <JSCodeStyleSettings>
+          <option name="INDENT_CHAINED_CALLS" value="false" />
+        </JSCodeStyleSettings>
+        <JavaCodeStyleSettings>
+          <option name="DO_NOT_WRAP_AFTER_SINGLE_ANNOTATION" value="true" />
+        </JavaCodeStyleSettings>
+        <Python>
+          <option name="USE_CONTINUATION_INDENT_FOR_ARGUMENTS" value="true" />
+        </Python>
+        <TypeScriptCodeStyleSettings>
+          <option name="INDENT_CHAINED_CALLS" value="false" />
+        </TypeScriptCodeStyleSettings>
         <XML>
+          <option name="XML_ALIGN_ATTRIBUTES" value="false" />
           <option name="XML_LEGACY_SETTINGS_IMPORTED" value="true" />
         </XML>
-        <ADDITIONAL_INDENT_OPTIONS fileType="haml">
-          <option name="INDENT_SIZE" value="2" />
-        </ADDITIONAL_INDENT_OPTIONS>
-        <ADDITIONAL_INDENT_OPTIONS fileType="java">
-          <option name="INDENT_SIZE" value="2" />
-          <option name="CONTINUATION_INDENT_SIZE" value="4" />
-          <option name="TAB_SIZE" value="8" />
-        </ADDITIONAL_INDENT_OPTIONS>
-        <ADDITIONAL_INDENT_OPTIONS fileType="js">
-          <option name="CONTINUATION_INDENT_SIZE" value="4" />
-        </ADDITIONAL_INDENT_OPTIONS>
-        <ADDITIONAL_INDENT_OPTIONS fileType="sass">
-          <option name="INDENT_SIZE" value="2" />
-        </ADDITIONAL_INDENT_OPTIONS>
-        <ADDITIONAL_INDENT_OPTIONS fileType="yml">
-          <option name="INDENT_SIZE" value="2" />
-        </ADDITIONAL_INDENT_OPTIONS>
+        <codeStyleSettings language="CSS">
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="CONTINUATION_INDENT_SIZE" value="4" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="ECMA Script Level 4">
+          <option name="KEEP_BLANK_LINES_IN_CODE" value="1" />
+          <option name="ALIGN_MULTILINE_PARAMETERS" value="false" />
+          <option name="ALIGN_MULTILINE_FOR" value="false" />
+          <option name="CALL_PARAMETERS_WRAP" value="1" />
+          <option name="METHOD_PARAMETERS_WRAP" value="1" />
+          <option name="EXTENDS_LIST_WRAP" value="1" />
+          <option name="BINARY_OPERATION_WRAP" value="1" />
+          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />
+          <option name="TERNARY_OPERATION_WRAP" value="1" />
+          <option name="TERNARY_OPERATION_SIGNS_ON_NEXT_LINE" value="true" />
+          <option name="FOR_STATEMENT_WRAP" value="1" />
+          <option name="ARRAY_INITIALIZER_WRAP" value="1" />
+          <option name="IF_BRACE_FORCE" value="3" />
+          <option name="DOWHILE_BRACE_FORCE" value="3" />
+          <option name="WHILE_BRACE_FORCE" value="3" />
+          <option name="FOR_BRACE_FORCE" value="3" />
+          <option name="PARENT_SETTINGS_INSTALLED" value="true" />
+        </codeStyleSettings>
+        <codeStyleSettings language="HTML">
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="CONTINUATION_INDENT_SIZE" value="4" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
         <codeStyleSettings language="JAVA">
+          <option name="KEEP_CONTROL_STATEMENT_IN_ONE_LINE" value="false" />
+          <option name="KEEP_BLANK_LINES_IN_CODE" value="1" />
+          <option name="ALIGN_MULTILINE_PARAMETERS" value="false" />
+          <option name="ALIGN_MULTILINE_RESOURCES" value="false" />
+          <option name="ALIGN_MULTILINE_FOR" value="false" />
+          <option name="CALL_PARAMETERS_WRAP" value="1" />
+          <option name="METHOD_PARAMETERS_WRAP" value="1" />
+          <option name="EXTENDS_LIST_WRAP" value="1" />
+          <option name="THROWS_KEYWORD_WRAP" value="1" />
+          <option name="METHOD_CALL_CHAIN_WRAP" value="1" />
+          <option name="BINARY_OPERATION_WRAP" value="1" />
+          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />
+          <option name="TERNARY_OPERATION_WRAP" value="1" />
+          <option name="TERNARY_OPERATION_SIGNS_ON_NEXT_LINE" value="true" />
+          <option name="KEEP_SIMPLE_BLOCKS_IN_ONE_LINE" value="true" />
+          <option name="KEEP_SIMPLE_METHODS_IN_ONE_LINE" value="true" />
+          <option name="KEEP_SIMPLE_LAMBDAS_IN_ONE_LINE" value="true" />
+          <option name="KEEP_SIMPLE_CLASSES_IN_ONE_LINE" value="true" />
+          <option name="FOR_STATEMENT_WRAP" value="1" />
+          <option name="ARRAY_INITIALIZER_WRAP" value="1" />
+          <option name="IF_BRACE_FORCE" value="3" />
+          <option name="DOWHILE_BRACE_FORCE" value="3" />
+          <option name="WHILE_BRACE_FORCE" value="3" />
+          <option name="FOR_BRACE_FORCE" value="3" />
+          <option name="PARENT_SETTINGS_INSTALLED" value="true" />
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="CONTINUATION_INDENT_SIZE" value="4" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="JSON">
+          <indentOptions>
+            <option name="CONTINUATION_INDENT_SIZE" value="4" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="JavaScript">
+          <option name="RIGHT_MARGIN" value="80" />
+          <option name="KEEP_BLANK_LINES_IN_CODE" value="1" />
           <option name="ALIGN_MULTILINE_PARAMETERS" value="false" />
+          <option name="ALIGN_MULTILINE_FOR" value="false" />
+          <option name="CALL_PARAMETERS_WRAP" value="1" />
+          <option name="METHOD_PARAMETERS_WRAP" value="1" />
+          <option name="BINARY_OPERATION_WRAP" value="1" />
+          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />
+          <option name="TERNARY_OPERATION_WRAP" value="1" />
+          <option name="TERNARY_OPERATION_SIGNS_ON_NEXT_LINE" value="true" />
+          <option name="FOR_STATEMENT_WRAP" value="1" />
+          <option name="ARRAY_INITIALIZER_WRAP" value="1" />
+          <option name="IF_BRACE_FORCE" value="3" />
+          <option name="DOWHILE_BRACE_FORCE" value="3" />
+          <option name="WHILE_BRACE_FORCE" value="3" />
+          <option name="FOR_BRACE_FORCE" value="3" />
+          <option name="PARENT_SETTINGS_INSTALLED" value="true" />
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="ObjectiveC">
+          <option name="KEEP_BLANK_LINES_BEFORE_RBRACE" value="1" />
+          <option name="BLANK_LINES_BEFORE_IMPORTS" value="0" />
+          <option name="BLANK_LINES_AFTER_IMPORTS" value="0" />
+          <option name="BLANK_LINES_AROUND_CLASS" value="0" />
+          <option name="BLANK_LINES_AROUND_METHOD" value="0" />
+          <option name="BLANK_LINES_AROUND_METHOD_IN_INTERFACE" value="0" />
+          <option name="ALIGN_MULTILINE_BINARY_OPERATION" value="false" />
+          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />
+          <option name="FOR_STATEMENT_WRAP" value="1" />
+          <option name="ASSIGNMENT_WRAP" value="1" />
           <indentOptions>
             <option name="INDENT_SIZE" value="2" />
             <option name="CONTINUATION_INDENT_SIZE" value="4" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="PROTO">
+          <option name="RIGHT_MARGIN" value="80" />
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="CONTINUATION_INDENT_SIZE" value="2" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="Python">
+          <option name="KEEP_BLANK_LINES_IN_CODE" value="1" />
+          <option name="RIGHT_MARGIN" value="80" />
+          <option name="ALIGN_MULTILINE_PARAMETERS" value="false" />
+          <option name="PARENT_SETTINGS_INSTALLED" value="true" />
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="CONTINUATION_INDENT_SIZE" value="4" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="SASS">
+          <indentOptions>
+            <option name="CONTINUATION_INDENT_SIZE" value="4" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="SCSS">
+          <indentOptions>
+            <option name="CONTINUATION_INDENT_SIZE" value="4" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="TypeScript">
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="XML">
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="CONTINUATION_INDENT_SIZE" value="2" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+          <arrangement>
+            <rules>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>xmlns:android</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>^$</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>xmlns:.*</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>^$</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:id</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>style</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>^$</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>^$</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:.*Style</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_width</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_height</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_weight</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_margin</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_marginTop</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_marginBottom</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_marginStart</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_marginEnd</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_marginLeft</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_marginRight</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_.*</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:padding</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:paddingTop</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:paddingBottom</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:paddingStart</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:paddingEnd</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:paddingLeft</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:paddingRight</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*</NAME>
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*</NAME>
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res-auto</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*</NAME>
+                      <XML_NAMESPACE>http://schemas.android.com/tools</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*</NAME>
+                      <XML_NAMESPACE>.*</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+            </rules>
+          </arrangement>
+        </codeStyleSettings>
+        <codeStyleSettings language="protobuf">
+          <option name="RIGHT_MARGIN" value="80" />
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="CONTINUATION_INDENT_SIZE" value="2" />
             <option name="TAB_SIZE" value="2" />
           </indentOptions>
         </codeStyleSettings>
       </value>
     </option>
-    <option name="PREFERRED_PROJECT_CODE_STYLE" value="GoogleStyle" />
+    <option name="USE_PER_PROJECT_SETTINGS" value="true" />
   </component>
-</project>
\ No newline at end of file
+</project>
diff --git a/.idea/inspectionProfiles/Project_Default.xml b/.idea/inspectionProfiles/Project_Default.xml
new file mode 100644
index 000000000..1c2b4c84f
--- /dev/null
+++ b/.idea/inspectionProfiles/Project_Default.xml
@@ -0,0 +1,9 @@
+<component name="InspectionProjectProfileManager">
+  <profile version="1.0">
+    <option name="myName" value="Project Default" />
+    <inspection_tool class="SerializableHasSerialVersionUIDField" enabled="true" level="WARNING" enabled_by_default="true">
+      <option name="ignoreAnonymousInnerClasses" value="false" />
+      <option name="superClassString" value="" />
+    </inspection_tool>
+  </profile>
+</component>
\ No newline at end of file
diff --git a/.travis.yml b/.travis.yml
index a16977739..8e655e0f8 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,24 +1,41 @@
 language: android
+sudo: false
+dist: trusty
+
+before_install:
+  - mkdir "$ANDROID_HOME/licenses" || true
+  - echo -e "\n8933bad161af4178b1185d1a37fbf41ea5269c55\nd56f5187479451eabf01fb78af6dfcb131a6481e" > "$ANDROID_HOME/licenses/android-sdk-license"
+  - echo -e "\n84831b9409646a918e30573bab4c9c91346d8abd\n504667f4c0de7af1a06de9f4b1727b84351f2910" > "$ANDROID_HOME/licenses/android-sdk-preview-license"
+
 android:
   components:
-  - tools
-  - platform-tools
-  - build-tools-26.0.1
-  - android-26
-
-  licenses:
-  - 'android-sdk-license.*'
+    # https://github.com/travis-ci/travis-ci/issues/6040#issuecomment-219367943
+    - tools
+    - tools
 
 jdk:
   - oraclejdk8
 
-sudo: false
+env:
+  matrix:
+    - COMPONENT=unit
+    - COMPONENT=firebase
+    - COMPONENT=instrumentation ANDROID_TARGET=16
+    - COMPONENT=instrumentation ANDROID_TARGET=17
+    - COMPONENT=instrumentation ANDROID_TARGET=18
+    - COMPONENT=instrumentation ANDROID_TARGET=19
+    - COMPONENT=instrumentation ANDROID_TARGET=21
+    - COMPONENT=instrumentation ANDROID_TARGET=22
+    - COMPONENT=samples
+
+before_script:
+  - ./scripts/travis_before_script.sh
 
-script: 'travis_retry ./gradlew build --parallel'
+script:
+  - ./scripts/travis_script.sh
 
 after_success:
-- scripts/travis-sonatype-publish.sh
-- ./gradlew jacocoTestReport coveralls
+  - ./scripts/travis_after_success.sh
 
 before_cache:
   - rm -f $HOME/.gradle/caches/modules-2/modules-2.lock
diff --git a/CHANGELOG.md b/CHANGELOG.md
new file mode 100644
index 000000000..7b49f092c
--- /dev/null
+++ b/CHANGELOG.md
@@ -0,0 +1,53 @@
+# Change Log
+
+## [v4.5.0](https://github.com/bumptech/glide/tree/HEAD)
+
+[Full Changelog](https://github.com/bumptech/glide/compare/v4.4.0...v4.5.0)
+
+## Features
+* Add an API to pause all requests for a given `Activity` or `Fragment` to allow callers to manually reduce memory when their Fragment or Application is backgrounded (@kurtisnelson, 09e33a2133eb1d4005b227439c0c53c9c4e8c89b) 
+* Fully support Bitmap re-use for `RGBA_F16` `Bitmap`s. Previously Glide supported decoding `RGBA_F16` `Bitmap`s, but would not re-use any stored in the `BitmapPool` when doing so (cc0288c3b4bfb82a109a3f279af52c57fc5e1499)
+* Support decoding Videos from resources as `AssetFileDescriptor`s (6e9866b5a19d06625006a9a8c605db21047df74b)
+* Added support for the [`MediaMetadataRetriever#getScaledFrameAtTime`][2] method added in OMR1 to marginally reduce memory usage when decoding video frames (ded8f77c9f2471e3c3413aa234656df8cf72dd2f)
+* Support transcoding `BitmapDrawable`s to `byte[]`s (015d2659a9ea7438ab72b94500a0921f8ff35aa3)
+
+## Bugs
+* Cleaned up old and incorrect `@TargetApi` annoatations (@SUPERCILEX, 67783961c71639871cc3687894976e6caeb6609e)
+* Added `@Nullable` and `@NonNull` annotations to many of Glide's APIs (@SUPERCILEX, dc12b60c8f0a21eb9b3ab2164471c93d2e20ae25, c3dafde00a061bafcd43a739336ca3503af13a7d, 0cffd1da977e9ca334032ebc1d798213a177aab7, f541b65e596a49d252ba6b80d3b05a111ce93461, 36e0b802c3a1e564caf230b351a6438fa32100ac, 650bb7770d08b279c2a7f00e25337618da54f7f3, bd2f21595d3404e6aadf1f4333bef369509c4a56, e35a73b4e78f2f05dc5c1163b8083ac1b662b02f, f37ced1512f7eabf37f6c93b1b7ffb32c3629b72, bb96b633174184965cd1bdf9027ef3843f59c54f, 276d4ff4bdce85763c985c90a87ea5e858a1ffe4, c3107801dab8ccbe121157bee7dba29b7d9723e6, )
+* Fixed a case where restarting an identical request with `skipMemoryCache(true)` would complete the load from the memory cache (#2663, 3dc1d18da75b44d8d97f4161fe0d330e4993e537)
+* Fixed decoding interlaced and downsampled GIFs as static images (#2698, b64f23de2a7ba38fceac1cda85f05158e80132f9)
+* Added more models to the list of devices requiring a lock when decoding or drawing Bitmaps (@strooooke, #738, c809f7ec03bbfc2c529f2c211cfc644c2073aab0, e923554b10fa9625f4fa6fe706f3d5a553843ab9)
+* Fixed a race condition where starting multiple loads simultaneously the first time any request is made for a given model and resource could lead to NPEs (#2708, d427cbd33206cbcc88ac4a0f0c29ef831d4bb5b5)
+* Make the annotation processor tests pass on Windows (@SUPERCILEX, #2709, 2b4be8b8c210abb34740f0778434679b644a6525)
+* Fix NPE and RuntimeExceptions thrown in `DefaultConnectivityMonitor` on some devices (c902730b75085cecdd40cd5817453d8af0eff4e9)
+* Only trim to half of the memory cache maximum size, not the current size, when background the app (@kurtisnelson, 429b7e2d9854da549eb0b852e2e08de176f05fbf)
+* Fix a `StateVerifier` exception thrown when `ResourceEncoder` implementations unexpectedly throw exceptions while writing resources to Glide's disk cache (6c7cf3f8cae998469a7e7df8c70c459311479a38)
+* Fix an NPE error message when `ResourceDrawableDecoder` fails to decode an image (d522ac7249ca1bf71f6de30e62d71a1faa8d4c4c)
+* Fix an `IllegalStateException` if a request using [`.error()`][3] is cleared while the error request is running (#2767, 9c70aa5f92f523c6bac29628554fdde5428e0cdd)
+* Cleaned up a number of accessor classes generated by unnecessarily strict visibility in inner classes (@TWiStErRob, e02969417a75048af0fcb61c5fbf6ea94bd2c4aa)
+* Updated OkHttp and removed a no longer necessary workaround for `ClassCastException`s thrown by the Android framework on O (#2355, 642b2dc431e54cb677088e934743d78f1ad84810)
+* Added missing annotations to overrides on some of Glide's generated classes (@TWiStErRob, 62d7464fb4f874897121591815ecb7503f7bc01b, 9fde00628f223e96372aeceadcb3e35a0635cb6d, d7bb6f956b34dd00ad0dbcb64f15f4b9c2fb0538)
+* Avoid throwing exceptions when `LruBitmapPool` was asked to provide `Bitmap`s with a `null` config (c1036c1cdc3c85827bf566e104a12ca880e26411)
+
+
+## Behavior Changes
+* Default to `aar` packaging in POMs, so `@aar` should no longer be required to avoid warnings about jars depending on aars (06ba3442fd8d25c943e986c2bd6c138aa4b390e3)
+* Default active resource retention to false (73759b9eb1d3b186c4deb6412137b0b1193fbd5d), but leave the option in `GlideBuilder` to manually enable it. Enabling active resource retention can lead to recycled `Bitmap` errors or `Bitmap` re-use bugs if applications call `Bitmap.recycle()` on any images loaded by Glide or mutate the contents of `Bitmap`s loaded by Glide. 
+* Treat devices with API < 19 as having `ActivityManager.isLowRam` set to `true` (#2650, b221d4bbec138efcdb1aabd07600b7df713f9e40)
+
+## Breaking Changes
+* Removed deprecated constructors requiring `Context`s in most of Glide's default `Transformation` (23975d933bcda7d136340b9988f2bd575065b667, 733b2e0f25a6d3ddbb4942172e92a9fe01c87363, 9bedc2b5fe5b1b2e05203af173c73f0e599a0177, 55594baf791ccb49dd5cdc256662360717b409bb, d8f6224d127b984c3ac1356d44f62126e4843d07, d840533448fd7bde528e0af7ce10c49653430c12, 2f76842b8ef9ac15c43a2c5175f23496b5a13f37, 144ac5374eb0bd11a8f8e92d7346dafac1426621, 150ebabbd7d5e8751c8678fa01418d1b1f1259da, 92d761d002da25320f2c504267f56d73b889b2d4, a6f1b1c1bef5b4e8be736c564792715266b07463) 
+
+## Deprecations
+* Deprecated [`VideoBitmapDecoder`][4], use [`VideoDecoder`][5] instead.
+
+## Build Changes
+* Glide must be compiled against API 27 (@SUPERCILEX, #2730, 75c2a8b6d216013e7fbf797231839a8f4c82757a)
+* Glide uses v27 of the support libraries (though v26 should work as well, to use v26 of the support library, see [Glide's Android SDK requirements docs page][1])
+* Updated to PMD 6.0.0 (@TWiStErRob, f16aef4c6ad583bafe796c7a952a0d10920c4dcd)
+* Fix a PMD failure when building with --profile or any other way in which class files didn't happen to have already been compiled (@TWiStErRob, #2776, fd73179166b15af246769c9b1ae205c65c584e5b)
+
+[1]: http://bumptech.github.io/glide/doc/download-setup.html#android-sdk-requirements
+[2]: https://developer.android.com/reference/android/media/MediaMetadataRetriever.html#getScaledFrameAtTime(long,%20int,%20int,%20int)
+[3]: http://bumptech.github.io/glide/javadocs/440/com/bumptech/glide/RequestBuilder.html#error-com.bumptech.glide.RequestBuilder-
+[4]: http://bumptech.github.io/glide/javadocs/450/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.html
diff --git a/README.md b/README.md
index b2e7f345b..f1445f0d3 100644
--- a/README.md
+++ b/README.md
@@ -18,6 +18,8 @@ also effective for almost any case where you need to fetch, resize, and display
 
 Download
 --------
+For detailed instructions and requirements, see Glide's [download and setup docs page][28].
+
 You can download a jar from GitHub's [releases page][1].
 
 Or use Gradle:
@@ -25,12 +27,12 @@ Or use Gradle:
 ```gradle
 repositories {
   mavenCentral()
-  maven { url 'https://maven.google.com' }
+  google()
 }
 
 dependencies {
-  compile 'com.github.bumptech.glide:glide:4.1.1'
-  annotationProcessor 'com.github.bumptech.glide:compiler:4.1.1'
+  implementation 'com.github.bumptech.glide:glide:4.6.1'
+  annotationProcessor 'com.github.bumptech.glide:compiler:4.6.1'
 }
 ```
 
@@ -40,30 +42,25 @@ Or Maven:
 <dependency>
   <groupId>com.github.bumptech.glide</groupId>
   <artifactId>glide</artifactId>
-  <version>4.1.1</version>
-</dependency>
-<dependency>
-  <groupId>com.google.android</groupId>
-  <artifactId>support-v4</artifactId>
-  <version>r7</version>
+  <version>4.6.1</version>
 </dependency>
 <dependency>
   <groupId>com.github.bumptech.glide</groupId>
   <artifactId>compiler</artifactId>
-  <version>4.1.1</version>
+  <version>4.6.1</version>
   <optional>true</optional>
 </dependency>
 ```
 
-For info on using the bleeding edge, see the [Snapshots][17] wiki page.
+For info on using the bleeding edge, see the [Snapshots][17] docs page.
 
 ProGuard
 --------
-Depending on your ProGuard (DexGuard) config and usage, you may need to include the following lines in your proguard.cfg (see [Configuration wiki](https://github.com/bumptech/glide/wiki/Configuration#keeping-a-glidemodule) for more details):
+Depending on your ProGuard (DexGuard) config and usage, you may need to include the following lines in your proguard.cfg (see the [Download and Setup docs page][25] for more details):
 
 ```pro
 -keep public class * implements com.bumptech.glide.module.GlideModule
--keep public class * extends com.bumptech.glide.AppGlideModule
+-keep public class * extends com.bumptech.glide.module.AppGlideModule
 -keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {
   **[] $VALUES;
   public *;
@@ -121,13 +118,13 @@ Comments/bugs/questions/pull requests are always welcome! Please read [CONTRIBUT
 Compatibility
 -------------
 
- * **Minimum Android SDK**: Glide requires a minimum API level of 14.
- * **Compile Android SDK**: Glide requires you to compile against API 26.
+ * **Minimum Android SDK**: Glide v4 requires a minimum API level of 14.
+ * **Compile Android SDK**: Glide v4 requires you to compile against API 26 or later.
 
- If you need to support older versions, consider staying on [Glide v3][14], which works on API 10, but not actively maintained.
- * **OkHttp 2.x**: there are optional dependencies available called `okhttp-integration`, see [Integration Libraries][12] wiki page.
- * **OkHttp 3.x**: there are optional dependencies available called `okhttp3-integration`, see [Integration Libraries][12] wiki page.
- * **Volley**: there are optional dependencies available called `volley-integration`, see [Integration Libraries][12] wiki page.
+ If you need to support older versions of Android, consider staying on [Glide v3][14], which works on API 10, but is not actively maintained.
+
+ * **OkHttp 3.x**: There is an optional dependency available called `okhttp3-integration`, see the [docs page][23].
+ * **Volley**: There is an optional dependency available called `volley-integration`, see the [docs page][24].
  * **Round Pictures**: `CircleImageView`/`CircularImageView`/`RoundedImageView` are known to have [issues][18] with `TransitionDrawable` (`.crossFade()` with `.thumbnail()` or `.placeholder()`) and animated GIFs, use a [`BitmapTransformation`][19] (`.circleCrop()` will be available in v4) or `.dontAnimate()` to fix the issue.
  * **Huge Images** (maps, comic strips): Glide can load huge images by downsampling them, but does not support zooming and panning `ImageView`s as they require special resource optimizations (such as tiling) to work without `OutOfMemoryError`s.
 
@@ -136,9 +133,8 @@ Build
 Building Glide with gradle is fairly straight forward:
 
 ```shell
-git clone git@github.com:bumptech/glide.git # use https://github.com/bumptech/glide.git if "Permission Denied"
+git clone https://github.com/bumptech/glide.git 
 cd glide
-git submodule init && git submodule update
 ./gradlew jar
 ```
 
@@ -160,14 +156,16 @@ You may also find precompiled APKs on the [releases page][1].
 Development
 -----------
 Follow the steps in the [Build](#build) section to setup the project and then edit the files however you wish.
-[Intellij IDEA 14][4] cleanly imports both Glide's source and tests and is the recommended way to work with Glide.
+[Android Studio][26] cleanly imports both Glide's source and tests and is the recommended way to work with Glide.
 
-To open the project in IntelliJ IDEA:
+To open the project in Android Studio:
 
 1. Go to *File* menu or the *Welcome Screen*
 2. Click on *Open...*
 3. Navigate to Glide's root directory.
-4. Select `build.gradle`
+4. Select `setting.gradle`
+
+For more details, see the [Contributing docs page][27].
 
 Getting Help
 ------------
@@ -200,7 +198,7 @@ This is not an official Google product.
 
 [1]: https://github.com/bumptech/glide/releases
 [2]: https://github.com/bumptech/glide/wiki
-[3]: http://bumptech.github.io/glide/ref/javadocs.html
+[3]: https://bumptech.github.io/glide/ref/javadocs.html
 [4]: https://www.jetbrains.com/idea/download/
 [5]: https://github.com/bumptech/glide/blob/master/CONTRIBUTING.md
 [6]: https://groups.google.com/forum/#!forum/glidelibrary
@@ -214,9 +212,15 @@ This is not an official Google product.
 [14]: https://github.com/bumptech/glide/tree/3.0
 [15]: https://github.com/bumptech/glide/tree/master
 [16]: https://github.com/bumptech/glide/blob/master/LICENSE
-[17]: https://github.com/bumptech/glide/wiki/Snapshots
+[17]: http://bumptech.github.io/glide/dev/snapshots.html
 [18]: https://github.com/bumptech/glide/issues?q=is%3Aissue+CircleImageView+OR+CircularImageView+OR+RoundedImageView
 [19]: https://github.com/wasabeef/glide-transformations
-[20]: http://bumptech.github.io/glide/
-[21]: http://bumptech.github.io/glide/doc/generatedapi.html
-[22]: https://muyangmin.github.io/glide-docs-cn/
\ No newline at end of file
+[20]: https://bumptech.github.io/glide/
+[21]: https://bumptech.github.io/glide/doc/generatedapi.html
+[22]: https://muyangmin.github.io/glide-docs-cn/
+[23]: http://bumptech.github.io/glide/int/okhttp3.html
+[24]: http://bumptech.github.io/glide/int/volley.html
+[25]: http://bumptech.github.io/glide/doc/download-setup.html#proguard
+[26]: https://developer.android.com/studio/index.html
+[27]: http://bumptech.github.io/glide/dev/contributing.html
+[28]: http://bumptech.github.io/glide/doc/download-setup.html
diff --git a/annotation/compiler/build.gradle b/annotation/compiler/build.gradle
index 656534bf7..4be6596a0 100644
--- a/annotation/compiler/build.gradle
+++ b/annotation/compiler/build.gradle
@@ -13,26 +13,31 @@ dependencies {
     // from https://code.google.com/archive/p/jarjar/downloads
     jarjar files('libs/jarjar-1.4.jar')
 
-    compileOnly 'com.squareup:javapoet:1.9.0'
-    compileOnly 'com.google.auto.service:auto-service:1.0-rc3'
-    compileOnly 'com.google.code.findbugs:jsr305:3.0.1'
-
+    compileOnly "com.squareup:javapoet:${JAVAPOET_VERSION}"
+    compileOnly "com.google.auto.service:auto-service:${AUTO_SERVICE_VERSION}"
+    compileOnly "com.google.code.findbugs:jsr305:${JSR_305_VERSION}"
     compile project(':annotation')
-    // This is to support com.sun.tootls.javac.util.List, currently used in RootModuleGenerator.
+    // This is to support com.sun.tools.javac.util.List, currently used in RootModuleGenerator.
     compile files(Jvm.current().getToolsJar())
 }
 
-def repackagedJar = file("$buildDir/intermediates/repackaged.jar")
-def proguardedJar = file("$buildDir/intermediates/proguarded.jar")
+// Make sure running `gradlew :annotation:compiler:check` actually does full quality control.
+test.dependsOn ':annotation:compiler:test:test'
+
+def packagingFolder = file("${buildDir}/intermediates")
+def repackagedJar = file("${packagingFolder}/repackaged.jar")
+def proguardedJar = file("${packagingFolder}/proguarded.jar")
 
 task compiledJar(type: Jar, dependsOn: classes) {
+    destinationDir = packagingFolder
+    archiveName = 'compiled.jar'
     from sourceSets.main.output
 }
 
 // Repackage compileOnly dependencies to avoid namespace collisions.
 task jarjar(dependsOn: [tasks.compiledJar, configurations.compileOnly]) {
     // Set up inputs and outputs to only rebuild when necessary (code change, dependency change).
-    inputs.file compiledJar
+    inputs.files compiledJar
     inputs.files configurations.compileOnly
     outputs.file repackagedJar
 
@@ -49,7 +54,7 @@ task jarjar(dependsOn: [tasks.compiledJar, configurations.compileOnly]) {
                         'META-INF/services/javax.annotation.processing.Processor'
                     ].join(','))
                 }
-                zipfileset(src: tasks.jar.archivePath)
+                zipfileset(src: tasks.compiledJar.archivePath)
                 def repackageIntoGlide = 'com.bumptech.glide.repackaged.@0'
                 rule result: repackageIntoGlide, pattern: 'com.squareup.javapoet.**'
                 rule result: repackageIntoGlide, pattern: 'com.google.auto.**'
@@ -71,10 +76,17 @@ task proguard(type: ProGuardTask, dependsOn: tasks.jarjar) {
     libraryjars "${System.getProperty('java.home')}/lib/rt.jar"
 }
 
-// Create the standard jar artifact based on our repackaged and proguarded jar.
+// Replace the contents of the standard jar task with those from our our compiled, repackaged and
+// proguarded jar. Replacing the task itself is possible and looks simpler, but requires
+// reconstructing the task dependency chain and is more complex in practice.
 jar {
     dependsOn proguard
     from zipTree(proguardedJar)
+    exclude { entry ->
+        sourceSets.main.output.files*.absolutePath.any {
+            entry.file.absolutePath.startsWith it
+        }
+    }
 }
 
 apply from: "${rootProject.projectDir}/scripts/upload.gradle"
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java
index 3e62fb816..291f594ae 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java
@@ -1,16 +1,22 @@
 package com.bumptech.glide.annotation.compiler;
 
+import static com.bumptech.glide.annotation.compiler.ProcessorUtil.nonNull;
+
 import com.bumptech.glide.annotation.Excludes;
 import com.squareup.javapoet.AnnotationSpec;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
 import com.squareup.javapoet.ParameterizedTypeName;
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
 import com.squareup.javapoet.TypeSpec.Builder;
 import com.squareup.javapoet.WildcardTypeName;
+import java.util.ArrayList;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.HashSet;
+import java.util.List;
 import java.util.Set;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
@@ -61,7 +67,8 @@
  *    }
  *
  *    {@literal @java.lang.Override}
- *    public java.util.Set<java.lang.Class<?>> getExcludedModuleClasses() {
+ *    {@literal @android.support.annotation.NonNull}
+ *    public java.util.Set&lt;java.lang.Class&lt;?>> getExcludedModuleClasses() {
  *      return appGlideModule.getExcludedModuleClasses();
  *    }
  *  }
@@ -74,6 +81,7 @@
   private static final String GENERATED_APP_MODULE_IMPL_SIMPLE_NAME =
       "GeneratedAppGlideModuleImpl";
   private static final String GENERATED_ROOT_MODULE_SIMPLE_NAME = "GeneratedAppGlideModule";
+
   private final ProcessorUtil processorUtil;
 
   AppModuleGenerator(ProcessorUtil processorUtil) {
@@ -82,15 +90,22 @@
 
   TypeSpec generate(TypeElement appGlideModule, Set<String> libraryGlideModuleClassNames) {
     ClassName appGlideModuleClassName = ClassName.get(appGlideModule);
-    Set<String> excludedGlideModuleClassNames =
+    List<String> excludedGlideModuleClassNames =
         getExcludedGlideModuleClassNames(appGlideModule);
 
+    List<String> orderedLibraryGlideModuleClassNames =
+        new ArrayList<>(libraryGlideModuleClassNames);
+    Collections.sort(orderedLibraryGlideModuleClassNames);
+
     MethodSpec constructor =
         generateConstructor(
-            appGlideModuleClassName, libraryGlideModuleClassNames, excludedGlideModuleClassNames);
+            appGlideModuleClassName,
+            orderedLibraryGlideModuleClassNames,
+            excludedGlideModuleClassNames);
 
     MethodSpec registerComponents =
-        generateRegisterComponents(libraryGlideModuleClassNames, excludedGlideModuleClassNames);
+        generateRegisterComponents(
+            orderedLibraryGlideModuleClassNames, excludedGlideModuleClassNames);
 
     MethodSpec getExcludedModuleClasses =
         generateGetExcludedModuleClasses(excludedGlideModuleClassNames);
@@ -99,8 +114,16 @@ TypeSpec generate(TypeElement appGlideModule, Set<String> libraryGlideModuleClas
         MethodSpec.methodBuilder("applyOptions")
             .addModifiers(Modifier.PUBLIC)
             .addAnnotation(Override.class)
-            .addParameter(ClassName.get("android.content", "Context"), "context")
-            .addParameter(ClassName.get("com.bumptech.glide", "GlideBuilder"), "builder")
+            .addParameter(ParameterSpec.builder(
+                ClassName.get("android.content", "Context"), "context")
+                .addAnnotation(nonNull())
+                .build()
+            )
+            .addParameter(ParameterSpec.builder(
+                ClassName.get("com.bumptech.glide", "GlideBuilder"), "builder")
+                .addAnnotation(nonNull())
+                .build()
+            )
             .addStatement("appGlideModule.applyOptions(context, builder)", appGlideModule)
             .build();
 
@@ -136,6 +159,7 @@ TypeSpec generate(TypeElement appGlideModule, Set<String> libraryGlideModuleClas
     builder.addMethod(
         MethodSpec.methodBuilder("getRequestManagerFactory")
             .addAnnotation(Override.class)
+            .addAnnotation(nonNull())
             .returns(generatedRequestManagerFactoryClassName)
             .addStatement("return new $T()", generatedRequestManagerFactoryClassName)
             .build());
@@ -143,7 +167,7 @@ TypeSpec generate(TypeElement appGlideModule, Set<String> libraryGlideModuleClas
   }
 
   // TODO: When we drop support for parsing GlideModules from AndroidManifests, remove this method.
-  private MethodSpec generateGetExcludedModuleClasses(Set<String> excludedClassNames) {
+  private MethodSpec generateGetExcludedModuleClasses(Collection<String> excludedClassNames) {
     TypeName wildCardOfObject = WildcardTypeName.subtypeOf(Object.class);
     ParameterizedTypeName classOfWildcardOfObjet =
         ParameterizedTypeName.get(ClassName.get(Class.class), wildCardOfObject);
@@ -154,6 +178,7 @@ private MethodSpec generateGetExcludedModuleClasses(Set<String> excludedClassNam
     MethodSpec.Builder builder = MethodSpec.methodBuilder("getExcludedModuleClasses")
         .addModifiers(Modifier.PUBLIC)
         .addAnnotation(Override.class)
+        .addAnnotation(nonNull())
         .returns(setOfClassOfWildcardOfObject);
 
     if (excludedClassNames.isEmpty()) {
@@ -174,15 +199,28 @@ private MethodSpec generateGetExcludedModuleClasses(Set<String> excludedClassNam
     return builder.build();
   }
 
-  private MethodSpec generateRegisterComponents(Set<String> libraryGlideModuleClassNames,
-      Set<String> excludedGlideModuleClassNames) {
+  private MethodSpec generateRegisterComponents(
+      Collection<String> libraryGlideModuleClassNames,
+      Collection<String> excludedGlideModuleClassNames) {
     MethodSpec.Builder registerComponents =
         MethodSpec.methodBuilder("registerComponents")
             .addModifiers(Modifier.PUBLIC)
             .addAnnotation(Override.class)
-            .addParameter(ClassName.get("android.content", "Context"), "context")
-            .addParameter(ClassName.get("com.bumptech.glide", "Glide"), "glide")
-            .addParameter(ClassName.get("com.bumptech.glide", "Registry"), "registry");
+            .addParameter(ParameterSpec.builder(
+                ClassName.get("android.content", "Context"), "context")
+                .addAnnotation(nonNull())
+                .build()
+            )
+            .addParameter(ParameterSpec.builder(
+                ClassName.get("com.bumptech.glide", "Glide"), "glide")
+                .addAnnotation(nonNull())
+                .build()
+            )
+            .addParameter(ParameterSpec.builder(
+                ClassName.get("com.bumptech.glide", "Registry"), "registry")
+                .addAnnotation(nonNull())
+                .build()
+            );
 
     for (String glideModule : libraryGlideModuleClassNames) {
       if (excludedGlideModuleClassNames.contains(glideModule)) {
@@ -198,7 +236,8 @@ private MethodSpec generateRegisterComponents(Set<String> libraryGlideModuleClas
   }
 
   private MethodSpec generateConstructor(ClassName appGlideModule,
-      Set<String> libraryGlideModuleClassNames, Set<String> excludedGlideModuleClassNames) {
+      Collection<String> libraryGlideModuleClassNames,
+      Collection<String> excludedGlideModuleClassNames) {
     MethodSpec.Builder constructorBuilder = MethodSpec.constructorBuilder();
     constructorBuilder.addStatement("appGlideModule = new $T()", appGlideModule);
 
@@ -224,8 +263,11 @@ private MethodSpec generateConstructor(ClassName appGlideModule,
     return constructorBuilder.build();
   }
 
-  private Set<String> getExcludedGlideModuleClassNames(TypeElement appGlideModule) {
-    return processorUtil.findClassValuesFromAnnotationOnClassAsNames(
+  private List<String> getExcludedGlideModuleClassNames(TypeElement appGlideModule) {
+    Set<String> names = processorUtil.findClassValuesFromAnnotationOnClassAsNames(
         appGlideModule, Excludes.class);
+    List<String> result = new ArrayList<>(names);
+    Collections.sort(result);
+    return result;
   }
 }
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java
index 17f64f327..5e10a334b 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java
@@ -15,9 +15,9 @@
 
 /**
  * Runs the final steps of Glide's annotation process and generates the combined
- * {@link AppGlideModule}, {@link com.bumptech.glide.Glide},
- * {@link com.bumptech.glide.RequestManager}, and
- * {@link com.bumptech.glide.request.RequestOptions} classes.
+ * {@code AppGlideModule}, {@code com.bumptech.glide.Glide},
+ * {@code com.bumptech.glide.RequestManager}, and
+ * {@code com.bumptech.glide.request.RequestOptions} classes.
  */
 final class AppModuleProcessor {
   private static final String COMPILER_PACKAGE_NAME =
@@ -166,8 +166,8 @@ private void writeRequestBuilder(String packageName, TypeSpec requestBuilder) {
   }
 
   private static final class FoundIndexedClassNames {
-    final Set<String> glideModules;
-    final Set<String> extensions;
+    private final Set<String> glideModules;
+    private final Set<String> extensions;
 
     private FoundIndexedClassNames(Set<String> glideModules, Set<String> extensions) {
       this.glideModules = glideModules;
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java
index 4d6ac80c8..eed0f1243 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java
@@ -5,6 +5,7 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Set;
+import javax.annotation.processing.ProcessingEnvironment;
 import javax.annotation.processing.RoundEnvironment;
 import javax.lang.model.element.TypeElement;
 
@@ -15,17 +16,22 @@
 final class ExtensionProcessor {
   private final ProcessorUtil processorUtil;
   private final IndexerGenerator indexerGenerator;
+  private final GlideExtensionValidator extensionValidator;
 
-  ExtensionProcessor(ProcessorUtil processorUtil, IndexerGenerator indexerGenerator) {
+  ExtensionProcessor(
+      ProcessingEnvironment processingEnvironment,
+      ProcessorUtil processorUtil,
+      IndexerGenerator indexerGenerator) {
     this.processorUtil = processorUtil;
     this.indexerGenerator = indexerGenerator;
+    extensionValidator = new GlideExtensionValidator(processingEnvironment, processorUtil);
   }
 
-  boolean processExtensions(Set<? extends TypeElement> set, RoundEnvironment env) {
+  boolean processExtensions(RoundEnvironment env) {
     List<TypeElement> elements = processorUtil.getElementsFor(GlideExtension.class, env);
     processorUtil.debugLog("Processing types : " + elements);
     for (TypeElement typeElement : elements) {
-      GlideExtensionValidator.validateExtension(typeElement);
+      extensionValidator.validateExtension(typeElement);
       processorUtil.debugLog("Processing elements: " + typeElement.getEnclosedElements());
     }
 
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java
index 9046219e2..32a8575d9 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java
@@ -16,8 +16,8 @@
  * Generates classes based on Glide's annotations that configure Glide, add support for additional
  * resource types, and/or extend Glide's API.
  *
- * <p>This processor discovers all {@link AppGlideModule} and
- * {@link LibraryGlideModule} implementations that are
+ * <p>This processor discovers all {@code AppGlideModule} and
+ * {@code LibraryGlideModule} implementations that are
  * annotated with {@link com.bumptech.glide.annotation.GlideModule}. Any implementations missing the
  * annotation will be ignored.
  *
@@ -26,42 +26,42 @@
  *
  * <p>Multiple classes are generated by this processor:
  * <ul>
- *   <li>For {@link LibraryGlideModule}s - A GlideIndexer class in a
+ *   <li>For {@code LibraryGlideModule}s - A GlideIndexer class in a
  *      specific package that will later be used by the processor to discover all
- *      {@link LibraryGlideModule} classes.
- *   <li>For {@link AppGlideModule}s - A single
- *      {@link AppGlideModule} implementation
- *     ({@link com.bumptech.glide.GeneratedAppGlideModule}) that calls all
- *     {@link LibraryGlideModule}s and the
- *     original {@link AppGlideModule} in the correct order when Glide is
+ *      {@code LibraryGlideModule} classes.
+ *   <li>For {@code AppGlideModule}s - A single
+ *      {@code AppGlideModule} implementation
+ *     ({@code com.bumptech.glide.GeneratedAppGlideModule}) that calls all
+ *     {@code LibraryGlideModule}s and the
+ *     original {@code AppGlideModule} in the correct order when Glide is
  *     initialized.
  *   <li>{@link com.bumptech.glide.annotation.GlideExtension}s -
  *   <ul>
- *     <li>A {@link com.bumptech.glide.request.RequestOptions} implementation that contains
+ *     <li>A {@code com.bumptech.glide.request.RequestOptions} implementation that contains
  *     static versions of all builder methods in the base class and both static and instance
  *     versions of methods in all {@link com.bumptech.glide.annotation.GlideExtension}s.
  *     <li>If one or more methods in one or more
  *     {@link com.bumptech.glide.annotation.GlideExtension} annotated classes are annotated with
  *     {@link GlideType}:
  *     <ul>
- *       <li>A {@link com.bumptech.glide.RequestManager} implementation containing a generated
+ *       <li>A {@code com.bumptech.glide.RequestManager} implementation containing a generated
  *       method for each method annotated with
  *       {@link GlideType}.
- *       <li>A {@link com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory}
- *       implementation that produces the generated {@link com.bumptech.glide.RequestManager}s.
- *       <li>A {@link com.bumptech.glide.Glide} look-alike that implements all static methods in
- *       the {@link com.bumptech.glide.Glide} singleton and returns the generated
- *       {@link com.bumptech.glide.RequestManager} implementation when appropriate.
+ *       <li>A {@code com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory}
+ *       implementation that produces the generated {@code com.bumptech.glide.RequestManager}s.
+ *       <li>A {@code com.bumptech.glide.Glide} look-alike that implements all static methods in
+ *       the {@code com.bumptech.glide.Glide} singleton and returns the generated
+ *       {@code com.bumptech.glide.RequestManager} implementation when appropriate.
  *     </ul>
  *   </ul>
  * </ul>
  *
- * <p>{@link AppGlideModule} implementations must only be included in
+ * <p>{@code AppGlideModule} implementations must only be included in
  * applications, not in libraries. There must be exactly one
- * {@link AppGlideModule} implementation per
- * Application. The {@link AppGlideModule} class is
+ * {@code AppGlideModule} implementation per
+ * Application. The {@code AppGlideModule} class is
  * used as a signal that all modules have been found and that the final merged
- * {@link com.bumptech.glide.GeneratedAppGlideModule} impl can be created.
+ * {@code com.bumptech.glide.GeneratedAppGlideModule} impl can be created.
  */
 @AutoService(Processor.class)
 public final class GlideAnnotationProcessor extends AbstractProcessor {
@@ -79,7 +79,8 @@ public synchronized void init(ProcessingEnvironment processingEnvironment) {
     IndexerGenerator indexerGenerator = new IndexerGenerator(processorUtil);
     libraryModuleProcessor = new LibraryModuleProcessor(processorUtil, indexerGenerator);
     appModuleProcessor = new AppModuleProcessor(processingEnvironment, processorUtil);
-    extensionProcessor = new ExtensionProcessor(processorUtil, indexerGenerator);
+    extensionProcessor =
+        new ExtensionProcessor(processingEnvironment, processorUtil, indexerGenerator);
   }
 
   @Override
@@ -96,22 +97,27 @@ public SourceVersion getSupportedSourceVersion() {
   }
 
    /**
-   * Each round we do the following:
-   * <ol>
-   *   <li>Find all AppGlideModules and save them to an instance variable (throw if > 1).
-   *   <li>Find all LibraryGlideModules
-   *   <li>For each LibraryGlideModule, write an Indexer with an Annotation with the class name.
-   *   <li>If we wrote any Indexers, return and wait for the next round.
-   *   <li>If we didn't write any Indexers and there is a AppGlideModule, write the
-   *   GeneratedAppGlideModule. Once the GeneratedAppGlideModule is written, we expect to be
-   *   finished. Any further generation of related classes will result in errors.
-   * </ol>
-   */
+    * Each round we do the following:
+    * <ol>
+    *   <li>Find all {@code AppGlideModule}s and save them to an instance variable (throw if > 1).
+    *   <li>Find all {@code LibraryGlideModule}s
+    *   <li>For each {@code LibraryGlideModule},
+    *       write an {@code Indexer} with an Annotation with the class name.
+    *   <li>If we wrote any {@code Indexer}s, return and wait for the next round.
+    *   <li>If we didn't write any {@code Indexer}s and there is a {@code AppGlideModule},
+    *       write the {@code GeneratedAppGlideModule}.
+    *       Once the {@code GeneratedAppGlideModule} is written, we expect to be finished.
+    *       Any further generation of related classes will result in errors.
+    * </ol>
+    */
   @Override
   public boolean process(Set<? extends TypeElement> set, RoundEnvironment env) {
+//    if (set.isEmpty() && !isGeneratedAppGlideModulePending) {
+//      return false;
+//    }
     processorUtil.process();
-    boolean newModulesWritten = libraryModuleProcessor.processModules(set, env);
-    boolean newExtensionWritten = extensionProcessor.processExtensions(set, env);
+    boolean newModulesWritten = libraryModuleProcessor.processModules(env);
+    boolean newExtensionWritten = extensionProcessor.processExtensions(env);
     appModuleProcessor.processModules(set, env);
 
     if (newExtensionWritten || newModulesWritten) {
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java
index 488c5578f..051cc4be6 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java
@@ -1,15 +1,26 @@
 package com.bumptech.glide.annotation.compiler;
 
+import static com.bumptech.glide.annotation.compiler.ProcessorUtil.nonNull;
+
 import com.bumptech.glide.annotation.GlideOption;
 import com.bumptech.glide.annotation.GlideType;
+import com.google.common.base.Function;
+import com.google.common.collect.FluentIterable;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
+import javax.tools.Diagnostic.Kind;
 
 /**
  * Validates that classes annotated with {@link com.bumptech.glide.annotation.GlideExtension}
@@ -20,75 +31,277 @@
  * for an Application.
  */
 final class GlideExtensionValidator {
+  private final ProcessingEnvironment processingEnvironment;
+  private final ProcessorUtil processorUtil;
 
-  private GlideExtensionValidator() { }
+  GlideExtensionValidator(
+      ProcessingEnvironment processingEnvironment, ProcessorUtil processorUtil) {
+    this.processingEnvironment = processingEnvironment;
+    this.processorUtil = processorUtil;
+  }
 
-  static void validateExtension(TypeElement typeElement) {
+  void validateExtension(TypeElement typeElement) {
     if (!typeElement.getModifiers().contains(Modifier.PUBLIC)) {
-      throw new IllegalArgumentException("RequestOptionsExtensions must be public");
+      throw new IllegalArgumentException(
+          "RequestOptionsExtensions must be public, including: " + getName(typeElement));
     }
     for (Element element : typeElement.getEnclosedElements()) {
       if (element.getKind() == ElementKind.CONSTRUCTOR) {
-        if (!element.getModifiers().contains(Modifier.PRIVATE)) {
-          throw new IllegalArgumentException("RequestOptionsExtensions must be public, with private"
-              + " constructors and only static methods. Found a non-private constructor");
-        }
-        ExecutableElement executableElement = (ExecutableElement) element;
-        if (!executableElement.getParameters().isEmpty()) {
-          throw new IllegalArgumentException("RequestOptionsExtensions must be public, with private"
-              + " constructors and only static methods. Found parameters in the constructor");
-        }
-        continue;
-      }
-      if (element.getKind() == ElementKind.METHOD) {
+        validateExtensionConstructor(element);
+      } else if (element.getKind() == ElementKind.METHOD) {
         ExecutableElement executableElement = (ExecutableElement) element;
         if (executableElement.getAnnotation(GlideOption.class) != null) {
-          validateExtendsRequestOptions(executableElement);
+          validateGlideOption(executableElement);
         } else if (executableElement.getAnnotation(GlideType.class) != null) {
-          validateExtendsRequestManager(executableElement);
+          validateGlideType(executableElement);
         }
       }
     }
   }
 
-  private static void validateExtendsRequestOptions(ExecutableElement executableElement) {
+  private static String getQualifiedMethodName(ExecutableElement executableElement) {
+    return getEnclosingClassName(executableElement) + "#" + getName(executableElement);
+  }
+
+  private static String getEnclosingClassName(Element element) {
+    return element.getEnclosingElement().toString();
+  }
+
+  private static String getName(Element element) {
+    return element.toString();
+  }
+
+  private static void validateExtensionConstructor(Element element) {
+    if (!element.getModifiers().contains(Modifier.PRIVATE)) {
+      throw new IllegalArgumentException(
+          "RequestOptionsExtensions must be public, with private constructors and only static"
+              + " methods. Found a non-private constructor in: " + getEnclosingClassName(element));
+    }
+    ExecutableElement executableElement = (ExecutableElement) element;
+    if (!executableElement.getParameters().isEmpty()) {
+      throw new IllegalArgumentException(
+          "RequestOptionsExtensions must be public, with private constructors and only static"
+              + " methods. Found parameters in the constructor of: "
+              + getEnclosingClassName(element));
+    }
+  }
+
+  private void validateGlideOption(ExecutableElement executableElement) {
+    if (returnsVoid(executableElement)) {
+      validateDeprecatedGlideOption(executableElement);
+    } else {
+      validateNewGlideOption(executableElement);
+    }
+  }
+
+  private void validateNewGlideOption(ExecutableElement executableElement) {
+    validateNewGlideOptionAnnotations(executableElement);
+    validateGlideOptionParameters(executableElement);
+    TypeMirror returnType = executableElement.getReturnType();
+    if (!isRequestOptions(returnType)) {
+      throw new IllegalArgumentException("@GlideOption methods should return a RequestOptions"
+          + " object, but " + getQualifiedMethodName(executableElement) + " returns " + returnType
+          + ". If you're using old style @GlideOption methods, your method may have a void return"
+          + " type, but doing so is deprecated and support will be removed in a future version");
+    }
+    validateGlideOptionOverride(executableElement);
+  }
+
+  private void validateNewGlideOptionAnnotations(ExecutableElement executableElement) {
+    validateAnnotatedNonNull(executableElement);
+  }
+
+  private void validateDeprecatedGlideOption(ExecutableElement executableElement) {
     validateStaticVoid(executableElement, GlideOption.class);
+    validateGlideOptionParameters(executableElement);
+    validateGlideOptionOverride(executableElement);
+  }
+
+  private static void validateGlideOptionParameters(ExecutableElement executableElement) {
     if (executableElement.getParameters().isEmpty()) {
       throw new IllegalArgumentException("@GlideOption methods must take a "
-          + "RequestOptions object as their first parameter, but given none");
+          + "RequestOptions object as their first parameter, but "
+          + getQualifiedMethodName(executableElement) + " has none");
     }
     VariableElement first = executableElement.getParameters().get(0);
     TypeMirror expected = first.asType();
-    if (!expected.toString().equals(
-        "com.bumptech.glide.request.RequestOptions")) {
+    if (!isRequestOptions(expected)) {
       throw new IllegalArgumentException("@GlideOption methods must take a"
-          + " RequestOptions object as their first parameter, but given: " + expected);
+          + " RequestOptions object as their first parameter, but the first parameter in "
+          + getQualifiedMethodName(executableElement) + " is " + expected);
     }
   }
 
-  private static void validateExtendsRequestManager(ExecutableElement executableElement) {
+  private static boolean isRequestOptions(TypeMirror typeMirror) {
+    return typeMirror.toString().equals("com.bumptech.glide.request.RequestOptions");
+  }
+
+  private void validateGlideOptionOverride(ExecutableElement element) {
+    int overrideType = processorUtil.getOverrideType(element);
+    boolean isOverridingRequestOptionsMethod = isMethodInRequestOptions(element);
+    if (isOverridingRequestOptionsMethod && overrideType == GlideOption.OVERRIDE_NONE) {
+      throw new IllegalArgumentException("Accidentally attempting to override a method in"
+          + " RequestOptions. Add an 'override' value in the @GlideOption annotation"
+          + " if this is intentional. Offending method: "
+          + getQualifiedMethodName(element));
+    } else if (!isOverridingRequestOptionsMethod && overrideType != GlideOption.OVERRIDE_NONE) {
+      throw new IllegalArgumentException("Requested to override an existing method in"
+          + " RequestOptions, but no such method was found. Offending method: "
+          + getQualifiedMethodName(element));
+    }
+  }
+
+  private boolean isMethodInRequestOptions(ExecutableElement toFind) {
+    // toFind is a method in a GlideExtension whose first argument is a BaseRequestOptions<?> type.
+    // Since we're comparing against methods in BaseRequestOptions itself, we need to drop that
+    // first type.
+    TypeElement requestOptionsType =
+        processingEnvironment
+            .getElementUtils()
+            .getTypeElement(RequestOptionsGenerator.REQUEST_OPTIONS_QUALIFIED_NAME);
+    List<String> toFindParameterNames = getComparableParameterNames(toFind, true /*skipFirst*/);
+    String toFindSimpleName = toFind.getSimpleName().toString();
+    for (Element element : requestOptionsType.getEnclosedElements()) {
+      if (element.getKind() != ElementKind.METHOD) {
+        continue;
+      }
+      ExecutableElement inBase = (ExecutableElement) element;
+      if (toFindSimpleName.equals(inBase.getSimpleName().toString())) {
+        List<String> parameterNamesInBase =
+            getComparableParameterNames(inBase, false /*skipFirst*/);
+        if (parameterNamesInBase.equals(toFindParameterNames)) {
+          return true;
+        }
+      }
+    }
+    return false;
+  }
+
+  private static List<String> getComparableParameterNames(
+      ExecutableElement element, boolean skipFirst) {
+    List<? extends VariableElement> parameters = element.getParameters();
+    if (skipFirst) {
+      parameters = parameters.subList(1, parameters.size());
+    }
+    List<String> result = new ArrayList<>(parameters.size());
+    for (VariableElement parameter : parameters) {
+      result.add(parameter.asType().toString());
+    }
+    return result;
+  }
+
+  private void validateGlideType(ExecutableElement executableElement) {
+    if (returnsVoid(executableElement)) {
+      validateDeprecatedGlideType(executableElement);
+    } else {
+      validateNewGlideType(executableElement);
+    }
+  }
+
+  private void validateNewGlideType(ExecutableElement executableElement) {
+    TypeMirror returnType = executableElement.getReturnType();
+    validateNewGlideTypeAnnotations(executableElement);
+    if (!isRequestBuilder(returnType) || !typeMatchesExpected(returnType, executableElement)) {
+      String expectedClassName = getGlideTypeValue(executableElement);
+      throw new IllegalArgumentException("@GlideType methods should return a RequestBuilder<"
+          + expectedClassName + "> object, but " + getQualifiedMethodName(executableElement)
+          + " returns: " + returnType + ". If you're using old style @GlideType methods, your"
+          + " method may have a void return type, but doing so is deprecated and support will be"
+          + " removed in a future version");
+    }
+    validateGlideTypeParameters(executableElement);
+  }
+
+  private String getGlideTypeValue(ExecutableElement executableElement) {
+    return
+        processorUtil
+            .findClassValuesFromAnnotationOnClassAsNames(
+                executableElement, GlideType.class).iterator().next();
+  }
+
+  private boolean typeMatchesExpected(
+      TypeMirror returnType, ExecutableElement executableElement) {
+    if (!(returnType instanceof DeclaredType)) {
+      return false;
+    }
+    List<? extends TypeMirror> typeArguments = ((DeclaredType) returnType).getTypeArguments();
+    if (typeArguments.size() != 1) {
+      return false;
+    }
+    TypeMirror argument = typeArguments.get(0);
+    String expected = getGlideTypeValue(executableElement);
+    return argument.toString().equals(expected);
+  }
+
+  private boolean isRequestBuilder(TypeMirror typeMirror) {
+    TypeMirror toCompare = processingEnvironment.getTypeUtils().erasure(typeMirror);
+    return toCompare.toString().equals("com.bumptech.glide.RequestBuilder");
+  }
+
+  private static void validateDeprecatedGlideType(ExecutableElement executableElement) {
     validateStaticVoid(executableElement, GlideType.class);
+    validateGlideTypeParameters(executableElement);
+  }
+
+  private static void validateGlideTypeParameters(ExecutableElement executableElement) {
     if (executableElement.getParameters().size() != 1) {
       throw new IllegalArgumentException("@GlideType methods must take a"
-          + " RequestOptions object as their first and only parameter, found multiple for: "
-      + executableElement.getEnclosingElement() + "#" + executableElement);
+          + " RequestBuilder object as their first and only parameter, but given multiple for: "
+          + getQualifiedMethodName(executableElement));
     }
 
     VariableElement first = executableElement.getParameters().get(0);
-    TypeMirror expected = first.asType();
-    if (!expected.toString().startsWith("com.bumptech.glide.RequestBuilder")) {
+    TypeMirror argumentType = first.asType();
+    if (!argumentType.toString().startsWith("com.bumptech.glide.RequestBuilder")) {
       throw new IllegalArgumentException("@GlideType methods must take a"
-          + " RequestBuilder object as their first parameter, but given: " + expected);
+          + " RequestBuilder object as their first and only parameter, but given: " + argumentType
+          + " for: " + getQualifiedMethodName(executableElement));
     }
   }
 
-  private static void validateStaticVoid(ExecutableElement executableElement, Class<?> clazz) {
+  private void validateNewGlideTypeAnnotations(ExecutableElement executableElement) {
+    validateAnnotatedNonNull(executableElement);
+  }
+
+  private void validateAnnotatedNonNull(ExecutableElement executableElement) {
+    Set<String> annotationNames =
+        FluentIterable.from(executableElement.getAnnotationMirrors())
+            .transform(new Function<AnnotationMirror, String>() {
+              @Override
+              public String apply(AnnotationMirror input) {
+                return input.getAnnotationType().asElement().toString();
+              }
+            })
+            .toSet();
+    if (!annotationNames.contains(nonNull().reflectionName())) {
+      processingEnvironment.getMessager().printMessage(
+          Kind.WARNING,
+          getQualifiedMethodName(executableElement)
+              + " is missing the " + nonNull().reflectionName() + " annotation,"
+              + " please add it to ensure that your extension methods are always returning non-null"
+              + " values");
+    }
+  }
+
+  private static void validateStatic(ExecutableElement executableElement, Class<?> clazz) {
     if (!executableElement.getModifiers().contains(Modifier.STATIC)) {
       throw new IllegalArgumentException("@" + clazz.getSimpleName() + " methods must be static");
     }
+  }
+
+  private static boolean returnsVoid(ExecutableElement executableElement) {
     TypeMirror returnType = executableElement.getReturnType();
-    if (returnType.getKind() != TypeKind.VOID) {
+    return returnType.getKind() == TypeKind.VOID;
+  }
+
+  private static void validateVoid(ExecutableElement executableElement, Class<?> clazz) {
+    if (!returnsVoid(executableElement)) {
       throw new IllegalArgumentException("@" + clazz.getSimpleName() + " methods must return void");
     }
   }
+
+  private static void validateStaticVoid(ExecutableElement executableElement, Class<?> clazz) {
+    validateStatic(executableElement, clazz);
+    validateVoid(executableElement, clazz);
+  }
 }
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java
index 99805e9b0..512fc42a7 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java
@@ -7,7 +7,7 @@
 import com.squareup.javapoet.AnnotationSpec;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.MethodSpec;
-import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.MethodSpec.Builder;
 import com.squareup.javapoet.TypeSpec;
 import java.util.ArrayList;
 import java.util.List;
@@ -23,7 +23,7 @@
  * Generates a Glide look-alike that acts as the entry point to the generated API
  * (GlideApp.with(...)).
  *
- * <p>>Generated {@link com.bumptech.glide.Glide} look-alikes look like this (note that the name
+ * <p>>Generated {@code com.bumptech.glide.Glide} look-alikes look like this (note that the name
  * is configurable in {@link com.bumptech.glide.annotation.GlideModule}):
  * <pre>
  * <code>
@@ -147,54 +147,57 @@ private MethodSpec overrideGlideStaticMethod(ExecutableElement methodToOverride)
         MethodSpec.methodBuilder(methodToOverride.getSimpleName().toString())
             .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
             .addJavadoc(processorUtil.generateSeeMethodJavadoc(methodToOverride))
-            .addParameters(Lists.transform(parameters,
-                new Function<VariableElement, ParameterSpec>() {
-                  @Override
-                  public ParameterSpec apply(VariableElement input) {
-                    return ParameterSpec.get(input);
-                  }
-            }));
-
-    TypeElement visibleForTestingType =
-        processingEnv
-            .getElementUtils()
-            .getTypeElement(VISIBLE_FOR_TESTING_QUALIFIED_NAME);
-    for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {
-      builder.addAnnotation(AnnotationSpec.get(mirror));
+            .addParameters(ProcessorUtil.getParameters(methodToOverride));
 
-      // Suppress a lint warning if we're overriding a VisibleForTesting method.
-      // See #1977.
-      if (mirror.getAnnotationType().asElement().equals(visibleForTestingType)) {
-        builder.addAnnotation(
-            AnnotationSpec.builder(
-                ClassName.get(SUPPRESS_LINT_PACKAGE_NAME, SUPPRESS_LINT_CLASS_NAME))
-                .addMember("value", "$S", "VisibleForTests")
-                .build());
-      }
-    }
+    addReturnAnnotations(builder, methodToOverride);
 
     boolean returnsValue = element != null;
     if (returnsValue) {
       builder.returns(ClassName.get(element));
     }
 
-    String code = returnsValue ? "return " : "";
-    code += "$T.$N(";
+    StringBuilder code = new StringBuilder(returnsValue ? "return " : "");
+    code.append("$T.$N(");
     List<Object> args = new ArrayList<>();
     args.add(ClassName.get(glideType));
     args.add(methodToOverride.getSimpleName());
     if (!parameters.isEmpty()) {
       for (VariableElement param : parameters) {
-        code += "$L, ";
+        code.append("$L, ");
         args.add(param.getSimpleName());
       }
-      code = code.substring(0, code.length() - 2);
+      code = new StringBuilder(code.substring(0, code.length() - 2));
     }
-    code += ")";
-    builder.addStatement(code, args.toArray(new Object[0]));
+    code.append(")");
+    builder.addStatement(code.toString(), args.toArray(new Object[0]));
     return builder.build();
   }
 
+  private Builder addReturnAnnotations(Builder builder, ExecutableElement methodToOverride) {
+    String visibleForTestingTypeQualifiedName =
+        processingEnv
+            .getElementUtils()
+            .getTypeElement(VISIBLE_FOR_TESTING_QUALIFIED_NAME)
+            .toString();
+
+    for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {
+      builder.addAnnotation(AnnotationSpec.get(mirror));
+
+      // Suppress a lint warning if we're overriding a VisibleForTesting method.
+      // See #1977.
+      String annotationQualifiedName = mirror.getAnnotationType().toString();
+      if (annotationQualifiedName.equals(visibleForTestingTypeQualifiedName)) {
+        builder.addAnnotation(
+            AnnotationSpec.builder(
+                ClassName.get(SUPPRESS_LINT_PACKAGE_NAME, SUPPRESS_LINT_CLASS_NAME))
+                .addMember("value", "$S", "VisibleForTests")
+                .build());
+      }
+    }
+
+    return builder;
+  }
+
   private List<ExecutableElement> discoverGlideMethodsToOverride() {
     return processorUtil.findStaticMethods(glideType);
   }
@@ -211,15 +214,17 @@ private MethodSpec overrideGlideWithMethod(
     Preconditions.checkArgument(
         parameters.size() == 1, "Expected size of 1, but got %s", methodToOverride);
     VariableElement parameter = parameters.iterator().next();
-    return MethodSpec.methodBuilder(methodToOverride.getSimpleName().toString())
+
+    Builder builder = MethodSpec.methodBuilder(methodToOverride.getSimpleName().toString())
         .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
         .addJavadoc(processorUtil.generateSeeMethodJavadoc(methodToOverride))
+        .addParameters(ProcessorUtil.getParameters(methodToOverride))
         .returns(generatedRequestManagerClassName)
-        .addParameter(ClassName.get(parameter.asType()), parameter.getSimpleName().toString())
         .addStatement("return ($T) $T.$N($L)",
             generatedRequestManagerClassName, glideType,
             methodToOverride.getSimpleName().toString(),
-            parameter.getSimpleName())
-        .build();
+            parameter.getSimpleName());
+
+    return addReturnAnnotations(builder, methodToOverride).build();
   }
 }
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/IndexerGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/IndexerGenerator.java
index afae52f38..7ff49feea 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/IndexerGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/IndexerGenerator.java
@@ -84,14 +84,15 @@ private static TypeSpec generate(List<TypeElement> libraryModules,
       annotationBuilder.addMember(value, "$S", ClassName.get(childModule).toString());
     }
 
-    String indexerName = INDEXER_NAME_PREFIX + annotation.getSimpleName() + "_";
+    StringBuilder indexerName = new StringBuilder(
+        INDEXER_NAME_PREFIX + annotation.getSimpleName() + "_");
     for (TypeElement element : libraryModules) {
-      indexerName += element.getQualifiedName().toString().replace(".", "_");
-      indexerName += "_";
+      indexerName.append(element.getQualifiedName().toString().replace(".", "_"));
+      indexerName.append("_");
     }
-    indexerName = indexerName.substring(0, indexerName.length() - 1);
+    indexerName = new StringBuilder(indexerName.substring(0, indexerName.length() - 1));
 
-    return TypeSpec.classBuilder(indexerName)
+    return TypeSpec.classBuilder(indexerName.toString())
         .addAnnotation(annotationBuilder.build())
         .addModifiers(Modifier.PUBLIC)
         .build();
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/LibraryModuleProcessor.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/LibraryModuleProcessor.java
index 8f79cb7e2..d6e6329a7 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/LibraryModuleProcessor.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/LibraryModuleProcessor.java
@@ -11,18 +11,18 @@
 
 /**
  * Generates Indexer classes annotated with {@link Index} for all
- * {@link LibraryGlideModule}s.
+ * {@code LibraryGlideModule}s.
  */
 final class LibraryModuleProcessor {
-  private ProcessorUtil processorUtil;
-  private IndexerGenerator indexerGenerator;
+  private final ProcessorUtil processorUtil;
+  private final IndexerGenerator indexerGenerator;
 
   LibraryModuleProcessor(ProcessorUtil processorUtil, IndexerGenerator indexerGenerator) {
     this.processorUtil = processorUtil;
     this.indexerGenerator = indexerGenerator;
   }
 
-  boolean processModules(Set<? extends TypeElement> set, RoundEnvironment env) {
+  boolean processModules(RoundEnvironment env) {
      // Order matters here, if we find an Indexer below, we return before writing the root module.
     // If we fail to add to appModules before then, we might accidentally skip a valid RootModule.
     List<TypeElement> libraryGlideModules = new ArrayList<>();
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java
index 5229afc21..201dd604a 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java
@@ -3,10 +3,13 @@
 import static com.bumptech.glide.annotation.compiler.GlideAnnotationProcessor.DEBUG;
 
 import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
 import com.google.common.base.Function;
+import com.google.common.base.Joiner;
 import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.Lists;
+import com.squareup.javapoet.AnnotationSpec;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.JavaFile;
@@ -14,13 +17,17 @@
 import com.squareup.javapoet.ParameterSpec;
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
+import com.squareup.javapoet.TypeVariableName;
 import com.sun.tools.javac.code.Attribute;
 import com.sun.tools.javac.code.Type.ClassType;
 import java.lang.annotation.Annotation;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashSet;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -35,8 +42,10 @@
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.TypeParameterElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.TypeVariable;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
@@ -54,6 +63,8 @@
       GLIDE_MODULE_PACKAGE_NAME + "." + LIBRARY_GLIDE_MODULE_SIMPLE_NAME;
   private static final String COMPILER_PACKAGE_NAME =
       GlideAnnotationProcessor.class.getPackage().getName();
+  private static final ClassName NONNULL_ANNOTATION =
+      ClassName.get("android.support.annotation", "NonNull");
 
   private final ProcessingEnvironment processingEnv;
   private final TypeElement appGlideModuleType;
@@ -87,6 +98,12 @@ boolean isExtension(TypeElement element) {
     return element.getAnnotation(GlideExtension.class) != null;
   }
 
+  int getOverrideType(ExecutableElement element) {
+    GlideOption glideOption =
+        element.getAnnotation(GlideOption.class);
+    return glideOption.override();
+  }
+
   void writeIndexer(TypeSpec indexer) {
     writeClass(COMPILER_PACKAGE_NAME, indexer);
   }
@@ -189,24 +206,23 @@ public Object apply(ParameterSpec input) {
   private CodeBlock generateSeeMethodJavadocInternal(
       TypeName nameOfClassContainingMethod, String methodName,
       List<Object> safeParameterNames) {
-     String javadocString = "@see $T#$L(";
+    StringBuilder javadocString = new StringBuilder("@see $T#$L(");
     List<Object> javadocArgs = new ArrayList<>();
     javadocArgs.add(nameOfClassContainingMethod);
     javadocArgs.add(methodName);
 
     for (Object param : safeParameterNames) {
-      javadocString += "$T, ";
+      javadocString.append("$T, ");
       javadocArgs.add(param);
     }
     if (javadocArgs.size() > 2) {
-      javadocString = javadocString.substring(0, javadocString.length() - 2);
+      javadocString = new StringBuilder(javadocString.substring(0, javadocString.length() - 2));
     }
-    javadocString += ")\n";
-    return CodeBlock.of(javadocString, javadocArgs.toArray(new Object[0]));
+    javadocString.append(")\n");
+    return CodeBlock.of(javadocString.toString(), javadocArgs.toArray(new Object[0]));
   }
 
-
-   /**
+  /**
    * Returns a safe String to use in a Javadoc that will function in a link.
    *
    * <p>This method exists because by Javadoc doesn't handle type parameters({@literal <T>}
@@ -233,6 +249,95 @@ void infoLog(String toLog) {
     processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, "[" + round + "] " + toLog);
   }
 
+  void warnLog(String toLog) {
+    processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING, toLog);
+  }
+
+  static CodeBlock generateCastingSuperCall(TypeName toReturn, ExecutableElement method) {
+    return CodeBlock.builder()
+        .add("return ($T) super.$N(", toReturn, method.getSimpleName())
+        .add(
+            FluentIterable.from(method.getParameters())
+                .transform(new Function<VariableElement, String>() {
+                  @Override
+                  public String apply(VariableElement input) {
+                    return input.getSimpleName().toString();
+                  }
+                })
+                .join(Joiner.on(",")))
+        .add(");\n")
+        .build();
+  }
+
+  static MethodSpec.Builder overriding(ExecutableElement method) {
+    String methodName = method.getSimpleName().toString();
+
+    MethodSpec.Builder builder = MethodSpec.methodBuilder(methodName)
+        .addAnnotation(Override.class);
+
+    Set<Modifier> modifiers = method.getModifiers();
+    modifiers = new LinkedHashSet<>(modifiers);
+    modifiers.remove(Modifier.ABSTRACT);
+    Modifier defaultModifier = null;
+    // Modifier.DEFAULT doesn't exist until Java 8.
+    try {
+      defaultModifier = Modifier.valueOf("DEFAULT");
+    } catch (IllegalArgumentException e) {
+      // Ignored.
+    }
+    modifiers.remove(defaultModifier);
+
+    builder = builder.addModifiers(modifiers);
+
+    for (TypeParameterElement typeParameterElement : method.getTypeParameters()) {
+      TypeVariable var = (TypeVariable) typeParameterElement.asType();
+      builder = builder.addTypeVariable(TypeVariableName.get(var));
+    }
+
+    builder = builder.returns(TypeName.get(method.getReturnType()))
+        .addParameters(getParameters(method))
+        .varargs(method.isVarArgs());
+
+    for (TypeMirror thrownType : method.getThrownTypes()) {
+      builder = builder.addException(TypeName.get(thrownType));
+    }
+
+    return builder;
+  }
+
+  static List<ParameterSpec> getParameters(ExecutableElement method) {
+    return getParameters(method.getParameters());
+  }
+
+  static List<ParameterSpec> getParameters(List<? extends VariableElement> parameters) {
+    List<ParameterSpec> result = new ArrayList<>();
+    for (VariableElement parameter : parameters) {
+      result.add(getParameter(parameter));
+    }
+    return result;
+  }
+
+  private static ParameterSpec getParameter(VariableElement method) {
+    TypeName type = TypeName.get(method.asType());
+    String name = method.getSimpleName().toString();
+    return ParameterSpec.builder(type, name)
+        .addModifiers(method.getModifiers())
+        .addAnnotations(getAnnotations(method))
+        .build();
+  }
+
+  private static List<AnnotationSpec> getAnnotations(VariableElement element) {
+    List<AnnotationSpec> result = new ArrayList<>();
+    for (AnnotationMirror mirror : element.getAnnotationMirrors()) {
+      result.add(AnnotationSpec.get(mirror));
+    }
+    return result;
+  }
+
+  static ClassName nonNull() {
+    return NONNULL_ANNOTATION;
+  }
+
   List<ExecutableElement> findInstanceMethodsReturning(TypeElement clazz, TypeMirror returnType) {
     return FluentIterable.from(clazz.getEnclosedElements())
         .filter(new FilterPublicMethods(returnType, MethodType.INSTANCE))
@@ -280,8 +385,11 @@ void infoLog(String toLog) {
         throw new IllegalArgumentException("Expected single value, but found: " + values);
       }
       excludedModuleAnnotationValue = values.iterator().next().getValue();
-      if (excludedModuleAnnotationValue == null) {
-        throw new NullPointerException("Failed to find Excludes#value");
+      if (excludedModuleAnnotationValue == null
+          || excludedModuleAnnotationValue instanceof Attribute.UnresolvedClass) {
+        throw new IllegalArgumentException(
+            "Failed to find value for: " + annotationClass + " from mirrors: "
+                + clazz.getAnnotationMirrors());
       }
     }
     if (excludedModuleAnnotationValue == null) {
@@ -289,11 +397,10 @@ void infoLog(String toLog) {
     }
     Object value = excludedModuleAnnotationValue.getValue();
     if (value instanceof List) {
-      List values = (List) value;
+      List<?> values = (List<?>) value;
       Set<String> result = new HashSet<>(values.size());
       for (Object current : values) {
-        Attribute.Class currentClass = (Attribute.Class) current;
-        result.add(currentClass.getValue().toString());
+        result.add(getExcludedModuleClassFromAnnotationAttribute(clazz, current));
       }
       return result;
     } else {
@@ -302,6 +409,32 @@ void infoLog(String toLog) {
     }
   }
 
+  // We should be able to cast to Attribute.Class rather than use reflection, but there are some
+  // compilers that seem to break when we do so. See #2673 for an example.
+  private static String getExcludedModuleClassFromAnnotationAttribute(
+      Element clazz, Object attribute) {
+    if (attribute.getClass().getSimpleName().equals("UnresolvedClass")) {
+      throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz
+          + ", one or more excluded Modules could not be found at compile time. Ensure that all"
+          + "excluded Modules are included in your classpath.");
+    }
+    Method[] methods = attribute.getClass().getDeclaredMethods();
+    if (methods == null || methods.length == 0) {
+      throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz
+          + ", invalid exclude: " + attribute);
+    }
+    for (Method method : methods) {
+      if (method.getName().equals("getValue")) {
+        try {
+          return method.invoke(attribute).toString();
+        } catch (IllegalAccessException | InvocationTargetException e) {
+          throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz, e);
+        }
+      }
+    }
+    throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz);
+  }
+
   private enum MethodType {
     STATIC,
     INSTANCE
@@ -312,12 +445,12 @@ void infoLog(String toLog) {
     private final TypeMirror returnType;
     private final MethodType methodType;
 
-    FilterPublicMethods(@Nullable TypeMirror returnType, MethodType methodType)  {
+    FilterPublicMethods(@Nullable TypeMirror returnType, MethodType methodType) {
       this.returnType = returnType;
       this.methodType = methodType;
     }
 
-    FilterPublicMethods(@Nullable TypeElement returnType, MethodType methodType)  {
+    FilterPublicMethods(@Nullable TypeElement returnType, MethodType methodType) {
       this(returnType != null ? returnType.asType() : null, methodType);
     }
 
@@ -335,10 +468,7 @@ public boolean apply(@Nullable Element input) {
         return false;
       }
       ExecutableElement method = (ExecutableElement) input;
-      if (returnType == null) {
-        return true;
-      }
-      return isReturnValueTypeMatching(method, returnType);
+      return returnType == null || isReturnValueTypeMatching(method, returnType);
     }
   }
 
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java
index 372d5b005..2486c8226 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.annotation.compiler;
 
+import static com.bumptech.glide.annotation.compiler.ProcessorUtil.nonNull;
+
 import com.bumptech.glide.annotation.GlideExtension;
 import com.bumptech.glide.annotation.GlideOption;
 import com.google.common.base.Function;
@@ -20,8 +22,11 @@
 import com.squareup.javapoet.TypeVariableName;
 import com.squareup.javapoet.WildcardTypeName;
 import java.io.File;
+import java.util.ArrayList;
 import java.util.Collections;
+import java.util.HashSet;
 import java.util.List;
+import java.util.Set;
 import javax.annotation.Nullable;
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.AnnotationMirror;
@@ -33,8 +38,8 @@
 import javax.lang.model.type.TypeMirror;
 
 /**
- * Generates a {@link com.bumptech.glide.RequestBuilder} subclass containing all methods from
- * the base class, all methods from {@link com.bumptech.glide.request.RequestOptions} and all
+ * Generates a {@code com.bumptech.glide.RequestBuilder} subclass containing all methods from
+ * the base class, all methods from {@code com.bumptech.glide.request.RequestOptions} and all
  * non-override {@link GlideOption} annotated methods in {@link GlideExtension} annotated
  * classes.
  *
@@ -105,6 +110,7 @@
       ImmutableSet.of("clone", "apply", "autoLock", "lock", "autoClone");
   private static final ClassName CHECK_RESULT_CLASS_NAME =
       ClassName.get("android.support.annotation", "CheckResult");
+  private static final AnnotationSpec NON_NULL = AnnotationSpec.builder(nonNull()).build();
 
   private final ProcessingEnvironment processingEnv;
   private final ProcessorUtil processorUtil;
@@ -177,8 +183,8 @@ TypeSpec generate(String generatedCodePackageName, @Nullable TypeSpec generatedO
   }
 
   /**
-   * Generates overrides of all methods in {@link com.bumptech.glide.RequestBuilder} that return
-   * {@link com.bumptech.glide.RequestBuilder} so that they return our generated subclass instead.
+   * Generates overrides of all methods in {@code com.bumptech.glide.RequestBuilder} that return
+   * {@code com.bumptech.glide.RequestBuilder} so that they return our generated subclass instead.
    */
   private List<MethodSpec> generateRequestBuilderOverrides() {
     TypeMirror rawRequestBuilderType =
@@ -194,8 +200,8 @@ public MethodSpec apply(ExecutableElement input) {
   }
 
   /**
-   * Generates an override of a particular method in {@link com.bumptech.glide.RequestBuilder} that
-   * returns {@link com.bumptech.glide.RequestBuilder} so that it returns our generated subclass
+   * Generates an override of a particular method in {@code com.bumptech.glide.RequestBuilder} that
+   * returns {@code com.bumptech.glide.RequestBuilder} so that it returns our generated subclass
    * instead.
    */
   private MethodSpec generateRequestBuilderOverride(ExecutableElement methodToOverride) {
@@ -207,7 +213,7 @@ private MethodSpec generateRequestBuilderOverride(ExecutableElement methodToOver
     ParameterizedTypeName generatedRequestBuilderOfType =
         ParameterizedTypeName.get(generatedRequestBuilderClassName, ClassName.get(typeArgument));
 
-    MethodSpec.Builder builder = MethodSpec.overriding(methodToOverride)
+    MethodSpec.Builder builder = ProcessorUtil.overriding(methodToOverride)
         .returns(generatedRequestBuilderOfType)
         .addCode(CodeBlock.builder()
             .add("return ($T) super.$N(",
@@ -224,7 +230,17 @@ public String apply(VariableElement input) {
             .build());
 
     for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {
-      builder.addAnnotation(AnnotationSpec.get(mirror));
+      builder = builder.addAnnotation(AnnotationSpec.get(mirror));
+    }
+
+    if (methodToOverride.isVarArgs()) {
+      builder = builder
+          .addModifiers(Modifier.FINAL)
+          .addAnnotation(SafeVarargs.class)
+          .addAnnotation(
+              AnnotationSpec.builder(SuppressWarnings.class)
+                  .addMember("value", "$S", "varargs")
+                  .build());
     }
 
     return builder.build();
@@ -234,7 +250,7 @@ public String apply(VariableElement input) {
    * Generates methods with equivalent names and arguments to methods annotated with
    * {@link GlideOption} in
    * {@link com.bumptech.glide.annotation.GlideExtension}s that return our generated
-   * {@link com.bumptech.glide.RequestBuilder} subclass.
+   * {@code com.bumptech.glide.RequestBuilder} subclass.
    */
   private List<MethodSpec> generateGeneratedRequestOptionsEquivalents(
       @Nullable final TypeSpec generatedOptions) {
@@ -260,10 +276,10 @@ public MethodSpec apply(MethodSpec input) {
 
   /**
    * Returns {@code true} if the given {@link MethodSpec} is a useful method to have in our
-   * {@link com.bumptech.glide.RequestBuilder} subclass.
+   * {@code com.bumptech.glide.RequestBuilder} subclass.
    *
    * <p>Only newly generated methods will be included in the generated
-   * {@link com.bumptech.glide.request.BaseRequestBuilder} subclass, so we only have to filter out
+   * {@code com.bumptech.glide.request.BaseRequestBuilder} subclass, so we only have to filter out
    * methods that override other methods to avoid duplicates.
    */
   private boolean isUsefulGeneratedRequestOption(MethodSpec requestOptionMethod) {
@@ -277,7 +293,7 @@ private boolean isUsefulGeneratedRequestOption(MethodSpec requestOptionMethod) {
 
    /**
    * Generates a particular method with  an equivalent name and arguments to the given method
-   * from the generated {@link com.bumptech.glide.request.BaseRequestBuilder} subclass.
+   * from the generated {@code com.bumptech.glide.request.BaseRequestBuilder} subclass.
    */
   private MethodSpec generateGeneratedRequestOptionEquivalent(MethodSpec requestOptionMethod) {
     CodeBlock callRequestOptionsMethod = CodeBlock.builder()
@@ -307,9 +323,8 @@ public boolean apply(AnnotationSpec input) {
                         // SafeVarargs can only be applied to final methods. GlideRequest is
                         // non-final to allow for mocking.
                         && !input.type.equals(TypeName.get(SafeVarargs.class))
-                        // @CheckResult isn't applicable for RequestBuilder because there is no
-                        // autoClone() in RequestBuilder.
-                        && !input.type.equals(CHECK_RESULT_CLASS_NAME);
+                        // We need to combine warnings below.
+                        && !input.type.equals(TypeName.get(SuppressWarnings.class));
                   }
                 })
                 .toList()
@@ -329,16 +344,52 @@ public boolean apply(AnnotationSpec input) {
         .endControlFlow()
         .addStatement("return this");
 
+    AnnotationSpec suppressWarnings = buildSuppressWarnings(requestOptionMethod);
+    if (suppressWarnings != null) {
+      result.addAnnotation(suppressWarnings);
+    }
+    return result.build();
+  }
+
+  @Nullable
+  private AnnotationSpec buildSuppressWarnings(MethodSpec requestOptionMethod) {
+    Set<String> suppressions = new HashSet<>();
+    if (requestOptionMethod.annotations.contains(
+        AnnotationSpec.builder(SuppressWarnings.class).build())) {
+      for (AnnotationSpec annotation : requestOptionMethod.annotations) {
+        if (annotation.type.equals(TypeName.get(SuppressWarnings.class))) {
+          List<CodeBlock> codeBlocks = annotation.members.get("value");
+          suppressions.addAll(FluentIterable.from(codeBlocks).transform(
+              new Function<CodeBlock, String>() {
+                @Override
+                public String apply(CodeBlock input) {
+                  return input.toString();
+                }
+              }).toSet());
+        }
+      }
+    }
+
     if (requestOptionMethod.annotations.contains(
         AnnotationSpec.builder(SafeVarargs.class).build())) {
-      result.addAnnotation(
-          AnnotationSpec.builder(SuppressWarnings.class)
-              .addMember("value", "$S", "unchecked")
-              .addMember("value", "$S", "varargs")
-              .build());
+      suppressions.add("unchecked");
+      suppressions.add("varargs");
     }
 
-    return result.build();
+    if (suppressions.isEmpty()) {
+      return null;
+    }
+    // Enforce ordering across compilers (Internal and External compilers end up disagreeing on the
+    // order produced by the Set additions above.)
+    ArrayList<String> suppressionsList = new ArrayList<>(suppressions);
+    Collections.sort(suppressionsList);
+
+    AnnotationSpec.Builder builder = AnnotationSpec.builder(SuppressWarnings.class);
+    for (String suppression : suppressionsList) {
+      builder.addMember("value", "$S", suppression);
+    }
+
+    return builder.build();
   }
 
   private List<MethodSpec> generateConstructors() {
@@ -351,25 +402,46 @@ public boolean apply(AnnotationSpec input) {
 
     MethodSpec firstConstructor =
         MethodSpec.constructorBuilder()
-            .addParameter(classOfTranscodeType, "transcodeClass")
-            .addParameter(requestBuilderOfWildcardOfObject, "other")
+            .addParameter(ParameterSpec.builder(classOfTranscodeType, "transcodeClass")
+                .addAnnotation(nonNull())
+                .build()
+            )
+            .addParameter(ParameterSpec.builder(requestBuilderOfWildcardOfObject, "other")
+                .addAnnotation(nonNull())
+                .build()
+            )
         .addStatement("super($N, $N)", "transcodeClass", "other")
         .build();
 
+    ClassName context = ClassName.get("android.content", "Context");
     ClassName glide = ClassName.get("com.bumptech.glide", "Glide");
     ClassName requestManager = ClassName.get("com.bumptech.glide", "RequestManager");
     MethodSpec secondConstructor =
         MethodSpec.constructorBuilder()
-            .addParameter(glide, "glide")
-            .addParameter(requestManager, "requestManager")
-            .addParameter(classOfTranscodeType, "transcodeClass")
-            .addStatement("super($N, $N ,$N)", "glide", "requestManager", "transcodeClass")
+            .addParameter(ParameterSpec.builder(glide, "glide")
+                .addAnnotation(nonNull())
+                .build()
+            )
+            .addParameter(ParameterSpec.builder(requestManager, "requestManager")
+                .addAnnotation(nonNull())
+                .build()
+            )
+            .addParameter(ParameterSpec.builder(classOfTranscodeType, "transcodeClass")
+                .addAnnotation(nonNull())
+                .build()
+            )
+            .addParameter(ParameterSpec.builder(context, "context")
+                .addAnnotation(nonNull())
+                .build()
+            )
+            .addStatement(
+                "super($N, $N ,$N, $N)", "glide", "requestManager", "transcodeClass", "context")
             .build();
     return ImmutableList.of(firstConstructor, secondConstructor);
   }
 
   /**
-   * Overrides the protected downloadOnly method in {@link com.bumptech.glide.RequestBuilder} to
+   * Overrides the protected downloadOnly method in {@code com.bumptech.glide.RequestBuilder} to
    * return our generated subclass instead.
    */
   private MethodSpec generateDownloadOnlyRequestMethod() {
@@ -378,6 +450,7 @@ private MethodSpec generateDownloadOnlyRequestMethod() {
     return MethodSpec.methodBuilder("getDownloadOnlyRequest")
         .addAnnotation(Override.class)
         .addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build())
+        .addAnnotation(NON_NULL)
         .returns(generatedRequestBuilderOfFile)
         .addModifiers(Modifier.PROTECTED)
         .addStatement("return new $T<>($T.class, $N).apply($N)",
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerFactoryGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerFactoryGenerator.java
index a86bb1a37..4aec3c8bb 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerFactoryGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerFactoryGenerator.java
@@ -1,7 +1,10 @@
 package com.bumptech.glide.annotation.compiler;
 
+import static com.bumptech.glide.annotation.compiler.ProcessorUtil.nonNull;
+
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
 import com.squareup.javapoet.TypeSpec;
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.Modifier;
@@ -10,10 +13,10 @@
 
 /**
  * Generates an implementation of
- * {@link com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory} that returns a
- * generated {@link com.bumptech.glide.RequestManager} implementation.
+ * {@code com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory} that returns a
+ * generated {@code com.bumptech.glide.RequestManager} implementation.
  *
- * <p>Generated {@link com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory}
+ * <p>Generated {@code com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory}
  * classes look like this:
  * <pre>
  * <code>
@@ -39,6 +42,8 @@
       "com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory";
   private static final String REQUEST_MANAGER_QUALIFIED_NAME =
       "com.bumptech.glide.RequestManager";
+  private static final ClassName CONTEXT_CLASS_NAME =
+      ClassName.get("android.content", "Context");
 
   static final String GENERATED_REQUEST_MANAGER_FACTORY_PACKAGE_NAME =
       "com.bumptech.glide";
@@ -75,12 +80,27 @@ TypeSpec generate(String generatedCodePackageName, TypeSpec generatedRequestMana
             MethodSpec.methodBuilder("build")
                 .addModifiers(Modifier.PUBLIC)
                 .addAnnotation(Override.class)
+                .addAnnotation(nonNull())
                 .returns(requestManagerClassName)
-                .addParameter(ClassName.get(glideType), "glide")
-                .addParameter(ClassName.get(lifecycleType), "lifecycle")
-                .addParameter(ClassName.get(requestManagerTreeNodeType), "treeNode")
+                .addParameter(ParameterSpec.builder(ClassName.get(glideType), "glide")
+                    .addAnnotation(nonNull())
+                    .build()
+                )
+                .addParameter(ParameterSpec.builder(ClassName.get(lifecycleType), "lifecycle")
+                    .addAnnotation(nonNull())
+                    .build()
+                )
+                .addParameter(
+                    ParameterSpec.builder(ClassName.get(requestManagerTreeNodeType), "treeNode")
+                        .addAnnotation(nonNull())
+                        .build()
+                )
+                .addParameter(ParameterSpec.builder(CONTEXT_CLASS_NAME, "context")
+                    .addAnnotation(nonNull())
+                    .build()
+                )
                 .addStatement(
-                    "return new $T(glide, lifecycle, treeNode)",
+                    "return new $T(glide, lifecycle, treeNode, context)",
                     ClassName.get(generatedCodePackageName, generatedRequestManagerSpec.name))
                 .build()
         )
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java
index 1c20fe858..31e646ddc 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java
@@ -1,16 +1,16 @@
 package com.bumptech.glide.annotation.compiler;
 
+import static com.bumptech.glide.annotation.compiler.ProcessorUtil.nonNull;
+
 import com.bumptech.glide.annotation.GlideExtension;
 import com.bumptech.glide.annotation.GlideType;
 import com.google.common.base.Function;
-import com.google.common.base.Joiner;
 import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.Lists;
 import com.squareup.javapoet.AnnotationSpec;
 import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.ParameterSpec;
 import com.squareup.javapoet.ParameterizedTypeName;
@@ -21,19 +21,20 @@
 import java.util.Set;
 import javax.annotation.Nullable;
 import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 
 /**
- * Generates an implementation of {@link com.bumptech.glide.RequestManager} that contains generated
+ * Generates an implementation of {@code com.bumptech.glide.RequestManager} that contains generated
  * methods from {@link GlideExtension}s and {@link GlideType}.
  *
- * <p>Generated {@link com.bumptech.glide.RequestManager} implementations look like this:
+ * <p>Generated {@code com.bumptech.glide.RequestManager} implementations look like this:
  * <pre>
  * <code>
  * public final class GeneratedRequestManager extends RequestManager {
@@ -59,6 +60,10 @@
       "com.bumptech.glide.manager.Lifecycle";
   private static final String REQUEST_MANAGER_TREE_NODE_QUALIFIED_NAME =
       "com.bumptech.glide.manager.RequestManagerTreeNode";
+  private static final ClassName CHECK_RESULT_CLASS_NAME =
+      ClassName.get("android.support.annotation", "CheckResult");
+  private static final ClassName CONTEXT_CLASS_NAME =
+      ClassName.get("android.content", "Context");
 
   private static final String GENERATED_REQUEST_MANAGER_SIMPLE_NAME =
       "GlideRequests";
@@ -92,42 +97,55 @@
     glideType = elementUtils.getTypeElement(GLIDE_QUALIFIED_NAME);
   }
 
-  @Nullable
   TypeSpec generate(
       String generatedCodePackageName, @Nullable TypeSpec requestOptions, TypeSpec requestBuilder,
       Set<String> glideExtensions) {
     generatedRequestBuilderClassName = ClassName.get(generatedCodePackageName, requestBuilder.name);
     return TypeSpec.classBuilder(GENERATED_REQUEST_MANAGER_SIMPLE_NAME)
-         .superclass(requestManagerClassName)
-         .addJavadoc("Includes all additions from methods in {@link $T}s\n"
-                 + "annotated with {@link $T}\n"
-                 + "\n"
-                 + "<p>Generated code, do not modify\n",
-             GlideExtension.class, GlideType.class)
+        .superclass(requestManagerClassName)
+        .addJavadoc("Includes all additions from methods in {@link $T}s\n"
+                + "annotated with {@link $T}\n"
+                + "\n"
+                + "<p>Generated code, do not modify\n",
+            GlideExtension.class, GlideType.class)
         .addAnnotation(
             AnnotationSpec.builder(SuppressWarnings.class)
                 .addMember("value", "$S", "deprecation")
                 .build())
-         .addModifiers(Modifier.PUBLIC)
-         .addMethod(generateAsMethod(generatedCodePackageName, requestBuilder))
-         .addMethod(generateCallSuperConstructor())
-         .addMethods(generateAdditionalRequestManagerMethods(glideExtensions))
-         .addMethods(generateRequestManagerMethodOverrides())
-         .addMethods(
-             FluentIterable.from(
-                 Collections.singletonList(
-                     generateOverrideSetRequestOptions(generatedCodePackageName, requestOptions)))
-                 .filter(Predicates.<MethodSpec>notNull()))
-         .build();
+        .addModifiers(Modifier.PUBLIC)
+        .addMethod(generateAsMethod(generatedCodePackageName, requestBuilder))
+        .addMethod(generateCallSuperConstructor())
+        .addMethods(generateExtensionRequestManagerMethods(glideExtensions))
+        .addMethods(generateRequestManagerRequestManagerMethodOverrides(generatedCodePackageName))
+        .addMethods(generateRequestManagerRequestBuilderMethodOverrides())
+        .addMethods(
+            FluentIterable.from(
+                Collections.singletonList(
+                    generateOverrideSetRequestOptions(generatedCodePackageName, requestOptions)))
+                .filter(Predicates.<MethodSpec>notNull()))
+        .build();
   }
 
   private MethodSpec generateCallSuperConstructor() {
     return MethodSpec.constructorBuilder()
         .addModifiers(Modifier.PUBLIC)
-        .addParameter(ClassName.get(glideType), "glide")
-        .addParameter(ClassName.get(lifecycleType), "lifecycle")
-        .addParameter(ClassName.get(requestManagerTreeNodeType), "treeNode")
-        .addStatement("super(glide, lifecycle, treeNode)")
+        .addParameter(ParameterSpec.builder(ClassName.get(glideType), "glide")
+            .addAnnotation(nonNull())
+            .build()
+        )
+        .addParameter(ParameterSpec.builder(ClassName.get(lifecycleType), "lifecycle")
+            .addAnnotation(nonNull())
+            .build()
+        )
+        .addParameter(ParameterSpec.builder(ClassName.get(requestManagerTreeNodeType), "treeNode")
+            .addAnnotation(nonNull())
+            .build()
+        )
+        .addParameter(ParameterSpec.builder(CONTEXT_CLASS_NAME, "context")
+            .addAnnotation(nonNull())
+            .build()
+        )
+        .addStatement("super(glide, lifecycle, treeNode, context)")
         .build();
   }
 
@@ -145,25 +163,50 @@ private MethodSpec generateAsMethod(String generatedCodePackageName, TypeSpec re
     return MethodSpec.methodBuilder("as")
         .addModifiers(Modifier.PUBLIC)
         .addAnnotation(Override.class)
+        .addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build())
+        .addAnnotation(nonNull())
         .addTypeVariable(TypeVariableName.get("ResourceType"))
-        .addParameter(classOfResouceType, "resourceClass")
         .returns(requestBuilderOfResourceType)
-        .addStatement("return new $T<>(glide, this, resourceClass)",
+        .addParameter(classOfResouceType.annotated(AnnotationSpec.builder(nonNull()).build()),
+            "resourceClass")
+        .addStatement("return new $T<>(glide, this, resourceClass, context)",
             this.generatedRequestBuilderClassName)
         .build();
   }
 
-  private List<MethodSpec> generateRequestManagerMethodOverrides() {
+  /** Generates the list of overrides of methods that return {@code RequestManager}. */
+  private List<MethodSpec> generateRequestManagerRequestManagerMethodOverrides(
+      final String generatedPackageName) {
+    return FluentIterable.from(
+        processorUtil.findInstanceMethodsReturning(requestManagerType, requestManagerType))
+        .transform(new Function<ExecutableElement, MethodSpec>() {
+          @Override
+          public MethodSpec apply(@Nullable ExecutableElement input) {
+            return generateRequestManagerRequestManagerMethodOverride(generatedPackageName, input);
+          }
+        })
+        .toList();
+  }
+
+  private MethodSpec generateRequestManagerRequestManagerMethodOverride(
+      String generatedPackageName, ExecutableElement method) {
+    ClassName generatedRequestManagerName =
+        ClassName.get(generatedPackageName, GENERATED_REQUEST_MANAGER_SIMPLE_NAME);
+    return ProcessorUtil.overriding(method)
+        .addAnnotation(nonNull())
+        .returns(generatedRequestManagerName)
+        .addCode(ProcessorUtil.generateCastingSuperCall(generatedRequestManagerName, method))
+        .build();
+  }
+
+  /** Generates the list of overrides of methods that return {@code RequestBuilder}. */
+  private List<MethodSpec> generateRequestManagerRequestBuilderMethodOverrides() {
     // Without the erasure, this is a RequestBuilder<Y>. A RequestBuilder<X> is not assignable to a
     // RequestBuilder<Y>. After type erasure this is a RequestBuilder. A RequestBuilder<X> is
     // assignable to the raw RequestBuilder.
     TypeMirror rawRequestBuilder = processingEnv.getTypeUtils()
         .erasure(requestBuilderType.asType());
 
-    final TypeElement classType =
-        processingEnv.getElementUtils().getTypeElement(Class.class.getCanonicalName());
-    final TypeMirror rawClassType = processingEnv.getTypeUtils().erasure(classType.asType());
-
     return FluentIterable.from(
         processorUtil.findInstanceMethodsReturning(requestManagerType, rawRequestBuilder))
         .filter(new Predicate<ExecutableElement>() {
@@ -176,7 +219,7 @@ public boolean apply(ExecutableElement input) {
         .transform(new Function<ExecutableElement, MethodSpec>() {
           @Override
           public MethodSpec apply(ExecutableElement input) {
-            return generateRequestManagerMethodOverride(input);
+            return generateRequestManagerRequestBuilderMethodOverride(input);
           }
         })
         .toList();
@@ -186,8 +229,9 @@ public MethodSpec apply(ExecutableElement input) {
    * Generates overrides of existing RequestManager methods so that they return our generated
    * RequestBuilder subtype.
    */
-  private MethodSpec generateRequestManagerMethodOverride(ExecutableElement methodToOverride) {
-     // We've already verified that this method returns a RequestBuilder and RequestBuilders have
+  private MethodSpec generateRequestManagerRequestBuilderMethodOverride(
+      ExecutableElement methodToOverride) {
+    // We've already verified that this method returns a RequestBuilder and RequestBuilders have
     // exactly one type argument, so this is safe unless those assumptions change.
     TypeMirror typeArgument =
         ((DeclaredType) methodToOverride.getReturnType()).getTypeArguments().get(0);
@@ -195,25 +239,19 @@ private MethodSpec generateRequestManagerMethodOverride(ExecutableElement method
     ParameterizedTypeName generatedRequestBuilderOfType =
         ParameterizedTypeName.get(generatedRequestBuilderClassName, ClassName.get(typeArgument));
 
-    return MethodSpec.overriding(methodToOverride)
+    MethodSpec.Builder builder = ProcessorUtil.overriding(methodToOverride)
         .returns(generatedRequestBuilderOfType)
-        .addCode(CodeBlock.builder()
-            .add("return ($T) super.$N(",
-                generatedRequestBuilderOfType, methodToOverride.getSimpleName())
-            .add(FluentIterable.from(methodToOverride.getParameters())
-                .transform(new Function<VariableElement, String>() {
-                  @Override
-                  public String apply(VariableElement input) {
-                    return input.getSimpleName().toString();
-                  }
-                })
-                .join(Joiner.on(", ")))
-            .add(");\n")
-            .build())
-        .build();
+        .addCode(
+            ProcessorUtil.generateCastingSuperCall(
+                generatedRequestBuilderOfType, methodToOverride));
+
+    for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {
+      builder.addAnnotation(AnnotationSpec.get(mirror));
+    }
+    return builder.build();
   }
 
-  private List<MethodSpec> generateAdditionalRequestManagerMethods(
+  private List<MethodSpec> generateExtensionRequestManagerMethods(
       Set<String> glideExtensions) {
     List<ExecutableElement> requestManagerExtensionMethods =
         processorUtil.findAnnotatedElementsInClasses(glideExtensions, GlideType.class);
@@ -229,6 +267,15 @@ public MethodSpec apply(ExecutableElement input) {
 
   // Generates methods added to RequestManager via GlideExtensions.
   private MethodSpec generateAdditionalRequestManagerMethod(ExecutableElement extensionMethod) {
+    if (extensionMethod.getReturnType().getKind() == TypeKind.VOID) {
+      return generateAdditionalRequestManagerMethodLegacy(extensionMethod);
+    } else {
+      return generateAdditionalRequestManagerMethodNew(extensionMethod);
+    }
+  }
+
+  private MethodSpec generateAdditionalRequestManagerMethodLegacy(
+      ExecutableElement extensionMethod) {
     String returnType = processorUtil.findClassValuesFromAnnotationOnClassAsNames(extensionMethod,
         GlideType.class).iterator().next();
     ClassName returnTypeClassName = ClassName.bestGuess(returnType);
@@ -239,6 +286,8 @@ private MethodSpec generateAdditionalRequestManagerMethod(ExecutableElement exte
         .addModifiers(Modifier.PUBLIC)
         .returns(parameterizedTypeName)
         .addJavadoc(processorUtil.generateSeeMethodJavadoc(extensionMethod))
+        .addAnnotation(nonNull())
+        .addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build())
         .addStatement(
             "$T requestBuilder = this.as($T.class)", parameterizedTypeName, returnTypeClassName)
         .addStatement("$T.$N(requestBuilder)",
@@ -247,8 +296,31 @@ private MethodSpec generateAdditionalRequestManagerMethod(ExecutableElement exte
         .build();
   }
 
+  private MethodSpec generateAdditionalRequestManagerMethodNew(
+      ExecutableElement extensionMethod) {
+    String returnType = processorUtil.findClassValuesFromAnnotationOnClassAsNames(extensionMethod,
+        GlideType.class).iterator().next();
+    ClassName returnTypeClassName = ClassName.bestGuess(returnType);
+    ParameterizedTypeName parameterizedTypeName =
+        ParameterizedTypeName.get(generatedRequestBuilderClassName, returnTypeClassName);
+
+    return MethodSpec.methodBuilder(extensionMethod.getSimpleName().toString())
+        .addModifiers(Modifier.PUBLIC)
+        .returns(parameterizedTypeName)
+        .addJavadoc(processorUtil.generateSeeMethodJavadoc(extensionMethod))
+        .addAnnotation(nonNull())
+        .addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build())
+        .addStatement(
+            "return ($T) $T.$N(this.as($T.class))",
+            parameterizedTypeName,
+            extensionMethod.getEnclosingElement(),
+            extensionMethod.getSimpleName(),
+            returnTypeClassName)
+        .build();
+  }
+
   /**
-   * The {@link com.bumptech.glide.request.RequestOptions} subclass should always be our
+   * The {@code RequestOptions} subclass should always be our
    * generated subclass type to avoid inadvertent errors where a different subclass is applied that
    * accidentally wipes out some logic in overidden methods in our generated subclass.
    */
@@ -261,10 +333,8 @@ private MethodSpec generateOverrideSetRequestOptions(
 
     Elements elementUtils = processingEnv.getElementUtils();
     TypeElement requestOptionsType =
-            elementUtils.getTypeElement(
-                RequestOptionsGenerator.REQUEST_OPTIONS_QUALIFIED_NAME);
-    TypeElement androidNonNullType =
-            elementUtils.getTypeElement("android.support.annotation.NonNull");
+        elementUtils.getTypeElement(
+            RequestOptionsGenerator.REQUEST_OPTIONS_QUALIFIED_NAME);
 
     // This class may have just been generated and therefore may not be found if we try to obtain
     // it via Elements, so use just the String version instead.
@@ -279,7 +349,7 @@ private MethodSpec generateOverrideSetRequestOptions(
         .addModifiers(Modifier.PROTECTED)
         .addParameter(
             ParameterSpec.builder(ClassName.get(requestOptionsType), parameterName)
-                .addAnnotation(ClassName.get(androidNonNullType))
+                .addAnnotation(nonNull())
                 .build())
         .beginControlFlow("if ($N instanceof $L)",
             parameterName, generatedRequestOptionsQualifiedName)
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java
index 209b7715b..852ebc5c0 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java
@@ -1,13 +1,14 @@
 package com.bumptech.glide.annotation.compiler;
 
 import static com.bumptech.glide.annotation.GlideOption.OVERRIDE_EXTEND;
-import static com.bumptech.glide.annotation.GlideOption.OVERRIDE_NONE;
+import static com.bumptech.glide.annotation.compiler.ProcessorUtil.nonNull;
 
 import com.bumptech.glide.annotation.GlideExtension;
 import com.bumptech.glide.annotation.GlideOption;
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
 import com.google.common.base.Objects;
+import com.google.common.base.Preconditions;
 import com.google.common.base.Strings;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
@@ -30,15 +31,15 @@
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.TypeParameterElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeKind;
 
 /**
- * Generates a new implementation of {@link com.bumptech.glide.request.RequestOptions}
+ * Generates a new implementation of {@code com.bumptech.glide.request.RequestOptions}
  * containing static versions of methods included in the base class and static and instance versions
  * of all methods annotated with {@link GlideOption} in classes annotated with
  * {@link GlideExtension}.
@@ -194,7 +195,7 @@ public MethodSpec apply(ExecutableElement input) {
   }
 
   private MethodSpec generateRequestOptionOverride(ExecutableElement methodToOverride) {
-    MethodSpec.Builder result = MethodSpec.overriding(methodToOverride)
+    MethodSpec.Builder result = ProcessorUtil.overriding(methodToOverride)
         .returns(glideOptionsName)
         .addModifiers(Modifier.FINAL)
         .addCode(CodeBlock.builder()
@@ -211,9 +212,12 @@ public String apply(VariableElement input) {
             .build());
 
     if (methodToOverride.getSimpleName().toString().equals("transforms")) {
-      result.addAnnotation(
-          AnnotationSpec.builder(SafeVarargs.class)
-              .build());
+      result
+          .addAnnotation(SafeVarargs.class)
+          .addAnnotation(
+              AnnotationSpec.builder(SuppressWarnings.class)
+                  .addMember("value", "$S", "varargs")
+                  .build());
     }
 
     for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {
@@ -225,39 +229,118 @@ public String apply(VariableElement input) {
 
   private List<MethodAndStaticVar> generateMethodsForRequestOptionsExtension(
       ExecutableElement element) {
-    boolean isOverridingRequestOptionsMethod = isMethodInRequestOptions(element);
-    int overrideType = getOverrideType(element);
-    if (isOverridingRequestOptionsMethod && overrideType == OVERRIDE_NONE) {
-      throw new IllegalArgumentException("Accidentally attempting to override a method in"
-          + " RequestOptions. Add an 'override' value in the @GlideOption annotation"
-          + " if this is intentional. Offending method: "
-          + element.getEnclosingElement() + "#" + element);
-    } else if (!isOverridingRequestOptionsMethod && overrideType != OVERRIDE_NONE) {
-      throw new IllegalArgumentException("Requested to override an existing method in"
-          + " RequestOptions, but no such method was found. Offending method: "
-          + element.getEnclosingElement() + "#" + element);
+    if (element.getReturnType().getKind() == TypeKind.VOID) {
+      processorUtil.warnLog(
+          "The " + element.getSimpleName() + " method annotated with @GlideOption in the "
+              + element.getEnclosingElement().getSimpleName() + " @GlideExtension is using a legacy"
+              + " format. Support will be removed in a future version. Please change your method"
+              + " definition so that your @GlideModule annotated methods return RequestOptions"
+              + " objects instead of null.");
+      return generateMethodsForRequestOptionsExtensionDeprecated(element);
+    } else {
+      return generateMethodsForRequestOptionsExtensionNew(element);
+    }
+  }
+
+  private List<MethodAndStaticVar> generateMethodsForRequestOptionsExtensionNew(
+      ExecutableElement element) {
+    int overrideType = processorUtil.getOverrideType(element);
+
+    String methodName = element.getSimpleName().toString();
+    MethodSpec.Builder builder = MethodSpec.methodBuilder(methodName)
+        .addModifiers(Modifier.PUBLIC)
+        .addJavadoc(processorUtil.generateSeeMethodJavadoc(element))
+        .varargs(element.isVarArgs())
+        .returns(glideOptionsName);
+
+    // The 0th element is expected to be a RequestOptions object.
+    List<? extends VariableElement> parameters =
+        element.getParameters().subList(1, element.getParameters().size());
+    builder.addParameters(ProcessorUtil.getParameters(parameters));
+
+    String extensionRequestOptionsArgument;
+    if (overrideType == OVERRIDE_EXTEND) {
+      builder
+          .addJavadoc(
+              processorUtil.generateSeeMethodJavadoc(requestOptionsName, methodName, parameters))
+          .addAnnotation(Override.class);
+
+      List<Object> methodArgs = new ArrayList<>();
+      methodArgs.add(element.getSimpleName().toString());
+      StringBuilder methodLiterals = new StringBuilder();
+      if (!parameters.isEmpty()) {
+        for (VariableElement variable : parameters) {
+          methodLiterals.append("$L, ");
+          methodArgs.add(variable.getSimpleName().toString());
+        }
+        methodLiterals = new StringBuilder(
+            methodLiterals.substring(0, methodLiterals.length() - 2));
+      }
+      extensionRequestOptionsArgument = CodeBlock.builder()
+          .add("super.$N(" + methodLiterals + ")", methodArgs.toArray(new Object[0]))
+          .build()
+          .toString();
+    } else {
+      extensionRequestOptionsArgument = "this";
+    }
+
+    List<Object> args = new ArrayList<>();
+    StringBuilder code = new StringBuilder("return ($T) $T.$L($L, ");
+    args.add(glideOptionsName);
+    args.add(ClassName.get(element.getEnclosingElement().asType()));
+    args.add(element.getSimpleName().toString());
+    args.add(extensionRequestOptionsArgument);
+    if (!parameters.isEmpty()) {
+      for (VariableElement variable : parameters) {
+        code.append("$L, ");
+        args.add(variable.getSimpleName().toString());
+      }
     }
+    code = new StringBuilder(code.substring(0, code.length() - 2));
+    code.append(")");
+    builder.addStatement(code.toString(), args.toArray(new Object[0]));
+
+    builder
+        .addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build())
+        .addAnnotation(nonNull());
+
+    List<MethodAndStaticVar> result = new ArrayList<>();
+    result.add(new MethodAndStaticVar(builder.build()));
+    MethodAndStaticVar methodAndVar = generateStaticMethodEquivalentForExtensionMethod(element);
+    if (methodAndVar != null) {
+      result.add(methodAndVar);
+    }
+
+    return result;
+  }
+
+  private List<MethodAndStaticVar> generateMethodsForRequestOptionsExtensionDeprecated(
+      ExecutableElement element) {
+    int overrideType = processorUtil.getOverrideType(element);
+
     String methodName = element.getSimpleName().toString();
     MethodSpec.Builder builder = MethodSpec.methodBuilder(methodName)
         .addModifiers(Modifier.PUBLIC)
         .addJavadoc(processorUtil.generateSeeMethodJavadoc(element))
+        .varargs(element.isVarArgs())
         .returns(glideOptionsName);
 
     // The 0th element is expected to be a RequestOptions object.
     List<? extends VariableElement> parameters =
         element.getParameters().subList(1, element.getParameters().size());
+    builder.addParameters(ProcessorUtil.getParameters(parameters));
 
     // Generates the String and list of arguments to pass in when calling this method or super.
     // IE centerCrop(context) creates methodLiterals="%L" and methodArgs=[centerCrop, context].
     List<Object> methodArgs = new ArrayList<>();
     methodArgs.add(element.getSimpleName().toString());
-    String methodLiterals = "";
+    StringBuilder methodLiterals = new StringBuilder();
     if (!parameters.isEmpty()) {
       for (VariableElement variable : parameters) {
-        methodLiterals += "$L, ";
+        methodLiterals.append("$L, ");
         methodArgs.add(variable.getSimpleName().toString());
       }
-      methodLiterals = methodLiterals.substring(0, methodLiterals.length() - 2);
+      methodLiterals = new StringBuilder(methodLiterals.substring(0, methodLiterals.length() - 2));
     }
 
     builder.beginControlFlow("if (isAutoCloneEnabled())")
@@ -274,34 +357,32 @@ public String apply(VariableElement input) {
           .addAnnotation(Override.class);
     }
 
-    for (VariableElement variable : parameters) {
-      builder.addParameter(getParameterSpec(variable));
-    }
-
     // Adds: <AnnotatedClass>.<thisMethodName>(RequestOptions<?>, <arg1>, <arg2>, <argN>);
     List<Object> args = new ArrayList<>();
-    String code = "$T.$L($L, ";
+    StringBuilder code = new StringBuilder("$T.$L($L, ");
     args.add(ClassName.get(element.getEnclosingElement().asType()));
     args.add(element.getSimpleName().toString());
     args.add("this");
     if (!parameters.isEmpty()) {
       for (VariableElement variable : parameters) {
-        code += "$L, ";
+        code.append("$L, ");
         args.add(variable.getSimpleName().toString());
       }
     }
-    code = code.substring(0, code.length() - 2);
-    code += ")";
-    builder.addStatement(code, args.toArray(new Object[0]));
+    code = new StringBuilder(code.substring(0, code.length() - 2));
+    code.append(")");
+    builder.addStatement(code.toString(), args.toArray(new Object[0]));
 
-    builder.addStatement("return this");
+    builder.addStatement("return this")
+        .addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build())
+        .addAnnotation(nonNull());
 
     List<MethodAndStaticVar> result = new ArrayList<>();
-
-    builder.addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build());
-
     result.add(new MethodAndStaticVar(builder.build()));
-    result.add(generateStaticMethodEquivalentForExtensionMethod(element));
+    MethodAndStaticVar methodAndVar = generateStaticMethodEquivalentForExtensionMethod(element);
+    if (methodAndVar != null) {
+      result.add(methodAndVar);
+    }
 
     return result;
   }
@@ -327,7 +408,7 @@ public String apply(VariableElement input) {
    * an existing method in RequestOptions.
    *
    * <p>The string names here just map between the static methods in
-   * {@link com.bumptech.glide.request.RequestOptions} and the instance methods they call.
+   * {@code com.bumptech.glide.request.RequestOptions} and the instance methods they call.
    */
   private static String getInstanceMethodNameFromStaticMethodName(String staticMethodName) {
     String equivalentInstanceMethodName;
@@ -362,25 +443,12 @@ private MethodAndStaticVar generateStaticMethodEquivalentForRequestOptionsStatic
     MethodSpec.Builder methodSpecBuilder =
         MethodSpec.methodBuilder(staticMethodName)
             .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
-        .addJavadoc(processorUtil.generateSeeMethodJavadoc(staticMethod))
-        .returns(glideOptionsName);
+            .addJavadoc(processorUtil.generateSeeMethodJavadoc(staticMethod))
+            .returns(glideOptionsName);
 
     List<? extends VariableElement> parameters = staticMethod.getParameters();
-    String createNewOptionAndCall = "new $T().$N(";
-    if (!parameters.isEmpty()) {
-      for (VariableElement parameter : parameters) {
-        methodSpecBuilder.addParameter(getParameterSpec(parameter));
-        createNewOptionAndCall += parameter.getSimpleName().toString();
-        // use the Application Context to avoid memory leaks.
-        if (memoize && isAndroidContext(parameter)) {
-          createNewOptionAndCall += ".getApplicationContext()";
-        }
-        createNewOptionAndCall += ", ";
-      }
-      createNewOptionAndCall =
-          createNewOptionAndCall.substring(0, createNewOptionAndCall.length() - 2);
-    }
-    createNewOptionAndCall += ")";
+    StringBuilder createNewOptionAndCall = createNewOptionAndCall(memoize, methodSpecBuilder,
+        parameters, "new $T().$N(", ProcessorUtil.getParameters(staticMethod));
 
     FieldSpec requiredStaticField = null;
     if (memoize) {
@@ -414,7 +482,9 @@ private MethodAndStaticVar generateStaticMethodEquivalentForRequestOptionsStatic
           TypeVariableName.get(typeParameterElement.getSimpleName().toString()));
     }
 
-    methodSpecBuilder.addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build());
+    methodSpecBuilder
+        .addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build())
+        .addAnnotation(nonNull());
 
     return new MethodAndStaticVar(methodSpecBuilder.build(), requiredStaticField);
   }
@@ -426,11 +496,12 @@ private static boolean memoizeStaticMethodFromArguments(ExecutableElement static
         .equals("android.content.Context"));
   }
 
+  @Nullable
   private MethodAndStaticVar generateStaticMethodEquivalentForExtensionMethod(
       ExecutableElement instanceMethod) {
     boolean skipStaticMethod = skipStaticMethod(instanceMethod);
     if (skipStaticMethod) {
-      return new MethodAndStaticVar();
+      return null;
     }
     String staticMethodName = getStaticMethodName(instanceMethod);
     String instanceMethodName = instanceMethod.getSimpleName().toString();
@@ -443,9 +514,12 @@ private MethodAndStaticVar generateStaticMethodEquivalentForExtensionMethod(
     }
     boolean memoize = memoizeStaticMethodFromAnnotation(instanceMethod);
 
+    //noinspection ResultOfMethodCallIgnored
+    Preconditions.checkNotNull(staticMethodName);
     MethodSpec.Builder methodSpecBuilder = MethodSpec.methodBuilder(staticMethodName)
         .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
         .addJavadoc(processorUtil.generateSeeMethodJavadoc(instanceMethod))
+        .varargs(instanceMethod.isVarArgs())
         .returns(glideOptionsName);
 
     List<? extends VariableElement> parameters = instanceMethod.getParameters();
@@ -460,24 +534,12 @@ private MethodAndStaticVar generateStaticMethodEquivalentForExtensionMethod(
     // Remove is not supported.
     parameters = parameters.subList(1, parameters.size());
 
-    String createNewOptionAndCall = "new $T().$L(";
-    if (!parameters.isEmpty()) {
-      for (VariableElement parameter : parameters) {
-        methodSpecBuilder.addParameter(getParameterSpec(parameter));
-        createNewOptionAndCall += parameter.getSimpleName().toString();
-        // use the Application Context to avoid memory leaks.
-        if (memoize && isAndroidContext(parameter)) {
-          createNewOptionAndCall += ".getApplicationContext()";
-        }
-        createNewOptionAndCall += ", ";
-      }
-      createNewOptionAndCall =
-          createNewOptionAndCall.substring(0, createNewOptionAndCall.length() - 2);
-    }
-    createNewOptionAndCall += ")";
+    StringBuilder createNewOptionAndCall = createNewOptionAndCall(memoize, methodSpecBuilder,
+        parameters, "new $T().$L(", ProcessorUtil.getParameters(parameters));
 
     FieldSpec requiredStaticField = null;
     if (memoize) {
+      // Generates code that looks like:
       // if (GlideOptions.<methodName> == null) {
       //   GlideOptions.<methodName> = new GlideOptions().<methodName>().autoClone()
       // }
@@ -495,6 +557,7 @@ private MethodAndStaticVar generateStaticMethodEquivalentForExtensionMethod(
           .endControlFlow()
           .addStatement("return $T.$N", glideOptionsName, staticVariableName);
     } else {
+      // Generates code that looks like:
       // return new GlideOptions().<methodName>()
       methodSpecBuilder.addStatement(
           "return " + createNewOptionAndCall, glideOptionsName, instanceMethodName);
@@ -511,55 +574,30 @@ private MethodAndStaticVar generateStaticMethodEquivalentForExtensionMethod(
     return new MethodAndStaticVar(methodSpecBuilder.build(), requiredStaticField);
   }
 
-  private boolean isAndroidContext(VariableElement variableElement) {
-    Element element = processingEnvironment.getTypeUtils().asElement(variableElement.asType());
-    return element.toString().equals("android.content.Context");
-  }
-
-  private boolean isMethodInRequestOptions(ExecutableElement toFind) {
-    // toFind is a method in a GlideExtension whose first argument is a BaseRequestOptions<?> type.
-    // Since we're comparing against methods in BaseRequestOptions itself, we need to drop that
-    // first type.
-    List<String> toFindParameterNames = getComparableParameterNames(toFind, true /*skipFirst*/);
-    String toFindSimpleName = toFind.getSimpleName().toString();
-    for (Element element : requestOptionsType.getEnclosedElements()) {
-      if (element.getKind() != ElementKind.METHOD) {
-        continue;
-      }
-      ExecutableElement inBase = (ExecutableElement) element;
-      if (toFindSimpleName.equals(inBase.getSimpleName().toString())) {
-        List<String> parameterNamesInBase =
-            getComparableParameterNames(inBase, false /*skipFirst*/);
-        if (parameterNamesInBase.equals(toFindParameterNames)) {
-          return true;
+  private StringBuilder createNewOptionAndCall(boolean memoize,
+      MethodSpec.Builder methodSpecBuilder,
+      List<? extends VariableElement> parameters, String start, List<ParameterSpec> specs) {
+    StringBuilder createNewOptionAndCall = new StringBuilder(start);
+    if (!parameters.isEmpty()) {
+      methodSpecBuilder.addParameters(specs);
+      for (VariableElement parameter : parameters) {
+        createNewOptionAndCall.append(parameter.getSimpleName().toString());
+        // use the Application Context to avoid memory leaks.
+        if (memoize && isAndroidContext(parameter)) {
+          createNewOptionAndCall.append(".getApplicationContext()");
         }
+        createNewOptionAndCall.append(", ");
       }
+      createNewOptionAndCall = new StringBuilder(
+          createNewOptionAndCall.substring(0, createNewOptionAndCall.length() - 2));
     }
-    return false;
-  }
-
-  private static ParameterSpec getParameterSpec(VariableElement variable) {
-    return ParameterSpec.builder(
-        TypeName.get(variable.asType()), variable.getSimpleName().toString()).build();
-  }
-
-  private static List<String> getComparableParameterNames(
-      ExecutableElement element, boolean skipFirst) {
-    List<? extends VariableElement> parameters = element.getParameters();
-    if (skipFirst) {
-      parameters = parameters.subList(1, parameters.size());
-    }
-    List<String> result = new ArrayList<>(parameters.size());
-    for (VariableElement parameter : parameters) {
-      result.add(parameter.asType().toString());
-    }
-    return result;
+    createNewOptionAndCall.append(")");
+    return createNewOptionAndCall;
   }
 
-  private static int getOverrideType(ExecutableElement element) {
-    GlideOption glideOption =
-        element.getAnnotation(GlideOption.class);
-    return glideOption.override();
+  private boolean isAndroidContext(VariableElement variableElement) {
+    Element element = processingEnvironment.getTypeUtils().asElement(variableElement.asType());
+    return element.toString().equals("android.content.Context");
   }
 
   @Nullable
@@ -583,14 +621,8 @@ private static boolean skipStaticMethod(ExecutableElement element) {
   }
 
   private static final class MethodAndStaticVar {
-    @Nullable
-    final MethodSpec method;
-    @Nullable
-    final FieldSpec staticField;
-
-    MethodAndStaticVar() {
-      this(null /*method*/);
-    }
+    @Nullable final MethodSpec method;
+    @Nullable final FieldSpec staticField;
 
     MethodAndStaticVar(@Nullable MethodSpec method) {
       this(method, null /*staticField*/);
@@ -605,12 +637,12 @@ private static boolean skipStaticMethod(ExecutableElement element) {
   private static final class MethodSignature {
     private final TypeName returnType;
     private final List<TypeName> parameterTypes;
-    private final Set<Modifier> modifiers;
+    private final boolean isStatic;
     private final String name;
 
     MethodSignature(MethodSpec spec) {
       name = spec.name;
-      modifiers = spec.modifiers;
+      isStatic = spec.modifiers.contains(Modifier.STATIC);
       returnType = spec.returnType;
       parameterTypes =
           Lists.transform(spec.parameters, new Function<ParameterSpec, TypeName>() {
@@ -630,14 +662,14 @@ public boolean equals(Object o) {
         return name.equals(other.name)
             && returnType.equals(other.returnType)
             && parameterTypes.equals(other.parameterTypes)
-            && modifiers.equals(other.modifiers);
+            && isStatic == other.isStatic;
       }
       return false;
     }
 
     @Override
     public int hashCode() {
-      return Objects.hashCode(name, returnType, parameterTypes, modifiers);
+      return Objects.hashCode(name, returnType, parameterTypes, isStatic);
     }
   }
 }
diff --git a/annotation/compiler/test/.gitignore b/annotation/compiler/test/.gitignore
new file mode 100644
index 000000000..796b96d1c
--- /dev/null
+++ b/annotation/compiler/test/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/annotation/compiler/test/build.gradle b/annotation/compiler/test/build.gradle
new file mode 100644
index 000000000..5bb534de3
--- /dev/null
+++ b/annotation/compiler/test/build.gradle
@@ -0,0 +1,51 @@
+apply plugin: 'java'
+
+sourceSets {
+    test {
+        output.resourcesDir = "build/classes/java/test"
+    }
+}
+
+// This special test only submodule exists because adding the :glide dependency seems to break
+// the annotation processor dependency chain for the internal sample apps. It's also somewhat
+// easier to parse as a separate module given the existing complexity here and in the compiler
+dependencies {
+    // build.gradle file.
+    testImplementation project(':glide')
+    testImplementation project(':annotation:compiler')
+    testImplementation "com.squareup:javapoet:${JAVAPOET_VERSION}"
+    testImplementation "com.google.auto.service:auto-service:${AUTO_SERVICE_VERSION}"
+    testImplementation "com.google.code.findbugs:jsr305:${JSR_305_VERSION}"
+    // Using 0.10 of compile-testing is required for Android Studio to function, but not for the
+    // gradle build. Not yet clear why, but it looks like some kind of version conflict between
+    // javapoet, guava and/or truth.
+    //noinspection GradleDependency
+    testImplementation 'com.google.testing.compile:compile-testing:0.10'
+    // Use a stupidly old version of the Android classes jar. This works because we just need to get
+    // our generated classes to compile and our generated classes tend to use simple and stable
+    // Android APIs. If that changes, we'll need to find an alternative.
+    testImplementation 'com.google.android:android:4.1.1.4'
+    // Use a stupidly old version of v4 because it's a jar. The newer support v4 packages are aars,
+    // which we can't depend on in a standard Java test. Since our usage of v4 is pretty simple,
+    // hopefully this will continue to work going forward.
+    testImplementation 'com.google.android:support-v4:r6'
+    testImplementation "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}"
+}
+
+task regenerateTestResources {
+    group 'Verification'
+    description 'Regenerates all test resource files under annotation/compiler/test/src/test/resources that are compared against the current output to detect regressions'
+    tasks.withType(Test) {
+        systemProperties.put("com.bumptech.glide.annotation.compiler.test.regenerate.path", projectDir)
+    }
+    doFirst {
+        println("Regenerating test resources....")
+    }
+    doLast {
+        println("Finished regenerating test resources")
+    }
+}
+regenerateTestResources.finalizedBy(test)
+
+test.maxParallelForks = 2
+
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithExcludesTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithExcludesTest.java
new file mode 100644
index 000000000..323a4b151
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithExcludesTest.java
@@ -0,0 +1,101 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.appResource;
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyLibraryModule;
+import static com.bumptech.glide.annotation.compiler.test.Util.glide;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.ReferencedResource;
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests AppGlideModules that use the @Excludes annotation with a single excluded Module class.
+ */
+@RunWith(JUnit4.class)
+public class AppGlideModuleWithExcludesTest {
+  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
+      new RegenerateResourcesRule(getClass());
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                forResource("AppModuleWithExcludes.java"),
+                emptyLibraryModule());
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideOptions"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideOptions.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequest"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideRequest.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequests"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideRequests.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilationGeneratesExpectedGlideAppClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideApp"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideApp.java").getCharContent(true)));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedAppGlideModuleImpl"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(forResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedRequestManagerFactory"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(appResource("GeneratedRequestManagerFactory.java").getCharContent(true)));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithMultipleExcludesTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithMultipleExcludesTest.java
new file mode 100644
index 000000000..86fb5b02b
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithMultipleExcludesTest.java
@@ -0,0 +1,101 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.appResource;
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+import static com.bumptech.glide.annotation.compiler.test.Util.glide;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.ReferencedResource;
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests AppGlideModules that use the @Excludes annotation with multiple excluded Module classes.
+ */
+@RunWith(JUnit4.class)
+public class AppGlideModuleWithMultipleExcludesTest {
+  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
+      new RegenerateResourcesRule(getClass());
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                forResource("AppModuleWithMultipleExcludes.java"),
+                forResource("EmptyLibraryModule1.java"),
+                forResource("EmptyLibraryModule2.java"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideOptions"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideOptions.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequest"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideRequest.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequests"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideRequests.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilationGeneratesExpectedGlideAppClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideApp"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideApp.java").getCharContent(true)));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedAppGlideModuleImpl"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(forResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedRequestManagerFactory"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(appResource("GeneratedRequestManagerFactory.java").getCharContent(true)));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppAndLibraryGlideModulesTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppAndLibraryGlideModulesTest.java
new file mode 100644
index 000000000..d9c18209d
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppAndLibraryGlideModulesTest.java
@@ -0,0 +1,122 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.annotation;
+import static com.bumptech.glide.annotation.compiler.test.Util.appResource;
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyLibraryModule;
+import static com.bumptech.glide.annotation.compiler.test.Util.glide;
+import static com.bumptech.glide.annotation.compiler.test.Util.libraryResource;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.ReferencedResource;
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests adding both an empty {@link com.bumptech.glide.module.AppGlideModule} and an empty
+ * {@link com.bumptech.glide.module.LibraryGlideModule} in a single project.
+ */
+@RunWith(JUnit4.class)
+public class EmptyAppAndLibraryGlideModulesTest {
+  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
+      new RegenerateResourcesRule(getClass());
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                emptyLibraryModule());
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_generatesAllExpectedFiles() {
+    Truth.assertThat(compilation.generatedSourceFiles()).hasSize(7);
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideOptions"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideOptions.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequest"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideRequest.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequests"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideRequests.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilationGeneratesExpectedGlideAppClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideApp"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideApp.java").getCharContent(true)));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedAppGlideModuleImpl"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(forResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedRequestManagerFactory"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(appResource("GeneratedRequestManagerFactory.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedIndexer() throws IOException {
+    String expectedClassName =
+        "GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule";
+    assertThat(compilation)
+        .generatedSourceFile(annotation(expectedClassName))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(libraryResource(expectedClassName + ".java").getCharContent(true)));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppGlideModuleTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppGlideModuleTest.java
new file mode 100644
index 000000000..8af5e23d9
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppGlideModuleTest.java
@@ -0,0 +1,99 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+import static com.bumptech.glide.annotation.compiler.test.Util.glide;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests adding a single {@link com.bumptech.glide.test.EmptyAppModule} in a project.
+ */
+@RunWith(JUnit4.class)
+public class EmptyAppGlideModuleTest {
+  private static final String MODULE_NAME = "EmptyAppModule.java";
+  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
+      new RegenerateResourcesRule(getClass());
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(forResource(MODULE_NAME));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_generatesAllExpectedFiles() {
+    Truth.assertThat(compilation.generatedSourceFiles()).hasSize(6);
+  }
+
+  @Test
+  public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideOptions"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource("GlideOptions.java").getCharContent(true)));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGlideRequestClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequest"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource("GlideRequest.java").getCharContent(true)));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequests"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource("GlideRequests.java").getCharContent(true)));
+  }
+
+  @Test
+  public void compilationGeneratesExpectedGlideAppClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideApp"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource("GlideApp.java").getCharContent(true)));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedAppGlideModuleImpl"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(forResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedRequestManagerFactory"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(forResource("GeneratedRequestManagerFactory.java").getCharContent(true)));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+}
+
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyLibraryGlideModuleTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyLibraryGlideModuleTest.java
new file mode 100644
index 000000000..f4776d227
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyLibraryGlideModuleTest.java
@@ -0,0 +1,57 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.annotation;
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests adding a single {@link com.bumptech.glide.module.LibraryGlideModule} in a project.
+ */
+@RunWith(JUnit4.class)
+public class EmptyLibraryGlideModuleTest {
+  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
+      new RegenerateResourcesRule(getClass());
+  private static final String MODULE_NAME = "EmptyLibraryModule.java";
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(forResource(MODULE_NAME));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_generatesAllExpectedFiles() {
+    Truth.assertThat(compilation.generatedSourceFiles()).hasSize(1);
+  }
+
+  @Test
+  public void compilation_generatesExpectedIndexer() throws IOException {
+    String expectedClassName =
+        "GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule";
+    assertThat(compilation)
+        .generatedSourceFile(annotation(expectedClassName))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource(expectedClassName + ".java").getCharContent(true)));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionOptionsTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionOptionsTest.java
new file mode 100644
index 000000000..8c2588db1
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionOptionsTest.java
@@ -0,0 +1,146 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.SubDirectory;
+import com.bumptech.glide.annotation.compiler.test.TestDescription;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Verifies only the output we expect to change based on the various configurations of GlideOptions.
+ *
+ * <p>The output for all classes is tested in {@link LegacyGlideExtensionWithOptionTest}.
+ */
+@RunWith(JUnit4.class)
+public class GlideExtensionOptionsTest {
+  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
+      new RegenerateResourcesRule(getClass());
+  @Rule public final TestDescription testDescription = new TestDescription();
+  private static final String EXTENSION_NAME = "Extension.java";
+
+  @Test
+  @SubDirectory("OverrideExtend")
+  public void compilation_withOverrideExtend_validOptions() throws IOException {
+    runTest(Subject.GlideOptions);
+  }
+
+  @Test
+  @SubDirectory("OverrideExtend")
+  public void compilation_withOverrideExtend_validRequest() throws IOException {
+    runTest(Subject.GlideRequest);
+  }
+
+  @Test
+  @SubDirectory("OverrideExtendMultipleArguments")
+  public void compilation_withOverrideReplace_andMultipleArguments_validOptions()
+      throws IOException {
+    runTest(Subject.GlideOptions);
+  }
+
+  @Test
+  @SubDirectory("OverrideExtendMultipleArguments")
+  public void compilation_withOverrideReplace_andMultipleArguments_validRequest()
+      throws IOException {
+    runTest(Subject.GlideRequest);
+  }
+
+  @Test
+  @SubDirectory("OverrideReplace")
+  public void compilation_withOverrideReplace_validOptions() throws IOException {
+    runTest(Subject.GlideOptions);
+  }
+
+  @Test
+  @SubDirectory("OverrideReplace")
+  public void compilation_withOverrideReplace_validRequest() throws IOException {
+    runTest(Subject.GlideRequest);
+  }
+
+  @Test
+  @SubDirectory("StaticMethodName")
+  public void compilation_withStaticMethodName_validOptions() throws IOException {
+    runTest(Subject.GlideOptions);
+  }
+
+  @Test
+  @SubDirectory("StaticMethodName")
+  public void compilation_withStaticMethodName_validRequest() throws IOException {
+    runTest(Subject.GlideRequest);
+  }
+
+  @Test
+  @SubDirectory("MemoizeStaticMethod")
+  public void compilation_withMemoizeStaticMethod_validOptions() throws IOException {
+    runTest(Subject.GlideOptions);
+  }
+
+  @Test
+  @SubDirectory("MemoizeStaticMethod")
+  public void compilation_withMemoizeStaticMethod_validRequest() throws IOException {
+    runTest(Subject.GlideRequest);
+  }
+
+  @Test
+  @SubDirectory("SkipStaticMethod")
+  public void compilation_withSkipStaticMethod_validOptions() throws IOException {
+    runTest(Subject.GlideOptions);
+  }
+
+  @Test
+  @SubDirectory("SkipStaticMethod")
+  public void compilation_withSkipStaticMethod_validRequest() throws IOException {
+    runTest(Subject.GlideRequest);
+  }
+
+  private enum Subject {
+    GlideOptions,
+    GlideRequest;
+
+    String file() {
+      return name() + ".java";
+    }
+  }
+
+  private void runTest(Subject subject) throws IOException {
+    String subDir = getSubDirectoryName();
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                extension(subDir));
+    assertThat(compilation).succeededWithoutWarnings();
+
+    assertThat(compilation)
+        .generatedSourceFile(subpackage(subject.name()))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource(subDir, subject.file()).getCharContent(true)));
+  }
+
+  private String getSubDirectoryName() {
+    return testDescription
+        .getDescription()
+        .getAnnotation(SubDirectory.class)
+        .value();
+  }
+
+  private JavaFileObject extension(String subdir) {
+    return forResource(subdir, EXTENSION_NAME);
+  }
+
+  private JavaFileObject forResource(String subdir, String name) {
+    return Util.forResource(getClass().getSimpleName(), subdir + "/" + name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionWithOptionTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionWithOptionTest.java
new file mode 100644
index 000000000..a67555ea8
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionWithOptionTest.java
@@ -0,0 +1,107 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.appResource;
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
+import static com.bumptech.glide.annotation.compiler.test.Util.glide;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.ReferencedResource;
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Verifies the output of the processor with a simple single extension option in the new
+ * option style where extension methods always return values.
+ */
+@RunWith(JUnit4.class)
+public class GlideExtensionWithOptionTest {
+  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
+      new RegenerateResourcesRule(getClass());
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                forResource("ExtensionWithOption.java"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_generatesAllExpectedFiles() {
+    Truth.assertThat(compilation.generatedSourceFiles()).hasSize(7);
+  }
+
+  @Test
+  public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideOptions"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource("GlideOptions.java").getCharContent(true)));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGlideRequestClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequest"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource("GlideRequest.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequests"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideRequests.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilationGeneratesExpectedGlideAppClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideApp"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideApp.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedAppGlideModuleImpl"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(appResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedRequestManagerFactory"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(appResource("GeneratedRequestManagerFactory.java").getCharContent(true)));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionWithTypeTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionWithTypeTest.java
new file mode 100644
index 000000000..af4a4b747
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionWithTypeTest.java
@@ -0,0 +1,106 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.appResource;
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
+import static com.bumptech.glide.annotation.compiler.test.Util.glide;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.ReferencedResource;
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Verifies the output of the processor with a simple single extension type.
+ */
+@RunWith(JUnit4.class)
+public class GlideExtensionWithTypeTest {
+  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
+      new RegenerateResourcesRule(getClass());
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                forResource("ExtensionWithType.java"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_generatesAllExpectedFiles() {
+    Truth.assertThat(compilation.generatedSourceFiles()).hasSize(7);
+  }
+
+  @Test
+  public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideOptions"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource("GlideOptions.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequest"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideRequest.java").getCharContent(true)));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequests"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource("GlideRequests.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilationGeneratesExpectedGlideAppClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideApp"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideApp.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedAppGlideModuleImpl"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(appResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedRequestManagerFactory"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(appResource("GeneratedRequestManagerFactory.java").getCharContent(true)));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidAppGlideModuleWithExcludesTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidAppGlideModuleWithExcludesTest.java
new file mode 100644
index 000000000..e99c6160c
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidAppGlideModuleWithExcludesTest.java
@@ -0,0 +1,78 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests AppGlideModules with invalid usages of the @Excludes annotation.
+ */
+// Ignore warnings since most methods use ExpectedException
+@SuppressWarnings("ResultOfMethodCallIgnored")
+@RunWith(JUnit4.class)
+public class InvalidAppGlideModuleWithExcludesTest {
+  @Rule public final ExpectedException expectedException = ExpectedException.none();
+
+  @Test
+  public void compilation_withMissingExcludedModuleClass_throws() {
+    expectedException.expect(RuntimeException.class);
+    javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            JavaFileObjects.forSourceLines(
+                "AppModuleWithExcludes",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.annotation.Excludes;",
+                "import com.bumptech.glide.annotation.GlideModule;",
+                "import com.bumptech.glide.module.AppGlideModule;",
+                "import com.bumptech.glide.test.EmptyLibraryModule;",
+                "@GlideModule",
+                "@Excludes(EmptyLibraryModule.class)",
+                "public final class AppModuleWithExcludes extends AppGlideModule {}"));
+  }
+
+  @Test
+  public void compilation_withEmptyExcludes_fails() {
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                JavaFileObjects.forSourceLines(
+                    "AppModuleWithExcludes",
+                    "package com.bumptech.glide.test;",
+                    "import com.bumptech.glide.annotation.Excludes;",
+                    "import com.bumptech.glide.annotation.GlideModule;",
+                    "import com.bumptech.glide.module.AppGlideModule;",
+                    "import com.bumptech.glide.test.EmptyLibraryModule;",
+                    "@GlideModule",
+                    "@Excludes",
+                    "public final class AppModuleWithExcludes extends AppGlideModule {}"));
+    assertThat(compilation).failed();
+  }
+
+  @Test
+  public void compilation_withNonGlideModule_throws() {
+     Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                JavaFileObjects.forSourceLines(
+                    "AppModuleWithExcludes",
+                    "package com.bumptech.glide.test;",
+                    "import com.bumptech.glide.annotation.Excludes;",
+                    "import com.bumptech.glide.annotation.GlideModule;",
+                    "import com.bumptech.glide.module.AppGlideModule;",
+                    "import com.bumptech.glide.test.EmptyLibraryModule;",
+                    "@GlideModule",
+                    "@Excludes(Object.class)",
+                    "public final class AppModuleWithExcludes extends AppGlideModule {}"));
+    assertThat(compilation).failed();
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideExtensionTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideExtensionTest.java
new file mode 100644
index 000000000..c1a47efa2
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideExtensionTest.java
@@ -0,0 +1,132 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+import static org.junit.Assert.fail;
+
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Checks assertions on {@link com.bumptech.glide.annotation.GlideExtension}s themselves.
+ */
+// Avoid warnings when using ExpectedException.
+@SuppressWarnings("ResultOfMethodCallIgnored")
+@RunWith(JUnit4.class)
+public class InvalidGlideExtensionTest {
+  @Rule public final ExpectedException expectedException = ExpectedException.none();
+
+  @Test
+  public void compilation_withPublicConstructor_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "PublicConstructor",
+                  "package com.bumptech.glide.test;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "@GlideExtension",
+                  "public class PublicConstructor { }"));
+      fail("Failed to throw expected exception");
+    } catch (RuntimeException e) {
+      Throwable cause = e.getCause();
+      Truth.assertThat(cause.getMessage()).contains("non-private constructor");
+      Truth.assertThat(cause.getMessage()).contains("PublicConstructor");
+
+    }
+  }
+
+  @Test
+  public void compilation_withPackagePrivateExtension_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "PackagePrivateExtension",
+                  "package com.bumptech.glide.test;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "@GlideExtension",
+                  "class PackagePrivateExtension {",
+                  "  private PackagePrivateExtension() {}",
+                  "}"));
+      fail("Failed to throw expected exception");
+    } catch (RuntimeException e) {
+      Throwable cause = e.getCause();
+      Truth.assertThat(cause.getMessage()).contains("must be public");
+      Truth.assertThat(cause.getMessage()).contains("PackagePrivateExtension");
+    }
+  }
+
+  @Test
+  public void compilation_withConstructorWithParameters_throws() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "ConstructorParametersExtension",
+                  "package com.bumptech.glide.test;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "@GlideExtension",
+                  "public class ConstructorParametersExtension {",
+                  "  private ConstructorParametersExtension(int failParam) {}",
+                  "  public void doSomething() {}",
+                  "}"));
+      fail("Failed to get expected exception");
+    } catch (RuntimeException e) {
+      Throwable cause = e.getCause();
+      Truth.assertThat(cause.getMessage()).contains("parameters in the constructor");
+      Truth.assertThat(cause.getMessage()).contains("ConstructorParametersExtension");
+    }
+  }
+
+  @Test
+  public void compilation_withNonStaticMethod_succeeds() {
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                JavaFileObjects.forSourceLines(
+                    "Extension",
+                    "package com.bumptech.glide.test;",
+                    "import com.bumptech.glide.annotation.GlideExtension;",
+                    "@GlideExtension",
+                    "public class Extension {",
+                    "  private Extension() {}",
+                    "  public void doSomething() {}",
+                    "}"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_withStaticMethod_succeeds() {
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                JavaFileObjects.forSourceLines(
+                    "Extension",
+                    "package com.bumptech.glide.test;",
+                    "import com.bumptech.glide.annotation.GlideExtension;",
+                    "@GlideExtension",
+                    "public class Extension {",
+                    "  private Extension() {}",
+                    "  public static void doSomething() {}",
+                    "}"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideOptionsExtensionTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideOptionsExtensionTest.java
new file mode 100644
index 000000000..a0be89706
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideOptionsExtensionTest.java
@@ -0,0 +1,341 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+import static org.junit.Assert.fail;
+
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Checks assertions on {@link com.bumptech.glide.annotation.GlideExtension}s for methods annotated
+ * with {@link com.bumptech.glide.annotation.GlideOption}.
+ */
+// Ignore warnings since most methods use ExpectedException
+@SuppressWarnings("ResultOfMethodCallIgnored")
+@RunWith(JUnit4.class)
+public class InvalidGlideOptionsExtensionTest {
+  @Rule public final ExpectedException expectedException = ExpectedException.none();
+
+  @Test
+  public void compilation_withAnnotatedNonStaticMethod_fails() {
+    expectedException.expect(RuntimeException.class);
+    javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideOption;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @GlideOption",
+                "  public void doSomething() {}",
+                "}"));
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_withRequestOptionsArgInWrongOrder_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "NonRequestOptionsFirstArgExtension",
+                  "package com.bumptech.glide.test;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "import com.bumptech.glide.annotation.GlideOption;",
+                  "import com.bumptech.glide.request.RequestOptions;",
+                  "@GlideExtension",
+                  "public class NonRequestOptionsFirstArgExtension{",
+                  "  private NonRequestOptionsFirstArgExtension() {}",
+                  "  @GlideOption",
+                  "  public static void doSomething(Object arg1, RequestOptions options) {}",
+                  "}"));
+      fail();
+    } catch (RuntimeException e) {
+      String message = e.getCause().getMessage();
+      Truth.assertThat(message).contains("RequestOptions object as their first parameter");
+      Truth.assertThat(message).contains("Object");
+      Truth.assertThat(message).contains("NonRequestOptionsFirstArgExtension");
+    }
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_withRequestOptionsArg_succeeds() {
+    Compilation compilation = javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideOption;",
+                "import com.bumptech.glide.request.RequestOptions;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @GlideOption",
+                "  public static void doSomething(RequestOptions options) {}",
+                "}"));
+    assertThat(compilation).succeeded();
+    assertThat(compilation).hadWarningContaining("is using a legacy format.");
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_withRequestOptionsArgAndOtherArg_succeeds() {
+    Compilation compilation = javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideOption;",
+                "import com.bumptech.glide.request.RequestOptions;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @GlideOption",
+                "  public static void doSomething(RequestOptions options, Object arg2) {}",
+                "}"));
+    assertThat(compilation).succeeded();
+    assertThat(compilation).hadWarningContaining("is using a legacy format.");
+  }
+
+  @Test
+  public void compilation_overridingOptionWithoutAnnotationType_fails() {
+    expectedException.expect(RuntimeException.class);
+    javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideOption;",
+                "import com.bumptech.glide.request.RequestOptions;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @GlideOption",
+                "  public static void centerCrop(RequestOptions options) {}",
+                "}"));
+  }
+
+  @Test
+  public void compilation_withOverrideExtend_butNotOverridingMethod_fails() {
+    expectedException.expect(RuntimeException.class);
+    javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideOption;",
+                "import com.bumptech.glide.request.RequestOptions;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @GlideOption(override = GlideOption.OVERRIDE_EXTEND)",
+                "  public static void something(RequestOptions options) {}",
+                "}"));
+  }
+
+  @Test
+  public void compilation_withOverrideExtend_andOverridingMethod_succeeds() {
+    Compilation compilation = javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideOption;",
+                "import com.bumptech.glide.request.RequestOptions;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @GlideOption(override = GlideOption.OVERRIDE_EXTEND)",
+                "  public static void centerCrop(RequestOptions options) {}",
+                "}"));
+    assertThat(compilation).succeeded();
+    assertThat(compilation).hadWarningContaining("is using a legacy format.");
+  }
+
+  @Test
+  public void compilation_withOverrideReplace_butNotOverridingMethod_fails() {
+    expectedException.expect(RuntimeException.class);
+    javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideOption;",
+                "import com.bumptech.glide.request.RequestOptions;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @GlideOption(override = GlideOption.OVERRIDE_REPLACE)",
+                "  public static void something(RequestOptions options) {}",
+                "}"));
+  }
+
+  @Test
+  public void compilation_withOverrideReplace_andOverridingMethod_succeeds() {
+    Compilation compilation = javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideOption;",
+                "import com.bumptech.glide.request.RequestOptions;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @GlideOption(override = GlideOption.OVERRIDE_REPLACE)",
+                "  public static void centerCrop(RequestOptions options) {}",
+                "}"));
+    assertThat(compilation).succeeded();
+    assertThat(compilation).hadWarningContaining("is using a legacy format.");
+  }
+
+  @Test
+  public void compilation_withRequestOptionsReturnValue_succeeds() {
+     Compilation compilation = javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import android.support.annotation.NonNull;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideOption;",
+                "import com.bumptech.glide.request.RequestOptions;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @NonNull",
+                "  @GlideOption",
+                "  public static RequestOptions doSomething(RequestOptions options) {",
+                "    return options;",
+                "  }",
+                "}"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_withNonRequestOptionsReturnValue_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "WrongReturnTypeExtension",
+                  "package com.bumptech.glide.test;",
+                  "import android.support.annotation.NonNull;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "import com.bumptech.glide.annotation.GlideOption;",
+                  "import com.bumptech.glide.request.RequestOptions;",
+                  "@GlideExtension",
+                  "public class WrongReturnTypeExtension {",
+                  "  private WrongReturnTypeExtension() {}",
+                  "  @NonNull",
+                  "  @GlideOption",
+                  "  public static Object doSomething(RequestOptions options) {",
+                  "    return options;",
+                  "  }",
+                  "}"));
+      fail();
+    } catch (RuntimeException e) {
+      String message = e.getCause().getMessage();
+      Truth.assertThat(message)
+          .contains("@GlideOption methods should return a RequestOptions object");
+      Truth.assertThat(message).contains("Object");
+      Truth.assertThat(message).contains("WrongReturnTypeExtension");
+    }
+  }
+
+  @Test
+  public void compilation_withMissingNonNullAnnotation_warns() {
+    Compilation compilation = javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideOption;",
+                "import com.bumptech.glide.request.RequestOptions;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @GlideOption",
+                "  public static RequestOptions doSomething(RequestOptions options) {",
+                "    return options;",
+                "  }",
+                "}"));
+    assertThat(compilation).succeeded();
+    assertThat(compilation).hadWarningCount(1);
+    assertThat(compilation).hadWarningContaining("android.support.annotation.NonNull");
+    assertThat(compilation).hadWarningContaining("com.bumptech.glide.test.Extension#doSomething");
+  }
+
+  @Test
+  public void compilation_withNoOptionParameters_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "MissingRequestOptionsExtension",
+                  "package com.bumptech.glide.test;",
+                  "import android.support.annotation.NonNull;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "import com.bumptech.glide.annotation.GlideOption;",
+                  "import com.bumptech.glide.request.RequestOptions;",
+                  "@GlideExtension",
+                  "public class MissingRequestOptionsExtension {",
+                  "  private MissingRequestOptionsExtension() {}",
+                  "  @NonNull",
+                  "  @GlideOption",
+                  "  public static RequestOptions doSomething() {",
+                  "    return options;",
+                  "  }",
+                  "}"));
+      fail();
+    } catch (RuntimeException e) {
+      String message = e.getCause().getMessage();
+      Truth.assertThat(message).contains("RequestOptions object as their first parameter");
+      Truth.assertThat(message).contains("doSomething");
+      Truth.assertThat(message).contains("MissingRequestOptionsExtension");
+    }
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideTypeExtensionTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideTypeExtensionTest.java
new file mode 100644
index 000000000..9076f806e
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideTypeExtensionTest.java
@@ -0,0 +1,354 @@
+package com.bumptech.glide.annotation.compiler;
+
+
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+import static org.junit.Assert.fail;
+
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import java.io.IOException;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Checks assertions on {@link com.bumptech.glide.annotation.GlideExtension}s for methods annotated
+ * with {@link com.bumptech.glide.annotation.GlideType}.
+ */
+// Ignore warnings since most methods use ExpectedException
+@SuppressWarnings("ResultOfMethodCallIgnored")
+@RunWith(JUnit4.class)
+public class InvalidGlideTypeExtensionTest {
+  @Rule public final ExpectedException expectedException = ExpectedException.none();
+
+  @Test
+  public void compilation_withAnnotatedNonStaticMethod_fails() {
+    expectedException.expectMessage("@GlideType methods must be static");
+    javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideType;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @GlideType(Number.class)",
+                "  public void doSomething() {}",
+                "}"));
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_withoutRequestBuilderArg_fails() {
+    expectedException
+        .expectMessage(
+            "@GlideType methods must take a RequestBuilder object as their first and only"
+                + " parameter, but given multiple for:"
+                + " com.bumptech.glide.test.Extension#doSomething()");
+    javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideType;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @GlideType(Number.class)",
+                "  public static void doSomething() {}",
+                "}"));
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_withRequestBuilderArg_succeeds() {
+    Compilation compilation = javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.RequestBuilder;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideType;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @GlideType(Number.class)",
+                "  public static void type(RequestBuilder<Number> builder) {}",
+                "}"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_withNonRequestBuilderArg_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "WrongParameterTypeExtension",
+                  "package com.bumptech.glide.test;",
+                  "import com.bumptech.glide.RequestBuilder;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "import com.bumptech.glide.annotation.GlideType;",
+                  "@GlideExtension",
+                  "public class WrongParameterTypeExtension {",
+                  "  private WrongParameterTypeExtension() {}",
+                  "  @GlideType(Number.class)",
+                  "  public static void type(Object arg) {}",
+                  "}"));
+    } catch (RuntimeException e) {
+      String message = e.getCause().getMessage();
+      Truth.assertThat(message).contains("RequestBuilder object as their first and only parameter");
+      Truth.assertThat(message).contains("Object");
+      Truth.assertThat(message).contains("WrongParameterTypeExtension");
+    }
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_withRequestBuilderArgAndOtherArg_fails() {
+    expectedException
+        .expectMessage(
+            "@GlideType methods must take a RequestBuilder object as their first and only"
+                + " parameter, but given multiple for:"
+                + " com.bumptech.glide.test.Extension#type("
+                + "com.bumptech.glide.RequestBuilder<java.lang.Number>,"
+                + "java.lang.Object)");
+    javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.RequestBuilder;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideType;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @GlideType(Number.class)",
+                "  public static void type(RequestBuilder<Number> builder, Object arg2) {}",
+                "}"));
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_overridingExistingType_fails()
+      throws IOException {
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                JavaFileObjects.forSourceLines(
+                    "Extension",
+                    "package com.bumptech.glide.test;",
+                    "import android.graphics.drawable.Drawable;",
+                    "import com.bumptech.glide.RequestBuilder;",
+                    "import com.bumptech.glide.annotation.GlideExtension;",
+                    "import com.bumptech.glide.annotation.GlideType;",
+                    "@GlideExtension",
+                    "public class Extension {",
+                    "  private Extension() {}",
+                    "  @GlideType(Drawable.class)",
+                    "  public static void asDrawable(RequestBuilder<Drawable> builder) {}",
+                    "}"));
+    expectedException
+        .expectMessage(
+            "error: method asDrawable() is already defined in class"
+                + " com.bumptech.glide.test.GlideRequests");
+    compilation.generatedSourceFile(subpackage("GlideRequests"));
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_returningRequestBuilder_succeeds() {
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                JavaFileObjects.forSourceLines(
+                    "Extension",
+                    "package com.bumptech.glide.test;",
+                    "import android.support.annotation.NonNull;",
+                    "import com.bumptech.glide.RequestBuilder;",
+                    "import com.bumptech.glide.annotation.GlideExtension;",
+                    "import com.bumptech.glide.annotation.GlideType;",
+                    "@GlideExtension",
+                    "public class Extension {",
+                    "  private Extension() {}",
+                    "  @NonNull",
+                    "  @GlideType(Number.class)",
+                    "  public static RequestBuilder<Number> asNumber(",
+                    "      RequestBuilder<Number> builder) {",
+                    "    return builder;",
+                    "  }",
+                    "}"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_returningNonRequestBuilder_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "WrongReturnTypeExtension",
+                  "package com.bumptech.glide.test;",
+                  "import com.bumptech.glide.RequestBuilder;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "import com.bumptech.glide.annotation.GlideType;",
+                  "@GlideExtension",
+                  "public class WrongReturnTypeExtension {",
+                  "  private WrongReturnTypeExtension() {}",
+                  "  @GlideType(Number.class)",
+                  "  public static Object asNumber(",
+                  "      RequestBuilder<Number> builder) {",
+                  "    return new Object();",
+                  "  }",
+                  "}"));
+      fail();
+    } catch (RuntimeException e) {
+      String message = e.getCause().getMessage();
+      Truth.assertThat(message).contains("@GlideType methods should return a RequestBuilder");
+      Truth.assertThat(message).contains("Number");
+      Truth.assertThat(message).contains("WrongReturnTypeExtension");
+    }
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_returningBuilderWithIncorrectType_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "WrongBuilderTypeExtension",
+                  "package com.bumptech.glide.test;",
+                  "import com.bumptech.glide.RequestBuilder;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "import com.bumptech.glide.annotation.GlideType;",
+                  "@GlideExtension",
+                  "public class WrongBuilderTypeExtension {",
+                  "  private WrongBuilderTypeExtension() {}",
+                  "  @GlideType(Number.class)",
+                  "  public static RequestBuilder<Object> asNumber(",
+                  "      RequestBuilder<Object> builder) {",
+                  "    return builder;",
+                  "  }",
+                  "}"));
+      fail();
+    } catch (RuntimeException e) {
+      String message = e.getCause().getMessage();
+      Truth.assertThat(message)
+          .contains("@GlideType methods should return a RequestBuilder<java.lang.Number>");
+      Truth.assertThat(message)
+          .contains("WrongBuilderTypeExtension");
+    }
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_returningBuilder_andMultipleParams_fails() {
+    expectedException.expectMessage(
+        "@GlideType methods must take a RequestBuilder object as their first and only parameter,"
+            + " but given multiple for:"
+            + " com.bumptech.glide.test.Extension#asNumber("
+            + "com.bumptech.glide.RequestBuilder<java.lang.Number>,java.lang.Object)");
+    javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.RequestBuilder;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideType;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @GlideType(Number.class)",
+                "  public static RequestBuilder<Number> asNumber(",
+                "      RequestBuilder<Number> builder, Object arg1) {",
+                "    return builder;",
+                "  }",
+                "}"));
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_returningBuilder_nonBuilderParam_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "IncorrectParameterExtension",
+                  "package com.bumptech.glide.test;",
+                  "import com.bumptech.glide.RequestBuilder;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "import com.bumptech.glide.annotation.GlideType;",
+                  "@GlideExtension",
+                  "public class IncorrectParameterExtension {",
+                  "  private IncorrectParameterExtension() {}",
+                  "  @GlideType(Number.class)",
+                  "  public static RequestBuilder<Number> asNumber(",
+                  "      Object arg) {",
+                  "    return null;",
+                  "  }",
+                  "}"));
+      fail();
+    } catch (RuntimeException e) {
+      String message = e.getCause().getMessage();
+      Truth.assertThat(message).contains("@GlideType methods must take a RequestBuilder object"
+          + " as their first and only parameter");
+      Truth.assertThat(message).contains("Object");
+      Truth.assertThat(message).contains("IncorrectParameterExtension");
+    }
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_returningRequestBuilder_missingNonNull_warns() {
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                JavaFileObjects.forSourceLines(
+                    "Extension",
+                    "package com.bumptech.glide.test;",
+                    "import com.bumptech.glide.RequestBuilder;",
+                    "import com.bumptech.glide.annotation.GlideExtension;",
+                    "import com.bumptech.glide.annotation.GlideType;",
+                    "@GlideExtension",
+                    "public class Extension {",
+                    "  private Extension() {}",
+                    "  @GlideType(Number.class)",
+                    "  public static RequestBuilder<Number> asNumber(",
+                    "      RequestBuilder<Number> builder) {",
+                    "    return builder;",
+                    "  }",
+                    "}"));
+    assertThat(compilation).succeeded();
+    assertThat(compilation).hadWarningCount(1);
+    assertThat(compilation).hadWarningContaining("android.support.annotation.NonNull");
+    assertThat(compilation).hadWarningContaining("com.bumptech.glide.test.Extension#asNumber");
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/LegacyGlideExtensionOptionsTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/LegacyGlideExtensionOptionsTest.java
new file mode 100644
index 000000000..5087f3be9
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/LegacyGlideExtensionOptionsTest.java
@@ -0,0 +1,134 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.SubDirectory;
+import com.bumptech.glide.annotation.compiler.test.TestDescription;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Verifies only the output we expect to change based on the various configurations of GlideOptions
+ * when GlideOptions are defined in the legacy format.
+ *
+ * <p>The output for all classes is tested in {@link LegacyGlideExtensionWithOptionTest}.
+ */
+@RunWith(JUnit4.class)
+public class LegacyGlideExtensionOptionsTest {
+  @Rule public final TestDescription testDescription = new TestDescription();
+  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
+      new RegenerateResourcesRule(getClass());
+
+  private static final String EXTENSION_NAME = "Extension.java";
+
+  @Test
+  @SubDirectory("OverrideExtend")
+  public void compilation_withOverrideExtend_validOptions() throws IOException {
+    runTest(Subject.GlideOptions);
+  }
+
+  @Test
+  @SubDirectory("OverrideExtend")
+  public void compilation_withOverrideExtend_validRequest() throws IOException {
+    runTest(Subject.GlideRequest);
+  }
+
+  @Test
+  @SubDirectory("OverrideReplace")
+  public void compilation_withOverrideReplace_validOptions() throws IOException {
+    runTest(Subject.GlideOptions);
+  }
+
+  @Test
+  @SubDirectory("OverrideReplace")
+  public void compilation_withOverrideReplace_validRequest() throws IOException {
+    runTest(Subject.GlideRequest);
+  }
+
+  @Test
+  @SubDirectory("StaticMethodName")
+  public void compilation_withStaticMethodName_validOptions() throws IOException {
+    runTest(Subject.GlideOptions);
+  }
+
+  @Test
+  @SubDirectory("StaticMethodName")
+  public void compilation_withStaticMethodName_validRequest() throws IOException {
+    runTest(Subject.GlideRequest);
+  }
+
+  @Test
+  @SubDirectory("MemoizeStaticMethod")
+  public void compilation_withMemoizeStaticMethod_validOptions() throws IOException {
+    runTest(Subject.GlideOptions);
+  }
+
+  @Test
+  @SubDirectory("MemoizeStaticMethod")
+  public void compilation_withMemoizeStaticMethod_validRequest() throws IOException {
+    runTest(Subject.GlideRequest);
+  }
+
+  @Test
+  @SubDirectory("SkipStaticMethod")
+  public void compilation_withSkipStaticMethod_validOptions() throws IOException {
+    runTest(Subject.GlideOptions);
+  }
+
+  @Test
+  @SubDirectory("SkipStaticMethod")
+  public void compilation_withSkipStaticMethod_validRequest() throws IOException {
+    runTest(Subject.GlideRequest);
+  }
+
+  private enum Subject {
+    GlideOptions,
+    GlideRequest;
+
+    String file() {
+      return name() + ".java";
+    }
+  }
+
+  private void runTest(Subject subject) throws IOException {
+    String subDirectoryName = getSubDirectoryName();
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                extension(subDirectoryName));
+    assertThat(compilation).succeeded();
+
+    assertThat(compilation)
+        .generatedSourceFile(subpackage(subject.name()))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource(subDirectoryName, subject.file()).getCharContent(true)));
+  }
+
+  private String getSubDirectoryName() {
+    return testDescription
+        .getDescription()
+        .getAnnotation(SubDirectory.class)
+        .value();
+  }
+
+  private JavaFileObject extension(String subdir) {
+    return forResource(subdir, EXTENSION_NAME);
+  }
+
+  private JavaFileObject forResource(String subdir, String name) {
+    return Util.forResource(getClass().getSimpleName(), subdir + "/" + name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/LegacyGlideExtensionWithOptionTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/LegacyGlideExtensionWithOptionTest.java
new file mode 100644
index 000000000..933402ff3
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/LegacyGlideExtensionWithOptionTest.java
@@ -0,0 +1,113 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.appResource;
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
+import static com.bumptech.glide.annotation.compiler.test.Util.glide;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.ReferencedResource;
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Verifies the output of the processor with a simple single extension option in the legacy
+ * option style where extension methods always returned {@code null}.
+ */
+@RunWith(JUnit4.class)
+public class LegacyGlideExtensionWithOptionTest {
+  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
+      new RegenerateResourcesRule(getClass());
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                forResource("ExtensionWithOption.java"));
+    assertThat(compilation).succeeded();
+    //noinspection ResultOfMethodCallIgnored
+    assertThat(compilation).hadWarningContaining(
+        "The squareThumb method annotated with @GlideOption in the ExtensionWithOption"
+            + " @GlideExtension is using a legacy format. Support will be removed in a future"
+            + " version. Please change your method definition so that your @GlideModule annotated"
+            + " methods return RequestOptions objects instead of null.");
+  }
+
+  @Test
+  public void compilation_generatesAllExpectedFiles() {
+    Truth.assertThat(compilation.generatedSourceFiles()).hasSize(7);
+  }
+
+  @Test
+  public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideOptions"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource("GlideOptions.java").getCharContent(true)));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGlideRequestClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequest"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource("GlideRequest.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequests"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideRequests.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilationGeneratesExpectedGlideAppClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideApp"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideApp.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedAppGlideModuleImpl"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(appResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedRequestManagerFactory"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(appResource("GeneratedRequestManagerFactory.java").getCharContent(true)));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/LegacyGlideExtensionWithTypeTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/LegacyGlideExtensionWithTypeTest.java
new file mode 100644
index 000000000..52b19d890
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/LegacyGlideExtensionWithTypeTest.java
@@ -0,0 +1,106 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.appResource;
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
+import static com.bumptech.glide.annotation.compiler.test.Util.glide;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.ReferencedResource;
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Verifies the output of the processor with a simple single extension type.
+ */
+@RunWith(JUnit4.class)
+public class LegacyGlideExtensionWithTypeTest {
+  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
+      new RegenerateResourcesRule(getClass());
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                forResource("ExtensionWithType.java"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_generatesAllExpectedFiles() {
+    Truth.assertThat(compilation.generatedSourceFiles()).hasSize(7);
+  }
+
+  @Test
+  public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideOptions"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource("GlideOptions.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequest"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideRequest.java").getCharContent(true)));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequests"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource("GlideRequests.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilationGeneratesExpectedGlideAppClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideApp"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideApp.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedAppGlideModuleImpl"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(appResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedRequestManagerFactory"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(appResource("GeneratedRequestManagerFactory.java").getCharContent(true)));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/MultipleAppGlideModuleTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/MultipleAppGlideModuleTest.java
new file mode 100644
index 000000000..cecf9f748
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/MultipleAppGlideModuleTest.java
@@ -0,0 +1,57 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.testing.compile.Compilation;
+import javax.tools.JavaFileObject;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Ensures that adding more than one {@link com.bumptech.glide.module.AppGlideModule} to a project
+ * will fail.
+ */
+@RunWith(JUnit4.class)
+public class MultipleAppGlideModuleTest {
+  private static final String FIRST_MODULE = "EmptyAppModule1.java";
+  private static final String SECOND_MODULE = "EmptyAppModule2.java";
+  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
+      new RegenerateResourcesRule(getClass());
+  @Rule public final ExpectedException expectedException = ExpectedException.none();
+
+  // Throws.
+  @SuppressWarnings("ResultOfMethodCallIgnored")
+  @Test
+  public void compilation_withTwoAppModules_fails() {
+    expectedException.expect(RuntimeException.class);
+    javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(forResource(FIRST_MODULE), forResource(SECOND_MODULE));
+  }
+
+  @Test
+  public void compilation_withFirstModuleOnly_succeeds() {
+    Compilation compilation = javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(forResource(FIRST_MODULE));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_withSecondModuleOnly_succeeds() {
+    Compilation compilation = javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(forResource(SECOND_MODULE));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/MultipleEmptyLibraryGlideModuleTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/MultipleEmptyLibraryGlideModuleTest.java
new file mode 100644
index 000000000..94e1c27b7
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/MultipleEmptyLibraryGlideModuleTest.java
@@ -0,0 +1,61 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.annotation;
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests adding multiple {@link com.bumptech.glide.module.LibraryGlideModule}s in a project.
+ */
+@RunWith(JUnit4.class)
+public class MultipleEmptyLibraryGlideModuleTest {
+  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
+      new RegenerateResourcesRule(getClass());
+  @Rule public final ExpectedException expectedException = ExpectedException.none();
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                forResource("EmptyLibraryModule1.java"),
+                forResource("EmptyLibraryModule2.java"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_generatesAllExpectedFiles() {
+    Truth.assertThat(compilation.generatedSourceFiles()).hasSize(1);
+  }
+
+  @Test
+  public void compilation_generatesExpectedIndexerForModules() throws IOException {
+    String expectedClassName =
+        "GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule1_com_bumptech_glide"
+            + "_test_EmptyLibraryModule2";
+    assertThat(compilation)
+        .generatedSourceFile(annotation(expectedClassName))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource(expectedClassName + ".java").getCharContent(true)));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/ReferencedResource.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/ReferencedResource.java
new file mode 100644
index 000000000..b7194411d
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/ReferencedResource.java
@@ -0,0 +1,24 @@
+package com.bumptech.glide.annotation.compiler.test;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Indicates that the method in question is referencing a test resource that it doesn't "own" and
+ * should not attempt to regenerate.
+ *
+ * <p>Used by {@link RegenerateResourcesRule} to ensure that if we are regenerating resources,
+ * we're only regenerating them for a single class and only for the single class that has the
+ * correct name and directory sequence so that we update the correct file.
+ *
+ * <p>Ideally this wouldn't be necessary. It would be great if we could find a way to go from the
+ * test failure more directly to the actual path of the resource used. Right now we're basically
+ * guessing based on this annotation, the class name of the test class, and any values from
+ * {@link SubDirectory}. Without this annotation, we'd end up writing files that were never used.
+ */
+@Target(ElementType.METHOD)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface ReferencedResource {
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/RegenerateResourcesRule.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/RegenerateResourcesRule.java
new file mode 100644
index 000000000..66f48c767
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/RegenerateResourcesRule.java
@@ -0,0 +1,101 @@
+package com.bumptech.glide.annotation.compiler.test;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+
+import android.support.annotation.NonNull;
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.Writer;
+import org.junit.ComparisonFailure;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+/**
+ * Regenerates test resources for annotation compiler tests when the
+ * {@link Util#REGENERATE_TEST_RESOURCES_PROPERTY_NAME} property is set to the directory containing
+ * the project.
+ *
+ * <p>This can easily be used via gradle by running:
+ * {@code
+ *  ./gradlew :annotation:compiler:test:regenerateTestResources
+ * }
+ *
+ * <p>Our regenerate task will set the appropriate environment variables that will allow the logic
+ * here to succeed. When running the tests normally, this class will do nothing.
+ */
+public final class RegenerateResourcesRule implements TestRule {
+
+  private final Class<?> testClass;
+
+  public RegenerateResourcesRule(Class<?> testClass) {
+    this.testClass = testClass;
+  }
+
+  @Override
+  public Statement apply(final Statement base, final Description description) {
+    return new Statement() {
+      @Override
+      public void evaluate() throws Throwable {
+        try {
+          base.evaluate();
+        } catch (ComparisonFailure e) {
+          String projectRoot = Util.getProjectRootIfRegeneratingTestResources();
+          if (projectRoot == null || description.getAnnotation(ReferencedResource.class) != null) {
+            throw e;
+          }
+          updateResourceFile(e, projectRoot, description);
+        }
+      }
+    };
+  }
+
+  private void updateResourceFile(
+      ComparisonFailure e, @NonNull String projectDirectory, Description description) {
+    String testClassName = testClass.getSimpleName();
+    String testFileName = parseFileNameFromMessage(e);
+    String testDirectory = projectDirectory + "/src/test/resources/" + testClassName;
+    String subDirectorySegment =
+        description.getAnnotation(SubDirectory.class) != null
+            ? description.getAnnotation(SubDirectory.class).value() + "/"
+            : "";
+
+    File expectedDirectory = new File(testDirectory + "/" + subDirectorySegment);
+    if (!expectedDirectory.exists() && !expectedDirectory.mkdirs()) {
+      throw new IllegalStateException(
+          "Failed to generate expected directory: " + expectedDirectory);
+    }
+    if (!expectedDirectory.isDirectory()) {
+      throw new IllegalStateException(
+          "Expected a directory, but found a file: " + expectedDirectory);
+    }
+
+    File expectedFile = new File(expectedDirectory, testFileName);
+    Writer writer = null;
+    try {
+      writer = new FileWriter(expectedFile);
+      writer.write(asUnixChars(e.getActual()).toString());
+      writer.close();
+    } catch (IOException e1) {
+      throw new RuntimeException("Failed to regenerate test file", e1);
+    } finally {
+      if (writer != null) {
+        try {
+          writer.close();
+        } catch (IOException exception) {
+          // Ignore.
+        }
+      }
+    }
+  }
+
+  // Parses </SOURCE_OUTPUT/com/bumptech/glide/test/GlideOptions.java> to GlideOptions.java.
+  private static String parseFileNameFromMessage(ComparisonFailure e) {
+    String message = e.getMessage();
+    int firstGreaterThanIndex = message.indexOf('>');
+    String substring = message.substring(0, firstGreaterThanIndex);
+    int lastForwardSlashIndex = substring.lastIndexOf('/');
+    return substring.substring(lastForwardSlashIndex + 1, substring.length());
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/SubDirectory.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/SubDirectory.java
new file mode 100644
index 000000000..c0023498a
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/SubDirectory.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.annotation.compiler.test;
+
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Indicates the subdirectory for a particular test that contains the test resource(s) used for the
+ * method.
+ *
+ * <p>Used both by tests to extract the correct subdirectory and by the
+ * {@link RegenerateResourcesRule} for the same purpose.
+ */
+@Target(ElementType.METHOD)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface SubDirectory {
+  String value();
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/TestDescription.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/TestDescription.java
new file mode 100644
index 000000000..2b4c7c72c
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/TestDescription.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.annotation.compiler.test;
+
+import org.junit.rules.TestWatcher;
+import org.junit.runner.Description;
+
+/**
+ * Exposes the {@link Description} for the current test, similar to
+ * {@link org.junit.rules.TestName}.
+ */
+public final class TestDescription extends TestWatcher {
+  private Description description;
+  @Override
+  protected void starting(Description description) {
+    this.description = description;
+  }
+
+  public Description getDescription() {
+    return description;
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/Util.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/Util.java
new file mode 100644
index 000000000..64c4f9f08
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/Util.java
@@ -0,0 +1,87 @@
+package com.bumptech.glide.annotation.compiler.test;
+
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+
+/** Test utilities. */
+public final class Util {
+  private static final String REGENERATE_TEST_RESOURCES_PROPERTY_NAME =
+      "com.bumptech.glide.annotation.compiler.test.regenerate.path";
+  private static final String GLIDE_PACKAGE_NAME = "com.bumptech.glide";
+  private static final String SUB_PACKAGE_NAME = qualified(GLIDE_PACKAGE_NAME, "test");
+  private static final String ANNOTATION_PACKAGE_NAME = "com.bumptech.glide.annotation.compiler";
+  private static final String DEFAULT_APP_DIR_NAME = "EmptyAppGlideModuleTest";
+  private static final String DEFAULT_LIBRARY_DIR_NAME = "EmptyLibraryGlideModuleTest";
+  /**
+   * Hardcoded file separator to workaround {@code JavaFileObjects.forResource(...)} defaulting to
+   * the unix one.
+   */
+  private static final String FILE_SEPARATOR = "/";
+  private static final String LINE_SEPARATOR = "\n";
+
+  private Util() {
+    // Utility class.
+  }
+
+  /**
+   * Returns the {@code String} from a system property that is expected to contain the project
+   * directory for the module containing these tests or {@code null} if we're not currently
+   * attempting to regenerate test resources.
+   */
+  static String getProjectRootIfRegeneratingTestResources() {
+    return System.getProperty(REGENERATE_TEST_RESOURCES_PROPERTY_NAME);
+  }
+
+  public static JavaFileObject emptyAppModule() {
+    return appResource("EmptyAppModule.java");
+  }
+
+  public static JavaFileObject emptyLibraryModule() {
+    return libraryResource("EmptyLibraryModule.java");
+  }
+
+  public static JavaFileObject appResource(String className) {
+    return forResource(DEFAULT_APP_DIR_NAME, className);
+  }
+
+  public static JavaFileObject libraryResource(String className) {
+    return forResource(DEFAULT_LIBRARY_DIR_NAME, className);
+  }
+
+  public static JavaFileObject forResource(String directoryName, String name) {
+    try {
+      return JavaFileObjects.forResource(directoryName + FILE_SEPARATOR + name);
+    } catch (IllegalArgumentException e) {
+      // IllegalArgumentException will be thrown if the resource is missing. If we're trying to
+      // generate test resources for a new test, we want to avoid this exception because it does not
+      // contain any expected output that we can write to a file. By returning an empty file, we
+      // avoid the exception and get the output from our comparison tests that we can then write
+      // out.
+      // If we're not regenerating test resources, we should throw the normal exception.
+      if (getProjectRootIfRegeneratingTestResources() != null) {
+        return JavaFileObjects.forSourceString("com.bumptech.test.empty", "");
+      }
+      throw e;
+    }
+  }
+
+  public static String annotation(String className) {
+    return qualified(ANNOTATION_PACKAGE_NAME, className);
+  }
+
+  public static String subpackage(String className) {
+    return qualified(SUB_PACKAGE_NAME, className);
+  }
+
+  public static String glide(String className) {
+    return qualified(GLIDE_PACKAGE_NAME, className);
+  }
+
+  public static CharSequence asUnixChars(CharSequence chars) {
+    return chars.toString().replace(System.lineSeparator(), LINE_SEPARATOR);
+  }
+
+  private static String qualified(String packageName, String className) {
+    return packageName + '.' + className;
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/AppModuleWithExcludes.java b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/AppModuleWithExcludes.java
new file mode 100644
index 000000000..579bb5ab3
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/AppModuleWithExcludes.java
@@ -0,0 +1,10 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.Excludes;
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
+import com.bumptech.glide.test.EmptyLibraryModule;
+
+@GlideModule
+@Excludes(EmptyLibraryModule.class)
+public final class AppModuleWithExcludes extends AppGlideModule {}
\ No newline at end of file
diff --git a/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java
new file mode 100644
index 000000000..ecb3b4b05
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java
@@ -0,0 +1,54 @@
+package com.bumptech.glide;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.util.Log;
+import com.bumptech.glide.test.AppModuleWithExcludes;
+import java.lang.Class;
+import java.lang.Override;
+import java.lang.SuppressWarnings;
+import java.util.HashSet;
+import java.util.Set;
+
+@SuppressWarnings("deprecation")
+final class GeneratedAppGlideModuleImpl extends GeneratedAppGlideModule {
+  private final AppModuleWithExcludes appGlideModule;
+
+  GeneratedAppGlideModuleImpl() {
+    appGlideModule = new AppModuleWithExcludes();
+    if (Log.isLoggable("Glide", Log.DEBUG)) {
+      Log.d("Glide", "Discovered AppGlideModule from annotation: com.bumptech.glide.test.AppModuleWithExcludes");
+      Log.d("Glide", "AppGlideModule excludes LibraryGlideModule from annotation: com.bumptech.glide.test.EmptyLibraryModule");
+    }
+  }
+
+  @Override
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
+    appGlideModule.applyOptions(context, builder);
+  }
+
+  @Override
+  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry) {
+    appGlideModule.registerComponents(context, glide, registry);
+  }
+
+  @Override
+  public boolean isManifestParsingEnabled() {
+    return appGlideModule.isManifestParsingEnabled();
+  }
+
+  @Override
+  @NonNull
+  public Set<Class<?>> getExcludedModuleClasses() {
+    Set<Class<?>> excludedClasses = new HashSet<Class<?>>();
+    excludedClasses.add(com.bumptech.glide.test.EmptyLibraryModule.class);
+    return excludedClasses;
+  }
+
+  @Override
+  @NonNull
+  GeneratedRequestManagerFactory getRequestManagerFactory() {
+    return new GeneratedRequestManagerFactory();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/AppModuleWithMultipleExcludes.java b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/AppModuleWithMultipleExcludes.java
new file mode 100644
index 000000000..c530727e1
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/AppModuleWithMultipleExcludes.java
@@ -0,0 +1,11 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.Excludes;
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
+import com.bumptech.glide.test.EmptyLibraryModule1;
+import com.bumptech.glide.test.EmptyLibraryModule2;
+
+@GlideModule
+@Excludes({EmptyLibraryModule1.class, EmptyLibraryModule2.class})
+public final class AppModuleWithMultipleExcludes extends AppGlideModule {}
\ No newline at end of file
diff --git a/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/EmptyLibraryModule1.java b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/EmptyLibraryModule1.java
new file mode 100644
index 000000000..236008a91
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/EmptyLibraryModule1.java
@@ -0,0 +1,7 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.LibraryGlideModule;
+
+@GlideModule
+public final class EmptyLibraryModule1 extends LibraryGlideModule {}
diff --git a/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/EmptyLibraryModule2.java b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/EmptyLibraryModule2.java
new file mode 100644
index 000000000..8a43eb292
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/EmptyLibraryModule2.java
@@ -0,0 +1,7 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.LibraryGlideModule;
+
+@GlideModule
+public final class EmptyLibraryModule2 extends LibraryGlideModule {}
diff --git a/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/GeneratedAppGlideModuleImpl.java b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/GeneratedAppGlideModuleImpl.java
new file mode 100644
index 000000000..af059c6b1
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/GeneratedAppGlideModuleImpl.java
@@ -0,0 +1,56 @@
+package com.bumptech.glide;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.util.Log;
+import com.bumptech.glide.test.AppModuleWithMultipleExcludes;
+import java.lang.Class;
+import java.lang.Override;
+import java.lang.SuppressWarnings;
+import java.util.HashSet;
+import java.util.Set;
+
+@SuppressWarnings("deprecation")
+final class GeneratedAppGlideModuleImpl extends GeneratedAppGlideModule {
+  private final AppModuleWithMultipleExcludes appGlideModule;
+
+  GeneratedAppGlideModuleImpl() {
+    appGlideModule = new AppModuleWithMultipleExcludes();
+    if (Log.isLoggable("Glide", Log.DEBUG)) {
+      Log.d("Glide", "Discovered AppGlideModule from annotation: com.bumptech.glide.test.AppModuleWithMultipleExcludes");
+      Log.d("Glide", "AppGlideModule excludes LibraryGlideModule from annotation: com.bumptech.glide.test.EmptyLibraryModule1");
+      Log.d("Glide", "AppGlideModule excludes LibraryGlideModule from annotation: com.bumptech.glide.test.EmptyLibraryModule2");
+    }
+  }
+
+  @Override
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
+    appGlideModule.applyOptions(context, builder);
+  }
+
+  @Override
+  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry) {
+    appGlideModule.registerComponents(context, glide, registry);
+  }
+
+  @Override
+  public boolean isManifestParsingEnabled() {
+    return appGlideModule.isManifestParsingEnabled();
+  }
+
+  @Override
+  @NonNull
+  public Set<Class<?>> getExcludedModuleClasses() {
+    Set<Class<?>> excludedClasses = new HashSet<Class<?>>();
+    excludedClasses.add(com.bumptech.glide.test.EmptyLibraryModule1.class);
+    excludedClasses.add(com.bumptech.glide.test.EmptyLibraryModule2.class);
+    return excludedClasses;
+  }
+
+  @Override
+  @NonNull
+  GeneratedRequestManagerFactory getRequestManagerFactory() {
+    return new GeneratedRequestManagerFactory();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppAndLibraryGlideModulesTest/GeneratedAppGlideModuleImpl.java b/annotation/compiler/test/src/test/resources/EmptyAppAndLibraryGlideModulesTest/GeneratedAppGlideModuleImpl.java
new file mode 100644
index 000000000..6e307e0ff
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyAppAndLibraryGlideModulesTest/GeneratedAppGlideModuleImpl.java
@@ -0,0 +1,54 @@
+package com.bumptech.glide;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.util.Log;
+import com.bumptech.glide.test.EmptyAppModule;
+import com.bumptech.glide.test.EmptyLibraryModule;
+import java.lang.Class;
+import java.lang.Override;
+import java.lang.SuppressWarnings;
+import java.util.Collections;
+import java.util.Set;
+
+@SuppressWarnings("deprecation")
+final class GeneratedAppGlideModuleImpl extends GeneratedAppGlideModule {
+  private final EmptyAppModule appGlideModule;
+
+  GeneratedAppGlideModuleImpl() {
+    appGlideModule = new EmptyAppModule();
+    if (Log.isLoggable("Glide", Log.DEBUG)) {
+      Log.d("Glide", "Discovered AppGlideModule from annotation: com.bumptech.glide.test.EmptyAppModule");
+      Log.d("Glide", "Discovered LibraryGlideModule from annotation: com.bumptech.glide.test.EmptyLibraryModule");
+    }
+  }
+
+  @Override
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
+    appGlideModule.applyOptions(context, builder);
+  }
+
+  @Override
+  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry) {
+    new EmptyLibraryModule().registerComponents(context, glide, registry);
+    appGlideModule.registerComponents(context, glide, registry);
+  }
+
+  @Override
+  public boolean isManifestParsingEnabled() {
+    return appGlideModule.isManifestParsingEnabled();
+  }
+
+  @Override
+  @NonNull
+  public Set<Class<?>> getExcludedModuleClasses() {
+    return Collections.emptySet();
+  }
+
+  @Override
+  @NonNull
+  GeneratedRequestManagerFactory getRequestManagerFactory() {
+    return new GeneratedRequestManagerFactory();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/EmptyAppModule.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/EmptyAppModule.java
new file mode 100644
index 000000000..203f9df63
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/EmptyAppModule.java
@@ -0,0 +1,7 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
+
+@GlideModule
+public final class EmptyAppModule extends AppGlideModule {}
\ No newline at end of file
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedAppGlideModuleImpl.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedAppGlideModuleImpl.java
new file mode 100644
index 000000000..f960738d9
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedAppGlideModuleImpl.java
@@ -0,0 +1,51 @@
+package com.bumptech.glide;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.util.Log;
+import com.bumptech.glide.test.EmptyAppModule;
+import java.lang.Class;
+import java.lang.Override;
+import java.lang.SuppressWarnings;
+import java.util.Collections;
+import java.util.Set;
+
+@SuppressWarnings("deprecation")
+final class GeneratedAppGlideModuleImpl extends GeneratedAppGlideModule {
+  private final EmptyAppModule appGlideModule;
+
+  GeneratedAppGlideModuleImpl() {
+    appGlideModule = new EmptyAppModule();
+    if (Log.isLoggable("Glide", Log.DEBUG)) {
+      Log.d("Glide", "Discovered AppGlideModule from annotation: com.bumptech.glide.test.EmptyAppModule");
+    }
+  }
+
+  @Override
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
+    appGlideModule.applyOptions(context, builder);
+  }
+
+  @Override
+  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry) {
+    appGlideModule.registerComponents(context, glide, registry);
+  }
+
+  @Override
+  public boolean isManifestParsingEnabled() {
+    return appGlideModule.isManifestParsingEnabled();
+  }
+
+  @Override
+  @NonNull
+  public Set<Class<?>> getExcludedModuleClasses() {
+    return Collections.emptySet();
+  }
+
+  @Override
+  @NonNull
+  GeneratedRequestManagerFactory getRequestManagerFactory() {
+    return new GeneratedRequestManagerFactory();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedRequestManagerFactory.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedRequestManagerFactory.java
new file mode 100644
index 000000000..2a442b0a5
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedRequestManagerFactory.java
@@ -0,0 +1,21 @@
+package com.bumptech.glide;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import com.bumptech.glide.manager.Lifecycle;
+import com.bumptech.glide.manager.RequestManagerRetriever;
+import com.bumptech.glide.manager.RequestManagerTreeNode;
+import com.bumptech.glide.test.GlideRequests;
+import java.lang.Override;
+
+/**
+ * Generated code, do not modify
+ */
+final class GeneratedRequestManagerFactory implements RequestManagerRetriever.RequestManagerFactory {
+  @Override
+  @NonNull
+  public RequestManager build(@NonNull Glide glide, @NonNull Lifecycle lifecycle,
+      @NonNull RequestManagerTreeNode treeNode, @NonNull Context context) {
+    return new GlideRequests(glide, lifecycle, treeNode, context);
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideApp.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideApp.java
new file mode 100644
index 000000000..4a1e8e108
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideApp.java
@@ -0,0 +1,130 @@
+package com.bumptech.glide.test;
+
+import android.annotation.SuppressLint;
+import android.app.Activity;
+import android.app.Fragment;
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
+import android.support.v4.app.FragmentActivity;
+import android.view.View;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
+import java.io.File;
+import java.lang.Deprecated;
+import java.lang.String;
+
+/**
+ * The entry point for interacting with Glide for Applications
+ *
+ * <p>Includes all generated APIs from all
+ * {@link com.bumptech.glide.annotation.GlideExtension}s in source and dependent libraries.
+ *
+ * <p>This class is generated and should not be modified
+ * @see Glide
+ */
+public final class GlideApp {
+  private GlideApp() {
+  }
+
+  /**
+   * @see Glide#getPhotoCacheDir(Context)
+   */
+  @Nullable
+  public static File getPhotoCacheDir(@NonNull Context arg0) {
+    return Glide.getPhotoCacheDir(arg0);
+  }
+
+  /**
+   * @see Glide#getPhotoCacheDir(Context, String)
+   */
+  @Nullable
+  public static File getPhotoCacheDir(@NonNull Context arg0, @NonNull String arg1) {
+    return Glide.getPhotoCacheDir(arg0, arg1);
+  }
+
+  /**
+   * @see Glide#get(Context)
+   */
+  @NonNull
+  public static Glide get(@NonNull Context arg0) {
+    return Glide.get(arg0);
+  }
+
+  /**
+   * @see Glide#init(Glide)
+   */
+  @Deprecated
+  @VisibleForTesting
+  @SuppressLint("VisibleForTests")
+  public static void init(Glide glide) {
+    Glide.init(glide);
+  }
+
+  /**
+   * @see Glide#init(Context, GlideBuilder)
+   */
+  @VisibleForTesting
+  @SuppressLint("VisibleForTests")
+  public static void init(@NonNull Context arg0, @NonNull GlideBuilder arg1) {
+    Glide.init(arg0, arg1);
+  }
+
+  /**
+   * @see Glide#tearDown()
+   */
+  @VisibleForTesting
+  @SuppressLint("VisibleForTests")
+  public static void tearDown() {
+    Glide.tearDown();
+  }
+
+  /**
+   * @see Glide#with(Context)
+   */
+  @NonNull
+  public static GlideRequests with(@NonNull Context arg0) {
+    return (GlideRequests) Glide.with(arg0);
+  }
+
+  /**
+   * @see Glide#with(Activity)
+   */
+  @NonNull
+  public static GlideRequests with(@NonNull Activity arg0) {
+    return (GlideRequests) Glide.with(arg0);
+  }
+
+  /**
+   * @see Glide#with(FragmentActivity)
+   */
+  @NonNull
+  public static GlideRequests with(@NonNull FragmentActivity arg0) {
+    return (GlideRequests) Glide.with(arg0);
+  }
+
+  /**
+   * @see Glide#with(Fragment)
+   */
+  @NonNull
+  public static GlideRequests with(@NonNull Fragment arg0) {
+    return (GlideRequests) Glide.with(arg0);
+  }
+
+  /**
+   * @see Glide#with(Fragment)
+   */
+  @NonNull
+  public static GlideRequests with(@NonNull android.support.v4.app.Fragment arg0) {
+    return (GlideRequests) Glide.with(arg0);
+  }
+
+  /**
+   * @see Glide#with(View)
+   */
+  @NonNull
+  public static GlideRequests with(@NonNull View arg0) {
+    return (GlideRequests) Glide.with(arg0);
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideOptions.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideOptions.java
new file mode 100644
index 000000000..9b92b8ab4
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideOptions.java
@@ -0,0 +1,618 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return new GlideOptions().sizeMultiplier(arg0);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy arg0) {
+    return new GlideOptions().diskCacheStrategy(arg0);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority arg0) {
+    return new GlideOptions().priority(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0,
+      @IntRange(from = 0) int arg1) {
+    return new GlideOptions().override(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().override(arg0);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key arg0) {
+    return new GlideOptions().signature(arg0);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> arg0) {
+    return new GlideOptions().transform(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return new GlideOptions().set(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> arg0) {
+    return new GlideOptions().decode(arg0);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat arg0) {
+    return new GlideOptions().format(arg0);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long arg0) {
+    return new GlideOptions().frame(arg0);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy arg0) {
+    return new GlideOptions().downsample(arg0);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().timeout(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int arg0) {
+    return new GlideOptions().encodeQuality(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat arg0) {
+    return new GlideOptions().encodeFormat(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return (GlideOptions) super.sizeMultiplier(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    return (GlideOptions) super.diskCacheStrategy(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions priority(@NonNull Priority arg0) {
+    return (GlideOptions) super.priority(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@Nullable Drawable arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@DrawableRes int arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@Nullable Drawable arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@DrawableRes int arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@Nullable Drawable arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@DrawableRes int arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions theme(@Nullable Resources.Theme arg0) {
+    return (GlideOptions) super.theme(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions signature(@NonNull Key arg0) {
+    return (GlideOptions) super.signature(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public final GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return (GlideOptions) super.set(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions decode(@NonNull Class<?> arg0) {
+    return (GlideOptions) super.decode(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    return (GlideOptions) super.encodeFormat(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    return (GlideOptions) super.encodeQuality(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions frame(@IntRange(from = 0) long arg0) {
+    return (GlideOptions) super.frame(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions format(@NonNull DecodeFormat arg0) {
+    return (GlideOptions) super.format(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions downsample(@NonNull DownsampleStrategy arg0) {
+    return (GlideOptions) super.downsample(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions timeout(@IntRange(from = 0) int arg0) {
+    return (GlideOptions) super.timeout(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.transform(arg0);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... arg0) {
+    return (GlideOptions) super.transforms(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.optionalTransform(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.optionalTransform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions transform(@NonNull Class<T> arg0, @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.transform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions apply(@NonNull RequestOptions arg0) {
+    return (GlideOptions) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequest.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequest.java
new file mode 100644
index 000000000..00c6c5d7a
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequest.java
@@ -0,0 +1,770 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).sizeMultiplier(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).sizeMultiplier(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useUnlimitedSourceGeneratorsPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useUnlimitedSourceGeneratorsPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useAnimationPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useAnimationPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).onlyRetrieveFromCache(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).onlyRetrieveFromCache(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).diskCacheStrategy(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).diskCacheStrategy(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).priority(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).priority(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).theme(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).theme(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).skipMemoryCache(skip);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).skipMemoryCache(skip);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(width, height);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(width, height);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(size);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(size);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).signature(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).signature(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#set(Option<T>, T)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).set(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).set(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).decode(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).decode(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeFormat(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeFormat(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeQuality(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeQuality(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).frame(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).frame(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).format(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).format(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).disallowHardwareConfig();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).disallowHardwareConfig();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).downsample(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).downsample(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).timeout(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).timeout(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalFitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalFitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCircleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCircleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).circleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).circleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transforms(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transforms(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> transform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontTransform();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontTransform();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontAnimate();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontAnimate();
+    }
+    return this;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull RequestOptions arg0) {
+    return (GlideRequest<TranscodeType>) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.transition(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.listener(arg0);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java
new file mode 100644
index 000000000..7824b67f9
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java
@@ -0,0 +1,171 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
+import com.bumptech.glide.manager.Lifecycle;
+import com.bumptech.glide.manager.RequestManagerTreeNode;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Includes all additions from methods in {@link com.bumptech.glide.annotation.GlideExtension}s
+ * annotated with {@link com.bumptech.glide.annotation.GlideType}
+ *
+ * <p>Generated code, do not modify
+ */
+@SuppressWarnings("deprecation")
+public class GlideRequests extends RequestManager {
+  public GlideRequests(@NonNull Glide glide, @NonNull Lifecycle lifecycle,
+      @NonNull RequestManagerTreeNode treeNode, @NonNull Context context) {
+    super(glide, lifecycle, treeNode, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  public <ResourceType> GlideRequest<ResourceType> as(@NonNull Class<ResourceType> resourceClass) {
+    return new GlideRequest<>(glide, this, resourceClass, context);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequests applyDefaultRequestOptions(@NonNull RequestOptions arg0) {
+    return (GlideRequests) super.applyDefaultRequestOptions(arg0);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequests setDefaultRequestOptions(@NonNull RequestOptions arg0) {
+    return (GlideRequests) super.setDefaultRequestOptions(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Bitmap> asBitmap() {
+    return (GlideRequest<Bitmap>) super.asBitmap();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<GifDrawable> asGif() {
+    return (GlideRequest<GifDrawable>) super.asGif();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> asDrawable() {
+    return (GlideRequest<Drawable>) super.asDrawable();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Bitmap arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Drawable arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable String arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Uri arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable File arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Integer arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable URL arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable byte[] arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Object arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<File> downloadOnly() {
+    return (GlideRequest<File>) super.downloadOnly();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<File> download(@Nullable Object arg0) {
+    return (GlideRequest<File>) super.download(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<File> asFile() {
+    return (GlideRequest<File>) super.asFile();
+  }
+
+  @Override
+  protected void setRequestOptions(@NonNull RequestOptions toSet) {
+    if (toSet instanceof com.bumptech.glide.test.GlideOptions) {
+      super.setRequestOptions(toSet);
+    } else {
+      super.setRequestOptions(new com.bumptech.glide.test.GlideOptions().apply(toSet));
+    }
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/EmptyLibraryGlideModuleTest/EmptyLibraryModule.java b/annotation/compiler/test/src/test/resources/EmptyLibraryGlideModuleTest/EmptyLibraryModule.java
new file mode 100644
index 000000000..60ad52260
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyLibraryGlideModuleTest/EmptyLibraryModule.java
@@ -0,0 +1,7 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.LibraryGlideModule;
+
+@GlideModule
+public final class EmptyLibraryModule extends LibraryGlideModule {}
diff --git a/annotation/compiler/test/src/test/resources/EmptyLibraryGlideModuleTest/GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule.java b/annotation/compiler/test/src/test/resources/EmptyLibraryGlideModuleTest/GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule.java
new file mode 100644
index 000000000..b18a61cd1
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyLibraryGlideModuleTest/GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule.java
@@ -0,0 +1,7 @@
+package com.bumptech.glide.annotation.compiler;
+
+@Index(
+    modules = "com.bumptech.glide.test.EmptyLibraryModule"
+)
+public class GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule {
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/Extension.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/Extension.java
new file mode 100644
index 000000000..05cf8447b
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/Extension.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.test;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.RequestOptions;
+
+@GlideExtension
+public final class Extension {
+
+  private Extension() {
+    // Utility class.
+  }
+
+  @NonNull
+  @GlideOption(memoizeStaticMethod = true)
+  public static RequestOptions test(RequestOptions requestOptions) {
+    return requestOptions.centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java
new file mode 100644
index 000000000..bd161674f
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java
@@ -0,0 +1,642 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see Extension
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform1;
+
+  private static GlideOptions centerInsideTransform2;
+
+  private static GlideOptions centerCropTransform3;
+
+  private static GlideOptions circleCropTransform4;
+
+  private static GlideOptions noTransformation5;
+
+  private static GlideOptions noAnimation6;
+
+  private static GlideOptions testOf0;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return new GlideOptions().sizeMultiplier(arg0);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy arg0) {
+    return new GlideOptions().diskCacheStrategy(arg0);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority arg0) {
+    return new GlideOptions().priority(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0,
+      @IntRange(from = 0) int arg1) {
+    return new GlideOptions().override(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().override(arg0);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key arg0) {
+    return new GlideOptions().signature(arg0);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform1 == null) {
+      GlideOptions.fitCenterTransform1 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform2 == null) {
+      GlideOptions.centerInsideTransform2 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform2;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform3 == null) {
+      GlideOptions.centerCropTransform3 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform4 == null) {
+      GlideOptions.circleCropTransform4 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform4;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> arg0) {
+    return new GlideOptions().transform(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation5 == null) {
+      GlideOptions.noTransformation5 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation5;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return new GlideOptions().set(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> arg0) {
+    return new GlideOptions().decode(arg0);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat arg0) {
+    return new GlideOptions().format(arg0);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long arg0) {
+    return new GlideOptions().frame(arg0);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy arg0) {
+    return new GlideOptions().downsample(arg0);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().timeout(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int arg0) {
+    return new GlideOptions().encodeQuality(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat arg0) {
+    return new GlideOptions().encodeFormat(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation6 == null) {
+      GlideOptions.noAnimation6 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation6;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return (GlideOptions) super.sizeMultiplier(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    return (GlideOptions) super.diskCacheStrategy(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions priority(@NonNull Priority arg0) {
+    return (GlideOptions) super.priority(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@Nullable Drawable arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@DrawableRes int arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@Nullable Drawable arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@DrawableRes int arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@Nullable Drawable arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@DrawableRes int arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions theme(@Nullable Resources.Theme arg0) {
+    return (GlideOptions) super.theme(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions signature(@NonNull Key arg0) {
+    return (GlideOptions) super.signature(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public final GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return (GlideOptions) super.set(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions decode(@NonNull Class<?> arg0) {
+    return (GlideOptions) super.decode(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    return (GlideOptions) super.encodeFormat(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    return (GlideOptions) super.encodeQuality(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions frame(@IntRange(from = 0) long arg0) {
+    return (GlideOptions) super.frame(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions format(@NonNull DecodeFormat arg0) {
+    return (GlideOptions) super.format(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions downsample(@NonNull DownsampleStrategy arg0) {
+    return (GlideOptions) super.downsample(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions timeout(@IntRange(from = 0) int arg0) {
+    return (GlideOptions) super.timeout(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.transform(arg0);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... arg0) {
+    return (GlideOptions) super.transforms(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.optionalTransform(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.optionalTransform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions transform(@NonNull Class<T> arg0, @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.transform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions apply(@NonNull RequestOptions arg0) {
+    return (GlideOptions) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see Extension#test(RequestOptions)
+   */
+  @CheckResult
+  @NonNull
+  public GlideOptions test() {
+    return (GlideOptions) Extension.test(this);
+  }
+
+  /**
+   * @see Extension#test(RequestOptions)
+   */
+  @CheckResult
+  public static GlideOptions testOf() {
+    if (GlideOptions.testOf0 == null) {
+      GlideOptions.testOf0 =
+          new GlideOptions().test().autoClone();
+    }
+    return GlideOptions.testOf0;
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java
new file mode 100644
index 000000000..ca9ea8813
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java
@@ -0,0 +1,784 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).sizeMultiplier(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).sizeMultiplier(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useUnlimitedSourceGeneratorsPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useUnlimitedSourceGeneratorsPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useAnimationPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useAnimationPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).onlyRetrieveFromCache(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).onlyRetrieveFromCache(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).diskCacheStrategy(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).diskCacheStrategy(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).priority(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).priority(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).theme(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).theme(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).skipMemoryCache(skip);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).skipMemoryCache(skip);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(width, height);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(width, height);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(size);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(size);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).signature(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).signature(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#set(Option<T>, T)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).set(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).set(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).decode(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).decode(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeFormat(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeFormat(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeQuality(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeQuality(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).frame(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).frame(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).format(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).format(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).disallowHardwareConfig();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).disallowHardwareConfig();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).downsample(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).downsample(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).timeout(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).timeout(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalFitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalFitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCircleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCircleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).circleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).circleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transforms(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transforms(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> transform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontTransform();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontTransform();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontAnimate();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontAnimate();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#test()
+   */
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> test() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).test();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).test();
+    }
+    return this;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull RequestOptions arg0) {
+    return (GlideRequest<TranscodeType>) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.transition(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.listener(arg0);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/Extension.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/Extension.java
new file mode 100644
index 000000000..b11fe757f
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/Extension.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.test;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.RequestOptions;
+
+@GlideExtension
+public final class Extension {
+
+  private Extension() {
+    // Utility class.
+  }
+
+  @NonNull
+  @GlideOption(override = GlideOption.OVERRIDE_EXTEND)
+  public static RequestOptions centerCrop(RequestOptions requestOptions) {
+    return requestOptions.centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideOptions.java
new file mode 100644
index 000000000..5043b0d98
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideOptions.java
@@ -0,0 +1,631 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see Extension
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return new GlideOptions().sizeMultiplier(arg0);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy arg0) {
+    return new GlideOptions().diskCacheStrategy(arg0);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority arg0) {
+    return new GlideOptions().priority(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0,
+      @IntRange(from = 0) int arg1) {
+    return new GlideOptions().override(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().override(arg0);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key arg0) {
+    return new GlideOptions().signature(arg0);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> arg0) {
+    return new GlideOptions().transform(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return new GlideOptions().set(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> arg0) {
+    return new GlideOptions().decode(arg0);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat arg0) {
+    return new GlideOptions().format(arg0);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long arg0) {
+    return new GlideOptions().frame(arg0);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy arg0) {
+    return new GlideOptions().downsample(arg0);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().timeout(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int arg0) {
+    return new GlideOptions().encodeQuality(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat arg0) {
+    return new GlideOptions().encodeFormat(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return (GlideOptions) super.sizeMultiplier(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    return (GlideOptions) super.diskCacheStrategy(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions priority(@NonNull Priority arg0) {
+    return (GlideOptions) super.priority(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@Nullable Drawable arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@DrawableRes int arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@Nullable Drawable arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@DrawableRes int arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@Nullable Drawable arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@DrawableRes int arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions theme(@Nullable Resources.Theme arg0) {
+    return (GlideOptions) super.theme(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions signature(@NonNull Key arg0) {
+    return (GlideOptions) super.signature(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public final GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return (GlideOptions) super.set(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions decode(@NonNull Class<?> arg0) {
+    return (GlideOptions) super.decode(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    return (GlideOptions) super.encodeFormat(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    return (GlideOptions) super.encodeQuality(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions frame(@IntRange(from = 0) long arg0) {
+    return (GlideOptions) super.frame(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions format(@NonNull DecodeFormat arg0) {
+    return (GlideOptions) super.format(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions downsample(@NonNull DownsampleStrategy arg0) {
+    return (GlideOptions) super.downsample(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions timeout(@IntRange(from = 0) int arg0) {
+    return (GlideOptions) super.timeout(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.transform(arg0);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... arg0) {
+    return (GlideOptions) super.transforms(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.optionalTransform(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.optionalTransform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions transform(@NonNull Class<T> arg0, @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.transform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions apply(@NonNull RequestOptions arg0) {
+    return (GlideOptions) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see Extension#centerCrop(RequestOptions)
+   * @see RequestOptions#centerCrop()
+   */
+  @Override
+  @CheckResult
+  @NonNull
+  public GlideOptions centerCrop() {
+    return (GlideOptions) Extension.centerCrop(super.centerCrop());
+  }
+
+  /**
+   * @see Extension#centerCrop(RequestOptions)
+   */
+  @CheckResult
+  public static GlideOptions centerCropOf() {
+    return new GlideOptions().centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideRequest.java
new file mode 100644
index 000000000..6179c1263
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideRequest.java
@@ -0,0 +1,770 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).sizeMultiplier(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).sizeMultiplier(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useUnlimitedSourceGeneratorsPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useUnlimitedSourceGeneratorsPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useAnimationPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useAnimationPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).onlyRetrieveFromCache(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).onlyRetrieveFromCache(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).diskCacheStrategy(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).diskCacheStrategy(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).priority(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).priority(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).theme(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).theme(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).skipMemoryCache(skip);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).skipMemoryCache(skip);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(width, height);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(width, height);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(size);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(size);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).signature(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).signature(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#set(Option<T>, T)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).set(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).set(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).decode(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).decode(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeFormat(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeFormat(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeQuality(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeQuality(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).frame(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).frame(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).format(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).format(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).disallowHardwareConfig();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).disallowHardwareConfig();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).downsample(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).downsample(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).timeout(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).timeout(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalFitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalFitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCircleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCircleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).circleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).circleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transforms(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transforms(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> transform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontTransform();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontTransform();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontAnimate();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontAnimate();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> centerCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerCrop();
+    }
+    return this;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull RequestOptions arg0) {
+    return (GlideRequest<TranscodeType>) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.transition(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.listener(arg0);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/Extension.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/Extension.java
new file mode 100644
index 000000000..a0be8a2c3
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/Extension.java
@@ -0,0 +1,22 @@
+package com.bumptech.glide.test;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.RequestOptions;
+
+@GlideExtension
+public final class Extension {
+
+  private Extension() {
+    // Utility class.
+  }
+
+  @NonNull
+  @GlideOption(override = GlideOption.OVERRIDE_EXTEND)
+  public static RequestOptions override(RequestOptions requestOptions, int width, int height) {
+    return requestOptions
+        .override(width, height)
+        .centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideOptions.java
new file mode 100644
index 000000000..be6e957ad
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideOptions.java
@@ -0,0 +1,621 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see Extension
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return new GlideOptions().sizeMultiplier(arg0);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy arg0) {
+    return new GlideOptions().diskCacheStrategy(arg0);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority arg0) {
+    return new GlideOptions().priority(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().override(arg0);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key arg0) {
+    return new GlideOptions().signature(arg0);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> arg0) {
+    return new GlideOptions().transform(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return new GlideOptions().set(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> arg0) {
+    return new GlideOptions().decode(arg0);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat arg0) {
+    return new GlideOptions().format(arg0);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long arg0) {
+    return new GlideOptions().frame(arg0);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy arg0) {
+    return new GlideOptions().downsample(arg0);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().timeout(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int arg0) {
+    return new GlideOptions().encodeQuality(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat arg0) {
+    return new GlideOptions().encodeFormat(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return (GlideOptions) super.sizeMultiplier(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    return (GlideOptions) super.diskCacheStrategy(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions priority(@NonNull Priority arg0) {
+    return (GlideOptions) super.priority(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@Nullable Drawable arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@DrawableRes int arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@Nullable Drawable arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@DrawableRes int arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@Nullable Drawable arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@DrawableRes int arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions theme(@Nullable Resources.Theme arg0) {
+    return (GlideOptions) super.theme(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions signature(@NonNull Key arg0) {
+    return (GlideOptions) super.signature(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public final GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return (GlideOptions) super.set(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions decode(@NonNull Class<?> arg0) {
+    return (GlideOptions) super.decode(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    return (GlideOptions) super.encodeFormat(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    return (GlideOptions) super.encodeQuality(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions frame(@IntRange(from = 0) long arg0) {
+    return (GlideOptions) super.frame(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions format(@NonNull DecodeFormat arg0) {
+    return (GlideOptions) super.format(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions downsample(@NonNull DownsampleStrategy arg0) {
+    return (GlideOptions) super.downsample(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions timeout(@IntRange(from = 0) int arg0) {
+    return (GlideOptions) super.timeout(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.transform(arg0);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... arg0) {
+    return (GlideOptions) super.transforms(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.optionalTransform(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.optionalTransform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions transform(@NonNull Class<T> arg0, @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.transform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions apply(@NonNull RequestOptions arg0) {
+    return (GlideOptions) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see Extension#override(RequestOptions, int, int)
+   * @see RequestOptions#override(int, int)
+   */
+  @Override
+  @CheckResult
+  @NonNull
+  public GlideOptions override(int width, int height) {
+    return (GlideOptions) Extension.override(super.override(width, height), width, height);
+  }
+
+  /**
+   * @see Extension#override(RequestOptions, int, int)
+   */
+  @CheckResult
+  public static GlideOptions overrideOf(int width, int height) {
+    return new GlideOptions().override(width, height);
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideRequest.java
new file mode 100644
index 000000000..ff1366641
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideRequest.java
@@ -0,0 +1,770 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).sizeMultiplier(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).sizeMultiplier(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useUnlimitedSourceGeneratorsPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useUnlimitedSourceGeneratorsPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useAnimationPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useAnimationPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).onlyRetrieveFromCache(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).onlyRetrieveFromCache(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).diskCacheStrategy(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).diskCacheStrategy(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).priority(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).priority(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).theme(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).theme(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).skipMemoryCache(skip);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).skipMemoryCache(skip);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(size);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(size);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).signature(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).signature(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#set(Option<T>, T)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).set(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).set(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).decode(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).decode(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeFormat(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeFormat(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeQuality(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeQuality(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).frame(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).frame(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).format(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).format(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).disallowHardwareConfig();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).disallowHardwareConfig();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).downsample(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).downsample(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).timeout(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).timeout(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalFitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalFitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCircleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCircleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).circleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).circleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transforms(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transforms(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> transform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontTransform();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontTransform();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontAnimate();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontAnimate();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(width, height);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(width, height);
+    }
+    return this;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull RequestOptions arg0) {
+    return (GlideRequest<TranscodeType>) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.transition(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.listener(arg0);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/Extension.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/Extension.java
new file mode 100644
index 000000000..78d91590f
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/Extension.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.test;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.RequestOptions;
+
+@GlideExtension
+public final class Extension {
+
+  private Extension() {
+    // Utility class.
+  }
+
+  @NonNull
+  @GlideOption(override = GlideOption.OVERRIDE_REPLACE)
+  public static RequestOptions centerCrop(RequestOptions requestOptions) {
+    return requestOptions.centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideOptions.java
new file mode 100644
index 000000000..8d0696027
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideOptions.java
@@ -0,0 +1,629 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see Extension
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return new GlideOptions().sizeMultiplier(arg0);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy arg0) {
+    return new GlideOptions().diskCacheStrategy(arg0);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority arg0) {
+    return new GlideOptions().priority(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0,
+      @IntRange(from = 0) int arg1) {
+    return new GlideOptions().override(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().override(arg0);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key arg0) {
+    return new GlideOptions().signature(arg0);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> arg0) {
+    return new GlideOptions().transform(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return new GlideOptions().set(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> arg0) {
+    return new GlideOptions().decode(arg0);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat arg0) {
+    return new GlideOptions().format(arg0);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long arg0) {
+    return new GlideOptions().frame(arg0);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy arg0) {
+    return new GlideOptions().downsample(arg0);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().timeout(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int arg0) {
+    return new GlideOptions().encodeQuality(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat arg0) {
+    return new GlideOptions().encodeFormat(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return (GlideOptions) super.sizeMultiplier(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    return (GlideOptions) super.diskCacheStrategy(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions priority(@NonNull Priority arg0) {
+    return (GlideOptions) super.priority(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@Nullable Drawable arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@DrawableRes int arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@Nullable Drawable arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@DrawableRes int arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@Nullable Drawable arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@DrawableRes int arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions theme(@Nullable Resources.Theme arg0) {
+    return (GlideOptions) super.theme(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions signature(@NonNull Key arg0) {
+    return (GlideOptions) super.signature(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public final GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return (GlideOptions) super.set(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions decode(@NonNull Class<?> arg0) {
+    return (GlideOptions) super.decode(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    return (GlideOptions) super.encodeFormat(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    return (GlideOptions) super.encodeQuality(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions frame(@IntRange(from = 0) long arg0) {
+    return (GlideOptions) super.frame(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions format(@NonNull DecodeFormat arg0) {
+    return (GlideOptions) super.format(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions downsample(@NonNull DownsampleStrategy arg0) {
+    return (GlideOptions) super.downsample(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions timeout(@IntRange(from = 0) int arg0) {
+    return (GlideOptions) super.timeout(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.transform(arg0);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... arg0) {
+    return (GlideOptions) super.transforms(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.optionalTransform(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.optionalTransform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions transform(@NonNull Class<T> arg0, @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.transform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions apply(@NonNull RequestOptions arg0) {
+    return (GlideOptions) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see Extension#centerCrop(RequestOptions)
+   */
+  @CheckResult
+  @NonNull
+  public GlideOptions centerCrop() {
+    return (GlideOptions) Extension.centerCrop(this);
+  }
+
+  /**
+   * @see Extension#centerCrop(RequestOptions)
+   */
+  @CheckResult
+  public static GlideOptions centerCropOf() {
+    return new GlideOptions().centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideRequest.java
new file mode 100644
index 000000000..6179c1263
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideRequest.java
@@ -0,0 +1,770 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).sizeMultiplier(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).sizeMultiplier(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useUnlimitedSourceGeneratorsPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useUnlimitedSourceGeneratorsPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useAnimationPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useAnimationPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).onlyRetrieveFromCache(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).onlyRetrieveFromCache(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).diskCacheStrategy(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).diskCacheStrategy(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).priority(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).priority(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).theme(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).theme(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).skipMemoryCache(skip);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).skipMemoryCache(skip);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(width, height);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(width, height);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(size);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(size);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).signature(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).signature(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#set(Option<T>, T)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).set(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).set(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).decode(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).decode(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeFormat(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeFormat(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeQuality(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeQuality(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).frame(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).frame(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).format(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).format(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).disallowHardwareConfig();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).disallowHardwareConfig();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).downsample(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).downsample(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).timeout(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).timeout(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalFitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalFitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCircleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCircleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).circleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).circleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transforms(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transforms(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> transform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontTransform();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontTransform();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontAnimate();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontAnimate();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> centerCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerCrop();
+    }
+    return this;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull RequestOptions arg0) {
+    return (GlideRequest<TranscodeType>) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.transition(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.listener(arg0);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/Extension.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/Extension.java
new file mode 100644
index 000000000..69db3bc0f
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/Extension.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.test;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.RequestOptions;
+
+@GlideExtension
+public final class Extension {
+
+  private Extension() {
+    // Utility class.
+  }
+
+  @NonNull
+  @GlideOption(skipStaticMethod = true)
+  public static RequestOptions test(RequestOptions requestOptions) {
+    return requestOptions.centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideOptions.java
new file mode 100644
index 000000000..74b45424d
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideOptions.java
@@ -0,0 +1,628 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see Extension
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return new GlideOptions().sizeMultiplier(arg0);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy arg0) {
+    return new GlideOptions().diskCacheStrategy(arg0);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority arg0) {
+    return new GlideOptions().priority(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0,
+      @IntRange(from = 0) int arg1) {
+    return new GlideOptions().override(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().override(arg0);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key arg0) {
+    return new GlideOptions().signature(arg0);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> arg0) {
+    return new GlideOptions().transform(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return new GlideOptions().set(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> arg0) {
+    return new GlideOptions().decode(arg0);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat arg0) {
+    return new GlideOptions().format(arg0);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long arg0) {
+    return new GlideOptions().frame(arg0);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy arg0) {
+    return new GlideOptions().downsample(arg0);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().timeout(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int arg0) {
+    return new GlideOptions().encodeQuality(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat arg0) {
+    return new GlideOptions().encodeFormat(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return (GlideOptions) super.sizeMultiplier(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    return (GlideOptions) super.diskCacheStrategy(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions priority(@NonNull Priority arg0) {
+    return (GlideOptions) super.priority(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@Nullable Drawable arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@DrawableRes int arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@Nullable Drawable arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@DrawableRes int arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@Nullable Drawable arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@DrawableRes int arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions theme(@Nullable Resources.Theme arg0) {
+    return (GlideOptions) super.theme(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions signature(@NonNull Key arg0) {
+    return (GlideOptions) super.signature(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public final GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return (GlideOptions) super.set(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions decode(@NonNull Class<?> arg0) {
+    return (GlideOptions) super.decode(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    return (GlideOptions) super.encodeFormat(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    return (GlideOptions) super.encodeQuality(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions frame(@IntRange(from = 0) long arg0) {
+    return (GlideOptions) super.frame(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions format(@NonNull DecodeFormat arg0) {
+    return (GlideOptions) super.format(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions downsample(@NonNull DownsampleStrategy arg0) {
+    return (GlideOptions) super.downsample(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions timeout(@IntRange(from = 0) int arg0) {
+    return (GlideOptions) super.timeout(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.transform(arg0);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... arg0) {
+    return (GlideOptions) super.transforms(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.optionalTransform(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.optionalTransform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions transform(@NonNull Class<T> arg0, @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.transform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions apply(@NonNull RequestOptions arg0) {
+    return (GlideOptions) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see Extension#test(RequestOptions)
+   */
+  @CheckResult
+  @NonNull
+  public GlideOptions test() {
+    return (GlideOptions) Extension.test(this);
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideRequest.java
new file mode 100644
index 000000000..ca9ea8813
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideRequest.java
@@ -0,0 +1,784 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).sizeMultiplier(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).sizeMultiplier(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useUnlimitedSourceGeneratorsPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useUnlimitedSourceGeneratorsPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useAnimationPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useAnimationPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).onlyRetrieveFromCache(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).onlyRetrieveFromCache(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).diskCacheStrategy(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).diskCacheStrategy(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).priority(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).priority(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).theme(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).theme(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).skipMemoryCache(skip);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).skipMemoryCache(skip);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(width, height);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(width, height);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(size);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(size);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).signature(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).signature(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#set(Option<T>, T)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).set(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).set(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).decode(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).decode(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeFormat(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeFormat(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeQuality(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeQuality(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).frame(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).frame(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).format(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).format(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).disallowHardwareConfig();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).disallowHardwareConfig();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).downsample(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).downsample(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).timeout(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).timeout(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalFitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalFitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCircleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCircleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).circleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).circleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transforms(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transforms(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> transform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontTransform();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontTransform();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontAnimate();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontAnimate();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#test()
+   */
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> test() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).test();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).test();
+    }
+    return this;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull RequestOptions arg0) {
+    return (GlideRequest<TranscodeType>) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.transition(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.listener(arg0);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/Extension.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/Extension.java
new file mode 100644
index 000000000..9e05dde64
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/Extension.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.test;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.RequestOptions;
+
+@GlideExtension
+public final class Extension {
+
+  private Extension() {
+    // Utility class.
+  }
+
+  @NonNull
+  @GlideOption(staticMethodName = "testSomething")
+  public static RequestOptions test(RequestOptions requestOptions) {
+    return requestOptions.centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideOptions.java
new file mode 100644
index 000000000..14f17549b
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideOptions.java
@@ -0,0 +1,636 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see Extension
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return new GlideOptions().sizeMultiplier(arg0);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy arg0) {
+    return new GlideOptions().diskCacheStrategy(arg0);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority arg0) {
+    return new GlideOptions().priority(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0,
+      @IntRange(from = 0) int arg1) {
+    return new GlideOptions().override(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().override(arg0);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key arg0) {
+    return new GlideOptions().signature(arg0);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> arg0) {
+    return new GlideOptions().transform(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return new GlideOptions().set(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> arg0) {
+    return new GlideOptions().decode(arg0);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat arg0) {
+    return new GlideOptions().format(arg0);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long arg0) {
+    return new GlideOptions().frame(arg0);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy arg0) {
+    return new GlideOptions().downsample(arg0);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().timeout(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int arg0) {
+    return new GlideOptions().encodeQuality(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat arg0) {
+    return new GlideOptions().encodeFormat(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return (GlideOptions) super.sizeMultiplier(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    return (GlideOptions) super.diskCacheStrategy(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions priority(@NonNull Priority arg0) {
+    return (GlideOptions) super.priority(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@Nullable Drawable arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@DrawableRes int arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@Nullable Drawable arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@DrawableRes int arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@Nullable Drawable arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@DrawableRes int arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions theme(@Nullable Resources.Theme arg0) {
+    return (GlideOptions) super.theme(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions signature(@NonNull Key arg0) {
+    return (GlideOptions) super.signature(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public final GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return (GlideOptions) super.set(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions decode(@NonNull Class<?> arg0) {
+    return (GlideOptions) super.decode(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    return (GlideOptions) super.encodeFormat(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    return (GlideOptions) super.encodeQuality(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions frame(@IntRange(from = 0) long arg0) {
+    return (GlideOptions) super.frame(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions format(@NonNull DecodeFormat arg0) {
+    return (GlideOptions) super.format(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions downsample(@NonNull DownsampleStrategy arg0) {
+    return (GlideOptions) super.downsample(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions timeout(@IntRange(from = 0) int arg0) {
+    return (GlideOptions) super.timeout(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.transform(arg0);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... arg0) {
+    return (GlideOptions) super.transforms(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.optionalTransform(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.optionalTransform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions transform(@NonNull Class<T> arg0, @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.transform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions apply(@NonNull RequestOptions arg0) {
+    return (GlideOptions) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see Extension#test(RequestOptions)
+   */
+  @CheckResult
+  @NonNull
+  public GlideOptions test() {
+    return (GlideOptions) Extension.test(this);
+  }
+
+  /**
+   * @see Extension#test(RequestOptions)
+   */
+  @CheckResult
+  public static GlideOptions testSomething() {
+    return new GlideOptions().test();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideRequest.java
new file mode 100644
index 000000000..ca9ea8813
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideRequest.java
@@ -0,0 +1,784 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).sizeMultiplier(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).sizeMultiplier(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useUnlimitedSourceGeneratorsPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useUnlimitedSourceGeneratorsPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useAnimationPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useAnimationPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).onlyRetrieveFromCache(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).onlyRetrieveFromCache(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).diskCacheStrategy(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).diskCacheStrategy(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).priority(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).priority(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).theme(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).theme(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).skipMemoryCache(skip);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).skipMemoryCache(skip);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(width, height);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(width, height);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(size);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(size);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).signature(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).signature(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#set(Option<T>, T)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).set(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).set(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).decode(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).decode(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeFormat(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeFormat(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeQuality(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeQuality(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).frame(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).frame(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).format(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).format(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).disallowHardwareConfig();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).disallowHardwareConfig();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).downsample(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).downsample(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).timeout(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).timeout(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalFitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalFitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCircleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCircleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).circleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).circleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transforms(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transforms(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> transform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontTransform();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontTransform();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontAnimate();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontAnimate();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#test()
+   */
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> test() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).test();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).test();
+    }
+    return this;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull RequestOptions arg0) {
+    return (GlideRequest<TranscodeType>) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.transition(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.listener(arg0);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/ExtensionWithOption.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/ExtensionWithOption.java
new file mode 100644
index 000000000..9884bcefb
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/ExtensionWithOption.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.test;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.RequestOptions;
+
+@GlideExtension
+public final class ExtensionWithOption {
+
+  private ExtensionWithOption() {
+    // Utility class.
+  }
+
+  @NonNull
+  @GlideOption
+  public static RequestOptions squareThumb(RequestOptions requestOptions) {
+    return requestOptions.centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideOptions.java
new file mode 100644
index 000000000..377c83922
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideOptions.java
@@ -0,0 +1,636 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see ExtensionWithOption
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return new GlideOptions().sizeMultiplier(arg0);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy arg0) {
+    return new GlideOptions().diskCacheStrategy(arg0);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority arg0) {
+    return new GlideOptions().priority(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0,
+      @IntRange(from = 0) int arg1) {
+    return new GlideOptions().override(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().override(arg0);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key arg0) {
+    return new GlideOptions().signature(arg0);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> arg0) {
+    return new GlideOptions().transform(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return new GlideOptions().set(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> arg0) {
+    return new GlideOptions().decode(arg0);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat arg0) {
+    return new GlideOptions().format(arg0);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long arg0) {
+    return new GlideOptions().frame(arg0);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy arg0) {
+    return new GlideOptions().downsample(arg0);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().timeout(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int arg0) {
+    return new GlideOptions().encodeQuality(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat arg0) {
+    return new GlideOptions().encodeFormat(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return (GlideOptions) super.sizeMultiplier(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    return (GlideOptions) super.diskCacheStrategy(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions priority(@NonNull Priority arg0) {
+    return (GlideOptions) super.priority(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@Nullable Drawable arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@DrawableRes int arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@Nullable Drawable arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@DrawableRes int arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@Nullable Drawable arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@DrawableRes int arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions theme(@Nullable Resources.Theme arg0) {
+    return (GlideOptions) super.theme(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions signature(@NonNull Key arg0) {
+    return (GlideOptions) super.signature(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public final GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return (GlideOptions) super.set(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions decode(@NonNull Class<?> arg0) {
+    return (GlideOptions) super.decode(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    return (GlideOptions) super.encodeFormat(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    return (GlideOptions) super.encodeQuality(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions frame(@IntRange(from = 0) long arg0) {
+    return (GlideOptions) super.frame(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions format(@NonNull DecodeFormat arg0) {
+    return (GlideOptions) super.format(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions downsample(@NonNull DownsampleStrategy arg0) {
+    return (GlideOptions) super.downsample(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions timeout(@IntRange(from = 0) int arg0) {
+    return (GlideOptions) super.timeout(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.transform(arg0);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... arg0) {
+    return (GlideOptions) super.transforms(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.optionalTransform(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.optionalTransform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions transform(@NonNull Class<T> arg0, @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.transform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions apply(@NonNull RequestOptions arg0) {
+    return (GlideOptions) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see ExtensionWithOption#squareThumb(RequestOptions)
+   */
+  @CheckResult
+  @NonNull
+  public GlideOptions squareThumb() {
+    return (GlideOptions) ExtensionWithOption.squareThumb(this);
+  }
+
+  /**
+   * @see ExtensionWithOption#squareThumb(RequestOptions)
+   */
+  @CheckResult
+  public static GlideOptions squareThumbOf() {
+    return new GlideOptions().squareThumb();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideRequest.java
new file mode 100644
index 000000000..fb9e7f7c3
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideRequest.java
@@ -0,0 +1,784 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).sizeMultiplier(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).sizeMultiplier(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useUnlimitedSourceGeneratorsPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useUnlimitedSourceGeneratorsPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useAnimationPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useAnimationPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).onlyRetrieveFromCache(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).onlyRetrieveFromCache(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).diskCacheStrategy(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).diskCacheStrategy(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).priority(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).priority(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).theme(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).theme(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).skipMemoryCache(skip);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).skipMemoryCache(skip);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(width, height);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(width, height);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(size);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(size);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).signature(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).signature(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#set(Option<T>, T)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).set(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).set(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).decode(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).decode(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeFormat(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeFormat(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeQuality(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeQuality(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).frame(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).frame(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).format(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).format(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).disallowHardwareConfig();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).disallowHardwareConfig();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).downsample(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).downsample(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).timeout(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).timeout(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalFitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalFitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCircleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCircleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).circleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).circleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transforms(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transforms(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> transform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontTransform();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontTransform();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontAnimate();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontAnimate();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#squareThumb()
+   */
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> squareThumb() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).squareThumb();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).squareThumb();
+    }
+    return this;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull RequestOptions arg0) {
+    return (GlideRequest<TranscodeType>) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.transition(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.listener(arg0);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/ExtensionWithType.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/ExtensionWithType.java
new file mode 100644
index 000000000..1d58e6ff0
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/ExtensionWithType.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.test;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideType;
+
+@GlideExtension
+public final class ExtensionWithType {
+
+  private ExtensionWithType() {
+    // Utility class.
+  }
+
+  @NonNull
+  @GlideType(Number.class)
+  public static RequestBuilder<Number> asNumber(RequestBuilder<Number> builder) {
+    return builder;
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideOptions.java
new file mode 100644
index 000000000..0b3fbfea0
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideOptions.java
@@ -0,0 +1,619 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see ExtensionWithType
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return new GlideOptions().sizeMultiplier(arg0);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy arg0) {
+    return new GlideOptions().diskCacheStrategy(arg0);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority arg0) {
+    return new GlideOptions().priority(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0,
+      @IntRange(from = 0) int arg1) {
+    return new GlideOptions().override(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().override(arg0);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key arg0) {
+    return new GlideOptions().signature(arg0);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> arg0) {
+    return new GlideOptions().transform(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return new GlideOptions().set(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> arg0) {
+    return new GlideOptions().decode(arg0);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat arg0) {
+    return new GlideOptions().format(arg0);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long arg0) {
+    return new GlideOptions().frame(arg0);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy arg0) {
+    return new GlideOptions().downsample(arg0);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().timeout(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int arg0) {
+    return new GlideOptions().encodeQuality(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat arg0) {
+    return new GlideOptions().encodeFormat(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return (GlideOptions) super.sizeMultiplier(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    return (GlideOptions) super.diskCacheStrategy(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions priority(@NonNull Priority arg0) {
+    return (GlideOptions) super.priority(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@Nullable Drawable arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@DrawableRes int arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@Nullable Drawable arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@DrawableRes int arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@Nullable Drawable arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@DrawableRes int arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions theme(@Nullable Resources.Theme arg0) {
+    return (GlideOptions) super.theme(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions signature(@NonNull Key arg0) {
+    return (GlideOptions) super.signature(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public final GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return (GlideOptions) super.set(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions decode(@NonNull Class<?> arg0) {
+    return (GlideOptions) super.decode(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    return (GlideOptions) super.encodeFormat(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    return (GlideOptions) super.encodeQuality(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions frame(@IntRange(from = 0) long arg0) {
+    return (GlideOptions) super.frame(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions format(@NonNull DecodeFormat arg0) {
+    return (GlideOptions) super.format(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions downsample(@NonNull DownsampleStrategy arg0) {
+    return (GlideOptions) super.downsample(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions timeout(@IntRange(from = 0) int arg0) {
+    return (GlideOptions) super.timeout(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.transform(arg0);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... arg0) {
+    return (GlideOptions) super.transforms(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.optionalTransform(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.optionalTransform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions transform(@NonNull Class<T> arg0, @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.transform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions apply(@NonNull RequestOptions arg0) {
+    return (GlideOptions) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java
new file mode 100644
index 000000000..87d740099
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java
@@ -0,0 +1,181 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
+import com.bumptech.glide.manager.Lifecycle;
+import com.bumptech.glide.manager.RequestManagerTreeNode;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Number;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Includes all additions from methods in {@link com.bumptech.glide.annotation.GlideExtension}s
+ * annotated with {@link com.bumptech.glide.annotation.GlideType}
+ *
+ * <p>Generated code, do not modify
+ */
+@SuppressWarnings("deprecation")
+public class GlideRequests extends RequestManager {
+  public GlideRequests(@NonNull Glide glide, @NonNull Lifecycle lifecycle,
+      @NonNull RequestManagerTreeNode treeNode, @NonNull Context context) {
+    super(glide, lifecycle, treeNode, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  public <ResourceType> GlideRequest<ResourceType> as(@NonNull Class<ResourceType> resourceClass) {
+    return new GlideRequest<>(glide, this, resourceClass, context);
+  }
+
+  /**
+   * @see ExtensionWithType#asNumber(RequestBuilder)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<Number> asNumber() {
+    return (GlideRequest<Number>) ExtensionWithType.asNumber(this.as(Number.class));
+  }
+
+  @Override
+  @NonNull
+  public GlideRequests applyDefaultRequestOptions(@NonNull RequestOptions arg0) {
+    return (GlideRequests) super.applyDefaultRequestOptions(arg0);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequests setDefaultRequestOptions(@NonNull RequestOptions arg0) {
+    return (GlideRequests) super.setDefaultRequestOptions(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Bitmap> asBitmap() {
+    return (GlideRequest<Bitmap>) super.asBitmap();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<GifDrawable> asGif() {
+    return (GlideRequest<GifDrawable>) super.asGif();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> asDrawable() {
+    return (GlideRequest<Drawable>) super.asDrawable();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Bitmap arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Drawable arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable String arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Uri arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable File arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Integer arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable URL arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable byte[] arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Object arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<File> downloadOnly() {
+    return (GlideRequest<File>) super.downloadOnly();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<File> download(@Nullable Object arg0) {
+    return (GlideRequest<File>) super.download(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<File> asFile() {
+    return (GlideRequest<File>) super.asFile();
+  }
+
+  @Override
+  protected void setRequestOptions(@NonNull RequestOptions toSet) {
+    if (toSet instanceof com.bumptech.glide.test.GlideOptions) {
+      super.setRequestOptions(toSet);
+    } else {
+      super.setRequestOptions(new com.bumptech.glide.test.GlideOptions().apply(toSet));
+    }
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/MemoizeStaticMethod/Extension.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/MemoizeStaticMethod/Extension.java
new file mode 100644
index 000000000..f37b64050
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/MemoizeStaticMethod/Extension.java
@@ -0,0 +1,18 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.RequestOptions;
+
+@GlideExtension
+public final class Extension {
+
+  private Extension() {
+    // Utility class.
+  }
+
+  @GlideOption(memoizeStaticMethod = true)
+  public static void test(RequestOptions requestOptions) {
+    requestOptions.centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java
new file mode 100644
index 000000000..6c0100161
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java
@@ -0,0 +1,646 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see Extension
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform1;
+
+  private static GlideOptions centerInsideTransform2;
+
+  private static GlideOptions centerCropTransform3;
+
+  private static GlideOptions circleCropTransform4;
+
+  private static GlideOptions noTransformation5;
+
+  private static GlideOptions noAnimation6;
+
+  private static GlideOptions testOf0;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return new GlideOptions().sizeMultiplier(arg0);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy arg0) {
+    return new GlideOptions().diskCacheStrategy(arg0);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority arg0) {
+    return new GlideOptions().priority(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0,
+      @IntRange(from = 0) int arg1) {
+    return new GlideOptions().override(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().override(arg0);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key arg0) {
+    return new GlideOptions().signature(arg0);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform1 == null) {
+      GlideOptions.fitCenterTransform1 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform2 == null) {
+      GlideOptions.centerInsideTransform2 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform2;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform3 == null) {
+      GlideOptions.centerCropTransform3 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform4 == null) {
+      GlideOptions.circleCropTransform4 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform4;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> arg0) {
+    return new GlideOptions().transform(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation5 == null) {
+      GlideOptions.noTransformation5 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation5;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return new GlideOptions().set(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> arg0) {
+    return new GlideOptions().decode(arg0);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat arg0) {
+    return new GlideOptions().format(arg0);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long arg0) {
+    return new GlideOptions().frame(arg0);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy arg0) {
+    return new GlideOptions().downsample(arg0);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().timeout(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int arg0) {
+    return new GlideOptions().encodeQuality(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat arg0) {
+    return new GlideOptions().encodeFormat(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation6 == null) {
+      GlideOptions.noAnimation6 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation6;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return (GlideOptions) super.sizeMultiplier(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    return (GlideOptions) super.diskCacheStrategy(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions priority(@NonNull Priority arg0) {
+    return (GlideOptions) super.priority(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@Nullable Drawable arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@DrawableRes int arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@Nullable Drawable arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@DrawableRes int arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@Nullable Drawable arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@DrawableRes int arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions theme(@Nullable Resources.Theme arg0) {
+    return (GlideOptions) super.theme(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions signature(@NonNull Key arg0) {
+    return (GlideOptions) super.signature(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public final GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return (GlideOptions) super.set(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions decode(@NonNull Class<?> arg0) {
+    return (GlideOptions) super.decode(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    return (GlideOptions) super.encodeFormat(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    return (GlideOptions) super.encodeQuality(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions frame(@IntRange(from = 0) long arg0) {
+    return (GlideOptions) super.frame(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions format(@NonNull DecodeFormat arg0) {
+    return (GlideOptions) super.format(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions downsample(@NonNull DownsampleStrategy arg0) {
+    return (GlideOptions) super.downsample(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions timeout(@IntRange(from = 0) int arg0) {
+    return (GlideOptions) super.timeout(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.transform(arg0);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... arg0) {
+    return (GlideOptions) super.transforms(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.optionalTransform(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.optionalTransform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions transform(@NonNull Class<T> arg0, @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.transform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions apply(@NonNull RequestOptions arg0) {
+    return (GlideOptions) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see Extension#test(RequestOptions)
+   */
+  @CheckResult
+  @NonNull
+  public GlideOptions test() {
+    if (isAutoCloneEnabled()) {
+      return clone().test();
+    }
+    Extension.test(this);
+    return this;
+  }
+
+  /**
+   * @see Extension#test(RequestOptions)
+   */
+  @CheckResult
+  public static GlideOptions testOf() {
+    if (GlideOptions.testOf0 == null) {
+      GlideOptions.testOf0 =
+          new GlideOptions().test().autoClone();
+    }
+    return GlideOptions.testOf0;
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java
new file mode 100644
index 000000000..ca9ea8813
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java
@@ -0,0 +1,784 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).sizeMultiplier(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).sizeMultiplier(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useUnlimitedSourceGeneratorsPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useUnlimitedSourceGeneratorsPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useAnimationPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useAnimationPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).onlyRetrieveFromCache(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).onlyRetrieveFromCache(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).diskCacheStrategy(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).diskCacheStrategy(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).priority(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).priority(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).theme(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).theme(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).skipMemoryCache(skip);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).skipMemoryCache(skip);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(width, height);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(width, height);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(size);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(size);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).signature(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).signature(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#set(Option<T>, T)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).set(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).set(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).decode(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).decode(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeFormat(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeFormat(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeQuality(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeQuality(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).frame(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).frame(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).format(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).format(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).disallowHardwareConfig();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).disallowHardwareConfig();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).downsample(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).downsample(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).timeout(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).timeout(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalFitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalFitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCircleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCircleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).circleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).circleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transforms(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transforms(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> transform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontTransform();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontTransform();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontAnimate();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontAnimate();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#test()
+   */
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> test() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).test();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).test();
+    }
+    return this;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull RequestOptions arg0) {
+    return (GlideRequest<TranscodeType>) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.transition(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.listener(arg0);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideExtend/Extension.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideExtend/Extension.java
new file mode 100644
index 000000000..5bc2838f8
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideExtend/Extension.java
@@ -0,0 +1,18 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.RequestOptions;
+
+@GlideExtension
+public final class Extension {
+
+  private Extension() {
+    // Utility class.
+  }
+
+  @GlideOption(override = GlideOption.OVERRIDE_EXTEND)
+  public static void centerCrop(RequestOptions requestOptions) {
+    requestOptions.centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideExtend/GlideOptions.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideExtend/GlideOptions.java
new file mode 100644
index 000000000..ebeb08175
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideExtend/GlideOptions.java
@@ -0,0 +1,636 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see Extension
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return new GlideOptions().sizeMultiplier(arg0);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy arg0) {
+    return new GlideOptions().diskCacheStrategy(arg0);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority arg0) {
+    return new GlideOptions().priority(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0,
+      @IntRange(from = 0) int arg1) {
+    return new GlideOptions().override(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().override(arg0);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key arg0) {
+    return new GlideOptions().signature(arg0);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> arg0) {
+    return new GlideOptions().transform(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return new GlideOptions().set(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> arg0) {
+    return new GlideOptions().decode(arg0);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat arg0) {
+    return new GlideOptions().format(arg0);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long arg0) {
+    return new GlideOptions().frame(arg0);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy arg0) {
+    return new GlideOptions().downsample(arg0);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().timeout(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int arg0) {
+    return new GlideOptions().encodeQuality(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat arg0) {
+    return new GlideOptions().encodeFormat(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return (GlideOptions) super.sizeMultiplier(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    return (GlideOptions) super.diskCacheStrategy(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions priority(@NonNull Priority arg0) {
+    return (GlideOptions) super.priority(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@Nullable Drawable arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@DrawableRes int arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@Nullable Drawable arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@DrawableRes int arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@Nullable Drawable arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@DrawableRes int arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions theme(@Nullable Resources.Theme arg0) {
+    return (GlideOptions) super.theme(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions signature(@NonNull Key arg0) {
+    return (GlideOptions) super.signature(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public final GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return (GlideOptions) super.set(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions decode(@NonNull Class<?> arg0) {
+    return (GlideOptions) super.decode(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    return (GlideOptions) super.encodeFormat(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    return (GlideOptions) super.encodeQuality(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions frame(@IntRange(from = 0) long arg0) {
+    return (GlideOptions) super.frame(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions format(@NonNull DecodeFormat arg0) {
+    return (GlideOptions) super.format(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions downsample(@NonNull DownsampleStrategy arg0) {
+    return (GlideOptions) super.downsample(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions timeout(@IntRange(from = 0) int arg0) {
+    return (GlideOptions) super.timeout(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.transform(arg0);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... arg0) {
+    return (GlideOptions) super.transforms(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.optionalTransform(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.optionalTransform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions transform(@NonNull Class<T> arg0, @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.transform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions apply(@NonNull RequestOptions arg0) {
+    return (GlideOptions) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see Extension#centerCrop(RequestOptions)
+   * @see RequestOptions#centerCrop()
+   */
+  @Override
+  @CheckResult
+  @NonNull
+  public GlideOptions centerCrop() {
+    if (isAutoCloneEnabled()) {
+      return clone().centerCrop();
+    }
+    super.centerCrop();
+    Extension.centerCrop(this);
+    return this;
+  }
+
+  /**
+   * @see Extension#centerCrop(RequestOptions)
+   */
+  @CheckResult
+  public static GlideOptions centerCropOf() {
+    return new GlideOptions().centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideExtend/GlideRequest.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideExtend/GlideRequest.java
new file mode 100644
index 000000000..6179c1263
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideExtend/GlideRequest.java
@@ -0,0 +1,770 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).sizeMultiplier(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).sizeMultiplier(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useUnlimitedSourceGeneratorsPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useUnlimitedSourceGeneratorsPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useAnimationPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useAnimationPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).onlyRetrieveFromCache(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).onlyRetrieveFromCache(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).diskCacheStrategy(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).diskCacheStrategy(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).priority(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).priority(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).theme(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).theme(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).skipMemoryCache(skip);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).skipMemoryCache(skip);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(width, height);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(width, height);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(size);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(size);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).signature(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).signature(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#set(Option<T>, T)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).set(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).set(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).decode(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).decode(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeFormat(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeFormat(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeQuality(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeQuality(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).frame(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).frame(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).format(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).format(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).disallowHardwareConfig();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).disallowHardwareConfig();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).downsample(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).downsample(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).timeout(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).timeout(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalFitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalFitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCircleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCircleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).circleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).circleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transforms(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transforms(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> transform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontTransform();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontTransform();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontAnimate();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontAnimate();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> centerCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerCrop();
+    }
+    return this;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull RequestOptions arg0) {
+    return (GlideRequest<TranscodeType>) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.transition(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.listener(arg0);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideReplace/Extension.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideReplace/Extension.java
new file mode 100644
index 000000000..591f857f2
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideReplace/Extension.java
@@ -0,0 +1,18 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.RequestOptions;
+
+@GlideExtension
+public final class Extension {
+
+  private Extension() {
+    // Utility class.
+  }
+
+  @GlideOption(override = GlideOption.OVERRIDE_REPLACE)
+  public static void centerCrop(RequestOptions requestOptions) {
+    requestOptions.centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideReplace/GlideOptions.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideReplace/GlideOptions.java
new file mode 100644
index 000000000..8604712ba
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideReplace/GlideOptions.java
@@ -0,0 +1,633 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see Extension
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return new GlideOptions().sizeMultiplier(arg0);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy arg0) {
+    return new GlideOptions().diskCacheStrategy(arg0);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority arg0) {
+    return new GlideOptions().priority(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0,
+      @IntRange(from = 0) int arg1) {
+    return new GlideOptions().override(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().override(arg0);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key arg0) {
+    return new GlideOptions().signature(arg0);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> arg0) {
+    return new GlideOptions().transform(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return new GlideOptions().set(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> arg0) {
+    return new GlideOptions().decode(arg0);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat arg0) {
+    return new GlideOptions().format(arg0);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long arg0) {
+    return new GlideOptions().frame(arg0);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy arg0) {
+    return new GlideOptions().downsample(arg0);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().timeout(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int arg0) {
+    return new GlideOptions().encodeQuality(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat arg0) {
+    return new GlideOptions().encodeFormat(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return (GlideOptions) super.sizeMultiplier(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    return (GlideOptions) super.diskCacheStrategy(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions priority(@NonNull Priority arg0) {
+    return (GlideOptions) super.priority(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@Nullable Drawable arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@DrawableRes int arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@Nullable Drawable arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@DrawableRes int arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@Nullable Drawable arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@DrawableRes int arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions theme(@Nullable Resources.Theme arg0) {
+    return (GlideOptions) super.theme(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions signature(@NonNull Key arg0) {
+    return (GlideOptions) super.signature(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public final GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return (GlideOptions) super.set(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions decode(@NonNull Class<?> arg0) {
+    return (GlideOptions) super.decode(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    return (GlideOptions) super.encodeFormat(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    return (GlideOptions) super.encodeQuality(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions frame(@IntRange(from = 0) long arg0) {
+    return (GlideOptions) super.frame(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions format(@NonNull DecodeFormat arg0) {
+    return (GlideOptions) super.format(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions downsample(@NonNull DownsampleStrategy arg0) {
+    return (GlideOptions) super.downsample(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions timeout(@IntRange(from = 0) int arg0) {
+    return (GlideOptions) super.timeout(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.transform(arg0);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... arg0) {
+    return (GlideOptions) super.transforms(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.optionalTransform(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.optionalTransform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions transform(@NonNull Class<T> arg0, @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.transform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions apply(@NonNull RequestOptions arg0) {
+    return (GlideOptions) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see Extension#centerCrop(RequestOptions)
+   */
+  @CheckResult
+  @NonNull
+  public GlideOptions centerCrop() {
+    if (isAutoCloneEnabled()) {
+      return clone().centerCrop();
+    }
+    Extension.centerCrop(this);
+    return this;
+  }
+
+  /**
+   * @see Extension#centerCrop(RequestOptions)
+   */
+  @CheckResult
+  public static GlideOptions centerCropOf() {
+    return new GlideOptions().centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideReplace/GlideRequest.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideReplace/GlideRequest.java
new file mode 100644
index 000000000..6179c1263
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideReplace/GlideRequest.java
@@ -0,0 +1,770 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).sizeMultiplier(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).sizeMultiplier(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useUnlimitedSourceGeneratorsPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useUnlimitedSourceGeneratorsPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useAnimationPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useAnimationPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).onlyRetrieveFromCache(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).onlyRetrieveFromCache(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).diskCacheStrategy(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).diskCacheStrategy(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).priority(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).priority(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).theme(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).theme(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).skipMemoryCache(skip);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).skipMemoryCache(skip);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(width, height);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(width, height);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(size);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(size);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).signature(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).signature(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#set(Option<T>, T)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).set(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).set(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).decode(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).decode(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeFormat(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeFormat(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeQuality(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeQuality(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).frame(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).frame(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).format(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).format(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).disallowHardwareConfig();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).disallowHardwareConfig();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).downsample(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).downsample(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).timeout(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).timeout(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalFitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalFitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCircleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCircleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).circleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).circleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transforms(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transforms(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> transform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontTransform();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontTransform();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontAnimate();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontAnimate();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> centerCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerCrop();
+    }
+    return this;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull RequestOptions arg0) {
+    return (GlideRequest<TranscodeType>) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.transition(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.listener(arg0);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/SkipStaticMethod/Extension.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/SkipStaticMethod/Extension.java
new file mode 100644
index 000000000..448a02b74
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/SkipStaticMethod/Extension.java
@@ -0,0 +1,18 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.RequestOptions;
+
+@GlideExtension
+public final class Extension {
+
+  private Extension() {
+    // Utility class.
+  }
+
+  @GlideOption(skipStaticMethod = true)
+  public static void test(RequestOptions requestOptions) {
+    requestOptions.centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/SkipStaticMethod/GlideOptions.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/SkipStaticMethod/GlideOptions.java
new file mode 100644
index 000000000..58fb322a4
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/SkipStaticMethod/GlideOptions.java
@@ -0,0 +1,632 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see Extension
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return new GlideOptions().sizeMultiplier(arg0);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy arg0) {
+    return new GlideOptions().diskCacheStrategy(arg0);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority arg0) {
+    return new GlideOptions().priority(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0,
+      @IntRange(from = 0) int arg1) {
+    return new GlideOptions().override(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().override(arg0);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key arg0) {
+    return new GlideOptions().signature(arg0);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> arg0) {
+    return new GlideOptions().transform(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return new GlideOptions().set(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> arg0) {
+    return new GlideOptions().decode(arg0);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat arg0) {
+    return new GlideOptions().format(arg0);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long arg0) {
+    return new GlideOptions().frame(arg0);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy arg0) {
+    return new GlideOptions().downsample(arg0);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().timeout(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int arg0) {
+    return new GlideOptions().encodeQuality(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat arg0) {
+    return new GlideOptions().encodeFormat(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return (GlideOptions) super.sizeMultiplier(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    return (GlideOptions) super.diskCacheStrategy(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions priority(@NonNull Priority arg0) {
+    return (GlideOptions) super.priority(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@Nullable Drawable arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@DrawableRes int arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@Nullable Drawable arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@DrawableRes int arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@Nullable Drawable arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@DrawableRes int arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions theme(@Nullable Resources.Theme arg0) {
+    return (GlideOptions) super.theme(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions signature(@NonNull Key arg0) {
+    return (GlideOptions) super.signature(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public final GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return (GlideOptions) super.set(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions decode(@NonNull Class<?> arg0) {
+    return (GlideOptions) super.decode(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    return (GlideOptions) super.encodeFormat(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    return (GlideOptions) super.encodeQuality(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions frame(@IntRange(from = 0) long arg0) {
+    return (GlideOptions) super.frame(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions format(@NonNull DecodeFormat arg0) {
+    return (GlideOptions) super.format(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions downsample(@NonNull DownsampleStrategy arg0) {
+    return (GlideOptions) super.downsample(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions timeout(@IntRange(from = 0) int arg0) {
+    return (GlideOptions) super.timeout(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.transform(arg0);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... arg0) {
+    return (GlideOptions) super.transforms(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.optionalTransform(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.optionalTransform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions transform(@NonNull Class<T> arg0, @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.transform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions apply(@NonNull RequestOptions arg0) {
+    return (GlideOptions) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see Extension#test(RequestOptions)
+   */
+  @CheckResult
+  @NonNull
+  public GlideOptions test() {
+    if (isAutoCloneEnabled()) {
+      return clone().test();
+    }
+    Extension.test(this);
+    return this;
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/SkipStaticMethod/GlideRequest.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/SkipStaticMethod/GlideRequest.java
new file mode 100644
index 000000000..ca9ea8813
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/SkipStaticMethod/GlideRequest.java
@@ -0,0 +1,784 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).sizeMultiplier(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).sizeMultiplier(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useUnlimitedSourceGeneratorsPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useUnlimitedSourceGeneratorsPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useAnimationPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useAnimationPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).onlyRetrieveFromCache(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).onlyRetrieveFromCache(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).diskCacheStrategy(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).diskCacheStrategy(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).priority(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).priority(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).theme(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).theme(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).skipMemoryCache(skip);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).skipMemoryCache(skip);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(width, height);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(width, height);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(size);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(size);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).signature(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).signature(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#set(Option<T>, T)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).set(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).set(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).decode(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).decode(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeFormat(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeFormat(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeQuality(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeQuality(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).frame(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).frame(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).format(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).format(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).disallowHardwareConfig();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).disallowHardwareConfig();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).downsample(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).downsample(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).timeout(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).timeout(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalFitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalFitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCircleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCircleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).circleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).circleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transforms(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transforms(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> transform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontTransform();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontTransform();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontAnimate();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontAnimate();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#test()
+   */
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> test() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).test();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).test();
+    }
+    return this;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull RequestOptions arg0) {
+    return (GlideRequest<TranscodeType>) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.transition(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.listener(arg0);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/StaticMethodName/Extension.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/StaticMethodName/Extension.java
new file mode 100644
index 000000000..b6c72bbad
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/StaticMethodName/Extension.java
@@ -0,0 +1,18 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.RequestOptions;
+
+@GlideExtension
+public final class Extension {
+
+  private Extension() {
+    // Utility class.
+  }
+
+  @GlideOption(staticMethodName = "testSomething")
+  public static void test(RequestOptions requestOptions) {
+    requestOptions.centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/StaticMethodName/GlideOptions.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/StaticMethodName/GlideOptions.java
new file mode 100644
index 000000000..970b5fb0a
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/StaticMethodName/GlideOptions.java
@@ -0,0 +1,640 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see Extension
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return new GlideOptions().sizeMultiplier(arg0);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy arg0) {
+    return new GlideOptions().diskCacheStrategy(arg0);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority arg0) {
+    return new GlideOptions().priority(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0,
+      @IntRange(from = 0) int arg1) {
+    return new GlideOptions().override(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().override(arg0);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key arg0) {
+    return new GlideOptions().signature(arg0);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> arg0) {
+    return new GlideOptions().transform(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return new GlideOptions().set(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> arg0) {
+    return new GlideOptions().decode(arg0);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat arg0) {
+    return new GlideOptions().format(arg0);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long arg0) {
+    return new GlideOptions().frame(arg0);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy arg0) {
+    return new GlideOptions().downsample(arg0);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().timeout(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int arg0) {
+    return new GlideOptions().encodeQuality(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat arg0) {
+    return new GlideOptions().encodeFormat(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return (GlideOptions) super.sizeMultiplier(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    return (GlideOptions) super.diskCacheStrategy(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions priority(@NonNull Priority arg0) {
+    return (GlideOptions) super.priority(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@Nullable Drawable arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@DrawableRes int arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@Nullable Drawable arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@DrawableRes int arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@Nullable Drawable arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@DrawableRes int arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions theme(@Nullable Resources.Theme arg0) {
+    return (GlideOptions) super.theme(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions signature(@NonNull Key arg0) {
+    return (GlideOptions) super.signature(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public final GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return (GlideOptions) super.set(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions decode(@NonNull Class<?> arg0) {
+    return (GlideOptions) super.decode(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    return (GlideOptions) super.encodeFormat(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    return (GlideOptions) super.encodeQuality(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions frame(@IntRange(from = 0) long arg0) {
+    return (GlideOptions) super.frame(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions format(@NonNull DecodeFormat arg0) {
+    return (GlideOptions) super.format(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions downsample(@NonNull DownsampleStrategy arg0) {
+    return (GlideOptions) super.downsample(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions timeout(@IntRange(from = 0) int arg0) {
+    return (GlideOptions) super.timeout(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.transform(arg0);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... arg0) {
+    return (GlideOptions) super.transforms(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.optionalTransform(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.optionalTransform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions transform(@NonNull Class<T> arg0, @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.transform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions apply(@NonNull RequestOptions arg0) {
+    return (GlideOptions) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see Extension#test(RequestOptions)
+   */
+  @CheckResult
+  @NonNull
+  public GlideOptions test() {
+    if (isAutoCloneEnabled()) {
+      return clone().test();
+    }
+    Extension.test(this);
+    return this;
+  }
+
+  /**
+   * @see Extension#test(RequestOptions)
+   */
+  @CheckResult
+  public static GlideOptions testSomething() {
+    return new GlideOptions().test();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/StaticMethodName/GlideRequest.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/StaticMethodName/GlideRequest.java
new file mode 100644
index 000000000..ca9ea8813
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/StaticMethodName/GlideRequest.java
@@ -0,0 +1,784 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).sizeMultiplier(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).sizeMultiplier(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useUnlimitedSourceGeneratorsPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useUnlimitedSourceGeneratorsPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useAnimationPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useAnimationPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).onlyRetrieveFromCache(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).onlyRetrieveFromCache(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).diskCacheStrategy(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).diskCacheStrategy(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).priority(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).priority(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).theme(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).theme(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).skipMemoryCache(skip);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).skipMemoryCache(skip);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(width, height);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(width, height);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(size);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(size);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).signature(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).signature(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#set(Option<T>, T)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).set(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).set(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).decode(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).decode(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeFormat(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeFormat(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeQuality(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeQuality(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).frame(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).frame(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).format(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).format(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).disallowHardwareConfig();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).disallowHardwareConfig();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).downsample(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).downsample(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).timeout(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).timeout(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalFitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalFitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCircleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCircleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).circleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).circleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transforms(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transforms(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> transform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontTransform();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontTransform();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontAnimate();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontAnimate();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#test()
+   */
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> test() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).test();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).test();
+    }
+    return this;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull RequestOptions arg0) {
+    return (GlideRequest<TranscodeType>) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.transition(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.listener(arg0);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithOptionTest/ExtensionWithOption.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithOptionTest/ExtensionWithOption.java
new file mode 100644
index 000000000..b67065d43
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithOptionTest/ExtensionWithOption.java
@@ -0,0 +1,18 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.RequestOptions;
+
+@GlideExtension
+public final class ExtensionWithOption {
+
+  private ExtensionWithOption() {
+    // Utility class.
+  }
+
+  @GlideOption
+  public static void squareThumb(RequestOptions requestOptions) {
+    requestOptions.centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithOptionTest/GlideOptions.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithOptionTest/GlideOptions.java
new file mode 100644
index 000000000..a7f63dd7c
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithOptionTest/GlideOptions.java
@@ -0,0 +1,640 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see ExtensionWithOption
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return new GlideOptions().sizeMultiplier(arg0);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy arg0) {
+    return new GlideOptions().diskCacheStrategy(arg0);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority arg0) {
+    return new GlideOptions().priority(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0,
+      @IntRange(from = 0) int arg1) {
+    return new GlideOptions().override(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().override(arg0);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key arg0) {
+    return new GlideOptions().signature(arg0);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> arg0) {
+    return new GlideOptions().transform(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return new GlideOptions().set(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> arg0) {
+    return new GlideOptions().decode(arg0);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat arg0) {
+    return new GlideOptions().format(arg0);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long arg0) {
+    return new GlideOptions().frame(arg0);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy arg0) {
+    return new GlideOptions().downsample(arg0);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().timeout(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int arg0) {
+    return new GlideOptions().encodeQuality(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat arg0) {
+    return new GlideOptions().encodeFormat(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return (GlideOptions) super.sizeMultiplier(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    return (GlideOptions) super.diskCacheStrategy(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions priority(@NonNull Priority arg0) {
+    return (GlideOptions) super.priority(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@Nullable Drawable arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@DrawableRes int arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@Nullable Drawable arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@DrawableRes int arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@Nullable Drawable arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@DrawableRes int arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions theme(@Nullable Resources.Theme arg0) {
+    return (GlideOptions) super.theme(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions signature(@NonNull Key arg0) {
+    return (GlideOptions) super.signature(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public final GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return (GlideOptions) super.set(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions decode(@NonNull Class<?> arg0) {
+    return (GlideOptions) super.decode(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    return (GlideOptions) super.encodeFormat(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    return (GlideOptions) super.encodeQuality(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions frame(@IntRange(from = 0) long arg0) {
+    return (GlideOptions) super.frame(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions format(@NonNull DecodeFormat arg0) {
+    return (GlideOptions) super.format(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions downsample(@NonNull DownsampleStrategy arg0) {
+    return (GlideOptions) super.downsample(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions timeout(@IntRange(from = 0) int arg0) {
+    return (GlideOptions) super.timeout(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.transform(arg0);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... arg0) {
+    return (GlideOptions) super.transforms(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.optionalTransform(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.optionalTransform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions transform(@NonNull Class<T> arg0, @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.transform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions apply(@NonNull RequestOptions arg0) {
+    return (GlideOptions) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see ExtensionWithOption#squareThumb(RequestOptions)
+   */
+  @CheckResult
+  @NonNull
+  public GlideOptions squareThumb() {
+    if (isAutoCloneEnabled()) {
+      return clone().squareThumb();
+    }
+    ExtensionWithOption.squareThumb(this);
+    return this;
+  }
+
+  /**
+   * @see ExtensionWithOption#squareThumb(RequestOptions)
+   */
+  @CheckResult
+  public static GlideOptions squareThumbOf() {
+    return new GlideOptions().squareThumb();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithOptionTest/GlideRequest.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithOptionTest/GlideRequest.java
new file mode 100644
index 000000000..fb9e7f7c3
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithOptionTest/GlideRequest.java
@@ -0,0 +1,784 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).sizeMultiplier(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).sizeMultiplier(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useUnlimitedSourceGeneratorsPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useUnlimitedSourceGeneratorsPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useAnimationPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useAnimationPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).onlyRetrieveFromCache(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).onlyRetrieveFromCache(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).diskCacheStrategy(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).diskCacheStrategy(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).priority(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).priority(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).theme(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).theme(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).skipMemoryCache(skip);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).skipMemoryCache(skip);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(width, height);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(width, height);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(size);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(size);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).signature(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).signature(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#set(Option<T>, T)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).set(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).set(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).decode(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).decode(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeFormat(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeFormat(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeQuality(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeQuality(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).frame(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).frame(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).format(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).format(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).disallowHardwareConfig();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).disallowHardwareConfig();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).downsample(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).downsample(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).timeout(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).timeout(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalFitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalFitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCircleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCircleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).circleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).circleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transforms(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transforms(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> transform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontTransform();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontTransform();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontAnimate();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontAnimate();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#squareThumb()
+   */
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> squareThumb() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).squareThumb();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).squareThumb();
+    }
+    return this;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull RequestOptions arg0) {
+    return (GlideRequest<TranscodeType>) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.transition(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.listener(arg0);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithTypeTest/ExtensionWithType.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithTypeTest/ExtensionWithType.java
new file mode 100644
index 000000000..47c22dd4d
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithTypeTest/ExtensionWithType.java
@@ -0,0 +1,16 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideType;
+
+@GlideExtension
+public final class ExtensionWithType {
+
+  private ExtensionWithType() {
+    // Utility class.
+  }
+
+  @GlideType(Number.class)
+  public static void asInteger(RequestBuilder<Number> builder) {}
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithTypeTest/GlideOptions.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithTypeTest/GlideOptions.java
new file mode 100644
index 000000000..0b3fbfea0
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithTypeTest/GlideOptions.java
@@ -0,0 +1,619 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see ExtensionWithType
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return new GlideOptions().sizeMultiplier(arg0);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy arg0) {
+    return new GlideOptions().diskCacheStrategy(arg0);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority arg0) {
+    return new GlideOptions().priority(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0,
+      @IntRange(from = 0) int arg1) {
+    return new GlideOptions().override(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().override(arg0);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key arg0) {
+    return new GlideOptions().signature(arg0);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> arg0) {
+    return new GlideOptions().transform(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return new GlideOptions().set(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> arg0) {
+    return new GlideOptions().decode(arg0);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat arg0) {
+    return new GlideOptions().format(arg0);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long arg0) {
+    return new GlideOptions().frame(arg0);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy arg0) {
+    return new GlideOptions().downsample(arg0);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().timeout(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int arg0) {
+    return new GlideOptions().encodeQuality(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat arg0) {
+    return new GlideOptions().encodeFormat(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return (GlideOptions) super.sizeMultiplier(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    return (GlideOptions) super.diskCacheStrategy(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions priority(@NonNull Priority arg0) {
+    return (GlideOptions) super.priority(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@Nullable Drawable arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@DrawableRes int arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@Nullable Drawable arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@DrawableRes int arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@Nullable Drawable arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@DrawableRes int arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions theme(@Nullable Resources.Theme arg0) {
+    return (GlideOptions) super.theme(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions signature(@NonNull Key arg0) {
+    return (GlideOptions) super.signature(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public final GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return (GlideOptions) super.set(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions decode(@NonNull Class<?> arg0) {
+    return (GlideOptions) super.decode(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    return (GlideOptions) super.encodeFormat(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    return (GlideOptions) super.encodeQuality(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions frame(@IntRange(from = 0) long arg0) {
+    return (GlideOptions) super.frame(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions format(@NonNull DecodeFormat arg0) {
+    return (GlideOptions) super.format(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions downsample(@NonNull DownsampleStrategy arg0) {
+    return (GlideOptions) super.downsample(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions timeout(@IntRange(from = 0) int arg0) {
+    return (GlideOptions) super.timeout(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.transform(arg0);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... arg0) {
+    return (GlideOptions) super.transforms(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.optionalTransform(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.optionalTransform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions transform(@NonNull Class<T> arg0, @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.transform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions apply(@NonNull RequestOptions arg0) {
+    return (GlideOptions) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithTypeTest/GlideRequests.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithTypeTest/GlideRequests.java
new file mode 100644
index 000000000..be9b074e6
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithTypeTest/GlideRequests.java
@@ -0,0 +1,183 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
+import com.bumptech.glide.manager.Lifecycle;
+import com.bumptech.glide.manager.RequestManagerTreeNode;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Number;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Includes all additions from methods in {@link com.bumptech.glide.annotation.GlideExtension}s
+ * annotated with {@link com.bumptech.glide.annotation.GlideType}
+ *
+ * <p>Generated code, do not modify
+ */
+@SuppressWarnings("deprecation")
+public class GlideRequests extends RequestManager {
+  public GlideRequests(@NonNull Glide glide, @NonNull Lifecycle lifecycle,
+      @NonNull RequestManagerTreeNode treeNode, @NonNull Context context) {
+    super(glide, lifecycle, treeNode, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  public <ResourceType> GlideRequest<ResourceType> as(@NonNull Class<ResourceType> resourceClass) {
+    return new GlideRequest<>(glide, this, resourceClass, context);
+  }
+
+  /**
+   * @see ExtensionWithType#asInteger(RequestBuilder)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<Number> asInteger() {
+    GlideRequest<Number> requestBuilder = this.as(Number.class);
+    ExtensionWithType.asInteger(requestBuilder);
+    return requestBuilder;
+  }
+
+  @Override
+  @NonNull
+  public GlideRequests applyDefaultRequestOptions(@NonNull RequestOptions arg0) {
+    return (GlideRequests) super.applyDefaultRequestOptions(arg0);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequests setDefaultRequestOptions(@NonNull RequestOptions arg0) {
+    return (GlideRequests) super.setDefaultRequestOptions(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Bitmap> asBitmap() {
+    return (GlideRequest<Bitmap>) super.asBitmap();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<GifDrawable> asGif() {
+    return (GlideRequest<GifDrawable>) super.asGif();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> asDrawable() {
+    return (GlideRequest<Drawable>) super.asDrawable();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Bitmap arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Drawable arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable String arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Uri arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable File arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Integer arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable URL arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable byte[] arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Object arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<File> downloadOnly() {
+    return (GlideRequest<File>) super.downloadOnly();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<File> download(@Nullable Object arg0) {
+    return (GlideRequest<File>) super.download(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<File> asFile() {
+    return (GlideRequest<File>) super.asFile();
+  }
+
+  @Override
+  protected void setRequestOptions(@NonNull RequestOptions toSet) {
+    if (toSet instanceof com.bumptech.glide.test.GlideOptions) {
+      super.setRequestOptions(toSet);
+    } else {
+      super.setRequestOptions(new com.bumptech.glide.test.GlideOptions().apply(toSet));
+    }
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/MultipleAppGlideModuleTest/EmptyAppModule1.java b/annotation/compiler/test/src/test/resources/MultipleAppGlideModuleTest/EmptyAppModule1.java
new file mode 100644
index 000000000..a05259d66
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/MultipleAppGlideModuleTest/EmptyAppModule1.java
@@ -0,0 +1,7 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
+
+@GlideModule
+public final class EmptyAppModule1 extends AppGlideModule {}
\ No newline at end of file
diff --git a/annotation/compiler/test/src/test/resources/MultipleAppGlideModuleTest/EmptyAppModule2.java b/annotation/compiler/test/src/test/resources/MultipleAppGlideModuleTest/EmptyAppModule2.java
new file mode 100644
index 000000000..fb46c0c13
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/MultipleAppGlideModuleTest/EmptyAppModule2.java
@@ -0,0 +1,7 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
+
+@GlideModule
+public final class EmptyAppModule2 extends AppGlideModule {}
\ No newline at end of file
diff --git a/annotation/compiler/test/src/test/resources/MultipleEmptyLibraryGlideModuleTest/EmptyLibraryModule1.java b/annotation/compiler/test/src/test/resources/MultipleEmptyLibraryGlideModuleTest/EmptyLibraryModule1.java
new file mode 100644
index 000000000..236008a91
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/MultipleEmptyLibraryGlideModuleTest/EmptyLibraryModule1.java
@@ -0,0 +1,7 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.LibraryGlideModule;
+
+@GlideModule
+public final class EmptyLibraryModule1 extends LibraryGlideModule {}
diff --git a/annotation/compiler/test/src/test/resources/MultipleEmptyLibraryGlideModuleTest/EmptyLibraryModule2.java b/annotation/compiler/test/src/test/resources/MultipleEmptyLibraryGlideModuleTest/EmptyLibraryModule2.java
new file mode 100644
index 000000000..8a43eb292
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/MultipleEmptyLibraryGlideModuleTest/EmptyLibraryModule2.java
@@ -0,0 +1,7 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.LibraryGlideModule;
+
+@GlideModule
+public final class EmptyLibraryModule2 extends LibraryGlideModule {}
diff --git a/annotation/compiler/test/src/test/resources/MultipleEmptyLibraryGlideModuleTest/GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule1_com_bumptech_glide_test_EmptyLibraryModule2.java b/annotation/compiler/test/src/test/resources/MultipleEmptyLibraryGlideModuleTest/GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule1_com_bumptech_glide_test_EmptyLibraryModule2.java
new file mode 100644
index 000000000..d4284aa69
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/MultipleEmptyLibraryGlideModuleTest/GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule1_com_bumptech_glide_test_EmptyLibraryModule2.java
@@ -0,0 +1,10 @@
+package com.bumptech.glide.annotation.compiler;
+
+@Index(
+    modules = {
+        "com.bumptech.glide.test.EmptyLibraryModule1",
+        "com.bumptech.glide.test.EmptyLibraryModule2"
+    }
+)
+public class GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule1_com_bumptech_glide_test_EmptyLibraryModule2 {
+}
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/Excludes.java b/annotation/src/main/java/com/bumptech/glide/annotation/Excludes.java
index 0a15f5a0d..13de814b2 100644
--- a/annotation/src/main/java/com/bumptech/glide/annotation/Excludes.java
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/Excludes.java
@@ -16,5 +16,5 @@
 @Target(ElementType.TYPE)
 @Retention(RetentionPolicy.RUNTIME)
 public @interface Excludes {
-  Class[] value();
+  Class<?>[] value();
 }
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/GlideModule.java b/annotation/src/main/java/com/bumptech/glide/annotation/GlideModule.java
index 679eb8bce..dc91418e2 100644
--- a/annotation/src/main/java/com/bumptech/glide/annotation/GlideModule.java
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideModule.java
@@ -16,7 +16,7 @@
 public @interface GlideModule {
   /**
    * Returns the name of the class that will be used as a replacement for
-   * {@link com.bumptech.glide.Glide} in Applications that depend on Glide's generated code.
+   * {@code com.bumptech.glide.Glide} in Applications that depend on Glide's generated code.
    */
   String glideName() default "GlideApp";
 }
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java b/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java
index 50bfbecb0..58197a802 100644
--- a/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java
@@ -7,16 +7,64 @@
 
 /**
  * Identifies methods in {@link GlideExtension} annotated classes that extend
- * {@link com.bumptech.glide.request.RequestOptions}.
+ * {@code com.bumptech.glide.request.RequestOptions}.
  *
  * <p>All annotated methods will be added to a single
- * {@link com.bumptech.glide.request.RequestOptions} implementation generated per application.
+ * {@code com.bumptech.glide.request.RequestOptions} implementation generated per application.
  * Overlapping method names in different extensions may cause errors at compile time.
  *
  * <p>Static equivalents of annotated methods will also be generated.
  *
  * <p>Methods with this annotation will only be found if they belong to classes annotated with
  * {@link GlideExtension}.
+ *
+ * <p>The preferred way of writing extension methods returns the provided
+ * {@code com.bumptech.glide.request.RequestOptions} object with one or more methods called on it.
+ * You must not return a newly instantiated {@code com.bumptech.glide.request.RequestOptions} object
+ * as doing so my cause a {@code ClassCastException} at runtime. Calling either
+ * {@code com.bumptech.glide.request.RequestOptions#autoClone()} or
+ * {@code com.bumptech.glide.request.RequestOptions#lock()} is safe, but unnecessary and should
+ * typically be avoided. The preferred style looks like:
+ *
+ * <pre>
+ * {@code
+ * {@link @}GlideExtension
+ * public class MyExtension {
+ *   private MyExtension() {}
+ *
+ *   {@literal @}GlideOption
+ *   public static RequestOptions myOption(RequestOptions options) {
+ *     return options
+ *         .optionOne()
+ *         .optionTwo();
+ *   }
+ * }
+ * }
+ * </pre>
+ *
+ * <p>The deprecated way of writing extension methods is simply a static void method. The
+ * {@code com.bumptech.glide.request.RequestOptions} object is cloned before it is passed to this
+ * method to avoid an option method returning a new instance, but using methods like
+ * {@code com.bumptech.glide.request.RequestOptions#clone()} or
+ * {@code com.bumptech.glide.request.RequestOptions#autoClone()} can result in options applied in
+ * the method being silently ignored. Prefer the new style whenever possible.
+ *
+ * <pre>
+ * {@code
+ * {@literal @}GlideExtension
+ * public class MyExtension {
+ *   private MyExtension() {}
+ *
+ *   // Deprecated! Use the new style of GlideOption extensions instead.
+ *   {@literal @}GlideOption
+ *   public static void myOption(RequestOptions options) {
+ *     options
+ *         .optionOne()
+ *         .optionTwo();
+ *   }
+ * }
+ * }
+ * </pre>
  */
 @Target(ElementType.METHOD)
 // Needs to be parsed from class files in JAR.
@@ -51,7 +99,7 @@
 
   /**
    * {@code true} to indicate that it's safe to statically memoize the result of this method using
-   * {@link com.bumptech.glide.request.RequestOptions#autoClone()}.
+   * {@code com.bumptech.glide.request.RequestOptions#autoClone()}.
    *
    * <p>This method should only be used for no-arg methods where there's only a single possible
    * value.
@@ -65,8 +113,8 @@
    *
    * <p>By default static methods are generated for all methods annotated with
    * {@link GlideOption}. These static factory methods allow for a cleaner API when used
-   * with {@link com.bumptech.glide.RequestBuilder#apply}. The static factory method by default
-   * simply creates a new {@link com.bumptech.glide.request.RequestOptions} object, calls the
+   * with {@code com.bumptech.glide.RequestBuilder#apply}. The static factory method by default
+   * simply creates a new {@code com.bumptech.glide.request.RequestOptions} object, calls the
    * instance version of the method on it and returns it. For example:
    * <pre>
    * <code>
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/GlideType.java b/annotation/src/main/java/com/bumptech/glide/annotation/GlideType.java
index f0c19a599..d3538d99b 100644
--- a/annotation/src/main/java/com/bumptech/glide/annotation/GlideType.java
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideType.java
@@ -7,10 +7,10 @@
 
 /**
  * Identifies methods in {@link GlideExtension} annotated classes that extend
- * {@link com.bumptech.glide.RequestManager}.
+ * {@code com.bumptech.glide.RequestManager}.
  *
  * <p>If one or more method is found with this annotation, an additional API entry point that
- * exposes a generated {@link com.bumptech.glide.RequestManager} subclass will be created. The
+ * exposes a generated {@code com.bumptech.glide.RequestManager} subclass will be created. The
  * generated API entry point acts as a drop in replacement for Glide. Glide.with(fragment) becomes
  * GlideApp.with(fragment). Although the Glide.with variant will still be available, only the new
  * API entry point will provide access to these additional methods.
@@ -22,8 +22,11 @@
  * with {@link GlideExtension}.
  *
  * <p>Methods annotated with GlideType must have a single parameter. The type of the
- * single parameter must be {@link com.bumptech.glide.request.RequestOptions}, with a type
+ * single parameter must be {@code com.bumptech.glide.RequestBuilder}, with a type
  * matching the value of {@link #value()}.
+ *
+ * <p>Compilation will fail if a method annotated with this method is identical to a method in
+ * {@code com.bumptech.glide.RequestManager}
  */
 @Target(ElementType.METHOD)
 // Needs to be parsed from class files in JAR.
@@ -33,7 +36,8 @@
   /**
    * A Resource class name, like GifDrawable.class, Bitmap.class etc.
    *
-   * <p>Must match the type of the {@link com.bumptech.glide.request.RequestOptions} parameter.
+   * <p>Must match the type of the {@code com.bumptech.glide.RequestBuilder} parameter in the
+   * annotated method.
    */
   Class<?> value();
 }
diff --git a/build.gradle b/build.gradle
index 3d157c29f..d54f9c4e5 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,14 +1,24 @@
+import se.bjurr.violations.gradle.plugin.ViolationsTask
+import org.gradle.api.tasks.testing.logging.TestExceptionFormat
+
 buildscript {
     repositories {
+        google()
         jcenter()
         maven {
             url "https://oss.sonatype.org/content/repositories/snapshots"
         }
+        maven {
+            url "https://plugins.gradle.org/m2/"
+        }
     }
 
     dependencies {
         classpath "com.android.tools.build:gradle:${ANDROID_GRADLE_VERSION}"
-        classpath "org.kt3k.gradle.plugin:coveralls-gradle-plugin:${COVERALLS_GRADLE_VERSION}"
+        if (!hasProperty('DISABLE_ERROR_PRONE')) {
+            classpath "net.ltgt.gradle:gradle-errorprone-plugin:${ERROR_PRONE_PLUGIN_VERSION}"
+        }
+        classpath "se.bjurr.violations:violations-gradle-plugin:${VIOLATIONS_PLUGIN_VERSION}"
     }
 }
 
@@ -21,28 +31,54 @@ if (JavaVersion.current().isJava8Compatible()) {
     }
 }
 
-subprojects {
-    tasks.withType(JavaCompile) {
-        sourceCompatibility = 1.7
-        targetCompatibility = 1.7
-    }
-}
-
 subprojects { project ->
+
     repositories {
+        google()
         jcenter()
         maven {
             url "https://oss.sonatype.org/content/repositories/snapshots"
         }
-        maven {
-            url "https://maven.google.com"
+    }
+
+    tasks.withType(JavaCompile) {
+        sourceCompatibility = 1.7
+        targetCompatibility = 1.7
+
+        options.setBootstrapClasspath(files("${System.getProperty('java.home')}/lib/rt.jar"))
+        // gifencoder is a legacy project that has a ton of warnings and is basically never
+        // modified, so we're not going to worry about cleaning it up.
+        if ("gifencoder" != project.getName()) {
+          options.compilerArgs \
+                << "-Xlint:all" \
+                /*
+                 * Java expects every annotation to have a processor, but we use
+                 * javax.annotation.Nullable, which doesn't have one.
+                 */ \
+                << "-Xlint:-processing" \
+                /*
+                 * See https://github.com/google/dagger/issues/945
+                 * and https://bugs.openjdk.java.net/browse/JDK-8190452
+                 */ \
+                << "-Xlint:-classfile"
+        }
+    }
+
+    tasks.withType(Test) {
+        testLogging {
+            exceptionFormat = TestExceptionFormat.FULL
         }
     }
 
+    // Avoid issues like #2452.
+    tasks.withType(Jar) {
+        duplicatesStrategy = DuplicatesStrategy.FAIL
+    }
+
     apply plugin: 'checkstyle'
 
     checkstyle {
-        toolVersion = '6.12.1'
+        toolVersion = '8.5'
     }
 
     checkstyle {
@@ -54,26 +90,54 @@ subprojects { project ->
         source 'src'
         include '**/*.java'
         exclude '**/gen/**'
+        // Caught by the violations plugin.
+        ignoreFailures = true
 
         // empty classpath
         classpath = files()
     }
 
+    apply plugin: "se.bjurr.violations.violations-gradle-plugin"
+
+    task violations(type: ViolationsTask) {
+        minSeverity 'INFO'
+        detailLevel 'VERBOSE'
+        maxViolations = 0
+        diffMaxViolations = 0
+
+        // Formats are listed here: https://github.com/tomasbjerre/violations-lib
+        def dir = projectDir.absolutePath
+        violations = [
+                ["FINDBUGS",    dir, ".*/findbugs/.*\\.xml\$",   "Findbugs"],
+                ["PMD",         dir, ".*/pmd/.*\\.xml\$",        "PMD"],
+                ["ANDROIDLINT", dir, ".*/lint-results\\.xml\$",  "AndroidLint"],
+                ["CHECKSTYLE",  dir, ".*/checkstyle/.*\\.xml\$", "Checkstyle"],
+        ]
+    }
+
     afterEvaluate {
         if (project.tasks.findByName('check')) {
             check.dependsOn('checkstyle')
+            check.finalizedBy violations
         }
-    }
 
-    gradle.projectsEvaluated {
-        tasks.withType(JavaCompile) {
-            options.compilerArgs << '-Xlint:unchecked' << '-Xlint:deprecation'
+        if (project.hasProperty("android")
+                && project.name != 'pmd'
+                && project.name != 'findbugs') {
+            android {
+                lintOptions {
+                    warningsAsErrors true
+                    quiet true
+                    // Caught by the violations plugin.
+                    abortOnError false
+                }
+            }
+
+            android.variantFilter { variant ->
+                if(variant.buildType.name == 'release') {
+                    variant.setIgnore(true)
+                }
+            }
         }
     }
 }
-
-task wrapper(type: Wrapper) {
-    gradleVersion = '4.1'
-    distributionType = Wrapper.DistributionType.ALL
-}
-
diff --git a/checkstyle.xml b/checkstyle.xml
index ec3f4a74d..52a2c2e5d 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -15,7 +15,9 @@
     </module>
 
     <!-- Ensure trailling newline for compatibility -->
-    <module name="NewlineAtEndOfFile" />
+    <module name="NewlineAtEndOfFile">
+        <property name="lineSeparator" value="lf"/>
+    </module>
 
     <!-- Space after 'for' and 'if' -->
     <module name="RegexpSingleline">
@@ -71,7 +73,7 @@
 
         <!-- Allow common trailing comments used to describe suppressions -->
         <module name="TrailingComment">
-          <property name="legalComment" value="Public API" />
+          <property name="legalComment" value="^Public API.?$|^NOPMD.*$" />
         </module>
 
         <!-- Checks for imports. -->
@@ -92,8 +94,16 @@
         <!-- Prevent importing Mockito matchers directly -->
         <module name="IllegalImport">
             <property name="illegalPkgs" value="org.mockito.internal" />
-            <message key="import.illegal" value="Import from illegal package - {0}. Use org.mockito.Matchers to instantiate argument matchers; or org.hamcrest.Matchers for assertThat." />
+            <message key="import.illegal" value="Import from illegal package - {0}. Use org.mockito.Matchers to instantiate argument matchers." />
         </module>
+
+        <!-- ArgumentMatchers isn't available internally, the same methods are available on org.mockito.Mockito. -->
+        <module name="IllegalImport">
+            <property name="illegalClasses" value="org\.mockito\.ArgumentMatchers.*" />
+            <property name="regexp" value="true" />
+            <message key="import.illegal" value="Import from illegal class - {0}. Use org.mockito.Mockito to statically import matcher methods." />
+        </module>
+
         <module name="ImportOrder">
           <!-- Checks for out of order import statements. -->
 
@@ -103,6 +113,7 @@
            <!-- This ensures that static imports go first. -->
            <property name="option" value="top"/>
            <property name="tokens" value="STATIC_IMPORT, IMPORT"/>
+           <property name="separated" value="true" />
          </module>
 
         <!-- Checks for whitespace. -->
diff --git a/checkstyle_suppressions.xml b/checkstyle_suppressions.xml
index 9faf18dc8..32352561b 100644
--- a/checkstyle_suppressions.xml
+++ b/checkstyle_suppressions.xml
@@ -5,7 +5,11 @@
     "http://www.puppycrawl.com/dtds/suppressions_1_1.dtd">
 
 <suppressions>
-    <suppress files=".*[/\\]library[/\\]src[/\\]test[/\\].*" checks="Javadoc.*"/>
+    <suppress files=".*[/\\]library[/\\]test[/\\]src[/\\]test[/\\].*" checks="Javadoc.*"/>
+    <suppress files=".*[/\\]annotation[/\\]compiler[/\\]test[/\\]src[/\\]test[/\\]resources[/\\].*" checks=".*"/>
+    <suppress files=".*[/\\]instrumentation[/\\]src[/\\].*" checks="Javadoc.*"/>
+    <suppress files=".*[/\\]instrumentation[/\\]src[/\\]androidTest[/\\].*" checks="Javadoc.*"/>
+    <suppress files=".*[/\\]instrumentation[/\\]src[/\\]androidTest[/\\].*[/\\]ResourceIds" checks=".*"/>
     <suppress files=".*[/\\]gif_encoder[/\\].*" checks=".*"/>
     <suppress files=".*RequestBuilder.java|ChildLoadProvider.java|TransitionOptions.java|BaseDecodeOptions.java|RequestOptions.java" checks="NoClone" />
 </suppressions>
diff --git a/debug.keystore b/debug.keystore
new file mode 100644
index 000000000..425f3d6a1
Binary files /dev/null and b/debug.keystore differ
diff --git a/gcloud-bumptech.json.enc b/gcloud-bumptech.json.enc
new file mode 100644
index 000000000..32dff8de0
Binary files /dev/null and b/gcloud-bumptech.json.enc differ
diff --git a/gcloud-sjudd.json.enc b/gcloud-sjudd.json.enc
new file mode 100644
index 000000000..1c9b64237
Binary files /dev/null and b/gcloud-sjudd.json.enc differ
diff --git a/glide/build.gradle b/glide/build.gradle
index 8a1ac2bff..ac0ec536a 100644
--- a/glide/build.gradle
+++ b/glide/build.gradle
@@ -1,3 +1,5 @@
+import com.android.build.gradle.api.LibraryVariant
+
 apply plugin: 'java'
 
 // The paths of Android projects that should be included in the jar and javadoc.
@@ -23,16 +25,16 @@ static def getAndroidPathsForJavadoc() {
 
 // The paths of Java projects that should be included only in Javadoc, not in the jar.
 static def getJavaPathsForJavadoc() {
-    [':annotation', ':annotation:compiler']
+    [':annotation']
 }
 
 (getAndroidPathsForJavadoc() + getAndroidPathsForJar() +
-        getJavaPathsForJar() + getJavaPathsForJavadoc()).forEach {
+        getJavaPathsForJar() + getJavaPathsForJavadoc()).each {
     evaluationDependsOn(it)
 }
 
 def asProjects(paths) {
-    paths.collect { project(it) }
+    paths.collect { String path -> project(path) }
 }
 
 def getAndroidSdkDirectory() {
@@ -59,8 +61,8 @@ def getInternalJavaProjectsForJavadoc() {
     asProjects(getJavaPathsForJavadoc())
 }
 
-def getReleaseVariantAndroidProjectsForJar() {
-    getAndroidLibraryVariantsForJar('release')
+def getAndroidProjectsForJar() {
+    getAndroidLibraryVariantsForJar('debug')
 }
 
 def getAndroidLibraryVariantsForJar(variantName) {
@@ -80,12 +82,15 @@ static def getAndroidLibraryVariants(projects, variantName) {
 }
 
 def getSourceFilesForVariantJar(variantName) {
-    getAndroidLibraryVariantsForJar(variantName).collect { it.javaCompile.source } +
-            getInternalJavaProjectsForJar().collect { it.sourceSets.main.allJava }
+    getAndroidLibraryVariantsForJar(variantName).collect {
+        it.getJavaCompiler().source.findAll {
+            return !it.getName().equals("R.java") && !it.getName().equals("BuildConfig.java")
+        }
+    } + getInternalJavaProjectsForJar().collect { it.sourceSets.main.allJava }
 }
 
 def getSourceFilesForVariantJavadoc(variantName) {
-    getAndroidLibraryVariantsForJavadoc(variantName).collect { it.javaCompile.source } +
+    getAndroidLibraryVariantsForJavadoc(variantName).collect { it.getJavaCompiler().source } +
             getInternalJavaProjectsForJavadoc().collect { it.sourceSets.main.allJava }
 }
 
@@ -93,56 +98,55 @@ def getAndroidJar() {
     "${getAndroidSdkDirectory()}/platforms/${getAndroidCompileSdkVersion()}/android.jar"
 }
 
-def getSupportJar() {
-    "${getAndroidSdkDirectory()}/extras/android/support/v4/android-support-v4.jar"
-}
-
 project.archivesBaseName = "${POM_ARTIFACT_ID}-${VERSION_NAME}"
 
 // Generate javadocs and sources containing batched documentation and sources for all internal
 // projects.
-['release', 'debug'].each { variantName ->
+['debug'].each { variantName ->
 
     task("${variantName}SourceJar", type: Jar) {
-      from getSourceFilesForVariantJar(variantName)
+        from getSourceFilesForVariantJar(variantName)
     }
 
-    def javadocTask = task("${variantName}Javadoc", type: Javadoc) {
+    def javadocTask = tasks.create("${variantName}Javadoc", Javadoc) {
         source = getSourceFilesForVariantJar(variantName)
         source += getSourceFilesForVariantJavadoc(variantName)
 
-        def classpathFiles = files(getAndroidLibraryVariantsForJar(variantName).collect {
-            files(it.javaCompile.classpath.files, getAndroidJar(), getSupportJar())
-        })
-        classpathFiles += files(getAndroidLibraryVariantsForJavadoc(variantName).collect {
-            files(it.javaCompile.classpath.files, getAndroidJar(), getSupportJar())
-        })
-        classpathFiles += (getInternalJavaProjectsForJavadoc().collect {
-            it.sourceSets.main.compileClasspath.files
-        }.flatten())
-        classpathFiles += (getInternalJavaProjectsForJar().collect {
-            it.sourceSets.main.compileClasspath.files
-        }.flatten())
-        // Finds dependencies of Android packages that would otherwise be ignored (Volley in
-        // particular)
-        classpathFiles += getInternalAndroidProjectsForJavadoc().collect {
-            files("${it.projectDir}/build/intermediates/classes/release")
+        doFirst {
+            it.classpath =
+                    project.files(
+                            getAndroidJar(),
+                            getAndroidLibraryVariantsForJar(variantName).collect {
+                                LibraryVariant lib -> lib.getJavaCompiler().classpath.files
+                            },
+                            getAndroidLibraryVariantsForJavadoc(variantName).collect {
+                                LibraryVariant lib -> lib.getJavaCompiler().classpath.files
+                            },
+                            getInternalJavaProjectsForJavadoc().collect { Project project ->
+                                project.sourceSets.main.compileClasspath.files
+                            },
+                            getInternalJavaProjectsForJar().collect { Project project ->
+                                project.sourceSets.main.compileClasspath.files
+                            },
+                            // Finds dependencies of Android packages that would otherwise be
+                            // ignored (Volley in particular)
+                            getInternalAndroidProjectsForJavadoc().collect { Project project ->
+                                project.file('build/intermediates/classes/debug')
+                            }
+            )
         }
-        classpath = files(classpathFiles)
 
         options {
             links("http://docs.oracle.com/javase/7/docs/api/")
             links("https://square.github.io/okhttp/3.x/okhttp/")
             links("https://square.github.io/okhttp/2.x/okhttp/")
-            // TODO: Ideally this would point to something hosted by Android.
-            links("http://afzaln.com/volley/")
             linksOffline("http://d.android.com/reference",
                     "${getAndroidSdkDirectory()}/docs/reference")
         }
 
         exclude '**/BuildConfig.java'
         exclude '**/R.java'
-    } as Javadoc
+    }
 
     def cleanJavadocTask = task("clean${variantName.capitalize()}Javadoc", type: Delete) {
         delete javadocTask.destinationDir
@@ -157,31 +161,34 @@ project.archivesBaseName = "${POM_ARTIFACT_ID}-${VERSION_NAME}"
 
 jar {
     from files(
-            getReleaseVariantAndroidProjectsForJar().collect { variant ->
-                variant.javaCompile.destinationDir
+            getAndroidProjectsForJar().collect { LibraryVariant variant ->
+                variant.getJavaCompiler().destinationDir
             }
     )
+    from files(getInternalJavaProjectsForJar().collect { it.sourceSets.main.output })
     exclude "**/R.class"
     exclude "**/BuildConfig.class"
-    from files(getInternalJavaProjectsForJar().collect { it.sourceSets.main.output })
+    exclude "**/R\$*.class"
+    exclude "android/**"
 }
 
-def getAllInternalProjectBuildDeps() {
-    getInternalAndroidProjectsForJar() + getInternalJavaProjectsForJar() +
-            getInternalJavaProjectsForJavadoc() + getInternalAndroidProjectsForJavadoc()
+(getInternalAndroidProjectsForJar() + getInternalAndroidProjectsForJavadoc()).each {
+    project ->
+        debugJavadoc.dependsOn(project.tasks.compileDebugSources)
+        jar.dependsOn(project.tasks.compileDebugSources)
 }
 
-getAllInternalProjectBuildDeps().each { project ->
-    releaseJavadoc.dependsOn(project.tasks.assemble)
-    debugJavadoc.dependsOn(project.tasks.assemble)
-    jar.dependsOn(project.tasks.build)
+(getInternalJavaProjectsForJar() + getInternalJavaProjectsForJavadoc()).each {
+    project ->
+        debugJavadoc.dependsOn(project.tasks.compileJava)
+        jar.dependsOn(project.tasks.compileJava)
 }
 
 artifacts {
-    archives releaseJavadocJar {
+    archives debugJavadocJar {
         classifier 'javadoc'
     }
-    archives releaseSourceJar {
+    archives debugSourceJar {
         classifier 'sources'
     }
 }
diff --git a/gradle.properties b/gradle.properties
index 52718a675..6e13ac59c 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,10 +1,10 @@
 org.gradle.daemon=true
 org.gradle.configureondemand=true
 
-VERSION_NAME=4.2.0-SNAPSHOT
+VERSION_NAME=4.6.1
 VERSION_MAJOR=4
-VERSION_MINOR=2
-VERSION_PATCH=0
+VERSION_MINOR=6
+VERSION_PATCH=1
 GROUP=com.github.bumptech.glide
 
 POM_DESCRIPTION=A fast and efficient image loading library for Android focused on smooth scrolling.
@@ -15,25 +15,32 @@ POM_SCM_DEV_CONNECTION=scm:git@github.com:bumptech/glide.git
 POM_DEVELOPER_ID=sjudd
 POM_DEVELOPER_NAME=Sam Judd
 POM_DEVELOPER_EMAIL=judds@google.com
-ANDROID_SUPPORT_VERSION=26.0.2
+ANDROID_SUPPORT_VERSION=27.0.2
 VOLLEY_VERSION=1.0.0
-OK_HTTP_VERSION=3.9.0
-ANDROID_GRADLE_VERSION=2.3.0
+OK_HTTP_VERSION=3.9.1
+ANDROID_GRADLE_VERSION=3.0.1
 DAGGER_VERSION=2.11
 
-COVERALLS_GRADLE_VERSION=2.4.0
-JUNIT_VERSION=4.12
-MOCKITO_VERSION=1.10.19
-ROBOLECTRIC_VERSION=3.3.2
+JUNIT_VERSION=4.13-SNAPSHOT
+# Matches the version in Google.
+MOCKITO_VERSION=1.9.5
+MOCKITO_ANDROID_VERSION=2.11.0
+ROBOLECTRIC_VERSION=3.6.1
 MOCKWEBSERVER_VERSION=3.0.0-RC1
-TRUTH_VERSION=0.26
+TRUTH_VERSION=0.36
+JSR_305_VERSION=3.0.2
+AUTO_SERVICE_VERSION=1.0-rc3
+JAVAPOET_VERSION=1.9.0
 
+PMD_VERSION=6.0.0
 FINDBUGS_VERSION=3.0.0
-JACOCO_VERSION=0.7.1.201405082137
+ERROR_PRONE_VERSION=2.1.4-SNAPSHOT
+ERROR_PRONE_PLUGIN_VERSION=0.0.13
+VIOLATIONS_PLUGIN_VERSION=1.8
 
-COMPILE_SDK_VERSION=26
-BUILD_TOOLS_VERSION=26.0.1
-TARGET_SDK_VERSION=26
+COMPILE_SDK_VERSION=27
+TARGET_SDK_VERSION=27
 MIN_SDK_VERSION=14
 
-org.gradle.jvmargs=-Xmx2048M
+org.gradle.jvmargs=-Xmx4096M
+TEST_JVM_MEMORY_SIZE=4096M
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index 7a3265ee9..6b6ea3ab4 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index bf1b63c34..702c4b68b 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -2,4 +2,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.3.1-all.zip
diff --git a/instrumentation/build.gradle b/instrumentation/build.gradle
new file mode 100644
index 000000000..c9ab489a7
--- /dev/null
+++ b/instrumentation/build.gradle
@@ -0,0 +1,49 @@
+tasks.whenTaskAdded { task ->
+    if (task.name == "lint") {
+        task.enabled = false
+    }
+}
+apply plugin: 'com.android.application'
+
+dependencies {
+    // Appcompat is required to ensure that Glide's runtime detection the v7 support Drawable
+    // loading classes functions. It's not clear why androidTestImplementation isn't sufficient, but for
+    // whatever reason, compile is the only dependency that seems to work.
+    implementation ("com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}") {
+        exclude group: 'android.arch.core'
+    }
+    annotationProcessor project(":annotation:compiler")
+    implementation project(":library")
+
+    androidTestImplementation project(':library')
+    androidTestImplementation "org.mockito:mockito-android:${MOCKITO_ANDROID_VERSION}"
+    androidTestImplementation "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
+    androidTestImplementation "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}"
+    androidTestImplementation 'com.android.support.test:runner:1.0.1'
+    androidTestImplementation 'com.android.support.test:rules:1.0.1'
+    androidTestImplementation "com.google.truth:truth:${TRUTH_VERSION}"
+    androidTestImplementation "junit:junit:${JUNIT_VERSION}"
+    // Not totally clear why this is required, but it seems to be missing when tests are run on
+    // 4.1.2 and 4.2.0 emulators.
+    androidTestImplementation 'com.google.code.findbugs:jsr305:3.0.2'
+
+}
+
+android {
+    compileSdkVersion COMPILE_SDK_VERSION as int
+
+    defaultConfig {
+        applicationId 'com.bumptech.glide.instrumentation'
+        minSdkVersion MIN_SDK_VERSION as int
+        targetSdkVersion TARGET_SDK_VERSION as int
+        versionCode 1
+        versionName '1.0'
+        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+    }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
+}
+
diff --git a/instrumentation/src/androidTest/AndroidManifest.xml b/instrumentation/src/androidTest/AndroidManifest.xml
new file mode 100644
index 000000000..f12090f37
--- /dev/null
+++ b/instrumentation/src/androidTest/AndroidManifest.xml
@@ -0,0 +1,11 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+  package="com.bumptech.glide.instrumentation.test">
+  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
+  <application android:label="GlideTest">
+    <uses-library android:name="android.test.runner" />
+  </application>
+
+  <instrumentation android:targetPackage="com.bumptech.glide.instrumentation"
+                   android:name="com.google.android.apps.common.testing.testrunner.Google3InstrumentationTestRunner"
+                   android:label="Glide Emulator Tests" />
+</manifest>
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/AsBytesTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/AsBytesTest.java
new file mode 100644
index 000000000..920e9635b
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/AsBytesTest.java
@@ -0,0 +1,221 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.drawable.BitmapDrawable;
+import android.net.Uri;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import com.google.common.io.ByteStreams;
+import java.io.BufferedOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.concurrent.TimeUnit;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(AndroidJUnit4.class)
+public class AsBytesTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+
+  private Context context;
+
+  @Before
+  public void setUp() throws IOException {
+    MockitoAnnotations.initMocks(this);
+    context = InstrumentationRegistry.getTargetContext();
+  }
+
+  @Test
+  public void loadImageResourceId_asBytes_providesBytesOfBitmap() {
+    byte[] data =
+        concurrency.get(
+            Glide.with(context)
+                .as(byte[].class)
+                .load(ResourceIds.raw.canonical)
+                .submit());
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadBitmap_asBytes_providesBytesOfBitmap() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    byte[] data =
+        concurrency.get(
+            Glide.with(context)
+                .as(byte[].class)
+                .load(bitmap)
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadBitmapDrawable_asBytes_providesBytesOfBitmap() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    byte[] data =
+        concurrency.get(
+            Glide.with(context)
+                .as(byte[].class)
+                .load(new BitmapDrawable(context.getResources(), bitmap))
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceId_asBytes_providesBytesOfFrame() {
+    byte[] data =
+        concurrency.get(
+            Glide.with(context)
+                .as(byte[].class)
+                .load(ResourceIds.raw.video)
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceId_asBytes_withFrameTime_providesBytesOfFrame() {
+    byte[] data =
+        concurrency.get(
+            GlideApp.with(context)
+                .as(byte[].class)
+                .load(ResourceIds.raw.video)
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoFile_asBytes_providesByteOfFrame() throws IOException {
+    byte[] data =
+        concurrency.get(
+            Glide.with(context)
+                .as(byte[].class)
+                .load(writeVideoToFile())
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoFile_asBytes_withFrameTime_providesByteOfFrame() throws IOException {
+    byte[] data =
+        concurrency.get(
+            GlideApp.with(context)
+                .as(byte[].class)
+                .load(writeVideoToFile())
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoFilePath_asBytes_providesByteOfFrame() throws IOException {
+    byte[] data =
+        concurrency.get(
+            Glide.with(context)
+                .as(byte[].class)
+                .load(writeVideoToFile().getAbsolutePath())
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoFilePath_asBytes_withFrameTime_providesByteOfFrame() throws IOException {
+    byte[] data =
+        concurrency.get(
+            GlideApp.with(context)
+                .as(byte[].class)
+                .load(writeVideoToFile().getAbsolutePath())
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoFileUri_asBytes_providesByteOfFrame() throws IOException {
+    byte[] data =
+        concurrency.get(
+            Glide.with(context)
+                .as(byte[].class)
+                .load(Uri.fromFile(writeVideoToFile()))
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoFileUri_asBytes_withFrameTime_providesByteOfFrame() throws IOException {
+    byte[] data =
+        concurrency.get(
+            GlideApp.with(context)
+                .as(byte[].class)
+                .load(Uri.fromFile(writeVideoToFile()))
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  private File writeVideoToFile() throws IOException {
+    byte[] videoData = loadVideoBytes();
+    File parent = context.getCacheDir();
+    if (!parent.mkdirs() && (!parent.exists() || !parent.isDirectory())) {
+      throw new IllegalStateException("Failed to mkdirs for: " + parent);
+    }
+    File toWrite = new File(parent, "temp.jpeg");
+    if (toWrite.exists() && !toWrite.delete()) {
+      throw new IllegalStateException("Failed to delete existing temp file: " + toWrite);
+    }
+
+    OutputStream os = null;
+    try {
+      os = new BufferedOutputStream(new FileOutputStream(toWrite));
+      os.write(videoData);
+      os.close();
+    } finally {
+      if (os != null) {
+        os.close();
+      }
+    }
+    return toWrite;
+  }
+
+  private byte[] loadVideoBytes() throws IOException {
+    Resources resources = context.getResources();
+    InputStream is = resources.openRawResource(ResourceIds.raw.video);
+    return ByteStreams.toByteArray(is);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/AsFileTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/AsFileTest.java
new file mode 100644
index 000000000..057c95c5a
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/AsFileTest.java
@@ -0,0 +1,124 @@
+package com.bumptech.glide;
+
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import android.content.Context;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.MockModelLoader;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+public class AsFileTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private final Context context = InstrumentationRegistry.getTargetContext();
+
+  @Test
+  public void asFile_withUrl_succeeds() {
+    String url = "https://www.w3schools.com/howto/img_fjords.jpg";
+
+    MockModelLoader.mock(url, getData());
+
+    File file =
+        concurrency.get(
+            GlideApp.with(context)
+                .asFile()
+                .load("https://www.w3schools.com/howto/img_fjords.jpg")
+                .submit());
+    assertThat(file).isNotNull();
+  }
+
+  @Test
+  public void asFile_withUrlAndDiskCacheStrategyData_succeeds() {
+    String url = "https://www.w3schools.com/howto/img_fjords.jpg";
+
+    MockModelLoader.mock(url, getData());
+
+    File file =
+        concurrency.get(
+            GlideApp.with(context)
+                .asFile()
+                .diskCacheStrategy(DiskCacheStrategy.DATA)
+                .load("https://www.w3schools.com/howto/img_fjords.jpg")
+                .submit());
+    assertThat(file).isNotNull();
+  }
+
+  @Test
+  public void asFile_withUrlAndDiskCacheStrategyResource_fails() {
+    String url = "https://www.w3schools.com/howto/img_fjords.jpg";
+
+    MockModelLoader.mock(url, getData());
+
+    try {
+      concurrency.get(
+          GlideApp.with(context)
+              .asFile()
+              .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+              .load("https://www.w3schools.com/howto/img_fjords.jpg")
+              .submit());
+      fail();
+    } catch (RuntimeException e) {
+      // expected.
+    }
+  }
+
+  @Test
+  public void asFile_withUrlAndDiskCacheStrategyAll_fails() {
+    String url = "https://www.w3schools.com/howto/img_fjords.jpg";
+
+    MockModelLoader.mock(url, getData());
+
+    try {
+      concurrency.get(
+          GlideApp.with(context)
+              .asFile()
+              .diskCacheStrategy(DiskCacheStrategy.ALL)
+              .load("https://www.w3schools.com/howto/img_fjords.jpg")
+              .submit());
+      fail();
+    } catch (RuntimeException e) {
+      // Expected.
+    }
+  }
+
+  private InputStream getData() {
+    InputStream is = null;
+    try {
+      is = context.getResources().openRawResource(ResourceIds.raw.canonical);
+      byte[] buffer = new byte[1024 * 1024];
+      ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+      int read;
+      while ((read = is.read(buffer)) != -1) {
+        outputStream.write(buffer, 0, read);
+      }
+      byte[] data = outputStream.toByteArray();
+      return new ByteArrayInputStream(data);
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    } finally {
+      if (is != null) {
+        try {
+          is.close();
+        } catch (IOException e) {
+          // Ignored.
+        }
+      }
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java
new file mode 100644
index 000000000..194d5afbf
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java
@@ -0,0 +1,493 @@
+package com.bumptech.glide;
+
+import static com.bumptech.glide.test.Matchers.anyDrawable;
+import static com.bumptech.glide.test.Matchers.anyDrawableTarget;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertThrows;
+import static org.junit.Assert.fail;
+import static org.mockito.AdditionalMatchers.not;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.anyBoolean;
+import static org.mockito.Mockito.eq;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.verify;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.os.Handler;
+import android.os.Looper;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import android.view.ViewGroup.LayoutParams;
+import android.widget.ImageView;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.engine.cache.LruResourceCache;
+import com.bumptech.glide.load.engine.cache.MemoryCacheAdapter;
+import com.bumptech.glide.request.FutureTarget;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.test.BitmapSubject;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.ResourceIds.raw;
+import com.bumptech.glide.test.TearDownGlide;
+import com.bumptech.glide.test.WaitModelLoader;
+import com.bumptech.glide.test.WaitModelLoader.WaitModel;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.function.ThrowingRunnable;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+/**
+ * Tests various aspects of memory and disk caching to verify resources can be retrieved as we
+ * expect.
+ */
+@RunWith(AndroidJUnit4.class)
+public class CachingTest {
+  private static final int IMAGE_SIZE_PIXELS = 500;
+  // Store at least 10 500x500 pixel Bitmaps with the ARGB_8888 config to be safe.
+  private static final long CACHE_SIZE_BYTES =
+      IMAGE_SIZE_PIXELS * IMAGE_SIZE_PIXELS * 4 * 10;
+
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+  @Mock private RequestListener<Drawable> requestListener;
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+
+  private Context context;
+
+  @Before
+  public void setUp() throws InterruptedException {
+    MockitoAnnotations.initMocks(this);
+    context = InstrumentationRegistry.getTargetContext();
+
+    Glide.init(
+        context, new GlideBuilder().setMemoryCache(new LruResourceCache(CACHE_SIZE_BYTES)));
+  }
+
+  @Test
+  public void submit_withDisabledMemoryCache_andResourceInActiveResources_loadsFromMemory() {
+    Glide.init(
+        context, new GlideBuilder().setMemoryCache(new MemoryCacheAdapter()));
+
+    FutureTarget<Drawable> first =
+        GlideApp.with(context)
+            .load(raw.canonical)
+            .submit();
+    concurrency.get(first);
+
+    concurrency.get(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.MEMORY_CACHE),
+            anyBoolean());
+  }
+
+  @Test
+  public void submit_withRequestClearedFromMemory_doesNotLoadFromMemory() {
+    Glide.init(
+        context, new GlideBuilder().setMemoryCache(new MemoryCacheAdapter()));
+
+    // Allow the request to be run and GCed without being cleared.
+    concurrency.loadOnOtherThread(new Runnable() {
+      @Override
+      public void run() {
+        FutureTarget<Drawable> first =
+            GlideApp.with(context)
+                .load(raw.canonical)
+                .submit();
+        concurrency.get(first);
+      }
+    });
+
+    // Wait for the weak reference to be cleared and the request to be removed from active
+    // resources.
+    // De-flake by allowing multiple tries
+    boolean isWeakRefCleared = false;
+    for (int j = 0; j < 100; j++) {
+      Runtime.getRuntime().gc();
+      concurrency.pokeMainThread();
+      try {
+        // Loading again here won't shuffle our resource around because it only changes our
+        // reference count from 1 to 2 and back. The reference we're waiting for will only be
+        // decremented when the target is GCed.
+        Target<Drawable> target =
+            concurrency.wait(
+                GlideApp.with(context)
+                    .load(ResourceIds.raw.canonical)
+                    .onlyRetrieveFromCache(true)
+                    .diskCacheStrategy(DiskCacheStrategy.NONE)
+                    .submit());
+        GlideApp.with(context).clear(target);
+      } catch (RuntimeException e) {
+        // The item has been cleared from active resources.
+        isWeakRefCleared = true;
+        break;
+      }
+    }
+
+    if (!isWeakRefCleared) {
+      fail("Failed to clear weak ref.");
+    }
+
+    concurrency.get(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            not(eq(DataSource.MEMORY_CACHE)),
+            anyBoolean());
+  }
+
+  @Test
+  public void submit_withPreviousRequestClearedFromMemory_completesFromDataDiskCache()
+      throws InterruptedException, ExecutionException, TimeoutException {
+    FutureTarget<Drawable> future = GlideApp.with(context)
+        .load(ResourceIds.raw.canonical)
+        .diskCacheStrategy(DiskCacheStrategy.DATA)
+        .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS);
+    concurrency.get(future);
+    GlideApp.with(context).clear(future);
+
+    clearMemoryCacheOnMainThread();
+
+    concurrency.get(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .diskCacheStrategy(DiskCacheStrategy.DATA)
+            .listener(requestListener)
+            .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.DATA_DISK_CACHE),
+            anyBoolean());
+  }
+
+  @Test
+  public void submit_withPreviousButNoLongerReferencedIdenticalRequest_completesFromMemoryCache()
+      throws InterruptedException, TimeoutException, ExecutionException {
+    // We can't allow any mocks (RequestListner, Target etc) to reference this request or the test
+    // will fail due to the transient strong reference to the request.
+    concurrency.get(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));
+
+    // Force the collection of weak references now that the listener/request in the first load is no
+    // longer referenced.
+    Runtime.getRuntime().gc();
+    concurrency.pokeMainThread();
+
+    concurrency.get(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .listener(requestListener)
+            .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.MEMORY_CACHE),
+            anyBoolean());
+  }
+
+  @Test
+  public void submit_withPreviousButNoLongerReferencedIdenticalRequest_doesNotRecycleBitmap()
+      throws InterruptedException, TimeoutException, ExecutionException {
+    // We can't allow any mocks (RequestListener, Target etc) to reference this request or the test
+    // will fail due to the transient strong reference to the request.
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(ResourceIds.raw.canonical)
+                .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+                .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));
+
+    // Force the collection of weak references now that the listener/request in the first load is no
+    // longer referenced.
+    Runtime.getRuntime().gc();
+    concurrency.pokeMainThread();
+
+    FutureTarget<Bitmap> future = GlideApp.with(context)
+        .asBitmap()
+        .load(ResourceIds.raw.canonical)
+        .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+        .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS);
+    concurrency.get(future);
+    Glide.with(context).clear(future);
+
+    clearMemoryCacheOnMainThread();
+
+    BitmapSubject.assertThat(bitmap).isNotRecycled();
+  }
+
+  @Test
+  public void clearDiskCache_doesNotPreventFutureLoads()
+      throws ExecutionException, InterruptedException, TimeoutException {
+    FutureTarget<Drawable> future = GlideApp.with(context)
+        .load(ResourceIds.raw.canonical)
+        .diskCacheStrategy(DiskCacheStrategy.DATA)
+        .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS);
+    concurrency.get(future);
+    GlideApp.with(context).clear(future);
+
+    clearMemoryCacheOnMainThread();
+    GlideApp.get(context).clearDiskCache();
+
+    future = GlideApp.with(context)
+        .load(ResourceIds.raw.canonical)
+        .diskCacheStrategy(DiskCacheStrategy.DATA)
+        .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS);
+    concurrency.get(future);
+
+    GlideApp.with(context).clear(future);
+    clearMemoryCacheOnMainThread();
+
+    concurrency.get(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+            .diskCacheStrategy(DiskCacheStrategy.DATA)
+            .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.DATA_DISK_CACHE),
+            anyBoolean());
+  }
+
+  // Tests #2428.
+  @Test
+  public void onlyRetrieveFromCache_withPreviousRequestLoadingFromSource_doesNotBlock() {
+    final WaitModel<Integer> waitModel = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);
+
+    FutureTarget<Drawable> loadFromSourceFuture = GlideApp.with(context)
+        .load(waitModel)
+        .submit();
+
+    FutureTarget<Drawable> onlyFromCacheFuture = GlideApp.with(context)
+        .load(waitModel)
+        .onlyRetrieveFromCache(true)
+        .submit();
+    try {
+      onlyFromCacheFuture.get(1000, TimeUnit.MILLISECONDS);
+      fail("Expected only from cache Future to time out");
+    } catch (InterruptedException | TimeoutException e) {
+      throw new RuntimeException(e);
+    } catch (ExecutionException e) {
+      // Expected.
+    }
+    waitModel.countDown();
+
+    assertThat(concurrency.get(loadFromSourceFuture)).isNotNull();
+  }
+
+  // Tests #2428.
+  @Test
+  public void submit_withRequestLoadingWithOnlyRetrieveFromCache_andNotInCache_doesNotFail() {
+    // Block the main thread so that we know that both requests will be queued but not started at
+    // the same time.
+    final CountDownLatch blockMainThread = new CountDownLatch(1);
+    new Handler(Looper.getMainLooper()).post(new Runnable() {
+      @Override
+      public void run() {
+         try {
+          blockMainThread.await();
+        } catch (InterruptedException e) {
+          throw new RuntimeException(e);
+        }
+      }
+    });
+
+    // Queue the retrieve from cache request first.
+    final Future<Drawable> firstQueuedFuture = GlideApp.with(context)
+        .load(ResourceIds.raw.canonical)
+        .onlyRetrieveFromCache(true)
+        .submit();
+
+    // Then queue the normal request.
+    FutureTarget<Drawable> expectedFuture =
+        GlideApp.with(context).load(ResourceIds.raw.canonical).submit();
+
+    // Run the requests.
+    blockMainThread.countDown();
+
+    // Verify that the request that didn't have retrieve from cache succeeds
+    assertThat(concurrency.get(expectedFuture)).isNotNull();
+    // The first request only from cache should fail because the item is not in cache.
+    assertThrows(RuntimeException.class, new ThrowingRunnable() {
+      @Override
+      public void run() throws Throwable {
+        concurrency.get(firstQueuedFuture);
+      }
+    });
+  }
+
+  @Test
+  public void loadIntoView_withoutSkipMemoryCache_loadsFromMemoryCacheIfPresent() {
+    final ImageView imageView = new ImageView(context);
+    imageView.setLayoutParams(new LayoutParams(100, 100));
+
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+            .dontTransform(),
+        imageView);
+
+    // Casting avoids a varags array warning.
+    //noinspection rawtypes
+    reset((RequestListener) requestListener);
+
+    // Run on the main thread, since this is already cached, we shouldn't need to try to wait. If we
+    // do end up re-using the old Target, our wait will always timeout anyway if we use
+    // loadOnMainThread. If the load doesn't complete in time, it will be caught by the listener
+    // below, which expects to be called synchronously.
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.with(context)
+                .load(ResourceIds.raw.canonical)
+                .listener(requestListener)
+                .dontTransform()
+                .into(imageView);
+          }
+        });
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.MEMORY_CACHE),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadIntoView_withSkipMemoryCacheFalse_loadsFromMemoryCacheIfPresent() {
+    final ImageView imageView = new ImageView(context);
+    imageView.setLayoutParams(new LayoutParams(100, 100));
+
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+            .skipMemoryCache(false)
+            .dontTransform(),
+        imageView);
+
+    // Casting avoids a varags array warning.
+    //noinspection rawtypes
+    reset((RequestListener) requestListener);
+
+    // Run on the main thread, since this is already cached, we shouldn't need to try to wait. If we
+    // do end up re-using the old Target, our wait will always timeout anyway if we use
+    // loadOnMainThread. If the load doesn't complete in time, it will be caught by the listener
+    // below, which expects to be called synchronously.
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.with(context)
+                .load(ResourceIds.raw.canonical)
+                .listener(requestListener)
+                .skipMemoryCache(false)
+                .dontTransform()
+                .into(imageView);
+          }
+        });
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.MEMORY_CACHE),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadIntoView_withSkipMemoryCache_doesNotLoadFromMemoryCacheIfPresent() {
+    final ImageView imageView = new ImageView(context);
+    imageView.setLayoutParams(new LayoutParams(100, 100));
+
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+            .dontTransform()
+            .skipMemoryCache(true),
+        imageView);
+
+    // Casting avoids a varags array warning.
+    //noinspection rawtypes
+    reset((RequestListener) requestListener);
+
+    // If this test fails due to a timeout, it's because we re-used the Target from the previous
+    // request, which breaks the logic in loadOnMainThread that expects a new Target's
+    // onResourceReady callback to be called. This can be confirmed by changing this to
+    // runOnMainThread and verifying that the RequestListener assertion below fails because
+    // the DataSource was from the memory cache.
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+            .dontTransform()
+            .skipMemoryCache(true),
+        imageView);
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            not(eq(DataSource.MEMORY_CACHE)),
+            anyBoolean());
+  }
+
+  private void clearMemoryCacheOnMainThread() throws InterruptedException {
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.get(context).clearMemory();
+      }
+    });
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/CenterCropRegressionTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/CenterCropRegressionTest.java
new file mode 100644
index 000000000..17e397879
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CenterCropRegressionTest.java
@@ -0,0 +1,96 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.test.BitmapRegressionTester;
+import com.bumptech.glide.test.CanonicalBitmap;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.RegressionTest;
+import com.bumptech.glide.test.SplitByCpu;
+import com.bumptech.glide.test.SplitBySdk;
+import com.bumptech.glide.test.TearDownGlide;
+import java.util.concurrent.ExecutionException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestName;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+@RegressionTest
+@SplitByCpu
+@SplitBySdk({24, 21, 16})
+public class CenterCropRegressionTest {
+  @Rule public final TestName testName = new TestName();
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private BitmapRegressionTester bitmapRegressionTester;
+  private Context context;
+  private CanonicalBitmap canonical;
+
+  @Before
+  public void setUp() {
+    context = InstrumentationRegistry.getTargetContext();
+    bitmapRegressionTester = new BitmapRegressionTester(getClass(), testName);
+    canonical = new CanonicalBitmap();
+  }
+
+  @Test
+  public void centerCrop_withSquareSmallerThanImage_returnsSquareImage()
+      throws ExecutionException, InterruptedException {
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .centerCrop()
+                .override(50));
+    assertThat(result.getWidth()).isEqualTo(50);
+    assertThat(result.getHeight()).isEqualTo(50);
+  }
+
+  @Test
+  public void centerCrop_withRectangleSmallerThanImage_returnsRectangularImage()
+      throws ExecutionException, InterruptedException {
+     Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .centerCrop()
+                .override(60, 70));
+    assertThat(result.getWidth()).isEqualTo(60);
+    assertThat(result.getHeight()).isEqualTo(70);
+  }
+
+  @Test
+  public void centerCrop_withSquareLargerThanImage_returnsUpscaledRectangularImage()
+      throws ExecutionException, InterruptedException {
+    Bitmap result =
+          bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .centerCrop()
+                .override(canonical.getWidth() * 2));
+    assertThat(result.getWidth()).isEqualTo(canonical.getWidth() * 2);
+    assertThat(result.getHeight()).isEqualTo(canonical.getWidth() * 2);
+  }
+
+  @Test
+  public void centerCrop_withRectangleLargerThanImage_returnsUpscaledRectangularImage()
+      throws ExecutionException, InterruptedException {
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .centerCrop()
+                .override(canonical.getWidth() * 2, canonical.getHeight() * 2));
+    assertThat(result.getWidth()).isEqualTo(canonical.getWidth() * 2);
+    assertThat(result.getHeight()).isEqualTo(canonical.getHeight() * 2);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/CenterInsideRegressionTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/CenterInsideRegressionTest.java
new file mode 100644
index 000000000..5643c3b73
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CenterInsideRegressionTest.java
@@ -0,0 +1,105 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.test.BitmapRegressionTester;
+import com.bumptech.glide.test.CanonicalBitmap;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.RegressionTest;
+import com.bumptech.glide.test.SplitByCpu;
+import com.bumptech.glide.test.SplitBySdk;
+import com.bumptech.glide.test.TearDownGlide;
+import java.util.concurrent.ExecutionException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.rules.TestName;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+@SplitByCpu
+@SplitBySdk({24, 21, 16})
+@RegressionTest
+public class CenterInsideRegressionTest {
+  @Rule public final TestName testName = new TestName();
+  @Rule public final ExpectedException expectedException = ExpectedException.none();
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private BitmapRegressionTester bitmapRegressionTester;
+  private Context context;
+  private CanonicalBitmap canonical;
+
+  @Before
+  public void setUp() {
+    context = InstrumentationRegistry.getTargetContext();
+    bitmapRegressionTester = new BitmapRegressionTester(getClass(), testName);
+    canonical = new CanonicalBitmap();
+  }
+
+  @Test
+  public void centerInside_withSquareSmallerThanImage_returnsImageFitWithinSquare()
+      throws ExecutionException, InterruptedException {
+
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .centerInside()
+                .override(50));
+
+    assertThat(result.getWidth()).isEqualTo(50);
+    assertThat(result.getHeight()).isEqualTo(37);
+  }
+
+  @Test
+  public void centerInside_withSquareLargerThanImage_returnsOriginalImage()
+      throws ExecutionException, InterruptedException {
+    float multiplier = 1.1f;
+    int multipliedWidth = (int) (canonical.getWidth() * multiplier);
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+              .asBitmap()
+              .load(canonical.getBitmap())
+              .centerInside()
+              .override(multipliedWidth));
+
+    assertThat(result.getWidth()).isEqualTo(canonical.getWidth());
+    assertThat(result.getHeight()).isEqualTo(canonical.getHeight());
+  }
+
+  @Test
+  public void centerInside_withNarrowRectangle_fitsWithinMaintainingAspectRatio()
+      throws ExecutionException, InterruptedException {
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+              .asBitmap()
+              .load(canonical.getBitmap())
+              .centerInside()
+              .override(canonical.getWidth() / 10, canonical.getHeight()));
+
+    assertThat(result.getWidth()).isEqualTo(canonical.getWidth() / 10);
+    assertThat(result.getHeight()).isEqualTo(canonical.getHeight() / 10);
+  }
+
+  @Test
+  public void centerInside_withShortRectangle_fitsWithinMaintainingAspectRatio()
+      throws ExecutionException, InterruptedException {
+     Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+              .asBitmap()
+              .load(canonical.getBitmap())
+              .centerInside()
+              .override(canonical.getWidth(), canonical.getHeight() / 2));
+
+    assertThat(result.getWidth()).isEqualTo(canonical.getWidth() / 2);
+    assertThat(result.getHeight()).isEqualTo(canonical.getHeight() / 2);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/CircleCropRegressionTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/CircleCropRegressionTest.java
new file mode 100644
index 000000000..d64c521e9
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CircleCropRegressionTest.java
@@ -0,0 +1,104 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.test.BitmapRegressionTester;
+import com.bumptech.glide.test.CanonicalBitmap;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.RegressionTest;
+import com.bumptech.glide.test.SplitByCpu;
+import com.bumptech.glide.test.SplitBySdk;
+import com.bumptech.glide.test.TearDownGlide;
+import java.util.concurrent.ExecutionException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.rules.TestName;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+@SplitByCpu
+@SplitBySdk({26, 24, 23, 21, 18, 16})
+@RegressionTest
+public class CircleCropRegressionTest {
+  @Rule public final TestName testName = new TestName();
+  @Rule public final ExpectedException expectedException = ExpectedException.none();
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private BitmapRegressionTester bitmapRegressionTester;
+  private Context context;
+  private CanonicalBitmap canonical;
+
+  @Before
+  public void setUp() {
+    context = InstrumentationRegistry.getTargetContext();
+    bitmapRegressionTester = new BitmapRegressionTester(getClass(), testName);
+    canonical = new CanonicalBitmap();
+  }
+
+  @Test
+  public void circleCrop_withSquareSmallerThanImage_returnsSquaredImage()
+      throws ExecutionException, InterruptedException {
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .circleCrop()
+                .override(50));
+
+    assertThat(result.getWidth()).isEqualTo(50);
+    assertThat(result.getHeight()).isEqualTo(50);
+  }
+
+  @Test
+  public void circleCrop_withSquareLargerThanImage_returnsUpscaledFitImage()
+      throws ExecutionException, InterruptedException {
+    float multiplier = 1.1f;
+    int multipliedWidth = (int) (canonical.getWidth() * multiplier);
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+              .asBitmap()
+              .load(canonical.getBitmap())
+              .circleCrop()
+              .override(multipliedWidth));
+
+    assertThat(result.getWidth()).isEqualTo(multipliedWidth);
+    assertThat(result.getHeight()).isEqualTo(multipliedWidth);
+  }
+
+  @Test
+  public void circleCrop_withNarrowRectangle_cropsWithin()
+      throws ExecutionException, InterruptedException {
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+              .asBitmap()
+              .load(canonical.getBitmap())
+              .circleCrop()
+              .override(canonical.getWidth() / 10, canonical.getHeight()));
+
+    assertThat(result.getWidth()).isEqualTo(canonical.getWidth() / 10);
+    assertThat(result.getHeight()).isEqualTo(canonical.getWidth() / 10);
+  }
+
+  @Test
+  public void circleCrop_withShortRectangle_fitsWithinMaintainingAspectRatio()
+      throws ExecutionException, InterruptedException {
+     Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+              .asBitmap()
+              .load(canonical.getBitmap())
+              .circleCrop()
+              .override(canonical.getWidth(), canonical.getHeight() / 2));
+
+    assertThat(result.getWidth()).isEqualTo(canonical.getHeight() / 2);
+    assertThat(result.getHeight()).isEqualTo(canonical.getHeight() / 2);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/DataUriTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/DataUriTest.java
new file mode 100644
index 000000000..0b46ad79d
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/DataUriTest.java
@@ -0,0 +1,105 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.CompressFormat;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import android.util.Base64;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import java.io.ByteArrayOutputStream;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+public class DataUriTest {
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private final Context context = InstrumentationRegistry.getTargetContext();
+
+  @Test
+  public void load_withJpegAsDataUriString_returnsBitmap() {
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(getDataUriString(CompressFormat.JPEG))
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withPngDataUriString_returnsBitmap() {
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(getDataUriString(CompressFormat.PNG))
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withJpegAsDataUri_returnsBitmap() {
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(getDataUri(CompressFormat.JPEG))
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withPngAsDataUri_returnsBitmap() {
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(getDataUri(CompressFormat.PNG))
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  private Uri getDataUri(CompressFormat format) {
+    return Uri.parse(getDataUriString(format));
+  }
+
+  private String getDataUriString(CompressFormat format) {
+    String bytes = getBase64BitmapBytes(format);
+    String imageType;
+    switch (format) {
+      case PNG:
+        imageType = "png";
+        break;
+      case JPEG:
+        imageType = "jpeg";
+        break;
+      case WEBP:
+        imageType = "webp";
+        break;
+      default:
+        throw new IllegalArgumentException("Unrecognized format: " + format);
+    }
+
+    String mimeType = "image/" + imageType;
+    return "data:" + mimeType + ";base64," + bytes;
+  }
+
+  private String getBase64BitmapBytes(CompressFormat format) {
+    ByteArrayOutputStream bos = new ByteArrayOutputStream();
+    Drawable drawable = context.getResources().getDrawable(ResourceIds.raw.canonical);
+    Bitmap bitmap = ((BitmapDrawable) drawable).getBitmap();
+    bitmap.compress(format, 100, bos);
+    byte[] data = bos.toByteArray();
+    return Base64.encodeToString(data, /*flags=*/ 0);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/DrawableTransformationTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/DrawableTransformationTest.java
new file mode 100644
index 000000000..370805966
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/DrawableTransformationTest.java
@@ -0,0 +1,209 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.ColorDrawable;
+import android.graphics.drawable.Drawable;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.resource.bitmap.TransformationUtils;
+import com.bumptech.glide.request.RequestOptions;
+import com.bumptech.glide.test.BitmapSubject;
+import com.bumptech.glide.test.GlideApp;
+import java.util.concurrent.ExecutionException;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+public class DrawableTransformationTest {
+  @Rule public final ExpectedException expectedException = ExpectedException.none();
+
+  private Context context;
+
+  @Before
+  public void setUp() {
+    context = InstrumentationRegistry.getTargetContext();
+  }
+
+  @After
+  public void tearDown() {
+    Glide.get(context).clearDiskCache();
+    Glide.tearDown();
+  }
+
+  @Test
+  public void load_withColorDrawable_sizeOriginal_optionalTransform_returnsColorDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable colorDrawable = new ColorDrawable(Color.RED);
+    Drawable result = Glide.with(context)
+        .load(colorDrawable)
+        .apply(new RequestOptions()
+            .optionalCenterCrop())
+        .submit()
+        .get();
+
+    assertThat(result).isInstanceOf(ColorDrawable.class);
+    assertThat(((ColorDrawable) result).getColor()).isEqualTo(Color.RED);
+  }
+
+  /**
+   * Transformations that do nothing can simply return the original Bitmap.
+   */
+  @Test
+  public void load_withColorDrawable_fixedSize_requiredUnitTransform_returnsOriginalDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable colorDrawable = new ColorDrawable(Color.RED);
+
+    Drawable result = Glide.with(context)
+        .load(colorDrawable)
+        .apply(new RequestOptions()
+            .centerCrop())
+        .submit(100, 100)
+        .get();
+
+    assertThat(result).isInstanceOf(ColorDrawable.class);
+    assertThat(((ColorDrawable) result).getColor()).isEqualTo(Color.RED);
+  }
+
+  /**
+   * Transformations that produce a different output color/shape/image etc will end up returning
+   * a {@link Bitmap} based on the original {@link Drawable} but with the transformation applied.
+   */
+  @Test
+  public void load_withColorDrawable_fixedSize_nonUnitRequiredTransform_returnsBitmapDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable colorDrawable = new ColorDrawable(Color.RED);
+
+    Drawable result = Glide.with(context)
+        .load(colorDrawable)
+        .apply(new RequestOptions()
+            .circleCrop())
+        .submit(100, 100)
+        .get();
+
+    Bitmap redSquare = Bitmap.createBitmap(100, 100, Config.ARGB_8888);
+    Canvas canvas = new Canvas(redSquare);
+    canvas.drawColor(Color.RED);
+
+    BitmapPool bitmapPool = mock(BitmapPool.class);
+    when(bitmapPool.get(100, 100, Bitmap.Config.ARGB_8888))
+        .thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    Bitmap expected = TransformationUtils.circleCrop(bitmapPool, redSquare, 100, 100);
+
+    assertThat(result).isInstanceOf(BitmapDrawable.class);
+    Bitmap bitmap = ((BitmapDrawable) result).getBitmap();
+    assertThat(bitmap.getWidth()).isEqualTo(100);
+    assertThat(bitmap.getHeight()).isEqualTo(100);
+    for (int x = 0; x < bitmap.getWidth(); x++) {
+      for (int y = 0; y < bitmap.getHeight(); y++) {
+        assertThat(bitmap.getPixel(x, y)).isEqualTo(expected.getPixel(x, y));
+      }
+    }
+  }
+
+  @Test
+  public void load_withColorDrawable_sizeOriginal_requiredTransform_fails()
+      throws ExecutionException, InterruptedException {
+    Drawable colorDrawable = new ColorDrawable(Color.RED);
+
+    expectedException.expect(ExecutionException.class);
+    Glide.with(context)
+        .load(colorDrawable)
+        .apply(new RequestOptions()
+            .centerCrop())
+        .submit()
+        .get();
+  }
+
+  @Test
+  public void load_withBitmapDrawable_andDoNothingTransformation_doesNotRecycleBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Bitmap.createBitmap(100, 200, Config.ARGB_8888);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+
+    Drawable result = GlideApp.with(context)
+        .load(drawable)
+        .fitCenter()
+        .override(bitmap.getWidth(), bitmap.getHeight())
+        .submit()
+        .get();
+
+    BitmapSubject.assertThat(result).isNotRecycled();
+  }
+
+  @Test
+  public void load_withBitmapDrawable_andFunctionalTransformation_doesNotRecycleBitmap()
+      throws ExecutionException, InterruptedException {
+      Bitmap bitmap = Bitmap.createBitmap(100, 200, Config.ARGB_8888);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+
+    Drawable result = GlideApp.with(context)
+        .load(drawable)
+        .fitCenter()
+        .override(bitmap.getWidth() / 2, bitmap.getHeight() / 2)
+        .submit()
+        .get();
+
+    BitmapSubject.assertThat(result).isNotRecycled();
+  }
+
+  @Test
+  public void load_withColorDrawable_fixedSize_unitBitmapTransform_recyclesIntermediates()
+      throws ExecutionException, InterruptedException {
+    Drawable colorDrawable = new ColorDrawable(Color.RED);
+
+    int width = 100;
+    int height = 200;
+
+    GlideApp.with(context)
+        .load(colorDrawable)
+        .fitCenter()
+        .override(width, height)
+        .submit()
+        .get();
+
+    BitmapPool bitmapPool = Glide.get(context).getBitmapPool();
+    // Make sure we didn't put the same Bitmap twice.
+    Bitmap first = bitmapPool.get(width, height, Config.ARGB_8888);
+    Bitmap second = bitmapPool.get(width, height, Config.ARGB_8888);
+
+    assertThat(first).isNotSameAs(second);
+  }
+   @Test
+  public void load_withColorDrawable_fixedSize_functionalBitmapTransform_doesNotRecycleOutput()
+      throws ExecutionException, InterruptedException {
+    Drawable colorDrawable = new ColorDrawable(Color.RED);
+
+    int width = 100;
+    int height = 200;
+
+    Drawable result = GlideApp.with(context)
+        .load(colorDrawable)
+        .circleCrop()
+        .override(width, height)
+        .submit()
+        .get();
+
+     BitmapSubject.assertThat(result).isNotRecycled();
+
+    BitmapPool bitmapPool = Glide.get(context).getBitmapPool();
+    // Make sure we didn't put the same Bitmap twice.
+    Bitmap first = bitmapPool.get(width, height, Config.ARGB_8888);
+    Bitmap second = bitmapPool.get(width, height, Config.ARGB_8888);
+
+    assertThat(first).isNotSameAs(second);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/ErrorHandlingTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/ErrorHandlingTest.java
new file mode 100644
index 000000000..2e4898227
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/ErrorHandlingTest.java
@@ -0,0 +1,164 @@
+package com.bumptech.glide;
+
+import static com.bumptech.glide.test.Matchers.anyDrawable;
+import static com.bumptech.glide.test.Matchers.anyDrawableTarget;
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.anyBoolean;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.EncodeStrategy;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceEncoder;
+import com.bumptech.glide.load.engine.GlideException;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy;
+import com.bumptech.glide.request.FutureTarget;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import com.bumptech.glide.test.WaitModelLoader;
+import com.bumptech.glide.test.WaitModelLoader.WaitModel;
+import java.io.File;
+import java.util.concurrent.CountDownLatch;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(AndroidJUnit4.class)
+public class ErrorHandlingTest {
+
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+  @Mock private RequestListener<Drawable> requestListener;
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+
+  private Context context;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    context = InstrumentationRegistry.getTargetContext();
+  }
+
+  // ResourceEncoders are expected not to throw and to return true or false. If they do throw, it's
+  // a developer error, so we expect UncaughtThrowableStrategy to be called.
+  @Test
+  public void load_whenEncoderFails_callsUncaughtThrowableStrategy() {
+    WaitForErrorStrategy strategy = new WaitForErrorStrategy();
+    Glide.init(context,
+        new GlideBuilder()
+            .setAnimationExecutor(GlideExecutor.newAnimationExecutor(/*threadCount=*/ 1, strategy))
+            .setSourceExecutor(GlideExecutor.newSourceExecutor(strategy))
+            .setDiskCacheExecutor(GlideExecutor.newDiskCacheExecutor(strategy)));
+    Glide.get(context).getRegistry().prepend(Bitmap.class, new FailEncoder());
+
+    concurrency.get(
+        Glide.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+            .submit());
+
+    // Writing to the disk cache and therefore the exception caused by our FailEncoder may happen
+    // after the request completes, so we should wait for the expected error explicitly.
+    ConcurrencyHelper.waitOnLatch(strategy.latch);
+    assertThat(strategy.error).isEqualTo(FailEncoder.TO_THROW);
+
+    verify(requestListener, never())
+        .onLoadFailed(any(GlideException.class), any(), anyDrawableTarget(), anyBoolean());
+  }
+
+  @Test
+  public void load_whenLoadSucceeds_butEncoderFails_doesNotCallOnLoadFailed() {
+    WaitForErrorStrategy strategy = new WaitForErrorStrategy();
+    Glide.init(context,
+        new GlideBuilder()
+            .setAnimationExecutor(GlideExecutor.newAnimationExecutor(/*threadCount=*/ 1, strategy))
+            .setSourceExecutor(GlideExecutor.newSourceExecutor(strategy))
+            .setDiskCacheExecutor(GlideExecutor.newDiskCacheExecutor(strategy)));
+    Glide.get(context).getRegistry().prepend(Bitmap.class, new FailEncoder());
+
+    concurrency.get(
+        Glide.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            any(DataSource.class),
+            anyBoolean());
+    verify(requestListener, never())
+        .onLoadFailed(any(GlideException.class), any(), anyDrawableTarget(), anyBoolean());
+  }
+
+  @Test
+  public void clearRequest_withError_afterPrimaryFails_clearsErrorRequest() {
+    WaitModel<Integer> errorModel = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);
+
+    FutureTarget<Drawable> target =
+        Glide.with(context)
+            .load((Object) null)
+            .error(
+                Glide.with(context)
+                    .load(errorModel)
+                    .listener(requestListener))
+            .submit();
+
+    Glide.with(context).clear(target);
+    errorModel.countDown();
+
+    // Make sure any pending requests run.
+    concurrency.pokeMainThread();
+    Glide.tearDown();
+    // Make sure that any callbacks posted back to the main thread run.
+    concurrency.pokeMainThread();
+  }
+
+  private static final class WaitForErrorStrategy implements UncaughtThrowableStrategy {
+    final CountDownLatch latch = new CountDownLatch(1);
+    @Nullable Throwable error = null;
+
+    @Override
+    public void handle(Throwable t) {
+      if (error != null) {
+        throw new IllegalArgumentException("Received second error", t);
+      }
+      error = t;
+      latch.countDown();
+    }
+  }
+
+  private static final class FailEncoder implements ResourceEncoder<Bitmap> {
+
+    static final RuntimeException TO_THROW = new RuntimeException();
+
+    @NonNull
+    @Override
+    public EncodeStrategy getEncodeStrategy(@NonNull Options options) {
+      return EncodeStrategy.TRANSFORMED;
+    }
+
+    @Override
+    public boolean encode(
+        @NonNull Resource<Bitmap> data, @NonNull File file, @NonNull Options options) {
+      throw TO_THROW;
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/ExternallyClearedDiskCacheTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/ExternallyClearedDiskCacheTest.java
new file mode 100644
index 000000000..bdda5fed0
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/ExternallyClearedDiskCacheTest.java
@@ -0,0 +1,125 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.mock;
+
+import android.content.Context;
+import android.graphics.drawable.Drawable;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.engine.cache.DiskCache;
+import com.bumptech.glide.load.engine.cache.DiskCache.Factory;
+import com.bumptech.glide.load.engine.cache.DiskLruCacheWrapper;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.ResourceIds.raw;
+import com.bumptech.glide.test.TearDownGlide;
+import java.io.File;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+// Tests #2465.
+@RunWith(AndroidJUnit4.class)
+public class ExternallyClearedDiskCacheTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private Context context;
+  private File cacheDir;
+
+  @Before
+  public void setUp() {
+    context = InstrumentationRegistry.getTargetContext();
+    cacheDir = context.getCacheDir();
+  }
+
+  @After
+  public void tearDown() {
+    // Force us to wait until Glide's threads shut down.
+    Glide.tearDown();
+    deleteRecursively(cacheDir);
+  }
+
+  @Test
+  public void clearDiskCache_afterOpeningDiskCache_andDeleteDirectoryOutsideGlide_doesNotThrow() {
+    DiskCache cache = DiskLruCacheWrapper.create(cacheDir, 1024 * 1024);
+    cache.get(mock(Key.class));
+    deleteRecursively(cacheDir);
+    cache.clear();
+  }
+
+  @Test
+  public void get_afterDeleteDirectoryOutsideGlideAndClose_doesNotThrow() {
+    DiskCache cache = DiskLruCacheWrapper.create(cacheDir, 1024 * 1024);
+    cache.get(mock(Key.class));
+    deleteRecursively(cacheDir);
+    cache.clear();
+
+    cache.get(mock(Key.class));
+  }
+
+  @Test
+  public void loadFromCache_afterDiskCacheDeletedAndCleared_doesNotFail() {
+    final DiskCache cache = DiskLruCacheWrapper.create(cacheDir, 1024 * 1024);
+    cache.get(mock(Key.class));
+    deleteRecursively(cacheDir);
+    cache.clear();
+
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setDiskCache(new Factory() {
+              @Override
+              public DiskCache build() {
+                return cache;
+              }
+            }));
+
+    Drawable drawable =
+        concurrency.get(
+            Glide.with(context)
+                .load(ResourceIds.raw.canonical)
+                .submit());
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void loadFromCache_afterDiskCacheDeleted_doesNotFail() {
+    final DiskCache cache = DiskLruCacheWrapper.create(cacheDir, 1024 * 1024);
+    cache.get(mock(Key.class));
+    deleteRecursively(cacheDir);
+
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setDiskCache(new Factory() {
+              @Override
+              public DiskCache build() {
+                return cache;
+              }
+            }));
+
+    Drawable drawable =
+        concurrency.get(Glide.with(context)
+            .load(raw.canonical)
+            .submit());
+    assertThat(drawable).isNotNull();
+  }
+
+  private static void deleteRecursively(File file) {
+    if (file.isDirectory()) {
+      File[] files = file.listFiles();
+      if (files != null) {
+        for (File f : files) {
+          deleteRecursively(f);
+        }
+      }
+    }
+    if (!file.delete() && file.exists()) {
+      throw new RuntimeException("Failed to delete: " + file);
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/FitCenterRegressionTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/FitCenterRegressionTest.java
new file mode 100644
index 000000000..b78a20779
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/FitCenterRegressionTest.java
@@ -0,0 +1,123 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.test.BitmapRegressionTester;
+import com.bumptech.glide.test.CanonicalBitmap;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.RegressionTest;
+import com.bumptech.glide.test.SplitByCpu;
+import com.bumptech.glide.test.SplitBySdk;
+import com.bumptech.glide.test.TearDownGlide;
+import java.util.concurrent.ExecutionException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.rules.TestName;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+@SplitByCpu
+@SplitBySdk({24, 23, 21, 19, 18, 16})
+@RegressionTest
+public class FitCenterRegressionTest {
+  @Rule public final TestName testName = new TestName();
+  @Rule public final ExpectedException expectedException = ExpectedException.none();
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private BitmapRegressionTester bitmapRegressionTester;
+  private Context context;
+  private CanonicalBitmap canonical;
+
+  @Before
+  public void setUp() {
+    context = InstrumentationRegistry.getTargetContext();
+    bitmapRegressionTester = new BitmapRegressionTester(getClass(), testName);
+    canonical = new CanonicalBitmap();
+  }
+
+  @Test
+  public void fitCenter_withSquareSmallerThanImage_returnsImageFitWithinSquare()
+      throws ExecutionException, InterruptedException {
+
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .fitCenter()
+                .override(50));
+
+    assertThat(result.getWidth()).isEqualTo(50);
+    assertThat(result.getHeight()).isEqualTo(37);
+  }
+
+  @Test
+  public void fitCenter_withSquareLargerThanImage_returnsUpscaledSquare()
+      throws ExecutionException, InterruptedException {
+    float multiplier = 1.1f;
+    int multipliedWidth = (int) (canonical.getWidth() * multiplier);
+    int multipliedHeight = (int) (canonical.getHeight() * multiplier);
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+              .asBitmap()
+              .load(canonical.getBitmap())
+              .fitCenter()
+              .override(multipliedWidth));
+
+    assertThat(result.getWidth()).isEqualTo(multipliedWidth);
+    assertThat(result.getHeight()).isEqualTo(multipliedHeight);
+  }
+
+  @Test
+  public void fitCenter_withNarrowRectangle_fitsWithinMaintainingAspectRatio()
+      throws ExecutionException, InterruptedException {
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+              .asBitmap()
+              .load(canonical.getBitmap())
+              .fitCenter()
+              .override(canonical.getWidth() / 10, canonical.getHeight()));
+
+    assertThat(result.getWidth()).isEqualTo(canonical.getWidth() / 10);
+    assertThat(result.getHeight()).isEqualTo(canonical.getHeight() / 10);
+  }
+
+  @Test
+  public void fitCenter_withShortRectangle_fitsWithinMaintainingAspectRatio()
+      throws ExecutionException, InterruptedException {
+     Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+              .asBitmap()
+              .load(canonical.getBitmap())
+              .fitCenter()
+              .override(canonical.getWidth(), canonical.getHeight() / 2));
+
+    assertThat(result.getWidth()).isEqualTo(canonical.getWidth() / 2);
+    assertThat(result.getHeight()).isEqualTo(canonical.getHeight() / 2);
+  }
+
+  @Test
+  public void fitCenter_withHugeRectangle_throwsOOM()
+      throws ExecutionException, InterruptedException {
+    float multiplier = Integer.MAX_VALUE / (canonical.getWidth() * canonical.getHeight() * 2);
+    int overrideWidth = (int) multiplier * canonical.getWidth();
+    int overrideHeight = (int) multiplier * canonical.getHeight();
+    expectedException.expect(ExecutionException.class);
+    GlideApp
+        .with(context)
+        .asBitmap()
+        .load(canonical.getBitmap())
+        .fitCenter()
+        .override(overrideWidth, overrideHeight)
+        .submit()
+        .get();
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBitmapTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBitmapTest.java
new file mode 100644
index 000000000..4e9ff73da
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBitmapTest.java
@@ -0,0 +1,363 @@
+package com.bumptech.glide;
+
+
+import static com.bumptech.glide.test.Matchers.anyBitmap;
+import static com.bumptech.glide.test.Matchers.anyBitmapTarget;
+import static com.bumptech.glide.test.Matchers.anyDrawable;
+import static com.bumptech.glide.test.Matchers.anyDrawableTarget;
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.anyBoolean;
+import static org.mockito.Mockito.eq;
+import static org.mockito.Mockito.verify;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.drawable.Drawable;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruBitmapPool;
+import com.bumptech.glide.load.engine.cache.LruResourceCache;
+import com.bumptech.glide.load.engine.cache.MemoryCacheAdapter;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import com.bumptech.glide.util.Util;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(AndroidJUnit4.class)
+public class LoadBitmapTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  @Mock private RequestListener<Bitmap> bitmapListener;
+  @Mock private RequestListener<Drawable> drawableListener;
+
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private Context context;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    context = InstrumentationRegistry.getTargetContext();
+  }
+
+  @Test
+  public void clearFromRequestBuilder_asDrawable_withLoadedBitmap_doesNotRecycleBitmap() {
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new MemoryCacheAdapter())
+        .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    Target<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .asDrawable()
+                .load(bitmap)
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    // Allow Glide's resource recycler to run on the main thread.
+    concurrency.pokeMainThread();
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void transformFromRequestBuilder_asDrawable_withLoadedBitmap_doesNotRecycleBitmap() {
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new MemoryCacheAdapter())
+        .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(bitmap)
+            .centerCrop()
+            .submit(100, 100));
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void clearFromRequestManager_withLoadedBitmap_doesNotRecycleBitmap() {
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new MemoryCacheAdapter())
+        .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    Target<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .load(bitmap)
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    // Allow Glide's resource recycler to run on the main thread.
+    concurrency.pokeMainThread();
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void transformFromRequestManager_withLoadedBitmap_doesNotRecycleBitmap() {
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new MemoryCacheAdapter())
+        .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(bitmap)
+            .centerCrop()
+            .submit(100, 100));
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void clearFromRequestBuilder_withLoadedBitmap_asBitmap_doesNotRecycleBitmap() {
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new MemoryCacheAdapter())
+        .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    Target<Bitmap> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(bitmap)
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    // Allow Glide's resource recycler to run on the main thread.
+    concurrency.pokeMainThread();
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void transformFromRequestBuilder_withLoadedBitmap_asBitmap_doesNotRecycleBitmap() {
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new MemoryCacheAdapter())
+        .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    concurrency.wait(
+        GlideApp.with(context)
+            .asBitmap()
+            .load(bitmap)
+            .centerCrop()
+            .submit(100, 100));
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void loadFromRequestManager_withBitmap_doesNotLoadFromDiskCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Target<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .load(bitmap)
+                .centerCrop()
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(bitmap)
+            .centerCrop()
+            .listener(drawableListener)
+            .submit(100, 100));
+
+    verify(drawableListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.LOCAL),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_asDrawable_withBitmap_doesNotLoadFromDiskCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Target<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .asDrawable()
+                .load(bitmap)
+                .centerCrop()
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(bitmap)
+            .centerCrop()
+            .listener(drawableListener)
+            .submit(100, 100));
+
+    verify(drawableListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.LOCAL),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_asDrawable_withBitmapAndStrategyBeforeLoad_notFromCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Target<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .asDrawable()
+                .diskCacheStrategy(DiskCacheStrategy.ALL)
+                .load(bitmap)
+                .centerCrop()
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(bitmap)
+            .centerCrop()
+            .listener(drawableListener)
+            .submit(100, 100));
+
+    verify(drawableListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.LOCAL),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_asBitmap_withBitmap_doesNotLoadFromDiskCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Target<Bitmap> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(bitmap)
+                .centerCrop()
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asBitmap()
+            .load(bitmap)
+            .centerCrop()
+            .listener(bitmapListener)
+            .submit(100, 100));
+
+    verify(bitmapListener)
+        .onResourceReady(
+            anyBitmap(),
+            any(),
+            anyBitmapTarget(),
+            eq(DataSource.LOCAL),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_asBitmap_withBitmapAndStrategyBeforeLoad_notFromCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Target<Bitmap> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .asBitmap()
+                .diskCacheStrategy(DiskCacheStrategy.ALL)
+                .load(bitmap)
+                .centerCrop()
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asBitmap()
+            .load(bitmap)
+            .centerCrop()
+            .listener(bitmapListener)
+            .submit(100, 100));
+
+    verify(bitmapListener)
+        .onResourceReady(
+            anyBitmap(),
+            any(),
+            anyBitmapTarget(),
+            eq(DataSource.LOCAL),
+            anyBoolean());
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBytesTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBytesTest.java
new file mode 100644
index 000000000..b6abc374d
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBytesTest.java
@@ -0,0 +1,525 @@
+package com.bumptech.glide;
+
+import static com.bumptech.glide.test.GlideOptions.skipMemoryCacheOf;
+import static com.bumptech.glide.test.Matchers.anyDrawable;
+import static com.bumptech.glide.test.Matchers.anyDrawableTarget;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.anyBoolean;
+import static org.mockito.Mockito.eq;
+import static org.mockito.Mockito.verify;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.CompressFormat;
+import android.graphics.Bitmap.Config;
+import android.graphics.BitmapFactory;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import android.widget.AbsListView.LayoutParams;
+import android.widget.ImageView;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.load.engine.executor.MockGlideExecutor;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.test.BitmapSubject;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import com.google.common.io.ByteStreams;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(AndroidJUnit4.class)
+public class LoadBytesTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+
+  @Mock private RequestListener<Drawable> requestListener;
+
+  private Context context;
+  private ImageView imageView;
+
+  @Before
+  public void setUp() throws IOException {
+    MockitoAnnotations.initMocks(this);
+    context = InstrumentationRegistry.getTargetContext();
+
+    imageView = new ImageView(context);
+    int[] dimensions = getCanonicalDimensions();
+    imageView.setLayoutParams(new LayoutParams(/*w=*/ dimensions[0], /*h=*/ dimensions[1]));
+
+    // Writes to the resource disk cache run in a non-blocking manner after the Target is notified.
+    // Unless we enforce a single threaded executor, the encode task races with our second decode
+    // task, causing the test to sometimes fail (when the second resource is started after the
+    // encode and loaded from the disk cache) and sometimes succeed (when the second resource is
+    // started before the encode and loads from source).
+    ExecutorService executor = Executors.newSingleThreadExecutor();
+    GlideExecutor glideExecutor = MockGlideExecutor.newTestExecutor(executor);
+    Glide.init(context, new GlideBuilder()
+        .setAnimationExecutor(glideExecutor)
+        .setDiskCacheExecutor(glideExecutor)
+        .setSourceExecutor(glideExecutor));
+  }
+
+  @Test
+  public void loadFromRequestManager_intoImageView_withDifferentByteArrays_loadsDifferentImages()
+      throws IOException, ExecutionException, InterruptedException {
+    final byte[] canonicalBytes = getCanonicalBytes();
+    final byte[] modifiedBytes = getModifiedBytes();
+
+    concurrency.loadOnMainThread(
+        Glide.with(context).load(canonicalBytes), imageView);
+    Bitmap firstBitmap = copyFromImageViewDrawable(imageView);
+
+    concurrency.loadOnMainThread(
+        Glide.with(context).load(modifiedBytes), imageView);
+    Bitmap secondBitmap = copyFromImageViewDrawable(imageView);
+
+    // This assertion alone doesn't catch the case where the second Bitmap is loaded from the result
+    // cache of the data from the first Bitmap.
+    BitmapSubject.assertThat(firstBitmap).isNotSameAs(secondBitmap);
+
+    Bitmap expectedCanonicalBitmap =
+        BitmapFactory.decodeByteArray(canonicalBytes, /*offset=*/ 0, canonicalBytes.length);
+    BitmapSubject.assertThat(firstBitmap).sameAs(expectedCanonicalBitmap);
+
+    Bitmap expectedModifiedBitmap =
+        BitmapFactory.decodeByteArray(modifiedBytes, /*offset=*/ 0, modifiedBytes.length);
+    BitmapSubject.assertThat(secondBitmap).sameAs(expectedModifiedBitmap);
+  }
+
+  @Test
+  public void loadFromRequestBuilder_intoImageView_withDifferentByteArrays_loadsDifferentImages()
+      throws IOException, ExecutionException, InterruptedException {
+    final byte[] canonicalBytes = getCanonicalBytes();
+    final byte[] modifiedBytes = getModifiedBytes();
+
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(canonicalBytes),
+        imageView);
+    Bitmap firstBitmap = copyFromImageViewDrawable(imageView);
+
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(modifiedBytes),
+        imageView);
+    Bitmap secondBitmap = copyFromImageViewDrawable(imageView);
+
+    // This assertion alone doesn't catch the case where the second Bitmap is loaded from the result
+    // cache of the data from the first Bitmap.
+    BitmapSubject.assertThat(firstBitmap).isNotSameAs(secondBitmap);
+
+    Bitmap expectedCanonicalBitmap =
+        BitmapFactory.decodeByteArray(canonicalBytes, /*offset=*/ 0, canonicalBytes.length);
+    BitmapSubject.assertThat(firstBitmap).sameAs(expectedCanonicalBitmap);
+
+    Bitmap expectedModifiedBitmap =
+        BitmapFactory.decodeByteArray(modifiedBytes, /*offset=*/ 0, modifiedBytes.length);
+    BitmapSubject.assertThat(secondBitmap).sameAs(expectedModifiedBitmap);
+  }
+
+  @Test
+  public void requestManager_intoImageView_withSameByteArrayAndMemoryCacheEnabled_loadsFromMemory()
+      throws IOException {
+    final byte[] canonicalBytes = getCanonicalBytes();
+    concurrency.loadOnMainThread(
+        Glide.with(context)
+            .load(canonicalBytes)
+            .apply(skipMemoryCacheOf(false)),
+        imageView);
+
+    Glide.with(context).clear(imageView);
+
+    concurrency.loadOnMainThread(
+        Glide.with(context)
+            .load(canonicalBytes)
+            .listener(requestListener)
+            .apply(skipMemoryCacheOf(false)),
+        imageView);
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
+  }
+
+  @Test
+  public void requestBuilder_intoImageView_withSameByteArrayAndMemoryCacheEnabled_loadsFromMemory()
+      throws IOException {
+    final byte[] canonicalBytes = getCanonicalBytes();
+    concurrency.loadOnMainThread(
+        Glide.with(context)
+            .asDrawable()
+            .load(canonicalBytes)
+            .apply(skipMemoryCacheOf(false)),
+        imageView);
+
+    Glide.with(context).clear(imageView);
+
+    concurrency.loadOnMainThread(
+        Glide.with(context)
+            .asDrawable()
+            .load(canonicalBytes)
+            .listener(requestListener)
+            .apply(skipMemoryCacheOf(false)),
+        imageView);
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestManager_withSameByteArray_validDiskCacheStrategy_returnsFromDiskCache()
+      throws IOException {
+    byte[] data = getCanonicalBytes();
+    Target<Drawable> target = concurrency.wait(
+        GlideApp.with(context)
+            .load(data)
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(data)
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.RESOURCE_DISK_CACHE),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_withSameByteArray_validDiskCacheStrategy_returnsFromDiskCache()
+      throws IOException {
+    byte[] data = getCanonicalBytes();
+    Target<Drawable> target = concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(data)
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(data)
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.RESOURCE_DISK_CACHE),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestManager_withSameByteArray_memoryCacheEnabled_returnsFromCache()
+      throws IOException {
+    byte[] data = getCanonicalBytes();
+    Target<Drawable> target = concurrency.wait(
+        GlideApp.with(context)
+            .load(data)
+            .skipMemoryCache(false)
+            .submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(data)
+            .skipMemoryCache(false)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_withSameByteArray_memoryCacheEnabled_returnsFromCache()
+      throws IOException {
+    byte[] data = getCanonicalBytes();
+    Target<Drawable> target = concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(data)
+            .skipMemoryCache(false)
+            .submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(data)
+            .skipMemoryCache(false)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestManager_withSameByteArray_returnsFromLocal() throws IOException {
+    byte[] data = getCanonicalBytes();
+    Target<Drawable> target = concurrency.wait(
+        GlideApp.with(context)
+            .load(data)
+            .submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(data)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_withSameByteArray_returnsFromLocal() throws IOException {
+    byte[] data = getCanonicalBytes();
+    Target<Drawable> target = concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(data)
+            .submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(data)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestManager_withSameByteArrayAndMissingFromMemory_returnsFromLocal()
+       throws IOException {
+    byte[] data = getCanonicalBytes();
+    Target<Drawable> target = concurrency.wait(
+        GlideApp.with(context)
+            .load(data)
+            .submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(data)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_withSameByteArrayAndMissingFromMemory_returnsFromLocal()
+       throws IOException {
+    byte[] data = getCanonicalBytes();
+    Target<Drawable> target = concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(data)
+            .submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(data)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
+  }
+
+  @Test
+  public void loadFromBuilder_withDiskCacheStrategySetBeforeLoad_doesNotOverrideDiskCacheStrategy()
+      throws IOException {
+    byte[] data = getCanonicalBytes();
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .load(data)
+            .submit());
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .listener(requestListener)
+            .load(data)
+            .submit());
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.RESOURCE_DISK_CACHE),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromBuilder_withSkipMemoryCacheSetBeforeLoad_doesNotOverrideSkipMemoryCache()
+      throws IOException {
+    byte[] data = getCanonicalBytes();
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .skipMemoryCache(false)
+            .load(data)
+            .submit());
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .skipMemoryCache(false)
+            .listener(requestListener)
+            .load(data)
+            .submit());
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
+  }
+
+  @Test
+  public void loadFromBuilder_withDataDiskCacheStrategy_returnsFromSource() throws IOException {
+    byte[] data = getCanonicalBytes();
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .diskCacheStrategy(DiskCacheStrategy.DATA)
+            .load(data)
+            .submit());
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .diskCacheStrategy(DiskCacheStrategy.DATA)
+            .skipMemoryCache(true)
+            .load(data)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(),
+        any(),
+        anyDrawableTarget(),
+        eq(DataSource.DATA_DISK_CACHE),
+        anyBoolean());
+  }
+
+  private Bitmap copyFromImageViewDrawable(ImageView imageView) {
+    if (imageView.getDrawable() == null) {
+      fail("Drawable unexpectedly null");
+    }
+
+    // Glide mutates Bitmaps, so it's possible that a Bitmap loaded into a View in one place may
+    // be re-used to load a different image later. Create a defensive copy just in case.
+    return Bitmap.createBitmap(((BitmapDrawable) imageView.getDrawable()).getBitmap());
+  }
+
+  private int[] getCanonicalDimensions() throws IOException {
+    byte[] canonicalBytes = getCanonicalBytes();
+    Bitmap bitmap =
+        BitmapFactory.decodeByteArray(canonicalBytes, /*offset=*/ 0, canonicalBytes.length);
+    return new int[] { bitmap.getWidth(), bitmap.getHeight() };
+  }
+
+  private byte[] getModifiedBytes() throws IOException {
+    int[] dimensions = getCanonicalDimensions();
+    Bitmap bitmap = Bitmap.createBitmap(dimensions[0], dimensions[1], Config.ARGB_8888);
+    ByteArrayOutputStream os = new ByteArrayOutputStream();
+    bitmap.compress(CompressFormat.PNG, /*quality=*/ 100, os);
+    return os.toByteArray();
+  }
+
+  private byte[] getCanonicalBytes() throws IOException {
+    int resourceId = ResourceIds.raw.canonical;
+    Resources resources = context.getResources();
+    InputStream is = resources.openRawResource(resourceId);
+    return ByteStreams.toByteArray(is);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadDrawableTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadDrawableTest.java
new file mode 100644
index 000000000..de411130c
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadDrawableTest.java
@@ -0,0 +1,212 @@
+package com.bumptech.glide;
+
+import static com.bumptech.glide.test.Matchers.anyDrawable;
+import static com.bumptech.glide.test.Matchers.anyDrawableTarget;
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.anyBoolean;
+import static org.mockito.Mockito.eq;
+import static org.mockito.Mockito.verify;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruBitmapPool;
+import com.bumptech.glide.load.engine.cache.LruResourceCache;
+import com.bumptech.glide.load.engine.cache.MemoryCacheAdapter;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import com.bumptech.glide.util.Util;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(AndroidJUnit4.class)
+public class LoadDrawableTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+
+  @Mock private RequestListener<Drawable> listener;
+
+  private Context context;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
+    context = InstrumentationRegistry.getTargetContext();
+  }
+
+  @Test
+  public void clear_withLoadedBitmapDrawable_doesNotRecycleBitmap() {
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new MemoryCacheAdapter())
+        .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+    Target<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .load(drawable)
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    // Allow Glide's resource recycler to run on the main thread.
+    concurrency.pokeMainThread();
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void transform_withLoadedBitmapDrawable_doesNotRecycleBitmap() {
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new MemoryCacheAdapter())
+        .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(drawable)
+            .centerCrop()
+            .submit(100, 100));
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void loadFromRequestManager_withBitmap_doesNotLoadFromDiskCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Target<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .load(drawable)
+                .centerCrop()
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(drawable)
+            .centerCrop()
+            .listener(listener)
+            .submit(100, 100));
+
+    verify(listener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.LOCAL),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_asDrawable_withBitmap_doesNotLoadFromDiskCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Target<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .asDrawable()
+                .load(drawable)
+                .centerCrop()
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(drawable)
+            .centerCrop()
+            .listener(listener)
+            .submit(100, 100));
+
+    verify(listener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.LOCAL),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_asDrawable_withBitmapAndStrategyBeforeLoad_notFromCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Target<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .asDrawable()
+                .diskCacheStrategy(DiskCacheStrategy.ALL)
+                .load(drawable)
+                .centerCrop()
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(drawable)
+            .centerCrop()
+            .listener(listener)
+            .submit(100, 100));
+
+    verify(listener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.LOCAL),
+            anyBoolean());
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadResourcesWithDownsamplerTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadResourcesWithDownsamplerTest.java
new file mode 100644
index 000000000..b2299e54a
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadResourcesWithDownsamplerTest.java
@@ -0,0 +1,349 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assume.assumeTrue;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.ColorSpace;
+import android.net.Uri;
+import android.os.Build;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.NonNull;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.model.ModelLoader;
+import com.bumptech.glide.load.model.ModelLoaderFactory;
+import com.bumptech.glide.load.model.MultiModelLoaderFactory;
+import com.bumptech.glide.signature.ObjectKey;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import java.io.ByteArrayOutputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Locale;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/**
+ * On API 26, decoding a variety of different images can cause {@link BitmapFactory} with
+ * {@link BitmapFactory.Options#inJustDecodeBounds} set to {@code true} to set
+ * {@link BitmapFactory.Options#outConfig} to null instead of a valid value, even though the image
+ * can be decoded successfully. Glide can mask these failures by decoding some image sources
+ * (notably including resource ids) using other data types and decoders.
+ *
+ * <p>This test ensures that we've worked around the framework issue by loading a variety of images
+ * and image types without the normal fallback behavior.
+ */
+@RunWith(AndroidJUnit4.class)
+public class LoadResourcesWithDownsamplerTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private final Context context = InstrumentationRegistry.getTargetContext();
+
+  @Test
+  public void loadJpegResource_withNoOtherLoaders_decodesResource() {
+    Glide.get(context).getRegistry()
+        .prepend(
+            Object.class,
+            InputStream.class,
+            new FakeModelLoader<>(ResourceIds.raw.canonical));
+
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(new Object())
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void loadWideGamutJpegResource_withNoOtherLoaders_decodesWideGamutBitmap() {
+    assumeTrue(
+        "Wide gamut is only available on O+", Build.VERSION.SDK_INT >= Build.VERSION_CODES.O);
+    Glide.get(context).getRegistry()
+        .prepend(
+            Object.class,
+            InputStream.class,
+            new FakeModelLoader<>(ResourceIds.raw.webkit_logo_p3));
+
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(new Object())
+                .submit());
+    assertThat(bitmap).isNotNull();
+    assertThat(bitmap.getConfig()).isEqualTo(Bitmap.Config.RGBA_F16);
+    assertThat(bitmap.getColorSpace())
+        .isEqualTo(ColorSpace.get(ColorSpace.Named.LINEAR_EXTENDED_SRGB));
+  }
+
+  @Test
+  public void loadOpaquePngResource_withNoOtherLoaders_decodesResource() {
+    Glide.get(context).getRegistry()
+        .prepend(
+            Object.class,
+            InputStream.class,
+            new FakeModelLoader<>(ResourceIds.raw.canonical_png));
+
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(new Object())
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void loadTransparentPngResource_withNoOtherLoaders_decodesResource() {
+    Glide.get(context).getRegistry()
+        .prepend(
+            Object.class,
+            InputStream.class,
+            new FakeModelLoader<>(ResourceIds.raw.canonical_transparent_png));
+
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(new Object())
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void loadTransparentGifResource_withNoOtherLoaders_decodesResource() {
+    Glide.get(context).getRegistry()
+        .prepend(
+            Object.class,
+            InputStream.class,
+            new FakeModelLoader<>(ResourceIds.raw.transparent_gif));
+
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(new Object())
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void loadTransparentGifResource_asHardware_withNoOtherLoaders_decodesResource() {
+    assumeTrue(
+        "Hardware Bitmaps are only supported on O+",
+        Build.VERSION.SDK_INT >= Build.VERSION_CODES.O);
+
+    Glide.get(context).getRegistry()
+        .prepend(
+            Object.class,
+            InputStream.class,
+            new FakeModelLoader<>(ResourceIds.raw.transparent_gif));
+
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                // Allow HARDWARE Bitmaps.
+                .format(DecodeFormat.PREFER_ARGB_8888)
+                .load(new Object())
+                .submit());
+    assertThat(bitmap).isNotNull();
+    assertThat(bitmap.getConfig()).isEqualTo(Bitmap.Config.HARDWARE);
+  }
+
+  @Test
+  public void loadTransparentGifResource_withNoOtherLoaders_fromBytes_decodesResource() {
+    byte[] data = getBytes(ResourceIds.raw.transparent_gif);
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(data)
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void loadOpaqueGifResource_withNoOtherLoaders_decodesResource() {
+    Glide.get(context).getRegistry()
+        .prepend(
+            Object.class,
+            InputStream.class,
+            new FakeModelLoader<>(ResourceIds.raw.opaque_gif));
+
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(new Object())
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void loadOpaqueGifResource_asBytes_decodesResource() {
+    byte[] data = getBytes(ResourceIds.raw.opaque_gif);
+     Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(data)
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void loadOpaqueGifResource_asHardware_withNoOtherLoaders_decodesResource() {
+    assumeTrue(
+        "Hardware Bitmaps are only supported on O+",
+        Build.VERSION.SDK_INT >= Build.VERSION_CODES.O);
+
+    Glide.get(context).getRegistry()
+        .prepend(
+            Object.class,
+            InputStream.class,
+            new FakeModelLoader<>(ResourceIds.raw.opaque_gif));
+
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                // Allow HARDWARE Bitmaps.
+                .format(DecodeFormat.PREFER_ARGB_8888)
+                .load(new Object())
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+
+  private byte[] getBytes(int resourceId) {
+    ByteArrayOutputStream os = new ByteArrayOutputStream();
+    InputStream is = null;
+    try {
+      is = context.getResources().openRawResource(resourceId);
+      byte[] buffer = new byte[1024 * 1024];
+      int read;
+      while ((read = is.read(buffer)) != -1) {
+        os.write(buffer, 0, read);
+      }
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    } finally {
+      if (is != null) {
+        try {
+          is.close();
+        } catch (IOException e) {
+          // Ignored;
+        }
+      }
+    }
+
+    return os.toByteArray();
+  }
+
+  private class FakeModelLoader<T> implements
+      ModelLoader<T, InputStream>,
+      ModelLoaderFactory<T, InputStream> {
+
+    private final int resourceId;
+
+    FakeModelLoader(int resourceId) {
+      this.resourceId = resourceId;
+    }
+
+    @android.support.annotation.Nullable
+    @Override
+    public LoadData<InputStream> buildLoadData(@NonNull Object o, int width, int height,
+        @NonNull Options options) {
+      return new LoadData<>(new ObjectKey(o), new Fetcher());
+    }
+
+    @Override
+    public boolean handles(@NonNull Object o) {
+      return true;
+    }
+
+    @NonNull
+    @Override
+    public ModelLoader<T, InputStream> build(@NonNull MultiModelLoaderFactory multiFactory) {
+      return this;
+    }
+
+    @Override
+    public void teardown() { }
+
+    private final class Fetcher implements DataFetcher<InputStream> {
+      private InputStream inputStream;
+
+      @Override
+      public void loadData(@NonNull Priority priority,
+          @NonNull DataCallback<? super InputStream> callback) {
+        inputStream = getInputStreamForResource(context, resourceId);
+        callback.onDataReady(inputStream);
+      }
+
+      private InputStream getInputStreamForResource(
+          Context context, @DrawableRes int resourceId) {
+        Resources resources = context.getResources();
+        try {
+          Uri parse =
+              Uri.parse(
+                  String.format(
+                      Locale.US,
+                      "%s://%s/%s/%s",
+                      ContentResolver.SCHEME_ANDROID_RESOURCE,
+                      resources.getResourcePackageName(resourceId),
+                      resources.getResourceTypeName(resourceId),
+                      resources.getResourceEntryName(resourceId)));
+          return context.getContentResolver().openInputStream(parse);
+        } catch (Resources.NotFoundException | FileNotFoundException e) {
+          throw new IllegalArgumentException("Resource ID " + resourceId + " not found", e);
+        }
+      }
+
+      @Override
+      public void cleanup() {
+        InputStream local = inputStream;
+        if (local != null) {
+          try {
+            local.close();
+          } catch (IOException e) {
+            // Ignored.
+          }
+        }
+      }
+
+      @Override
+      public void cancel() {
+        // Do nothing.
+      }
+
+      @NonNull
+      @Override
+      public Class<InputStream> getDataClass() {
+        return InputStream.class;
+      }
+
+      @NonNull
+      @Override
+      public DataSource getDataSource() {
+        return DataSource.LOCAL;
+      }
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadVideoResourceTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadVideoResourceTest.java
new file mode 100644
index 000000000..d99570490
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadVideoResourceTest.java
@@ -0,0 +1,323 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import java.io.IOException;
+import java.util.concurrent.TimeUnit;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.MockitoAnnotations;
+
+/**
+ * Tests that Glide is able to load videos stored in resources and loaded as
+ * {@link android.content.res.AssetFileDescriptor}s.
+ */
+@RunWith(AndroidJUnit4.class)
+public class LoadVideoResourceTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+
+  private Context context;
+
+  @Before
+  public void setUp() throws IOException {
+    MockitoAnnotations.initMocks(this);
+    context = InstrumentationRegistry.getTargetContext();
+  }
+
+  @Test
+  public void loadVideoResourceId_fromInt_decodesFrame() {
+    Drawable frame =
+        concurrency.get(
+            Glide.with(context)
+                .load(ResourceIds.raw.video)
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceId_fromInt_withFrameTime_decodesFrame() {
+    Drawable frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .load(ResourceIds.raw.video)
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  // Testing boxed integer.
+  @SuppressWarnings("UnnecessaryBoxing")
+  @Test
+  public void loadVideoResourceId_fromInteger_decodesFrame() {
+    Drawable frame =
+        concurrency.get(
+            Glide.with(context)
+                .load(new Integer(ResourceIds.raw.video))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  // Testing boxed integer.
+  @SuppressWarnings("UnnecessaryBoxing")
+  @Test
+  public void loadVideoResourceId_fromInteger_withFrameTime_decodesFrame() {
+    Drawable frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .load(new Integer(ResourceIds.raw.video))
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceId_asBitmap_decodesFrame() {
+    Bitmap frame =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(ResourceIds.raw.video)
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceId_asBitmap_withFrameTime_decodesFrame() {
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(ResourceIds.raw.video)
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUri_fromId_decodesFrame() {
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(context.getPackageName())
+            .path(String.valueOf(ResourceIds.raw.video))
+            .build();
+
+    Drawable frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .load(uri)
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUri_asBitmap_fromId_decodesFrame() {
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(context.getPackageName())
+            .path(String.valueOf(ResourceIds.raw.video))
+            .build();
+
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(uri)
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUri_fromId_withFrame_decodesFrame() {
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(context.getPackageName())
+            .path(String.valueOf(ResourceIds.raw.video))
+            .build();
+
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(uri)
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUriString_fromId_decodesFrame() {
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(context.getPackageName())
+            .path(String.valueOf(ResourceIds.raw.video))
+            .build();
+
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(uri.toString())
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUriString_fromId_withFrame_decodesFrame() {
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(context.getPackageName())
+            .path(String.valueOf(ResourceIds.raw.video))
+            .build();
+
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(uri.toString())
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUri_fromName_decodesFrame() {
+    Resources resources = context.getResources();
+    int resourceId = ResourceIds.raw.video;
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(resources.getResourcePackageName(resourceId))
+            .appendPath(resources.getResourceTypeName(resourceId))
+            .appendPath(resources.getResourceEntryName(resourceId))
+            .build();
+
+    Drawable frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .load(uri)
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUri_asBitmap_fromName_decodesFrame() {
+    Resources resources = context.getResources();
+    int resourceId = ResourceIds.raw.video;
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(resources.getResourcePackageName(resourceId))
+            .appendPath(resources.getResourceTypeName(resourceId))
+            .appendPath(resources.getResourceEntryName(resourceId))
+            .build();
+
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(uri)
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUri_fromName_withFrame_decodesFrame() {
+    Resources resources = context.getResources();
+    int resourceId = ResourceIds.raw.video;
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(resources.getResourcePackageName(resourceId))
+            .appendPath(resources.getResourceTypeName(resourceId))
+            .appendPath(resources.getResourceEntryName(resourceId))
+            .build();
+
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(uri)
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUriString_fromName_decodesFrame() {
+    Resources resources = context.getResources();
+    int resourceId = ResourceIds.raw.video;
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(resources.getResourcePackageName(resourceId))
+            .appendPath(resources.getResourceTypeName(resourceId))
+            .appendPath(resources.getResourceEntryName(resourceId))
+            .build();
+
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(uri.toString())
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUriString_fromName_withFrame_decodesFrame() {
+    Resources resources = context.getResources();
+    int resourceId = ResourceIds.raw.video;
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(resources.getResourcePackageName(resourceId))
+            .appendPath(resources.getResourceTypeName(resourceId))
+            .appendPath(resources.getResourceEntryName(resourceId))
+            .build();
+
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(uri.toString())
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java
new file mode 100644
index 000000000..e41db5705
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java
@@ -0,0 +1,531 @@
+package com.bumptech.glide;
+
+import static com.bumptech.glide.request.RequestOptions.bitmapTransform;
+import static com.bumptech.glide.request.RequestOptions.centerCropTransform;
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.content.pm.ResolveInfo;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.resource.bitmap.RoundedCorners;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.ExecutionException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.rules.TestName;
+import org.junit.runner.RunWith;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(AndroidJUnit4.class)
+public class NonBitmapDrawableResourcesTest {
+  @Rule public final TestName testName = new TestName();
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  @Rule public final ExpectedException expectedException = ExpectedException.none();
+
+  private Context context;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    context = InstrumentationRegistry.getTargetContext();
+  }
+
+  @Test
+  public void load_withBitmapResourceId_asDrawable_producesNonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(android.R.drawable.star_big_off)
+        .submit()
+        .get();
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withBitmapResourceId_asDrawable_withTransformation_producesNonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(android.R.drawable.star_big_off)
+        .apply(centerCropTransform())
+        .submit()
+        .get();
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withBitmapResourceId_asBitmap_producesNonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(android.R.drawable.star_big_off)
+        .submit()
+        .get();
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withBitmapAliasResourceId_asDrawable_producesNonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.bitmap_alias)
+        .submit()
+        .get();
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withBitmapAliasResourceId_asDrawable_withTransformation_producesNonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.bitmap_alias)
+        .apply(centerCropTransform())
+        .submit()
+        .get();
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withBitmapAliasResourceId_asBitmap_producesNonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.bitmap_alias)
+        .submit()
+        .get();
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withShapeDrawableResourceId_asDrawable_producesNonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.shape_drawable)
+        .submit()
+        .get();
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withShapeDrawableResourceId_asDrawable_withTransformation_sizeOriginal_fails()
+      throws ExecutionException, InterruptedException {
+    expectedException.expect(ExecutionException.class);
+    Glide.with(context)
+        .load(ResourceIds.drawable.shape_drawable)
+        .apply(centerCropTransform())
+        .submit()
+        .get();
+  }
+
+  @Test
+  public void load_withShapeDrawableResourceId_asDrawable_withTransformation_validSize_succeeds()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.shape_drawable)
+        .apply(bitmapTransform(new RoundedCorners(10)))
+        .submit(100, 200)
+        .get();
+    assertThat(drawable).isNotNull();
+    assertThat(drawable.getIntrinsicWidth()).isEqualTo(100);
+    assertThat(drawable.getIntrinsicHeight()).isEqualTo(200);
+  }
+
+  @Test
+  public void load_withShapeDrawableResourceId_asBitmap_withSizeOriginal_fails()
+      throws ExecutionException, InterruptedException {
+    expectedException.expect(ExecutionException.class);
+    Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.shape_drawable)
+        .submit()
+        .get();
+  }
+
+  @Test
+  public void load_withShapeDrawableResourceId_asBitmap_withValidSize_returnsNonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.shape_drawable)
+        .submit(100, 200)
+        .get();
+    assertThat(bitmap).isNotNull();
+    assertThat(bitmap.getWidth()).isEqualTo(100);
+    assertThat(bitmap.getHeight()).isEqualTo(200);
+  }
+
+  @Test
+  public void load_withShapeDrawableResourceId_asBitmap_withValidSizeAndTransform_nonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.shape_drawable)
+        .apply(centerCropTransform())
+        .submit(100, 200)
+        .get();
+    assertThat(bitmap).isNotNull();
+    assertThat(bitmap.getWidth()).isEqualTo(100);
+    assertThat(bitmap.getHeight()).isEqualTo(200);
+  }
+
+  @Test
+  public void load_withStateListDrawableResourceId_asDrawable_producesNonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.state_list_drawable)
+        .submit()
+        .get();
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withStateListDrawableResourceId_asDrawable_withTransformation_nonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.state_list_drawable)
+        .apply(centerCropTransform())
+        .submit()
+        .get();
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withStateListDrawableResourceId_asBitmap_producesNonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.state_list_drawable)
+        .submit()
+        .get();
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withStateListDrawableResourceId_asBitmap_withTransformation_nonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.state_list_drawable)
+        .apply(centerCropTransform())
+        .submit()
+        .get();
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withVectorDrawableResourceId_asDrawable_producesNonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.vector_drawable)
+        .submit()
+        .get();
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withVectorDrawableResourceId_asDrawable_withTransformation_nonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.vector_drawable)
+        .apply(centerCropTransform())
+        .submit()
+        .get();
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withVectorDrawableResourceId_asBitmap_producesNonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.vector_drawable)
+        .submit()
+        .get();
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withVectorDrawableResourceId_asBitmap_withTransformation_producesNonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.vector_drawable)
+        .apply(centerCropTransform())
+        .submit()
+        .get();
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withNinePatchResourceId_asDrawable_producesNonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.googlelogo_color_120x44dp)
+        .submit()
+        .get();
+
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withNinePatchResourceId_asDrawable_withTransformation_producesNonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.googlelogo_color_120x44dp)
+        .apply(centerCropTransform())
+        .submit()
+        .get();
+
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withNinePatchResourceId_asBitmap_producesNonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.googlelogo_color_120x44dp)
+        .submit()
+        .get();
+
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withNinePatchResourceId_asBitmap_withTransformation_producesNonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.googlelogo_color_120x44dp)
+        .apply(centerCropTransform())
+        .submit()
+        .get();
+
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withApplicationIconResourceIdUri_asDrawable_producesNonNullDrawable()
+      throws NameNotFoundException, ExecutionException, InterruptedException {
+    for (String packageName : getInstalledPackages()) {
+      int iconResourceId = getResourceId(packageName);
+
+      Uri uri = new Uri.Builder()
+          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+          .authority(packageName)
+          .path(String.valueOf(iconResourceId))
+          .build();
+
+      Drawable drawable = Glide.with(context)
+          .load(uri)
+          .submit()
+          .get();
+      assertThat(drawable).isNotNull();
+    }
+  }
+
+  @Test
+  public void load_withApplicationIconResourceIdUri_asDrawable_withTransformation_nonNullDrawable()
+      throws NameNotFoundException, ExecutionException, InterruptedException {
+    for (String packageName : getInstalledPackages()) {
+      int iconResourceId = getResourceId(packageName);
+
+      Uri uri = new Uri.Builder()
+          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+          .authority(packageName)
+          .path(String.valueOf(iconResourceId))
+          .build();
+
+      Drawable drawable = Glide.with(context)
+          .load(uri)
+          .apply(centerCropTransform())
+          .submit()
+          .get();
+      assertThat(drawable).isNotNull();
+    }
+  }
+
+  @Test
+  public void load_withApplicationIconResourceIdUri_asBitmap_producesNonNullBitmap()
+      throws NameNotFoundException, ExecutionException, InterruptedException {
+    for (String packageName : getInstalledPackages()) {
+      int iconResourceId = getResourceId(packageName);
+
+      Uri uri = new Uri.Builder()
+          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+          .authority(packageName)
+          .path(String.valueOf(iconResourceId))
+          .build();
+
+      Bitmap bitmap = Glide.with(context)
+          .asBitmap()
+          .load(uri)
+          .submit()
+          .get();
+      assertThat(bitmap).isNotNull();
+    }
+  }
+
+  @Test
+  public void load_withApplicationIconResourceIdUri_asBitmap_withTransformation_nonNullBitmap()
+      throws NameNotFoundException, ExecutionException, InterruptedException {
+    for (String packageName : getInstalledPackages()) {
+      int iconResourceId = getResourceId(packageName);
+
+      Uri uri = new Uri.Builder()
+          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+          .authority(packageName)
+          .path(String.valueOf(iconResourceId))
+          .build();
+
+      Bitmap bitmap = Glide.with(context)
+          .asBitmap()
+          .apply(centerCropTransform())
+          .load(uri)
+          .submit()
+          .get();
+      assertThat(bitmap).isNotNull();
+    }
+  }
+
+  @Test
+  public void load_withApplicationIconResourceNameUri_asDrawable_producesNonNullDrawable()
+      throws ExecutionException, InterruptedException, NameNotFoundException {
+    for (String packageName : getInstalledPackages()) {
+      int iconResourceId = getResourceId(packageName);
+
+      Context toUse = context.createPackageContext(packageName, /*flags=*/ 0);
+      Resources resources = toUse.getResources();
+      Uri uri = new Uri.Builder()
+          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+          .authority(packageName)
+          .path(resources.getResourceTypeName(iconResourceId))
+          .path(resources.getResourceEntryName(iconResourceId))
+          .path(String.valueOf(iconResourceId))
+          .build();
+
+      Drawable drawable = Glide.with(context)
+          .load(uri)
+          .submit()
+          .get();
+      assertThat(drawable).isNotNull();
+    }
+  }
+
+
+  @Test
+  public void load_withApplicationIconResourceNameUri_asDrawable_withTransform_nonNullDrawable()
+      throws ExecutionException, InterruptedException, NameNotFoundException {
+    for (String packageName : getInstalledPackages()) {
+      int iconResourceId = getResourceId(packageName);
+
+      Context toUse = context.createPackageContext(packageName, /*flags=*/ 0);
+      Resources resources = toUse.getResources();
+      Uri uri = new Uri.Builder()
+          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+          .authority(packageName)
+          .path(resources.getResourceTypeName(iconResourceId))
+          .path(resources.getResourceEntryName(iconResourceId))
+          .path(String.valueOf(iconResourceId))
+          .build();
+
+      Drawable drawable = Glide.with(context)
+          .load(uri)
+          .apply(centerCropTransform())
+          .submit()
+          .get();
+      assertThat(drawable).isNotNull();
+    }
+  }
+
+  @Test
+  public void load_withApplicationIconResourceNameUri_asBitmap_producesNonNullBitmap()
+      throws ExecutionException, InterruptedException, NameNotFoundException {
+    for (String packageName : getInstalledPackages()) {
+      int iconResourceId = getResourceId(packageName);
+
+      Context toUse = context.createPackageContext(packageName, /*flags=*/ 0);
+      Resources resources = toUse.getResources();
+      Uri uri = new Uri.Builder()
+          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+          .authority(packageName)
+          .path(resources.getResourceTypeName(iconResourceId))
+          .path(resources.getResourceEntryName(iconResourceId))
+          .path(String.valueOf(iconResourceId))
+          .build();
+
+      Bitmap bitmap = Glide.with(context)
+          .asBitmap()
+          .load(uri)
+          .submit()
+          .get();
+      assertThat(bitmap).isNotNull();
+    }
+  }
+
+  @Test
+  public void load_withApplicationIconResourceNameUri_asBitmap_withTransform_nonNullBitmap()
+      throws ExecutionException, InterruptedException, NameNotFoundException {
+    for (String packageName : getInstalledPackages()) {
+      int iconResourceId = getResourceId(packageName);
+
+      Context toUse = context.createPackageContext(packageName, /*flags=*/ 0);
+      Resources resources = toUse.getResources();
+      Uri uri = new Uri.Builder()
+          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+          .authority(packageName)
+          .path(resources.getResourceTypeName(iconResourceId))
+          .path(resources.getResourceEntryName(iconResourceId))
+          .path(String.valueOf(iconResourceId))
+          .build();
+
+      Bitmap bitmap = Glide.with(context)
+          .asBitmap()
+          .apply(centerCropTransform())
+          .load(uri)
+          .submit()
+          .get();
+      assertThat(bitmap).isNotNull();
+    }
+  }
+
+  private Set<String> getInstalledPackages() {
+    Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
+    mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
+    PackageManager packageManager = context.getPackageManager();
+    List<ResolveInfo> pkgAppsList =
+        packageManager.queryIntentActivities(mainIntent, /*flags=*/ 0);
+    Set<String> result = new HashSet<>();
+    for (ResolveInfo info : pkgAppsList) {
+      int iconResourceId = getResourceId(info.activityInfo.packageName);
+      if (iconResourceId != 0) {
+        result.add(info.activityInfo.packageName);
+      }
+    }
+    return result;
+  }
+
+  private int getResourceId(String packageName) {
+    PackageInfo packageInfo;
+    try {
+      packageInfo = context.getPackageManager().getPackageInfo(packageName, /*flags=*/ 0);
+    } catch (NameNotFoundException e) {
+      return 0;
+    }
+    return packageInfo.applicationInfo.icon;
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java
new file mode 100644
index 000000000..2019c1758
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java
@@ -0,0 +1,96 @@
+package com.bumptech.glide;
+
+import android.content.Context;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import android.widget.ImageView;
+import com.bumptech.glide.manager.Lifecycle;
+import com.bumptech.glide.manager.LifecycleListener;
+import com.bumptech.glide.manager.RequestManagerTreeNode;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.ResourceIds.raw;
+import com.bumptech.glide.test.TearDownGlide;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(AndroidJUnit4.class)
+public class RequestManagerTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  @Mock private RequestManagerTreeNode treeNode;
+
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private RequestManager requestManager;
+  private Context context;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    context = InstrumentationRegistry.getTargetContext();
+    Glide glide = Glide.get(context);
+    requestManager = new RequestManager(glide, new Lifecycle() {
+      @Override
+      public void addListener(@NonNull LifecycleListener listener) {
+        listener.onStart();
+      }
+
+      @Override
+      public void removeListener(@NonNull LifecycleListener listener) {
+        // Do nothing.
+      }
+    }, treeNode, context);
+  }
+
+  /**
+   * Tests #2262.
+   */
+  @Test
+  public void clear_withNonOwningRequestManager_afterOwningManagerIsDestroyed_doesNotThrow() {
+    // First destroy our Fragment/Activity RequestManager.
+    requestManager.onDestroy();
+
+    final ImageView imageView = new ImageView(context);
+    imageView.measure(100, 100);
+    imageView.layout(0, 0, 100, 100);
+    // Then start a new load with our now destroyed RequestManager.
+    concurrency.loadOnMainThread(requestManager.load(ResourceIds.raw.canonical), imageView);
+
+    // Finally clear our new load with any RequestManager other than the one we used to start it.
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.with(context).clear(imageView);
+      }
+    });
+  }
+
+  /**
+   * Tests b/69361054.
+   */
+  @Test
+  public void clear_withNonOwningRequestManager_onBackgroundTHread_doesNotThrow() {
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        requestManager.onDestroy();
+      }
+    });
+
+    final Target<Drawable> target =
+        concurrency.wait(requestManager.load(raw.canonical).submit());
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.with(context).clear(target);
+      }
+    });
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java
new file mode 100644
index 000000000..c89ea575c
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java
@@ -0,0 +1,254 @@
+package com.bumptech.glide;
+
+import static com.bumptech.glide.test.Matchers.anyDrawable;
+import static com.bumptech.glide.test.Matchers.anyDrawableTarget;
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.anyBoolean;
+import static org.mockito.Mockito.eq;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
+import android.content.Context;
+import android.graphics.drawable.Drawable;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import android.widget.ImageView;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import com.bumptech.glide.test.WaitModelLoader;
+import com.bumptech.glide.test.WaitModelLoader.WaitModel;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+/**
+ * Tests the behaviors of Requests of all types.
+ */
+@RunWith(AndroidJUnit4.class)
+public class RequestTest {
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+  @Mock private RequestListener<Drawable> requestListener;
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private Context context;
+  private ImageView imageView;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    context = InstrumentationRegistry.getTargetContext();
+    imageView = new ImageView(context);
+    imageView.measure(100, 100);
+    imageView.layout(0, 0, 100, 100);
+
+    // Some emulators only have a single resize thread, so waiting on a latch will block them
+    // forever.
+    Glide.init(context,
+        new GlideBuilder().setSourceExecutor(GlideExecutor.newUnlimitedSourceExecutor()));
+  }
+
+  @Test
+  public void clear_withSingleRequest_nullsOutDrawableInView() {
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical),
+        imageView);
+    assertThat(imageView.getDrawable()).isNotNull();
+
+    concurrency.clearOnMainThread(imageView);
+    assertThat(imageView.getDrawable()).isNull();
+  }
+
+  @Test
+  public void clear_withRequestWithThumbnail_nullsOutDrawableInView() {
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .thumbnail(
+                GlideApp.with(context)
+                    .load(ResourceIds.raw.canonical)
+                    .override(100, 100)),
+        imageView);
+    assertThat(imageView.getDrawable()).isNotNull();
+
+    concurrency.clearOnMainThread(imageView);
+    assertThat(imageView.getDrawable()).isNull();
+  }
+
+  @Test
+  public void onStop_withSingleRequest_doesNotNullOutDrawableInView() {
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical),
+        imageView);
+    assertThat(imageView.getDrawable()).isNotNull();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.with(context).onStop();
+      }
+    });
+    assertThat(imageView.getDrawable()).isNotNull();
+  }
+
+  @Test
+  public void onStop_withRequestWithThumbnail_doesNotNullOutDrawableInView() {
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .thumbnail(
+                GlideApp.with(context)
+                  .load(ResourceIds.raw.canonical)
+                  .override(100, 100)),
+        imageView);
+    assertThat(imageView.getDrawable()).isNotNull();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.with(context).onStop();
+      }
+    });
+    assertThat(imageView.getDrawable()).isNotNull();
+  }
+
+  @Test
+  public void onStop_withSingleRequestInProgress_nullsOutDrawableInView() {
+    final WaitModel<Integer> model = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.with(context)
+                .load(ResourceIds.raw.canonical)
+                .into(imageView);
+          }
+        });
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.with(context).onStop();
+      }
+    });
+    assertThat(imageView.getDrawable()).isNull();
+    model.countDown();
+  }
+
+  @Test
+  public void onStop_withRequestWithThumbnailBothInProgress_nullsOutDrawableInView() {
+    final WaitModel<Integer> model = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.with(context)
+                .load(model)
+                .thumbnail(
+                    GlideApp.with(context)
+                    .load(model)
+                    .override(100, 100))
+                .into(imageView);
+
+          }
+        });
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.with(context).onStop();
+      }
+    });
+    assertThat(imageView.getDrawable()).isNull();
+    model.countDown();
+  }
+
+  /** Tests #2555. */
+  @Test
+  public void onStop_withRequestWithOnlyFullInProgress_nullsOutDrawableInView() {
+    final WaitModel<Integer> mainModel = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);
+    concurrency.loadUntilFirstFinish(
+        GlideApp.with(context)
+            .load(mainModel)
+            .listener(requestListener)
+                .thumbnail(GlideApp.with(context)
+                    .load(ResourceIds.raw.canonical)
+                    .listener(requestListener)
+                    .override(100, 100)),
+        imageView);
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.with(context).onStop();
+      }
+    });
+
+    verify(requestListener, never())
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.DATA_DISK_CACHE),
+            anyBoolean());
+    verify(requestListener, never())
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.RESOURCE_DISK_CACHE),
+            anyBoolean());
+    assertThat(imageView.getDrawable()).isNull();
+    mainModel.countDown();
+  }
+
+  @Test
+  public void onStop_withRequestWithOnlyThumbnailInProgress_doesNotNullOutDrawableInView() {
+    final WaitModel<Integer> thumbModel = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);
+    concurrency.loadUntilFirstFinish(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+                .thumbnail(GlideApp.with(context)
+                    .load(thumbModel)
+                    .listener(requestListener)
+                    .override(100, 100)),
+        imageView);
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.with(context).onStop();
+      }
+    });
+
+    verify(requestListener, never())
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.DATA_DISK_CACHE),
+            anyBoolean());
+    verify(requestListener, never())
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.RESOURCE_DISK_CACHE),
+            anyBoolean());
+
+    // Only requests that are running are paused in onStop. The full request should take priority
+    // over the thumbnail request. Therefore, if the full request is finished in onStop, it should
+    // not be cleared, even if the thumbnail request is still running.
+    assertThat(imageView.getDrawable()).isNotNull();
+    thumbModel.countDown();
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/RoundedCornersRegressionTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/RoundedCornersRegressionTest.java
new file mode 100644
index 000000000..0b9404aed
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RoundedCornersRegressionTest.java
@@ -0,0 +1,97 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.resource.bitmap.RoundedCorners;
+import com.bumptech.glide.test.BitmapRegressionTester;
+import com.bumptech.glide.test.CanonicalBitmap;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.RegressionTest;
+import com.bumptech.glide.test.SplitByCpu;
+import com.bumptech.glide.test.SplitBySdk;
+import com.bumptech.glide.test.TearDownGlide;
+import java.util.concurrent.ExecutionException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestName;
+import org.junit.rules.TestRule;
+import org.junit.runner.RunWith;
+
+/**
+ * Compares the output of RoundedCorners with canonical resource files for all SDKs Glide supports
+ * and fails on deltas.
+ */
+@RunWith(AndroidJUnit4.class)
+@SplitByCpu
+@SplitBySdk({26, 24, 23, 21, 19, 18, 16})
+@RegressionTest
+public class RoundedCornersRegressionTest {
+  @Rule public final TestRule tearDownGlide = new TearDownGlide();
+  @Rule public final TestName testName = new TestName();
+
+  private Context context;
+  private BitmapRegressionTester bitmapRegressionTester;
+  private CanonicalBitmap canonicalBitmap;
+
+  @Before
+  public void setUp() throws Exception {
+    context = InstrumentationRegistry.getTargetContext();
+    bitmapRegressionTester = new BitmapRegressionTester(getClass(), testName);
+    canonicalBitmap = new CanonicalBitmap();
+  }
+
+  @Test
+  public void testRoundedCorners() throws ExecutionException, InterruptedException {
+    bitmapRegressionTester.test(
+        GlideApp.with(context)
+            .asBitmap()
+            .load(canonicalBitmap.getBitmap())
+            .transform(new RoundedCorners(5)));
+  }
+
+  @Test
+  public void testRoundedCorners_usePool() throws ExecutionException, InterruptedException {
+    canonicalBitmap = canonicalBitmap.scale(0.1f);
+
+    Bitmap redRect =
+        createRect(
+            Color.RED,
+            canonicalBitmap.getWidth(),
+            canonicalBitmap.getHeight(),
+            Bitmap.Config.ARGB_8888);
+
+    Glide.get(context).getBitmapPool().put(redRect);
+
+    Bitmap roundedRect = bitmapRegressionTester.test(
+        GlideApp.with(context)
+            .asBitmap()
+            .load(canonicalBitmap.getBitmap())
+            .override(canonicalBitmap.getWidth(), canonicalBitmap.getHeight())
+            .transform(new RoundedCorners(5)));
+
+    assertThat(roundedRect).isEqualTo(redRect);
+  }
+
+  @Test
+  public void testRoundedCorners_overRounded() throws ExecutionException, InterruptedException {
+    bitmapRegressionTester.test(
+        GlideApp.with(context)
+            .asBitmap()
+            .load(canonicalBitmap.getBitmap())
+            .transform(new RoundedCorners(20)));
+  }
+
+  private Bitmap createRect(int color, int width, int height, Bitmap.Config config) {
+    final Bitmap result = Bitmap.createBitmap(width, height, config);
+    Canvas canvas = new Canvas(result);
+    canvas.drawColor(color);
+    return result;
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/WideGamutTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/WideGamutTest.java
new file mode 100644
index 000000000..17db2efb4
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/WideGamutTest.java
@@ -0,0 +1,228 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assume.assumeTrue;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.CompressFormat;
+import android.graphics.Bitmap.Config;
+import android.graphics.ColorSpace;
+import android.graphics.ColorSpace.Named;
+import android.os.Build;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruBitmapPool;
+import com.bumptech.glide.load.resource.bitmap.RoundedCorners;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import java.io.ByteArrayOutputStream;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+public class WideGamutTest {
+  @Rule public final TestRule tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private final Context context = InstrumentationRegistry.getTargetContext();
+
+  @Before
+  public void setUp() {
+    assumeTrue(Build.VERSION.SDK_INT >= Build.VERSION_CODES.O);
+  }
+
+  @Test
+  public void load_withWideGamutImage_returnsWideGamutBitmap() {
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(ResourceIds.raw.webkit_logo_p3)
+                .submit());
+    assertThat(bitmap.getConfig()).isEqualTo(Bitmap.Config.RGBA_F16);
+  }
+
+  @Test
+  public void load_withWideGamutImage_bitmapInPoolWithSizeAndConfig_usesBitmapFromPool() {
+    int bitmapDimension = 1000;
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setBitmapPool(new LruBitmapPool(bitmapDimension * bitmapDimension * 8 * 4)));
+    Bitmap expected = Bitmap.createBitmap(bitmapDimension, bitmapDimension, Bitmap.Config.RGBA_F16);
+
+    Glide.get(context)
+        .getBitmapPool()
+        .put(expected);
+
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(ResourceIds.raw.webkit_logo_p3)
+                .submit());
+    assertThat(bitmap).isSameAs(expected);
+  }
+
+  @Test
+  public void load_withWideGamutImage_hardwareAllowed_returnsHardwareBitmap() {
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .format(DecodeFormat.PREFER_ARGB_8888)
+                .load(ResourceIds.raw.webkit_logo_p3)
+                .submit());
+    assertThat(bitmap.getConfig()).isEqualTo(Bitmap.Config.HARDWARE);
+  }
+
+  @Test
+  public void load_withEncodedPngWideGamutImage_decodesWideGamut() {
+    Bitmap toCompress =
+        Bitmap.createBitmap(
+            100, 100, Bitmap.Config.RGBA_F16, /*hasAlpha=*/ true, ColorSpace.get(Named.DCI_P3));
+
+    byte[] data = asPng(toCompress);
+
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(data)
+                .submit());
+    assertThat(bitmap.getConfig()).isEqualTo(Bitmap.Config.RGBA_F16);
+  }
+
+  @Test
+  public void load_withEncodedJpegWideGamutImage_decodesArgb8888() {
+    // TODO(b/71430152): Figure out whether or not this is supposed to pass in API 26 and fail in
+    // API 27.
+    assumeTrue(Build.VERSION.SDK_INT != Build.VERSION_CODES.O_MR1);
+    Bitmap toCompress =
+        Bitmap.createBitmap(
+            100, 100, Bitmap.Config.RGBA_F16, /*hasAlpha=*/ true, ColorSpace.get(Named.DCI_P3));
+
+    byte[] data = asJpeg(toCompress);
+
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(data)
+                .submit());
+    assertThat(bitmap.getConfig()).isEqualTo(Bitmap.Config.ARGB_8888);
+  }
+
+  @Test
+  public void load_withEncodedWebpWideGamutImage_decodesArgb8888() {
+    Bitmap toCompress =
+        Bitmap.createBitmap(
+            100, 100, Bitmap.Config.RGBA_F16, /*hasAlpha=*/ true, ColorSpace.get(Named.DCI_P3));
+
+    byte[] data = asWebp(toCompress);
+
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(data)
+                .submit());
+    assertThat(bitmap.getConfig()).isEqualTo(Bitmap.Config.ARGB_8888);
+  }
+
+  @Test
+  public void load_withSmallerWideGamutInPool_decodesBitmap() {
+    BitmapPool bitmapPool = Glide.get(context).getBitmapPool();
+    Bitmap toPut = Bitmap.createBitmap(300, 298, Config.RGBA_F16);
+    bitmapPool.put(toPut);
+    // Add a second Bitmap to account for the InputStream decode.
+    bitmapPool.put(Bitmap.createBitmap(toPut));
+
+    Bitmap wideGamut = Bitmap.createBitmap(300, 300, Config.RGBA_F16);
+    byte[] data = asPng(wideGamut);
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(data)
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void circleCrop_withWideGamutBitmap_producesWideGamutBitmap() {
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Config.RGBA_F16);
+    byte[] data = asPng(bitmap);
+
+    Bitmap result =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(data)
+                .circleCrop()
+                .submit());
+    assertThat(result).isNotNull();
+    assertThat(result.getConfig()).isEqualTo(Config.RGBA_F16);
+  }
+
+  @Test
+  public void roundedCorners_withWideGamutBitmap_producesWideGamutBitmap() {
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Config.RGBA_F16);
+    byte[] data = asPng(bitmap);
+
+    Bitmap result =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(data)
+                .transform(new RoundedCorners(/*roundingRadius=*/ 10))
+                .submit());
+    assertThat(result).isNotNull();
+    assertThat(result.getConfig()).isEqualTo(Config.RGBA_F16);
+  }
+
+  @Test
+  public void loadWideGamutImage_withArgb888OfSufficientSizeInPool_usesArgb8888Bitmap() {
+    Bitmap wideGamut = Bitmap.createBitmap(100, 50, Bitmap.Config.RGBA_F16);
+    byte[] data = asPng(wideGamut);
+
+    Bitmap argb8888 = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    Glide.init(context, new GlideBuilder()
+        .setBitmapPool(new LruBitmapPool(wideGamut.getAllocationByteCount() * 5)));
+    Glide.get(context).getBitmapPool().put(argb8888);
+
+    Bitmap result =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(data)
+                .submit());
+
+    assertThat(result).isSameAs(argb8888);
+  }
+
+  private static byte[] asJpeg(Bitmap bitmap) {
+    return toByteArray(bitmap, CompressFormat.JPEG);
+  }
+
+  private static byte[] asPng(Bitmap bitmap) {
+    return toByteArray(bitmap, CompressFormat.PNG);
+  }
+
+  private static byte[] asWebp(Bitmap bitmap) {
+    return toByteArray(bitmap, CompressFormat.WEBP);
+  }
+
+  private static byte[] toByteArray(Bitmap bitmap, CompressFormat format) {
+    ByteArrayOutputStream os = new ByteArrayOutputStream();
+    assertThat(bitmap.compress(format, 100, os)).isTrue();
+    return os.toByteArray();
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java b/instrumentation/src/androidTest/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
new file mode 100644
index 000000000..94ef1782c
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
@@ -0,0 +1,116 @@
+package com.bumptech.glide.load.engine.executor;
+
+import android.os.StrictMode;
+import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
+import com.google.common.util.concurrent.ForwardingExecutorService;
+import com.google.common.util.concurrent.MoreExecutors;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Future;
+
+/**
+ * Creates mock {@link GlideExecutor}s.
+ */
+@VisibleForTesting
+public final class MockGlideExecutor {
+  private MockGlideExecutor() {
+    // Utility class.
+  }
+
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public static GlideExecutor newTestExecutor(ExecutorService executorService) {
+    return new GlideExecutor(executorService);
+  }
+
+  public static GlideExecutor newMainThreadExecutor() {
+    return newTestExecutor(new DirectExecutorService());
+  }
+
+  /**
+   * @deprecated Use {@link #newMainThreadExecutor} instead.
+   */
+  @Deprecated
+  public static GlideExecutor newMainThreadUnlimitedExecutor() {
+    return newMainThreadExecutor();
+  }
+
+  /**
+   * DirectExecutorService that enforces StrictMode and converts ExecutionExceptions into
+   * RuntimeExceptions.
+   */
+  private static final class DirectExecutorService extends ForwardingExecutorService {
+    private static final StrictMode.ThreadPolicy THREAD_POLICY =
+        new StrictMode.ThreadPolicy.Builder()
+            .detectNetwork()
+            .penaltyDeath()
+            .build();
+
+    private final ExecutorService delegate;
+
+    DirectExecutorService() {
+      delegate = MoreExecutors.newDirectExecutorService();
+    }
+
+    @Override
+    protected ExecutorService delegate() {
+      return delegate;
+    }
+
+    @NonNull
+    @Override
+    public <T> Future<T> submit(@NonNull Runnable task, @NonNull T result) {
+      return getUninterruptibly(super.submit(task, result));
+    }
+
+    @NonNull
+    @Override
+    public <T> Future<T> submit(@NonNull Callable<T> task) {
+      return getUninterruptibly(super.submit(task));
+    }
+
+    @NonNull
+    @Override
+    public Future<?> submit(@NonNull Runnable task) {
+      return getUninterruptibly(super.submit(task));
+    }
+
+    @Override
+    public void execute(@NonNull final Runnable command) {
+      delegate.execute(new Runnable() {
+        @Override
+        public void run() {
+          StrictMode.ThreadPolicy oldPolicy = StrictMode.getThreadPolicy();
+          StrictMode.setThreadPolicy(THREAD_POLICY);
+          try {
+            command.run();
+          } finally {
+            StrictMode.setThreadPolicy(oldPolicy);
+          }
+        }
+      });
+    }
+
+    private <T> Future<T> getUninterruptibly(Future<T> future) {
+      boolean interrupted = false;
+      try {
+        while (!future.isDone()) {
+          try {
+            future.get();
+          } catch (ExecutionException e) {
+            throw new RuntimeException(e);
+          } catch (InterruptedException e) {
+            interrupted = true;
+          }
+        }
+      } finally {
+        if (interrupted) {
+          Thread.currentThread().interrupt();
+        }
+      }
+      return future;
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerEmulatorTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerEmulatorTest.java
new file mode 100644
index 000000000..4aac56188
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerEmulatorTest.java
@@ -0,0 +1,619 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static android.graphics.Bitmap.CompressFormat.JPEG;
+import static android.graphics.Bitmap.CompressFormat.PNG;
+import static android.graphics.Bitmap.CompressFormat.WEBP;
+import static android.os.Build.VERSION_CODES.KITKAT;
+import static com.bumptech.glide.load.resource.bitmap.DownsamplerEmulatorTest.Api.apis;
+import static com.bumptech.glide.load.resource.bitmap.DownsamplerEmulatorTest.Api.atAndAbove;
+import static com.bumptech.glide.load.resource.bitmap.DownsamplerEmulatorTest.Api.below;
+import static com.bumptech.glide.load.resource.bitmap.DownsamplerEmulatorTest.Api.onAllApisAndAllFormatsExpect;
+import static com.bumptech.glide.load.resource.bitmap.DownsamplerEmulatorTest.Formats.Builder.allFormats;
+import static com.bumptech.glide.load.resource.bitmap.DownsamplerEmulatorTest.Formats.Builder.formats;
+import static org.junit.Assert.fail;
+
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.CompressFormat;
+import android.graphics.Bitmap.Config;
+import android.os.Build;
+import android.os.Build.VERSION_CODES;
+import android.support.annotation.Nullable;
+import android.support.test.runner.AndroidJUnit4;
+import android.util.DisplayMetrics;
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/**
+ * Runs tests to make sure that DownsampleStrategy provides the output we expect.
+ *
+ * WEBP at and above N rounds. Webp below N floors. PNG always floors. JPEG always rounds.
+ */
+@RunWith(AndroidJUnit4.class)
+@SuppressWarnings("VisibleForTests")
+public class DownsamplerEmulatorTest {
+
+  @Test
+  public void calculateScaling_withAtMost() throws IOException {
+    new Tester(DownsampleStrategy.AT_MOST)
+        .setTargetDimensions(100, 100)
+        .givenSquareImageWithDimensionOf(100, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(400, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(300, onAllApisAndAllFormatsExpect(75, 75))
+        .givenImageWithDimensionsOf(799, 100,
+            atAndAbove(VERSION_CODES.N)
+                .with(
+                    formats(JPEG, WEBP)
+                        .expect(100, 13),
+                    formats(PNG)
+                        .expect(99, 12)),
+            below(VERSION_CODES.N)
+                .with(
+                    formats(JPEG)
+                        .expect(100, 13),
+                    formats(PNG, WEBP)
+                        .expect(99, 12)))
+        .givenImageWithDimensionsOf(800, 100,
+            atAndAbove(VERSION_CODES.N)
+                .with(
+                    formats(JPEG, WEBP)
+                        .expect(100, 13),
+                    formats(PNG)
+                        .expect(100, 12)),
+            below(VERSION_CODES.N)
+                .with(
+                    formats(JPEG)
+                        .expect(100, 13),
+                    formats(PNG, WEBP)
+                        .expect(100, 12)))
+        .givenImageWithDimensionsOf(801, 100, onAllApisAndAllFormatsExpect(50, 6))
+        .givenImageWithDimensionsOf(100, 800,
+            atAndAbove(VERSION_CODES.N)
+                .with(
+                    formats(JPEG, WEBP)
+                        .expect(13, 100),
+                    formats(PNG)
+                        .expect(12, 100)),
+            below(VERSION_CODES.N)
+                .with(
+                    formats(JPEG)
+                        .expect(13, 100),
+                    formats(PNG, WEBP)
+                        .expect(12, 100)))
+        .givenImageWithDimensionsOf(87, 78, onAllApisAndAllFormatsExpect(87, 78))
+        // This set of examples demonstrate that webp uses round on N+ and floor < N.
+        .setTargetDimensions(13, 13)
+        .givenSquareImageWithDimensionOf(99,
+            atAndAbove(KITKAT)
+                .with(
+                    // 99 / 8.0 = 12.375. ceil(12.375) = 13. round(12.375) = 12. floor(12.375) = 12.
+                    formats(JPEG)
+                        .expect(13, 13),
+                    formats(PNG, WEBP)
+                        .expect(12, 12)),
+            below(KITKAT)
+                .with(
+                    formats(JPEG)
+                        .expect(13, 13),
+                    formats(PNG, WEBP)
+                        .expect(12, 12)))
+        .givenSquareImageWithDimensionOf(100,
+            atAndAbove(VERSION_CODES.N)
+                .with(
+                    // 100 / 8.0 = 12.5. ceil(12.5) = 13. round(12.5) = 13. floor(12.5) = 12.
+                    formats(JPEG, WEBP)
+                        .expect(13, 13),
+                    formats(PNG)
+                        .expect(12, 12)),
+            below(VERSION_CODES.N)
+                .with(
+                    formats(JPEG)
+                        .expect(13, 13),
+                    formats(PNG, WEBP)
+                        .expect(12, 12)))
+        // Upscaling
+        .setTargetDimensions(500, 500)
+        .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(200, 200))
+        .givenSquareImageWithDimensionOf(450, onAllApisAndAllFormatsExpect(450, 450))
+        .givenImageWithDimensionsOf(200, 450, onAllApisAndAllFormatsExpect(200, 450))
+        .run();
+  }
+
+  @Test
+  public void calculateScaling_withAtLeast() throws IOException {
+    new Tester(DownsampleStrategy.AT_LEAST)
+        .setTargetDimensions(100, 100)
+        .givenSquareImageWithDimensionOf(100, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(300, onAllApisAndAllFormatsExpect(150, 150))
+        .givenImageWithDimensionsOf(799, 100, onAllApisAndAllFormatsExpect(799, 100))
+        .givenImageWithDimensionsOf(800, 100, onAllApisAndAllFormatsExpect(800, 100))
+        .givenImageWithDimensionsOf(801, 100, onAllApisAndAllFormatsExpect(801, 100))
+        .givenImageWithDimensionsOf(100, 800, onAllApisAndAllFormatsExpect(100, 800))
+        .givenImageWithDimensionsOf(87, 78, onAllApisAndAllFormatsExpect(87, 78))
+        // Upscaling
+        .setTargetDimensions(500, 500)
+        .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(200, 200))
+        .givenSquareImageWithDimensionOf(450, onAllApisAndAllFormatsExpect(450, 450))
+        .givenImageWithDimensionsOf(200, 450, onAllApisAndAllFormatsExpect(200, 450))
+        .run();
+  }
+
+  @Test
+  public void calculateScaling_withCenterInside() throws IOException {
+    new Tester(DownsampleStrategy.CENTER_INSIDE)
+        .setTargetDimensions(100, 100)
+        .givenSquareImageWithDimensionOf(100, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(400, onAllApisAndAllFormatsExpect(100, 100))
+        .givenImageWithDimensionsOf(300, 300,
+            atAndAbove(KITKAT).with(allFormats().expect(100, 100)),
+            below(KITKAT).with(allFormats().expect(150, 150)))
+        .givenImageWithDimensionsOf(799, 100,
+            atAndAbove(KITKAT).with(allFormats().expect(100, 13)),
+            below(KITKAT)
+                .with(
+                    formats(JPEG)
+                        .expect(200, 25),
+                    formats(PNG, WEBP)
+                        .expect(199, 25)))
+        .givenImageWithDimensionsOf(800, 100,
+            atAndAbove(KITKAT).with(allFormats().expect(100, 13)),
+            below(KITKAT).with(allFormats().expect(200, 25)))
+        .givenImageWithDimensionsOf(801, 100,
+            atAndAbove(VERSION_CODES.N)
+                .with(
+                    formats(JPEG, WEBP)
+                        .expect(100, 13),
+                    formats(PNG)
+                        .expect(100, 12)),
+            apis(KITKAT, VERSION_CODES.M)
+              .with(
+                  formats(JPEG)
+                      .expect(100, 13),
+                  formats(PNG, WEBP)
+                      .expect(100, 12)),
+            below(KITKAT)
+                .with(
+                    // JPEG is correct because CENTER_INSIDE wants to give a subsequent
+                    // transformation an image that is greater in size than the requested size. On
+                    // Api > VERSION_CODES.KITKAT, CENTER_INSIDE can do the transformation itself.
+                    // On < VERSION_CODES.KITKAT, it has to assume a subsequent transformation will
+                    // be called.
+                    formats(JPEG)
+                        .expect(101, 13),
+                    formats(PNG, WEBP)
+                        .expect(100, 12)))
+        .givenImageWithDimensionsOf(100, 800,
+            atAndAbove(KITKAT).with(allFormats().expect(13, 100)),
+            below(KITKAT).with(allFormats().expect(25, 200)))
+        .givenImageWithDimensionsOf(87, 78, onAllApisAndAllFormatsExpect(87, 78))
+        .setTargetDimensions(897, 897)
+        .givenImageWithDimensionsOf(2208, 1520,
+            atAndAbove(KITKAT).with(allFormats().expect(897, 618)),
+            below(KITKAT).with(allFormats().expect(1104, 760)))
+        // Upscaling
+        .setTargetDimensions(500, 500)
+        .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(200, 200))
+        .givenSquareImageWithDimensionOf(450, onAllApisAndAllFormatsExpect(450, 450))
+        .givenImageWithDimensionsOf(200, 450, onAllApisAndAllFormatsExpect(200, 450))
+        .run();
+  }
+
+  @Test
+  public void calculateScaling_withCenterOutside() throws IOException {
+    new Tester(DownsampleStrategy.CENTER_OUTSIDE)
+        .setTargetDimensions(100, 100)
+        .givenSquareImageWithDimensionOf(100, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(400, onAllApisAndAllFormatsExpect(100, 100))
+        .givenImageWithDimensionsOf(300, 300,
+            atAndAbove(KITKAT).with(allFormats().expect(100, 100)),
+            below(KITKAT).with(allFormats().expect(150, 150)))
+        .givenImageWithDimensionsOf(799, 100, onAllApisAndAllFormatsExpect(799, 100))
+        .givenImageWithDimensionsOf(800, 100, onAllApisAndAllFormatsExpect(800, 100))
+        .givenImageWithDimensionsOf(801, 100, onAllApisAndAllFormatsExpect(801, 100))
+        .givenImageWithDimensionsOf(100, 800, onAllApisAndAllFormatsExpect(100, 800))
+        .givenImageWithDimensionsOf(87, 78,
+            atAndAbove(KITKAT).with(allFormats().expect(112, 100)),
+            below(KITKAT).with(allFormats().expect(87, 78)))
+        // Upscaling
+        .setTargetDimensions(500, 500)
+        .givenSquareImageWithDimensionOf(200,
+            atAndAbove(KITKAT).with(allFormats().expect(500, 500)),
+            below(KITKAT).with(allFormats().expect(200, 200)))
+        .givenSquareImageWithDimensionOf(450,
+            atAndAbove(KITKAT).with(allFormats().expect(500, 500)),
+            below(KITKAT).with(allFormats().expect(450, 450)))
+        .givenImageWithDimensionsOf(200, 450,
+            atAndAbove(KITKAT).with(allFormats().expect(500, 1125)),
+            below(KITKAT).with(allFormats().expect(200, 450)))
+        .run();
+  }
+
+  @Test
+  public void calculateScaling_withNone() throws IOException {
+    new Tester(DownsampleStrategy.NONE)
+        .setTargetDimensions(100, 100)
+        .givenSquareImageWithDimensionOf(100, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(200, 200))
+        .givenSquareImageWithDimensionOf(400, onAllApisAndAllFormatsExpect(400, 400))
+        .givenSquareImageWithDimensionOf(300, onAllApisAndAllFormatsExpect(300, 300))
+        .givenImageWithDimensionsOf(799, 100, onAllApisAndAllFormatsExpect(799, 100))
+        .givenImageWithDimensionsOf(800, 100, onAllApisAndAllFormatsExpect(800, 100))
+        .givenImageWithDimensionsOf(801, 100, onAllApisAndAllFormatsExpect(801, 100))
+        .givenImageWithDimensionsOf(100, 800, onAllApisAndAllFormatsExpect(100, 800))
+        .givenImageWithDimensionsOf(87, 78, onAllApisAndAllFormatsExpect(87, 78))
+        .setTargetDimensions(500, 500)
+        .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(200, 200))
+        .givenSquareImageWithDimensionOf(450, onAllApisAndAllFormatsExpect(450, 450))
+        .givenImageWithDimensionsOf(200, 450, onAllApisAndAllFormatsExpect(200, 450))
+        .run();
+  }
+
+  @Test
+  public void calculateScaling_withFitCenter() throws IOException {
+    new Tester(DownsampleStrategy.FIT_CENTER)
+        .setTargetDimensions(100, 100)
+        .givenSquareImageWithDimensionOf(100, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(400, onAllApisAndAllFormatsExpect(100, 100))
+        .givenImageWithDimensionsOf(300, 300,
+            atAndAbove(KITKAT).with(allFormats().expect(100, 100)),
+            below(KITKAT).with(allFormats().expect(150, 150)))
+        .givenImageWithDimensionsOf(799, 100,
+            atAndAbove(KITKAT).with(allFormats().expect(100, 13)),
+            below(KITKAT)
+                .with(
+                    formats(JPEG)
+                        .expect(200, 25),
+                    formats(PNG, WEBP)
+                        .expect(199, 25)))
+        .givenImageWithDimensionsOf(800, 100,
+            atAndAbove(KITKAT).with(allFormats().expect(100, 13)),
+            below(KITKAT).with(allFormats().expect(200, 25)))
+        .givenImageWithDimensionsOf(801, 100,
+            atAndAbove(VERSION_CODES.N)
+                .with(
+                    formats(JPEG, WEBP)
+                        .expect(100, 13),
+                    formats(PNG)
+                        .expect(100, 12)),
+            apis(KITKAT, VERSION_CODES.M)
+                .with(
+                    formats(JPEG)
+                        .expect(100, 13),
+                    formats(PNG, WEBP)
+                        .expect(100, 12)),
+            below(KITKAT)
+                .with(
+                    // JPEG is correct because FIT_CENTER wants to give a subsequent transformation
+                    // an image that is greater in size than the requested size. On
+                    // Api > VERSION_CODES.KITKAT, FIT_CENTER can do the transformation itself.
+                    // On < VERSION_CODES.KITKAT, it has to assume a transformation will be run
+                    // after it that will fix the rounding error.
+                    formats(JPEG)
+                        .expect(101, 13),
+                    formats(PNG, WEBP)
+                        .expect(100, 12)))
+        .givenImageWithDimensionsOf(100, 800,
+            atAndAbove(KITKAT).with(allFormats().expect(13, 100)),
+            below(KITKAT).with(allFormats().expect(25, 200)))
+        .givenImageWithDimensionsOf(87, 78,
+            atAndAbove(KITKAT).with(allFormats().expect(100, 90)),
+            below(KITKAT).with(allFormats().expect(87, 78)))
+        .setTargetDimensions(897, 897)
+        .givenImageWithDimensionsOf(2208, 1520,
+            atAndAbove(KITKAT).with(allFormats().expect(897, 618)),
+            below(KITKAT).with(allFormats().expect(1104, 760)))
+        .setTargetDimensions(270, 270)
+        // This set of larger image examples exercises sample sizes > 8. Android' scaling logic
+        // varies for jpegs.
+        .givenImageWithDimensionsOf(9014, 1638,
+            // 15 and 16 will OOM so don't run them.
+            atAndAbove(KITKAT).with(allFormats().expect(270, 49)),
+            apis(VERSION_CODES.JELLY_BEAN_MR1, VERSION_CODES.JELLY_BEAN_MR2)
+                .with(allFormats().expect(281, 51)))
+        .givenImageWithDimensionsOf(1638, 9014,
+            // 15 and 16 will OOM so don't run them.
+            atAndAbove(KITKAT).with(allFormats().expect(49, 270)),
+            apis(VERSION_CODES.JELLY_BEAN_MR1, VERSION_CODES.JELLY_BEAN_MR2)
+                .with(allFormats().expect(51, 281)))
+        .givenImageWithDimensionsOf(1638, 1638,
+            atAndAbove(KITKAT).with(allFormats().expect(270, 270)),
+            below(KITKAT)
+                .with(
+                    formats(JPEG)
+                        .expect(410, 410),
+                    formats(PNG, WEBP)
+                        .expect(409, 409)))
+        .givenImageWithDimensionsOf(4507, 819,
+            atAndAbove(KITKAT).with(allFormats().expect(270, 49)),
+            below(KITKAT).with(
+                formats(JPEG)
+                    .expect(282, 51),
+                formats(PNG, WEBP)
+                    .expect(281, 51)))
+        .givenImageWithDimensionsOf(4503, 819,
+            atAndAbove(KITKAT).with(allFormats().expect(270, 49)),
+            below(KITKAT).with(allFormats().expect(281, 51)))
+        // Upscaling
+        .setTargetDimensions(500, 500)
+        .givenSquareImageWithDimensionOf(200,
+            atAndAbove(KITKAT).with(allFormats().expect(500, 500)),
+            below(KITKAT).with(allFormats().expect(200, 200)))
+        .givenSquareImageWithDimensionOf(450,
+            atAndAbove(KITKAT).with(allFormats().expect(500, 500)),
+            below(KITKAT).with(allFormats().expect(450, 450)))
+        .givenImageWithDimensionsOf(200, 450,
+            atAndAbove(KITKAT).with(allFormats().expect(222, 500)),
+            below(KITKAT).with(allFormats().expect(200, 450)))
+        .run();
+  }
+
+  /** Returns an error string if the test failed, and {@code null} otherwise. */
+  @Nullable
+  private static String runScaleTest(
+      CompressFormat format,
+      int initialWidth,
+      int initialHeight,
+      int targetWidth,
+      int targetHeight,
+      DownsampleStrategy strategy,
+      int expectedWidth,
+      int expectedHeight) throws IOException {
+    Downsampler downsampler = buildDownsampler();
+
+    InputStream is = openBitmapStream(format, initialWidth, initialHeight);
+    Options options = new Options()
+        .set(Downsampler.DOWNSAMPLE_STRATEGY, strategy);
+    Bitmap bitmap = downsampler.decode(is, targetWidth, targetHeight, options).get();
+    try {
+      if (bitmap.getWidth() != expectedWidth || bitmap.getHeight() != expectedHeight) {
+        return "API: " + Build.VERSION.SDK_INT + ", os: " + Build.VERSION.RELEASE
+            + ", format: " + format + ", strategy: " + strategy + " -"
+            + " Initial " + readableDimens(initialWidth, initialHeight)
+            + " Target " + readableDimens(targetWidth, targetHeight)
+            + " Expected " + readableDimens(expectedWidth, expectedHeight)
+            + ", but Received " + readableDimens(bitmap.getWidth(), bitmap.getHeight());
+      }
+    } finally {
+      bitmap.recycle();
+    }
+    return null;
+  }
+
+  private static String readableDimens(int width, int height) {
+    return "[" + width + "x" + height + "]";
+  }
+
+  private static Downsampler buildDownsampler() {
+    List<ImageHeaderParser> parsers =
+        Collections.<ImageHeaderParser>singletonList(new DefaultImageHeaderParser());
+    DisplayMetrics displayMetrics = new DisplayMetrics();
+    // XHDPI.
+    displayMetrics.densityDpi = 320;
+    BitmapPool bitmapPool = new BitmapPoolAdapter();
+    ArrayPool arrayPool = new LruArrayPool();
+    return new Downsampler(parsers, displayMetrics, bitmapPool, arrayPool);
+  }
+
+  private static InputStream openBitmapStream(CompressFormat format, int width, int height) {
+    Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888);
+    ByteArrayOutputStream os = new ByteArrayOutputStream();
+    bitmap.compress(format, 100 /*quality*/, os);
+    bitmap.recycle();
+    byte[] data = os.toByteArray();
+    return new ByteArrayInputStream(data);
+  }
+
+  static final class Tester {
+    private final DownsampleStrategy strategy;
+    private final List<TestCase> testCases = new ArrayList<>();
+
+    private int targetWidth;
+    private int targetHeight;
+
+    Tester(DownsampleStrategy strategy) {
+      this.strategy = strategy;
+    }
+
+    Tester setTargetDimensions(int targetWidth, int targetHeight) {
+      this.targetWidth = targetWidth;
+      this.targetHeight = targetHeight;
+      return this;
+    }
+
+    Tester givenSquareImageWithDimensionOf(int dimension, Api... apis) {
+      return givenImageWithDimensionsOf(dimension, dimension, apis);
+    }
+
+    Tester givenImageWithDimensionsOf(
+        int sourceWidth, int sourceHeight, Api... apis) {
+      testCases.add(new TestCase(sourceWidth, sourceHeight, targetWidth, targetHeight, apis));
+      return this;
+    }
+
+    void run() throws IOException {
+      List<String> results = new ArrayList<>();
+      for (TestCase testCase : testCases) {
+        results.addAll(testCase.test(strategy));
+      }
+
+      if (results.isEmpty()) {
+        return;
+      }
+
+      StringBuilder failure = new StringBuilder("Failing Tests:\n");
+      for (String result : results) {
+        failure.append(result).append("\n");
+      }
+      fail(failure.substring(0, failure.length() - 1));
+    }
+
+    private static final class TestCase {
+      private final int sourceWidth;
+      private final int sourceHeight;
+      private final int targetWidth;
+      private final int targetHeight;
+      private final Api[] apis;
+
+      TestCase(int sourceWidth, int sourceHeight, int targetWidth, int targetHeight, Api... apis) {
+        this.sourceWidth = sourceWidth;
+        this.sourceHeight = sourceHeight;
+        this.targetWidth = targetWidth;
+        this.targetHeight = targetHeight;
+        this.apis = apis;
+      }
+
+      List<String> test(DownsampleStrategy strategy)
+          throws IOException {
+        List<String> results = new ArrayList<>();
+        for (Api api : apis) {
+          results.addAll(api.test(sourceWidth, sourceHeight, targetWidth, targetHeight, strategy));
+        }
+        return results;
+      }
+    }
+  }
+
+  static final class Api {
+    private final int startVersion;
+    private final int stopVersion;
+    private final Formats[] formats;
+
+    static Builder apis(int min, int max) {
+      return new Builder().min(min).max(max);
+    }
+
+    static Builder atAndAbove(int min) {
+      return new Builder().min(min);
+    }
+
+    static Builder below(int max) {
+      // max is inclusive.
+      return new Builder().max(max - 1);
+    }
+
+    static Builder allApis() {
+      return new Builder();
+    }
+
+    static Api onAllApisAndAllFormatsExpect(int width, int height) {
+      return allApis().with(allFormats().expect(width, height));
+    }
+
+    static final class Builder {
+      private int maxVersion = Integer.MAX_VALUE;
+      private int minVersion = Integer.MIN_VALUE;
+
+      Builder min(int version) {
+        minVersion = version;
+        return this;
+      }
+
+      Builder max(int version) {
+        this.maxVersion = version;
+        return this;
+      }
+
+      Api with(Formats... formats) {
+        return new Api(minVersion, maxVersion, formats);
+      }
+    }
+
+    Api(int startVersion, int stopVersion, Formats... formats) {
+      this.startVersion = startVersion;
+      this.stopVersion = stopVersion;
+      this.formats = formats;
+    }
+
+    List<String> test(
+        int sourceWidth,
+        int sourceHeight,
+        int targetWidth,
+        int targetHeight,
+        DownsampleStrategy strategy)
+        throws IOException {
+      if (Build.VERSION.SDK_INT < startVersion || Build.VERSION.SDK_INT > stopVersion) {
+        return Collections.emptyList();
+      }
+
+      List<String> results = new ArrayList<>();
+      for (Formats format : formats) {
+        results.addAll(
+            format.runTest(sourceWidth, sourceHeight, targetWidth, targetHeight, strategy));
+
+      }
+      return results;
+    }
+  }
+
+  static final class Formats {
+    private final int expectedWidth;
+    private final int expectedHeight;
+    private final CompressFormat[] formats;
+
+    static final class Builder {
+      private final CompressFormat[] formats;
+
+      static Builder allFormats() {
+        return formats(CompressFormat.values());
+      }
+
+      static Builder formats(CompressFormat... formats) {
+        return new Builder(formats);
+      }
+
+      Builder(CompressFormat... formats) {
+        this.formats = formats;
+      }
+
+      Formats expect(int width, int height) {
+        return new Formats(formats, width, height);
+      }
+    }
+
+    Formats(CompressFormat[] formats, int expectedWidth, int expectedHeight) {
+      this.formats = formats;
+      this.expectedWidth = expectedWidth;
+      this.expectedHeight = expectedHeight;
+    }
+
+    List<String> runTest(
+        int sourceWidth,
+        int sourceHeight,
+        int targetWidth,
+        int targetHeight,
+        DownsampleStrategy strategy) throws IOException {
+      List<String> result = new ArrayList<>();
+      for (CompressFormat format : formats) {
+        String testResult = runScaleTest(
+            format,
+            sourceWidth,
+            sourceHeight,
+            targetWidth,
+            targetHeight,
+            strategy,
+            expectedWidth,
+            expectedHeight);
+        if (testResult != null) {
+          result.add(testResult);
+        }
+      }
+      return result;
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
new file mode 100644
index 000000000..57c48916e
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
@@ -0,0 +1,220 @@
+package com.bumptech.glide.load.resource.gif;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.Manifest.permission;
+import android.content.Context;
+import android.os.Build;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.rule.GrantPermissionRule;
+import android.support.test.runner.AndroidJUnit4;
+import android.view.View;
+import android.view.WindowManager;
+import android.view.WindowManager.LayoutParams;
+import android.widget.ImageView;
+import com.bumptech.glide.load.resource.gif.GifDrawable.GifState;
+import com.bumptech.glide.load.resource.gif.GifFrameLoader.OnEveryFrameListener;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import com.bumptech.glide.util.Preconditions;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestName;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+public class GifDrawableTest {
+  @Rule public final TestName testName = new TestName();
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  @Rule public final GrantPermissionRule grantPermissionRule;
+  private final ConcurrencyHelper concurrencyHelper = new ConcurrencyHelper();
+
+  {
+    if (Build.VERSION.SDK_INT > Build.VERSION_CODES.M) {
+      grantPermissionRule = GrantPermissionRule.grant(permission.SYSTEM_ALERT_WINDOW);
+    } else {
+      grantPermissionRule = GrantPermissionRule.grant();
+    }
+  }
+
+  private Context context;
+
+  @Before
+  public void setUp() {
+    context = InstrumentationRegistry.getTargetContext();
+  }
+
+  @Test
+  public void loadGif_withInterlacedTransparentGif_sizeOriginal_succeeds()
+      throws ExecutionException, InterruptedException {
+    GifDrawable gifDrawable =
+        concurrencyHelper.get(
+            GlideApp.with(context)
+                .asGif()
+                .load(ResourceIds.raw.interlaced_transparent_gif)
+                .submit());
+    assertThat(gifDrawable).isNotNull();
+  }
+
+  @Test
+  public void loadGif_withInterlacedTransparentGif_downsampled_succeeds()
+      throws ExecutionException, InterruptedException {
+    GifDrawable gifDrawable =
+        concurrencyHelper.get(
+            GlideApp.with(context)
+                .asGif()
+                .load(ResourceIds.raw.interlaced_transparent_gif)
+                .submit(10, 10));
+    assertThat(gifDrawable).isNotNull();
+  }
+
+  @Test
+  public void loadGif_withTransparentGif_sizeOriginal_succeeds()
+      throws ExecutionException, InterruptedException {
+    GifDrawable gifDrawable =
+        concurrencyHelper.get(
+            GlideApp.with(context)
+                .asGif()
+                .load(ResourceIds.raw.transparent_gif)
+                .submit());
+    assertThat(gifDrawable).isNotNull();
+  }
+
+  @Test
+  public void loadGif_withTransparentGif_downsampled_succeeds()
+      throws ExecutionException, InterruptedException {
+    GifDrawable gifDrawable =
+        concurrencyHelper.get(
+            GlideApp.with(context)
+                .asGif()
+                .load(ResourceIds.raw.transparent_gif)
+                .submit(10, 10));
+    assertThat(gifDrawable).isNotNull();
+  }
+
+  @Test
+  public void loadGif_withOpaqueGif_sizeOriginal_succeeds()
+      throws ExecutionException, InterruptedException {
+    GifDrawable gifDrawable =
+        concurrencyHelper.get(
+            GlideApp.with(context)
+                .asGif()
+                .load(ResourceIds.raw.opaque_gif)
+                .submit());
+    assertThat(gifDrawable).isNotNull();
+  }
+
+  @Test
+  public void loadGif_withOpaqueGif_downsampled_succeeds()
+      throws ExecutionException, InterruptedException {
+    GifDrawable gifDrawable =
+        concurrencyHelper.get(
+            GlideApp.with(context)
+                .asGif()
+                .load(ResourceIds.raw.opaque_gif)
+                .submit(10, 10));
+    assertThat(gifDrawable).isNotNull();
+  }
+
+  @Test
+  public void loadGif_withOpaqueInterlacedGif_sizeOriginal_succeeds()
+      throws ExecutionException, InterruptedException {
+    GifDrawable gifDrawable =
+        concurrencyHelper.get(
+            GlideApp.with(context)
+                .asGif()
+              .load(ResourceIds.raw.opaque_interlaced_gif)
+              .submit());
+    assertThat(gifDrawable).isNotNull();
+  }
+
+  @Test
+  public void loadGif_withOpaqueInterlacedGif_downsampled_succeeds()
+      throws ExecutionException, InterruptedException {
+    GifDrawable gifDrawable =
+        concurrencyHelper.get(
+            GlideApp.with(context)
+                .asGif()
+                .load(ResourceIds.raw.opaque_interlaced_gif)
+                .submit(10, 10));
+    assertThat(gifDrawable).isNotNull();
+  }
+
+  @Test
+  public void loadGif_intoImageView_afterStop_restartsGif()
+      throws ExecutionException, InterruptedException {
+    // Mimic the state the Drawable can get into if it was loaded into a View previously and stopped
+    // so that it ended up with a pending frame that finished after the stop call.
+    final GifDrawable gifDrawable =
+        concurrencyHelper.get(
+            GlideApp.with(context)
+                .asGif()
+                .load(ResourceIds.raw.dl_world_anim)
+                .submit(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL));
+
+    final CountDownLatch waitForGifFrame = new CountDownLatch(1);
+    // Starting/Stopping loads in GIFs must happen on the main thread.
+    concurrencyHelper.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            // Make sure a frame is loaded while the drawable is stopped.
+            GifState gifState =
+                (GifState) Preconditions.checkNotNull(gifDrawable.getConstantState());
+            gifState.frameLoader.setOnEveryFrameReadyListener(new OnEveryFrameListener() {
+              @Override
+              public void onFrameReady() {
+                waitForGifFrame.countDown();
+              }
+            });
+            gifDrawable.start();
+            gifDrawable.stop();
+          }
+        });
+    ConcurrencyHelper.waitOnLatch(waitForGifFrame);
+
+    // Load the Drawable with the pending frame into a new View and make sure it ends up in the
+    // running state.
+    final ImageView imageView = new ImageView(context);
+    concurrencyHelper.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            addViewToWindow(imageView);
+          }
+        });
+
+    concurrencyHelper.loadOnMainThread(
+        GlideApp.with(context)
+            .load(gifDrawable)
+            .override(Target.SIZE_ORIGINAL),
+        imageView);
+
+    GifDrawable drawableFromView = (GifDrawable) imageView.getDrawable();
+    assertThat(drawableFromView.isRunning()).isTrue();
+
+    drawableFromView.stop();
+    gifDrawable.stop();
+  }
+
+  @SuppressWarnings("deprecation")
+  private void addViewToWindow(View view) {
+    WindowManager.LayoutParams layoutParams = new WindowManager.LayoutParams();
+    layoutParams.height = WindowManager.LayoutParams.MATCH_PARENT;
+    layoutParams.width = WindowManager.LayoutParams.MATCH_PARENT;
+    layoutParams.type =
+        Build.VERSION.SDK_INT >= Build.VERSION_CODES.O
+            ? LayoutParams.TYPE_APPLICATION_OVERLAY
+            : Build.VERSION.SDK_INT == Build.VERSION_CODES.M
+                ? LayoutParams.TYPE_TOAST : LayoutParams.TYPE_SYSTEM_ALERT;
+    WindowManager windowManager =
+        (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
+    Preconditions.checkNotNull(windowManager).addView(view, layoutParams);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapRegressionTester.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapRegressionTester.java
new file mode 100644
index 000000000..f0510cca1
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapRegressionTester.java
@@ -0,0 +1,186 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.CompressFormat;
+import android.graphics.BitmapFactory;
+import android.os.Build;
+import android.os.Environment;
+import android.support.annotation.Nullable;
+import android.support.test.InstrumentationRegistry;
+import com.bumptech.glide.RequestBuilder;
+import java.io.BufferedOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.lang.reflect.Method;
+import java.util.Arrays;
+import java.util.concurrent.ExecutionException;
+import org.junit.rules.TestName;
+
+/**
+ * Checks for regressions for a given Glide load by comparing the result of a load to a previously
+ * saved Bitmap.
+ *
+ * <p>Can be used to generate or re-generate expected {@link Bitmap}s by placing a file named
+ * "regenerate" in /sdcard/DCIM/test_files. The apks containing this tester will need to have
+ * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE}. Resources can be split by apk
+ * by adding {@link SplitBySdk} to test methods or classes. If {@link SplitBySdk} is added to both
+ * a test class and a particular method, the values from the method will be used.
+ *
+ * <p>This class only handles exactly one Bitmap comparison per test method because the resource
+ * names it expects and generates are based on the method name.
+ */
+public final class BitmapRegressionTester {
+  private static final String RESOURCE_TYPE = "raw";
+  private static final String EXTENSION = ".png";
+  private static final String REGENERATE_SIGNAL_FILE_NAME = "regenerate";
+  private static final String GENERATED_FILES_DIR = "test_files";
+  private static final String SEPARATOR = "_";
+
+  private final Class<?> testClass;
+  private final TestName testName;
+  private final Context context = InstrumentationRegistry.getTargetContext();
+
+  public BitmapRegressionTester(Class<?> testClass, TestName testName) {
+    this.testClass = testClass;
+    this.testName = testName;
+
+    if (testClass.getAnnotation(RegressionTest.class) == null) {
+      throw new IllegalArgumentException(
+          testClass + " must be annotated with " + RegressionTest.class);
+    }
+  }
+
+  public Bitmap test(RequestBuilder<Bitmap> request)
+      throws ExecutionException, InterruptedException {
+    Bitmap result = request
+        .submit()
+        .get();
+    if (writeNewExpected()) {
+      writeBitmap(result);
+    }
+    Bitmap expected = decodeExpected();
+    BitmapSubject.assertThat(result).sameAs(expected);
+    return result;
+  }
+
+  private String getResourceName() {
+    return getClassNameString()
+        + SEPARATOR + testName.getMethodName().toLowerCase()
+        + getSdkIntString()
+        + getCpuString();
+  }
+
+  private String getClassNameString() {
+    StringBuilder result = new StringBuilder();
+    for (char c : testClass.getSimpleName().toCharArray()) {
+      if (Character.isUpperCase(c)) {
+        result.append(Character.toLowerCase(c));
+      }
+    }
+    return result.toString();
+  }
+
+  @Nullable
+  private SplitBySdk getSplitBySdkValues() {
+    SplitBySdk result;
+    try {
+      Method method =
+          testClass.getMethod(testName.getMethodName(), /*parameterTypes=*/ (Class[]) null);
+      result = method.getAnnotation(SplitBySdk.class);
+    } catch (NoSuchMethodException e) {
+      throw new RuntimeException(e);
+    }
+
+    if (result == null) {
+      result = testClass.getAnnotation(SplitBySdk.class);
+    }
+    return result;
+  }
+
+  @SuppressWarnings("deprecation")
+  private String getCpuString() {
+    return splitByCpu() ? SEPARATOR + Build.CPU_ABI.replace("-", "_") : "";
+  }
+
+  private boolean splitByCpu() {
+    return testClass.getAnnotation(SplitByCpu.class) != null;
+  }
+
+  private String getSdkIntString() {
+    SplitBySdk splitBySdk = getSplitBySdkValues();
+    if (splitBySdk == null) {
+      return "";
+    }
+    int targetSdk = -1;
+    int[] values = splitBySdk.value();
+    Arrays.sort(values);
+    for (int value : values) {
+      if (value > Build.VERSION.SDK_INT) {
+        break;
+      }
+      targetSdk = value;
+    }
+
+    if (targetSdk == -1) {
+      return "";
+    }
+
+    return SEPARATOR + targetSdk;
+  }
+
+  private File getTestFilesDir() {
+    File dir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM);
+    return new File(dir, GENERATED_FILES_DIR);
+  }
+
+  private void writeBitmap(Bitmap bitmap) {
+    File testFilesDir = getTestFilesDir();
+    File subdirectory = new File(testFilesDir, RESOURCE_TYPE);
+    if (!subdirectory.exists() && !subdirectory.mkdirs()) {
+      throw new IllegalArgumentException("Failed to make directory: " + subdirectory);
+    }
+
+    File file = new File(subdirectory, getResourceName() + EXTENSION);
+    if (file.exists() && !file.delete()) {
+      throw new IllegalStateException("Failed to remove existing file: " + file);
+    }
+
+    OutputStream os = null;
+    try {
+      os = new BufferedOutputStream(new FileOutputStream(file));
+      bitmap.compress(CompressFormat.PNG, /*quality=*/100, os);
+      os.close();
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    } finally {
+      if (os != null) {
+        try {
+          os.close();
+        } catch (IOException e) {
+          // Ignored.
+        }
+      }
+    }
+  }
+
+  private boolean writeNewExpected() {
+    File testFiles = getTestFilesDir();
+    return new File(testFiles, REGENERATE_SIGNAL_FILE_NAME).exists();
+  }
+
+  private Bitmap decodeExpected() {
+    int resourceId =
+        context.getResources()
+            .getIdentifier(getResourceName(), RESOURCE_TYPE, context.getPackageName());
+    if (resourceId == 0) {
+      throw new IllegalArgumentException("Failed to find resource for: " + getResourceName()
+       + " with type: " + RESOURCE_TYPE + " and package: " + context.getPackageName());
+    }
+    BitmapFactory.Options options = new BitmapFactory.Options();
+    options.inScaled = false;
+    return BitmapFactory.decodeResource(context.getResources(), resourceId, options);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapSubject.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapSubject.java
new file mode 100644
index 000000000..fede0a765
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapSubject.java
@@ -0,0 +1,103 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.NonNull;
+import android.support.test.InstrumentationRegistry;
+import android.support.v4.content.res.ResourcesCompat;
+import com.google.common.truth.FailureMetadata;
+import com.google.common.truth.Subject;
+import com.google.common.truth.Truth;
+
+/**
+ * Truth assertions for comparing {@link Bitmap}s.
+ */
+// Test APIs.
+@SuppressWarnings({"WeakerAccess", "unused"})
+public final class BitmapSubject extends Subject<BitmapSubject, Bitmap> {
+
+  private static final Subject.Factory<BitmapSubject, Bitmap> FACTORY =
+      new Subject.Factory<BitmapSubject, Bitmap>() {
+        @Override
+        public BitmapSubject createSubject(
+            @NonNull FailureMetadata metadata, @NonNull Bitmap actual) {
+          return new BitmapSubject(metadata, actual);
+        }
+      };
+
+  private BitmapSubject(FailureMetadata failureMetadata, Bitmap subject) {
+    super(failureMetadata, subject);
+  }
+
+  public static BitmapSubject assertThat(Drawable drawable) {
+    if (!(drawable instanceof BitmapDrawable)) {
+      throw new IllegalArgumentException("Not a BitmapDrawable: " + drawable);
+    }
+    return assertThat(((BitmapDrawable) drawable).getBitmap());
+  }
+
+  public static BitmapSubject assertThat(Bitmap bitmap) {
+    return Truth.assertAbout(FACTORY).that(bitmap);
+  }
+
+  @Override
+  protected String actualCustomStringRepresentation() {
+    return getDisplayString(actual());
+  }
+
+  private static String getDisplayString(Bitmap bitmap) {
+     return "<"
+        + "[" + bitmap.getWidth() + "x" + bitmap.getHeight() + "]"
+        + " "
+        + bitmap.getConfig()
+        + ">";
+  }
+
+  public void sameAs(@DrawableRes int resourceId) {
+    Context context = InstrumentationRegistry.getTargetContext();
+    Drawable drawable =
+        ResourcesCompat.getDrawable(context.getResources(), resourceId, context.getTheme());
+    sameAs(drawable);
+  }
+
+  public void isMutable()  {
+    if (!actual().isMutable()) {
+      fail("is mutable");
+    }
+  }
+
+  public void isImmutable() {
+    if (actual().isMutable()) {
+      fail("is immutable");
+    }
+  }
+
+  public void isNotRecycled() {
+    if (actual().isRecycled()) {
+      fail("is not recycled");
+    }
+  }
+
+  @SuppressWarnings({"unchecked", "ConstantConditions"})
+  public void sameAs(Drawable other) {
+    if (!(other instanceof BitmapDrawable)) {
+      fail("Not a BitmapDrawable");
+    }
+    sameAs(((BitmapDrawable) other).getBitmap());
+  }
+
+  public void sameAs(Bitmap other) {
+    if (!actual().sameAs(other)) {
+      fail("is the same as " + getDisplayString(other));
+    }
+  }
+
+  public void isNotSameAs(Bitmap other) {
+    if (actual().sameAs(other)) {
+      fail("is not the same as " + getDisplayString(other));
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/CanonicalBitmap.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/CanonicalBitmap.java
new file mode 100644
index 000000000..e71aadaf0
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/CanonicalBitmap.java
@@ -0,0 +1,55 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.test.InstrumentationRegistry;
+import com.bumptech.glide.util.Preconditions;
+
+public final class CanonicalBitmap {
+  @Nullable
+  private Bitmap bitmap;
+  @Nullable
+  private Float scaleFactor;
+
+  @NonNull
+  public synchronized Bitmap getBitmap() {
+    if (bitmap == null) {
+      bitmap = decodeBitmap();
+    }
+    return bitmap;
+  }
+
+  public CanonicalBitmap scale(float scaleFactor) {
+    Preconditions.checkArgument(bitmap == null, "Can't set scale factor after decoding image");
+    this.scaleFactor = scaleFactor;
+    return this;
+  }
+
+  public int getWidth() {
+    return getBitmap().getWidth();
+  }
+
+  public int getHeight() {
+    return getBitmap().getHeight();
+  }
+
+  private Bitmap decodeBitmap() {
+    Context context = InstrumentationRegistry.getTargetContext();
+    BitmapFactory.Options options = new BitmapFactory.Options();
+    options.inScaled = false;
+    int resourceId = ResourceIds.raw.canonical;
+    Bitmap result = BitmapFactory.decodeResource(context.getResources(), resourceId, options);
+    if (scaleFactor != null) {
+      result = Bitmap.createScaledBitmap(
+          result,
+          (int) (result.getWidth() * scaleFactor),
+          (int) (result.getHeight() * scaleFactor),
+          /*filter=*/false);
+    }
+    // Make sure the Bitmap is immutable.
+    return result;
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java
new file mode 100644
index 000000000..edca18631
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java
@@ -0,0 +1,327 @@
+package com.bumptech.glide.test;
+
+import android.graphics.drawable.Drawable;
+import android.os.Debug;
+import android.os.Handler;
+import android.os.Looper;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.test.InstrumentationRegistry;
+import android.widget.ImageView;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.request.FutureTarget;
+import com.bumptech.glide.request.Request;
+import com.bumptech.glide.request.target.DrawableImageViewTarget;
+import com.bumptech.glide.request.target.SizeReadyCallback;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.util.Preconditions;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
+
+/**
+ * Helper for running sections of code on the main thread in emulator tests.
+ */
+public class ConcurrencyHelper {
+  private final Handler handler = new Handler(Looper.getMainLooper());
+  private static final long TIMEOUT_SECONDS = 10;
+  private static final TimeUnit TIMEOUT_UNIT = TimeUnit.SECONDS;
+
+  public <T> T get(final Future<T> future) {
+    final AtomicReference<T> reference = new AtomicReference<>();
+    wait(new Waiter() {
+      @Override
+      public boolean await(long timeout, TimeUnit timeUnit) throws InterruptedException {
+        try {
+          reference.set(future.get(timeout, timeUnit));
+          return true;
+        } catch (ExecutionException e) {
+          throw new RuntimeException(e.getCause());
+        } catch (TimeoutException e) {
+          return false;
+        }
+      }
+    });
+    return reference.get();
+  }
+
+  public <T> Target<T> wait(FutureTarget<T> future) {
+    get(future);
+    return future;
+  }
+
+  public void loadOnOtherThread(final Runnable runnable) {
+    final AtomicBoolean isDone = new AtomicBoolean();
+    final Thread thread = new Thread(new Runnable() {
+      @Override
+      public void run() {
+        runnable.run();
+        isDone.set(true);
+      }
+    });
+    thread.start();
+
+    wait(new Waiter() {
+      @Override
+      public boolean await(long timeout, TimeUnit timeUnit) throws InterruptedException {
+        thread.join(timeUnit.toMillis(timeout));
+        return isDone.get();
+      }
+    });
+  }
+
+  public void loadOnMainThread(
+      final RequestBuilder<Drawable> builder, ImageView imageView) {
+    loadOnMainThread(builder, new DrawableImageViewTarget(imageView));
+  }
+
+  public void clearOnMainThread(final ImageView imageView) {
+    runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.with(InstrumentationRegistry.getTargetContext())
+            .clear(imageView);
+      }
+    });
+  }
+
+  public void loadUntilFirstFinish(
+      final RequestBuilder<Drawable> builder, ImageView imageView) {
+    loadUntilFirstFinish(builder, new DrawableImageViewTarget(imageView));
+  }
+
+  private <T> void loadUntilFirstFinish(
+      final RequestBuilder<T> builder, final Target<T> target) {
+    final CountDownLatch latch = new CountDownLatch(1);
+    callOnMainThread(new Callable<Target<T>>() {
+      @Override
+      public Target<T> call() {
+        builder.into(new Target<T>() {
+          @Override
+          public void onStart() {
+            target.onStart();
+          }
+
+          @Override
+          public void onStop() {
+            target.onStop();
+          }
+
+          @Override
+          public void onDestroy() {
+            target.onDestroy();
+          }
+
+          @Override
+          public void onResourceReady(@NonNull T resource,
+              @Nullable Transition<? super T> transition) {
+            target.onResourceReady(resource, transition);
+            latch.countDown();
+          }
+
+          @Override
+          public void onLoadCleared(@Nullable Drawable placeholder) {
+            target.onLoadCleared(placeholder);
+          }
+
+          @Override
+          public void onLoadStarted(@Nullable Drawable placeholder) {
+            target.onLoadStarted(placeholder);
+          }
+
+          @Override
+          public void onLoadFailed(@Nullable Drawable errorDrawable) {
+            target.onLoadFailed(errorDrawable);
+            latch.countDown();
+          }
+
+          @Override
+          public void getSize(@NonNull SizeReadyCallback cb) {
+            target.getSize(cb);
+          }
+
+          @Override
+          public void removeCallback(@NonNull SizeReadyCallback cb) {
+            target.removeCallback(cb);
+          }
+
+          @Override
+          public void setRequest(@Nullable Request request) {
+            target.setRequest(request);
+          }
+
+          @Nullable
+          @Override
+          public Request getRequest() {
+            return target.getRequest();
+          }
+        });
+        return target;
+      }
+    });
+    waitOnLatch(latch);
+  }
+
+  private <T> void loadOnMainThread(final RequestBuilder<T> builder, final Target<T> target) {
+    final CountDownLatch latch = new CountDownLatch(1);
+    callOnMainThread(new Callable<Target<T>>() {
+      @Override
+      public Target<T> call() {
+        builder.into(new Target<T>() {
+          @Override
+          public void onStart() {
+            target.onStart();
+          }
+
+          @Override
+          public void onStop() {
+            target.onStop();
+          }
+
+          @Override
+          public void onDestroy() {
+            target.onDestroy();
+          }
+
+          @Override
+          public void onResourceReady(@NonNull T resource,
+              @Nullable Transition<? super T> transition) {
+            target.onResourceReady(resource, transition);
+            if (!Preconditions.checkNotNull(getRequest()).isRunning()) {
+              latch.countDown();
+            }
+          }
+
+          @Override
+          public void onLoadCleared(@Nullable Drawable placeholder) {
+            target.onLoadCleared(placeholder);
+          }
+
+          @Override
+          public void onLoadStarted(@Nullable Drawable placeholder) {
+            target.onLoadStarted(placeholder);
+          }
+
+          @Override
+          public void onLoadFailed(@Nullable Drawable errorDrawable) {
+            target.onLoadFailed(errorDrawable);
+            if (!Preconditions.checkNotNull(getRequest()).isRunning()) {
+              latch.countDown();
+            }
+          }
+
+          @Override
+          public void getSize(@NonNull SizeReadyCallback cb) {
+            target.getSize(cb);
+          }
+
+          @Override
+          public void removeCallback(@NonNull SizeReadyCallback cb) {
+            target.removeCallback(cb);
+          }
+
+          @Override
+          public void setRequest(@Nullable Request request) {
+            target.setRequest(request);
+          }
+
+          @Nullable
+          @Override
+          public Request getRequest() {
+            return target.getRequest();
+          }
+        });
+        return target;
+      }
+    });
+    waitOnLatch(latch);
+  }
+
+  public void pokeMainThread() {
+    runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        // Do nothing.
+      }
+    });
+  }
+
+  public void runOnMainThread(final Runnable runnable) {
+    callOnMainThread(new Callable<Void>() {
+      @Override
+      public Void call() {
+        runnable.run();
+        return null;
+      }
+    });
+  }
+
+  private <T> void callOnMainThread(final Callable<T> callable) {
+    final CountDownLatch latch = new CountDownLatch(1);
+    handler.post(new Runnable() {
+      @Override
+      public void run() {
+        try {
+          callable.call();
+        } catch (Exception e) {
+          throw new RuntimeException(e);
+        }
+        latch.countDown();
+      }
+    });
+    waitOnLatch(latch);
+  }
+
+  public static void waitOnLatch(final CountDownLatch latch) {
+    wait(new Waiter() {
+      @Override
+      public boolean await(long timeout, TimeUnit timeUnit) throws InterruptedException {
+        return latch.await(timeout, timeUnit);
+      }
+    });
+  }
+
+  private interface Waiter {
+    boolean await(long timeout, TimeUnit timeUnit) throws InterruptedException;
+  }
+
+  private static void wait(Waiter waiter) {
+    boolean isFinished = false;
+    do {
+      try {
+        try {
+          isFinished = waiter.await(TIMEOUT_SECONDS, TIMEOUT_UNIT);
+          if (!isFinished) {
+            throw new WaiterException("Timed out while waiting");
+          }
+        } catch (InterruptedException e) {
+          throw new WaiterException(e);
+        }
+      } catch (WaiterException e) {
+        if (Debug.isDebuggerConnected()) {
+          continue;
+        }
+        throw e;
+      }
+    } while (Debug.isDebuggerConnected() && !isFinished);
+  }
+
+  private static final class WaiterException extends RuntimeException {
+    private static final long serialVersionUID = -627297254223169728L;
+
+    WaiterException(String message) {
+      super(message);
+    }
+
+    WaiterException(Throwable cause) {
+      super(cause);
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/Matchers.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/Matchers.java
new file mode 100644
index 000000000..d941793ea
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/Matchers.java
@@ -0,0 +1,38 @@
+package com.bumptech.glide.test;
+
+import static org.mockito.Mockito.any;
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import com.bumptech.glide.request.target.Target;
+
+/**
+ * Mockito matchers for various common classes.
+ */
+public final class Matchers {
+
+  private Matchers() {
+    // Utility class.
+  }
+
+  public static Target<Drawable> anyDrawableTarget() {
+    return anyTarget();
+  }
+
+  public static Target<Bitmap> anyBitmapTarget() {
+    return anyTarget();
+  }
+
+  @SuppressWarnings("unchecked")
+  public static <T> Target<T> anyTarget() {
+    return (Target<T>) any(Target.class);
+  }
+
+  public static Bitmap anyBitmap() {
+    return any();
+  }
+
+  public static Drawable anyDrawable() {
+    return any();
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/MockModelLoader.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/MockModelLoader.java
new file mode 100644
index 000000000..c1f14110d
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/MockModelLoader.java
@@ -0,0 +1,97 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.test.InstrumentationRegistry;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.model.ModelLoader;
+import com.bumptech.glide.load.model.ModelLoaderFactory;
+import com.bumptech.glide.load.model.MultiModelLoaderFactory;
+import com.bumptech.glide.signature.ObjectKey;
+
+public final class MockModelLoader<ModelT, DataT> implements ModelLoader<ModelT, DataT> {
+  private final ModelT model;
+  private final DataT data;
+
+  @SuppressWarnings("unchecked")
+  public static <ModelT, DataT> void mock(final ModelT model, final DataT data) {
+    Context context = InstrumentationRegistry.getTargetContext();
+
+    Glide.get(context)
+        .getRegistry()
+        .replace(
+            (Class<ModelT>) model.getClass(),
+            (Class<DataT>) data.getClass(),
+            new ModelLoaderFactory<ModelT, DataT>() {
+              @NonNull
+              @Override
+              public ModelLoader<ModelT, DataT> build(
+                  @NonNull MultiModelLoaderFactory multiFactory) {
+                return new MockModelLoader<>(model, data);
+              }
+
+              @Override
+              public void teardown() {
+                // Do nothing.
+              }
+            });
+  }
+
+  private MockModelLoader(ModelT model, DataT data) {
+    this.model = model;
+    this.data = data;
+  }
+
+  @Override
+  public LoadData<DataT> buildLoadData(@NonNull ModelT modelT, int width, int height,
+      @NonNull Options options) {
+    return new LoadData<>(new ObjectKey(modelT), new MockDataFetcher<>(data));
+  }
+
+  @Override
+  public boolean handles(@NonNull ModelT model) {
+    return this.model.equals(model);
+  }
+
+  private static final class MockDataFetcher<DataT> implements DataFetcher<DataT> {
+
+    private final DataT data;
+
+    MockDataFetcher(DataT data) {
+      this.data = data;
+    }
+
+    @Override
+    public void loadData(
+        @NonNull Priority priority, @NonNull DataCallback<? super DataT> callback) {
+      callback.onDataReady(data);
+    }
+
+    @Override
+    public void cleanup() {
+      // Do nothing.
+    }
+
+    @Override
+    public void cancel() {
+      // Do nothing.
+    }
+
+    @NonNull
+    @Override
+    @SuppressWarnings("unchecked")
+    public Class<DataT> getDataClass() {
+      return (Class<DataT>) data.getClass();
+    }
+
+    @NonNull
+    @Override
+    public DataSource getDataSource() {
+      return DataSource.REMOTE;
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/RegressionTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/RegressionTest.java
new file mode 100644
index 000000000..a6dd3629e
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/RegressionTest.java
@@ -0,0 +1,17 @@
+package com.bumptech.glide.test;
+
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Indicates that a test is a regression test that relies on comparing a newly transformed image to
+ * a previously generated copy of the same image to detect changes.
+ */
+@Target(ElementType.TYPE)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface RegressionTest {
+  // Intentionally empty.
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/ResourceIds.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ResourceIds.java
new file mode 100644
index 000000000..d751f0f07
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ResourceIds.java
@@ -0,0 +1,42 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.support.test.InstrumentationRegistry;
+
+/**
+ * Internally in google we don't appear to be able to reference resource ids directly, this class is
+ * a hack around that until we figure out what's going wrong.
+ */
+public final class ResourceIds {
+  private ResourceIds() {
+    // Utility class.
+  }
+
+  public interface raw {
+    int dl_world_anim = getResourceId("raw", "dl_world_anim");
+    int canonical = getResourceId("raw", "canonical");
+    int canonical_png = getResourceId("raw", "canonical_png");
+    int canonical_transparent_png = getResourceId("raw", "canonical_transparent_png");
+    int interlaced_transparent_gif = getResourceId("raw", "interlaced_transparent_gif");
+    int transparent_gif = getResourceId("raw", "transparent_gif");
+    int opaque_gif = getResourceId("raw", "opaque_gif");
+    int opaque_interlaced_gif = getResourceId("raw", "opaque_interlaced_gif");
+    int webkit_logo_p3 = getResourceId("raw", "webkit_logo_p3");
+    int video = getResourceId("raw", "video");
+  }
+
+  public interface drawable {
+    int bitmap_alias = getResourceId("drawable", "bitmap_alias");
+    int googlelogo_color_120x44dp= getResourceId("drawable", "googlelogo_color_120x44dp");
+    int shape_drawable = getResourceId("drawable", "shape_drawable");
+    int state_list_drawable = getResourceId("drawable", "state_list_drawable");
+    int vector_drawable = getResourceId("drawable", "vector_drawable");
+  }
+
+  private static int getResourceId(String type, String resourceName) {
+    Context context = InstrumentationRegistry.getTargetContext();
+    Resources res = context.getResources();
+    return res.getIdentifier(resourceName, type, context.getPackageName());
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/SplitByCpu.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/SplitByCpu.java
new file mode 100644
index 000000000..05fc9cc50
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/SplitByCpu.java
@@ -0,0 +1,15 @@
+package com.bumptech.glide.test;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Indicates that the test relies on transformations or operations that may produce different
+ * outputs on different CPUs.
+ */
+@Target(ElementType.TYPE)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface SplitByCpu {
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/SplitBySdk.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/SplitBySdk.java
new file mode 100644
index 000000000..bc882430a
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/SplitBySdk.java
@@ -0,0 +1,16 @@
+package com.bumptech.glide.test;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Used by {@link BitmapRegressionTester} to generate SDK specific resources to account for
+ * differences in Android's image decoding APIs across versions.
+ */
+@Target({ ElementType.METHOD, ElementType.TYPE })
+@Retention(RetentionPolicy.RUNTIME)
+public @interface SplitBySdk {
+  int[] value();
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/TearDownGlide.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/TearDownGlide.java
new file mode 100644
index 000000000..a99644ddb
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/TearDownGlide.java
@@ -0,0 +1,37 @@
+package com.bumptech.glide.test;
+
+import android.support.test.InstrumentationRegistry;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.RequestManager;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+/**
+ * Clears out Glide's disk cache and the Glide singleton after every test method.
+ */
+public final class TearDownGlide implements TestRule {
+
+  @Override
+  public Statement apply(final Statement base, Description description) {
+    return new Statement() {
+      @Override
+      public void evaluate() throws Throwable {
+        try {
+          base.evaluate();
+        } finally {
+          new ConcurrencyHelper().runOnMainThread(new Runnable() {
+            @Override
+            public void run() {
+              RequestManager requestManager =
+                  Glide.with(InstrumentationRegistry.getTargetContext());
+              requestManager.onStop();
+              requestManager.onDestroy();
+            }
+          });
+          Glide.tearDown();
+        }
+      }
+    };
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java
new file mode 100644
index 000000000..2c89c9227
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java
@@ -0,0 +1,137 @@
+package com.bumptech.glide.test;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.test.InstrumentationRegistry;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.model.ModelLoader;
+import com.bumptech.glide.load.model.ModelLoaderFactory;
+import com.bumptech.glide.load.model.MultiModelLoaderFactory;
+import com.bumptech.glide.test.WaitModelLoader.WaitModel;
+import java.io.InputStream;
+import java.util.concurrent.CountDownLatch;
+
+/**
+ * Allows callers to load an object but force the load to pause until {@link WaitModel#countDown()}
+ * is called.
+ */
+public final class WaitModelLoader<Model, Data>
+    implements ModelLoader<WaitModel<Model>, Data> {
+
+  private final ModelLoader<Model, Data> wrapped;
+
+  private WaitModelLoader(ModelLoader<Model, Data> wrapped) {
+    this.wrapped = wrapped;
+  }
+
+  @Nullable
+  @Override
+  public LoadData<Data> buildLoadData(
+      @NonNull WaitModel<Model> waitModel, int width, int height, @NonNull Options options) {
+    LoadData<Data> wrappedLoadData = wrapped
+        .buildLoadData(waitModel.wrapped, width, height, options);
+    if (wrappedLoadData == null) {
+      return null;
+    }
+    return new LoadData<>(
+        wrappedLoadData.sourceKey, new WaitFetcher<>(wrappedLoadData.fetcher, waitModel.latch));
+  }
+
+  @Override
+  public boolean handles(@NonNull WaitModel<Model> waitModel) {
+    return wrapped.handles(waitModel.wrapped);
+  }
+
+  public static final class WaitModel<T> {
+    private final CountDownLatch latch = new CountDownLatch(1);
+    private final T wrapped;
+
+    WaitModel(T wrapped) {
+      this.wrapped = wrapped;
+    }
+
+    public void countDown() {
+      if (latch.getCount() != 1) {
+        throw new IllegalStateException();
+      }
+      latch.countDown();
+    }
+  }
+
+  public static final class Factory<Model, Data>
+      implements ModelLoaderFactory<WaitModel<Model>, Data> {
+
+    private final Class<Model> modelClass;
+    private final Class<Data> dataClass;
+
+    Factory(Class<Model> modelClass, Class<Data> dataClass) {
+      this.modelClass = modelClass;
+      this.dataClass = dataClass;
+    }
+
+    public static synchronized <T> WaitModel<T> waitOn(T model) {
+      @SuppressWarnings("unchecked") ModelLoaderFactory<WaitModel<T>, InputStream> streamFactory =
+          new Factory<>((Class<T>) model.getClass(), InputStream.class);
+      Glide.get(InstrumentationRegistry.getTargetContext())
+          .getRegistry()
+          .replace(WaitModel.class, InputStream.class, streamFactory);
+
+      return new WaitModel<>(model);
+    }
+
+    @NonNull
+    @Override
+    public ModelLoader<WaitModel<Model>, Data> build(
+        MultiModelLoaderFactory multiFactory) {
+      return new WaitModelLoader<>(multiFactory.build(modelClass, dataClass));
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+  }
+
+  private static final class WaitFetcher<Data> implements DataFetcher<Data> {
+
+    private final DataFetcher<Data> wrapped;
+    private final CountDownLatch toWaitOn;
+
+    WaitFetcher(DataFetcher<Data> wrapped, CountDownLatch toWaitOn) {
+      this.wrapped = wrapped;
+      this.toWaitOn = toWaitOn;
+    }
+
+    @Override
+    public void loadData(@NonNull Priority priority, @NonNull DataCallback<? super Data> callback) {
+      ConcurrencyHelper.waitOnLatch(toWaitOn);
+      wrapped.loadData(priority, callback);
+    }
+
+    @Override
+    public void cleanup() {
+      wrapped.cleanup();
+    }
+
+    @Override
+    public void cancel() {
+      wrapped.cancel();
+    }
+
+    @NonNull
+    @Override
+    public Class<Data> getDataClass() {
+      return wrapped.getDataClass();
+    }
+
+    @NonNull
+    @Override
+    public DataSource getDataSource() {
+      return wrapped.getDataSource();
+    }
+  }
+}
diff --git a/instrumentation/src/main/AndroidManifest.xml b/instrumentation/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..fa6e2915f
--- /dev/null
+++ b/instrumentation/src/main/AndroidManifest.xml
@@ -0,0 +1,6 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+  package="com.bumptech.glide.instrumentation">
+  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
+  <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" />
+  <application />
+</manifest>
diff --git a/instrumentation/src/main/java/com/bumptech/glide/test/InstrumentationAppGlideModule.java b/instrumentation/src/main/java/com/bumptech/glide/test/InstrumentationAppGlideModule.java
new file mode 100644
index 000000000..056d6140a
--- /dev/null
+++ b/instrumentation/src/main/java/com/bumptech/glide/test/InstrumentationAppGlideModule.java
@@ -0,0 +1,9 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
+
+@GlideModule
+public class InstrumentationAppGlideModule extends AppGlideModule {
+  // Intentionally empty.
+}
diff --git a/instrumentation/src/main/res/drawable/bitmap_alias.xml b/instrumentation/src/main/res/drawable/bitmap_alias.xml
new file mode 100644
index 000000000..7dc0bb70a
--- /dev/null
+++ b/instrumentation/src/main/res/drawable/bitmap_alias.xml
@@ -0,0 +1,3 @@
+<?xml version="1.0" encoding="utf-8"?>
+<bitmap xmlns:android="http://schemas.android.com/apk/res/android"
+  android:src="@android:drawable/star_big_off" />
diff --git a/instrumentation/src/main/res/drawable/googlelogo_color_120x44dp.9.png b/instrumentation/src/main/res/drawable/googlelogo_color_120x44dp.9.png
new file mode 100644
index 000000000..1ab50e6cf
Binary files /dev/null and b/instrumentation/src/main/res/drawable/googlelogo_color_120x44dp.9.png differ
diff --git a/instrumentation/src/main/res/drawable/shape_drawable.xml b/instrumentation/src/main/res/drawable/shape_drawable.xml
new file mode 100644
index 000000000..3b19d1445
--- /dev/null
+++ b/instrumentation/src/main/res/drawable/shape_drawable.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<shape xmlns:android="http://schemas.android.com/apk/res/android"
+  android:shape="rectangle">
+  <solid android:color="#ffabcdef"/>
+</shape>
diff --git a/instrumentation/src/main/res/drawable/state_list_drawable.xml b/instrumentation/src/main/res/drawable/state_list_drawable.xml
new file mode 100644
index 000000000..d43039f86
--- /dev/null
+++ b/instrumentation/src/main/res/drawable/state_list_drawable.xml
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="utf-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+
+  <item android:drawable="@android:drawable/checkbox_on_background"
+    android:state_pressed="true" />
+  <item android:drawable="@android:drawable/checkbox_on_background"
+    android:state_checked="true" />
+  <item android:drawable="@android:drawable/checkbox_off_background" />
+
+</selector>
diff --git a/instrumentation/src/main/res/drawable/vector_drawable.xml b/instrumentation/src/main/res/drawable/vector_drawable.xml
new file mode 100644
index 000000000..1732bb9ba
--- /dev/null
+++ b/instrumentation/src/main/res/drawable/vector_drawable.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+  android:width="64dp"
+  android:height="64dp"
+  android:viewportHeight="24.0"
+  android:viewportWidth="24.0">
+  <path
+    android:fillColor="#f9b840"
+    android:pathData="M15.5,5.5c1.1,0 2,-0.9 2,-2s-0.9,-2 -2,-2 -2,0.9
+        -2,2 0.9,2 2,2zM5,12c-2.8,0 -5,2.2 -5,5s2.2,5 5,5 5,-2.2 5,-5 -2.2,
+        -5 -5,-5zM5,20.5c-1.9,0 -3.5,-1.6 -3.5,-3.5s1.6,-3.5 3.5,-3.5 3.5,
+        1.6 3.5,3.5 -1.6,3.5 -3.5,3.5zM10.8,10.5l2.4,-2.4 0.8,0.8c1.3,1.3
+        3,2.1 5.1,2.1L19.1,9c-1.5,0 -2.7,-0.6 -3.6,-1.5l-1.9,-1.9c-0.5,-0.4
+        -1,-0.6 -1.6,-0.6s-1.1,0.2 -1.4,0.6L7.8,8.4c-0.4,0.4 -0.6,0.9 -0.6,
+        1.4 0,0.6 0.2,1.1 0.6,1.4L11,14v5h2v-6.2l-2.2,-2.3zM19,12c-2.8,0 -5,
+        2.2 -5,5s2.2,5 5,5 5,-2.2 5,-5 -2.2,-5 -5,-5zM19,20.5c-1.9,0 -3.5,-1.6
+         -3.5,-3.5s1.6,-3.5 3.5,-3.5 3.5,1.6 3.5,3.5 -1.6,3.5 -3.5,3.5z" />
+</vector>
diff --git a/instrumentation/src/main/res/raw/canonical.jpg b/instrumentation/src/main/res/raw/canonical.jpg
new file mode 100644
index 000000000..889ba2762
Binary files /dev/null and b/instrumentation/src/main/res/raw/canonical.jpg differ
diff --git a/instrumentation/src/main/res/raw/canonical_png.png b/instrumentation/src/main/res/raw/canonical_png.png
new file mode 100644
index 000000000..475aa74c4
Binary files /dev/null and b/instrumentation/src/main/res/raw/canonical_png.png differ
diff --git a/instrumentation/src/main/res/raw/canonical_transparent_png.png b/instrumentation/src/main/res/raw/canonical_transparent_png.png
new file mode 100644
index 000000000..6e8e3eb97
Binary files /dev/null and b/instrumentation/src/main/res/raw/canonical_transparent_png.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_16_armeabi_v7a.png
new file mode 100644
index 000000000..a001e38f1
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_16_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_16_x86.png
new file mode 100644
index 000000000..3a08a9026
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_21_armeabi_v7a.png
new file mode 100644
index 000000000..a001e38f1
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_21_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_21_x86.png
new file mode 100644
index 000000000..515b8e4d3
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_24_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_24_x86.png
new file mode 100644
index 000000000..16efb6214
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_16_armeabi_v7a.png
new file mode 100644
index 000000000..33ae114e4
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_16_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_16_x86.png
new file mode 100644
index 000000000..930e93090
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_21_armeabi_v7a.png
new file mode 100644
index 000000000..33ae114e4
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_21_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_21_x86.png
new file mode 100644
index 000000000..cfd574f85
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_24_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_24_x86.png
new file mode 100644
index 000000000..f8bd1018a
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_16_armeabi_v7a.png
new file mode 100644
index 000000000..3c4f98d1b
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_16_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_16_x86.png
new file mode 100644
index 000000000..fdc961ec6
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_21_armeabi_v7a.png
new file mode 100644
index 000000000..3c4f98d1b
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_21_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_21_x86.png
new file mode 100644
index 000000000..1cd39b7e8
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_24_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_24_x86.png
new file mode 100644
index 000000000..25ca7a8d8
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_16_armeabi_v7a.png
new file mode 100644
index 000000000..63613050c
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_16_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_16_x86.png
new file mode 100644
index 000000000..a6f2ebb73
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_21_armeabi_v7a.png
new file mode 100644
index 000000000..63613050c
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_21_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_21_x86.png
new file mode 100644
index 000000000..fce9cc8e9
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_24_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_24_x86.png
new file mode 100644
index 000000000..889309568
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_16_armeabi_v7a.png
new file mode 100644
index 000000000..7d9667d0c
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_16_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_16_x86.png
new file mode 100644
index 000000000..1515a3629
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_18_armeabi_v7a.png
new file mode 100644
index 000000000..b6cccc383
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_18_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_18_x86.png
new file mode 100644
index 000000000..040a0cb58
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_21_armeabi_v7a.png
new file mode 100644
index 000000000..b6cccc383
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_21_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_21_x86.png
new file mode 100644
index 000000000..3746332ad
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_23_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_23_x86.png
new file mode 100644
index 000000000..c0e1a463f
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_24_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_24_x86.png
new file mode 100644
index 000000000..84ce56297
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_26_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_26_x86.png
new file mode 100644
index 000000000..84ce56297
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_26_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_16_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_16_x86.png
new file mode 100644
index 000000000..1515a3629
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_18_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_18_x86.png
new file mode 100644
index 000000000..040a0cb58
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_21_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_21_x86.png
new file mode 100644
index 000000000..3746332ad
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_23_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_23_x86.png
new file mode 100644
index 000000000..c0e1a463f
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_24_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_24_x86.png
new file mode 100644
index 000000000..84ce56297
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_26_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_26_x86.png
new file mode 100644
index 000000000..84ce56297
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_26_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png
new file mode 100644
index 000000000..bba6152db
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_16_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_16_x86.png
new file mode 100644
index 000000000..b667fbe14
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_18_armeabi_v7a.png
new file mode 100644
index 000000000..3d86fa33a
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_18_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_18_x86.png
new file mode 100644
index 000000000..5829492f9
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png
new file mode 100644
index 000000000..3d86fa33a
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_21_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_21_x86.png
new file mode 100644
index 000000000..7de62e0ea
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_23_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_23_x86.png
new file mode 100644
index 000000000..fdc93c5f0
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_24_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_24_x86.png
new file mode 100644
index 000000000..0f6e9e1df
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_26_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_26_x86.png
new file mode 100644
index 000000000..060028372
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_26_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_16_armeabi_v7a.png
new file mode 100644
index 000000000..6d5494869
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_16_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_16_x86.png
new file mode 100644
index 000000000..80aa1e15a
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_18_armeabi_v7a.png
new file mode 100644
index 000000000..1c0e76eb5
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_18_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_18_x86.png
new file mode 100644
index 000000000..95a70ed33
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_21_armeabi_v7a.png
new file mode 100644
index 000000000..1c0e76eb5
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_21_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_21_x86.png
new file mode 100644
index 000000000..466ab5d9f
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_23_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_23_x86.png
new file mode 100644
index 000000000..810cec1b2
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_24_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_24_x86.png
new file mode 100644
index 000000000..43b654ec6
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_26_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_26_x86.png
new file mode 100644
index 000000000..ceca292da
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_26_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_16_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_16_x86.png
new file mode 100644
index 000000000..cab94eaaa
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_18_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_18_x86.png
new file mode 100644
index 000000000..640c93085
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_21_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_21_x86.png
new file mode 100644
index 000000000..9ead8030f
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_23_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_23_x86.png
new file mode 100644
index 000000000..6f4a4e311
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_24_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_24_x86.png
new file mode 100644
index 000000000..6ab29373f
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_26_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_26_x86.png
new file mode 100644
index 000000000..54d467fb6
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_26_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_16_armeabi_v7a.png
new file mode 100644
index 000000000..288e5f0a3
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_16_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_16_x86.png
new file mode 100644
index 000000000..cab94eaaa
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_18_armeabi_v7a.png
new file mode 100644
index 000000000..14f685740
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_18_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_18_x86.png
new file mode 100644
index 000000000..640c93085
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_21_armeabi_v7a.png
new file mode 100644
index 000000000..14f685740
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_21_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_21_x86.png
new file mode 100644
index 000000000..9ead8030f
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_23_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_23_x86.png
new file mode 100644
index 000000000..6f4a4e311
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_24_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_24_x86.png
new file mode 100644
index 000000000..6ab29373f
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_26_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_26_x86.png
new file mode 100644
index 000000000..54d467fb6
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_26_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png
new file mode 100644
index 000000000..b83034ff1
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_16_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_16_x86.png
new file mode 100644
index 000000000..1262ce7c0
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png
new file mode 100644
index 000000000..b83034ff1
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_21_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_21_x86.png
new file mode 100644
index 000000000..5a64e7e63
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_24_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_24_x86.png
new file mode 100644
index 000000000..396837460
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png
new file mode 100644
index 000000000..31351c2ac
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_16_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_16_x86.png
new file mode 100644
index 000000000..1a6a857c7
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png
new file mode 100644
index 000000000..31351c2ac
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_21_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_21_x86.png
new file mode 100644
index 000000000..9320e9f76
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_24_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_24_x86.png
new file mode 100644
index 000000000..fb6a40f75
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_16_armeabi_v7a.png
new file mode 100644
index 000000000..9f7ad2686
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_16_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_16_x86.png
new file mode 100644
index 000000000..2e1cbbf18
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_21_armeabi_v7a.png
new file mode 100644
index 000000000..9f7ad2686
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_21_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_21_x86.png
new file mode 100644
index 000000000..afe43f81a
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_24_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_24_x86.png
new file mode 100644
index 000000000..5c0019916
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_armeabi_v7a.png
new file mode 100644
index 000000000..fe7204f45
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_x86.png
new file mode 100644
index 000000000..7e45a3dc9
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_armeabi_v7a.png
new file mode 100644
index 000000000..fe7204f45
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_x86.png
new file mode 100644
index 000000000..c1e4e13fc
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_24_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_24_x86.png
new file mode 100644
index 000000000..e7eb65010
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/dl_world_anim.gif b/instrumentation/src/main/res/raw/dl_world_anim.gif
new file mode 100644
index 000000000..1e3b8dea2
Binary files /dev/null and b/instrumentation/src/main/res/raw/dl_world_anim.gif differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png
new file mode 100644
index 000000000..b83034ff1
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_16_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_16_x86.png
new file mode 100644
index 000000000..1262ce7c0
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_18_armeabi_v7a.png
new file mode 100644
index 000000000..b83034ff1
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_18_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_18_x86.png
new file mode 100644
index 000000000..1262ce7c0
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_19_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_19_armeabi_v7a.png
new file mode 100644
index 000000000..b83034ff1
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_19_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_19_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_19_x86.png
new file mode 100644
index 000000000..1262ce7c0
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_19_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png
new file mode 100644
index 000000000..b83034ff1
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_21_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_21_x86.png
new file mode 100644
index 000000000..5a64e7e63
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_23_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_23_x86.png
new file mode 100644
index 000000000..5a64e7e63
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_24_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_24_x86.png
new file mode 100644
index 000000000..396837460
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png
new file mode 100644
index 000000000..31351c2ac
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_16_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_16_x86.png
new file mode 100644
index 000000000..1a6a857c7
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_18_armeabi_v7a.png
new file mode 100644
index 000000000..31351c2ac
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_18_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_18_x86.png
new file mode 100644
index 000000000..1a6a857c7
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_19_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_19_armeabi_v7a.png
new file mode 100644
index 000000000..31351c2ac
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_19_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_19_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_19_x86.png
new file mode 100644
index 000000000..1a6a857c7
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_19_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png
new file mode 100644
index 000000000..31351c2ac
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_21_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_21_x86.png
new file mode 100644
index 000000000..9320e9f76
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_23_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_23_x86.png
new file mode 100644
index 000000000..9320e9f76
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_24_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_24_x86.png
new file mode 100644
index 000000000..fb6a40f75
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_16_armeabi_v7a.png
new file mode 100644
index 000000000..e1abe0fae
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_16_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_16_x86.png
new file mode 100644
index 000000000..6834ef69e
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_18_armeabi_v7a.png
new file mode 100644
index 000000000..e1abe0fae
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_18_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_18_x86.png
new file mode 100644
index 000000000..6834ef69e
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_19_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_19_armeabi_v7a.png
new file mode 100644
index 000000000..e1abe0fae
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_19_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_19_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_19_x86.png
new file mode 100644
index 000000000..6834ef69e
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_19_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_21_armeabi_v7a.png
new file mode 100644
index 000000000..e1abe0fae
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_21_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_21_x86.png
new file mode 100644
index 000000000..cbf40ecec
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_23_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_23_x86.png
new file mode 100644
index 000000000..cbf40ecec
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_24_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_24_x86.png
new file mode 100644
index 000000000..a2a03bfe4
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_armeabi_v7a.png
new file mode 100644
index 000000000..fe7204f45
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_x86.png
new file mode 100644
index 000000000..7e45a3dc9
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_18_armeabi_v7a.png
new file mode 100644
index 000000000..fe7204f45
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_18_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_18_x86.png
new file mode 100644
index 000000000..7e45a3dc9
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_19_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_19_armeabi_v7a.png
new file mode 100644
index 000000000..fe7204f45
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_19_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_19_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_19_x86.png
new file mode 100644
index 000000000..7e45a3dc9
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_19_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_armeabi_v7a.png
new file mode 100644
index 000000000..fe7204f45
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_x86.png
new file mode 100644
index 000000000..c1e4e13fc
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_23_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_23_x86.png
new file mode 100644
index 000000000..c1e4e13fc
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_24_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_24_x86.png
new file mode 100644
index 000000000..e7eb65010
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/interlaced_transparent_gif.gif b/instrumentation/src/main/res/raw/interlaced_transparent_gif.gif
new file mode 100644
index 000000000..283e0fb16
Binary files /dev/null and b/instrumentation/src/main/res/raw/interlaced_transparent_gif.gif differ
diff --git a/instrumentation/src/main/res/raw/opaque_gif.gif b/instrumentation/src/main/res/raw/opaque_gif.gif
new file mode 100644
index 000000000..3b50db910
Binary files /dev/null and b/instrumentation/src/main/res/raw/opaque_gif.gif differ
diff --git a/instrumentation/src/main/res/raw/opaque_interlaced_gif.gif b/instrumentation/src/main/res/raw/opaque_interlaced_gif.gif
new file mode 100644
index 000000000..4ebf12daf
Binary files /dev/null and b/instrumentation/src/main/res/raw/opaque_interlaced_gif.gif differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_16_armeabi_v7a.png
new file mode 100644
index 000000000..caa7c5963
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_16_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_16_x86.png
new file mode 100644
index 000000000..45956c505
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_18_armeabi_v7a.png
new file mode 100644
index 000000000..669269f2b
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_18_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_18_x86.png
new file mode 100644
index 000000000..3e4aab0a0
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_19_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_19_armeabi_v7a.png
new file mode 100644
index 000000000..669269f2b
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_19_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_19_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_19_x86.png
new file mode 100644
index 000000000..3e4aab0a0
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_19_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_21_armeabi_v7a.png
new file mode 100644
index 000000000..6c4dab5b5
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_21_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_21_x86.png
new file mode 100644
index 000000000..28cfaf4bf
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_23_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_23_x86.png
new file mode 100644
index 000000000..28cfaf4bf
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_24_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_24_x86.png
new file mode 100644
index 000000000..cd56aa644
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_26_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_26_x86.png
new file mode 100644
index 000000000..e68bc997c
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_26_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_16_armeabi_v7a.png
new file mode 100644
index 000000000..e1eda26d6
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_16_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_16_x86.png
new file mode 100644
index 000000000..6a53e1dd8
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_18_armeabi_v7a.png
new file mode 100644
index 000000000..683d55fe4
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_18_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_18_x86.png
new file mode 100644
index 000000000..c70fdea57
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_19_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_19_armeabi_v7a.png
new file mode 100644
index 000000000..683d55fe4
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_19_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_19_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_19_x86.png
new file mode 100644
index 000000000..c70fdea57
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_19_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_21_armeabi_v7a.png
new file mode 100644
index 000000000..ecbff14cb
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_21_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_21_x86.png
new file mode 100644
index 000000000..cbb3895b0
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_23_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_23_x86.png
new file mode 100644
index 000000000..843b78f9b
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_24_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_24_x86.png
new file mode 100644
index 000000000..fd26de305
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_26_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_26_x86.png
new file mode 100644
index 000000000..098a5da5e
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_26_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_16_armeabi_v7a.png
new file mode 100644
index 000000000..c8bc48aa4
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_16_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_16_x86.png
new file mode 100644
index 000000000..e42fb5cf8
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_18_armeabi_v7a.png
new file mode 100644
index 000000000..a5cda420f
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_18_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_18_x86.png
new file mode 100644
index 000000000..42229a13f
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_19_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_19_armeabi_v7a.png
new file mode 100644
index 000000000..a5cda420f
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_19_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_19_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_19_x86.png
new file mode 100644
index 000000000..42229a13f
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_19_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_21_armeabi_v7a.png
new file mode 100644
index 000000000..b29b0da31
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_21_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_21_x86.png
new file mode 100644
index 000000000..0f4b78b5d
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_23_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_23_x86.png
new file mode 100644
index 000000000..0f4b78b5d
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_24_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_24_x86.png
new file mode 100644
index 000000000..2295f8881
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_26_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_26_x86.png
new file mode 100644
index 000000000..2295f8881
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_26_x86.png differ
diff --git a/instrumentation/src/main/res/raw/transparent_gif.gif b/instrumentation/src/main/res/raw/transparent_gif.gif
new file mode 100644
index 000000000..88c7097e7
Binary files /dev/null and b/instrumentation/src/main/res/raw/transparent_gif.gif differ
diff --git a/instrumentation/src/main/res/raw/video.mp4 b/instrumentation/src/main/res/raw/video.mp4
new file mode 100644
index 000000000..3ffc91a98
Binary files /dev/null and b/instrumentation/src/main/res/raw/video.mp4 differ
diff --git a/instrumentation/src/main/res/raw/webkit_logo_p3.png b/instrumentation/src/main/res/raw/webkit_logo_p3.png
new file mode 100644
index 000000000..55bad7f81
Binary files /dev/null and b/instrumentation/src/main/res/raw/webkit_logo_p3.png differ
diff --git a/instrumentation/src/main/res/values/strings.xml b/instrumentation/src/main/res/values/strings.xml
new file mode 100644
index 000000000..55344e519
--- /dev/null
+++ b/instrumentation/src/main/res/values/strings.xml
@@ -0,0 +1,3 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+</resources>
\ No newline at end of file
diff --git a/integration/gifencoder/build.gradle b/integration/gifencoder/build.gradle
index 3ef29e0f6..a2ebd546b 100644
--- a/integration/gifencoder/build.gradle
+++ b/integration/gifencoder/build.gradle
@@ -1,19 +1,18 @@
 apply plugin: 'com.android.library'
 
 dependencies {
-    compile project(':library')
-
-    testCompile project(":testutil")
-    testCompile "com.google.truth:truth:${TRUTH_VERSION}"
-    testCompile "junit:junit:${JUNIT_VERSION}"
-    testCompile "org.mockito:mockito-all:${MOCKITO_VERSION}"
-    testCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
-    testCompile "com.android.support:support-v4:${ANDROID_SUPPORT_VERSION}"
+    implementation project(':library')
+
+    testImplementation project(":testutil")
+    testImplementation "com.google.truth:truth:${TRUTH_VERSION}"
+    testImplementation "junit:junit:${JUNIT_VERSION}"
+    testImplementation "org.mockito:mockito-core:${MOCKITO_VERSION}"
+    testImplementation "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
+    testImplementation "com.android.support:support-v4:${ANDROID_SUPPORT_VERSION}"
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     sourceSets {
         main {
diff --git a/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java
index 9051d5f12..0d67e6fd7 100644
--- a/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java
+++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java
@@ -2,6 +2,8 @@
 
 import android.content.Context;
 import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
 import android.util.Log;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.gifdecoder.GifHeader;
@@ -37,19 +39,22 @@
 
   private static final String KEY_ENCODE_TRANSFORMATION =
       "com.bumptech.glide.load.resource.gif.GifResourceEncoder.EncodeTransformation";
-   /**
+  /**
    * A boolean option that, if set to <code>true</code>, causes the fully transformed
    * GIF to be written to cache.
    *
-   * <p> Warning - encoding GIFs is slow and often produces larger and less efficient GIFs than
-   * the originals. Re-encoding may be worth it to decrease the size of very large GIFs. </p>
+   * <p>Warning - encoding GIFs is slow and often produces larger and less efficient GIFs than
+   * the originals. Re-encoding may be worth it to decrease the size of very large GIFs.
    *
-   * <p> Defaults to <code>false</code>. </p>
+   * <p>Defaults to <code>false</code>.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public static final Option<Boolean> ENCODE_TRANSFORMATION =
       Option.disk(KEY_ENCODE_TRANSFORMATION, false, new Option.CacheKeyUpdater<Boolean>() {
         @Override
-        public void update(byte[] keyBytes, Boolean value, MessageDigest messageDigest) {
+        public void update(@NonNull byte[] keyBytes, @NonNull Boolean value,
+            @NonNull MessageDigest messageDigest) {
           if (value) {
             messageDigest.update(keyBytes);
           }
@@ -59,15 +64,17 @@ public void update(byte[] keyBytes, Boolean value, MessageDigest messageDigest)
   private static final Factory FACTORY = new Factory();
   private static final String TAG = "GifEncoder";
   private final GifDecoder.BitmapProvider provider;
-  private Context context;
+  private final Context context;
   private final BitmapPool bitmapPool;
   private final Factory factory;
 
-  public ReEncodingGifResourceEncoder(Context context, BitmapPool bitmapPool) {
+  // Public API.
+  @SuppressWarnings("unused")
+  public ReEncodingGifResourceEncoder(@NonNull Context context, @NonNull BitmapPool bitmapPool) {
     this(context, bitmapPool, FACTORY);
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   ReEncodingGifResourceEncoder(Context context, BitmapPool bitmapPool, Factory factory) {
     this.context = context;
     this.bitmapPool = bitmapPool;
@@ -75,15 +82,17 @@ public ReEncodingGifResourceEncoder(Context context, BitmapPool bitmapPool) {
     this.factory = factory;
   }
 
+  @NonNull
   @Override
-  public EncodeStrategy getEncodeStrategy(Options options) {
+  public EncodeStrategy getEncodeStrategy(@NonNull Options options) {
     Boolean encodeTransformation = options.get(ENCODE_TRANSFORMATION);
     return encodeTransformation != null && encodeTransformation
         ? EncodeStrategy.TRANSFORMED : EncodeStrategy.SOURCE;
   }
 
   @Override
-  public boolean encode(Resource<GifDrawable> resource, File file, Options options) {
+  public boolean encode(@NonNull Resource<GifDrawable> resource, @NonNull File file,
+      @NonNull Options options) {
     GifDrawable drawable = resource.get();
     Transformation<Bitmap> transformation = drawable.getFrameTransformation();
     boolean isTransformed = !(transformation instanceof UnitTransformation);
@@ -191,22 +200,23 @@ private GifDecoder decodeHeaders(ByteBuffer data) {
     return transformedResource;
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class Factory {
 
-    public GifDecoder buildDecoder(GifDecoder.BitmapProvider bitmapProvider) {
+    GifDecoder buildDecoder(GifDecoder.BitmapProvider bitmapProvider) {
       return new StandardGifDecoder(bitmapProvider);
     }
 
-    public GifHeaderParser buildParser() {
+    GifHeaderParser buildParser() {
       return new GifHeaderParser();
     }
 
-    public AnimatedGifEncoder buildEncoder() {
+    AnimatedGifEncoder buildEncoder() {
       return new AnimatedGifEncoder();
     }
 
-    public Resource<Bitmap> buildFrameResource(Bitmap bitmap, BitmapPool bitmapPool) {
+    @NonNull
+    Resource<Bitmap> buildFrameResource(@NonNull Bitmap bitmap, @NonNull BitmapPool bitmapPool) {
       return new BitmapResource(bitmap, bitmapPool);
     }
   }
diff --git a/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java
index dde1d0243..641dc7357 100644
--- a/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java
+++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java
@@ -3,7 +3,6 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
-import static org.junit.Assume.assumeTrue;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
 import static org.mockito.Matchers.eq;
@@ -49,14 +48,14 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class ReEncodingGifResourceEncoderTest {
-  @Mock Resource<GifDrawable> resource;
-  @Mock GifDecoder decoder;
-  @Mock GifHeaderParser parser;
-  @Mock AnimatedGifEncoder gifEncoder;
-  @Mock Resource<Bitmap> frameResource;
-  @Mock GifDrawable gifDrawable;
-  @Mock Transformation<Bitmap> frameTransformation;
-  @Mock Resource<Bitmap> transformedResource;
+  @Mock private Resource<GifDrawable> resource;
+  @Mock private GifDecoder decoder;
+  @Mock private GifHeaderParser parser;
+  @Mock private AnimatedGifEncoder gifEncoder;
+  @Mock private Resource<Bitmap> frameResource;
+  @Mock private GifDrawable gifDrawable;
+  @Mock private Transformation<Bitmap> frameTransformation;
+  @Mock private Resource<Bitmap> transformedResource;
 
   private ReEncodingGifResourceEncoder encoder;
   private Options options;
@@ -70,6 +69,7 @@ public void setUp() {
     Application context = RuntimeEnvironment.application;
 
     ReEncodingGifResourceEncoder.Factory factory = mock(ReEncodingGifResourceEncoder.Factory.class);
+    when(decoder.getNextFrame()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
     when(factory.buildDecoder(any(GifDecoder.BitmapProvider.class))).thenReturn(decoder);
     when(factory.buildParser()).thenReturn(parser);
     when(factory.buildEncoder()).thenReturn(gifEncoder);
@@ -94,6 +94,8 @@ public void setUp() {
 
   @After
   public void tearDown() {
+    // GC before delete() to release files on Windows (https://stackoverflow.com/a/4213208/253468)
+    System.gc();
     if (file.exists() && !file.delete()) {
       throw new RuntimeException("Failed to delete file");
     }
@@ -119,8 +121,6 @@ public void testEncodeStrategy_withEncodeTransformationFalse_returnsSource() {
   @Test
   public void testEncode_withEncodeTransformationFalse_writesSourceDataToStream()
       throws IOException {
-    // Most likely an instance of http://stackoverflow.com/q/991489/253468
-    assumeTrue(!System.getProperty("os.name").startsWith("Windows"));
     options.set(ReEncodingGifResourceEncoder.ENCODE_TRANSFORMATION, false);
     String expected = "testString";
     byte[] data = expected.getBytes("UTF-8");
@@ -133,7 +133,6 @@ public void testEncode_withEncodeTransformationFalse_writesSourceDataToStream()
   @Test
   public void testEncode_WithEncodeTransformationFalse_whenOsThrows_returnsFalse()
       throws IOException {
-
     options.set(ReEncodingGifResourceEncoder.ENCODE_TRANSFORMATION, false);
     byte[] data = "testString".getBytes("UTF-8");
     when(gifDrawable.getBuffer()).thenReturn(ByteBuffer.wrap(data));
@@ -311,10 +310,7 @@ public void testRecyclesFrameResourceAfterWritingIfFrameResourceIsNotTransformed
   }
 
   @Test
-  public void testWritesBytesDirectlyToDiskIfTransformationIsUnitTransformation()
-      throws IOException {
-    // Most likely an instance of http://stackoverflow.com/q/991489/253468
-    assumeTrue(!System.getProperty("os.name").startsWith("Windows"));
+  public void testWritesBytesDirectlyToDiskIfTransformationIsUnitTransformation() {
     when(gifDrawable.getFrameTransformation()).thenReturn(UnitTransformation.<Bitmap>get());
     String expected = "expected";
     when(gifDrawable.getBuffer()).thenReturn(ByteBuffer.wrap(expected.getBytes()));
diff --git a/integration/okhttp/build.gradle b/integration/okhttp/build.gradle
index dcce0013f..a8cd599a1 100644
--- a/integration/okhttp/build.gradle
+++ b/integration/okhttp/build.gradle
@@ -1,16 +1,15 @@
 apply plugin: 'com.android.library'
 
 dependencies {
-    compile project(':library')
+    implementation project(':library')
     annotationProcessor project(':annotation:compiler')
 
-    compile "com.squareup.okhttp:okhttp:2.7.1"
-    compile "com.android.support:support-annotations:{$ANDROID_SUPPORT_VERSION}"
+    api "com.squareup.okhttp:okhttp:2.7.5"
+    api "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}"
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         minSdkVersion MIN_SDK_VERSION as int
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java
index 36a47491f..1bc1047a9 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.integration.okhttp;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
@@ -21,7 +22,7 @@
 @Deprecated
 public class OkHttpGlideModule implements com.bumptech.glide.module.GlideModule {
   @Override
-  public void applyOptions(Context context, GlideBuilder builder) {
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
     // Do nothing.
   }
 
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
index 936f95f81..dcac2f768 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
@@ -27,16 +27,19 @@
   private static final String TAG = "OkHttpFetcher";
   private final OkHttpClient client;
   private final GlideUrl url;
-  @Synthetic InputStream stream;
-  @Synthetic ResponseBody responseBody;
+  @SuppressWarnings("WeakerAccess") @Synthetic InputStream stream;
+  @SuppressWarnings("WeakerAccess") @Synthetic ResponseBody responseBody;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public OkHttpStreamFetcher(OkHttpClient client, GlideUrl url) {
     this.client = client;
     this.url = url;
   }
 
   @Override
-  public void loadData(Priority priority, final DataCallback<? super InputStream> callback) {
+  public void loadData(@NonNull Priority priority,
+      @NonNull final DataCallback<? super InputStream> callback) {
     Request.Builder requestBuilder = new Request.Builder().url(url.toStringUrl());
     for (Map.Entry<String, String> headerEntry : url.getHeaders().entrySet()) {
       String key = headerEntry.getKey();
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java
index 48468bf63..174c446f2 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.integration.okhttp;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
@@ -18,27 +19,32 @@
 
   private final OkHttpClient client;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public OkHttpUrlLoader(OkHttpClient client) {
     this.client = client;
   }
 
   @Override
-  public boolean handles(GlideUrl url) {
+  public boolean handles(@NonNull GlideUrl url) {
     return true;
   }
 
+  @SuppressWarnings("deprecation")
   @Override
-  public LoadData<InputStream> buildLoadData(GlideUrl model, int width, int height,
-      Options options) {
+  public LoadData<InputStream> buildLoadData(@NonNull GlideUrl model, int width, int height,
+      @NonNull Options options) {
     return new LoadData<>(model, new OkHttpStreamFetcher(client, model));
   }
 
   /**
    * The default factory for {@link OkHttpUrlLoader}s.
    */
+  // Public API.
+  @SuppressWarnings({"WeakerAccess", "deprecation"})
   public static class Factory implements ModelLoaderFactory<GlideUrl, InputStream> {
     private static volatile OkHttpClient internalClient;
-    private OkHttpClient client;
+    private final OkHttpClient client;
 
     private static OkHttpClient getInternalClient() {
       if (internalClient == null) {
@@ -65,6 +71,8 @@ public Factory(OkHttpClient client) {
       this.client = client;
     }
 
+    @NonNull
+    @SuppressWarnings("deprecation")
     @Override
     public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new OkHttpUrlLoader(client);
diff --git a/integration/okhttp3/build.gradle b/integration/okhttp3/build.gradle
index 5290c6a42..8e8590841 100644
--- a/integration/okhttp3/build.gradle
+++ b/integration/okhttp3/build.gradle
@@ -1,16 +1,15 @@
 apply plugin: 'com.android.library'
 
 dependencies {
-    compile project(':library')
+    implementation project(':library')
     annotationProcessor project(':annotation:compiler')
 
-    compile "com.squareup.okhttp3:okhttp:${OK_HTTP_VERSION}"
-    compile "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}"
+    api "com.squareup.okhttp3:okhttp:${OK_HTTP_VERSION}"
+    api "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}"
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         minSdkVersion MIN_SDK_VERSION as int
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java
index 60517251f..e58b041dd 100644
--- a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.integration.okhttp3;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
@@ -22,7 +23,7 @@
 @Deprecated
 public class OkHttpGlideModule implements com.bumptech.glide.module.GlideModule {
   @Override
-  public void applyOptions(Context context, GlideBuilder builder) {
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
     // Do nothing.
   }
 
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java
index 74eace9eb..b315acbd7 100644
--- a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.integration.okhttp3;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.Registry;
 import com.bumptech.glide.annotation.GlideModule;
@@ -19,7 +20,8 @@
 @GlideModule
 public final class OkHttpLibraryGlideModule extends LibraryGlideModule {
   @Override
-  public void registerComponents(Context context, Glide glide, Registry registry) {
+  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry) {
     registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());
   }
 }
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java
index a0b0faaef..2b6a69b38 100644
--- a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.integration.okhttp3;
 
-import android.os.Build;
 import android.support.annotation.NonNull;
 import android.util.Log;
 import com.bumptech.glide.Priority;
@@ -9,7 +8,7 @@
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.util.ContentLengthInputStream;
-import com.bumptech.glide.util.Synthetic;
+import com.bumptech.glide.util.Preconditions;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.Map;
@@ -21,23 +20,27 @@
 /**
  * Fetches an {@link InputStream} using the okhttp library.
  */
-public class OkHttpStreamFetcher implements DataFetcher<InputStream>,
- okhttp3.Callback {
+public class OkHttpStreamFetcher implements DataFetcher<InputStream>, okhttp3.Callback {
   private static final String TAG = "OkHttpFetcher";
   private final Call.Factory client;
   private final GlideUrl url;
-  @Synthetic InputStream stream;
-  @Synthetic ResponseBody responseBody;
-  private volatile Call call;
+  private InputStream stream;
+  private ResponseBody responseBody;
   private DataCallback<? super InputStream> callback;
+  // call may be accessed on the main thread while the object is in use on other threads. All other
+  // accesses to variables may occur on different threads, but only one at a time.
+  private volatile Call call;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public OkHttpStreamFetcher(Call.Factory client, GlideUrl url) {
     this.client = client;
     this.url = url;
   }
 
   @Override
-  public void loadData(Priority priority, final DataCallback<? super InputStream> callback) {
+  public void loadData(@NonNull Priority priority,
+      @NonNull final DataCallback<? super InputStream> callback) {
     Request.Builder requestBuilder = new Request.Builder().url(url.toStringUrl());
     for (Map.Entry<String, String> headerEntry : url.getHeaders().entrySet()) {
       String key = headerEntry.getKey();
@@ -47,25 +50,11 @@ public void loadData(Priority priority, final DataCallback<? super InputStream>
     this.callback = callback;
 
     call = client.newCall(request);
-    if (Build.VERSION.SDK_INT != Build.VERSION_CODES.O) {
-      call.enqueue(this);
-    } else {
-      try {
-        // Calling execute instead of enqueue is a workaround for #2355, where okhttp throws a
-        // ClassCastException on O.
-        onResponse(call, call.execute());
-      } catch (IOException e) {
-        onFailure(call, e);
-      } catch (ClassCastException e) {
-        // It's not clear that this catch is necessary, the error may only occur even on O if
-        // enqueue is used.
-        onFailure(call, new IOException("Workaround for framework bug on O", e));
-      }
-    }
+    call.enqueue(this);
   }
 
   @Override
-  public void onFailure(Call call, IOException e) {
+  public void onFailure(@NonNull Call call, @NonNull IOException e) {
     if (Log.isLoggable(TAG, Log.DEBUG)) {
       Log.d(TAG, "OkHttp failed to obtain result", e);
     }
@@ -74,10 +63,10 @@ public void onFailure(Call call, IOException e) {
   }
 
   @Override
-  public void onResponse(Call call, Response response) throws IOException {
+  public void onResponse(@NonNull Call call, @NonNull Response response) {
     responseBody = response.body();
     if (response.isSuccessful()) {
-      long contentLength = responseBody.contentLength();
+      long contentLength = Preconditions.checkNotNull(responseBody).contentLength();
       stream = ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);
       callback.onDataReady(stream);
     } else {
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java
index b63164a59..8f8f9066c 100644
--- a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.integration.okhttp3;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
@@ -16,27 +17,31 @@
 
   private final Call.Factory client;
 
-  public OkHttpUrlLoader(Call.Factory client) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public OkHttpUrlLoader(@NonNull Call.Factory client) {
     this.client = client;
   }
 
   @Override
-  public boolean handles(GlideUrl url) {
+  public boolean handles(@NonNull GlideUrl url) {
     return true;
   }
 
   @Override
-  public LoadData<InputStream> buildLoadData(GlideUrl model, int width, int height,
-      Options options) {
+  public LoadData<InputStream> buildLoadData(@NonNull GlideUrl model, int width, int height,
+      @NonNull Options options) {
     return new LoadData<>(model, new OkHttpStreamFetcher(client, model));
   }
 
   /**
    * The default factory for {@link OkHttpUrlLoader}s.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public static class Factory implements ModelLoaderFactory<GlideUrl, InputStream> {
     private static volatile Call.Factory internalClient;
-    private Call.Factory client;
+    private final Call.Factory client;
 
     private static Call.Factory getInternalClient() {
       if (internalClient == null) {
@@ -61,10 +66,11 @@ public Factory() {
      *
      * @param client this is typically an instance of {@code OkHttpClient}.
      */
-    public Factory(Call.Factory client) {
+    public Factory(@NonNull Call.Factory client) {
       this.client = client;
     }
 
+    @NonNull
     @Override
     public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new OkHttpUrlLoader(client);
diff --git a/integration/recyclerview/build.gradle b/integration/recyclerview/build.gradle
index 24eb09e46..2a6154e9f 100644
--- a/integration/recyclerview/build.gradle
+++ b/integration/recyclerview/build.gradle
@@ -1,14 +1,13 @@
 apply plugin: 'com.android.library'
 
 dependencies {
-    compile project(':library')
-    provided "com.android.support:recyclerview-v7:${ANDROID_SUPPORT_VERSION}"
-    provided "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
+    implementation project(':library')
+    compileOnly "com.android.support:recyclerview-v7:${ANDROID_SUPPORT_VERSION}"
+    compileOnly "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         minSdkVersion MIN_SDK_VERSION as int
diff --git a/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerToListViewScrollListener.java b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerToListViewScrollListener.java
index a3fd25880..30bf14dcb 100644
--- a/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerToListViewScrollListener.java
+++ b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerToListViewScrollListener.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.integration.recyclerview;
 
+import android.support.annotation.NonNull;
 import android.support.v7.widget.LinearLayoutManager;
 import android.support.v7.widget.RecyclerView;
 import android.widget.AbsListView;
@@ -11,6 +12,8 @@
  *
  * <p>Requires that the the recycler view be using a {@link LinearLayoutManager} subclass.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public final class RecyclerToListViewScrollListener extends RecyclerView.OnScrollListener {
   public static final int UNKNOWN_SCROLL_STATE = Integer.MIN_VALUE;
   private final AbsListView.OnScrollListener scrollListener;
@@ -18,7 +21,7 @@
   private int lastVisibleCount = -1;
   private int lastItemCount = -1;
 
-  public RecyclerToListViewScrollListener(AbsListView.OnScrollListener scrollListener) {
+  public RecyclerToListViewScrollListener(@NonNull AbsListView.OnScrollListener scrollListener) {
     this.scrollListener = scrollListener;
   }
 
diff --git a/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java
index 47be184a7..fb2294780 100644
--- a/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java
+++ b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java
@@ -2,6 +2,7 @@
 
 import android.app.Activity;
 import android.app.Fragment;
+import android.support.annotation.NonNull;
 import android.support.v4.app.FragmentActivity;
 import android.support.v7.widget.RecyclerView;
 import com.bumptech.glide.Glide;
@@ -34,17 +35,18 @@
   /**
    * Helper constructor that accepts an {@link Activity}.
    */
-  public RecyclerViewPreloader(Activity activity,
-      PreloadModelProvider<T> preloadModelProvider,
-      PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {
+  public RecyclerViewPreloader(@NonNull Activity activity,
+      @NonNull PreloadModelProvider<T> preloadModelProvider,
+      @NonNull PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {
     this(Glide.with(activity), preloadModelProvider, preloadDimensionProvider, maxPreload);
   }
 
   /**
    * Helper constructor that accepts an {@link FragmentActivity}.
    */
-  public RecyclerViewPreloader(FragmentActivity fragmentActivity,
-      PreloadModelProvider<T> preloadModelProvider, PreloadSizeProvider<T> preloadDimensionProvider,
+  public RecyclerViewPreloader(@NonNull FragmentActivity fragmentActivity,
+      @NonNull PreloadModelProvider<T> preloadModelProvider,
+      @NonNull PreloadSizeProvider<T> preloadDimensionProvider,
       int maxPreload) {
     this(Glide.with(fragmentActivity), preloadModelProvider, preloadDimensionProvider, maxPreload);
   }
@@ -52,8 +54,9 @@ public RecyclerViewPreloader(FragmentActivity fragmentActivity,
   /**
    * Helper constructor that accepts an {@link Fragment}.
    */
-  public RecyclerViewPreloader(Fragment fragment,
-      PreloadModelProvider<T> preloadModelProvider, PreloadSizeProvider<T> preloadDimensionProvider,
+  public RecyclerViewPreloader(@NonNull Fragment fragment,
+      @NonNull PreloadModelProvider<T> preloadModelProvider,
+      @NonNull PreloadSizeProvider<T> preloadDimensionProvider,
       int maxPreload) {
     this(Glide.with(fragment), preloadModelProvider, preloadDimensionProvider, maxPreload);
   }
@@ -61,11 +64,13 @@ public RecyclerViewPreloader(Fragment fragment,
   /**
    * Helper constructor that accepts an {@link android.support.v4.app.Fragment}.
    */
-  public RecyclerViewPreloader(android.support.v4.app.Fragment fragment,
-      PreloadModelProvider<T> preloadModelProvider, PreloadSizeProvider<T> preloadDimensionProvider,
+  public RecyclerViewPreloader(@NonNull android.support.v4.app.Fragment fragment,
+      @NonNull PreloadModelProvider<T> preloadModelProvider,
+      @NonNull PreloadSizeProvider<T> preloadDimensionProvider,
       int maxPreload) {
     this(Glide.with(fragment), preloadModelProvider, preloadDimensionProvider, maxPreload);
   }
+
   /**
    * Constructor that accepts interfaces for providing the dimensions of images to preload, the list
    * of models to preload for a given position, and the request to use to load images.
@@ -74,9 +79,9 @@ public RecyclerViewPreloader(android.support.v4.app.Fragment fragment,
    * @param preloadDimensionProvider Provides the dimensions of images to load.
    * @param maxPreload               Maximum number of items to preload.
    */
-  public RecyclerViewPreloader(RequestManager requestManager,
-      PreloadModelProvider<T> preloadModelProvider,
-      PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {
+  public RecyclerViewPreloader(@NonNull RequestManager requestManager,
+      @NonNull PreloadModelProvider<T> preloadModelProvider,
+      @NonNull PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {
 
     ListPreloader<T> listPreloader = new ListPreloader<>(requestManager, preloadModelProvider,
         preloadDimensionProvider, maxPreload);
diff --git a/integration/volley/build.gradle b/integration/volley/build.gradle
index b4c5a53ff..a6776127a 100644
--- a/integration/volley/build.gradle
+++ b/integration/volley/build.gradle
@@ -1,22 +1,21 @@
 apply plugin: 'com.android.library'
 
 dependencies {
-    compile project(':library')
-    compile "com.android.volley:volley:${VOLLEY_VERSION}"
-    compile "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}"
+    implementation project(':library')
+    api "com.android.volley:volley:${VOLLEY_VERSION}"
+    api "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}"
     annotationProcessor project(':annotation:compiler')
 
-    testCompile project(":testutil")
-    testCompile "com.google.truth:truth:${TRUTH_VERSION}"
-    testCompile "junit:junit:${JUNIT_VERSION}"
-    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}"
-    testCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
-    testCompile "com.squareup.okhttp3:mockwebserver:${MOCKWEBSERVER_VERSION}"
+    testImplementation project(":testutil")
+    testImplementation "com.google.truth:truth:${TRUTH_VERSION}"
+    testImplementation "junit:junit:${JUNIT_VERSION}"
+    testImplementation "org.mockito:mockito-core:${MOCKITO_VERSION}"
+    testImplementation "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
+    testImplementation "com.squareup.okhttp3:mockwebserver:${MOCKWEBSERVER_VERSION}"
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         minSdkVersion MIN_SDK_VERSION as int
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java
index 52899e89a..5756c6172 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.integration.volley;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
@@ -22,7 +23,7 @@
 @SuppressWarnings("deprecation")
 public class VolleyGlideModule implements com.bumptech.glide.module.GlideModule {
   @Override
-  public void applyOptions(Context context, GlideBuilder builder) {
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
     // Do nothing.
   }
 
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyLibraryGlideModule.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyLibraryGlideModule.java
index 6fa56468c..514c62008 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyLibraryGlideModule.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyLibraryGlideModule.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.integration.volley;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.Registry;
 import com.bumptech.glide.annotation.GlideModule;
@@ -21,7 +22,8 @@
 @GlideModule
 public class VolleyLibraryGlideModule extends LibraryGlideModule {
   @Override
-  public void registerComponents(Context context, Glide glide, Registry registry) {
+  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry) {
     registry.replace(GlideUrl.class, InputStream.class, new VolleyUrlLoader.Factory(context));
   }
 }
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java
index 3a4e17415..97348ecc6 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java
@@ -2,7 +2,6 @@
 
 import android.support.annotation.NonNull;
 import android.util.Log;
-import com.android.volley.AuthFailureError;
 import com.android.volley.NetworkResponse;
 import com.android.volley.Request;
 import com.android.volley.RequestQueue;
@@ -21,6 +20,8 @@
 /**
  * A DataFetcher backed by volley for fetching images via http.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public class VolleyStreamFetcher implements DataFetcher<InputStream> {
   private static final String TAG = "VolleyStreamFetcher";
   public static final VolleyRequestFactory DEFAULT_REQUEST_FACTORY = new VolleyRequestFactory() {
@@ -49,7 +50,8 @@ public VolleyStreamFetcher(RequestQueue requestQueue, GlideUrl url,
   }
 
   @Override
-  public void loadData(Priority priority, DataCallback<? super InputStream> callback) {
+  public void loadData(@NonNull Priority priority,
+      @NonNull DataCallback<? super InputStream> callback) {
     request = requestFactory.create(url.toStringUrl(), callback, glideToVolleyPriority(priority),
         url.getHeaders());
     requestQueue.add(request);
@@ -80,7 +82,7 @@ public DataSource getDataSource() {
     return DataSource.REMOTE;
   }
 
-  private static Request.Priority glideToVolleyPriority(Priority priority) {
+  private static Request.Priority glideToVolleyPriority(@NonNull Priority priority) {
     switch (priority) {
       case LOW:
         return Request.Priority.LOW;
@@ -97,6 +99,8 @@ public DataSource getDataSource() {
    * Default {@link com.android.volley.Request} implementation for Glide that receives errors and
    * results on volley's background thread.
    */
+  // Public API.
+  @SuppressWarnings("unused")
   public static class GlideRequest extends Request<byte[]> {
     private final DataCallback<? super InputStream> callback;
     private final Priority priority;
@@ -115,7 +119,7 @@ public GlideRequest(String url, DataCallback<? super InputStream> callback, Prio
     }
 
     @Override
-    public Map<String, String> getHeaders() throws AuthFailureError {
+    public Map<String, String> getHeaders() {
       return headers;
     }
 
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java
index 02c3c0921..a5ceda30a 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.integration.volley;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import com.android.volley.RequestQueue;
 import com.android.volley.toolbox.Volley;
 import com.bumptech.glide.load.Options;
@@ -18,29 +19,35 @@
   private final RequestQueue requestQueue;
   private final VolleyRequestFactory requestFactory;
 
+  // Public API.
+  @SuppressWarnings("unused")
   public VolleyUrlLoader(RequestQueue requestQueue) {
     this(requestQueue, VolleyStreamFetcher.DEFAULT_REQUEST_FACTORY);
   }
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public VolleyUrlLoader(RequestQueue requestQueue, VolleyRequestFactory requestFactory) {
     this.requestQueue = requestQueue;
     this.requestFactory = requestFactory;
   }
 
   @Override
-  public boolean handles(GlideUrl url) {
+  public boolean handles(@NonNull GlideUrl url) {
     return true;
   }
 
   @Override
-  public LoadData<InputStream> buildLoadData(GlideUrl url, int width, int height,
-      Options options) {
+  public LoadData<InputStream> buildLoadData(@NonNull GlideUrl url, int width, int height,
+      @NonNull Options options) {
     return new LoadData<>(url, new VolleyStreamFetcher(requestQueue, url, requestFactory));
   }
 
   /**
    * The default factory for {@link VolleyUrlLoader}s.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public static class Factory implements ModelLoaderFactory<GlideUrl, InputStream> {
     private static volatile RequestQueue internalQueue;
 
@@ -70,6 +77,7 @@ public Factory(RequestQueue requestQueue, VolleyRequestFactory requestFactory) {
       this.requestQueue = requestQueue;
     }
 
+    @NonNull
     @Override
     public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory factory) {
       return new VolleyUrlLoader(requestQueue, requestFactory);
diff --git a/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java
index b1271b9a2..740acc113 100644
--- a/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java
+++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java
@@ -51,8 +51,7 @@
 public class VolleyStreamFetcherServerTest {
   private static final String DEFAULT_PATH = "/fakepath";
 
-  @Mock VolleyRequestFactory requestFactory;
-  @Mock DataFetcher.DataCallback<InputStream> callback;
+  @Mock private DataFetcher.DataCallback<InputStream> callback;
 
   private MockWebServer mockWebServer;
   private RequestQueue requestQueue;
diff --git a/library/build.gradle b/library/build.gradle
index 52b79d6af..a47b7173b 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -1,62 +1,32 @@
 apply plugin: 'com.android.library'
-apply plugin: 'maven'
-apply plugin: 'findbugs'
-apply plugin: 'pmd'
-apply plugin: 'jacoco'
-apply plugin: 'com.github.kt3k.coveralls'
 
-findbugs {
-    toolVersion = FINDBUGS_VERSION
+if (!hasProperty('DISABLE_ERROR_PRONE')) {
+    apply plugin: "net.ltgt.errorprone"
 }
-jacoco {
-    toolVersion = JACOCO_VERSION
-}
-coveralls {
-    jacocoReportPath = 'build/reports/jacoco/jacocoTestReport/jacocoTestReport.xml'
+
+tasks.withType(JavaCompile) {
+    options.fork = true
 }
 
 dependencies {
-    compile project(':third_party:gif_decoder')
-    compile project(':third_party:disklrucache')
-    compile project(':annotation')
-    provided "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
-    provided "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}"
-    testCompile project(':testutil')
-    testCompile 'com.google.guava:guava-testlib:18.0'
-    testCompile "com.google.truth:truth:${TRUTH_VERSION}"
-    testCompile "junit:junit:${JUNIT_VERSION}"
-    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}"
-    testCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
-    testCompile "com.squareup.okhttp3:mockwebserver:${MOCKWEBSERVER_VERSION}"
-    testCompile "com.android.support:support-v4:${ANDROID_SUPPORT_VERSION}"
-}
+    api project(':third_party:gif_decoder')
+    api project(':third_party:disklrucache')
+    api project(':annotation')
+    api "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
+    compileOnly "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}"
 
-android.testOptions.unitTests.all {
-    // configure max heap size of the test JVM
-    maxHeapSize = '2048m'
-    if (JavaVersion.current() <= JavaVersion.VERSION_1_7) {
-        // Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize=2048m; support was removed in 8.0
-        jvmArgs '-XX:MaxPermSize=2048m'
+    if (project.plugins.hasPlugin('net.ltgt.errorprone')) {
+        errorprone "com.google.errorprone:error_prone_core:${ERROR_PRONE_VERSION}"
     }
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
-
         versionName VERSION_NAME as String
-
-        consumerProguardFiles 'proguard-rules.txt'
-    }
-
-    buildTypes {
-        debug {
-            testCoverageEnabled = true
-        }
     }
 
     compileOptions {
@@ -65,92 +35,18 @@ android {
     }
 }
 
-afterEvaluate {
-    if (tasks.findByName("assembleDebug") == null) {
-        return
-    }
-
-    task findbugs(type: FindBugs, dependsOn: assembleDebug) {
-
-        description 'Run findbugs'
-        group 'verification'
-
-        classes = fileTree('build/intermediates/classes/debug/')
-        source = fileTree('src/main/java')
-        classpath = project.configurations.compile
-
-        effort = 'max'
-
-        excludeFilter = file("findbugs-exclude.xml")
-
-        reports {
-            xml.enabled = false
-            html.enabled = true
-        }
-    }
-
-    check.dependsOn('findbugs')
-
-    pmd {
-        toolVersion '5.4.0'
-    }
-
-    task pmd(type: Pmd) {
-        targetJdk = TargetJdk.VERSION_1_7
-
-        description 'Run pmd'
-        group 'verification'
-
-        // If ruleSets is not empty, it seems to contain some
-        // defaults which override rules in the ruleset file...
-        ruleSets = []
-        ruleSetFiles = files('pmd-ruleset.xml')
-        source = fileTree('src/main/java')
-
-        reports {
-            xml.enabled = false
-            html.enabled = true
-        }
-    }
+check.dependsOn(':library:findbugs:findbugs')
+check.dependsOn(':library:pmd:pmd')
+check.dependsOn(':library:test:check')
 
-    check.dependsOn('pmd')
-
-    task jacocoTestReport(type: JacocoReport, dependsOn: testDebugUnitTest) {
-        def coverageSourceDirs = ['src/main/java']
-        group = "Reporting"
-        description = "Generate Jacoco coverage reports"
-
-        classDirectories = fileTree(
-                dir: 'build/intermediates/classes/debug',
-                excludes: ['**/R.class',
-                           '**/R$*.class',
-                           '**/BuildConfig.*',
-                           '**/Manifest*.*',
-                           '**/BitmapRequestBuilder.class',
-                           '**/DrawableRequestBuilder.class',
-                           '**/GifRequestBuilder.class',]
-        )
-
-        additionalSourceDirs = files(coverageSourceDirs)
-        sourceDirectories = files(coverageSourceDirs)
-        executionData = files('build/jacoco/testDebug.exec')
-
-        reports {
-            xml.enabled = true
-            html.enabled = true
-        }
-    }
+// Used in pmd and findbugs subprojects.
+@SuppressWarnings("GroovyUnusedDeclaration")
+def classPathForQuality() {
+    return files(
+            android.bootClasspath,
+            project.configurations.compile,
+            project.android.libraryVariants.collect { it.javaCompile.classpath }
+    )
 }
 
 apply from: "${rootProject.projectDir}/scripts/upload.gradle"
-// exclude <dependency> tag for android support-v4 library from :glide's pom
-// this will ensure that this warning will not prevent the build from completing:
-// Module 'com.github.bumptech.glide:glide:4.0.0-SNAPSHOT' depends on one or more Android Libraries
-// but is a jar. Most users will need to override support-v4 version anyway if a newer version is
-// available
-// TODO make support-v4 a <scope>runtime</scope> dependency in pom.xml
-afterEvaluate {
-    uploadArchives.repositories.mavenDeployer.pom.whenConfigured { p ->
-        p.dependencies = p.dependencies.findAll { dep -> dep.artifactId != "support-v4" }
-    }
-}
diff --git a/library/findbugs-exclude.xml b/library/findbugs-exclude.xml
index e9defbbe7..bd1e9afd3 100644
--- a/library/findbugs-exclude.xml
+++ b/library/findbugs-exclude.xml
@@ -38,8 +38,14 @@
 
     <!-- We make a best effort attempt to acquire the cpu count from a fixed path -->
     <Match>
-      <Class name="com.bumptech.glide.load.engine.executor.GlideExecutor" />
+      <Class name="com.bumptech.glide.load.engine.executor.RuntimeCompat" />
       <Bug pattern="DMI_HARDCODED_ABSOLUTE_FILENAME" />
     </Match>
 
+    <!-- Re-using the byte array saves allocations, there's no serious risk of mutations. -->
+    <Match>
+      <Class name="com.bumptech.glide.util.FixedPreloadSizeProvider" />
+      <Bug pattern="EI_EXPOSE_REP" />
+    </Match>
+
 </FindBugsFilter>
diff --git a/library/findbugs/build.gradle b/library/findbugs/build.gradle
new file mode 100644
index 000000000..a2e5b3f2a
--- /dev/null
+++ b/library/findbugs/build.gradle
@@ -0,0 +1,31 @@
+apply plugin: 'findbugs'
+
+findbugs {
+    toolVersion FINDBUGS_VERSION
+}
+
+def library = project(':library')
+
+tasks.create('findbugs', FindBugs) {
+    dependsOn library.tasks.compileDebugJavaWithJavac
+
+    description 'Run findbugs'
+    group 'verification'
+
+    classes = fileTree(library.tasks.compileDebugJavaWithJavac.destinationDir)
+    source library.android.sourceSets.main.java.srcDirs
+    classpath = files()
+    doFirst {
+        classpath += library.classPathForQuality()
+    }
+    effort = 'max'
+    excludeFilter = file("${library.projectDir}/findbugs-exclude.xml")
+
+    // Failures are caught and printed by the violations plugin.
+    ignoreFailures = true
+
+    reports {
+        xml.enabled = true
+        html.enabled = false
+    }
+}
diff --git a/library/lint.xml b/library/lint.xml
index 869eb6598..c6cf01b20 100644
--- a/library/lint.xml
+++ b/library/lint.xml
@@ -1,6 +1,5 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <lint>
     <issue id="AllowBackup" severity="ignore"/>
-    <!-- TODO: Fix this after RequestManager#get(View) uses official APIs -->
-    <issue id="RestrictedApi" severity="ignore"/>
+    <issue id="ExifInterface" severity="ignore"/>
 </lint>
diff --git a/library/pmd-ruleset.xml b/library/pmd-ruleset.xml
index 76249e191..8297a5c09 100644
--- a/library/pmd-ruleset.xml
+++ b/library/pmd-ruleset.xml
@@ -3,56 +3,168 @@
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 http://pmd.sourceforge.net/ruleset_2_0_0.xsd">
 
-    <description>This ruleset was created from PMD.rul</description>
+    <description>Check for flaws in Glide's codebase.</description>
 
-    <rule ref="rulesets/java/basic.xml">
+    <rule ref="category/java/errorprone.xml">
         <exclude name="AvoidBranchingStatementAsLastInLoop"/>
+        <!-- Not using beans. -->
+        <exclude name="BeanMembersShouldSerialize" />
+        <!-- wat -->
+        <exclude name="AvoidFieldNameMatchingTypeName" />
+        <!-- This is identifying trivial cases that are clearly correct. -->
+        <exclude name="DataflowAnomalyAnalysis" />
+        <!-- Used regularly for object pooling. -->
+        <exclude name="NullAssignment" />
+        <!-- This can make the code easier to read and avoid duplicated logic in some cases. -->
+        <exclude name="AssignmentInOperand" />
+        <!-- I don't think this is confusing. -->
+        <exclude name="AvoidFieldNameMatchingMethodName" />
+        <!-- There are enough cases where this makes sense (typically related to logic around the number of items in a collection) that a blanket ban doesn't seem like a good idea. -->
+        <exclude name="AvoidLiteralsInIfCondition" />
+        <!-- It's clear that this is bad, but we have a number of cases where it makes sense and a blanket ban is irritating. -->
+        <exclude name="AvoidCatchingThrowable" />
     </rule>
-    <rule ref="rulesets/java/braces.xml"/>
-    <rule ref="rulesets/java/strings.xml">
-        <!-- TODO: This warns about annotations, apparently fixed in a later version. -->
-        <exclude name="AvoidDuplicateLiterals"/>
+    <rule ref="category/java/errorprone.xml/AvoidDuplicateLiterals">
+      <properties>
+        <property name="skipAnnotations" value="true" />
+      </properties>
+    </rule>
+    <rule ref="category/java/codestyle.xml">
+      <!-- Abstract classes don't need to have Abstract in the name -->
+      <exclude name="AbstractNaming" />
+      <!-- Who cares? -->
+      <exclude name="AtLeastOneConstructor" />
+      <!-- Don't need to annotate package private methods. -->
+      <exclude name="DefaultPackage" />
+      <exclude name="CommentDefaultAccessModifier" />
+      <!-- Optionally implemented default empty methods are fine. -->
+      <exclude name="EmptyMethodInAbstractClassShouldBeAbstract" />
+      <!-- Why make generics less clear by using shorter names? -->
+      <exclude name="GenericsNaming" />
+      <!-- No need to enforce final if it's not necessary. -->
+      <exclude name="MethodArgumentCouldBeFinal" />
+      <exclude name="LocalVariableCouldBeFinal" />
+      <!-- This isn't always the easiest way to read a method. -->
+      <exclude name="OnlyOneReturn" />
+      <!-- Obfuscated code is best code? -->
+      <exclude name="LongVariable" />
+      <!-- This is not always true. -->
+      <exclude name="ShortClassName" />
+      <!-- A good idea but we have tons of violations. FIXME. -->
+      <exclude name="ShortMethodName" />
+      <exclude name="ShortVariable" />
+      <!-- We don't use in and out to mean modified or not modified by the method, it's useful to match framework methods. -->
+      <exclude name="AvoidPrefixingMethodParameters" />
+      <!-- No idea what this is supposed to accomplish. -->
+      <exclude name="AvoidFinalLocalVariable" />
+      <!-- These are often useful for clarity and explicitly suggested by Google's code style. -->
+      <exclude name="UselessParentheses" />
+      <!-- Theoretically this might be reasonable but the number of imports probably varies from class to class and this doesn't seem worth the overhead to maintain. -->
+      <exclude name="TooManyStaticImports" />
+      <!-- Lots of existing violations, not clear that the overhead is worthwhile though there are some cases where we definitely need to call super. FIXME. -->
+      <exclude name="CallSuperInConstructor" />
+      <!-- This is a reasonable idea, but in practice often the != null case is the expected case and it makes sense for it to come first. -->
+      <exclude name="ConfusingTernary" />
+    </rule>
+    <rule ref="category/java/performance.xml" >
+      <!-- Android may not behave the same as java VMs, using short can be clearer when working with binary data. -->
+      <exclude name="AvoidUsingShortType" />
+      <!-- The suggsted alternatives are not available until Glide's minsdk level is 26+ -->
+      <exclude name="AvoidFileStream" />
+    </rule>
+    <rule ref="category/java/bestpractices.xml" >
+      <!-- Catches any method, test or not, that has the name "tearDown". -->
+      <exclude name="JUnit4TestShouldUseAfterAnnotation" />
+      <!-- This is a good idea, but in practice it's often somewhat clearer than defining a temporary variable and we do it all over the place. -->
+      <exclude name="AvoidReassigningParameters" />
+      <!-- This ignores imports used by javadocs and is worse than the existing checkstyle check. -->
+      <exclude name="UnusedImports" />
+    </rule>
+    <rule ref="category/java/bestpractices.xml/OneDeclarationPerLine">
+      <properties>
+        <property name="strictMode" value="true" />
+        <!-- Allow `for (int i = 0, size = list.size(); i < size; i++) {`
+             Somewhat clearer to set size along with the index. -->
+        <property name="violationSuppressXPath"
+                  value="self::LocalVariableDeclaration
+                           [parent::ForInit]
+                           [Type/PrimitiveType[@Image = 'int']
+                             and VariableDeclarator/VariableDeclaratorId[@Image='i']
+                             and VariableDeclarator/VariableDeclaratorId[@Image='size']
+                           ]
+                        " />
+      </properties>
+    </rule>
+    <rule ref="category/java/bestpractices.xml/AccessorMethodGeneration"
+      message="Avoid autogenerated methods to access private fields and methods of inner / outer classes.
+                       Use @Synthetic to flag members made more visible than necessary to prevent accessors.">
+      <properties>
+        <!-- Ignore references to `private static final * * = <literal>`
+             Suppress via XPath: current node (access that generates the accessor) is .
+             Check if there exists a FieldDeclaration (private static final)
+             which has a VariableInitializer with a Literal
+             and the name (@Image) of the declaration is the same as the accessed member.
+             TODO calculated constants are false positive https://github.com/pmd/pmd/issues/808
+        -->
+        <property name="violationSuppressXPath" value="
+                .[@Image =
+                    //FieldDeclaration[@Private = 'true' and @Static='true' and @Final='true']
+                    /VariableDeclarator[
+                        VariableInitializer/Expression/PrimaryExpression[not(PrimarySuffix)]/PrimaryPrefix/Literal
+                    ]/VariableDeclaratorId/@Image
+                 ]" />
+      </properties>
     </rule>
-    <rule ref="rulesets/java/unusedcode.xml"/>
 
-    <rule ref="rulesets/java/design.xml">
-        <exclude name="ConfusingTernary"/>
-        <exclude name="EmptyMethodInAbstractClassShouldBeAbstract"/>
-        <exclude name="AvoidSynchronizedAtMethodLevel"/>
+    <rule ref="category/java/design.xml">
+        <exclude name="GodClass" />
+        <!-- No idea how you reasonably define this. -->
+        <exclude name="ExcessiveImports" />
+        <exclude name="CouplingBetweenObjects" />
+        <exclude name="TooManyMethods" />
+        <exclude name="LawOfDemeter" />
+        <exclude name="NcssCount" />
+        <exclude name="ExcessiveParameterList" />
+        <exclude name="TooManyFields" />
+        <!-- We don't define any packages to use with this rule. -->
+        <exclude name="LoosePackageCoupling" />
+        <!-- Throwing other types of exceptions doesn't seem to add much to clarify. -->
+        <exclude name="AvoidThrowingRawExceptionTypes" />
+        <exclude name="AvoidThrowingNullPointerException" />
+        <!-- TODO: explore these further. -->
+        <exclude name="CyclomaticComplexity" />
+        <exclude name="NPathComplexity" />
+        <exclude name="ExcessiveMethodLength" />
+        <exclude name="ExcessiveClassLength" />
+        <exclude name="ExcessivePublicCount" />
+        <!-- This is redundant, also caught with AvoidCatchingNPEs. -->
+        <exclude name="AvoidCatchingGenericException" />
+    </rule>
 
+    <rule ref="category/java/multithreading.xml">
+        <exclude name="AvoidSynchronizedAtMethodLevel"/>
         <!-- This check breaks on double checked locking which is safe in Java 6/7 -->
         <exclude name="NonThreadSafeSingleton"/>
-
-        <!-- TODO: Fix these -->
-        <exclude name="AvoidReassigningParameters"/>
-        <exclude name="GodClass"/>
+        <!-- Used frequently in the singleton pattern. -->
+        <exclude name="AvoidUsingVolatile" />
+        <!-- No reason to do this by default. -->
+        <exclude name="UseConcurrentHashMap" />
+        <exclude name="DoNotUseThreads" />
     </rule>
 
-    <rule ref="rulesets/java/empty.xml/EmptyCatchBlock" message="Commented blocks are ok">
+    <rule ref="category/java/errorprone.xml/EmptyCatchBlock" message="Commented blocks are ok">
         <properties>
             <property name="allowCommentedBlocks" value="true"/>
         </properties>
     </rule>
 
 
-    <!--Overrides default check to avoid violation when @Synthetic annotation is present-->
-    <rule ref="rulesets/java/design.xml/UncommentedEmptyConstructor"
-          message="Document empty constructor">
-
-        <properties>
-            <property name="xpath">
-                <value>
-                    <![CDATA[
-//ConstructorDeclaration[@Private='false'][count(BlockStatement) = 0 and
-($ignoreExplicitConstructorInvocation = 'true' or not(ExplicitConstructorInvocation)) and @containsComment = 'false'
- and not(../Annotation/MarkerAnnotation/Name[@Image='Synthetic'])]
- ]]>
-                </value>
-            </property>
-
-        </properties>
-
+  <!-- Configures check to avoid violation when @Synthetic annotation is present. -->
+    <rule ref="category/java/documentation.xml/UncommentedEmptyConstructor">
+      <properties>
+        <property name="violationSuppressXPath"
+          value="../Annotation/MarkerAnnotation/Name[@Image='Synthetic']" />
+      </properties>
     </rule>
 
-
 </ruleset>
diff --git a/library/pmd/build.gradle b/library/pmd/build.gradle
new file mode 100644
index 000000000..d02349082
--- /dev/null
+++ b/library/pmd/build.gradle
@@ -0,0 +1,39 @@
+apply plugin: 'pmd'
+
+def library = project(':library')
+
+pmd {
+    toolVersion PMD_VERSION
+}
+
+tasks.create('pmd', Pmd) {
+    dependsOn library.tasks.compileDebugJavaWithJavac
+    targetJdk = TargetJdk.VERSION_1_7
+
+    description 'Run pmd'
+    group 'verification'
+
+    // If ruleSets is not empty, it seems to contain some
+    // defaults which override rules in the ruleset file...
+    ruleSets = []
+    ruleSetFiles = files("${library.projectDir}/pmd-ruleset.xml")
+    source library.android.sourceSets.main.java.srcDirs
+    classpath = files()
+    classpath += files(library.tasks.compileDebugJavaWithJavac.destinationDir)
+    doFirst {
+        classpath += library.classPathForQuality()
+    }
+
+    //TODO enable this once new Gradle containing this flag is out
+    //see https://github.com/gradle/gradle/pull/3125#issuecomment-352442432
+    //incrementalAnalysis = true
+
+    // Failures are caught and printed by the violations plugin.
+    ignoreFailures = true
+
+    reports {
+        xml.enabled = true
+        html.enabled = false
+    }
+}
+
diff --git a/library/proguard-rules.txt b/library/proguard-rules.txt
index 078afb542..bfb14d052 100644
--- a/library/proguard-rules.txt
+++ b/library/proguard-rules.txt
@@ -1,6 +1,9 @@
 -keep public class * implements com.bumptech.glide.module.GlideModule
--keep public class * extends com.bumptech.glide.GeneratedAppGlideModule
+-keep public class * extends com.bumptech.glide.module.AppGlideModule
 -keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {
-    **[] $VALUES;
-    public *;
-}
\ No newline at end of file
+  **[] $VALUES;
+  public *;
+}
+
+# Uncomment for DexGuard only
+#-keepresourcexmlelements manifest/application/meta-data@value=GlideModule
\ No newline at end of file
diff --git a/library/src/main/AndroidManifest.xml b/library/src/main/AndroidManifest.xml
index 06f5c692a..2e0f06b5f 100644
--- a/library/src/main/AndroidManifest.xml
+++ b/library/src/main/AndroidManifest.xml
@@ -1,6 +1,5 @@
 <?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-          package="com.bumptech.glide">
+<manifest package="com.bumptech.glide">
 
     <application/>
 </manifest>
diff --git a/library/src/main/java/com/bumptech/glide/GeneratedAppGlideModule.java b/library/src/main/java/com/bumptech/glide/GeneratedAppGlideModule.java
index 853990ec2..5f480de80 100644
--- a/library/src/main/java/com/bumptech/glide/GeneratedAppGlideModule.java
+++ b/library/src/main/java/com/bumptech/glide/GeneratedAppGlideModule.java
@@ -16,7 +16,6 @@
   /**
    * This method can be removed when manifest parsing is no longer supported.
    */
-  @Deprecated
   @NonNull
   abstract Set<Class<?>> getExcludedModuleClasses();
 
diff --git a/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java b/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java
index 1fe9588f5..a630b4f86 100644
--- a/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java
+++ b/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.request.transition.TransitionFactory;
 import com.bumptech.glide.request.transition.ViewPropertyTransition;
 
@@ -9,7 +10,8 @@
  *
  * @param <TranscodeType> The type of the resource that will be displayed.
  */
-@SuppressWarnings("PMD.UseUtilityClass")
+// Public API.
+@SuppressWarnings({"PMD.UseUtilityClass", "unused"})
 public final class GenericTransitionOptions<TranscodeType> extends
     TransitionOptions<GenericTransitionOptions<TranscodeType>, TranscodeType> {
   /**
@@ -17,6 +19,7 @@
    *
    * @see GenericTransitionOptions#dontTransition()
    */
+  @NonNull
   public static <TranscodeType> GenericTransitionOptions<TranscodeType> withNoTransition() {
     return new GenericTransitionOptions<TranscodeType>().dontTransition();
   }
@@ -26,6 +29,7 @@
    *
    * @see GenericTransitionOptions#transition(int)
    */
+  @NonNull
   public static <TranscodeType> GenericTransitionOptions<TranscodeType> with(
       int viewAnimationId) {
     return new GenericTransitionOptions<TranscodeType>().transition(viewAnimationId);
@@ -36,8 +40,9 @@
    *
    * @see GenericTransitionOptions#transition(ViewPropertyTransition.Animator)
    */
+  @NonNull
   public static <TranscodeType> GenericTransitionOptions<TranscodeType> with(
-      ViewPropertyTransition.Animator animator) {
+      @NonNull ViewPropertyTransition.Animator animator) {
     return new GenericTransitionOptions<TranscodeType>().transition(animator);
   }
 
@@ -46,8 +51,9 @@
    *
    * @see GenericTransitionOptions#transition(TransitionFactory)
    */
+  @NonNull
   public static <TranscodeType> GenericTransitionOptions<TranscodeType> with(
-      TransitionFactory<? super TranscodeType> transitionFactory) {
+      @NonNull TransitionFactory<? super TranscodeType> transitionFactory) {
     return new GenericTransitionOptions<TranscodeType>().transition(transitionFactory);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/Glide.java b/library/src/main/java/com/bumptech/glide/Glide.java
index 0227e4131..c7f7e4562 100644
--- a/library/src/main/java/com/bumptech/glide/Glide.java
+++ b/library/src/main/java/com/bumptech/glide/Glide.java
@@ -1,16 +1,18 @@
 package com.bumptech.glide;
 
-import android.annotation.TargetApi;
 import android.app.Activity;
 import android.content.ComponentCallbacks2;
+import android.content.ContentResolver;
 import android.content.Context;
+import android.content.res.AssetFileDescriptor;
 import android.content.res.Configuration;
 import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
 import android.net.Uri;
-import android.os.Build;
 import android.os.ParcelFileDescriptor;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.support.annotation.VisibleForTesting;
 import android.support.v4.app.Fragment;
@@ -19,6 +21,7 @@
 import android.view.View;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.data.InputStreamRewinder;
 import com.bumptech.glide.load.engine.Engine;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
@@ -51,9 +54,13 @@
 import com.bumptech.glide.load.resource.bitmap.ByteBufferBitmapDecoder;
 import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;
 import com.bumptech.glide.load.resource.bitmap.Downsampler;
+import com.bumptech.glide.load.resource.bitmap.ResourceBitmapDecoder;
 import com.bumptech.glide.load.resource.bitmap.StreamBitmapDecoder;
-import com.bumptech.glide.load.resource.bitmap.VideoBitmapDecoder;
+import com.bumptech.glide.load.resource.bitmap.UnitBitmapDecoder;
+import com.bumptech.glide.load.resource.bitmap.VideoDecoder;
 import com.bumptech.glide.load.resource.bytes.ByteBufferRewinder;
+import com.bumptech.glide.load.resource.drawable.ResourceDrawableDecoder;
+import com.bumptech.glide.load.resource.drawable.UnitDrawableDecoder;
 import com.bumptech.glide.load.resource.file.FileDecoder;
 import com.bumptech.glide.load.resource.gif.ByteBufferGifDecoder;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
@@ -62,10 +69,10 @@
 import com.bumptech.glide.load.resource.gif.StreamGifDecoder;
 import com.bumptech.glide.load.resource.transcode.BitmapBytesTranscoder;
 import com.bumptech.glide.load.resource.transcode.BitmapDrawableTranscoder;
+import com.bumptech.glide.load.resource.transcode.DrawableBytesTranscoder;
 import com.bumptech.glide.load.resource.transcode.GifDrawableBytesTranscoder;
 import com.bumptech.glide.manager.ConnectivityMonitorFactory;
 import com.bumptech.glide.manager.RequestManagerRetriever;
-import com.bumptech.glide.module.GlideModule;
 import com.bumptech.glide.module.ManifestParser;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.ImageViewTargetFactory;
@@ -74,6 +81,7 @@
 import com.bumptech.glide.util.Util;
 import java.io.File;
 import java.io.InputStream;
+import java.lang.reflect.InvocationTargetException;
 import java.net.URL;
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
@@ -88,7 +96,6 @@
  * {@link RequestBuilder} and maintaining an {@link Engine}, {@link BitmapPool},
  * {@link com.bumptech.glide.load.engine.cache.DiskCache} and {@link MemoryCache}.
  */
-@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
 public class Glide implements ComponentCallbacks2 {
   private static final String DEFAULT_DISK_CACHE_DIR = "image_manager_disk_cache";
   private static final String TAG = "Glide";
@@ -115,7 +122,7 @@
    * @see #getPhotoCacheDir(android.content.Context, String)
    */
   @Nullable
-  public static File getPhotoCacheDir(Context context) {
+  public static File getPhotoCacheDir(@NonNull Context context) {
     return getPhotoCacheDir(context, DEFAULT_DISK_CACHE_DIR);
   }
 
@@ -128,7 +135,7 @@ public static File getPhotoCacheDir(Context context) {
    * @see #getPhotoCacheDir(android.content.Context)
    */
   @Nullable
-  public static File getPhotoCacheDir(Context context, String cacheName) {
+  public static File getPhotoCacheDir(@NonNull Context context, @NonNull String cacheName) {
     File cacheDir = context.getCacheDir();
     if (cacheDir != null) {
       File result = new File(cacheDir, cacheName);
@@ -149,7 +156,8 @@ public static File getPhotoCacheDir(Context context, String cacheName) {
    *
    * @return the singleton
    */
-  public static Glide get(Context context) {
+  @NonNull
+  public static Glide get(@NonNull Context context) {
     if (glide == null) {
       synchronized (Glide.class) {
         if (glide == null) {
@@ -161,7 +169,7 @@ public static Glide get(Context context) {
     return glide;
   }
 
-  private static void checkAndInitializeGlide(Context context) {
+  private static void checkAndInitializeGlide(@NonNull Context context) {
     // In the thread running initGlide(), one or more classes may call Glide.get(context).
     // Without this check, those calls could trigger infinite recursion.
     if (isInitializing) {
@@ -173,22 +181,49 @@ private static void checkAndInitializeGlide(Context context) {
     isInitializing = false;
   }
 
+  /**
+   * @deprecated Use {@link #init(Context, GlideBuilder)} to get a singleton compatible with
+   * Glide's generated API.
+   *
+   * <p>This method will be removed in a future version of Glide.
+   */
   @VisibleForTesting
+  @Deprecated
   public static synchronized void init(Glide glide) {
+    if (Glide.glide != null) {
+      tearDown();
+    }
     Glide.glide = glide;
   }
 
+  @VisibleForTesting
+  public static synchronized void init(@NonNull Context context, @NonNull GlideBuilder builder) {
+    if (Glide.glide != null) {
+      tearDown();
+    }
+    initializeGlide(context, builder);
+  }
+
   @VisibleForTesting
   public static synchronized void tearDown() {
+    if (glide != null) {
+      glide.getContext()
+          .getApplicationContext()
+          .unregisterComponentCallbacks(glide);
+      glide.engine.shutdown();
+    }
     glide = null;
   }
 
+  private static void initializeGlide(@NonNull Context context) {
+    initializeGlide(context, new GlideBuilder());
+  }
+
   @SuppressWarnings("deprecation")
-  private static void initializeGlide(Context context) {
+  private static void initializeGlide(@NonNull Context context, @NonNull GlideBuilder builder) {
     Context applicationContext = context.getApplicationContext();
-
     GeneratedAppGlideModule annotationGeneratedModule = getAnnotationGeneratedGlideModules();
-    List<GlideModule> manifestModules = Collections.emptyList();
+    List<com.bumptech.glide.module.GlideModule> manifestModules = Collections.emptyList();
     if (annotationGeneratedModule == null || annotationGeneratedModule.isManifestParsingEnabled()) {
       manifestModules = new ManifestParser(applicationContext).parse();
     }
@@ -197,8 +232,9 @@ private static void initializeGlide(Context context) {
         && !annotationGeneratedModule.getExcludedModuleClasses().isEmpty()) {
       Set<Class<?>> excludedModuleClasses =
           annotationGeneratedModule.getExcludedModuleClasses();
-      for (Iterator<GlideModule> iterator = manifestModules.iterator(); iterator.hasNext();) {
-        GlideModule current = iterator.next();
+      Iterator<com.bumptech.glide.module.GlideModule> iterator = manifestModules.iterator();
+      while (iterator.hasNext()) {
+        com.bumptech.glide.module.GlideModule current = iterator.next();
         if (!excludedModuleClasses.contains(current.getClass())) {
           continue;
         }
@@ -210,7 +246,7 @@ private static void initializeGlide(Context context) {
     }
 
     if (Log.isLoggable(TAG, Log.DEBUG)) {
-      for (GlideModule glideModule : manifestModules) {
+      for (com.bumptech.glide.module.GlideModule glideModule : manifestModules) {
         Log.d(TAG, "Discovered GlideModule from manifest: " + glideModule.getClass());
       }
     }
@@ -218,22 +254,21 @@ private static void initializeGlide(Context context) {
     RequestManagerRetriever.RequestManagerFactory factory =
         annotationGeneratedModule != null
             ? annotationGeneratedModule.getRequestManagerFactory() : null;
-    GlideBuilder builder = new GlideBuilder()
-        .setRequestManagerFactory(factory);
-    for (GlideModule module : manifestModules) {
+    builder.setRequestManagerFactory(factory);
+    for (com.bumptech.glide.module.GlideModule module : manifestModules) {
       module.applyOptions(applicationContext, builder);
     }
     if (annotationGeneratedModule != null) {
       annotationGeneratedModule.applyOptions(applicationContext, builder);
     }
     Glide glide = builder.build(applicationContext);
-    for (GlideModule module : manifestModules) {
+    for (com.bumptech.glide.module.GlideModule module : manifestModules) {
       module.registerComponents(applicationContext, glide, glide.registry);
     }
     if (annotationGeneratedModule != null) {
       annotationGeneratedModule.registerComponents(applicationContext, glide, glide.registry);
     }
-    context.getApplicationContext().registerComponentCallbacks(glide);
+    applicationContext.registerComponentCallbacks(glide);
     Glide.glide = glide;
   }
 
@@ -245,39 +280,44 @@ private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules() {
       Class<GeneratedAppGlideModule> clazz =
           (Class<GeneratedAppGlideModule>)
               Class.forName("com.bumptech.glide.GeneratedAppGlideModuleImpl");
-      result = clazz.newInstance();
+      result = clazz.getDeclaredConstructor().newInstance();
     } catch (ClassNotFoundException e) {
       if (Log.isLoggable(TAG, Log.WARN)) {
         Log.w(TAG, "Failed to find GeneratedAppGlideModule. You should include an"
-            + " annotationProcessor compile dependency on com.github.bumptech.glide:glide:compiler"
+            + " annotationProcessor compile dependency on com.github.bumptech.glide:compiler"
             + " in your application and a @GlideModule annotated AppGlideModule implementation or"
             + " LibraryGlideModules will be silently ignored");
       }
+    // These exceptions can't be squashed across all versions of Android.
     } catch (InstantiationException e) {
-      throw new IllegalStateException("GeneratedAppGlideModuleImpl is implemented incorrectly."
-          + " If you've manually implemented this class, remove your implementation. The Annotation"
-          + " processor will generate a correct implementation.", e);
-      // These exceptions can't be squashed across all versions of Android.
+      throwIncorrectGlideModule(e);
     } catch (IllegalAccessException e) {
-      throw new IllegalStateException("GeneratedAppGlideModuleImpl is implemented incorrectly."
-          + " If you've manually implemented this class, remove your implementation. The Annotation"
-          + " processor will generate a correct implementation.", e);
+      throwIncorrectGlideModule(e);
+    } catch (NoSuchMethodException e) {
+      throwIncorrectGlideModule(e);
+    } catch (InvocationTargetException e) {
+      throwIncorrectGlideModule(e);
     }
     return result;
   }
 
-  @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+  private static void throwIncorrectGlideModule(Exception e) {
+    throw new IllegalStateException("GeneratedAppGlideModuleImpl is implemented incorrectly."
+        + " If you've manually implemented this class, remove your implementation. The Annotation"
+        + " processor will generate a correct implementation.", e);
+  }
+
   Glide(
-      Context context,
-      Engine engine,
-      MemoryCache memoryCache,
-      BitmapPool bitmapPool,
-      ArrayPool arrayPool,
-      RequestManagerRetriever requestManagerRetriever,
-      ConnectivityMonitorFactory connectivityMonitorFactory,
+      @NonNull Context context,
+      @NonNull Engine engine,
+      @NonNull MemoryCache memoryCache,
+      @NonNull BitmapPool bitmapPool,
+      @NonNull ArrayPool arrayPool,
+      @NonNull RequestManagerRetriever requestManagerRetriever,
+      @NonNull ConnectivityMonitorFactory connectivityMonitorFactory,
       int logLevel,
-      RequestOptions defaultRequestOptions,
-      Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions) {
+      @NonNull RequestOptions defaultRequestOptions,
+      @NonNull Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions) {
     this.engine = engine;
     this.bitmapPool = bitmapPool;
     this.arrayPool = arrayPool;
@@ -297,38 +337,85 @@ private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules() {
         resources.getDisplayMetrics(), bitmapPool, arrayPool);
     ByteBufferGifDecoder byteBufferGifDecoder =
         new ByteBufferGifDecoder(context, registry.getImageHeaderParsers(), bitmapPool, arrayPool);
+    ResourceDecoder<ParcelFileDescriptor, Bitmap> parcelFileDescriptorVideoDecoder =
+        VideoDecoder.parcel(bitmapPool);
+    ByteBufferBitmapDecoder byteBufferBitmapDecoder = new ByteBufferBitmapDecoder(downsampler);
+    StreamBitmapDecoder streamBitmapDecoder = new StreamBitmapDecoder(downsampler, arrayPool);
+    ResourceDrawableDecoder resourceDrawableDecoder =
+        new ResourceDrawableDecoder(context);
+    ResourceLoader.StreamFactory resourceLoaderStreamFactory =
+        new ResourceLoader.StreamFactory(resources);
+    ResourceLoader.UriFactory resourceLoaderUriFactory =
+        new ResourceLoader.UriFactory(resources);
+    ResourceLoader.FileDescriptorFactory resourceLoaderFileDescriptorFactory =
+        new ResourceLoader.FileDescriptorFactory(resources);
+    ResourceLoader.AssetFileDescriptorFactory resourceLoaderAssetFileDescriptorFactory =
+        new ResourceLoader.AssetFileDescriptorFactory(resources);
+    BitmapEncoder bitmapEncoder = new BitmapEncoder(arrayPool);
+
+    BitmapBytesTranscoder bitmapBytesTranscoder = new BitmapBytesTranscoder();
+    GifDrawableBytesTranscoder gifDrawableBytesTranscoder = new GifDrawableBytesTranscoder();
+
+    ContentResolver contentResolver = context.getContentResolver();
 
     registry
         .append(ByteBuffer.class, new ByteBufferEncoder())
         .append(InputStream.class, new StreamEncoder(arrayPool))
         /* Bitmaps */
-        .append(Registry.BUCKET_BITMAP, ByteBuffer.class, Bitmap.class,
-            new ByteBufferBitmapDecoder(downsampler))
-        .append(Registry.BUCKET_BITMAP, InputStream.class, Bitmap.class,
-            new StreamBitmapDecoder(downsampler, arrayPool))
-        .append(Registry.BUCKET_BITMAP, ParcelFileDescriptor.class, Bitmap.class,
-            new VideoBitmapDecoder(bitmapPool))
-        .append(Bitmap.class, new BitmapEncoder())
-        /* GlideBitmapDrawables */
-        .append(Registry.BUCKET_BITMAP_DRAWABLE, ByteBuffer.class, BitmapDrawable.class,
-            new BitmapDrawableDecoder<>(resources, bitmapPool,
-                new ByteBufferBitmapDecoder(downsampler)))
-        .append(Registry.BUCKET_BITMAP_DRAWABLE, InputStream.class, BitmapDrawable.class,
-            new BitmapDrawableDecoder<>(resources, bitmapPool,
-                new StreamBitmapDecoder(downsampler, arrayPool)))
-        .append(Registry.BUCKET_BITMAP_DRAWABLE, ParcelFileDescriptor.class, BitmapDrawable.class,
-            new BitmapDrawableDecoder<>(resources, bitmapPool, new VideoBitmapDecoder(bitmapPool)))
-        .append(BitmapDrawable.class, new BitmapDrawableEncoder(bitmapPool, new BitmapEncoder()))
+        .append(Registry.BUCKET_BITMAP, ByteBuffer.class, Bitmap.class, byteBufferBitmapDecoder)
+        .append(Registry.BUCKET_BITMAP, InputStream.class, Bitmap.class, streamBitmapDecoder)
+        .append(
+            Registry.BUCKET_BITMAP,
+            ParcelFileDescriptor.class,
+            Bitmap.class,
+            parcelFileDescriptorVideoDecoder)
+        .append(
+            Registry.BUCKET_BITMAP,
+            AssetFileDescriptor.class,
+            Bitmap.class,
+            VideoDecoder.asset(bitmapPool))
+        .append(Bitmap.class, Bitmap.class, UnitModelLoader.Factory.<Bitmap>getInstance())
+        .append(
+            Registry.BUCKET_BITMAP, Bitmap.class, Bitmap.class, new UnitBitmapDecoder())
+        .append(Bitmap.class, bitmapEncoder)
+        /* BitmapDrawables */
+        .append(
+            Registry.BUCKET_BITMAP_DRAWABLE,
+            ByteBuffer.class,
+            BitmapDrawable.class,
+            new BitmapDrawableDecoder<>(resources, byteBufferBitmapDecoder))
+        .append(
+            Registry.BUCKET_BITMAP_DRAWABLE,
+            InputStream.class,
+            BitmapDrawable.class,
+            new BitmapDrawableDecoder<>(resources, streamBitmapDecoder))
+        .append(
+            Registry.BUCKET_BITMAP_DRAWABLE,
+            ParcelFileDescriptor.class,
+            BitmapDrawable.class,
+            new BitmapDrawableDecoder<>(resources, parcelFileDescriptorVideoDecoder))
+        .append(BitmapDrawable.class, new BitmapDrawableEncoder(bitmapPool, bitmapEncoder))
         /* GIFs */
-        .append(Registry.BUCKET_GIF, InputStream.class, GifDrawable.class,
+        .append(
+            Registry.BUCKET_GIF,
+            InputStream.class,
+            GifDrawable.class,
             new StreamGifDecoder(registry.getImageHeaderParsers(), byteBufferGifDecoder, arrayPool))
         .append(Registry.BUCKET_GIF, ByteBuffer.class, GifDrawable.class, byteBufferGifDecoder)
         .append(GifDrawable.class, new GifDrawableEncoder())
         /* GIF Frames */
         // Compilation with Gradle requires the type to be specified for UnitModelLoader here.
-        .append(GifDecoder.class, GifDecoder.class, new UnitModelLoader.Factory<GifDecoder>())
-        .append(Registry.BUCKET_BITMAP, GifDecoder.class, Bitmap.class,
+        .append(
+            GifDecoder.class, GifDecoder.class, UnitModelLoader.Factory.<GifDecoder>getInstance())
+        .append(
+            Registry.BUCKET_BITMAP,
+            GifDecoder.class,
+            Bitmap.class,
             new GifFrameResourceDecoder(bitmapPool))
+        /* Drawables */
+        .append(Uri.class, Drawable.class, resourceDrawableDecoder)
+        .append(
+            Uri.class, Bitmap.class, new ResourceBitmapDecoder(resourceDrawableDecoder, bitmapPool))
         /* Files */
         .register(new ByteBufferRewinder.Factory())
         .append(File.class, ByteBuffer.class, new ByteBufferFileLoader.Factory())
@@ -336,53 +423,88 @@ private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules() {
         .append(File.class, File.class, new FileDecoder())
         .append(File.class, ParcelFileDescriptor.class, new FileLoader.FileDescriptorFactory())
         // Compilation with Gradle requires the type to be specified for UnitModelLoader here.
-        .append(File.class, File.class, new UnitModelLoader.Factory<File>())
+        .append(File.class, File.class, UnitModelLoader.Factory.<File>getInstance())
         /* Models */
         .register(new InputStreamRewinder.Factory(arrayPool))
-        .append(int.class, InputStream.class, new ResourceLoader.StreamFactory(resources))
+        .append(int.class, InputStream.class, resourceLoaderStreamFactory)
+        .append(
+            int.class,
+            ParcelFileDescriptor.class,
+            resourceLoaderFileDescriptorFactory)
+        .append(Integer.class, InputStream.class, resourceLoaderStreamFactory)
         .append(
-                int.class,
-                ParcelFileDescriptor.class,
-                new ResourceLoader.FileDescriptorFactory(resources))
-        .append(Integer.class, InputStream.class, new ResourceLoader.StreamFactory(resources))
+            Integer.class,
+            ParcelFileDescriptor.class,
+            resourceLoaderFileDescriptorFactory)
+        .append(Integer.class, Uri.class, resourceLoaderUriFactory)
         .append(
-                Integer.class,
-                ParcelFileDescriptor.class,
-                new ResourceLoader.FileDescriptorFactory(resources))
-        .append(String.class, InputStream.class, new DataUrlLoader.StreamFactory())
+            int.class,
+            AssetFileDescriptor.class,
+            resourceLoaderAssetFileDescriptorFactory)
+        .append(
+            Integer.class,
+            AssetFileDescriptor.class,
+            resourceLoaderAssetFileDescriptorFactory)
+        .append(int.class, Uri.class, resourceLoaderUriFactory)
+        .append(String.class, InputStream.class, new DataUrlLoader.StreamFactory<String>())
+        .append(Uri.class, InputStream.class, new DataUrlLoader.StreamFactory<Uri>())
         .append(String.class, InputStream.class, new StringLoader.StreamFactory())
         .append(String.class, ParcelFileDescriptor.class, new StringLoader.FileDescriptorFactory())
+        .append(
+            String.class, AssetFileDescriptor.class, new StringLoader.AssetFileDescriptorFactory())
         .append(Uri.class, InputStream.class, new HttpUriLoader.Factory())
         .append(Uri.class, InputStream.class, new AssetUriLoader.StreamFactory(context.getAssets()))
         .append(
-                Uri.class,
-                ParcelFileDescriptor.class,
-                new AssetUriLoader.FileDescriptorFactory(context.getAssets()))
+            Uri.class,
+            ParcelFileDescriptor.class,
+            new AssetUriLoader.FileDescriptorFactory(context.getAssets()))
         .append(Uri.class, InputStream.class, new MediaStoreImageThumbLoader.Factory(context))
         .append(Uri.class, InputStream.class, new MediaStoreVideoThumbLoader.Factory(context))
         .append(
             Uri.class,
-             InputStream.class,
-             new UriLoader.StreamFactory(context.getContentResolver()))
-        .append(Uri.class, ParcelFileDescriptor.class,
-             new UriLoader.FileDescriptorFactory(context.getContentResolver()))
+            InputStream.class,
+            new UriLoader.StreamFactory(contentResolver))
+        .append(
+            Uri.class,
+            ParcelFileDescriptor.class,
+             new UriLoader.FileDescriptorFactory(contentResolver))
+        .append(
+            Uri.class,
+            AssetFileDescriptor.class,
+            new UriLoader.AssetFileDescriptorFactory(contentResolver))
         .append(Uri.class, InputStream.class, new UrlUriLoader.StreamFactory())
         .append(URL.class, InputStream.class, new UrlLoader.StreamFactory())
         .append(Uri.class, File.class, new MediaStoreFileLoader.Factory(context))
         .append(GlideUrl.class, InputStream.class, new HttpGlideUrlLoader.Factory())
         .append(byte[].class, ByteBuffer.class, new ByteArrayLoader.ByteBufferFactory())
         .append(byte[].class, InputStream.class, new ByteArrayLoader.StreamFactory())
+        .append(Uri.class, Uri.class, UnitModelLoader.Factory.<Uri>getInstance())
+        .append(Drawable.class, Drawable.class, UnitModelLoader.Factory.<Drawable>getInstance())
+        .append(Drawable.class, Drawable.class, new UnitDrawableDecoder())
         /* Transcoders */
-        .register(Bitmap.class, BitmapDrawable.class,
-            new BitmapDrawableTranscoder(resources, bitmapPool))
-        .register(Bitmap.class, byte[].class, new BitmapBytesTranscoder())
-        .register(GifDrawable.class, byte[].class, new GifDrawableBytesTranscoder());
+        .register(
+            Bitmap.class,
+            BitmapDrawable.class,
+            new BitmapDrawableTranscoder(resources))
+        .register(Bitmap.class, byte[].class, bitmapBytesTranscoder)
+        .register(
+            Drawable.class,
+            byte[].class,
+            new DrawableBytesTranscoder(
+                bitmapPool, bitmapBytesTranscoder, gifDrawableBytesTranscoder))
+        .register(GifDrawable.class, byte[].class, gifDrawableBytesTranscoder);
 
     ImageViewTargetFactory imageViewTargetFactory = new ImageViewTargetFactory();
     glideContext =
         new GlideContext(
-            context, registry, imageViewTargetFactory, defaultRequestOptions,
-            defaultTransitionOptions, engine, logLevel);
+            context,
+            arrayPool,
+            registry,
+            imageViewTargetFactory,
+            defaultRequestOptions,
+            defaultTransitionOptions,
+            engine,
+            logLevel);
   }
 
   /**
@@ -404,10 +526,12 @@ private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules() {
    * {@link com.bumptech.glide.load.Transformation}s. Use outside of these classes is not generally
    * recommended. </p>
    */
+  @NonNull
   public BitmapPool getBitmapPool() {
     return bitmapPool;
   }
 
+  @NonNull
   public ArrayPool getArrayPool() {
     return arrayPool;
   }
@@ -415,6 +539,7 @@ public ArrayPool getArrayPool() {
   /**
    * @return The context associated with this instance.
    */
+  @NonNull
   public Context getContext() {
     return glideContext.getBaseContext();
   }
@@ -423,6 +548,7 @@ ConnectivityMonitorFactory getConnectivityMonitorFactory() {
     return connectivityMonitorFactory;
   }
 
+  @NonNull
   GlideContext getGlideContext() {
     return glideContext;
   }
@@ -452,7 +578,8 @@ GlideContext getGlideContext() {
    * {@link com.bumptech.glide.load.engine.prefill.PreFillType.Builder Builders} representing
    * individual sizes and configurations of {@link android.graphics.Bitmap}s to be pre-filled.
    */
-  public void preFillBitmapPool(PreFillType.Builder... bitmapAttributeBuilders) {
+  @SuppressWarnings("unused") // Public API
+  public void preFillBitmapPool(@NonNull PreFillType.Builder... bitmapAttributeBuilders) {
     bitmapPreFiller.preFill(bitmapAttributeBuilders);
   }
 
@@ -492,16 +619,17 @@ public void trimMemory(int level) {
    *     This method should always be called on a background thread, since it is a blocking call.
    * </p>
    */
-  @SuppressWarnings("unused") // Public API
+  // Public API.
+  @SuppressWarnings({"unused", "WeakerAccess"})
   public void clearDiskCache() {
     Util.assertBackgroundThread();
     engine.clearDiskCache();
   }
 
-
   /**
    * Internal method.
    */
+  @NonNull
   public RequestManagerRetriever getRequestManagerRetriever() {
     return requestManagerRetriever;
   }
@@ -518,7 +646,9 @@ public RequestManagerRetriever getRequestManagerRetriever() {
    *
    * @return the previous MemoryCategory used by Glide.
    */
-  public MemoryCategory setMemoryCategory(MemoryCategory memoryCategory) {
+  @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
+  public MemoryCategory setMemoryCategory(@NonNull MemoryCategory memoryCategory) {
     // Engine asserts this anyway when removing resources, fail faster and consistently
     Util.assertMainThread();
     // memory cache needs to be trimmed before bitmap pool to trim re-pooled Bitmaps too. See #687.
@@ -529,12 +659,13 @@ public MemoryCategory setMemoryCategory(MemoryCategory memoryCategory) {
     return oldCategory;
   }
 
+  @NonNull
   private static RequestManagerRetriever getRetriever(@Nullable Context context) {
     // Context could be null for other reasons (ie the user passes in null), but in practice it will
     // only occur due to errors with the Fragment lifecycle.
     Preconditions.checkNotNull(
         context,
-        "You cannot start a load on a not yet attached View or a  Fragment where getActivity() "
+        "You cannot start a load on a not yet attached View or a Fragment where getActivity() "
             + "returns null (which usually occurs when getActivity() is called before the Fragment "
             + "is attached or after the Fragment is destroyed).");
     return Glide.get(context).getRequestManagerRetriever();
@@ -562,7 +693,8 @@ private static RequestManagerRetriever getRetriever(@Nullable Context context) {
    * @see #with(android.support.v4.app.Fragment)
    * @see #with(android.support.v4.app.FragmentActivity)
    */
-  public static RequestManager with(Context context) {
+  @NonNull
+  public static RequestManager with(@NonNull Context context) {
     return getRetriever(context).get(context);
   }
 
@@ -573,7 +705,8 @@ public static RequestManager with(Context context) {
    * @param activity The activity to use.
    * @return A RequestManager for the given activity that can be used to start a load.
    */
-  public static RequestManager with(Activity activity) {
+  @NonNull
+  public static RequestManager with(@NonNull Activity activity) {
     return getRetriever(activity).get(activity);
   }
 
@@ -585,7 +718,8 @@ public static RequestManager with(Activity activity) {
    * @param activity The activity to use.
    * @return A RequestManager for the given FragmentActivity that can be used to start a load.
    */
-  public static RequestManager with(FragmentActivity activity) {
+  @NonNull
+  public static RequestManager with(@NonNull FragmentActivity activity) {
     return getRetriever(activity).get(activity);
   }
 
@@ -596,7 +730,8 @@ public static RequestManager with(FragmentActivity activity) {
    * @param fragment The fragment to use.
    * @return A RequestManager for the given Fragment that can be used to start a load.
    */
-  public static RequestManager with(android.app.Fragment fragment) {
+  @NonNull
+  public static RequestManager with(@NonNull android.app.Fragment fragment) {
     return getRetriever(fragment.getActivity()).get(fragment);
   }
 
@@ -608,7 +743,8 @@ public static RequestManager with(android.app.Fragment fragment) {
    * @param fragment The fragment to use.
    * @return A RequestManager for the given Fragment that can be used to start a load.
    */
-  public static RequestManager with(Fragment fragment) {
+  @NonNull
+  public static RequestManager with(@NonNull Fragment fragment) {
     return getRetriever(fragment.getActivity()).get(fragment);
   }
 
@@ -637,23 +773,26 @@ public static RequestManager with(Fragment fragment) {
    * @param view The view to search for a containing Fragment or Activity from.
    * @return A RequestManager that can be used to start a load.
    */
-  public static RequestManager with(View view) {
+  @NonNull
+  public static RequestManager with(@NonNull View view) {
     return getRetriever(view.getContext()).get(view);
   }
 
+  @NonNull
   public Registry getRegistry() {
     return registry;
   }
 
-  void removeFromManagers(Target<?> target) {
+  boolean removeFromManagers(@NonNull Target<?> target) {
     synchronized (managers) {
       for (RequestManager requestManager : managers) {
         if (requestManager.untrack(target)) {
-          return;
+          return true;
         }
       }
     }
-    throw new IllegalStateException("Failed to remove target from managers");
+
+    return false;
   }
 
   void registerRequestManager(RequestManager requestManager) {
@@ -668,7 +807,7 @@ void registerRequestManager(RequestManager requestManager) {
   void unregisterRequestManager(RequestManager requestManager) {
     synchronized (managers) {
       if (!managers.contains(requestManager)) {
-        throw new IllegalStateException("Cannot register not yet registered manager");
+        throw new IllegalStateException("Cannot unregister not yet registered manager");
       }
       managers.remove(requestManager);
     }
diff --git a/library/src/main/java/com/bumptech/glide/GlideBuilder.java b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
index e77742fcb..2a336aa82 100644
--- a/library/src/main/java/com/bumptech/glide/GlideBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide;
 
 import android.content.Context;
+import android.graphics.Bitmap;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.support.v4.util.ArrayMap;
@@ -23,11 +24,14 @@
 import com.bumptech.glide.manager.RequestManagerRetriever;
 import com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory;
 import com.bumptech.glide.request.RequestOptions;
+import com.bumptech.glide.request.target.Target;
 import java.util.Map;
 
 /**
  * A builder class for setting default structural classes for Glide to use.
  */
+// Public API.
+@SuppressWarnings({"unused", "WeakerAccess"})
 public final class GlideBuilder {
   private final Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions = new ArrayMap<>();
   private Engine engine;
@@ -43,6 +47,8 @@
   private RequestOptions defaultRequestOptions = new RequestOptions();
   @Nullable
   private RequestManagerFactory requestManagerFactory;
+  private GlideExecutor animationExecutor;
+  private boolean isActiveResourceRetentionAllowed;
 
   /**
    * Sets the {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} implementation to use
@@ -51,7 +57,8 @@
    * @param bitmapPool The pool to use.
    * @return This builder.
    */
-  public GlideBuilder setBitmapPool(BitmapPool bitmapPool) {
+  @NonNull
+  public GlideBuilder setBitmapPool(@Nullable BitmapPool bitmapPool) {
     this.bitmapPool = bitmapPool;
     return this;
   }
@@ -63,7 +70,8 @@ public GlideBuilder setBitmapPool(BitmapPool bitmapPool) {
    * @param arrayPool The pool to use.
    * @return This builder.
    */
-  public GlideBuilder setArrayPool(ArrayPool arrayPool) {
+  @NonNull
+  public GlideBuilder setArrayPool(@Nullable ArrayPool arrayPool) {
     this.arrayPool = arrayPool;
     return this;
   }
@@ -75,7 +83,8 @@ public GlideBuilder setArrayPool(ArrayPool arrayPool) {
    * @param memoryCache The cache to use.
    * @return This builder.
    */
-  public GlideBuilder setMemoryCache(MemoryCache memoryCache) {
+  @NonNull
+  public GlideBuilder setMemoryCache(@Nullable MemoryCache memoryCache) {
     this.memoryCache = memoryCache;
     return this;
   }
@@ -108,45 +117,94 @@ public DiskCache build() {
    * @param diskCacheFactory The disk cache factory to use.
    * @return This builder.
    */
-  public GlideBuilder setDiskCache(DiskCache.Factory diskCacheFactory) {
+  @NonNull
+  public GlideBuilder setDiskCache(@Nullable DiskCache.Factory diskCacheFactory) {
     this.diskCacheFactory = diskCacheFactory;
     return this;
   }
 
   /**
-   * Sets the {@link java.util.concurrent.ExecutorService} implementation to use when retrieving
+   * Sets the {@link GlideExecutor} to use when retrieving
    * {@link com.bumptech.glide.load.engine.Resource}s that are not already in the cache.
    *
-   * <p> Any implementation must order requests based on their {@link com.bumptech.glide.Priority}
-   * for thumbnail requests to work properly.
+   * <p>The thread count defaults to the number of cores available on the device, with a maximum of
+   * 4.
+   *
+   * <p>Use the {@link GlideExecutor#newSourceExecutor()} methods if you'd like to specify options
+   * for the source executor.
    *
    * @param service The ExecutorService to use.
    * @return This builder.
    * @see #setDiskCacheExecutor(GlideExecutor)
    * @see GlideExecutor
+   *
+   * @deprecated Use {@link #setSourceExecutor(GlideExecutor)}
    */
-  public GlideBuilder setResizeExecutor(GlideExecutor service) {
+  @Deprecated
+  public GlideBuilder setResizeExecutor(@Nullable GlideExecutor service) {
+    return setSourceExecutor(service);
+  }
+
+  /**
+   * Sets the {@link GlideExecutor} to use when retrieving
+   * {@link com.bumptech.glide.load.engine.Resource}s that are not already in the cache.
+   *
+   * <p>The thread count defaults to the number of cores available on the device, with a maximum of
+   * 4.
+   *
+   * <p>Use the {@link GlideExecutor#newSourceExecutor()} methods if you'd like to specify options
+   * for the source executor.
+   *
+   * @param service The ExecutorService to use.
+   * @return This builder.
+   * @see #setDiskCacheExecutor(GlideExecutor)
+   * @see GlideExecutor
+   */
+  @NonNull
+  public GlideBuilder setSourceExecutor(@Nullable GlideExecutor service) {
     this.sourceExecutor = service;
     return this;
   }
 
   /**
-   * Sets the {@link java.util.concurrent.ExecutorService} implementation to use when retrieving
-   * {@link com.bumptech.glide.load.engine.Resource}s that are currently in cache.
+   * Sets the {@link GlideExecutor} to use when retrieving
+   * {@link com.bumptech.glide.load.engine.Resource}s that are currently in Glide's disk caches.
    *
-   * <p> Any implementation must order requests based on their {@link com.bumptech.glide.Priority}
-   * for thumbnail requests to work properly.
+   * <p>Defaults to a single thread which is usually the best combination of memory usage,
+   * jank, and performance, even on high end devices.
    *
-   * @param service The ExecutorService to use.
+   * <p>Use the {@link GlideExecutor#newDiskCacheExecutor()} if you'd like to specify options
+   * for the disk cache executor.
+   *
+   * @param service The {@link GlideExecutor} to use.
    * @return This builder.
-   * @see #setResizeExecutor(GlideExecutor)
+   * @see #setSourceExecutor(GlideExecutor)
    * @see GlideExecutor
    */
-  public GlideBuilder setDiskCacheExecutor(GlideExecutor service) {
+  @NonNull
+  public GlideBuilder setDiskCacheExecutor(@Nullable GlideExecutor service) {
     this.diskCacheExecutor = service;
     return this;
   }
 
+  /**
+   * Sets the {@link GlideExecutor} to use when loading frames of animated images and particularly
+   * of {@link com.bumptech.glide.load.resource.gif.GifDrawable}s.
+   *
+   * <p>Defaults to one or two threads, depending on the number of cores available.
+   *
+   * <p>Use the {@link GlideExecutor#newAnimationExecutor()} methods  if you'd like to specify
+   * options for the animation executor.
+   *
+   * @param service The {@link GlideExecutor} to use.
+   * @return This builder.
+   */
+  @NonNull
+  public GlideBuilder setAnimationExecutor(@Nullable GlideExecutor service) {
+    this.animationExecutor = service;
+    return this;
+  }
+
   /**
    * Sets the default {@link RequestOptions} to use for all loads across the app.
    *
@@ -157,7 +215,8 @@ public GlideBuilder setDiskCacheExecutor(GlideExecutor service) {
    * @param requestOptions The options to use by default.
    * @return This builder.
    */
-  public GlideBuilder setDefaultRequestOptions(RequestOptions requestOptions) {
+  @NonNull
+  public GlideBuilder setDefaultRequestOptions(@Nullable RequestOptions requestOptions) {
     this.defaultRequestOptions = requestOptions;
     return this;
   }
@@ -178,6 +237,7 @@ public GlideBuilder setDefaultRequestOptions(RequestOptions requestOptions) {
    * {@link android.graphics.drawable.BitmapDrawable}s, the transition you registered for
    * {@link android.graphics.drawable.BitmapDrawable}s will be used.
    */
+  @NonNull
   public <T> GlideBuilder setDefaultTransitionOptions(
       @NonNull Class<T> clazz, @Nullable TransitionOptions<?, T> options) {
     defaultTransitionOptions.put(clazz, options);
@@ -212,7 +272,8 @@ public GlideBuilder setDecodeFormat(DecodeFormat decodeFormat) {
    * @param builder The builder to use (will not be modified).
    * @return This builder.
    */
-  public GlideBuilder setMemorySizeCalculator(MemorySizeCalculator.Builder builder) {
+  @NonNull
+  public GlideBuilder setMemorySizeCalculator(@NonNull MemorySizeCalculator.Builder builder) {
     return setMemorySizeCalculator(builder.build());
   }
 
@@ -226,7 +287,8 @@ public GlideBuilder setMemorySizeCalculator(MemorySizeCalculator.Builder builder
    * @param calculator The calculator to use.
    * @return This builder.
    */
-  public GlideBuilder setMemorySizeCalculator(MemorySizeCalculator calculator) {
+  @NonNull
+  public GlideBuilder setMemorySizeCalculator(@Nullable MemorySizeCalculator calculator) {
     this.memorySizeCalculator = calculator;
     return this;
   }
@@ -239,7 +301,8 @@ public GlideBuilder setMemorySizeCalculator(MemorySizeCalculator calculator) {
    * @param factory The factory to use
    * @return This builder.
    */
-  public GlideBuilder setConnectivityMonitorFactory(ConnectivityMonitorFactory factory) {
+  @NonNull
+  public GlideBuilder setConnectivityMonitorFactory(@Nullable ConnectivityMonitorFactory factory) {
     this.connectivityMonitorFactory = factory;
     return this;
   }
@@ -269,6 +332,7 @@ public GlideBuilder setConnectivityMonitorFactory(ConnectivityMonitorFactory fac
    * @param logLevel The log level to use from {@link Log}.
    * @return This builder.
    */
+  @NonNull
   public GlideBuilder setLogLevel(int logLevel) {
     if (logLevel < Log.VERBOSE || logLevel > Log.ERROR) {
       throw new IllegalArgumentException("Log level must be one of Log.VERBOSE, Log.DEBUG,"
@@ -278,19 +342,68 @@ public GlideBuilder setLogLevel(int logLevel) {
     return this;
   }
 
-  GlideBuilder setRequestManagerFactory(
-      @Nullable RequestManagerRetriever.RequestManagerFactory factory) {
-    this.requestManagerFactory = factory;
+  /**
+   * If set to {@code true}, allows Glide to re-capture resources that are loaded into
+   * {@link com.bumptech.glide.request.target.Target}s which are subsequently de-referenced and
+   * garbage collected without being cleared.
+   *
+   * <p>Defaults to {@code false}.
+   *
+   * <p>Glide's resource re-use system is permissive, which means that's acceptable for callers to
+   * load resources into {@link com.bumptech.glide.request.target.Target}s and then never clear the
+   * {@link com.bumptech.glide.request.target.Target}. To do so, Glide uses
+   * {@link java.lang.ref.WeakReference}s to track resources that belong to
+   * {@link com.bumptech.glide.request.target.Target}s that haven't yet been cleared. Setting
+   * this method to {@code true} allows Glide to also maintain a hard reference to the underlying
+   * resource so that if the {@link com.bumptech.glide.request.target.Target} is garbage collected,
+   * Glide can return the underlying resource to it's memory cache so that subsequent requests will
+   * not unexpectedly re-load the resource from disk or source. As a side affect, it will take
+   * the system slightly longer to garbage collect the underlying resource because the weak
+   * reference has to be cleared and processed before the hard reference is removed. As a result,
+   * setting this method to {@code true} may transiently increase the memory usage of an
+   * application.
+   *
+   * <p>Leaving this method at the default {@code false} value will allow the platform to garbage
+   * collect resources more quickly, but will lead to unexpected memory cache misses if callers load
+   * resources into {@link com.bumptech.glide.request.target.Target}s but never clear them.
+   *
+   * <p>If you set this method to {@code true} you <em>must not</em> call
+   * {@link Bitmap#recycle()} or mutate any Bitmaps returned by Glide. If this method is set to
+   * {@code false}, recycling or mutating Bitmaps is inefficient but safe as long as you do not
+   * clear the corresponding {@link com.bumptech.glide.request.target.Target} used to load the
+   * {@link Bitmap}. However, if you set this method to {@code true} and recycle or mutate any
+   * returned {@link Bitmap}s or other mutable resources, Glide may recover those resources and
+   * attempt to use them later on, resulting in crashes, graphical corruption or undefined behavior.
+   *
+   * <p>Regardless of what value this method is set to, it's always good practice to clear
+   * {@link com.bumptech.glide.request.target.Target}s when you're done with the corresponding
+   * resource. Clearing {@link com.bumptech.glide.request.target.Target}s allows Glide to maximize
+   * resource re-use, minimize memory overhead and minimize unexpected behavior resulting from
+   * edge cases. If you use {@link RequestManager#clear(Target)}, calling {@link Bitmap#recycle()}
+   * or mutating {@link Bitmap}s is not only unsafe, it's also totally unnecessary and should be
+   * avoided. In all cases, prefer {@link RequestManager#clear(Target)} to {@link Bitmap#recycle()}.
+   *
+   * @return This builder.
+   */
+  @NonNull
+  public GlideBuilder setIsActiveResourceRetentionAllowed(
+      boolean isActiveResourceRetentionAllowed) {
+    this.isActiveResourceRetentionAllowed = isActiveResourceRetentionAllowed;
     return this;
   }
 
+  void setRequestManagerFactory(@Nullable RequestManagerFactory factory) {
+    this.requestManagerFactory = factory;
+  }
+
   // For testing.
   GlideBuilder setEngine(Engine engine) {
     this.engine = engine;
     return this;
   }
 
-  public Glide build(Context context) {
+  @NonNull
+  public Glide build(@NonNull Context context) {
     if (sourceExecutor == null) {
       sourceExecutor = GlideExecutor.newSourceExecutor();
     }
@@ -299,6 +412,10 @@ public Glide build(Context context) {
       diskCacheExecutor = GlideExecutor.newDiskCacheExecutor();
     }
 
+    if (animationExecutor == null) {
+      animationExecutor = GlideExecutor.newAnimationExecutor();
+    }
+
     if (memorySizeCalculator == null) {
       memorySizeCalculator = new MemorySizeCalculator.Builder(context).build();
     }
@@ -329,12 +446,19 @@ public Glide build(Context context) {
     }
 
     if (engine == null) {
-      engine = new Engine(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor,
-          GlideExecutor.newUnlimitedSourceExecutor());
+      engine =
+          new Engine(
+              memoryCache,
+              diskCacheFactory,
+              diskCacheExecutor,
+              sourceExecutor,
+              GlideExecutor.newUnlimitedSourceExecutor(),
+              GlideExecutor.newAnimationExecutor(),
+              isActiveResourceRetentionAllowed);
     }
 
-    RequestManagerRetriever requestManagerRetriever = new RequestManagerRetriever(
-        requestManagerFactory);
+    RequestManagerRetriever requestManagerRetriever =
+        new RequestManagerRetriever(requestManagerFactory);
 
     return new Glide(
         context,
diff --git a/library/src/main/java/com/bumptech/glide/GlideContext.java b/library/src/main/java/com/bumptech/glide/GlideContext.java
index 1e0aa58ab..eeb98cc5f 100644
--- a/library/src/main/java/com/bumptech/glide/GlideContext.java
+++ b/library/src/main/java/com/bumptech/glide/GlideContext.java
@@ -1,18 +1,17 @@
 package com.bumptech.glide;
 
-import android.annotation.TargetApi;
 import android.content.Context;
 import android.content.ContextWrapper;
-import android.os.Build;
 import android.os.Handler;
 import android.os.Looper;
 import android.support.annotation.NonNull;
 import android.support.annotation.VisibleForTesting;
 import android.widget.ImageView;
 import com.bumptech.glide.load.engine.Engine;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.ImageViewTargetFactory;
-import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.request.target.ViewTarget;
 import java.util.Map;
 import java.util.Map.Entry;
 
@@ -20,12 +19,12 @@
  * Global context for all loads in Glide containing and exposing the various registries and classes
  * required to load resources.
  */
-@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
 public class GlideContext extends ContextWrapper {
   @VisibleForTesting
   static final TransitionOptions<?, ?> DEFAULT_TRANSITION_OPTIONS =
-      new GenericTransitionOptions<Object>();
+      new GenericTransitionOptions<>();
   private final Handler mainHandler;
+  private final ArrayPool arrayPool;
   private final Registry registry;
   private final ImageViewTargetFactory imageViewTargetFactory;
   private final RequestOptions defaultRequestOptions;
@@ -33,11 +32,17 @@
   private final Engine engine;
   private final int logLevel;
 
-  public GlideContext(Context context, Registry registry,
-      ImageViewTargetFactory imageViewTargetFactory, RequestOptions defaultRequestOptions,
-      Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions, Engine engine,
+  public GlideContext(
+      @NonNull Context context,
+      @NonNull ArrayPool arrayPool,
+      @NonNull Registry registry,
+      @NonNull ImageViewTargetFactory imageViewTargetFactory,
+      @NonNull RequestOptions defaultRequestOptions,
+      @NonNull Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions,
+      @NonNull Engine engine,
       int logLevel) {
     super(context.getApplicationContext());
+    this.arrayPool = arrayPool;
     this.registry = registry;
     this.imageViewTargetFactory = imageViewTargetFactory;
     this.defaultRequestOptions = defaultRequestOptions;
@@ -54,7 +59,7 @@ public RequestOptions getDefaultRequestOptions() {
 
   @SuppressWarnings("unchecked")
   @NonNull
-  public <T> TransitionOptions<?, T> getDefaultTransitionOptions(Class<T> transcodeClass) {
+  public <T> TransitionOptions<?, T> getDefaultTransitionOptions(@NonNull Class<T> transcodeClass) {
     TransitionOptions<?, ?> result = defaultTransitionOptions.get(transcodeClass);
     if (result == null) {
       for (Entry<Class<?>, TransitionOptions<?, ?>> value : defaultTransitionOptions.entrySet()) {
@@ -69,18 +74,23 @@ public RequestOptions getDefaultRequestOptions() {
     return (TransitionOptions<?, T>) result;
   }
 
-  public <X> Target<X> buildImageViewTarget(ImageView imageView, Class<X> transcodeClass) {
+  @NonNull
+  public <X> ViewTarget<ImageView, X> buildImageViewTarget(
+      @NonNull ImageView imageView, @NonNull Class<X> transcodeClass) {
     return imageViewTargetFactory.buildTarget(imageView, transcodeClass);
   }
 
+  @NonNull
   public Handler getMainHandler() {
     return mainHandler;
   }
 
+  @NonNull
   public Engine getEngine() {
     return engine;
   }
 
+  @NonNull
   public Registry getRegistry() {
     return registry;
   }
@@ -88,4 +98,9 @@ public Registry getRegistry() {
   public int getLogLevel() {
     return logLevel;
   }
+
+  @NonNull
+  public ArrayPool getArrayPool() {
+    return arrayPool;
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/ListPreloader.java b/library/src/main/java/com/bumptech/glide/ListPreloader.java
index 7aaa9d370..a6f5835f8 100644
--- a/library/src/main/java/com/bumptech/glide/ListPreloader.java
+++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java
@@ -85,7 +85,7 @@
      * @param item The model to load.
      */
     @Nullable
-    RequestBuilder getPreloadRequestBuilder(U item);
+    RequestBuilder<?> getPreloadRequestBuilder(@NonNull U item);
   }
 
   /**
@@ -107,7 +107,7 @@
      * @param item A model
      */
     @Nullable
-    int[] getPreloadSize(T item, int adapterPosition, int perItemPosition);
+    int[] getPreloadSize(@NonNull T item, int adapterPosition, int perItemPosition);
   }
 
   /**
@@ -119,8 +119,9 @@
    * @param preloadDimensionProvider Provides the dimensions of images to load.
    * @param maxPreload               Maximum number of items to preload.
    */
-  public ListPreloader(RequestManager requestManager, PreloadModelProvider<T> preloadModelProvider,
-      PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {
+  public ListPreloader(@NonNull RequestManager requestManager,
+      @NonNull PreloadModelProvider<T> preloadModelProvider,
+      @NonNull PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {
     this.requestManager = requestManager;
     this.preloadModelProvider = preloadModelProvider;
     this.preloadDimensionProvider = preloadDimensionProvider;
@@ -169,12 +170,12 @@ private void preload(int from, int to) {
     if (from < to) {
       // Increasing
       for (int i = start; i < end; i++) {
-        preloadAdapterPosition(this.preloadModelProvider.getPreloadItems(i), i, true);
+        preloadAdapterPosition(preloadModelProvider.getPreloadItems(i), i, true);
       }
     } else {
       // Decreasing
       for (int i = end - 1; i >= start; i--) {
-        preloadAdapterPosition(this.preloadModelProvider.getPreloadItems(i), i, false);
+        preloadAdapterPosition(preloadModelProvider.getPreloadItems(i), i, false);
       }
     }
 
@@ -206,7 +207,7 @@ private void preloadItem(@Nullable T item, int position, int perItemPosition) {
       return;
     }
     RequestBuilder<Object> preloadRequestBuilder =
-        preloadModelProvider.getPreloadRequestBuilder(item);
+        (RequestBuilder<Object>) preloadModelProvider.getPreloadRequestBuilder(item);
     if (preloadRequestBuilder == null) {
       return;
     }
@@ -223,6 +224,8 @@ private void cancelAll() {
   private static final class PreloadTargetQueue {
     private final Queue<PreloadTarget> queue;
 
+    // The loop is short and the only point is to create the objects.
+    @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")
     PreloadTargetQueue(int size) {
       queue = Util.createQueue(size);
 
@@ -248,17 +251,18 @@ public PreloadTarget next(int width, int height) {
     PreloadTarget() { }
 
     @Override
-    public void onResourceReady(Object resource, Transition<? super Object> transition) {
+    public void onResourceReady(@NonNull Object resource,
+        @Nullable Transition<? super Object> transition) {
       // Do nothing.
     }
 
     @Override
-    public void getSize(SizeReadyCallback cb) {
+    public void getSize(@NonNull SizeReadyCallback cb) {
       cb.onSizeReady(photoWidth, photoHeight);
     }
 
     @Override
-    public void removeCallback(SizeReadyCallback cb) {
+    public void removeCallback(@NonNull SizeReadyCallback cb) {
       // Do nothing because we don't retain references to SizeReadyCallbacks.
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/MemoryCategory.java b/library/src/main/java/com/bumptech/glide/MemoryCategory.java
index a5781f62d..af84e0454 100644
--- a/library/src/main/java/com/bumptech/glide/MemoryCategory.java
+++ b/library/src/main/java/com/bumptech/glide/MemoryCategory.java
@@ -18,7 +18,7 @@
    */
   HIGH(1.5f);
 
-  private float multiplier;
+  private final float multiplier;
 
   MemoryCategory(float multiplier) {
     this.multiplier = multiplier;
diff --git a/library/src/main/java/com/bumptech/glide/ModelTypes.java b/library/src/main/java/com/bumptech/glide/ModelTypes.java
new file mode 100644
index 000000000..42a14053e
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/ModelTypes.java
@@ -0,0 +1,55 @@
+package com.bumptech.glide;
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import java.io.File;
+import java.net.URL;
+
+/**
+ * Ensures that the set of explicitly supported model types remains consistent across Glide's
+ * API surface.
+ */
+interface ModelTypes<T> {
+  @NonNull
+  @CheckResult
+  T load(@Nullable Bitmap bitmap);
+
+  @NonNull
+  @CheckResult
+  T load(@Nullable Drawable drawable);
+
+  @NonNull
+  @CheckResult
+  T load(@Nullable String string);
+
+  @NonNull
+  @CheckResult
+  T load(@Nullable Uri uri);
+
+  @NonNull
+  @CheckResult
+  T load(@Nullable File file);
+
+  @NonNull
+  @CheckResult
+  T load(@RawRes @DrawableRes @Nullable Integer resourceId);
+
+  @Deprecated
+  @CheckResult
+  T load(@Nullable URL url);
+
+  @NonNull
+  @CheckResult
+  T load(@Nullable byte[] model);
+
+  @NonNull
+  @CheckResult
+  @SuppressWarnings("unchecked")
+  T load(@Nullable Object model);
+}
diff --git a/library/src/main/java/com/bumptech/glide/Registry.java b/library/src/main/java/com/bumptech/glide/Registry.java
index 97ef93a87..62f135d7d 100644
--- a/library/src/main/java/com/bumptech/glide/Registry.java
+++ b/library/src/main/java/com/bumptech/glide/Registry.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.support.v4.util.Pools.Pool;
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.ImageHeaderParser;
@@ -32,6 +34,8 @@
  * Manages component registration to extend or replace Glide's default loading, decoding, and
  * encoding logic.
  */
+// Public API.
+@SuppressWarnings({"WeakerAccess", "unused"})
 public class Registry {
   public static final String BUCKET_GIF = "Gif";
   public static final String BUCKET_BITMAP = "Bitmap";
@@ -50,10 +54,10 @@
   private final ModelToResourceClassCache modelToResourceClassCache =
       new ModelToResourceClassCache();
   private final LoadPathCache loadPathCache = new LoadPathCache();
-  private final Pool<List<Exception>> exceptionListPool = FactoryPools.threadSafeList();
+  private final Pool<List<Throwable>> throwableListPool = FactoryPools.threadSafeList();
 
   public Registry() {
-    this.modelLoaderRegistry = new ModelLoaderRegistry(exceptionListPool);
+    this.modelLoaderRegistry = new ModelLoaderRegistry(throwableListPool);
     this.encoderRegistry = new EncoderRegistry();
     this.decoderRegistry = new ResourceDecoderRegistry();
     this.resourceEncoderRegistry = new ResourceEncoderRegistry();
@@ -79,8 +83,9 @@ public Registry() {
    * @deprecated Use the equivalent {@link #append(Class, Class, ModelLoaderFactory)} method
    * instead.
    */
+  @NonNull
   @Deprecated
-  public <Data> Registry register(Class<Data> dataClass, Encoder<Data> encoder) {
+  public <Data> Registry register(@NonNull Class<Data> dataClass, @NonNull Encoder<Data> encoder) {
     return append(dataClass, encoder);
   }
 
@@ -99,7 +104,8 @@ public Registry() {
    *
    * @see #prepend(Class, Encoder)
    */
-  public <Data> Registry append(Class<Data> dataClass, Encoder<Data> encoder) {
+  @NonNull
+  public <Data> Registry append(@NonNull Class<Data> dataClass, @NonNull Encoder<Data> encoder) {
     encoderRegistry.append(dataClass, encoder);
     return this;
   }
@@ -115,7 +121,8 @@ public Registry() {
    *
    * @see #append(Class, Encoder)
    */
-  public <Data> Registry prepend(Class<Data> dataClass, Encoder<Data> encoder) {
+  @NonNull
+  public <Data> Registry prepend(@NonNull Class<Data> dataClass, @NonNull Encoder<Data> encoder) {
     encoderRegistry.prepend(dataClass, encoder);
     return this;
   }
@@ -140,10 +147,11 @@ public Registry() {
    * {@link com.bumptech.glide.load.resource.gif.GifDrawable} etc).
    * @param decoder The {@link ResourceDecoder} to register.
    */
+  @NonNull
   public <Data, TResource> Registry append(
-      Class<Data> dataClass,
-      Class<TResource> resourceClass,
-      ResourceDecoder<Data, TResource> decoder) {
+      @NonNull Class<Data> dataClass,
+      @NonNull Class<TResource> resourceClass,
+      @NonNull ResourceDecoder<Data, TResource> decoder) {
     append(BUCKET_APPEND_ALL, dataClass, resourceClass, decoder);
     return this;
   }
@@ -169,11 +177,12 @@ public Registry() {
    * {@link com.bumptech.glide.load.resource.gif.GifDrawable} etc).
    * @param decoder The {@link ResourceDecoder} to register.
    */
+  @NonNull
   public <Data, TResource> Registry append(
-      String bucket,
-      Class<Data> dataClass,
-      Class<TResource> resourceClass,
-      ResourceDecoder<Data, TResource> decoder) {
+      @NonNull String bucket,
+      @NonNull Class<Data> dataClass,
+      @NonNull Class<TResource> resourceClass,
+      @NonNull ResourceDecoder<Data, TResource> decoder) {
     decoderRegistry.append(bucket, decoder, dataClass, resourceClass);
     return this;
   }
@@ -198,10 +207,11 @@ public Registry() {
    * {@link com.bumptech.glide.load.resource.gif.GifDrawable} etc).
    * @param decoder The {@link ResourceDecoder} to register.
    */
+  @NonNull
   public <Data, TResource> Registry prepend(
-      Class<Data> dataClass,
-      Class<TResource> resourceClass,
-      ResourceDecoder<Data, TResource> decoder) {
+      @NonNull Class<Data> dataClass,
+      @NonNull Class<TResource> resourceClass,
+      @NonNull ResourceDecoder<Data, TResource> decoder) {
     prepend(BUCKET_PREPEND_ALL, dataClass, resourceClass, decoder);
     return this;
   }
@@ -227,11 +237,12 @@ public Registry() {
    * {@link com.bumptech.glide.load.resource.gif.GifDrawable} etc).
    * @param decoder The {@link ResourceDecoder} to register.
    */
+  @NonNull
   public <Data, TResource> Registry prepend(
-      String bucket,
-      Class<Data> dataClass,
-      Class<TResource> resourceClass,
-      ResourceDecoder<Data, TResource> decoder) {
+      @NonNull String bucket,
+      @NonNull Class<Data> dataClass,
+      @NonNull Class<TResource> resourceClass,
+      @NonNull ResourceDecoder<Data, TResource> decoder) {
     decoderRegistry.prepend(bucket, decoder, dataClass, resourceClass);
     return this;
   }
@@ -252,7 +263,8 @@ public Registry() {
    * @param buckets The list of bucket identifiers in order from highest priority to least priority.
    */
   // Final to avoid a PMD error.
-  public final Registry setResourceDecoderBucketPriorityList(List<String> buckets) {
+  @NonNull
+  public final Registry setResourceDecoderBucketPriorityList(@NonNull List<String> buckets) {
     List<String> modifiedBuckets = new ArrayList<>(buckets);
     modifiedBuckets.add(0, BUCKET_PREPEND_ALL);
     modifiedBuckets.add(BUCKET_APPEND_ALL);
@@ -276,9 +288,10 @@ public final Registry setResourceDecoderBucketPriorityList(List<String> buckets)
    *
    * @deprecated Use the equivalent {@link #append(Class, ResourceEncoder)} method instead.
    */
+  @NonNull
   @Deprecated
   public <TResource> Registry register(
-      Class<TResource> resourceClass, ResourceEncoder<TResource> encoder) {
+      @NonNull Class<TResource> resourceClass, @NonNull ResourceEncoder<TResource> encoder) {
     return append(resourceClass, encoder);
   }
 
@@ -298,8 +311,9 @@ public final Registry setResourceDecoderBucketPriorityList(List<String> buckets)
    *
    * @see #prepend(Class, ResourceEncoder)
    */
+  @NonNull
   public <TResource> Registry append(
-      Class<TResource> resourceClass, ResourceEncoder<TResource> encoder) {
+      @NonNull Class<TResource> resourceClass, @NonNull ResourceEncoder<TResource> encoder) {
     resourceEncoderRegistry.append(resourceClass, encoder);
     return this;
   }
@@ -316,8 +330,9 @@ public final Registry setResourceDecoderBucketPriorityList(List<String> buckets)
    *
    * @see #append(Class, ResourceEncoder)
    */
+  @NonNull
   public <TResource> Registry prepend(
-      Class<TResource> resourceClass, ResourceEncoder<TResource> encoder) {
+      @NonNull Class<TResource> resourceClass, @NonNull ResourceEncoder<TResource> encoder) {
     resourceEncoderRegistry.prepend(resourceClass, encoder);
     return this;
   }
@@ -326,7 +341,8 @@ public final Registry setResourceDecoderBucketPriorityList(List<String> buckets)
    * Registers a new {@link com.bumptech.glide.load.data.DataRewinder.Factory} to handle a
    * non-default data type that can be rewind to allow for efficient reads of file headers.
    */
-  public Registry register(DataRewinder.Factory factory) {
+  @NonNull
+  public Registry register(@NonNull DataRewinder.Factory<?> factory) {
     dataRewinderRegistry.register(factory);
     return this;
   }
@@ -341,8 +357,10 @@ public Registry register(DataRewinder.Factory factory) {
    * {@link android.graphics.drawable.BitmapDrawable}).
    * @param transcoder The {@link ResourceTranscoder} to register.
    */
-  public <TResource, Transcode> Registry register(Class<TResource> resourceClass,
-      Class<Transcode> transcodeClass, ResourceTranscoder<TResource, Transcode> transcoder) {
+  @NonNull
+  public <TResource, Transcode> Registry register(
+      @NonNull Class<TResource> resourceClass, @NonNull Class<Transcode> transcodeClass,
+      @NonNull ResourceTranscoder<TResource, Transcode> transcoder) {
     transcoderRegistry.register(resourceClass, transcodeClass, transcoder);
     return this;
   }
@@ -351,7 +369,8 @@ public Registry register(DataRewinder.Factory factory) {
    * Registers a new {@link ImageHeaderParser} that can obtain some basic metadata from an image
    * header (orientation, type etc).
    */
-  public Registry register(ImageHeaderParser parser) {
+  @NonNull
+  public Registry register(@NonNull ImageHeaderParser parser) {
     imageHeaderParserRegistry.add(parser);
     return this;
   }
@@ -378,8 +397,10 @@ public Registry register(ImageHeaderParser parser) {
    * @param dataClass  the data class (e.g. {@link java.io.InputStream},
    * {@link java.io.FileDescriptor}).
    */
-  public <Model, Data> Registry append(Class<Model> modelClass, Class<Data> dataClass,
-      ModelLoaderFactory<Model, Data> factory) {
+  @NonNull
+  public <Model, Data> Registry append(
+      @NonNull Class<Model> modelClass, @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<Model, Data> factory) {
     modelLoaderRegistry.append(modelClass, dataClass, factory);
     return this;
   }
@@ -407,8 +428,10 @@ public Registry register(ImageHeaderParser parser) {
    * @param dataClass  the data class (e.g. {@link java.io.InputStream},
    * {@link java.io.FileDescriptor}).
    */
-  public <Model, Data> Registry prepend(Class<Model> modelClass, Class<Data> dataClass,
-      ModelLoaderFactory<Model, Data> factory) {
+  @NonNull
+  public <Model, Data> Registry prepend(
+      @NonNull Class<Model> modelClass, @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<Model, Data> factory) {
     modelLoaderRegistry.prepend(modelClass, dataClass, factory);
     return this;
   }
@@ -436,17 +459,24 @@ public Registry register(ImageHeaderParser parser) {
    * @param dataClass  the data class (e.g. {@link java.io.InputStream},
    * {@link java.io.FileDescriptor}).
    */
-  public <Model, Data> Registry replace(Class<Model> modelClass, Class<Data> dataClass,
-      ModelLoaderFactory<Model, Data> factory) {
+  @NonNull
+  public <Model, Data> Registry replace(
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<? extends Model, ? extends Data> factory) {
     modelLoaderRegistry.replace(modelClass, dataClass, factory);
     return this;
   }
 
+  @Nullable
   public <Data, TResource, Transcode> LoadPath<Data, TResource, Transcode> getLoadPath(
-      Class<Data> dataClass, Class<TResource> resourceClass, Class<Transcode> transcodeClass) {
+      @NonNull Class<Data> dataClass, @NonNull Class<TResource> resourceClass,
+      @NonNull Class<Transcode> transcodeClass) {
     LoadPath<Data, TResource, Transcode> result =
         loadPathCache.get(dataClass, resourceClass, transcodeClass);
-    if (result == null && !loadPathCache.contains(dataClass, resourceClass, transcodeClass)) {
+    if (loadPathCache.isEmptyLoadPath(result)) {
+      return null;
+    } else if (result == null) {
       List<DecodePath<Data, TResource, Transcode>> decodePaths =
           getDecodePaths(dataClass, resourceClass, transcodeClass);
       // It's possible there is no way to decode or transcode to the desired types from a given
@@ -454,17 +484,19 @@ public Registry register(ImageHeaderParser parser) {
       if (decodePaths.isEmpty()) {
         result = null;
       } else {
-        result = new LoadPath<>(dataClass, resourceClass, transcodeClass, decodePaths,
-            exceptionListPool);
+        result =
+            new LoadPath<>(
+                dataClass, resourceClass, transcodeClass, decodePaths, throwableListPool);
       }
       loadPathCache.put(dataClass, resourceClass, transcodeClass, result);
     }
     return result;
   }
 
+  @NonNull
   private <Data, TResource, Transcode> List<DecodePath<Data, TResource, Transcode>> getDecodePaths(
-      Class<Data> dataClass, Class<TResource> resourceClass, Class<Transcode> transcodeClass) {
-
+      @NonNull Class<Data> dataClass, @NonNull Class<TResource> resourceClass,
+      @NonNull Class<Transcode> transcodeClass) {
     List<DecodePath<Data, TResource, Transcode>> decodePaths = new ArrayList<>();
     List<Class<TResource>> registeredResourceClasses =
         decoderRegistry.getResourceClasses(dataClass, resourceClass);
@@ -479,15 +511,20 @@ public Registry register(ImageHeaderParser parser) {
             decoderRegistry.getDecoders(dataClass, registeredResourceClass);
         ResourceTranscoder<TResource, Transcode> transcoder =
             transcoderRegistry.get(registeredResourceClass, registeredTranscodeClass);
-        decodePaths.add(new DecodePath<>(dataClass, registeredResourceClass,
-            registeredTranscodeClass, decoders, transcoder, exceptionListPool));
+        @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")
+        DecodePath<Data, TResource, Transcode> path =
+            new DecodePath<>(dataClass, registeredResourceClass, registeredTranscodeClass,
+                decoders, transcoder, throwableListPool);
+        decodePaths.add(path);
       }
     }
     return decodePaths;
   }
 
+  @NonNull
   public <Model, TResource, Transcode> List<Class<?>> getRegisteredResourceClasses(
-      Class<Model> modelClass, Class<TResource> resourceClass, Class<Transcode> transcodeClass) {
+      @NonNull Class<Model> modelClass, @NonNull Class<TResource> resourceClass,
+      @NonNull Class<Transcode> transcodeClass) {
     List<Class<?>> result = modelToResourceClassCache.get(modelClass, resourceClass);
 
     if (result == null) {
@@ -500,7 +537,7 @@ public Registry register(ImageHeaderParser parser) {
           List<Class<Transcode>> registeredTranscodeClasses = transcoderRegistry
               .getTranscodeClasses(registeredResourceClass, transcodeClass);
           if (!registeredTranscodeClasses.isEmpty() && !result.contains(registeredResourceClass)) {
-              result.add(registeredResourceClass);
+            result.add(registeredResourceClass);
           }
         }
       }
@@ -511,11 +548,12 @@ public Registry register(ImageHeaderParser parser) {
     return result;
   }
 
-  public boolean isResourceEncoderAvailable(Resource<?> resource) {
+  public boolean isResourceEncoderAvailable(@NonNull Resource<?> resource) {
     return resourceEncoderRegistry.get(resource.getResourceClass()) != null;
   }
 
-  public <X> ResourceEncoder<X> getResultEncoder(Resource<X> resource)
+  @NonNull
+  public <X> ResourceEncoder<X> getResultEncoder(@NonNull Resource<X> resource)
       throws NoResultEncoderAvailableException {
     ResourceEncoder<X> resourceEncoder = resourceEncoderRegistry.get(resource.getResourceClass());
     if (resourceEncoder != null) {
@@ -524,8 +562,9 @@ public boolean isResourceEncoderAvailable(Resource<?> resource) {
     throw new NoResultEncoderAvailableException(resource.getResourceClass());
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
-  public <X> Encoder<X> getSourceEncoder(X data) throws NoSourceEncoderAvailableException {
+  public <X> Encoder<X> getSourceEncoder(@NonNull X data) throws NoSourceEncoderAvailableException {
     Encoder<X> encoder = encoderRegistry.getEncoder((Class<X>) data.getClass());
     if (encoder != null) {
       return encoder;
@@ -533,11 +572,13 @@ public boolean isResourceEncoderAvailable(Resource<?> resource) {
     throw new NoSourceEncoderAvailableException(data.getClass());
   }
 
-  public <X> DataRewinder<X> getRewinder(X data) {
+  @NonNull
+  public <X> DataRewinder<X> getRewinder(@NonNull X data) {
     return dataRewinderRegistry.build(data);
   }
 
-  public <Model> List<ModelLoader<Model, ?>> getModelLoaders(Model model) {
+  @NonNull
+  public <Model> List<ModelLoader<Model, ?>> getModelLoaders(@NonNull Model model) {
     List<ModelLoader<Model, ?>> result = modelLoaderRegistry.getModelLoaders(model);
     if (result.isEmpty()) {
       throw new NoModelLoaderAvailableException(model);
@@ -545,6 +586,7 @@ public boolean isResourceEncoderAvailable(Resource<?> resource) {
     return result;
   }
 
+  @NonNull
   public List<ImageHeaderParser> getImageHeaderParsers() {
     List<ImageHeaderParser> result = imageHeaderParserRegistry.getParsers();
     if (result.isEmpty()) {
@@ -557,12 +599,15 @@ public boolean isResourceEncoderAvailable(Resource<?> resource) {
    * Thrown when no {@link com.bumptech.glide.load.model.ModelLoader} is registered for a given
    * model class.
    */
+  // Never serialized by Glide.
+  @SuppressWarnings("serial")
   public static class NoModelLoaderAvailableException extends MissingComponentException {
-    public NoModelLoaderAvailableException(Object model) {
+    public NoModelLoaderAvailableException(@NonNull Object model) {
       super("Failed to find any ModelLoaders for model: " + model);
     }
 
-    public NoModelLoaderAvailableException(Class<?> modelClass, Class<?> dataClass) {
+    public NoModelLoaderAvailableException(@NonNull Class<?> modelClass,
+        @NonNull Class<?> dataClass) {
       super("Failed to find any ModelLoaders for model: " + modelClass + " and data: " + dataClass);
     }
   }
@@ -570,17 +615,24 @@ public NoModelLoaderAvailableException(Class<?> modelClass, Class<?> dataClass)
   /**
    * Thrown when no {@link ResourceEncoder} is registered for a given resource class.
    */
+  // Never serialized by Glide.
+  @SuppressWarnings("serial")
   public static class NoResultEncoderAvailableException extends MissingComponentException {
-    public NoResultEncoderAvailableException(Class<?> resourceClass) {
-      super("Failed to find result encoder for resource class: " + resourceClass);
+    public NoResultEncoderAvailableException(@NonNull Class<?> resourceClass) {
+      super("Failed to find result encoder for resource class: " + resourceClass
+          + ", you may need to consider registering a new Encoder for the requested type or"
+          + " DiskCacheStrategy.DATA/DiskCacheStrategy.NONE if caching your transformed resource is"
+          + " unnecessary.");
     }
   }
 
   /**
    * Thrown when no {@link Encoder} is registered for a given data class.
    */
+  // Never serialized by Glide.
+  @SuppressWarnings("serial")
   public static class NoSourceEncoderAvailableException extends MissingComponentException {
-    public NoSourceEncoderAvailableException(Class<?> dataClass) {
+    public NoSourceEncoderAvailableException(@NonNull Class<?> dataClass) {
       super("Failed to find source encoder for data class: " + dataClass);
     }
   }
@@ -588,8 +640,10 @@ public NoSourceEncoderAvailableException(Class<?> dataClass) {
   /**
    * Thrown when some necessary component is missing for a load.
    */
+  // Never serialized by Glide.
+  @SuppressWarnings("serial")
   public static class MissingComponentException extends RuntimeException {
-    public MissingComponentException(String message) {
+    public MissingComponentException(@NonNull String message) {
       super(message);
     }
   }
@@ -597,6 +651,8 @@ public MissingComponentException(String message) {
   /**
    * Thrown when no {@link ImageHeaderParser} is registered.
    */
+  // Never serialized by Glide.
+  @SuppressWarnings("serial")
   public static final class NoImageHeaderParserException extends MissingComponentException {
     public NoImageHeaderParserException() {
       super("Failed to find image header parser.");
diff --git a/library/src/main/java/com/bumptech/glide/RequestBuilder.java b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
index 55b044f0a..3f8056407 100644
--- a/library/src/main/java/com/bumptech/glide/RequestBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
@@ -1,13 +1,22 @@
 package com.bumptech.glide;
 
+import static com.bumptech.glide.request.RequestOptions.diskCacheStrategyOf;
 import static com.bumptech.glide.request.RequestOptions.signatureOf;
+import static com.bumptech.glide.request.RequestOptions.skipMemoryCacheOf;
 
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
 import android.net.Uri;
 import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
 import android.widget.ImageView;
+import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.request.ErrorRequestCoordinator;
 import com.bumptech.glide.request.FutureTarget;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.RequestCoordinator;
@@ -18,13 +27,13 @@
 import com.bumptech.glide.request.ThumbnailRequestCoordinator;
 import com.bumptech.glide.request.target.PreloadTarget;
 import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.request.target.ViewTarget;
 import com.bumptech.glide.signature.ApplicationVersionSignature;
-import com.bumptech.glide.signature.ObjectKey;
 import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
 import java.io.File;
 import java.net.URL;
-import java.util.UUID;
 
 /**
  * A generic class that can handle setting options and staring loads for generic resource types.
@@ -32,17 +41,21 @@
  * @param <TranscodeType> The type of resource that will be delivered to the
  * {@link com.bumptech.glide.request.target.Target}.
  */
-public class RequestBuilder<TranscodeType> implements Cloneable {
+// Public API.
+@SuppressWarnings({"unused", "WeakerAccess"})
+public class RequestBuilder<TranscodeType> implements Cloneable,
+    ModelTypes<RequestBuilder<TranscodeType>> {
   // Used in generated subclasses
   protected static final RequestOptions DOWNLOAD_ONLY_OPTIONS =
       new RequestOptions().diskCacheStrategy(DiskCacheStrategy.DATA).priority(Priority.LOW)
           .skipMemoryCache(true);
 
-  private final GlideContext context;
+  private final Context context;
   private final RequestManager requestManager;
   private final Class<TranscodeType> transcodeClass;
   private final RequestOptions defaultRequestOptions;
   private final Glide glide;
+  private final GlideContext glideContext;
 
   @NonNull protected RequestOptions requestOptions;
 
@@ -55,42 +68,54 @@
   // than relying on model not to be null.
   @Nullable private RequestListener<TranscodeType> requestListener;
   @Nullable private RequestBuilder<TranscodeType> thumbnailBuilder;
+  @Nullable private RequestBuilder<TranscodeType> errorBuilder;
   @Nullable private Float thumbSizeMultiplier;
   private boolean isDefaultTransitionOptionsSet = true;
   private boolean isModelSet;
   private boolean isThumbnailBuilt;
 
   protected RequestBuilder(Glide glide, RequestManager requestManager,
-      Class<TranscodeType> transcodeClass) {
+      Class<TranscodeType> transcodeClass, Context context) {
     this.glide = glide;
     this.requestManager = requestManager;
-    this.context = glide.getGlideContext();
     this.transcodeClass = transcodeClass;
     this.defaultRequestOptions = requestManager.getDefaultRequestOptions();
+    this.context = context;
     this.transitionOptions = requestManager.getDefaultTransitionOptions(transcodeClass);
     this.requestOptions = defaultRequestOptions;
+    this.glideContext = glide.getGlideContext();
   }
 
   protected RequestBuilder(Class<TranscodeType> transcodeClass, RequestBuilder<?> other) {
-    this(other.glide, other.requestManager, transcodeClass);
+    this(other.glide, other.requestManager, transcodeClass, other.context);
     model = other.model;
     isModelSet = other.isModelSet;
     requestOptions = other.requestOptions;
   }
 
   /**
-   * Applies the given options to the request, options set or unset in the given options will
-   * replace those previously set in options in this class.
+   * Applies the given options to the request.
+   *
+   * <p>As with {@link RequestOptions#apply(RequestOptions)}, {@code #apply} only replaces those
+   * values that are explicitly set in the given {@link RequestOptions} object. If you need to
+   * completely reset all previously set options, create a new {@code RequestBuilder} instead of
+   * using this method.
    *
    * @see RequestOptions#apply(RequestOptions)
    * @return This request builder.
    */
+  @NonNull
+  @CheckResult
   public RequestBuilder<TranscodeType> apply(@NonNull RequestOptions requestOptions) {
     Preconditions.checkNotNull(requestOptions);
     this.requestOptions = getMutableOptions().apply(requestOptions);
     return this;
   }
 
+  // We're checking to see if we need to clone our options object because we want to make sure the
+  // original is never modified, so we need reference equality.
+  @SuppressWarnings("ReferenceEquality")
+  @NonNull
   protected RequestOptions getMutableOptions() {
     return defaultRequestOptions == this.requestOptions
         ? this.requestOptions.clone() : this.requestOptions;
@@ -105,6 +130,8 @@ protected RequestOptions getMutableOptions() {
    *
    * @return This request builder.
    */
+  @NonNull
+  @CheckResult
   public RequestBuilder<TranscodeType> transition(
       @NonNull TransitionOptions<?, ? super TranscodeType> transitionOptions) {
     this.transitionOptions = Preconditions.checkNotNull(transitionOptions);
@@ -113,13 +140,15 @@ protected RequestOptions getMutableOptions() {
   }
 
   /**
-   * Sets a RequestBuilder listener to monitor the resource load. It's best to create a single
+   * Sets a {@link RequestListener} to monitor the resource load. It's best to create a single
    * instance of an exception handler per type of request (usually activity/fragment) rather than
    * pass one in per request to avoid some redundant object allocation.
    *
    * @param requestListener The request listener to use.
    * @return This request builder.
    */
+  @NonNull
+  @CheckResult
   @SuppressWarnings("unchecked")
   public RequestBuilder<TranscodeType> listener(
       @Nullable RequestListener<TranscodeType> requestListener) {
@@ -128,6 +157,34 @@ protected RequestOptions getMutableOptions() {
     return this;
   }
 
+  /**
+   * Sets a {@link RequestBuilder} that is built and run iff the load started by this
+   * {@link RequestBuilder} fails.
+   *
+   * <p>If this {@link RequestBuilder} uses a thumbnail that succeeds the given error
+   * {@link RequestBuilder} will be started anyway if the non-thumbnail request fails.
+   *
+   * <p>Recursive calls to this method as well as calls to {@link #thumbnail(float)} and
+   * {@link #thumbnail(RequestBuilder)} are supported for the given error {@link RequestBuilder}.
+   *
+   * <p>Unlike {@link #thumbnail(RequestBuilder)} and {@link #thumbnail(float)}, no options from
+   * this primary {@link RequestBuilder} are propagated to the given error {@link RequestBuilder}.
+   * Options like priority, override widths and heights and transitions must be applied
+   * independently to the error builder.
+   *
+   * <p>The given {@link RequestBuilder} will start and potentially override a fallback drawable
+   * if it's set on this {@link RequestBuilder} via
+   * {@link RequestOptions#fallback(android.graphics.drawable.Drawable)} or
+   * {@link RequestOptions#fallback(int)}.
+   *
+   * @return This {@link RequestBuilder}.
+   */
+  @NonNull
+  public RequestBuilder<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> errorBuilder) {
+    this.errorBuilder = errorBuilder;
+    return this;
+  }
+
   /**
    * Loads and displays the resource retrieved by the given thumbnail request if it finishes before
    * this request. Best used for loading thumbnail resources that are smaller and will be loaded
@@ -135,12 +192,19 @@ protected RequestOptions getMutableOptions() {
    * requests will actually finish. However, if the thumb request completes after the full request,
    * the thumb resource will never replace the full resource.
    *
-   * @param thumbnailRequest The request to use to load the thumbnail.
-   * @return This request builder.
+   * <p>Recursive calls to thumbnail are supported.
+   *
+   * <p>Overrides any previous calls to this method, {@link #thumbnail(float)} and
+   * {@link #thumbnail(RequestBuilder[])}.
+   *
    * @see #thumbnail(float)
+   * @see #thumbnail(RequestBuilder[])
    *
-   * <p> Recursive calls to thumbnail are supported. </p>
+   * @param thumbnailRequest The request to use to load the thumbnail.
+   * @return This request builder.
    */
+  @NonNull
+  @CheckResult
   @SuppressWarnings("unchecked")
   public RequestBuilder<TranscodeType> thumbnail(
       @Nullable RequestBuilder<TranscodeType> thumbnailRequest) {
@@ -149,30 +213,99 @@ protected RequestOptions getMutableOptions() {
     return this;
   }
 
+  /**
+   * Recursively applies {@link #thumbnail(RequestBuilder)} so that the {@link RequestBuilder}s are
+   * loaded as thumbnails in the given priority order.
+   *
+   * <p>{@link #thumbnail(RequestBuilder)} is applied in the order given so that the
+   * {@link RequestBuilder} at position 0 has the {@link RequestBuilder} at position 1 applied
+   * as using its thumbnail method, the {@link RequestBuilder} at position 1 has the
+   * {@link RequestBuilder} at position 2 applied using its thumbnail method and so on.
+   *
+   * <p>Calling this method with an {@code null} array of {@link RequestBuilder} thumbnails or
+   * an empty array of {@link RequestBuilder} thumbnails is equivalent to calling
+   * {@link #thumbnail(RequestBuilder)} with {@code null}.
+   *
+   * <p>Any individual {@link RequestBuilder} in the array of thumbnails provided here may be
+   * {@code null}. {@code null} {@link RequestBuilder}s are ignored and excluded from the recursive
+   * chain.
+   *
+   * <p>The {@link RequestBuilder} objects provided here may be mutated and have any previous
+   * calls to this method or {@link #thumbnail(RequestBuilder)} methods overridden.
+   *
+   * <p>Overrides any previous calls to {@link #thumbnail(RequestBuilder)},
+   * {@link #thumbnail(float)} and this method.
+   *
+   * @see #thumbnail(float)
+   * @see #thumbnail(RequestBuilder)
+   *
+   * @return This request builder.
+   */
+  @SuppressWarnings({"CheckResult", "unchecked"})
+  @NonNull
+  @CheckResult
+  public RequestBuilder<TranscodeType> thumbnail(
+      @Nullable RequestBuilder<TranscodeType>... thumbnails) {
+    if (thumbnails == null || thumbnails.length == 0) {
+      return thumbnail((RequestBuilder<TranscodeType>) null);
+    }
+
+    RequestBuilder<TranscodeType> previous = null;
+
+    // Start with the lowest priority thumbnail so that we can safely handle mutations if
+    // autoClone() is enabled by assigning the result of calling thumbnail() during the iteration.
+    // Starting with the highest priority thumbnail would prevent us from assigning the result of
+    // thumbnail because the mutated request wouldn't be used in the next iteration.
+    for (int i = thumbnails.length - 1; i >= 0; i--) {
+      RequestBuilder<TranscodeType> current = thumbnails[i];
+      // Ignore null thumbnails.
+      if (current == null) {
+        continue;
+      }
+
+      if (previous == null) {
+        // If we don't yet have our first non-null request, set it and continue.
+        previous = current;
+      } else {
+        // Otherwise make our next lowest priority request the thumbnail of our current request.
+        previous = current.thumbnail(previous);
+      }
+    }
+    return thumbnail(previous);
+  }
+
   /**
    * Loads a resource in an identical manner to this request except with the dimensions of the
    * target multiplied by the given size multiplier. If the thumbnail load completes before the full
    * size load, the thumbnail will be shown. If the thumbnail load completes after the full size
    * load, the thumbnail will not be shown.
    *
-   * <p> Note - The thumbnail resource will be smaller than the size requested so the target (or
+   * <p>Note - The thumbnail resource will be smaller than the size requested so the target (or
    * {@link ImageView}) must be able to scale the thumbnail appropriately. See
-   * {@link android.widget.ImageView.ScaleType}. </p>
+   * {@link android.widget.ImageView.ScaleType}.
    *
-   * <p> Almost all options will be copied from the original load, including the {@link
+   * <p>Almost all options will be copied from the original load, including the {@link
    * com.bumptech.glide.load.model.ModelLoader}, {@link com.bumptech.glide.load.ResourceDecoder},
    * and {@link com.bumptech.glide.load.Transformation}s. However,
    * {@link com.bumptech.glide.request.RequestOptions#placeholder(int)} and
    * {@link com.bumptech.glide.request.RequestOptions#error(int)}, and
    * {@link #listener(RequestListener)} will only be used on the full size load and will not be
-   * copied for the thumbnail load. </p>
+   * copied for the thumbnail load.
+   *
+   * <p>Recursive calls to thumbnail are supported.
+   *
+   * <p>Overrides any previous calls to this method, {@link #thumbnail(RequestBuilder[])},
+   *  and {@link #thumbnail(RequestBuilder)}.
    *
-   * <p> Recursive calls to thumbnail are supported. </p>
+   * @see #thumbnail(RequestBuilder)
+   * @see #thumbnail(RequestBuilder[])
    *
    * @param sizeMultiplier The multiplier to apply to the {@link Target}'s dimensions when loading
    *                       the thumbnail.
    * @return This request builder.
    */
+  @NonNull
+  @CheckResult
   @SuppressWarnings("unchecked")
   public RequestBuilder<TranscodeType> thumbnail(float sizeMultiplier) {
     if (sizeMultiplier < 0f || sizeMultiplier > 1f) {
@@ -186,25 +319,79 @@ protected RequestOptions getMutableOptions() {
   /**
    * Sets the specific model to load data for.
    *
-   * <p> This method must be called at least once before
-   * {@link #into(com.bumptech.glide.request.target.Target)} is called. </p>
-   *
    * @param model The model to load data for, or null.
    * @return This request builder.
    */
+  @NonNull
+  @CheckResult
   @SuppressWarnings("unchecked")
+  @Override
   public RequestBuilder<TranscodeType> load(@Nullable Object model) {
     return loadGeneric(model);
   }
 
+  @NonNull
   private RequestBuilder<TranscodeType> loadGeneric(@Nullable Object model) {
     this.model = model;
     isModelSet = true;
     return this;
   }
+  /**
+   * Returns an object to load the given {@link Bitmap}.
+   *
+   * <p>It's almost always better to allow Glide to load {@link Bitmap}s than
+   * pass {@link Bitmap}s into Glide. If you have a custom way to obtain {@link Bitmap}s that is
+   * not supported by Glide by default, consider registering a custom
+   * {@link com.bumptech.glide.load.model.ModelLoader} or
+   * {@link com.bumptech.glide.load.ResourceDecoder} instead of using this method.
+   *
+   * <p>The {@link DiskCacheStrategy} is set to {@link DiskCacheStrategy#NONE}. Previous calls to
+   * {@link #apply(RequestOptions)} or previously applied {@link DiskCacheStrategy}s will be
+   * overridden by this method. Applying an {@link DiskCacheStrategy} other than
+   * {@link DiskCacheStrategy#NONE} after calling this method may result in undefined behavior.
+   *
+   * <p>In memory caching relies on Object equality. The contents of the {@link Bitmap}s are not
+   * compared.
+   *
+   * @see #load(Object)
+   */
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<TranscodeType> load(@Nullable Bitmap bitmap) {
+    return loadGeneric(bitmap)
+        .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
+  }
+
+  /**
+   * Returns a request builder to load the given {@link Drawable}.
+   *
+   * <p>It's almost always better to allow Glide to load {@link Bitmap}s than to pass
+   * {@link Bitmap}s into Glide using this method . If you have a custom way to obtain
+   * {@link Bitmap}s that is not supported by Glide by default, consider registering a custom
+   * {@link com.bumptech.glide.load.model.ModelLoader} or
+   * {@link com.bumptech.glide.load.ResourceDecoder} instead of using this method.
+   *
+   * <p>The {@link DiskCacheStrategy} is set to {@link DiskCacheStrategy#NONE}. Previous calls to
+   * {@link #apply(RequestOptions)} or previously applied {@link DiskCacheStrategy}s will be
+   * overridden by this method. Applying an {@link DiskCacheStrategy} other than
+   * {@link DiskCacheStrategy#NONE} after calling this method may result in undefined behavior.
+   *
+   * <p>In memory caching relies on Object equality. The contents of the {@link Drawable}s are not
+   * compared.
+   *
+   * @see #load(Object)
+   */
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<TranscodeType> load(@Nullable Drawable drawable) {
+    return loadGeneric(drawable)
+        .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
+  }
 
   /**
-   * Returns a request builder to load the given {@link java.lang.String}. signature.
+   * Returns a request builder to load the given {@link java.lang.String}.
    *
    * <p> Note - this method caches data using only the given String as the cache key. If the data is
    * a Uri outside of your control, or you otherwise expect the data represented by the given String
@@ -222,6 +409,9 @@ protected RequestOptions getMutableOptions() {
    * @param string A file path, or a uri or url handled by
    * {@link com.bumptech.glide.load.model.UriLoader}.
    */
+  @NonNull
+  @Override
+  @CheckResult
   public RequestBuilder<TranscodeType> load(@Nullable String string) {
     return loadGeneric(string);
   }
@@ -244,6 +434,9 @@ protected RequestOptions getMutableOptions() {
    * @param uri The Uri representing the image. Must be of a type handled by
    * {@link com.bumptech.glide.load.model.UriLoader}.
    */
+  @NonNull
+  @CheckResult
+  @Override
   public RequestBuilder<TranscodeType> load(@Nullable Uri uri) {
     return loadGeneric(uri);
   }
@@ -251,7 +444,7 @@ protected RequestOptions getMutableOptions() {
   /**
    * Returns a request builder to load the given {@link File}.
    *
-   * <p> Note - this method caches data for Files using only the file path itself as the cache key.
+   * <p>Note - this method caches data for Files using only the file path itself as the cache key.
    * The data in the File can change so using this method can lead to displaying stale data. If you
    * expect the data in the File to change, Consider using
    * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)}
@@ -260,23 +453,25 @@ protected RequestOptions getMutableOptions() {
    * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
    * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
    * appropriate.
-   * </p>
    *
    * @see #load(Object)
    *
    * @param file The File containing the image
    */
+  @NonNull
+  @CheckResult
+  @Override
   public RequestBuilder<TranscodeType> load(@Nullable File file) {
     return loadGeneric(file);
   }
 
   /**
-   * Returns a request builder to load the given resource id. Returns a request builder that uses
-   * the {@link com.bumptech.glide.load.model.ModelLoaderFactory} currently registered or
+   * Returns a request builder that uses the
+   * {@link com.bumptech.glide.load.model.ModelLoaderFactory} currently registered or
    * {@link Integer} to load the image represented by the given {@link Integer} resource id.
    * Defaults to {@link com.bumptech.glide.load.model.ResourceLoader} to load resource id models.
    *
-   * <p> By default this method adds a version code based signature to the cache key used to cache
+   * <p>By default this method adds a version code based signature to the cache key used to cache
    * this resource in Glide. This signature is sufficient to guarantee that end users will see the
    * most up to date versions of your Drawables, but during development if you do not increment your
    * version code before each install and you replace a Drawable with different data without
@@ -284,12 +479,28 @@ protected RequestOptions getMutableOptions() {
    * using {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} via
    * {@link RequestOptions#diskCacheStrategy(com.bumptech.glide.load.engine.DiskCacheStrategy)}
    * during development, and re-enabling the default
-   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESOURCE} for release builds. </p>
+   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESOURCE} for release builds.
+   *
+   * <p>This method will load non-{@link android.graphics.Bitmap} resources like
+   * {@link android.graphics.drawable.VectorDrawable}s. Although Glide makes a best effort to apply
+   * {@link com.bumptech.glide.load.Transformation}s to these {@link Drawable}s by either extracting
+   * the underlying {@link Bitmap} or by converting the {@link Drawable} to a {@link Bitmap}, Glide
+   * is still not able to transform all types of resources. Animated {@link Drawable}s cannot be
+   * transformed (other than {@link com.bumptech.glide.load.resource.gif.GifDrawable}). To avoid
+   * load failures if a {@link Drawable} can't be transformed, use the optional transformation
+   * methods like {@link RequestOptions#optionalTransform(Class, Transformation)}.
+   *
+   * <p>In some cases converting {@link Drawable}s to {@link Bitmap}s may be inefficient. Use this
+   * method, especially in conjunction with {@link com.bumptech.glide.load.Transformation}s with
+   * caution for non-{@link Bitmap} {@link Drawable}s.
    *
    * @see #load(Integer)
    * @see com.bumptech.glide.signature.ApplicationVersionSignature
    */
-  public RequestBuilder<TranscodeType> load(@Nullable Integer resourceId) {
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer resourceId) {
     return loadGeneric(resourceId).apply(signatureOf(ApplicationVersionSignature.obtain(context)));
   }
 
@@ -298,11 +509,13 @@ protected RequestOptions getMutableOptions() {
    *
    * @param url The URL representing the image.
    * @see #load(Object)
-   * @deprecated The {@link java.net.URL} class has <a href="http://goo.gl/c4hHNu">a number of
-   * performance problems</a> and should generally be avoided when possible. Prefer
-   * {@link #load(android.net.Uri)} or {@link #load(String)}.
+   * @deprecated The {@link java.net.URL} class has
+   * <a href="http://goo.gl/c4hHNu">a number of performance problems</a> and should generally be
+   * avoided when possible. Prefer {@link #load(android.net.Uri)} or {@link #load(String)}.
    */
   @Deprecated
+  @CheckResult
+  @Override
   public RequestBuilder<TranscodeType> load(@Nullable URL url) {
     return loadGeneric(url);
   }
@@ -310,15 +523,23 @@ protected RequestOptions getMutableOptions() {
   /**
    * Returns a request to load the given byte array.
    *
-   * <p> Note - by default loads for bytes are not cached in either the memory or the disk cache.
-   * </p>
+   * <p>Note - by default loads for bytes are not cached in either the memory or the disk cache.
    *
    * @param model the data to load.
    * @see #load(Object)
    */
+  @NonNull
+  @CheckResult
+  @Override
   public RequestBuilder<TranscodeType> load(@Nullable byte[] model) {
-    return loadGeneric(model).apply(signatureOf(new ObjectKey(UUID.randomUUID().toString()))
-        .diskCacheStrategy(DiskCacheStrategy.NONE).skipMemoryCache(true /*skipMemoryCache*/));
+    RequestBuilder<TranscodeType> result = loadGeneric(model);
+    if (!result.requestOptions.isDiskCacheStrategySet()) {
+        result = result.apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
+    }
+    if (!result.requestOptions.isSkipMemoryCacheSet()) {
+      result = result.apply(skipMemoryCacheOf(true /*skipMemoryCache*/));
+    }
+    return result;
   }
 
   /**
@@ -329,7 +550,11 @@ protected RequestOptions getMutableOptions() {
    * arguments, the current model is not copied copied so changes to the model will affect both
    * builders. </p>
    */
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings({
+      "unchecked",
+      // we don't want to throw to be user friendly
+      "PMD.CloneThrowsCloneNotSupportedException"
+  })
   @CheckResult
   @Override
   public RequestBuilder<TranscodeType> clone() {
@@ -350,11 +575,22 @@ protected RequestOptions getMutableOptions() {
    * @return The given target.
    * @see RequestManager#clear(Target)
    */
+  @NonNull
   public <Y extends Target<TranscodeType>> Y into(@NonNull Y target) {
-    return into(target, getMutableOptions());
+    return into(target, /*targetListener=*/ null);
   }
 
-  private <Y extends Target<TranscodeType>> Y into(@NonNull Y target, RequestOptions options) {
+  @NonNull
+  @Synthetic <Y extends Target<TranscodeType>> Y into(
+      @NonNull Y target,
+      @Nullable RequestListener<TranscodeType> targetListener) {
+    return into(target, targetListener, getMutableOptions());
+  }
+
+  private <Y extends Target<TranscodeType>> Y into(
+      @NonNull Y target,
+      @Nullable RequestListener<TranscodeType> targetListener,
+      @NonNull RequestOptions options) {
     Util.assertMainThread();
     Preconditions.checkNotNull(target);
     if (!isModelSet) {
@@ -362,16 +598,20 @@ protected RequestOptions getMutableOptions() {
     }
 
     options = options.autoClone();
-    Request request = buildRequest(target, options);
+    Request request = buildRequest(target, targetListener, options);
 
     Request previous = target.getRequest();
-    if (request.isEquivalentTo(previous)) {
+    if (request.isEquivalentTo(previous)
+        && !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) {
       request.recycle();
       // If the request is completed, beginning again will ensure the result is re-delivered,
       // triggering RequestListeners and Targets. If the request is failed, beginning again will
       // restart the request, giving it another chance to complete. If the request is already
       // running, we can let it continue running without interruption.
       if (!Preconditions.checkNotNull(previous).isRunning()) {
+        // Use the previous request rather than the new one to allow for optimizations like skipping
+        // setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions
+        // that are done in the individual Request.
         previous.begin();
       }
       return target;
@@ -384,6 +624,15 @@ protected RequestOptions getMutableOptions() {
     return target;
   }
 
+  // If the caller is using skipMemoryCache and the previous request is finished, calling begin on
+  // the previous request will complete from memory because it will just use the resource that had
+  // already been loaded. If the previous request isn't complete, we can wait for it to finish
+  // because the previous request must also be using skipMemoryCache for the requests to be
+  // equivalent. See #2663 for additional context.
+  private boolean isSkipMemoryCacheWithCompletePreviousRequest(
+      RequestOptions options, Request previous) {
+    return !options.isMemoryCacheable() && previous.isComplete();
+  }
 
   /**
    * Sets the {@link ImageView} the resource will be loaded into, cancels any existing loads into
@@ -396,7 +645,8 @@ protected RequestOptions getMutableOptions() {
    * @return The
    * {@link com.bumptech.glide.request.target.Target} used to wrap the given {@link ImageView}.
    */
-  public Target<TranscodeType> into(ImageView view) {
+  @NonNull
+  public ViewTarget<ImageView, TranscodeType> into(@NonNull ImageView view) {
     Util.assertMainThread();
     Preconditions.checkNotNull(view);
 
@@ -429,7 +679,10 @@ protected RequestOptions getMutableOptions() {
       }
     }
 
-    return into(context.buildImageViewTarget(view, transcodeClass), requestOptions);
+    return into(
+        glideContext.buildImageViewTarget(view, transcodeClass),
+        /*targetListener=*/ null,
+        requestOptions);
   }
 
   /**
@@ -464,6 +717,7 @@ protected RequestOptions getMutableOptions() {
    * @see #submit(int, int)
    * @see #into(Target)
    */
+  @NonNull
   public FutureTarget<TranscodeType> submit() {
     return submit(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
   }
@@ -480,21 +734,22 @@ protected RequestOptions getMutableOptions() {
    *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
    *               previously called).
    */
+  @NonNull
   public FutureTarget<TranscodeType> submit(int width, int height) {
     final RequestFutureTarget<TranscodeType> target =
-        new RequestFutureTarget<>(context.getMainHandler(), width, height);
+        new RequestFutureTarget<>(glideContext.getMainHandler(), width, height);
 
     if (Util.isOnBackgroundThread()) {
-      context.getMainHandler().post(new Runnable() {
+      glideContext.getMainHandler().post(new Runnable() {
         @Override
         public void run() {
           if (!target.isCancelled()) {
-            into(target);
+            into(target, target);
           }
         }
       });
     } else {
-      into(target);
+      into(target, target);
     }
 
     return target;
@@ -518,6 +773,7 @@ public void run() {
    * {@link RequestManager#clear(Target)}.
    * @see com.bumptech.glide.ListPreloader
    */
+  @NonNull
   public Target<TranscodeType> preload(int width, int height) {
     final PreloadTarget<TranscodeType> target = PreloadTarget.obtain(requestManager, width, height);
     return into(target);
@@ -532,6 +788,7 @@ public void run() {
    * {@link RequestManager#clear(Target)}
    * @see #preload(int, int)
    */
+  @NonNull
   public Target<TranscodeType> preload() {
     return preload(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
   }
@@ -548,7 +805,7 @@ public void run() {
    */
   @Deprecated
   @CheckResult
-  public <Y extends Target<File>> Y downloadOnly(Y target) {
+  public <Y extends Target<File>> Y downloadOnly(@NonNull Y target) {
     return getDownloadOnlyRequest().into(target);
   }
 
@@ -570,12 +827,14 @@ public void run() {
     return getDownloadOnlyRequest().submit(width, height);
   }
 
+  @NonNull
   @CheckResult
   protected RequestBuilder<File> getDownloadOnlyRequest() {
     return new RequestBuilder<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
   }
 
-  private Priority getThumbnailPriority(Priority current) {
+  @NonNull
+  private Priority getThumbnailPriority(@NonNull Priority current) {
     switch (current) {
       case LOW:
         return Priority.NORMAL;
@@ -589,15 +848,83 @@ private Priority getThumbnailPriority(Priority current) {
     }
   }
 
-  private Request buildRequest(Target<TranscodeType> target, RequestOptions requestOptions) {
-    return buildRequestRecursive(target, null, transitionOptions, requestOptions.getPriority(),
-        requestOptions.getOverrideWidth(), requestOptions.getOverrideHeight(), requestOptions);
+  private Request buildRequest(
+      Target<TranscodeType> target,
+      @Nullable RequestListener<TranscodeType> targetListener,
+      RequestOptions requestOptions) {
+    return buildRequestRecursive(
+        target,
+        targetListener,
+        /*parentCoordinator=*/ null,
+        transitionOptions,
+        requestOptions.getPriority(),
+        requestOptions.getOverrideWidth(),
+        requestOptions.getOverrideHeight(),
+        requestOptions);
+  }
+
+  private Request buildRequestRecursive(
+      Target<TranscodeType> target,
+      @Nullable RequestListener<TranscodeType> targetListener,
+      @Nullable RequestCoordinator parentCoordinator,
+      TransitionOptions<?, ? super TranscodeType> transitionOptions,
+      Priority priority,
+      int overrideWidth,
+      int overrideHeight,
+      RequestOptions requestOptions) {
+
+    // Build the ErrorRequestCoordinator first if necessary so we can update parentCoordinator.
+    ErrorRequestCoordinator errorRequestCoordinator = null;
+    if (errorBuilder != null) {
+      errorRequestCoordinator = new ErrorRequestCoordinator(parentCoordinator);
+      parentCoordinator = errorRequestCoordinator;
+    }
+
+    Request mainRequest =
+        buildThumbnailRequestRecursive(
+            target,
+            targetListener,
+            parentCoordinator,
+            transitionOptions,
+            priority,
+            overrideWidth,
+            overrideHeight,
+            requestOptions);
+
+    if (errorRequestCoordinator == null) {
+      return mainRequest;
+    }
+
+    int errorOverrideWidth = errorBuilder.requestOptions.getOverrideWidth();
+    int errorOverrideHeight = errorBuilder.requestOptions.getOverrideHeight();
+    if (Util.isValidDimensions(overrideWidth, overrideHeight)
+        && !errorBuilder.requestOptions.isValidOverride()) {
+      errorOverrideWidth = requestOptions.getOverrideWidth();
+      errorOverrideHeight = requestOptions.getOverrideHeight();
+    }
+
+    Request errorRequest = errorBuilder.buildRequestRecursive(
+        target,
+        targetListener,
+        errorRequestCoordinator,
+        errorBuilder.transitionOptions,
+        errorBuilder.requestOptions.getPriority(),
+        errorOverrideWidth,
+        errorOverrideHeight,
+        errorBuilder.requestOptions);
+    errorRequestCoordinator.setRequests(mainRequest, errorRequest);
+    return errorRequestCoordinator;
   }
 
-  private Request buildRequestRecursive(Target<TranscodeType> target,
-      @Nullable ThumbnailRequestCoordinator parentCoordinator,
+  private Request buildThumbnailRequestRecursive(
+      Target<TranscodeType> target,
+      RequestListener<TranscodeType> targetListener,
+      @Nullable RequestCoordinator parentCoordinator,
       TransitionOptions<?, ? super TranscodeType> transitionOptions,
-      Priority priority, int overrideWidth, int overrideHeight, RequestOptions requestOptions) {
+      Priority priority,
+      int overrideWidth,
+      int overrideHeight,
+      RequestOptions requestOptions) {
     if (thumbnailBuilder != null) {
       // Recursive case: contains a potentially recursive thumbnail request builder.
       if (isThumbnailBuilt) {
@@ -626,13 +953,22 @@ private Request buildRequestRecursive(Target<TranscodeType> target,
       }
 
       ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
-      Request fullRequest = obtainRequest(target, requestOptions, coordinator,
-          transitionOptions, priority, overrideWidth, overrideHeight);
+      Request fullRequest =
+          obtainRequest(
+              target,
+              targetListener,
+              requestOptions,
+              coordinator,
+              transitionOptions,
+              priority,
+              overrideWidth,
+              overrideHeight);
       isThumbnailBuilt = true;
       // Recursively generate thumbnail requests.
       Request thumbRequest =
           thumbnailBuilder.buildRequestRecursive(
               target,
+              targetListener,
               coordinator,
               thumbTransitionOptions,
               thumbPriority,
@@ -645,29 +981,58 @@ private Request buildRequestRecursive(Target<TranscodeType> target,
     } else if (thumbSizeMultiplier != null) {
       // Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse.
       ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
-      Request fullRequest = obtainRequest(target, requestOptions, coordinator, transitionOptions,
-          priority, overrideWidth, overrideHeight);
+      Request fullRequest =
+          obtainRequest(
+              target,
+              targetListener,
+              requestOptions,
+              coordinator,
+              transitionOptions,
+              priority,
+              overrideWidth,
+              overrideHeight);
       RequestOptions thumbnailOptions = requestOptions.clone()
           .sizeMultiplier(thumbSizeMultiplier);
 
-      Request thumbnailRequest = obtainRequest(target, thumbnailOptions, coordinator,
-          transitionOptions, getThumbnailPriority(priority), overrideWidth, overrideHeight);
+      Request thumbnailRequest =
+          obtainRequest(
+              target,
+              targetListener,
+              thumbnailOptions,
+              coordinator,
+              transitionOptions,
+              getThumbnailPriority(priority),
+              overrideWidth,
+              overrideHeight);
 
       coordinator.setRequests(fullRequest, thumbnailRequest);
       return coordinator;
     } else {
       // Base case: no thumbnail.
-      return obtainRequest(target, requestOptions, parentCoordinator, transitionOptions, priority,
-          overrideWidth, overrideHeight);
+      return obtainRequest(
+          target,
+          targetListener,
+          requestOptions,
+          parentCoordinator,
+          transitionOptions,
+          priority,
+          overrideWidth,
+          overrideHeight);
     }
   }
 
-  private Request obtainRequest(Target<TranscodeType> target,
-      RequestOptions requestOptions, RequestCoordinator requestCoordinator,
-      TransitionOptions<?, ? super TranscodeType> transitionOptions, Priority priority,
-      int overrideWidth, int overrideHeight) {
+  private Request obtainRequest(
+      Target<TranscodeType> target,
+      RequestListener<TranscodeType> targetListener,
+      RequestOptions requestOptions,
+      RequestCoordinator requestCoordinator,
+      TransitionOptions<?, ? super TranscodeType> transitionOptions,
+      Priority priority,
+      int overrideWidth,
+      int overrideHeight) {
     return SingleRequest.obtain(
         context,
+        glideContext,
         model,
         transcodeClass,
         requestOptions,
@@ -675,9 +1040,10 @@ private Request obtainRequest(Target<TranscodeType> target,
         overrideHeight,
         priority,
         target,
+        targetListener,
         requestListener,
         requestCoordinator,
-        context.getEngine(),
+        glideContext.getEngine(),
         transitionOptions.getTransitionFactory());
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/RequestManager.java b/library/src/main/java/com/bumptech/glide/RequestManager.java
index 8275cee2c..f05ad0d83 100644
--- a/library/src/main/java/com/bumptech/glide/RequestManager.java
+++ b/library/src/main/java/com/bumptech/glide/RequestManager.java
@@ -7,8 +7,10 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
+import android.net.Uri;
 import android.os.Handler;
 import android.os.Looper;
+import android.support.annotation.CheckResult;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.view.View;
@@ -29,6 +31,7 @@
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
 import java.io.File;
+import java.net.URL;
 
 /**
  * A class for managing and starting requests for Glide. Can use activity, fragment and connectivity
@@ -42,7 +45,8 @@
  * @see Glide#with(android.support.v4.app.Fragment)
  * @see Glide#with(Context)
  */
-public class RequestManager implements LifecycleListener {
+public class RequestManager implements LifecycleListener,
+    ModelTypes<RequestBuilder<Drawable>> {
   private static final RequestOptions DECODE_TYPE_BITMAP = decodeTypeOf(Bitmap.class).lock();
   private static final RequestOptions DECODE_TYPE_GIF = decodeTypeOf(GifDrawable.class).lock();
   private static final RequestOptions DOWNLOAD_ONLY_OPTIONS =
@@ -50,6 +54,7 @@
           .skipMemoryCache(true);
 
   protected final Glide glide;
+  protected final Context context;
   @Synthetic final Lifecycle lifecycle;
   private final RequestTracker requestTracker;
   private final RequestManagerTreeNode treeNode;
@@ -63,11 +68,18 @@ public void run() {
   private final Handler mainHandler = new Handler(Looper.getMainLooper());
   private final ConnectivityMonitor connectivityMonitor;
 
-  @NonNull
   private RequestOptions requestOptions;
 
-  public RequestManager(Glide glide, Lifecycle lifecycle, RequestManagerTreeNode treeNode) {
-    this(glide, lifecycle, treeNode, new RequestTracker(), glide.getConnectivityMonitorFactory());
+  public RequestManager(
+      @NonNull Glide glide, @NonNull Lifecycle lifecycle,
+      @NonNull RequestManagerTreeNode treeNode, @NonNull Context context) {
+    this(
+        glide,
+        lifecycle,
+        treeNode,
+        new RequestTracker(),
+        glide.getConnectivityMonitorFactory(),
+        context);
   }
 
   // Our usage is safe here.
@@ -77,16 +89,18 @@ public RequestManager(Glide glide, Lifecycle lifecycle, RequestManagerTreeNode t
       Lifecycle lifecycle,
       RequestManagerTreeNode treeNode,
       RequestTracker requestTracker,
-      ConnectivityMonitorFactory factory) {
+      ConnectivityMonitorFactory factory,
+      Context context) {
     this.glide = glide;
     this.lifecycle = lifecycle;
     this.treeNode = treeNode;
     this.requestTracker = requestTracker;
-
-    final Context context = glide.getGlideContext().getBaseContext();
+    this.context = context;
 
     connectivityMonitor =
-        factory.build(context, new RequestManagerConnectivityListener(requestTracker));
+        factory.build(
+            context.getApplicationContext(),
+            new RequestManagerConnectivityListener(requestTracker));
 
     // If we're the application level request manager, we may be created on a background thread.
     // In that case we cannot risk synchronously pausing or resuming requests, so we hack around the
@@ -108,7 +122,7 @@ protected void setRequestOptions(@NonNull RequestOptions toSet) {
     requestOptions = toSet.clone().autoClone();
   }
 
-  private void updateRequestOptions(RequestOptions toUpdate) {
+  private void updateRequestOptions(@NonNull RequestOptions toUpdate) {
     requestOptions = requestOptions.apply(toUpdate);
   }
 
@@ -130,7 +144,8 @@ private void updateRequestOptions(RequestOptions toUpdate) {
    *
    * @return This request manager.
    */
-  public RequestManager applyDefaultRequestOptions(RequestOptions requestOptions) {
+  @NonNull
+  public RequestManager applyDefaultRequestOptions(@NonNull RequestOptions requestOptions) {
     updateRequestOptions(requestOptions);
     return this;
   }
@@ -140,9 +155,8 @@ public RequestManager applyDefaultRequestOptions(RequestOptions requestOptions)
    * with the given {@link RequestOptions}.
    *
    * <p>The {@link RequestOptions} provided here replace those that have been previously provided
-   * via {@link GlideBuilder#setDefaultRequestOptions(RequestOptions)}, {@link
-   * #setDefaultRequestOptions(RequestOptions)} and {@link
-   * #applyDefaultRequestOptions(RequestOptions)}.
+   * via this method, {@link GlideBuilder#setDefaultRequestOptions(RequestOptions)}, and
+   * {@link #applyDefaultRequestOptions(RequestOptions)}.
    *
    * <p>Subsequent calls to {@link #applyDefaultRequestOptions(RequestOptions)} will not mutate
    * the {@link RequestOptions} provided here. Instead the manager will create a clone of these
@@ -152,7 +166,8 @@ public RequestManager applyDefaultRequestOptions(RequestOptions requestOptions)
    *
    * @return This request manager.
    */
-  public RequestManager setDefaultRequestOptions(RequestOptions requestOptions) {
+  @NonNull
+  public RequestManager setDefaultRequestOptions(@NonNull RequestOptions requestOptions) {
     setRequestOptions(requestOptions);
     return this;
   }
@@ -193,6 +208,10 @@ public boolean isPaused() {
   /**
    * Cancels any in progress loads, but does not clear resources of completed loads.
    *
+   * <p>Note #{@link #resumeRequests()} must be called for any requests made before or while the
+   * manager is paused to complete. RequestManagers attached to Fragments and Activities
+   * automatically resume onStart().
+   *
    * @see #isPaused()
    * @see #resumeRequests()
    */
@@ -201,6 +220,27 @@ public void pauseRequests() {
     requestTracker.pauseRequests();
   }
 
+  /**
+   * Cancels any in progress loads and clears resources of completed loads.
+   *
+   * <p>Note #{@link #resumeRequests()} must be called for any requests made before or while the
+   * manager is paused to complete. RequestManagers attached to Fragments and Activities
+   * automatically resume onStart().
+   *
+   * <p>This will release the memory used by completed bitmaps but leaves them in any configured
+   * caches. When an #{@link android.app.Activity} receives #{@link
+   * android.app.Activity#onTrimMemory(int)} at a level of #{@link
+   * android.content.ComponentCallbacks2#TRIM_MEMORY_BACKGROUND} this is desirable in order to keep
+   * your process alive longer.
+   *
+   * @see #isPaused()
+   * @see #resumeRequests()
+   */
+  public void pauseAllRequests() {
+    Util.assertMainThread();
+    requestTracker.pauseAllRequests();
+  }
+
   /**
    * Performs {@link #pauseRequests()} recursively for all managers that are contextually
    * descendant to this manager based on the Activity/Fragment hierarchy:
@@ -215,6 +255,8 @@ public void pauseRequests() {
    * <p>Note, on pre-Jelly Bean MR1 calling pause on a Fragment will not cause child fragments to
    * pause, in this case either call pause on the Activity or use a support Fragment.
    */
+  // Public API.
+  @SuppressWarnings({"WeakerAccess", "unused"})
   public void pauseRequestsRecursive() {
     Util.assertMainThread();
     pauseRequests();
@@ -239,6 +281,8 @@ public void resumeRequests() {
    * descendant to this manager based on the Activity/Fragment hierarchy. The hierarchical semantics
    * are identical as for {@link #pauseRequestsRecursive()}.
    */
+  // Public API.
+  @SuppressWarnings("unused")
   public void resumeRequestsRecursive() {
     Util.assertMainThread();
     resumeRequests();
@@ -292,6 +336,8 @@ public void onDestroy() {
    *
    * @return A new request builder for loading a {@link android.graphics.Bitmap}
    */
+  @NonNull
+  @CheckResult
   public RequestBuilder<Bitmap> asBitmap() {
     return as(Bitmap.class).apply(DECODE_TYPE_BITMAP);
   }
@@ -309,6 +355,8 @@ public void onDestroy() {
    * @return A new request builder for loading a
    * {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
    */
+  @NonNull
+  @CheckResult
   public RequestBuilder<GifDrawable> asGif() {
     return as(GifDrawable.class).apply(DECODE_TYPE_GIF);
   }
@@ -323,16 +371,120 @@ public void onDestroy() {
    *
    * @return A new request builder for loading a {@link Drawable}.
    */
+  @NonNull
+  @CheckResult
   public RequestBuilder<Drawable> asDrawable() {
     return as(Drawable.class);
   }
 
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(Bitmap)}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<Drawable> load(@Nullable Bitmap bitmap) {
+    return asDrawable().load(bitmap);
+  }
+
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(Drawable)}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<Drawable> load(@Nullable Drawable drawable) {
+    return asDrawable().load(drawable);
+  }
+
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(String)}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<Drawable> load(@Nullable String string) {
+    return asDrawable().load(string);
+  }
+
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(Uri)}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<Drawable> load(@Nullable Uri uri) {
+    return asDrawable().load(uri);
+  }
+
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(File)}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<Drawable> load(@Nullable File file) {
+    return asDrawable().load(file);
+  }
+
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(Integer)}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @SuppressWarnings("deprecation")
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<Drawable> load(@Nullable Integer resourceId) {
+    return asDrawable().load(resourceId);
+  }
+
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(URL)}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @SuppressWarnings("deprecation")
+  @CheckResult
+  @Override
+  @Deprecated
+  public RequestBuilder<Drawable> load(@Nullable URL url) {
+    return asDrawable().load(url);
+  }
+
+
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(byte[])}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<Drawable> load(@Nullable byte[] model) {
+    return asDrawable().load(model);
+  }
+
   /**
    * A helper method equivalent to calling {@link #asDrawable()} and then {@link
    * RequestBuilder#load(Object)} with the given model.
    *
    * @return A new request builder for loading a {@link Drawable} using the given model.
    */
+  @NonNull
+  @CheckResult
+  @Override
   public RequestBuilder<Drawable> load(@Nullable Object model) {
     return asDrawable().load(model);
   }
@@ -348,6 +500,8 @@ public void onDestroy() {
    *
    * @return A new request builder for downloading content to cache and returning the cache File.
    */
+  @NonNull
+  @CheckResult
   public RequestBuilder<File> downloadOnly() {
     return as(File.class).apply(DOWNLOAD_ONLY_OPTIONS);
   }
@@ -358,6 +512,8 @@ public void onDestroy() {
    *
    * @return A new request builder for loading a {@link Drawable} using the given model.
    */
+  @NonNull
+  @CheckResult
   public RequestBuilder<File> download(@Nullable Object model) {
     return downloadOnly().load(model);
   }
@@ -371,6 +527,8 @@ public void onDestroy() {
    *
    * @return A new request builder for obtaining File paths to content.
    */
+  @NonNull
+  @CheckResult
   public RequestBuilder<File> asFile() {
     return as(File.class).apply(skipMemoryCacheOf(true));
   }
@@ -383,8 +541,11 @@ public void onDestroy() {
    * @param resourceClass The resource to decode.
    * @return A new request builder for loading the given resource class.
    */
-  public <ResourceType> RequestBuilder<ResourceType> as(Class<ResourceType> resourceClass) {
-    return new RequestBuilder<>(glide, this, resourceClass);
+  @NonNull
+  @CheckResult
+  public <ResourceType> RequestBuilder<ResourceType> as(
+      @NonNull Class<ResourceType> resourceClass) {
+    return new RequestBuilder<>(glide, this, resourceClass, context);
   }
 
   /**
@@ -399,7 +560,7 @@ public void onDestroy() {
    *                                  tag.
    * @see #clear(Target)
    */
-  public void clear(View view) {
+  public void clear(@NonNull View view) {
     clear(new ClearTarget(view));
   }
 
@@ -426,14 +587,33 @@ public void run() {
     }
   }
 
-  private void untrackOrDelegate(Target<?> target) {
+  private void untrackOrDelegate(@NonNull Target<?> target) {
     boolean isOwnedByUs = untrack(target);
-    if (!isOwnedByUs) {
-      glide.removeFromManagers(target);
+    // We'll end up here if the Target was cleared after the RequestManager that started the request
+    // is destroyed. That can happen for at least two reasons:
+    // 1. We call clear() on a background thread using something other than Application Context
+    // RequestManager.
+    // 2. The caller retains a reference to the RequestManager after the corresponding Activity or
+    // Fragment is destroyed, starts a load with it, and then clears that load with a different
+    // RequestManager. Callers seem especially likely to do this in retained Fragments (#2262).
+    //
+    // #1 is always an error. At best the caller is leaking memory briefly in something like an
+    // AsyncTask. At worst the caller is leaking an Activity or Fragment for a sustained period of
+    // time if they do something like reference the Activity RequestManager in a long lived
+    // background thread or task.
+    //
+    // #2 is always an error. Callers shouldn't be starting new loads using RequestManagers after
+    // the corresponding Activity or Fragment is destroyed because retaining any reference to the
+    // RequestManager leaks memory. It's possible that there's some brief period of time during or
+    // immediately after onDestroy where this is reasonable, but I can't think of why.
+    if (!isOwnedByUs && !glide.removeFromManagers(target) && target.getRequest() != null) {
+      Request request = target.getRequest();
+      target.setRequest(null);
+      request.clear();
     }
   }
 
-  boolean untrack(Target<?> target) {
+  boolean untrack(@NonNull Target<?> target) {
     Request request = target.getRequest();
     // If the Target doesn't have a request, it's already been cleared.
     if (request == null) {
@@ -449,7 +629,7 @@ boolean untrack(Target<?> target) {
     }
   }
 
-  void track(Target<?> target, Request request) {
+  void track(@NonNull Target<?> target, @NonNull Request request) {
     targetTracker.track(target);
     requestTracker.runRequest(request);
   }
@@ -472,7 +652,7 @@ public String toString() {
       .ConnectivityListener {
     private final RequestTracker requestTracker;
 
-    public RequestManagerConnectivityListener(RequestTracker requestTracker) {
+    RequestManagerConnectivityListener(@NonNull RequestTracker requestTracker) {
       this.requestTracker = requestTracker;
     }
 
@@ -486,12 +666,13 @@ public void onConnectivityChanged(boolean isConnected) {
 
   private static class ClearTarget extends ViewTarget<View, Object> {
 
-    public ClearTarget(View view) {
+    ClearTarget(@NonNull View view) {
       super(view);
     }
 
     @Override
-    public void onResourceReady(Object resource, Transition<? super Object> transition) {
+    public void onResourceReady(@NonNull Object resource,
+        @Nullable Transition<? super Object> transition) {
       // Do nothing.
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/TransitionOptions.java b/library/src/main/java/com/bumptech/glide/TransitionOptions.java
index 7768f6fcc..ce2cfe469 100644
--- a/library/src/main/java/com/bumptech/glide/TransitionOptions.java
+++ b/library/src/main/java/com/bumptech/glide/TransitionOptions.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.request.transition.NoTransition;
 import com.bumptech.glide.request.transition.TransitionFactory;
 import com.bumptech.glide.request.transition.ViewAnimationFactory;
@@ -23,6 +24,7 @@
    *
    * @return This request builder.
    */
+  @NonNull
   public final CHILD dontTransition() {
     return transition(NoTransition.getFactory());
   }
@@ -36,8 +38,9 @@ public final CHILD dontTransition() {
    *                        transition.
    * @return This request builder.
    */
+  @NonNull
   public final CHILD transition(int viewAnimationId) {
-    return transition(new ViewAnimationFactory<TranscodeType>(viewAnimationId));
+    return transition(new ViewAnimationFactory<>(viewAnimationId));
   }
 
   /**
@@ -49,18 +52,35 @@ public final CHILD transition(int viewAnimationId) {
    *                 .Animator} to run.
    * @return This request builder.
    */
-  public final CHILD transition(ViewPropertyTransition.Animator animator) {
-    return transition(new ViewPropertyAnimationFactory<TranscodeType>(animator));
+  @NonNull
+  public final CHILD transition(@NonNull ViewPropertyTransition.Animator animator) {
+    return transition(new ViewPropertyAnimationFactory<>(animator));
   }
 
-  public final CHILD transition(TransitionFactory<? super TranscodeType> transitionFactory) {
+  /**
+   * Uses the given {@link TransitionFactory} to build a
+   * {@link com.bumptech.glide.request.transition.Transition} for each request started with these
+   * {@code TransitionOptions}.
+   *
+   * @return This request builder.
+   */
+  @NonNull
+  public final CHILD transition(
+      @NonNull TransitionFactory<? super TranscodeType> transitionFactory) {
     this.transitionFactory = Preconditions.checkNotNull(transitionFactory);
     return self();
   }
 
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings({
+      // cast to CHILD is safe given the generic argument represents the object's runtime class
+      "unchecked",
+      // CHILD is the correct class name.
+      "PMD.CloneMethodReturnTypeMustMatchClassName",
+      // we don't want to throw to be user friendly
+      "PMD.CloneThrowsCloneNotSupportedException"
+  })
   @Override
-  protected final CHILD clone() {
+  public final CHILD clone() {
     try {
       return (CHILD) super.clone();
     } catch (CloneNotSupportedException e) {
diff --git a/library/src/main/java/com/bumptech/glide/load/Encoder.java b/library/src/main/java/com/bumptech/glide/load/Encoder.java
index db652b1ad..400cc7422 100644
--- a/library/src/main/java/com/bumptech/glide/load/Encoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/Encoder.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load;
 
+import android.support.annotation.NonNull;
 import java.io.File;
 
 /**
@@ -8,7 +9,6 @@
  * @param <T> The type of the data that will be written.
  */
 public interface Encoder<T> {
-
   /**
    * Writes the given data to the given output stream and returns True if the write completed
    * successfully and should be committed.
@@ -17,5 +17,5 @@
    * @param file The File to write the data to.
    * @param options The put of options to apply when encoding.
    */
-  boolean encode(T data, File file, Options options);
+  boolean encode(@NonNull T data, @NonNull File file, @NonNull Options options);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/HttpException.java b/library/src/main/java/com/bumptech/glide/load/HttpException.java
index 6b4430c98..b13edc5d7 100644
--- a/library/src/main/java/com/bumptech/glide/load/HttpException.java
+++ b/library/src/main/java/com/bumptech/glide/load/HttpException.java
@@ -10,7 +10,11 @@
  * users may attempt to retry or otherwise uniformly handle certain types of errors regardless of
  * the underlying http library.
  */
+// Public API.
+@SuppressWarnings({"WeakerAccess", "unused"})
 public final class HttpException extends IOException {
+  private static final long serialVersionUID = 1L;
+
   public static final int UNKNOWN = -1;
   private final int statusCode;
 
diff --git a/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java
index 6cecef3ac..b188c4df3 100644
--- a/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java
+++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import java.io.IOException;
 import java.io.InputStream;
@@ -10,9 +11,9 @@
  */
 public interface ImageHeaderParser {
   /**
-   * A constant indicating we were unable to parse the orientation from the image either because
-   * no exif segment containing orientation data existed, or because of an I/O error attempting to
-   * read the exif segment.
+   * A constant indicating we were unable to parse the orientation from the image either because no
+   * exif segment containing orientation data existed, or because of an I/O error attempting to read
+   * the exif segment.
    */
   int UNKNOWN_ORIENTATION = -1;
 
@@ -32,10 +33,9 @@
     WEBP_A(true),
     /** WebP type without alpha. */
     WEBP(false),
-    /**
-     * Unrecognized type.
-     */
+    /** Unrecognized type. */
     UNKNOWN(false);
+
     private final boolean hasAlpha;
 
     ImageType(boolean hasAlpha) {
@@ -47,8 +47,11 @@ public boolean hasAlpha() {
     }
   }
 
-  ImageType getType(InputStream is) throws IOException;
-  ImageType getType(ByteBuffer byteBuffer) throws IOException;
+  @NonNull
+  ImageType getType(@NonNull InputStream is) throws IOException;
+
+  @NonNull
+  ImageType getType(@NonNull ByteBuffer byteBuffer) throws IOException;
 
   /**
    * Parse the orientation from the image header. If it doesn't handle this image type (or this is
@@ -56,8 +59,9 @@ public boolean hasAlpha() {
    *
    * @return The exif orientation if present or -1 if the header couldn't be parsed or doesn't
    * contain an orientation
-   * @throws IOException
    */
-  int getOrientation(InputStream is, ArrayPool byteArrayPool) throws IOException;
-  int getOrientation(ByteBuffer byteBuffer, ArrayPool byteArrayPool) throws IOException;
+  int getOrientation(@NonNull InputStream is, @NonNull ArrayPool byteArrayPool) throws IOException;
+
+  int getOrientation(@NonNull ByteBuffer byteBuffer, @NonNull ArrayPool byteArrayPool)
+      throws IOException;
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java
index b092e15f2..97930be11 100644
--- a/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java
+++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import com.bumptech.glide.load.ImageHeaderParser.ImageType;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
@@ -20,8 +21,9 @@
   private ImageHeaderParserUtils() { }
 
   /** Returns the ImageType for the given InputStream. */
-  public static ImageType getType(List<ImageHeaderParser> parsers, @Nullable InputStream is,
-      ArrayPool byteArrayPool) throws IOException {
+  @NonNull
+  public static ImageType getType(@NonNull List<ImageHeaderParser> parsers,
+      @Nullable InputStream is, @NonNull ArrayPool byteArrayPool) throws IOException {
     if (is == null) {
       return ImageType.UNKNOWN;
     }
@@ -31,7 +33,9 @@ public static ImageType getType(List<ImageHeaderParser> parsers, @Nullable Input
     }
 
     is.mark(MARK_POSITION);
-    for (ImageHeaderParser parser : parsers) {
+    //noinspection ForLoopReplaceableByForEach to improve perf
+    for (int i = 0, size = parsers.size(); i < size; i++) {
+      ImageHeaderParser parser = parsers.get(i);
       try {
         ImageType type = parser.getType(is);
         if (type != ImageType.UNKNOWN) {
@@ -46,13 +50,17 @@ public static ImageType getType(List<ImageHeaderParser> parsers, @Nullable Input
   }
 
   /** Returns the ImageType for the given ByteBuffer. */
-  public static ImageType getType(List<ImageHeaderParser> parsers, @Nullable ByteBuffer buffer)
+  @NonNull
+  public static ImageType getType(@NonNull List<ImageHeaderParser> parsers,
+      @Nullable ByteBuffer buffer)
       throws IOException {
     if (buffer == null) {
       return ImageType.UNKNOWN;
     }
 
-    for (ImageHeaderParser parser : parsers) {
+    //noinspection ForLoopReplaceableByForEach to improve perf
+    for (int i = 0, size = parsers.size(); i < size; i++) {
+      ImageHeaderParser parser = parsers.get(i);
       ImageType type = parser.getType(buffer);
       if (type != ImageType.UNKNOWN) {
         return type;
@@ -62,9 +70,11 @@ public static ImageType getType(List<ImageHeaderParser> parsers, @Nullable ByteB
     return ImageType.UNKNOWN;
   }
 
-  /** Returns the orientation for the given InputStream. */
-  public static int getOrientation(List<ImageHeaderParser> parsers, @Nullable InputStream is,
-      ArrayPool byteArrayPool) throws IOException {
+  /**
+   * Returns the orientation for the given InputStream.
+   */
+  public static int getOrientation(@NonNull List<ImageHeaderParser> parsers,
+      @Nullable InputStream is, @NonNull ArrayPool byteArrayPool) throws IOException {
     if (is == null) {
       return ImageHeaderParser.UNKNOWN_ORIENTATION;
     }
@@ -74,7 +84,9 @@ public static int getOrientation(List<ImageHeaderParser> parsers, @Nullable Inpu
     }
 
     is.mark(MARK_POSITION);
-    for (ImageHeaderParser parser : parsers) {
+    //noinspection ForLoopReplaceableByForEach to improve perf
+    for (int i = 0, size = parsers.size(); i < size; i++) {
+      ImageHeaderParser parser = parsers.get(i);
       try {
         int orientation = parser.getOrientation(is, byteArrayPool);
         if (orientation != ImageHeaderParser.UNKNOWN_ORIENTATION) {
diff --git a/library/src/main/java/com/bumptech/glide/load/Key.java b/library/src/main/java/com/bumptech/glide/load/Key.java
index 47bb2e01a..f78a7b168 100644
--- a/library/src/main/java/com/bumptech/glide/load/Key.java
+++ b/library/src/main/java/com/bumptech/glide/load/Key.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load;
 
+import android.support.annotation.NonNull;
 import java.nio.charset.Charset;
 import java.security.MessageDigest;
 
@@ -21,11 +22,19 @@
    * <p> Note - Using {@link java.security.MessageDigest#reset()} inside of this method will result
    * in undefined behavior. </p>
    */
-  void updateDiskCacheKey(MessageDigest messageDigest);
+  void updateDiskCacheKey(@NonNull MessageDigest messageDigest);
 
+  /**
+   * For caching to work correctly, implementations <em>must</em> implement this method and
+   * {@link #hashCode()}.
+   */
   @Override
   boolean equals(Object o);
 
+  /**
+   * For caching to work correctly, implementations <em>must</em> implement this method and
+   * {@link #equals(Object)}.
+   */
   @Override
   int hashCode();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java
index c4c5d712b..6b1d038f2 100644
--- a/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.Resource;
 import java.security.MessageDigest;
 import java.util.Arrays;
@@ -15,15 +16,16 @@
   private final Collection<? extends Transformation<T>> transformations;
 
   @SafeVarargs
-  public MultiTransformation(Transformation<T>... transformations) {
-    if (transformations.length < 1) {
+  @SuppressWarnings("varargs")
+  public MultiTransformation(@NonNull Transformation<T>... transformations) {
+    if (transformations.length == 0) {
       throw new IllegalArgumentException(
           "MultiTransformation must contain at least one Transformation");
     }
     this.transformations = Arrays.asList(transformations);
   }
 
-  public MultiTransformation(Collection<? extends Transformation<T>> transformationList) {
+  public MultiTransformation(@NonNull Collection<? extends Transformation<T>> transformationList) {
     if (transformationList.isEmpty()) {
       throw new IllegalArgumentException(
           "MultiTransformation must contain at least one Transformation");
@@ -31,9 +33,10 @@ public MultiTransformation(Collection<? extends Transformation<T>> transformatio
     this.transformations = transformationList;
   }
 
+  @NonNull
   @Override
   public Resource<T> transform(
-      Context context, Resource<T> resource, int outWidth, int outHeight) {
+      @NonNull Context context, @NonNull Resource<T> resource, int outWidth, int outHeight) {
     Resource<T> previous = resource;
 
     for (Transformation<T> transformation : transformations) {
@@ -61,7 +64,7 @@ public int hashCode() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     for (Transformation<T> transformation : transformations) {
       transformation.updateDiskCacheKey(messageDigest);
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/Option.java b/library/src/main/java/com/bumptech/glide/load/Option.java
index a63bdc44b..561264871 100644
--- a/library/src/main/java/com/bumptech/glide/load/Option.java
+++ b/library/src/main/java/com/bumptech/glide/load/Option.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import com.bumptech.glide.util.Preconditions;
 import java.security.MessageDigest;
@@ -26,7 +27,8 @@
 public final class Option<T> {
   private static final CacheKeyUpdater<Object> EMPTY_UPDATER = new CacheKeyUpdater<Object>() {
     @Override
-    public void update(byte[] keyBytes, Object value, MessageDigest messageDigest) {
+    public void update(@NonNull byte[] keyBytes, @NonNull Object value,
+        @NonNull MessageDigest messageDigest) {
       // Do nothing.
     }
   };
@@ -43,8 +45,9 @@ public void update(byte[] keyBytes, Object value, MessageDigest messageDigest) {
    * @param key A unique package prefixed {@link String} that identifies this option (must be
    *            stable across builds, so {@link Class#getName()} should <em>not</em> be used).
    */
-  public static <T> Option<T> memory(String key) {
-    return new Option<>(key, null /*defaultValue*/, Option.<T>emptyUpdater());
+  @NonNull
+  public static <T> Option<T> memory(@NonNull String key) {
+    return new Option<>(key, null, Option.<T>emptyUpdater());
   }
 
   /**
@@ -54,7 +57,8 @@ public void update(byte[] keyBytes, Object value, MessageDigest messageDigest) {
    * @param key A unique package prefixed {@link String} that identifies this option (must be
    *            stable across builds, so {@link Class#getName()} should <em>not</em> be used).
    */
-  public static <T> Option<T> memory(String key, T defaultValue) {
+  @NonNull
+  public static <T> Option<T> memory(@NonNull String key, @NonNull T defaultValue) {
     return new Option<>(key, defaultValue, Option.<T>emptyUpdater());
   }
 
@@ -65,8 +69,10 @@ public void update(byte[] keyBytes, Object value, MessageDigest messageDigest) {
    * @param key A unique package prefixed {@link String} that identifies this option (must be
    *            stable across builds, so {@link Class#getName()} should <em>not</em> be used).
    */
-  public static <T> Option<T> disk(String key, CacheKeyUpdater<T> cacheKeyUpdater) {
-    return new Option<>(key, null /*defaultValue*/, cacheKeyUpdater);
+  @NonNull
+  public static <T> Option<T> disk(@NonNull String key,
+      @NonNull CacheKeyUpdater<T> cacheKeyUpdater) {
+    return new Option<>(key, null, cacheKeyUpdater);
   }
 
   /**
@@ -77,11 +83,14 @@ public void update(byte[] keyBytes, Object value, MessageDigest messageDigest) {
    * @param key A unique package prefixed {@link String} that identifies this option (must be
    *            stable across builds, so {@link Class#getName()} should <em>not</em> be used).
    */
-  public static <T> Option<T> disk(String key, T defaultValue, CacheKeyUpdater<T> cacheKeyUpdater) {
+  @NonNull
+  public static <T> Option<T> disk(@NonNull String key, @Nullable T defaultValue,
+      @NonNull CacheKeyUpdater<T> cacheKeyUpdater) {
     return new Option<>(key, defaultValue, cacheKeyUpdater);
   }
 
-  Option(String key, T defaultValue, CacheKeyUpdater<T> cacheKeyUpdater) {
+  private Option(@NonNull String key, @Nullable T defaultValue,
+      @NonNull CacheKeyUpdater<T> cacheKeyUpdater) {
     this.key = Preconditions.checkNotEmpty(key);
     this.defaultValue = defaultValue;
     this.cacheKeyUpdater = Preconditions.checkNotNull(cacheKeyUpdater);
@@ -90,6 +99,8 @@ public void update(byte[] keyBytes, Object value, MessageDigest messageDigest) {
   /**
    * Returns a reasonable default to use if no other value is set, or {@code null}.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   @Nullable
   public T getDefaultValue() {
     return defaultValue;
@@ -100,10 +111,11 @@ public T getDefaultValue() {
    * value using the {@link com.bumptech.glide.load.Option.CacheKeyUpdater} optionally provided in
    * the constructor.
    */
-  public void update(T value, MessageDigest messageDigest) {
+  public void update(@NonNull T value, @NonNull MessageDigest messageDigest) {
     cacheKeyUpdater.update(getKeyBytes(), value, messageDigest);
   }
 
+  @NonNull
   private byte[] getKeyBytes() {
     if (keyBytes == null) {
       keyBytes = key.getBytes(Key.CHARSET);
@@ -125,6 +137,7 @@ public int hashCode() {
     return key.hashCode();
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
   private static <T> CacheKeyUpdater<T> emptyUpdater() {
     return (CacheKeyUpdater<T>) EMPTY_UPDATER;
@@ -147,7 +160,19 @@ public String toString() {
     /**
      * Updates the given {@link MessageDigest} with the bytes of the given key (to avoid incidental
      * value collisions when values are not particularly unique) and value.
+     *
+     * <p>If your {@link Option} shouldn't affect the disk cache key, you should not implement this
+     * class and use {@link Option#memory(String)} or {@link Option#memory(String, Object)} instead.
+     *
+     * @param keyBytes The bytes of the {@link String} used as the key for this particular
+     * {@link Option}. Should be added to the {@code messageDigest} using
+     * {@link MessageDigest#update(byte[])} by all implementations if the digest is updated with
+     * the given {@code value} parameter.
+     *
+     * @param value The value of of this particular option. Typically you should convert the value
+     * to a byte array using some stable mechanism and then call
+     * {@link MessageDigest#update(byte[])} to update the given digest.
      */
-    void update(byte[] keyBytes, T value, MessageDigest messageDigest);
+    void update(@NonNull byte[] keyBytes, @NonNull T value, @NonNull MessageDigest messageDigest);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/Options.java b/library/src/main/java/com/bumptech/glide/load/Options.java
index 32aa7c227..bf2685323 100644
--- a/library/src/main/java/com/bumptech/glide/load/Options.java
+++ b/library/src/main/java/com/bumptech/glide/load/Options.java
@@ -1,9 +1,10 @@
 package com.bumptech.glide.load;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.support.v4.util.ArrayMap;
 import android.support.v4.util.SimpleArrayMap;
 import java.security.MessageDigest;
-import java.util.Map;
 
 /**
  * A set of {@link Option Options} to apply to in memory and disk cache keys.
@@ -11,17 +12,19 @@
 public final class Options implements Key {
   private final ArrayMap<Option<?>, Object> values = new ArrayMap<>();
 
-  public void putAll(Options other) {
+  public void putAll(@NonNull Options other) {
     values.putAll((SimpleArrayMap<Option<?>, Object>) other.values);
   }
 
-  public <T> Options set(Option<T> option, T value) {
+  @NonNull
+  public <T> Options set(@NonNull Option<T> option, @NonNull T value) {
     values.put(option, value);
     return this;
   }
 
+  @Nullable
   @SuppressWarnings("unchecked")
-  public <T> T get(Option<T> option) {
+  public <T> T get(@NonNull Option<T> option) {
     return values.containsKey(option) ? (T) values.get(option) : option.getDefaultValue();
   }
 
@@ -40,9 +43,11 @@ public int hashCode() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
-    for (Map.Entry<Option<?>, Object> entry : values.entrySet()) {
-      updateDiskCacheKey(entry.getKey(), entry.getValue(), messageDigest);
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
+    for (int i = 0; i < values.size(); i++) {
+      Option<?> key = values.keyAt(i);
+      Object value = values.valueAt(i);
+      updateDiskCacheKey(key, value, messageDigest);
     }
   }
 
@@ -54,7 +59,8 @@ public String toString() {
   }
 
   @SuppressWarnings("unchecked")
-  private static <T> void updateDiskCacheKey(Option<T> option, Object value, MessageDigest md) {
+  private static <T> void updateDiskCacheKey(@NonNull Option<T> option, @NonNull Object value,
+      @NonNull MessageDigest md) {
     option.update((T) value, md);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java
index f8e67f7e0..977339e25 100644
--- a/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import com.bumptech.glide.load.engine.Resource;
 import java.io.IOException;
@@ -16,29 +17,26 @@
    * Returns {@code true} if this decoder is capable of decoding the given source with the given
    * options, and {@code false} otherwise.
    *
-   * <p> Decoders should make a best effort attempt to quickly determine if they are likely to be
+   * <p>Decoders should make a best effort attempt to quickly determine if they are likely to be
    * able to decode data, but should not attempt to completely read the given data. A typical
    * implementation would check the file headers verify they match content the decoder expects to
-   * handle (i.e. a GIF decoder should verify that the image contains the GIF header block. </p>
+   * handle (i.e. a GIF decoder should verify that the image contains the GIF header block.
    *
-   * <p> Decoders that return {@code true} from {@link #handles(Object, Options)} may still
-   * return {@code null} from {@link #decode(Object, int, int, Options)} if the data is
-   * partial or formatted incorrectly. </p>
-   *
-   * @throws IOException
+   * <p>Decoders that return {@code true} from {@code handles} may still return {@code null} from
+   * {@link #decode(Object, int, int, Options)} if the data is partial or formatted incorrectly.
    */
-  boolean handles(T source, Options options) throws IOException;
+  boolean handles(@NonNull T source, @NonNull Options options) throws IOException;
 
   /**
    * Returns a decoded resource from the given data or null if no resource could be decoded.
    *
-   * <p> The {@code source} is managed by the caller, there's no need to close it. The returned
-   * {@link Resource} will be {@link Resource#recycle() released} when the engine sees fit. </p>
+   * <p>The {@code source} is managed by the caller, there's no need to close it. The returned
+   * {@link Resource} will be {@link Resource#recycle() released} when the engine sees fit.
    *
-   * <p> Note - The {@code width} and {@code height} arguments are hints only, there is no
+   * <p>Note - The {@code width} and {@code height} arguments are hints only, there is no
    * requirement that the decoded resource exactly match the given dimensions. A typical use case
    * would be to use the target dimensions to determine how much to downsample Bitmaps by to avoid
-   * overly large allocations. </p>
+   * overly large allocations.
    *
    * @param source  The data the resource should be decoded from.
    * @param width   The ideal width in pixels of the decoded resource, or {@link
@@ -52,8 +50,8 @@
    *                all of their option keys are present. However, implementations may assume that
    *                if one of their option keys is present, it's value is non-null and is of the
    *                expected type.
-   * @throws IOException
    */
   @Nullable
-  Resource<Z> decode(T source, int width, int height, Options options) throws IOException;
+  Resource<Z> decode(@NonNull T source, int width, int height, @NonNull Options options)
+      throws IOException;
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/ResourceEncoder.java b/library/src/main/java/com/bumptech/glide/load/ResourceEncoder.java
index 941d3845d..d17985845 100644
--- a/library/src/main/java/com/bumptech/glide/load/ResourceEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/ResourceEncoder.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.Resource;
 
 /**
@@ -10,5 +11,6 @@
  */
 public interface ResourceEncoder<T> extends Encoder<Resource<T>> {
   // specializing the generic arguments
-  EncodeStrategy getEncodeStrategy(Options options);
+  @NonNull
+  EncodeStrategy getEncodeStrategy(@NonNull Options options);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/Transformation.java b/library/src/main/java/com/bumptech/glide/load/Transformation.java
index 3d5c96e0f..2e9ab29d9 100644
--- a/library/src/main/java/com/bumptech/glide/load/Transformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/Transformation.java
@@ -1,7 +1,10 @@
 package com.bumptech.glide.load;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.Resource;
+import java.nio.charset.Charset;
+import java.security.MessageDigest;
 
 /**
  * A class for performing an arbitrary transformation on a resource that implements
@@ -9,11 +12,17 @@
  * cache and {@link #updateDiskCacheKey(java.security.MessageDigest)}} to identify the
  * transformation in disk caches.
  *
- * <p>Using the fully qualified class name (not {@link Class#getName()} to avoid proguard
- * obfuscation) is an easy way to implement
- * {@link #updateDiskCacheKey(java.security.MessageDigest)}} correctly.
+ * <p>Using the fully qualified class name as a static final {@link String} (not
+ * {@link Class#getName()} to avoid proguard obfuscation) is an easy way to implement
+ * {@link #updateDiskCacheKey(java.security.MessageDigest)}} correctly. If additional arguments are
+ * required they can be passed in to the constructor of the {@code Transformation} and then used to
+ * update the {@link java.security.MessageDigest} passed in to
+ * {@link #updateDiskCacheKey(MessageDigest)}. If arguments are primitive types, they can typically
+ * easily be serialized using {@link java.nio.ByteBuffer}. {@link String} types can be serialized
+ * with {@link String#getBytes(Charset)} using the constant {@link #CHARSET}.
  *
- * <p>Implementations <em>must</em> implement {@link #equals(Object)} and {@link #hashCode()}.
+ * <p>Implementations <em>must</em> implement {@link #equals(Object)} and {@link #hashCode()} for
+ * memory caching to work correctly.
  *
  * @param <T> The type of the resource being transformed.
  */
@@ -53,19 +62,7 @@
    *                  original resource height.
    * @return The transformed resource.
    */
-  Resource<T> transform(Context context, Resource<T> resource, int outWidth, int outHeight);
-
-  /**
-   * For caching to work correctly, implementations <em>must</em> implement this method and
-   * {@link #hashCode()}.
-   */
-  @Override
-  boolean equals(Object o);
-
-  /**
-   * For caching to work correctly, implementations <em>must</em> implement this method and
-   * {@link #equals(Object)}.
-   */
-  @Override
-  int hashCode();
+  @NonNull
+  Resource<T> transform(@NonNull Context context, @NonNull Resource<T> resource,
+      int outWidth, int outHeight);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/AssetFileDescriptorLocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/AssetFileDescriptorLocalUriFetcher.java
new file mode 100644
index 000000000..66a287823
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/data/AssetFileDescriptorLocalUriFetcher.java
@@ -0,0 +1,39 @@
+package com.bumptech.glide.load.data;
+
+import android.content.ContentResolver;
+import android.content.res.AssetFileDescriptor;
+import android.net.Uri;
+import android.support.annotation.NonNull;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+
+/**
+ * Fetches an {@link AssetFileDescriptor} for a local {@link android.net.Uri}.
+ */
+public final class AssetFileDescriptorLocalUriFetcher extends LocalUriFetcher<AssetFileDescriptor> {
+
+  public AssetFileDescriptorLocalUriFetcher(ContentResolver contentResolver, Uri uri) {
+    super(contentResolver, uri);
+  }
+
+  @Override
+  protected AssetFileDescriptor loadResource(Uri uri, ContentResolver contentResolver)
+      throws FileNotFoundException {
+    AssetFileDescriptor result = contentResolver.openAssetFileDescriptor(uri, "r");
+    if (result == null) {
+      throw new FileNotFoundException("FileDescriptor is null for: " + uri);
+    }
+    return result;
+  }
+
+  @Override
+  protected void close(AssetFileDescriptor data) throws IOException {
+    data.close();
+  }
+
+  @NonNull
+  @Override
+  public Class<AssetFileDescriptor> getDataClass() {
+    return AssetFileDescriptor.class;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java
index 366a9ad3d..f21eb6c64 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java
@@ -19,13 +19,15 @@
   private final AssetManager assetManager;
   private T data;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public AssetPathFetcher(AssetManager assetManager, String assetPath) {
     this.assetManager = assetManager;
     this.assetPath = assetPath;
   }
 
   @Override
-  public void loadData(Priority priority, DataCallback<? super T> callback) {
+  public void loadData(@NonNull Priority priority, @NonNull DataCallback<? super T> callback) {
     try {
       data = loadResource(assetManager, assetPath);
     } catch (IOException e) {
@@ -74,7 +76,6 @@ public DataSource getDataSource() {
    * Closes the concrete data type if necessary.
    *
    * @param data The data to close.
-   * @throws IOException
    */
   protected abstract void close(T data) throws IOException;
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/BufferedOutputStream.java b/library/src/main/java/com/bumptech/glide/load/data/BufferedOutputStream.java
new file mode 100644
index 000000000..ce9cd17b1
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/data/BufferedOutputStream.java
@@ -0,0 +1,102 @@
+package com.bumptech.glide.load.data;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * An {@link OutputStream} implementation that recycles and re-uses {@code byte[]}s using the
+ * provided {@link ArrayPool}.
+ */
+public final class BufferedOutputStream extends OutputStream {
+  @NonNull
+  private final OutputStream out;
+  private byte[] buffer;
+  private ArrayPool arrayPool;
+  private int index;
+
+  public BufferedOutputStream(@NonNull OutputStream out, @NonNull ArrayPool arrayPool) {
+    this(out, arrayPool, ArrayPool.STANDARD_BUFFER_SIZE_BYTES);
+  }
+
+  @VisibleForTesting
+  BufferedOutputStream(@NonNull OutputStream out, ArrayPool arrayPool, int bufferSize) {
+    this.out = out;
+    this.arrayPool = arrayPool;
+    buffer = arrayPool.get(bufferSize, byte[].class);
+  }
+
+  @Override
+  public void write(int b) throws IOException {
+    buffer[index++] = (byte) b;
+    maybeFlushBuffer();
+  }
+
+  @Override
+  public void write(@NonNull byte[] b) throws IOException {
+    write(b, 0, b.length);
+  }
+
+  @Override
+  public void write(@NonNull byte[] b, int initialOffset, int length) throws IOException {
+    int writtenSoFar = 0;
+    do {
+      int remainingToWrite = length - writtenSoFar;
+      int currentOffset = initialOffset + writtenSoFar;
+      // If we still need to write at least the buffer size worth of bytes, we might as well do so
+      // directly and avoid the overhead of copying to the buffer first.
+      if (index == 0 && remainingToWrite >= buffer.length) {
+        out.write(b, currentOffset, remainingToWrite);
+        return;
+      }
+
+      int remainingSpaceInBuffer = buffer.length - index;
+      int totalBytesToWriteToBuffer = Math.min(remainingToWrite, remainingSpaceInBuffer);
+
+      System.arraycopy(b, currentOffset, buffer, index, totalBytesToWriteToBuffer);
+
+      index += totalBytesToWriteToBuffer;
+      writtenSoFar += totalBytesToWriteToBuffer;
+
+      maybeFlushBuffer();
+    } while (writtenSoFar < length);
+  }
+
+  @Override
+  public void flush() throws IOException {
+    flushBuffer();
+    out.flush();
+  }
+
+  private void flushBuffer() throws IOException {
+    if (index > 0) {
+      out.write(buffer, 0, index);
+      index = 0;
+    }
+  }
+
+  private void maybeFlushBuffer() throws IOException {
+    if (index == buffer.length) {
+      flushBuffer();
+    }
+  }
+
+  @Override
+  public void close() throws IOException {
+    try {
+      flush();
+    } finally {
+      out.close();
+    }
+    release();
+  }
+
+  private void release() {
+    if (buffer != null) {
+      arrayPool.put(buffer);
+      buffer = null;
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java
index 9889eaf06..4a1674fd9 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java
@@ -39,7 +39,7 @@
      *
      * @param e a non-null {@link Exception} indicating why the load failed.
      */
-    void onLoadFailed(Exception e);
+    void onLoadFailed(@NonNull Exception e);
   }
 
   /**
@@ -63,7 +63,7 @@
    * @param callback The callback to use when the request is complete
    * @see #cleanup() where the data retuned will be cleaned up
    */
-  void loadData(Priority priority, DataCallback<? super T> callback);
+  void loadData(@NonNull Priority priority, @NonNull DataCallback<? super T> callback);
 
   /**
    * Cleanup or recycle any resources used by this data fetcher. This method will be called in a
diff --git a/library/src/main/java/com/bumptech/glide/load/data/DataRewinder.java b/library/src/main/java/com/bumptech/glide/load/data/DataRewinder.java
index 73dd6411e..805198ca6 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/DataRewinder.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/DataRewinder.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.data;
 
+import android.support.annotation.NonNull;
 import java.io.IOException;
 
 /**
@@ -20,12 +21,14 @@
     /**
      * Returns a new {@link com.bumptech.glide.load.data.DataRewinder} wrapping the given data.
      */
-    DataRewinder<T> build(T data);
+    @NonNull
+    DataRewinder<T> build(@NonNull T data);
 
     /**
      * Returns the class of data this factory can produce
      * {@link com.bumptech.glide.load.data.DataRewinder}s for.
      */
+    @NonNull
     Class<T> getDataClass();
   }
 
@@ -34,8 +37,8 @@
    * returns the re-wound data (or a wrapper for the re-wound data).
    *
    * @return An object pointing to the wrapped data.
-   * @throws IOException
    */
+  @NonNull
   T rewindAndGet() throws IOException;
 
   /**
diff --git a/library/src/main/java/com/bumptech/glide/load/data/DataRewinderRegistry.java b/library/src/main/java/com/bumptech/glide/load/data/DataRewinderRegistry.java
index 1d7ce3c2e..9aa20bc8f 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/DataRewinderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/DataRewinderRegistry.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.data;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.util.Preconditions;
 import java.util.HashMap;
 import java.util.Map;
@@ -12,23 +13,26 @@
   private final Map<Class<?>, DataRewinder.Factory<?>> rewinders = new HashMap<>();
   private static final DataRewinder.Factory<?> DEFAULT_FACTORY =
       new DataRewinder.Factory<Object>() {
+        @NonNull
         @Override
-        public DataRewinder<Object> build(Object data) {
+        public DataRewinder<Object> build(@NonNull Object data) {
           return new DefaultRewinder(data);
         }
 
+        @NonNull
         @Override
         public Class<Object> getDataClass() {
           throw new UnsupportedOperationException("Not implemented");
         }
       };
 
-  public synchronized void register(DataRewinder.Factory<?> factory) {
+  public synchronized void register(@NonNull DataRewinder.Factory<?> factory) {
     rewinders.put(factory.getDataClass(), factory);
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
-  public synchronized <T> DataRewinder<T> build(T data) {
+  public synchronized <T> DataRewinder<T> build(@NonNull T data) {
     Preconditions.checkNotNull(data);
     DataRewinder.Factory<T> result = (DataRewinder.Factory<T>) rewinders.get(data.getClass());
     if (result == null) {
@@ -46,13 +50,14 @@ public synchronized void register(DataRewinder.Factory<?> factory) {
     return result.build(data);
   }
 
-  private static class DefaultRewinder implements DataRewinder<Object> {
+  private static final class DefaultRewinder implements DataRewinder<Object> {
     private final Object data;
 
-    public DefaultRewinder(Object data) {
+    DefaultRewinder(@NonNull Object data) {
       this.data = data;
     }
 
+    @NonNull
     @Override
     public Object rewindAndGet() {
       return data;
diff --git a/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java b/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java
index de4436d93..9f5d79e62 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.data;
 
+import android.support.annotation.NonNull;
 import java.io.FilterInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -15,46 +16,46 @@
   /** Allow two bytes for the file format. */
   private static final int SEGMENT_START_POSITION = 2;
   private static final byte[] EXIF_SEGMENT = new byte[] {
-      /** segment start id. */
+      /* segment start id. */
       (byte) 0xFF,
-      /** segment type. */
+      /* segment type. */
       (byte) 0xE1,
-      /** segmentLength. */
+      /* segmentLength. */
       0x00,
       (byte) 0x1C,
-      /** exif identifier. */
+      /* exif identifier. */
       0x45,
       0x78,
       0x69,
       0x66,
       0x00,
       0x00,
-      /** motorola byte order (big endian). */
+      /* motorola byte order (big endian). */
       (byte) 0x4D,
       (byte) 0x4D,
-      /** filler? */
+      /* filler? */
       0x00,
       0x00,
-      /** first id offset. */
+      /* first id offset. */
       0x00,
       0x00,
       0x00,
       0x08,
-      /** tagCount. */
+      /* tagCount. */
       0x00,
       0x01,
-      /** exif tag type. */
+      /* exif tag type. */
       0x01,
       0x12,
-      /** 2 byte format. */
+      /* 2 byte format. */
       0x00,
       0x02,
-      /** component count. */
+      /* component count. */
       0x00,
       0x00,
       0x00,
       0x01,
-      /** 2 byte orientation value, the first byte of which is always 0. */
+      /* 2 byte orientation value, the first byte of which is always 0. */
       0x00,
   };
   private static final int SEGMENT_LENGTH = EXIF_SEGMENT.length;
@@ -75,8 +76,10 @@ public boolean markSupported() {
     return false;
   }
 
+  // No need for synchronized since all we do is throw.
+  @SuppressWarnings("UnsynchronizedOverridesSynchronized")
   @Override
-  public void mark(int readlimit) {
+  public void mark(int readLimit) {
     throw new UnsupportedOperationException();
   }
 
@@ -97,7 +100,7 @@ public int read() throws IOException {
   }
 
   @Override
-  public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
+  public int read(@NonNull byte[] buffer, int byteOffset, int byteCount) throws IOException {
     int read;
     if (position > ORIENTATION_POSITION) {
       read = super.read(buffer, byteOffset, byteCount);
@@ -120,11 +123,14 @@ public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException
   public long skip(long byteCount) throws IOException {
     long skipped = super.skip(byteCount);
     if (skipped > 0) {
-      position += skipped;
+      // See http://errorprone.info/bugpattern/NarrowingCompoundAssignment.
+      position = (int) (position + skipped);
     }
     return skipped;
   }
 
+  // No need for synchronized since all we do is throw.
+  @SuppressWarnings("UnsynchronizedOverridesSynchronized")
   @Override
   public void reset() throws IOException {
     throw new UnsupportedOperationException();
diff --git a/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
index 6989129cc..e8f914b6e 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.data;
 
 import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
 import android.text.TextUtils;
 import android.util.Log;
 import com.bumptech.glide.Priority;
@@ -23,9 +24,13 @@
 public class HttpUrlFetcher implements DataFetcher<InputStream> {
   private static final String TAG = "HttpUrlFetcher";
   private static final int MAXIMUM_REDIRECTS = 5;
-  // Visible for testing.
+  @VisibleForTesting
   static final HttpUrlConnectionFactory DEFAULT_CONNECTION_FACTORY =
       new DefaultHttpUrlConnectionFactory();
+  /**
+   * Returned when a connection error prevented us from receiving an http error.
+   */
+  private static final int INVALID_STATUS_CODE = -1;
 
   private final GlideUrl glideUrl;
   private final int timeout;
@@ -39,7 +44,7 @@ public HttpUrlFetcher(GlideUrl glideUrl, int timeout) {
     this(glideUrl, timeout, DEFAULT_CONNECTION_FACTORY);
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   HttpUrlFetcher(GlideUrl glideUrl, int timeout, HttpUrlConnectionFactory connectionFactory) {
     this.glideUrl = glideUrl;
     this.timeout = timeout;
@@ -47,25 +52,22 @@ public HttpUrlFetcher(GlideUrl glideUrl, int timeout) {
   }
 
   @Override
-  public void loadData(Priority priority, DataCallback<? super InputStream> callback) {
+  public void loadData(@NonNull Priority priority,
+      @NonNull DataCallback<? super InputStream> callback) {
     long startTime = LogTime.getLogTime();
-    final InputStream result;
     try {
-      result = loadDataWithRedirects(glideUrl.toURL(), 0 /*redirects*/, null /*lastUrl*/,
-          glideUrl.getHeaders());
+      InputStream result = loadDataWithRedirects(glideUrl.toURL(), 0, null, glideUrl.getHeaders());
+      callback.onDataReady(result);
     } catch (IOException e) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
         Log.d(TAG, "Failed to load data for url", e);
       }
       callback.onLoadFailed(e);
-      return;
-    }
-
-    if (Log.isLoggable(TAG, Log.VERBOSE)) {
-      Log.v(TAG, "Finished http url fetcher fetch in " + LogTime.getElapsedMillis(startTime)
-          + " ms and loaded " + result);
+    } finally {
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+        Log.v(TAG, "Finished http url fetcher fetch in " + LogTime.getElapsedMillis(startTime));
+      }
     }
-    callback.onDataReady(result);
   }
 
   private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,
@@ -106,9 +108,9 @@ private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,
       return null;
     }
     final int statusCode = urlConnection.getResponseCode();
-    if (statusCode / 100 == 2) {
+    if (isHttpOk(statusCode)) {
       return getStreamForSuccessfulRequest(urlConnection);
-    } else if (statusCode / 100 == 3) {
+    } else if (isHttpRedirect(statusCode)) {
       String redirectUrlString = urlConnection.getHeaderField("Location");
       if (TextUtils.isEmpty(redirectUrlString)) {
         throw new HttpException("Received empty or null redirect url");
@@ -118,13 +120,23 @@ private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,
       // to disconnecting the url connection below. See #2352.
       cleanup();
       return loadDataWithRedirects(redirectUrl, redirects + 1, url, headers);
-    } else if (statusCode == -1) {
+    } else if (statusCode == INVALID_STATUS_CODE) {
       throw new HttpException(statusCode);
     } else {
       throw new HttpException(urlConnection.getResponseMessage(), statusCode);
     }
   }
 
+  // Referencing constants is less clear than a simple static method.
+  private static boolean isHttpOk(int statusCode) {
+    return statusCode / 100 == 2;
+  }
+
+  // Referencing constants is less clear than a simple static method.
+  private static boolean isHttpRedirect(int statusCode) {
+    return statusCode / 100 == 3;
+  }
+
   private InputStream getStreamForSuccessfulRequest(HttpURLConnection urlConnection)
       throws IOException {
     if (TextUtils.isEmpty(urlConnection.getContentEncoding())) {
diff --git a/library/src/main/java/com/bumptech/glide/load/data/InputStreamRewinder.java b/library/src/main/java/com/bumptech/glide/load/data/InputStreamRewinder.java
index 08fce42d8..9a0766ce7 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/InputStreamRewinder.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/InputStreamRewinder.java
@@ -1,7 +1,9 @@
 package com.bumptech.glide.load.data;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.resource.bitmap.RecyclableBufferedInputStream;
+import com.bumptech.glide.util.Synthetic;
 import java.io.IOException;
 import java.io.InputStream;
 
@@ -15,11 +17,13 @@
 
   private final RecyclableBufferedInputStream bufferedStream;
 
+  @Synthetic
   InputStreamRewinder(InputStream is, ArrayPool byteArrayPool) {
     bufferedStream = new RecyclableBufferedInputStream(is, byteArrayPool);
     bufferedStream.mark(MARK_LIMIT);
   }
 
+  @NonNull
   @Override
   public InputStream rewindAndGet() throws IOException {
     bufferedStream.reset();
@@ -42,11 +46,13 @@ public Factory(ArrayPool byteArrayPool) {
       this.byteArrayPool = byteArrayPool;
     }
 
+    @NonNull
     @Override
     public DataRewinder<InputStream> build(InputStream data) {
       return new InputStreamRewinder(data, byteArrayPool);
     }
 
+    @NonNull
     @Override
     public Class<InputStream> getDataClass() {
       return InputStream.class;
diff --git a/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java
index 81d12b054..68ee75305 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java
@@ -30,13 +30,16 @@
    *                by {@link ContentResolver#openInputStream(android.net.Uri)}
    * @see ContentResolver#openInputStream(android.net.Uri)
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public LocalUriFetcher(ContentResolver contentResolver, Uri uri) {
     this.contentResolver = contentResolver;
     this.uri = uri;
   }
 
   @Override
-  public final void loadData(Priority priority, DataCallback<? super T> callback) {
+  public final void loadData(@NonNull Priority priority,
+      @NonNull DataCallback<? super T> callback) {
     try {
       data = loadResource(uri, contentResolver);
     } catch (FileNotFoundException e) {
diff --git a/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
index cb4cb966b..758e4a543 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
@@ -1,10 +1,8 @@
 package com.bumptech.glide.load.data;
 
-import android.annotation.TargetApi;
 import android.content.ContentResolver;
 import android.content.UriMatcher;
 import android.net.Uri;
-import android.os.Build;
 import android.provider.ContactsContract;
 import android.support.annotation.NonNull;
 import java.io.FileNotFoundException;
@@ -88,7 +86,6 @@ private InputStream loadResourceFromUri(Uri uri, ContentResolver contentResolver
     }
   }
 
-  @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
   private InputStream openContactPhotoInputStream(ContentResolver contentResolver, Uri contactUri) {
     return ContactsContract.Contacts.openContactPhotoInputStream(contentResolver, contactUri,
         true /*preferHighres*/);
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/MediaStoreUtil.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/MediaStoreUtil.java
index dc6cbef6e..d7f7e44af 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/mediastore/MediaStoreUtil.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/MediaStoreUtil.java
@@ -3,6 +3,7 @@
 import android.content.ContentResolver;
 import android.net.Uri;
 import android.provider.MediaStore;
+import com.bumptech.glide.request.target.Target;
 
 /**
  * Utility classes for interacting with the media store.
@@ -33,6 +34,9 @@ public static boolean isMediaStoreImageUri(Uri uri) {
   }
 
   public static boolean isThumbnailSize(int width, int height) {
-    return width <= MINI_THUMB_WIDTH && height <= MINI_THUMB_HEIGHT;
+    return width != Target.SIZE_ORIGINAL
+        && height != Target.SIZE_ORIGINAL
+        && width <= MINI_THUMB_WIDTH
+        && height <= MINI_THUMB_HEIGHT;
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
index 64fcec28f..3b90b0a6b 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
@@ -6,6 +6,7 @@
 import android.net.Uri;
 import android.provider.MediaStore;
 import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
 import android.util.Log;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.Priority;
@@ -28,8 +29,6 @@
   private final ThumbnailStreamOpener opener;
   private InputStream inputStream;
 
-  // TODO(nnaze): These build methods do not need the full Glide or Context objects.
-
   public static ThumbFetcher buildImageFetcher(Context context, Uri uri) {
     return build(context, uri, new ImageThumbnailQuery(context.getContentResolver()));
   }
@@ -46,14 +45,15 @@ private static ThumbFetcher build(Context context, Uri uri, ThumbnailQuery query
     return new ThumbFetcher(uri, opener);
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   ThumbFetcher(Uri mediaStoreImageUri, ThumbnailStreamOpener opener) {
     this.mediaStoreImageUri = mediaStoreImageUri;
     this.opener = opener;
   }
 
   @Override
-  public void loadData(Priority priority, DataCallback<? super InputStream> callback) {
+  public void loadData(@NonNull Priority priority,
+      @NonNull DataCallback<? super InputStream> callback) {
     try {
       inputStream = openThumbInputStream();
     } catch (FileNotFoundException e) {
@@ -118,11 +118,11 @@ public DataSource getDataSource() {
     }
 
     private static final String[] PATH_PROJECTION = {
-      MediaStore.Video.Thumbnails.DATA
+        MediaStore.Video.Thumbnails.DATA
     };
     private static final String PATH_SELECTION =
         MediaStore.Video.Thumbnails.KIND + " = " + MediaStore.Video.Thumbnails.MINI_KIND
-        + " AND " + MediaStore.Video.Thumbnails.VIDEO_ID + " = ?";
+            + " AND " + MediaStore.Video.Thumbnails.VIDEO_ID + " = ?";
 
     @Override
     public Cursor query(Uri uri) {
@@ -146,11 +146,11 @@ public Cursor query(Uri uri) {
     }
 
     private static final String[] PATH_PROJECTION = {
-      MediaStore.Images.Thumbnails.DATA,
+        MediaStore.Images.Thumbnails.DATA,
     };
     private static final String PATH_SELECTION =
         MediaStore.Images.Thumbnails.KIND + " = " + MediaStore.Images.Thumbnails.MINI_KIND
-        + " AND " + MediaStore.Images.Thumbnails.IMAGE_ID + " = ?";
+            + " AND " + MediaStore.Images.Thumbnails.IMAGE_ID + " = ?";
 
     @Override
     public Cursor query(Uri uri) {
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
index 323f02e17..7749477ac 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
@@ -3,6 +3,8 @@
 import android.content.ContentResolver;
 import android.database.Cursor;
 import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.text.TextUtils;
 import android.util.Log;
 import com.bumptech.glide.load.ImageHeaderParser;
@@ -24,13 +26,13 @@
   private final ContentResolver contentResolver;
   private final List<ImageHeaderParser> parsers;
 
-  public ThumbnailStreamOpener(
+  ThumbnailStreamOpener(
       List<ImageHeaderParser> parsers, ThumbnailQuery query, ArrayPool byteArrayPool,
       ContentResolver contentResolver) {
     this(parsers, DEFAULT_SERVICE, query, byteArrayPool, contentResolver);
   }
 
-  public ThumbnailStreamOpener(
+  ThumbnailStreamOpener(
       List<ImageHeaderParser> parsers,
       FileService service,
       ThumbnailQuery query,
@@ -43,13 +45,13 @@ public ThumbnailStreamOpener(
     this.parsers = parsers;
   }
 
-  public int getOrientation(Uri uri) {
+  int getOrientation(Uri uri) {
     InputStream is = null;
     try {
       is = contentResolver.openInputStream(uri);
       return ImageHeaderParserUtils.getOrientation(parsers, is, byteArrayPool);
-      // openInputStream can throw NPEs.
-    } catch (IOException | NullPointerException e) {
+      // PMD.AvoidCatchingNPE framework method openInputStream can throw NPEs.
+    } catch (@SuppressWarnings("PMD.AvoidCatchingNPE") IOException | NullPointerException e) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
         Log.d(TAG, "Failed to open uri: " + uri, e);
       }
@@ -66,37 +68,43 @@ public int getOrientation(Uri uri) {
   }
 
   public InputStream open(Uri uri) throws FileNotFoundException {
-    Uri thumbnailUri = null;
-    InputStream inputStream = null;
+    String path = getPath(uri);
+    if (TextUtils.isEmpty(path)) {
+      return null;
+    }
+
+    File file = service.get(path);
+    if (!isValid(file)) {
+      return null;
+    }
+
+    Uri thumbnailUri = Uri.fromFile(file);
+    try {
+      return contentResolver.openInputStream(thumbnailUri);
+      // PMD.AvoidCatchingNPE framework method openInputStream can throw NPEs.
+    } catch (@SuppressWarnings("PMD.AvoidCatchingNPE") NullPointerException e) {
+      throw (FileNotFoundException)
+          new FileNotFoundException("NPE opening uri: " + uri + " -> " + thumbnailUri).initCause(e);
+    }
+  }
 
+  @Nullable
+  private String getPath(@NonNull Uri uri) {
     final Cursor cursor = query.query(uri);
     try {
-      if (cursor == null || !cursor.moveToFirst()) {
+      if (cursor != null && cursor.moveToFirst()) {
+        return cursor.getString(0);
+      } else {
         return null;
       }
-      String path = cursor.getString(0);
-      if (TextUtils.isEmpty(path)) {
-        return null;
-      }
-
-      File file = service.get(path);
-      if (service.exists(file) && service.length(file) > 0) {
-        thumbnailUri = Uri.fromFile(file);
-      }
     } finally {
       if (cursor != null) {
         cursor.close();
       }
     }
-    if (thumbnailUri != null) {
-      try {
-        inputStream = contentResolver.openInputStream(thumbnailUri);
-        // openInputStream can throw NPEs.
-      } catch (NullPointerException e) {
-        throw (FileNotFoundException)
-          new FileNotFoundException("NPE opening uri: " + thumbnailUri).initCause(e);
-      }
-    }
-    return inputStream;
+  }
+
+  private boolean isValid(File file) {
+    return service.exists(file) && 0 < service.length(file);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java b/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java
new file mode 100644
index 000000000..5ccbf7b7f
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java
@@ -0,0 +1,201 @@
+package com.bumptech.glide.load.engine;
+
+import android.os.Handler;
+import android.os.Handler.Callback;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Process;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.engine.EngineResource.ResourceListener;
+import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Synthetic;
+import com.bumptech.glide.util.Util;
+import java.lang.ref.ReferenceQueue;
+import java.lang.ref.WeakReference;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.TimeUnit;
+
+final class ActiveResources {
+  private static final int MSG_CLEAN_REF = 1;
+
+  private final boolean isActiveResourceRetentionAllowed;
+  private final Handler mainHandler = new Handler(Looper.getMainLooper(), new Callback() {
+    @Override
+    public boolean handleMessage(Message msg) {
+      if (msg.what == MSG_CLEAN_REF) {
+        cleanupActiveReference((ResourceWeakReference) msg.obj);
+        return true;
+      }
+      return false;
+    }
+  });
+  @VisibleForTesting
+  final Map<Key, ResourceWeakReference> activeEngineResources = new HashMap<>();
+
+  private ResourceListener listener;
+
+  /**
+   * Lazily instantiate to avoid exceptions if Glide is initialized on a background thread.
+   *
+   * @see <a href="https://github.com/bumptech/glide/issues/295">#295</a>
+   */
+  @Nullable
+  private ReferenceQueue<EngineResource<?>> resourceReferenceQueue;
+  @Nullable
+  private Thread cleanReferenceQueueThread;
+  private volatile boolean isShutdown;
+  @Nullable
+  private volatile DequeuedResourceCallback cb;
+
+  ActiveResources(boolean isActiveResourceRetentionAllowed) {
+    this.isActiveResourceRetentionAllowed = isActiveResourceRetentionAllowed;
+  }
+
+  void setListener(ResourceListener listener) {
+    this.listener = listener;
+  }
+
+  void activate(Key key, EngineResource<?> resource) {
+    ResourceWeakReference toPut =
+        new ResourceWeakReference(
+            key,
+            resource,
+            getReferenceQueue(),
+            isActiveResourceRetentionAllowed);
+
+    ResourceWeakReference removed = activeEngineResources.put(key, toPut);
+    if (removed != null) {
+      removed.reset();
+    }
+  }
+
+  void deactivate(Key key) {
+    ResourceWeakReference removed = activeEngineResources.remove(key);
+    if (removed != null) {
+      removed.reset();
+    }
+  }
+
+  @Nullable
+  EngineResource<?> get(Key key) {
+    ResourceWeakReference activeRef = activeEngineResources.get(key);
+    if (activeRef == null) {
+      return null;
+    }
+
+    EngineResource<?> active = activeRef.get();
+    if (active == null) {
+      cleanupActiveReference(activeRef);
+    }
+    return active;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic void cleanupActiveReference(@NonNull ResourceWeakReference ref) {
+    Util.assertMainThread();
+    activeEngineResources.remove(ref.key);
+
+    if (!ref.isCacheable || ref.resource == null) {
+      return;
+    }
+    EngineResource<?> newResource =
+        new EngineResource<>(ref.resource, /*isCacheable=*/ true, /*isRecyclable=*/ false);
+    newResource.setResourceListener(ref.key, listener);
+    listener.onResourceReleased(ref.key, newResource);
+  }
+
+  private ReferenceQueue<EngineResource<?>> getReferenceQueue() {
+    if (resourceReferenceQueue == null) {
+      resourceReferenceQueue = new ReferenceQueue<>();
+      cleanReferenceQueueThread = new Thread(new Runnable() {
+        @SuppressWarnings("InfiniteLoopStatement")
+        @Override
+        public void run() {
+          Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
+          cleanReferenceQueue();
+        }
+      }, "glide-active-resources");
+      cleanReferenceQueueThread.start();
+    }
+    return resourceReferenceQueue;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic void cleanReferenceQueue() {
+    while (!isShutdown) {
+      try {
+        ResourceWeakReference ref = (ResourceWeakReference) resourceReferenceQueue.remove();
+        mainHandler.obtainMessage(MSG_CLEAN_REF, ref).sendToTarget();
+
+        // This section for testing only.
+        DequeuedResourceCallback current = cb;
+        if (current != null) {
+          current.onResourceDequeued();
+        }
+        // End for testing only.
+      } catch (InterruptedException e) {
+        Thread.currentThread().interrupt();
+      }
+    }
+  }
+
+  @VisibleForTesting
+  void setDequeuedResourceCallback(DequeuedResourceCallback cb) {
+    this.cb = cb;
+  }
+
+  @VisibleForTesting
+  interface DequeuedResourceCallback {
+    void onResourceDequeued();
+  }
+
+  @VisibleForTesting
+  void shutdown() {
+    isShutdown = true;
+    if (cleanReferenceQueueThread == null) {
+      return;
+    }
+
+    cleanReferenceQueueThread.interrupt();
+    try {
+      cleanReferenceQueueThread.join(TimeUnit.SECONDS.toMillis(5));
+      if (cleanReferenceQueueThread.isAlive()) {
+        throw new RuntimeException("Failed to join in time");
+      }
+    } catch (InterruptedException e) {
+      Thread.currentThread().interrupt();
+    }
+  }
+
+  @VisibleForTesting
+  static final class ResourceWeakReference extends WeakReference<EngineResource<?>> {
+    @SuppressWarnings("WeakerAccess") @Synthetic final Key key;
+    @SuppressWarnings("WeakerAccess") @Synthetic final boolean isCacheable;
+
+    @Nullable @SuppressWarnings("WeakerAccess") @Synthetic Resource<?> resource;
+
+    @Synthetic
+    @SuppressWarnings("WeakerAccess")
+    ResourceWeakReference(
+        @NonNull Key key,
+        @NonNull EngineResource<?> referent,
+        @NonNull ReferenceQueue<? super EngineResource<?>> queue,
+        boolean isActiveResourceRetentionAllowed) {
+      super(referent, queue);
+      this.key = Preconditions.checkNotNull(key);
+      this.resource =
+          referent.isCacheable() && isActiveResourceRetentionAllowed
+              ? Preconditions.checkNotNull(referent.getResource()) : null;
+      isCacheable = referent.isCacheable();
+    }
+
+    void reset() {
+      resource = null;
+      clear();
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java
index a97652e7d..bc19d18eb 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.data.DataFetcher;
@@ -15,7 +16,7 @@
 class DataCacheGenerator implements DataFetcherGenerator,
     DataFetcher.DataCallback<Object> {
 
-  private List<Key> cacheKeys;
+  private final List<Key> cacheKeys;
   private final DecodeHelper<?> helper;
   private final FetcherReadyCallback cb;
 
@@ -50,6 +51,9 @@ public boolean startNext() {
       }
 
       Key sourceId = cacheKeys.get(sourceIdIndex);
+      // PMD.AvoidInstantiatingObjectsInLoops The loop iterates a limited number of times
+      // and the actions it performs are much more expensive than a single allocation.
+      @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")
       Key originalKey = new DataCacheKey(sourceId, helper.getSignature());
       cacheFile = helper.getDiskCache().get(originalKey);
       if (cacheFile != null) {
@@ -92,7 +96,7 @@ public void onDataReady(Object data) {
   }
 
   @Override
-  public void onLoadFailed(Exception e) {
+  public void onLoadFailed(@NonNull Exception e) {
     cb.onDataFetcherFailed(sourceKey, e, loadData.fetcher, DataSource.DATA_DISK_CACHE);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java
index e70792c74..5177438a9 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Key;
 import java.security.MessageDigest;
 
@@ -11,12 +12,12 @@
   private final Key sourceKey;
   private final Key signature;
 
-  public DataCacheKey(Key sourceKey, Key signature) {
+  DataCacheKey(Key sourceKey, Key signature) {
     this.sourceKey = sourceKey;
     this.signature = signature;
   }
 
-  public Key getSourceKey() {
+  Key getSourceKey() {
     return sourceKey;
   }
 
@@ -45,7 +46,7 @@ public String toString() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     sourceKey.updateDiskCacheKey(messageDigest);
     signature.updateDiskCacheKey(messageDigest);
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheWriter.java b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheWriter.java
index eb7d4a4bd..59f39bd00 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheWriter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheWriter.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.cache.DiskCache;
@@ -26,7 +27,7 @@
   }
 
   @Override
-  public boolean write(File file) {
+  public boolean write(@NonNull File file) {
     return encoder.encode(data, file, options);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
index 5c6529ff0..6a4283f1c 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
@@ -8,6 +8,8 @@
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceEncoder;
 import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DecodeJob.DiskCacheProvider;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.cache.DiskCache;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoader.LoadData;
@@ -16,6 +18,7 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
 
 final class DecodeHelper<Transcode> {
 
@@ -40,7 +43,7 @@
   private boolean isScaleOnlyOrNoTransform;
 
   @SuppressWarnings("unchecked")
-  <R> DecodeHelper<R> init(
+  <R> void init(
       GlideContext glideContext,
       Object model,
       Key signature,
@@ -54,7 +57,7 @@
       Map<Class<?>, Transformation<?>> transformations,
       boolean isTransformationRequired,
       boolean isScaleOnlyOrNoTransform,
-      DecodeJob.DiskCacheProvider diskCacheProvider) {
+      DiskCacheProvider diskCacheProvider) {
     this.glideContext = glideContext;
     this.model = model;
     this.signature = signature;
@@ -70,11 +73,6 @@
     this.isTransformationRequired = isTransformationRequired;
     this.isScaleOnlyOrNoTransform = isScaleOnlyOrNoTransform;
 
-    return (DecodeHelper<R>) this;
-  }
-
-  Object getModel() {
-    return model;
   }
 
   void clear() {
@@ -122,6 +120,18 @@ int getHeight() {
     return height;
   }
 
+  ArrayPool getArrayPool() {
+    return glideContext.getArrayPool();
+  }
+
+  Class<?> getTranscodeClass() {
+    return transcodeClass;
+  }
+
+  Class<?> getModelClass() {
+    return model.getClass();
+  }
+
   List<Class<?>> getRegisteredResourceClasses() {
     return glideContext.getRegistry()
         .getRegisteredResourceClasses(model.getClass(), resourceClass, transcodeClass);
@@ -142,7 +152,16 @@ boolean isScaleOnlyOrNoTransform() {
   @SuppressWarnings("unchecked")
   <Z> Transformation<Z> getTransformation(Class<Z> resourceClass) {
     Transformation<Z> result = (Transformation<Z>) transformations.get(resourceClass);
-     if (result == null) {
+    if (result == null) {
+      for (Entry<Class<?>, Transformation<?>> entry : transformations.entrySet()) {
+        if (entry.getKey().isAssignableFrom(resourceClass)) {
+          result = (Transformation<Z>) entry.getValue();
+          break;
+        }
+      }
+    }
+
+    if (result == null) {
       if (transformations.isEmpty() && isTransformationRequired) {
         throw new IllegalArgumentException(
             "Missing transformation for " + resourceClass + ". If you wish to"
@@ -169,8 +188,8 @@ boolean isResourceEncoderAvailable(Resource<?> resource) {
 
   boolean isSourceKey(Key key) {
     List<LoadData<?>> loadData = getLoadData();
-    int size = loadData.size();
-    for (int i = 0; i < size; i++) {
+    //noinspection ForLoopReplaceableByForEach to improve perf
+    for (int i = 0, size = loadData.size(); i < size; i++) {
       LoadData<?> current = loadData.get(i);
       if (current.sourceKey.equals(key)) {
         return true;
@@ -184,8 +203,8 @@ boolean isSourceKey(Key key) {
       isLoadDataSet = true;
       loadData.clear();
       List<ModelLoader<Object, ?>> modelLoaders = glideContext.getRegistry().getModelLoaders(model);
-      int size = modelLoaders.size();
-      for (int i = 0; i < size; i++) {
+      //noinspection ForLoopReplaceableByForEach to improve perf
+      for (int i = 0, size = modelLoaders.size(); i < size; i++) {
         ModelLoader<Object, ?> modelLoader = modelLoaders.get(i);
         LoadData<?> current =
             modelLoader.buildLoadData(model, width, height, options);
@@ -202,8 +221,8 @@ boolean isSourceKey(Key key) {
       isCacheKeysSet = true;
       cacheKeys.clear();
       List<LoadData<?>> loadData = getLoadData();
-      int size = loadData.size();
-      for (int i = 0; i < size; i++) {
+      //noinspection ForLoopReplaceableByForEach to improve perf
+      for (int i = 0, size = loadData.size(); i < size; i++) {
         LoadData<?> data = loadData.get(i);
         if (!cacheKeys.contains(data.sourceKey)) {
           cacheKeys.add(data.sourceKey);
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
index d1eb3619b..3fe0bb3d5 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.engine;
 
 import android.os.Build;
+import android.support.annotation.NonNull;
 import android.support.v4.os.TraceCompat;
 import android.support.v4.util.Pools;
 import android.util.Log;
@@ -18,7 +19,6 @@
 import com.bumptech.glide.load.engine.cache.DiskCache;
 import com.bumptech.glide.load.resource.bitmap.Downsampler;
 import com.bumptech.glide.util.LogTime;
-import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.pool.FactoryPools.Poolable;
 import com.bumptech.glide.util.pool.StateVerifier;
@@ -41,22 +41,22 @@
     Poolable {
   private static final String TAG = "DecodeJob";
 
-  @Synthetic final DecodeHelper<R> decodeHelper = new DecodeHelper<>();
-  private final List<Exception> exceptions = new ArrayList<>();
+  private final DecodeHelper<R> decodeHelper = new DecodeHelper<>();
+  private final List<Throwable> throwables = new ArrayList<>();
   private final StateVerifier stateVerifier = StateVerifier.newInstance();
   private final DiskCacheProvider diskCacheProvider;
   private final Pools.Pool<DecodeJob<?>> pool;
-  @Synthetic final DeferredEncodeManager<?> deferredEncodeManager = new DeferredEncodeManager<>();
+  private final DeferredEncodeManager<?> deferredEncodeManager = new DeferredEncodeManager<>();
   private final ReleaseManager releaseManager = new ReleaseManager();
 
   private GlideContext glideContext;
-  @Synthetic Key signature;
+  private Key signature;
   private Priority priority;
   private EngineKey loadKey;
-  @Synthetic int width;
-  @Synthetic int height;
-  @Synthetic DiskCacheStrategy diskCacheStrategy;
-  @Synthetic Options options;
+  private int width;
+  private int height;
+  private DiskCacheStrategy diskCacheStrategy;
+  private Options options;
   private Callback<R> callback;
   private int order;
   private Stage stage;
@@ -65,7 +65,7 @@
   private boolean onlyRetrieveFromCache;
 
   private Thread currentThread;
-  @Synthetic Key currentSourceKey;
+  private Key currentSourceKey;
   private Key currentAttemptingKey;
   private Object currentData;
   private DataSource currentDataSource;
@@ -140,8 +140,8 @@ boolean willDecodeFromCache() {
   /**
    * Called when this object is no longer in use externally.
    *
-   * @param isRemovedFromQueue {@code true} if we've been removed from the queue and {@link #run}
-   *                           is neither in progress nor will ever be called again.
+   * @param isRemovedFromQueue {@code true} if we've been removed from the queue and {@link #run} is
+   *                           neither in progress nor will ever be called again.
    */
   void release(boolean isRemovedFromQueue) {
     if (releaseManager.release(isRemovedFromQueue)) {
@@ -188,12 +188,12 @@ private void releaseInternal() {
     currentFetcher = null;
     startFetchTime = 0L;
     isCancelled = false;
-    exceptions.clear();
+    throwables.clear();
     pool.release(this);
   }
 
   @Override
-  public int compareTo(DecodeJob<?> other) {
+  public int compareTo(@NonNull DecodeJob<?> other) {
     int result = getPriority() - other.getPriority();
     if (result == 0) {
       result = order - other.order;
@@ -228,23 +228,29 @@ public void run() {
         return;
       }
       runWrapped();
-    } catch (RuntimeException e) {
+    } catch (Throwable t) {
+      // Catch Throwable and not Exception to handle OOMs. Throwables are swallowed by our
+      // usage of .submit() in GlideExecutor so we're not silently hiding crashes by doing this. We
+      // are however ensuring that our callbacks are always notified when a load fails. Without this
+      // notification, uncaught throwables never notify the corresponding callbacks, which can cause
+      // loads to silently hang forever, a case that's especially bad for users using Futures on
+      // background threads.
       if (Log.isLoggable(TAG, Log.DEBUG)) {
         Log.d(TAG, "DecodeJob threw unexpectedly"
             + ", isCancelled: " + isCancelled
-            + ", stage: " + stage, e);
+            + ", stage: " + stage, t);
       }
       // When we're encoding we've already notified our callback and it isn't safe to do so again.
       if (stage != Stage.ENCODE) {
+        throwables.add(t);
         notifyFailed();
       }
       if (!isCancelled) {
-        throw e;
+        throw t;
       }
     } finally {
-      Preconditions.checkArgument(
-          localFetcher == null || currentFetcher == null || localFetcher.equals(currentFetcher),
-          "Fetchers don't match!, old: " + localFetcher + " new: " + currentFetcher);
+      // Keeping track of the fetcher here and calling cleanup is excessively paranoid, we call
+      // close in all cases anyway.
       if (localFetcher != null) {
         localFetcher.cleanup();
       }
@@ -253,7 +259,7 @@ public void run() {
   }
 
   private void runWrapped() {
-     switch (runReason) {
+    switch (runReason) {
       case INITIALIZE:
         stage = getNextStage(Stage.INITIALIZE);
         currentGenerator = getNextGenerator();
@@ -310,7 +316,7 @@ private void runGenerators() {
 
   private void notifyFailed() {
     setNotifiedOrThrow();
-    GlideException e = new GlideException("Failed to load resource", new ArrayList<>(exceptions));
+    GlideException e = new GlideException("Failed to load resource", new ArrayList<>(throwables));
     callback.onLoadFailed(e);
     onLoadFailed();
   }
@@ -380,7 +386,7 @@ public void onDataFetcherFailed(Key attemptedKey, Exception e, DataFetcher<?> fe
     fetcher.cleanup();
     GlideException exception = new GlideException("Fetching data failed", e);
     exception.setLoggingDetails(attemptedKey, dataSource, fetcher.getDataClass());
-    exceptions.add(exception);
+    throwables.add(exception);
     if (Thread.currentThread() != currentThread) {
       runReason = RunReason.SWITCH_TO_SOURCE_SERVICE;
       callback.reschedule(this);
@@ -393,15 +399,15 @@ private void decodeFromRetrievedData() {
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
       logWithTimeAndKey("Retrieved data", startFetchTime,
           "data: " + currentData
-          + ", cache key: " + currentSourceKey
-          + ", fetcher: " + currentFetcher);
+              + ", cache key: " + currentSourceKey
+              + ", fetcher: " + currentFetcher);
     }
     Resource<R> resource = null;
     try {
       resource = decodeFromData(currentFetcher, currentData, currentDataSource);
     } catch (GlideException e) {
       e.setLoggingDetails(currentAttemptingKey, currentDataSource);
-      exceptions.add(e);
+      throwables.add(e);
     }
     if (resource != null) {
       notifyEncodeAndRelease(resource, currentDataSource);
@@ -433,8 +439,10 @@ private void notifyEncodeAndRelease(Resource<R> resource, DataSource dataSource)
       if (lockedResource != null) {
         lockedResource.unlock();
       }
-      onEncodeComplete();
     }
+    // Call onEncodeComplete outside the finally block so that it's not called if the encode process
+    // throws.
+    onEncodeComplete();
   }
 
   private <Data> Resource<R> decodeFromData(DataFetcher<?> fetcher, Data data,
@@ -461,6 +469,7 @@ private void notifyEncodeAndRelease(Resource<R> resource, DataSource dataSource)
     return runLoadPath(data, dataSource, path);
   }
 
+  @NonNull
   private Options getOptionsWithHardwareConfig(DataSource dataSource) {
     Options options = this.options;
     if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {
@@ -503,11 +512,74 @@ private void logWithTimeAndKey(String message, long startTime, String extraArgs)
         + Thread.currentThread().getName());
   }
 
+  @NonNull
   @Override
   public StateVerifier getVerifier() {
     return stateVerifier;
   }
 
+  @Synthetic
+  @NonNull
+  <Z> Resource<Z> onResourceDecoded(DataSource dataSource,
+      @NonNull Resource<Z> decoded) {
+    @SuppressWarnings("unchecked")
+    Class<Z> resourceSubClass = (Class<Z>) decoded.get().getClass();
+    Transformation<Z> appliedTransformation = null;
+    Resource<Z> transformed = decoded;
+    if (dataSource != DataSource.RESOURCE_DISK_CACHE) {
+      appliedTransformation = decodeHelper.getTransformation(resourceSubClass);
+      transformed = appliedTransformation.transform(glideContext, decoded, width, height);
+    }
+    // TODO: Make this the responsibility of the Transformation.
+    if (!decoded.equals(transformed)) {
+      decoded.recycle();
+    }
+
+    final EncodeStrategy encodeStrategy;
+    final ResourceEncoder<Z> encoder;
+    if (decodeHelper.isResourceEncoderAvailable(transformed)) {
+      encoder = decodeHelper.getResultEncoder(transformed);
+      encodeStrategy = encoder.getEncodeStrategy(options);
+    } else {
+      encoder = null;
+      encodeStrategy = EncodeStrategy.NONE;
+    }
+
+    Resource<Z> result = transformed;
+    boolean isFromAlternateCacheKey = !decodeHelper.isSourceKey(currentSourceKey);
+    if (diskCacheStrategy.isResourceCacheable(isFromAlternateCacheKey, dataSource,
+        encodeStrategy)) {
+      if (encoder == null) {
+        throw new Registry.NoResultEncoderAvailableException(transformed.get().getClass());
+      }
+      final Key key;
+      switch (encodeStrategy) {
+        case SOURCE:
+          key = new DataCacheKey(currentSourceKey, signature);
+          break;
+        case TRANSFORMED:
+          key =
+              new ResourceCacheKey(
+                  decodeHelper.getArrayPool(),
+                  currentSourceKey,
+                  signature,
+                  width,
+                  height,
+                  appliedTransformation,
+                  resourceSubClass,
+                  options);
+          break;
+        default:
+          throw new IllegalArgumentException("Unknown strategy: " + encodeStrategy);
+      }
+
+      LockedResource<Z> lockedResult = LockedResource.obtain(transformed);
+      deferredEncodeManager.init(key, encoder, lockedResult);
+      result = lockedResult;
+    }
+    return result;
+  }
+
   private final class DecodeCallback<Z> implements DecodePath.DecodeCallback<Z> {
 
     private final DataSource dataSource;
@@ -517,57 +589,10 @@ public StateVerifier getVerifier() {
       this.dataSource = dataSource;
     }
 
+    @NonNull
     @Override
-    public Resource<Z> onResourceDecoded(Resource<Z> decoded) {
-      Class<Z> resourceSubClass = getResourceClass(decoded);
-      Transformation<Z> appliedTransformation = null;
-      Resource<Z> transformed = decoded;
-      if (dataSource != DataSource.RESOURCE_DISK_CACHE) {
-        appliedTransformation = decodeHelper.getTransformation(resourceSubClass);
-        transformed = appliedTransformation.transform(glideContext, decoded, width, height);
-      }
-      // TODO: Make this the responsibility of the Transformation.
-      if (!decoded.equals(transformed)) {
-        decoded.recycle();
-      }
-
-      final EncodeStrategy encodeStrategy;
-      final ResourceEncoder<Z> encoder;
-      if (decodeHelper.isResourceEncoderAvailable(transformed)) {
-        encoder = decodeHelper.getResultEncoder(transformed);
-        encodeStrategy = encoder.getEncodeStrategy(options);
-      } else {
-        encoder = null;
-        encodeStrategy = EncodeStrategy.NONE;
-      }
-
-      Resource<Z> result = transformed;
-      boolean isFromAlternateCacheKey = !decodeHelper.isSourceKey(currentSourceKey);
-      if (diskCacheStrategy.isResourceCacheable(isFromAlternateCacheKey, dataSource,
-          encodeStrategy)) {
-        if (encoder == null) {
-          throw new Registry.NoResultEncoderAvailableException(transformed.get().getClass());
-        }
-        final Key key;
-        if (encodeStrategy == EncodeStrategy.SOURCE) {
-          key = new DataCacheKey(currentSourceKey, signature);
-        } else if (encodeStrategy == EncodeStrategy.TRANSFORMED) {
-          key = new ResourceCacheKey(currentSourceKey, signature, width, height,
-              appliedTransformation, resourceSubClass, options);
-        } else {
-          throw new IllegalArgumentException("Unknown strategy: " + encodeStrategy);
-        }
-
-        LockedResource<Z> lockedResult = LockedResource.obtain(transformed);
-        deferredEncodeManager.init(key, encoder, lockedResult);
-        result = lockedResult;
-      }
-      return result;
-    }
-
-    @SuppressWarnings("unchecked")
-    private Class<Z> getResourceClass(Resource<Z> resource) {
-      return (Class<Z>) resource.get().getClass();
+    public Resource<Z> onResourceDecoded(@NonNull Resource<Z> decoded) {
+      return DecodeJob.this.onResourceDecoded(dataSource, decoded);
     }
   }
 
@@ -609,8 +634,8 @@ private boolean isComplete(boolean isRemovedFromQueue) {
   }
 
   /**
-   * Allows transformed resources to be encoded after the transcoded result is already delivered
-   * to requestors.
+   * Allows transformed resources to be encoded after the transcoded result is already delivered to
+   * requestors.
    */
   private static class DeferredEncodeManager<Z> {
     private Key key;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java
index e74320bf0..919dc7584 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java
@@ -1,11 +1,13 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
 import android.support.v4.util.Pools.Pool;
 import android.util.Log;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.data.DataRewinder;
 import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
+import com.bumptech.glide.util.Preconditions;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
@@ -23,13 +25,13 @@
   private final Class<DataType> dataClass;
   private final List<? extends ResourceDecoder<DataType, ResourceType>> decoders;
   private final ResourceTranscoder<ResourceType, Transcode> transcoder;
-  private final Pool<List<Exception>> listPool;
+  private final Pool<List<Throwable>> listPool;
   private final String failureMessage;
 
   public DecodePath(Class<DataType> dataClass, Class<ResourceType> resourceClass,
       Class<Transcode> transcodeClass,
       List<? extends ResourceDecoder<DataType, ResourceType>> decoders,
-      ResourceTranscoder<ResourceType, Transcode> transcoder, Pool<List<Exception>> listPool) {
+      ResourceTranscoder<ResourceType, Transcode> transcoder, Pool<List<Throwable>> listPool) {
     this.dataClass = dataClass;
     this.decoders = decoders;
     this.transcoder = transcoder;
@@ -39,15 +41,16 @@ public DecodePath(Class<DataType> dataClass, Class<ResourceType> resourceClass,
   }
 
   public Resource<Transcode> decode(DataRewinder<DataType> rewinder, int width, int height,
-      Options options, DecodeCallback<ResourceType> callback) throws GlideException {
+      @NonNull Options options, DecodeCallback<ResourceType> callback) throws GlideException {
     Resource<ResourceType> decoded = decodeResource(rewinder, width, height, options);
     Resource<ResourceType> transformed = callback.onResourceDecoded(decoded);
     return transcoder.transcode(transformed, options);
   }
 
+  @NonNull
   private Resource<ResourceType> decodeResource(DataRewinder<DataType> rewinder, int width,
-      int height, Options options) throws GlideException {
-    List<Exception> exceptions = listPool.acquire();
+      int height, @NonNull Options options) throws GlideException {
+    List<Throwable> exceptions = Preconditions.checkNotNull(listPool.acquire());
     try {
       return decodeResourceWithList(rewinder, width, height, options, exceptions);
     } finally {
@@ -55,9 +58,11 @@ public DecodePath(Class<DataType> dataClass, Class<ResourceType> resourceClass,
     }
   }
 
+  @NonNull
   private Resource<ResourceType> decodeResourceWithList(DataRewinder<DataType> rewinder, int width,
-      int height, Options options, List<Exception> exceptions) throws GlideException {
+      int height, @NonNull Options options, List<Throwable> exceptions) throws GlideException {
     Resource<ResourceType> result = null;
+    //noinspection ForLoopReplaceableByForEach to improve perf
     for (int i = 0, size = decoders.size(); i < size; i++) {
       ResourceDecoder<DataType, ResourceType> decoder = decoders.get(i);
       try {
@@ -68,7 +73,7 @@ public DecodePath(Class<DataType> dataClass, Class<ResourceType> resourceClass,
         }
         // Some decoders throw unexpectedly. If they do, we shouldn't fail the entire load path, but
         // instead log and continue. See #2406 for an example.
-      } catch (IOException | RuntimeException e) {
+      } catch (IOException | RuntimeException | OutOfMemoryError e) {
         if (Log.isLoggable(TAG, Log.VERBOSE)) {
           Log.v(TAG, "Failed to decode data for " + decoder, e);
         }
@@ -93,6 +98,7 @@ public String toString() {
   }
 
   interface DecodeCallback<ResourceType> {
-    Resource<ResourceType> onResourceDecoded(Resource<ResourceType> resource);
+    @NonNull
+    Resource<ResourceType> onResourceDecoded(@NonNull Resource<ResourceType> resource);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
index 315d4cf11..dcb320c2d 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
@@ -1,7 +1,8 @@
 package com.bumptech.glide.load.engine;
 
-import android.os.Looper;
-import android.os.MessageQueue;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 import android.support.v4.util.Pools;
 import android.util.Log;
 import com.bumptech.glide.GlideContext;
@@ -16,13 +17,13 @@
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
 import com.bumptech.glide.request.ResourceCallback;
 import com.bumptech.glide.util.LogTime;
+import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
 import com.bumptech.glide.util.pool.FactoryPools;
-import java.lang.ref.ReferenceQueue;
-import java.lang.ref.WeakReference;
-import java.util.HashMap;
 import java.util.Map;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.TimeUnit;
 
 /**
  * Responsible for starting loads and managing active and cached resources.
@@ -32,64 +33,61 @@
     EngineResource.ResourceListener {
   private static final String TAG = "Engine";
   private static final int JOB_POOL_SIZE = 150;
-  private final Map<Key, EngineJob<?>> jobs;
+  private final Jobs jobs;
   private final EngineKeyFactory keyFactory;
   private final MemoryCache cache;
   private final EngineJobFactory engineJobFactory;
-  private final Map<Key, WeakReference<EngineResource<?>>> activeResources;
   private final ResourceRecycler resourceRecycler;
   private final LazyDiskCacheProvider diskCacheProvider;
   private final DecodeJobFactory decodeJobFactory;
+  private final ActiveResources activeResources;
 
-  // Lazily instantiate to avoid exceptions if Glide is initialized on a background thread. See
-  // #295.
-  private ReferenceQueue<EngineResource<?>> resourceReferenceQueue;
-
-  /**
-   * Allows a request to indicate it no longer is interested in a given load.
-   */
-  public static class LoadStatus {
-    private final EngineJob<?> engineJob;
-    private final ResourceCallback cb;
-
-    public LoadStatus(ResourceCallback cb, EngineJob<?> engineJob) {
-      this.cb = cb;
-      this.engineJob = engineJob;
-    }
-
-    public void cancel() {
-      engineJob.removeCallback(cb);
-    }
-  }
-
-  public Engine(MemoryCache memoryCache,
+  public Engine(
+      MemoryCache memoryCache,
       DiskCache.Factory diskCacheFactory,
       GlideExecutor diskCacheExecutor,
       GlideExecutor sourceExecutor,
-      GlideExecutor sourceUnlimitedExecutor) {
-    this(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor, sourceUnlimitedExecutor,
-        null, null, null, null, null, null);
+      GlideExecutor sourceUnlimitedExecutor,
+      GlideExecutor animationExecutor,
+      boolean isActiveResourceRetentionAllowed) {
+    this(
+        memoryCache,
+        diskCacheFactory,
+        diskCacheExecutor,
+        sourceExecutor,
+        sourceUnlimitedExecutor,
+        animationExecutor,
+        /*jobs=*/ null,
+        /*keyFactory=*/ null,
+        /*activeResources=*/ null,
+        /*engineJobFactory=*/ null,
+        /*decodeJobFactory=*/ null,
+        /*resourceRecycler=*/ null,
+        isActiveResourceRetentionAllowed);
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   Engine(MemoryCache cache,
       DiskCache.Factory diskCacheFactory,
       GlideExecutor diskCacheExecutor,
       GlideExecutor sourceExecutor,
       GlideExecutor sourceUnlimitedExecutor,
-      Map<Key, EngineJob<?>> jobs,
+      GlideExecutor animationExecutor,
+      Jobs jobs,
       EngineKeyFactory keyFactory,
-      Map<Key, WeakReference<EngineResource<?>>> activeResources,
+      ActiveResources activeResources,
       EngineJobFactory engineJobFactory,
       DecodeJobFactory decodeJobFactory,
-      ResourceRecycler resourceRecycler) {
+      ResourceRecycler resourceRecycler,
+      boolean isActiveResourceRetentionAllowed) {
     this.cache = cache;
     this.diskCacheProvider = new LazyDiskCacheProvider(diskCacheFactory);
 
     if (activeResources == null) {
-      activeResources = new HashMap<>();
+      activeResources = new ActiveResources(isActiveResourceRetentionAllowed);
     }
     this.activeResources = activeResources;
+    activeResources.setListener(this);
 
     if (keyFactory == null) {
       keyFactory = new EngineKeyFactory();
@@ -97,13 +95,14 @@ public Engine(MemoryCache memoryCache,
     this.keyFactory = keyFactory;
 
     if (jobs == null) {
-      jobs = new HashMap<>();
+      jobs = new Jobs();
     }
     this.jobs = jobs;
 
     if (engineJobFactory == null) {
-      engineJobFactory = new EngineJobFactory(diskCacheExecutor, sourceExecutor,
-          sourceUnlimitedExecutor, this);
+      engineJobFactory =
+          new EngineJobFactory(
+              diskCacheExecutor, sourceExecutor, sourceUnlimitedExecutor, animationExecutor, this);
     }
     this.engineJobFactory = engineJobFactory;
 
@@ -121,19 +120,26 @@ public Engine(MemoryCache memoryCache,
   }
 
   /**
-   * Starts a load for the given arguments. Must be called on the main thread.
+   * Starts a load for the given arguments.
+   *
+   * <p>Must be called on the main thread.
    *
-   * <p> The flow for any request is as follows: <ul> <li>Check the memory cache and provide the
-   * cached resource if present</li> <li>Check the current put of actively used resources and return
-   * the active resource if present</li> <li>Check the current put of in progress loads and add the
-   * cb to the in progress load if present</li> <li>Start a new load</li> </ul> </p>
+   * <p>The flow for any request is as follows:
+   * <ul>
+   *   <li>Check the current set of actively used resources, return the active resource if
+   *   present, and move any newly inactive resources into the memory cache.</li>
+   *   <li>Check the memory cache and provide the cached resource if present.</li>
+   *   <li>Check the current set of in progress loads and add the cb to the in progress load if
+   *   one is present.</li>
+   *   <li>Start a new load.</li>
+   * </ul>
    *
-   * <p> Active resources are those that have been provided to at least one request and have not yet
+   * <p>Active resources are those that have been provided to at least one request and have not yet
    * been released. Once all consumers of a resource have released that resource, the resource then
    * goes to cache. If the resource is ever returned to a new consumer from cache, it is re-added to
    * the active resources. If the resource is evicted from the cache, its resources are recycled and
    * re-used if possible and the resource is discarded. There is no strict requirement that
-   * consumers release their resources so active resources are held weakly. </p>
+   * consumers release their resources so active resources are held weakly.
    *
    * @param width  The target width in pixels of the desired resource.
    * @param height The target height in pixels of the desired resource.
@@ -155,6 +161,7 @@ public Engine(MemoryCache memoryCache,
       Options options,
       boolean isMemoryCacheable,
       boolean useUnlimitedSourceExecutorPool,
+      boolean useAnimationPool,
       boolean onlyRetrieveFromCache,
       ResourceCallback cb) {
     Util.assertMainThread();
@@ -163,25 +170,25 @@ public Engine(MemoryCache memoryCache,
     EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,
         resourceClass, transcodeClass, options);
 
-    EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);
-    if (cached != null) {
-      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);
+    EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);
+    if (active != null) {
+      cb.onResourceReady(active, DataSource.MEMORY_CACHE);
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
-        logWithTimeAndKey("Loaded resource from cache", startTime, key);
+        logWithTimeAndKey("Loaded resource from active resources", startTime, key);
       }
       return null;
     }
 
-    EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);
-    if (active != null) {
-      cb.onResourceReady(active, DataSource.MEMORY_CACHE);
+    EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);
+    if (cached != null) {
+      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
-        logWithTimeAndKey("Loaded resource from active resources", startTime, key);
+        logWithTimeAndKey("Loaded resource from cache", startTime, key);
       }
       return null;
     }
 
-    EngineJob<?> current = jobs.get(key);
+    EngineJob<?> current = jobs.get(key, onlyRetrieveFromCache);
     if (current != null) {
       current.addCallback(cb);
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
@@ -190,26 +197,35 @@ public Engine(MemoryCache memoryCache,
       return new LoadStatus(cb, current);
     }
 
-    EngineJob<R> engineJob = engineJobFactory.build(key, isMemoryCacheable,
-        useUnlimitedSourceExecutorPool);
-    DecodeJob<R> decodeJob = decodeJobFactory.build(
-        glideContext,
-        model,
-        key,
-        signature,
-        width,
-        height,
-        resourceClass,
-        transcodeClass,
-        priority,
-        diskCacheStrategy,
-        transformations,
-        isTransformationRequired,
-        isScaleOnlyOrNoTransform,
-        onlyRetrieveFromCache,
-        options,
-        engineJob);
+    EngineJob<R> engineJob =
+        engineJobFactory.build(
+            key,
+            isMemoryCacheable,
+            useUnlimitedSourceExecutorPool,
+            useAnimationPool,
+            onlyRetrieveFromCache);
+
+    DecodeJob<R> decodeJob =
+        decodeJobFactory.build(
+            glideContext,
+            model,
+            key,
+            signature,
+            width,
+            height,
+            resourceClass,
+            transcodeClass,
+            priority,
+            diskCacheStrategy,
+            transformations,
+            isTransformationRequired,
+            isScaleOnlyOrNoTransform,
+            onlyRetrieveFromCache,
+            options,
+            engineJob);
+
     jobs.put(key, engineJob);
+
     engineJob.addCallback(cb);
     engineJob.start(decodeJob);
 
@@ -223,20 +239,14 @@ private static void logWithTimeAndKey(String log, long startTime, Key key) {
     Log.v(TAG, log + " in " + LogTime.getElapsedMillis(startTime) + "ms, key: " + key);
   }
 
+  @Nullable
   private EngineResource<?> loadFromActiveResources(Key key, boolean isMemoryCacheable) {
     if (!isMemoryCacheable) {
       return null;
     }
-
-    EngineResource<?> active = null;
-    WeakReference<EngineResource<?>> activeRef = activeResources.get(key);
-    if (activeRef != null) {
-      active = activeRef.get();
-      if (active != null) {
-        active.acquire();
-      } else {
-        activeResources.remove(key);
-      }
+    EngineResource<?> active = activeResources.get(key);
+    if (active != null) {
+      active.acquire();
     }
 
     return active;
@@ -250,12 +260,11 @@ private static void logWithTimeAndKey(String log, long startTime, Key key) {
     EngineResource<?> cached = getEngineResourceFromCache(key);
     if (cached != null) {
       cached.acquire();
-      activeResources.put(key, new ResourceWeakReference(key, cached, getReferenceQueue()));
+      activeResources.activate(key, cached);
     }
     return cached;
   }
 
-  @SuppressWarnings("unchecked")
   private EngineResource<?> getEngineResourceFromCache(Key key) {
     Resource<?> cached = cache.remove(key);
 
@@ -266,7 +275,7 @@ private static void logWithTimeAndKey(String log, long startTime, Key key) {
       // Save an object allocation if we've cached an EngineResource (the typical case).
       result = (EngineResource<?>) cached;
     } else {
-      result = new EngineResource<>(cached, true /*isMemoryCacheable*/);
+      result = new EngineResource<>(cached, true /*isMemoryCacheable*/, true /*isRecyclable*/);
     }
     return result;
   }
@@ -282,39 +291,37 @@ public void release(Resource<?> resource) {
 
   @SuppressWarnings("unchecked")
   @Override
-  public void onEngineJobComplete(Key key, EngineResource<?> resource) {
+  public void onEngineJobComplete(EngineJob<?> engineJob, Key key, EngineResource<?> resource) {
     Util.assertMainThread();
     // A null resource indicates that the load failed, usually due to an exception.
     if (resource != null) {
       resource.setResourceListener(key, this);
 
       if (resource.isCacheable()) {
-        activeResources.put(key, new ResourceWeakReference(key, resource, getReferenceQueue()));
+        activeResources.activate(key, resource);
       }
     }
-    // TODO: should this check that the engine job is still current?
-    jobs.remove(key);
+
+    jobs.removeIfCurrent(key, engineJob);
   }
 
   @Override
-  public void onEngineJobCancelled(EngineJob engineJob, Key key) {
+  public void onEngineJobCancelled(EngineJob<?> engineJob, Key key) {
     Util.assertMainThread();
-    EngineJob<?> current = jobs.get(key);
-    if (engineJob.equals(current)) {
-      jobs.remove(key);
-    }
+
+    jobs.removeIfCurrent(key, engineJob);
   }
 
   @Override
-  public void onResourceRemoved(final Resource<?> resource) {
+  public void onResourceRemoved(@NonNull final Resource<?> resource) {
     Util.assertMainThread();
     resourceRecycler.recycle(resource);
   }
 
   @Override
-  public void onResourceReleased(Key cacheKey, EngineResource resource) {
+  public void onResourceReleased(Key cacheKey, EngineResource<?> resource) {
     Util.assertMainThread();
-    activeResources.remove(cacheKey);
+    activeResources.deactivate(cacheKey);
     if (resource.isCacheable()) {
       cache.put(cacheKey, resource);
     } else {
@@ -326,13 +333,28 @@ public void clearDiskCache() {
     diskCacheProvider.getDiskCache().clear();
   }
 
-  private ReferenceQueue<EngineResource<?>> getReferenceQueue() {
-    if (resourceReferenceQueue == null) {
-      resourceReferenceQueue = new ReferenceQueue<>();
-      MessageQueue queue = Looper.myQueue();
-      queue.addIdleHandler(new RefQueueIdleHandler(activeResources, resourceReferenceQueue));
+  @VisibleForTesting
+  public void shutdown() {
+    engineJobFactory.shutdown();
+    diskCacheProvider.clearDiskCacheIfCreated();
+    activeResources.shutdown();
+  }
+
+  /**
+   * Allows a request to indicate it no longer is interested in a given load.
+   */
+  public static class LoadStatus {
+    private final EngineJob<?> engineJob;
+    private final ResourceCallback cb;
+
+    LoadStatus(ResourceCallback cb, EngineJob<?> engineJob) {
+      this.cb = cb;
+      this.engineJob = engineJob;
+    }
+
+    public void cancel() {
+      engineJob.removeCallback(cb);
     }
-    return resourceReferenceQueue;
   }
 
   private static class LazyDiskCacheProvider implements DecodeJob.DiskCacheProvider {
@@ -340,10 +362,18 @@ public void clearDiskCache() {
     private final DiskCache.Factory factory;
     private volatile DiskCache diskCache;
 
-    public LazyDiskCacheProvider(DiskCache.Factory factory) {
+    LazyDiskCacheProvider(DiskCache.Factory factory) {
       this.factory = factory;
     }
 
+    @VisibleForTesting
+    synchronized void clearDiskCacheIfCreated() {
+      if (diskCache == null) {
+        return;
+      }
+      diskCache.clear();
+    }
+
     @Override
     public DiskCache getDiskCache() {
       if (diskCache == null) {
@@ -360,47 +390,15 @@ public DiskCache getDiskCache() {
     }
   }
 
-  private static class ResourceWeakReference extends WeakReference<EngineResource<?>> {
-    @Synthetic final Key key;
-
-    public ResourceWeakReference(Key key, EngineResource<?> r,
-        ReferenceQueue<? super EngineResource<?>> q) {
-      super(r, q);
-      this.key = key;
-    }
-  }
-
-  // Responsible for cleaning up the active resource map by remove weak references that have been
-  // cleared.
-  private static class RefQueueIdleHandler implements MessageQueue.IdleHandler {
-    private final Map<Key, WeakReference<EngineResource<?>>> activeResources;
-    private final ReferenceQueue<EngineResource<?>> queue;
-
-    public RefQueueIdleHandler(Map<Key, WeakReference<EngineResource<?>>> activeResources,
-        ReferenceQueue<EngineResource<?>> queue) {
-      this.activeResources = activeResources;
-      this.queue = queue;
-    }
-
-    @Override
-    public boolean queueIdle() {
-      ResourceWeakReference ref = (ResourceWeakReference) queue.poll();
-      if (ref != null) {
-        activeResources.remove(ref.key);
-      }
-
-      return true;
-    }
-  }
-
-  // Visible for testing.
+  @VisibleForTesting
   static class DecodeJobFactory {
     @Synthetic final DecodeJob.DiskCacheProvider diskCacheProvider;
-    @Synthetic final Pools.Pool<DecodeJob<?>> pool = FactoryPools.simple(JOB_POOL_SIZE,
-        new FactoryPools.Factory<DecodeJob<?>>() {
+    @Synthetic final Pools.Pool<DecodeJob<?>> pool =
+        FactoryPools.simple(JOB_POOL_SIZE,
+            new FactoryPools.Factory<DecodeJob<?>>() {
           @Override
           public DecodeJob<?> create() {
-            return new DecodeJob<Object>(diskCacheProvider, pool);
+            return new DecodeJob<>(diskCacheProvider, pool);
           }
         });
     private int creationOrder;
@@ -426,7 +424,7 @@ public boolean queueIdle() {
         boolean onlyRetrieveFromCache,
         Options options,
         DecodeJob.Callback<R> callback) {
-      DecodeJob<R> result = (DecodeJob<R>) pool.acquire();
+      DecodeJob<R> result = Preconditions.checkNotNull((DecodeJob<R>) pool.acquire());
       return result.init(
           glideContext,
           model,
@@ -448,34 +446,79 @@ public boolean queueIdle() {
     }
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class EngineJobFactory {
     @Synthetic final GlideExecutor diskCacheExecutor;
     @Synthetic final GlideExecutor sourceExecutor;
     @Synthetic final GlideExecutor sourceUnlimitedExecutor;
+    @Synthetic final GlideExecutor animationExecutor;
     @Synthetic final EngineJobListener listener;
-    @Synthetic final Pools.Pool<EngineJob<?>> pool = FactoryPools.simple(JOB_POOL_SIZE,
-        new FactoryPools.Factory<EngineJob<?>>() {
-          @Override
-          public EngineJob<?> create() {
-            return new EngineJob<Object>(diskCacheExecutor, sourceExecutor, sourceUnlimitedExecutor,
-                listener, pool);
-          }
-        });
-
-    EngineJobFactory(GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor,
-        GlideExecutor sourceUnlimitedExecutor, EngineJobListener listener) {
+    @Synthetic final Pools.Pool<EngineJob<?>> pool =
+        FactoryPools.simple(
+            JOB_POOL_SIZE,
+            new FactoryPools.Factory<EngineJob<?>>() {
+              @Override
+              public EngineJob<?> create() {
+                return new EngineJob<>(
+                    diskCacheExecutor,
+                    sourceExecutor,
+                    sourceUnlimitedExecutor,
+                    animationExecutor,
+                    listener,
+                    pool);
+              }
+            });
+
+    EngineJobFactory(
+        GlideExecutor diskCacheExecutor,
+        GlideExecutor sourceExecutor,
+        GlideExecutor sourceUnlimitedExecutor,
+        GlideExecutor animationExecutor,
+        EngineJobListener listener) {
       this.diskCacheExecutor = diskCacheExecutor;
       this.sourceExecutor = sourceExecutor;
       this.sourceUnlimitedExecutor = sourceUnlimitedExecutor;
+      this.animationExecutor = animationExecutor;
       this.listener = listener;
     }
 
+    @VisibleForTesting
+    void shutdown() {
+      shutdownAndAwaitTermination(diskCacheExecutor);
+      shutdownAndAwaitTermination(sourceExecutor);
+      shutdownAndAwaitTermination(sourceUnlimitedExecutor);
+      shutdownAndAwaitTermination(animationExecutor);
+    }
+
     @SuppressWarnings("unchecked")
-    <R> EngineJob<R> build(Key key, boolean isMemoryCacheable,
-        boolean useUnlimitedSourceGeneratorPool) {
-      EngineJob<R> result = (EngineJob<R>) pool.acquire();
-      return result.init(key, isMemoryCacheable, useUnlimitedSourceGeneratorPool);
+    <R> EngineJob<R> build(
+        Key key,
+        boolean isMemoryCacheable,
+        boolean useUnlimitedSourceGeneratorPool,
+        boolean useAnimationPool,
+        boolean onlyRetrieveFromCache) {
+      EngineJob<R> result = Preconditions.checkNotNull((EngineJob<R>) pool.acquire());
+      return result.init(
+          key,
+          isMemoryCacheable,
+          useUnlimitedSourceGeneratorPool,
+          useAnimationPool,
+          onlyRetrieveFromCache);
+    }
+
+    private static void shutdownAndAwaitTermination(ExecutorService pool) {
+      long shutdownSeconds = 5;
+      pool.shutdown();
+      try {
+        if (!pool.awaitTermination(shutdownSeconds, TimeUnit.SECONDS)) {
+          pool.shutdownNow();
+          if (!pool.awaitTermination(shutdownSeconds, TimeUnit.SECONDS)) {
+            throw new RuntimeException("Failed to shutdown");
+          }
+        }
+      } catch (InterruptedException ie) {
+        throw new RuntimeException(ie);
+      }
     }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
index 3517092ac..344a15036 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
@@ -3,6 +3,8 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
+import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
 import android.support.v4.util.Pools;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
@@ -39,10 +41,13 @@
   private final GlideExecutor diskCacheExecutor;
   private final GlideExecutor sourceExecutor;
   private final GlideExecutor sourceUnlimitedExecutor;
+  private final GlideExecutor animationExecutor;
 
   private Key key;
   private boolean isCacheable;
   private boolean useUnlimitedSourceGeneratorPool;
+  private boolean useAnimationPool;
+  private boolean onlyRetrieveFromCache;
   private Resource<?> resource;
   private DataSource dataSource;
   private boolean hasResource;
@@ -57,31 +62,53 @@
   // Checked primarily on the main thread, but also on other threads in reschedule.
   private volatile boolean isCancelled;
 
-  EngineJob(GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor,
+  EngineJob(
+      GlideExecutor diskCacheExecutor,
+      GlideExecutor sourceExecutor,
       GlideExecutor sourceUnlimitedExecutor,
-      EngineJobListener listener, Pools.Pool<EngineJob<?>> pool) {
-    this(diskCacheExecutor, sourceExecutor, sourceUnlimitedExecutor, listener, pool,
+      GlideExecutor animationExecutor,
+      EngineJobListener listener,
+      Pools.Pool<EngineJob<?>> pool) {
+    this(
+        diskCacheExecutor,
+        sourceExecutor,
+        sourceUnlimitedExecutor,
+        animationExecutor,
+        listener,
+        pool,
         DEFAULT_FACTORY);
   }
 
-  // Visible for testing.
-  EngineJob(GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor,
+  @VisibleForTesting
+  EngineJob(
+      GlideExecutor diskCacheExecutor,
+      GlideExecutor sourceExecutor,
       GlideExecutor sourceUnlimitedExecutor,
-      EngineJobListener listener, Pools.Pool<EngineJob<?>> pool,
+      GlideExecutor animationExecutor,
+      EngineJobListener listener,
+      Pools.Pool<EngineJob<?>> pool,
       EngineResourceFactory engineResourceFactory) {
     this.diskCacheExecutor = diskCacheExecutor;
     this.sourceExecutor = sourceExecutor;
     this.sourceUnlimitedExecutor = sourceUnlimitedExecutor;
+    this.animationExecutor = animationExecutor;
     this.listener = listener;
     this.pool = pool;
     this.engineResourceFactory = engineResourceFactory;
   }
 
-  // Visible for testing.
-  EngineJob<R> init(Key key, boolean isCacheable, boolean useUnlimitedSourceGeneratorPool) {
+  @VisibleForTesting
+  EngineJob<R> init(
+      Key key,
+      boolean isCacheable,
+      boolean useUnlimitedSourceGeneratorPool,
+      boolean useAnimationPool,
+      boolean onlyRetrieveFromCache) {
     this.key = key;
     this.isCacheable = isCacheable;
     this.useUnlimitedSourceGeneratorPool = useUnlimitedSourceGeneratorPool;
+    this.useAnimationPool = useAnimationPool;
+    this.onlyRetrieveFromCache = onlyRetrieveFromCache;
     return this;
   }
 
@@ -93,7 +120,7 @@ public void start(DecodeJob<R> decodeJob) {
     executor.execute(decodeJob);
   }
 
-  public void addCallback(ResourceCallback cb) {
+  void addCallback(ResourceCallback cb) {
     Util.assertMainThread();
     stateVerifier.throwIfRecycled();
     if (hasResource) {
@@ -105,7 +132,7 @@ public void addCallback(ResourceCallback cb) {
     }
   }
 
-  public void removeCallback(ResourceCallback cb) {
+  void removeCallback(ResourceCallback cb) {
     Util.assertMainThread();
     stateVerifier.throwIfRecycled();
     if (hasResource || hasLoadFailed) {
@@ -118,8 +145,13 @@ public void removeCallback(ResourceCallback cb) {
     }
   }
 
+  boolean onlyRetrieveFromCache() {
+    return onlyRetrieveFromCache;
+  }
+
   private GlideExecutor getActiveSourceExecutor() {
-    return useUnlimitedSourceGeneratorPool ? sourceUnlimitedExecutor : sourceExecutor;
+    return useUnlimitedSourceGeneratorPool
+        ? sourceUnlimitedExecutor : (useAnimationPool ? animationExecutor : sourceExecutor);
   }
 
   // We cannot remove callbacks while notifying our list of callbacks directly because doing so
@@ -176,9 +208,11 @@ void handleResultOnMainThread() {
     // Hold on to resource for duration of request so we don't recycle it in the middle of
     // notifying if it synchronously released by one of the callbacks.
     engineResource.acquire();
-    listener.onEngineJobComplete(key, engineResource);
+    listener.onEngineJobComplete(this, key, engineResource);
 
-    for (ResourceCallback cb : cbs) {
+    //noinspection ForLoopReplaceableByForEach to improve perf
+    for (int i = 0, size = cbs.size(); i < size; i++) {
+      ResourceCallback cb = cbs.get(i);
       if (!isInIgnoredCallbacks(cb)) {
         engineResource.acquire();
         cb.onResourceReady(engineResource, dataSource);
@@ -252,7 +286,7 @@ void handleExceptionOnMainThread() {
     }
     hasLoadFailed = true;
 
-    listener.onEngineJobComplete(key, null);
+    listener.onEngineJobComplete(this, key, null);
 
     for (ResourceCallback cb : cbs) {
       if (!isInIgnoredCallbacks(cb)) {
@@ -263,21 +297,23 @@ void handleExceptionOnMainThread() {
     release(false /*isRemovedFromQueue*/);
   }
 
+  @NonNull
   @Override
   public StateVerifier getVerifier() {
     return stateVerifier;
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class EngineResourceFactory {
     public <R> EngineResource<R> build(Resource<R> resource, boolean isMemoryCacheable) {
-      return new EngineResource<>(resource, isMemoryCacheable);
+      return new EngineResource<>(resource, isMemoryCacheable, /*isRecyclable=*/ true);
     }
   }
 
   private static class MainThreadCallback implements Handler.Callback {
 
     @Synthetic
+    @SuppressWarnings("WeakerAccess")
     MainThreadCallback() { }
 
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineJobListener.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineJobListener.java
index 0d3c2e410..4b068286f 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineJobListener.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJobListener.java
@@ -4,7 +4,7 @@
 
 interface EngineJobListener {
 
-  void onEngineJobComplete(Key key, EngineResource<?> resource);
+  void onEngineJobComplete(EngineJob<?> engineJob, Key key, EngineResource<?> resource);
 
-  void onEngineJobCancelled(EngineJob engineJob, Key key);
+  void onEngineJobCancelled(EngineJob<?> engineJob, Key key);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java
index a95e820a8..9f16b6115 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.Transformation;
@@ -21,9 +22,15 @@
   private final Options options;
   private int hashCode;
 
-  public EngineKey(Object model, Key signature, int width, int height,
-      Map<Class<?>, Transformation<?>> transformations, Class<?> resourceClass,
-      Class<?> transcodeClass, Options options) {
+  EngineKey(
+      Object model,
+      Key signature,
+      int width,
+      int height,
+      Map<Class<?>, Transformation<?>> transformations,
+      Class<?> resourceClass,
+      Class<?> transcodeClass,
+      Options options) {
     this.model = Preconditions.checkNotNull(model);
     this.signature = Preconditions.checkNotNull(signature, "Signature must not be null");
     this.width = width;
@@ -83,7 +90,7 @@ public String toString() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     throw new UnsupportedOperationException();
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineKeyFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineKeyFactory.java
index ec00d0a06..05e7a55a0 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineKeyFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineKeyFactory.java
@@ -8,7 +8,7 @@
 class EngineKeyFactory {
 
   @SuppressWarnings("rawtypes")
-  public EngineKey buildKey(Object model, Key signature, int width, int height,
+  EngineKey buildKey(Object model, Key signature, int width, int height,
       Map<Class<?>, Transformation<?>> transformations, Class<?> resourceClass,
       Class<?> transcodeClass, Options options) {
     return new EngineKey(model, signature, width, height, transformations, resourceClass,
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
index c03168f69..75bb1b841 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.engine;
 
 import android.os.Looper;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.util.Preconditions;
 
@@ -12,6 +13,7 @@
  */
 class EngineResource<Z> implements Resource<Z> {
   private final boolean isCacheable;
+  private final boolean isRecyclable;
   private ResourceListener listener;
   private Key key;
   private int acquired;
@@ -22,9 +24,10 @@
     void onResourceReleased(Key key, EngineResource<?> resource);
   }
 
-  EngineResource(Resource<Z> toWrap, boolean isCacheable) {
+  EngineResource(Resource<Z> toWrap, boolean isCacheable, boolean isRecyclable) {
     resource = Preconditions.checkNotNull(toWrap);
     this.isCacheable = isCacheable;
+    this.isRecyclable = isRecyclable;
   }
 
   void setResourceListener(Key key, ResourceListener listener) {
@@ -32,15 +35,21 @@ void setResourceListener(Key key, ResourceListener listener) {
     this.listener = listener;
   }
 
+  Resource<Z> getResource() {
+    return resource;
+  }
+
   boolean isCacheable() {
     return isCacheable;
   }
 
+  @NonNull
   @Override
   public Class<Z> getResourceClass() {
     return resource.getResourceClass();
   }
 
+  @NonNull
   @Override
   public Z get() {
     return resource.get();
@@ -60,7 +69,9 @@ public void recycle() {
       throw new IllegalStateException("Cannot recycle a resource that has already been recycled");
     }
     isRecycled = true;
-    resource.recycle();
+    if (isRecyclable) {
+      resource.recycle();
+    }
   }
 
   /**
@@ -86,9 +97,9 @@ void acquire() {
    * Decrements the number of consumers using the wrapped resource. Must be called on the main
    * thread.
    *
-   * <p> This must only be called when a consumer that called the {@link #acquire()} method is now
-   * done with the resource. Generally external users should never callthis method, the framework
-   * will take care of this for you. </p>
+   * <p>This must only be called when a consumer that called the {@link #acquire()} method is now
+   * done with the resource. Generally external users should never call this method, the framework
+   * will take care of this for you.
    */
   void release() {
     if (acquired <= 0) {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java b/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
index f932aac27..79d05eff5 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
@@ -15,24 +15,29 @@
 /**
  * An exception with zero or more causes indicating why a load in Glide failed.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public final class GlideException extends Exception {
+  private static final long serialVersionUID = 1L;
+
   private static final StackTraceElement[] EMPTY_ELEMENTS = new StackTraceElement[0];
 
-  private final List<Exception> causes;
+  private final List<Throwable> causes;
   private Key key;
   private DataSource dataSource;
   private Class<?> dataClass;
+  private String detailMessage;
 
   public GlideException(String message) {
-    this(message, Collections.<Exception>emptyList());
+    this(message, Collections.<Throwable>emptyList());
   }
 
-  public GlideException(String detailMessage, Exception cause) {
+  public GlideException(String detailMessage, Throwable cause) {
     this(detailMessage, Collections.singletonList(cause));
   }
 
-  public GlideException(String detailMessage, List<Exception> causes) {
-    super(detailMessage);
+  public GlideException(String detailMessage, List<Throwable> causes) {
+    this.detailMessage = detailMessage;
     setStackTrace(EMPTY_ELEMENTS);
     this.causes = causes;
   }
@@ -47,6 +52,10 @@ void setLoggingDetails(Key key, DataSource dataSource, Class<?> dataClass) {
     this.dataClass = dataClass;
   }
 
+
+
+  // No need to synchronize when doing nothing whatsoever.
+  @SuppressWarnings("UnsynchronizedOverridesSynchronized")
   @Override
   public Throwable fillInStackTrace() {
     // Avoid an expensive allocation by doing nothing here. Causes should contain all relevant
@@ -62,7 +71,7 @@ public Throwable fillInStackTrace() {
    *
    * @see #getRootCauses()
    */
-  public List<Exception> getCauses() {
+  public List<Throwable> getCauses() {
     return causes;
   }
 
@@ -74,8 +83,8 @@ public Throwable fillInStackTrace() {
    * a given model using multiple different pathways, there may be multiple related or unrelated
    * reasons for a load to fail.
    */
-  public List<Exception> getRootCauses() {
-    List<Exception> rootCauses = new ArrayList<>();
+  public List<Throwable> getRootCauses() {
+    List<Throwable> rootCauses = new ArrayList<>();
     addRootCauses(this, rootCauses);
     return rootCauses;
   }
@@ -88,20 +97,20 @@ public Throwable fillInStackTrace() {
    * complete stack traces.
    */
   public void logRootCauses(String tag) {
-    List<Exception> causes = getRootCauses();
+    List<Throwable> causes = getRootCauses();
     for (int i = 0, size = causes.size(); i < size; i++) {
       Log.i(tag, "Root cause (" + (i + 1) + " of " + size + ")", causes.get(i));
     }
   }
 
-  private void addRootCauses(Exception exception, List<Exception> rootCauses) {
-    if (exception instanceof GlideException) {
-      GlideException glideException = (GlideException) exception;
-      for (Exception e : glideException.getCauses()) {
-        addRootCauses(e, rootCauses);
+  private void addRootCauses(Throwable throwable, List<Throwable> rootCauses) {
+    if (throwable instanceof GlideException) {
+      GlideException glideException = (GlideException) throwable;
+      for (Throwable t : glideException.getCauses()) {
+        addRootCauses(t, rootCauses);
       }
     } else {
-      rootCauses.add(exception);
+      rootCauses.add(throwable);
     }
   }
 
@@ -125,29 +134,47 @@ private void printStackTrace(Appendable appendable) {
     appendCauses(getCauses(), new IndentedAppendable(appendable));
   }
 
+  // PMD doesn't seem to notice that we're allocating the builder with the suggested size.
+  @SuppressWarnings("PMD.InsufficientStringBufferDeclaration")
   @Override
   public String getMessage() {
-    return super.getMessage()
-        + (dataClass != null ? ", " + dataClass : "")
-        + (dataSource != null ? ", " + dataSource : "")
-        + (key != null ? ", " + key : "");
+    StringBuilder result = new StringBuilder(71)
+        .append(detailMessage)
+        .append(dataClass != null ? ", " + dataClass : "")
+        .append(dataSource != null ? ", " + dataSource : "")
+        .append(key != null ? ", " + key : "");
+
+    List<Throwable> rootCauses = getRootCauses();
+    if (rootCauses.isEmpty()) {
+      return result.toString();
+    } else if (rootCauses.size() == 1) {
+      result.append("\nThere was 1 cause:");
+    } else {
+      result.append("\nThere were ").append(rootCauses.size()).append(" causes:");
+    }
+    for (Throwable cause : rootCauses) {
+      result.append('\n')
+          .append(cause.getClass().getName()).append('(').append(cause.getMessage()).append(')');
+    }
+    result.append("\n call GlideException#logRootCauses(String) for more detail");
+    return result.toString();
   }
 
   // Appendable throws, PrintWriter, PrintStream, and IndentedAppendable do not, so this should
   // never happen.
   @SuppressWarnings("PMD.PreserveStackTrace")
-  private static void appendExceptionMessage(Exception e, Appendable appendable) {
+  private static void appendExceptionMessage(Throwable t, Appendable appendable) {
     try {
-      appendable.append(e.getClass().toString()).append(": ").append(e.getMessage()).append('\n');
+      appendable.append(t.getClass().toString()).append(": ").append(t.getMessage()).append('\n');
     } catch (IOException e1) {
-      throw new RuntimeException(e);
+      throw new RuntimeException(t);
     }
   }
 
   // Appendable throws, PrintWriter, PrintStream, and IndentedAppendable do not, so this should
   // never happen.
   @SuppressWarnings("PMD.PreserveStackTrace")
-  private static void appendCauses(List<Exception> causes, Appendable appendable) {
+  private static void appendCauses(List<Throwable> causes, Appendable appendable) {
     try {
       appendCausesWrapped(causes, appendable);
     } catch (IOException e) {
@@ -156,7 +183,7 @@ private static void appendCauses(List<Exception> causes, Appendable appendable)
   }
 
   @SuppressWarnings("ThrowableResultOfMethodCallIgnored")
-  private static void appendCausesWrapped(List<Exception> causes, Appendable appendable)
+  private static void appendCausesWrapped(List<Throwable> causes, Appendable appendable)
       throws IOException {
     int size = causes.size();
     for (int i = 0; i < size; i++) {
@@ -166,7 +193,7 @@ private static void appendCausesWrapped(List<Exception> causes, Appendable appen
           .append(String.valueOf(size))
           .append("): ");
 
-      Exception cause = causes.get(i);
+      Throwable cause = causes.get(i);
       if (cause instanceof GlideException) {
         GlideException glideCause = (GlideException) cause;
         glideCause.printStackTrace(appendable);
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Jobs.java b/library/src/main/java/com/bumptech/glide/load/engine/Jobs.java
new file mode 100644
index 000000000..93b3106f7
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Jobs.java
@@ -0,0 +1,36 @@
+package com.bumptech.glide.load.engine;
+
+import android.support.annotation.VisibleForTesting;
+import com.bumptech.glide.load.Key;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
+final class Jobs {
+  private final Map<Key, EngineJob<?>> jobs = new HashMap<>();
+  private final Map<Key, EngineJob<?>> onlyCacheJobs = new HashMap<>();
+
+  @VisibleForTesting
+  Map<Key, EngineJob<?>> getAll() {
+    return Collections.unmodifiableMap(jobs);
+  }
+
+  EngineJob<?> get(Key key, boolean onlyRetrieveFromCache) {
+    return getJobMap(onlyRetrieveFromCache).get(key);
+  }
+
+  void put(Key key, EngineJob<?> job) {
+    getJobMap(job.onlyRetrieveFromCache()).put(key, job);
+  }
+
+  void removeIfCurrent(Key key, EngineJob<?> expected) {
+    Map<Key, EngineJob<?>> jobMap = getJobMap(expected.onlyRetrieveFromCache());
+    if (expected.equals(jobMap.get(key))) {
+      jobMap.remove(key);
+    }
+  }
+
+  private Map<Key, EngineJob<?>> getJobMap(boolean onlyRetrieveFromCache) {
+    return onlyRetrieveFromCache ? onlyCacheJobs : jobs;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/LoadPath.java b/library/src/main/java/com/bumptech/glide/load/engine/LoadPath.java
index d182da6ea..dca8f8952 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/LoadPath.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/LoadPath.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
 import android.support.v4.util.Pools.Pool;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataRewinder;
@@ -21,13 +22,13 @@
  */
 public class LoadPath<Data, ResourceType, Transcode> {
   private final Class<Data> dataClass;
-  private final Pool<List<Exception>> listPool;
+  private final Pool<List<Throwable>> listPool;
   private final List<? extends DecodePath<Data, ResourceType, Transcode>> decodePaths;
   private final String failureMessage;
 
   public LoadPath(Class<Data> dataClass, Class<ResourceType> resourceClass,
       Class<Transcode> transcodeClass,
-      List<DecodePath<Data, ResourceType, Transcode>> decodePaths, Pool<List<Exception>> listPool) {
+      List<DecodePath<Data, ResourceType, Transcode>> decodePaths, Pool<List<Throwable>> listPool) {
     this.dataClass = dataClass;
     this.listPool = listPool;
     this.decodePaths = Preconditions.checkNotEmpty(decodePaths);
@@ -35,22 +36,23 @@ public LoadPath(Class<Data> dataClass, Class<ResourceType> resourceClass,
         + resourceClass.getSimpleName() + "->" + transcodeClass.getSimpleName() + "}";
   }
 
-  public Resource<Transcode> load(DataRewinder<Data> rewinder, Options options, int width,
+  public Resource<Transcode> load(DataRewinder<Data> rewinder, @NonNull Options options, int width,
       int height, DecodePath.DecodeCallback<ResourceType> decodeCallback) throws GlideException {
-    List<Exception> exceptions = listPool.acquire();
+    List<Throwable> throwables = Preconditions.checkNotNull(listPool.acquire());
     try {
-      return loadWithExceptionList(rewinder, options, width, height, decodeCallback, exceptions);
+      return loadWithExceptionList(rewinder, options, width, height, decodeCallback, throwables);
     } finally {
-      listPool.release(exceptions);
+      listPool.release(throwables);
     }
   }
 
-  private Resource<Transcode> loadWithExceptionList(DataRewinder<Data> rewinder, Options options,
+  private Resource<Transcode> loadWithExceptionList(DataRewinder<Data> rewinder,
+      @NonNull Options options,
       int width, int height, DecodePath.DecodeCallback<ResourceType> decodeCallback,
-      List<Exception> exceptions) throws GlideException {
-    int size = decodePaths.size();
+      List<Throwable> exceptions) throws GlideException {
     Resource<Transcode> result = null;
-    for (int i = 0; i < size; i++) {
+    //noinspection ForLoopReplaceableByForEach to improve perf
+    for (int i = 0, size = decodePaths.size(); i < size; i++) {
       DecodePath<Data, ResourceType, Transcode> path = decodePaths.get(i);
       try {
         result = path.decode(rewinder, width, height, options, decodeCallback);
@@ -75,7 +77,6 @@ public LoadPath(Class<Data> dataClass, Class<ResourceType> resourceClass,
 
   @Override
   public String toString() {
-    return "LoadPath{" + "decodePaths="
-        + Arrays.toString(decodePaths.toArray(new DecodePath[decodePaths.size()])) + '}';
+    return "LoadPath{" + "decodePaths=" + Arrays.toString(decodePaths.toArray()) + '}';
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java b/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java
index 5ee05aca7..594b26441 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java
@@ -1,6 +1,8 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
 import android.support.v4.util.Pools;
+import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.pool.FactoryPools;
 import com.bumptech.glide.util.pool.StateVerifier;
@@ -27,12 +29,14 @@
   private boolean isRecycled;
 
   @SuppressWarnings("unchecked")
+  @NonNull
   static <Z> LockedResource<Z> obtain(Resource<Z> resource) {
-    LockedResource<Z> result = (LockedResource<Z>) POOL.acquire();
+    LockedResource<Z> result = Preconditions.checkNotNull((LockedResource<Z>) POOL.acquire());
     result.init(resource);
     return result;
   }
 
+  @SuppressWarnings("WeakerAccess")
   @Synthetic
   LockedResource() { }
 
@@ -47,7 +51,7 @@ private void release() {
     POOL.release(this);
   }
 
-  public synchronized void unlock() {
+  synchronized void unlock() {
     stateVerifier.throwIfRecycled();
 
     if (!isLocked) {
@@ -59,11 +63,13 @@ public synchronized void unlock() {
     }
   }
 
+  @NonNull
   @Override
   public Class<Z> getResourceClass() {
     return toWrap.getResourceClass();
   }
 
+  @NonNull
   @Override
   public Z get() {
     return toWrap.get();
@@ -85,6 +91,7 @@ public synchronized void recycle() {
     }
   }
 
+  @NonNull
   @Override
   public StateVerifier getVerifier() {
     return stateVerifier;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Resource.java b/library/src/main/java/com/bumptech/glide/load/engine/Resource.java
index 3717a889d..6667381ba 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Resource.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Resource.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
 
 /**
  * A resource interface that wraps a particular type so that it can be pooled and reused.
@@ -11,6 +12,7 @@
   /**
    * Returns the {@link Class} of the wrapped resource.
    */
+  @NonNull
   Class<Z> getResourceClass();
 
   /**
@@ -23,6 +25,7 @@
    * {@link android.graphics.drawable.Drawable Drawable}s should always return a new
    * {@link android.graphics.drawable.Drawable Drawable}. </p>
    */
+  @NonNull
   Z get();
 
   /**
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java
index b0d444ed9..4e427b920 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Transformation;
@@ -19,7 +20,7 @@
   private final FetcherReadyCallback cb;
   private final DecodeHelper<?> helper;
 
-  private int sourceIdIndex = 0;
+  private int sourceIdIndex;
   private int resourceClassIndex = -1;
   private Key sourceKey;
   private List<ModelLoader<File, ?>> modelLoaders;
@@ -31,7 +32,7 @@
   private File cacheFile;
   private ResourceCacheKey currentKey;
 
-  public ResourceCacheGenerator(DecodeHelper<?> helper, FetcherReadyCallback cb) {
+  ResourceCacheGenerator(DecodeHelper<?> helper, FetcherReadyCallback cb) {
     this.helper = helper;
     this.cb = cb;
   }
@@ -43,6 +44,14 @@ public boolean startNext() {
       return false;
     }
     List<Class<?>> resourceClasses = helper.getRegisteredResourceClasses();
+    if (resourceClasses.isEmpty()) {
+      if (File.class.equals(helper.getTranscodeClass())) {
+        return false;
+      }
+      throw new IllegalStateException(
+          "Failed to find any load path from " + helper.getModelClass() + " to "
+              + helper.getTranscodeClass());
+    }
     while (modelLoaders == null || !hasNextModelLoader()) {
       resourceClassIndex++;
       if (resourceClassIndex >= resourceClasses.size()) {
@@ -56,12 +65,22 @@ public boolean startNext() {
       Key sourceId = sourceIds.get(sourceIdIndex);
       Class<?> resourceClass = resourceClasses.get(resourceClassIndex);
       Transformation<?> transformation = helper.getTransformation(resourceClass);
-
-      currentKey = new ResourceCacheKey(sourceId, helper.getSignature(), helper.getWidth(),
-          helper.getHeight(), transformation, resourceClass, helper.getOptions());
+      // PMD.AvoidInstantiatingObjectsInLoops Each iteration is comparatively expensive anyway,
+      // we only run until the first one succeeds, the loop runs for only a limited
+      // number of iterations on the order of 10-20 in the worst case.
+      currentKey =
+          new ResourceCacheKey(// NOPMD AvoidInstantiatingObjectsInLoops
+              helper.getArrayPool(),
+              sourceId,
+              helper.getSignature(),
+              helper.getWidth(),
+              helper.getHeight(),
+              transformation,
+              resourceClass,
+              helper.getOptions());
       cacheFile = helper.getDiskCache().get(currentKey);
       if (cacheFile != null) {
-        this.sourceKey = sourceId;
+        sourceKey = sourceId;
         modelLoaders = helper.getModelLoaders(cacheFile);
         modelLoaderIndex = 0;
       }
@@ -71,9 +90,8 @@ public boolean startNext() {
     boolean started = false;
     while (!started && hasNextModelLoader()) {
       ModelLoader<File, ?> modelLoader = modelLoaders.get(modelLoaderIndex++);
-      loadData =
-          modelLoader.buildLoadData(cacheFile, helper.getWidth(), helper.getHeight(),
-              helper.getOptions());
+      loadData = modelLoader.buildLoadData(cacheFile,
+          helper.getWidth(), helper.getHeight(), helper.getOptions());
       if (loadData != null && helper.hasLoadPath(loadData.fetcher.getDataClass())) {
         started = true;
         loadData.fetcher.loadData(helper.getPriority(), this);
@@ -102,7 +120,7 @@ public void onDataReady(Object data) {
   }
 
   @Override
-  public void onLoadFailed(Exception e) {
+  public void onLoadFailed(@NonNull Exception e) {
     cb.onDataFetcherFailed(currentKey, e, loadData.fetcher, DataSource.RESOURCE_DISK_CACHE);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java
index 2fbd7051e..afd18a739 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java
@@ -1,8 +1,10 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.util.LruCache;
 import com.bumptech.glide.util.Util;
 import java.nio.ByteBuffer;
@@ -13,6 +15,7 @@
  */
 final class ResourceCacheKey implements Key {
   private static final LruCache<Class<?>, byte[]> RESOURCE_CLASS_BYTES = new LruCache<>(50);
+  private final ArrayPool arrayPool;
   private final Key sourceKey;
   private final Key signature;
   private final int width;
@@ -21,8 +24,16 @@
   private final Options options;
   private final Transformation<?> transformation;
 
-  public ResourceCacheKey(Key sourceKey, Key signature, int width, int height,
-      Transformation<?> appliedTransformation, Class<?> decodedResourceClass, Options options) {
+  ResourceCacheKey(
+      ArrayPool arrayPool,
+      Key sourceKey,
+      Key signature,
+      int width,
+      int height,
+      Transformation<?> appliedTransformation,
+      Class<?> decodedResourceClass,
+      Options options) {
+    this.arrayPool = arrayPool;
     this.sourceKey = sourceKey;
     this.signature = signature;
     this.width = width;
@@ -62,8 +73,9 @@ public int hashCode() {
 
   // TODO: Include relevant options?
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
-    byte[] dimensions = ByteBuffer.allocate(8).putInt(width).putInt(height).array();
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
+    byte[] dimensions = arrayPool.getExact(8, byte[].class);
+    ByteBuffer.wrap(dimensions).putInt(width).putInt(height).array();
     signature.updateDiskCacheKey(messageDigest);
     sourceKey.updateDiskCacheKey(messageDigest);
     messageDigest.update(dimensions);
@@ -72,6 +84,7 @@ public void updateDiskCacheKey(MessageDigest messageDigest) {
     }
     options.updateDiskCacheKey(messageDigest);
     messageDigest.update(getResourceClassBytes());
+    arrayPool.put(dimensions);
   }
 
   private byte[] getResourceClassBytes() {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java b/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java
index 6d8d365b8..4ad3cf905 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java
@@ -14,7 +14,7 @@
   private final Handler handler =
       new Handler(Looper.getMainLooper(), new ResourceRecyclerCallback());
 
-  public void recycle(Resource<?> resource) {
+  void recycle(Resource<?> resource) {
     Util.assertMainThread();
 
     if (isRecycling) {
@@ -30,8 +30,8 @@ public void recycle(Resource<?> resource) {
     }
   }
 
-  private static class ResourceRecyclerCallback implements Handler.Callback {
-    public static final int RECYCLE_RESOURCE = 1;
+  private static final class ResourceRecyclerCallback implements Handler.Callback {
+    static final int RECYCLE_RESOURCE = 1;
 
     @Synthetic
     ResourceRecyclerCallback() { }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java
index c3f3420dc..5a57b971b 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
 import android.util.Log;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Encoder;
@@ -32,7 +33,7 @@
   private volatile ModelLoader.LoadData<?> loadData;
   private DataCacheKey originalKey;
 
-  public SourceGenerator(DecodeHelper<?> helper, FetcherReadyCallback cb) {
+  SourceGenerator(DecodeHelper<?> helper, FetcherReadyCallback cb) {
     this.helper = helper;
     this.cb = cb;
   }
@@ -114,7 +115,7 @@ public void onDataReady(Object data) {
   }
 
   @Override
-  public void onLoadFailed(Exception e) {
+  public void onLoadFailed(@NonNull Exception e) {
     cb.onDataFetcherFailed(originalKey, e, loadData.fetcher, loadData.fetcher.getDataSource());
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java
index 18427396a..e53c49de4 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java
@@ -3,7 +3,7 @@
  * Interface for handling operations on a primitive array type.
  * @param <T> Array type (e.g. byte[], int[])
  */
-public interface ArrayAdapterInterface<T> {
+interface ArrayAdapterInterface<T> {
 
   /**
    * TAG for logging.
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java
index bfdb18621..7cb169dbb 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java
@@ -15,17 +15,42 @@
    *
    * <p>Arrays may be ignored, for example if the array is larger than the maximum size of the
    * pool.
+   *
+   * @deprecated Use {@link #put(Object)}
    */
+  @Deprecated
   <T> void put(T array, Class<T> arrayClass);
 
+  /**
+   * Optionally adds the given array of the given type to the pool.
+   *
+   * <p>Arrays may be ignored, for example if the array is larger than the maximum size of the
+   * pool.
+   */
+  <T> void put(T array);
+
   /**
    * Returns a non-null array of the given type with a length >= to the given size.
    *
    * <p>If an array of the given size isn't in the pool, a new one will be allocated.
    *
    * <p>This class makes no guarantees about the contents of the returned array.
+   *
+   * @see #getExact(int, Class)
    */
   <T> T get(int size, Class<T> arrayClass);
+
+  /**
+   * Returns a non-null array of the given type with a length exactly equal to the given size.
+   *
+   * <p>If an array of the given size isn't in the pool, a new one will be allocated.
+   *
+   * <p>This class makes no guarantees about the contents of the returned array.
+   *
+   * @see #get(int, Class)
+   */
+  <T> T getExact(int size, Class<T> arrayClass);
+
   /**
    * Clears all arrays from the pool.
    */
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java
index f9448856b..58ee33826 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
 import android.graphics.Bitmap;
+import android.support.annotation.VisibleForTesting;
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
 
@@ -12,6 +13,7 @@
   private final KeyPool keyPool = new KeyPool();
   private final GroupedLinkedMap<Key, Bitmap> groupedMap = new GroupedLinkedMap<>();
 
+  @Override
   public void put(Bitmap bitmap) {
     final Key key = keyPool.get(bitmap.getWidth(), bitmap.getHeight(), bitmap.getConfig());
 
@@ -54,14 +56,15 @@ private static String getBitmapString(Bitmap bitmap) {
     return getBitmapString(bitmap.getWidth(), bitmap.getHeight(), bitmap.getConfig());
   }
 
+  @SuppressWarnings("WeakerAccess")
   @Synthetic
   static String getBitmapString(int width, int height, Bitmap.Config config) {
     return "[" + width + "x" + height + "], " + config;
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class KeyPool extends BaseKeyPool<Key> {
-    public Key get(int width, int height, Bitmap.Config config) {
+    Key get(int width, int height, Bitmap.Config config) {
       Key result = get();
       result.init(width, height, config);
       return result;
@@ -73,7 +76,7 @@ protected Key create() {
     }
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class Key implements Poolable {
     private final KeyPool pool;
     private int width;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java
index ffdba43d3..ccb085511 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java
@@ -7,7 +7,7 @@
   private static final int MAX_SIZE = 20;
   private final Queue<T> keyPool = Util.createQueue(MAX_SIZE);
 
-  protected T get() {
+  T get() {
     T result = keyPool.poll();
     if (result == null) {
       result = create();
@@ -21,5 +21,5 @@ public void offer(T key) {
     }
   }
 
-  protected abstract T create();
+  abstract T create();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java
index 3fecc0360..7b234184a 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java
@@ -11,7 +11,7 @@
   /**
    * Returns the current maximum size of the pool in bytes.
    */
-  int getMaxSize();
+  long getMaxSize();
 
   /**
    * Multiplies the initial size of the pool by the given multiplier to dynamically and
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java
index af72c1b82..60652581e 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java
@@ -10,7 +10,7 @@
  */
 public class BitmapPoolAdapter implements BitmapPool {
   @Override
-  public int getMaxSize() {
+  public long getMaxSize() {
     return 0;
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java
index d190a475f..9060fd825 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java
@@ -127,11 +127,11 @@ private void makeTail(LinkedEntry<K, V> entry) {
 
     // Used only for the first item in the list which we will treat specially and which will not
     // contain a value.
-    public LinkedEntry() {
+    LinkedEntry() {
       this(null);
     }
 
-    public LinkedEntry(K key) {
+    LinkedEntry(K key) {
       next = prev = this;
       this.key = key;
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java
index 6da2cb0e0..f6838dd26 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java
@@ -16,13 +16,14 @@
  */
 public final class LruArrayPool implements ArrayPool {
   // 4MB.
-  static final int DEFAULT_SIZE = 4 * 1024 * 1024;
+  private static final int DEFAULT_SIZE = 4 * 1024 * 1024;
 
   /**
    * The maximum number of times larger an int array may be to be than a requested size to eligible
    * to be returned from the pool.
    */
-  private static final int MAX_OVER_SIZE_MULTIPLE = 8;
+  @VisibleForTesting
+  static final int MAX_OVER_SIZE_MULTIPLE = 8;
   /** Used to calculate the maximum % of the total pool size a single byte array may consume. */
   private static final int SINGLE_ARRAY_MAX_SIZE_DIVISOR = 2;
 
@@ -47,8 +48,17 @@ public LruArrayPool(int maxSize) {
     this.maxSize = maxSize;
   }
 
+  @Deprecated
   @Override
-  public synchronized <T> void put(T array, Class<T> arrayClass) {
+  public <T> void put(T array, Class<T> arrayClass) {
+    put(array);
+  }
+
+  @Override
+  public synchronized <T> void put(T array) {
+    @SuppressWarnings("unchecked")
+    Class<T> arrayClass = (Class<T>) array.getClass();
+
     ArrayAdapterInterface<T> arrayAdapter = getAdapterFromType(arrayClass);
     int size = arrayAdapter.getArrayLength(array);
     int arrayBytes = size * arrayAdapter.getElementSizeInBytes();
@@ -66,35 +76,43 @@ public LruArrayPool(int maxSize) {
   }
 
   @Override
-  public <T> T get(int size, Class<T> arrayClass) {
-    ArrayAdapterInterface<T> arrayAdapter = getAdapterFromType(arrayClass);
-    T result;
-    synchronized (this) {
-      Integer possibleSize = getSizesForAdapter(arrayClass).ceilingKey(size);
-      final Key key;
-      if (mayFillRequest(size, possibleSize)) {
-        key = keyPool.get(possibleSize, arrayClass);
-      } else {
-        key = keyPool.get(size, arrayClass);
-      }
+  public synchronized <T> T getExact(int size, Class<T> arrayClass) {
+    Key key = keyPool.get(size, arrayClass);
+    return getForKey(key, arrayClass);
+  }
 
-      result = getArrayForKey(key);
-      if (result != null) {
-        currentSize -= arrayAdapter.getArrayLength(result) * arrayAdapter.getElementSizeInBytes();
-        decrementArrayOfSize(arrayAdapter.getArrayLength(result), arrayClass);
-      }
+  @Override
+  public synchronized <T> T get(int size, Class<T> arrayClass) {
+    Integer possibleSize = getSizesForAdapter(arrayClass).ceilingKey(size);
+    final Key key;
+    if (mayFillRequest(size, possibleSize)) {
+      key = keyPool.get(possibleSize, arrayClass);
+    } else {
+      key = keyPool.get(size, arrayClass);
+    }
+    return getForKey(key, arrayClass);
+  }
+
+  private <T> T getForKey(Key key, Class<T> arrayClass) {
+    ArrayAdapterInterface<T> arrayAdapter = getAdapterFromType(arrayClass);
+    T result = getArrayForKey(key);
+    if (result != null) {
+      currentSize -= arrayAdapter.getArrayLength(result) * arrayAdapter.getElementSizeInBytes();
+      decrementArrayOfSize(arrayAdapter.getArrayLength(result), arrayClass);
     }
 
     if (result == null) {
       if (Log.isLoggable(arrayAdapter.getTag(), Log.VERBOSE)) {
-        Log.v(arrayAdapter.getTag(), "Allocated " + size + " bytes");
+        Log.v(arrayAdapter.getTag(), "Allocated " + key.size + " bytes");
       }
-      result = arrayAdapter.newArray(size);
+      result = arrayAdapter.newArray(key.size);
     }
     return result;
   }
 
-  @SuppressWarnings("unchecked")
+
+  // Our cast is safe because the Key is based on the type.
+  @SuppressWarnings({"unchecked", "TypeParameterUnusedInFormals"})
   @Nullable
   private <T> T getArrayForKey(Key key) {
     return (T) groupedMap.get(key);
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
index 88150031d..0540e469e 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
@@ -26,18 +26,18 @@
 
   private final LruPoolStrategy strategy;
   private final Set<Bitmap.Config> allowedConfigs;
-  private final int initialMaxSize;
+  private final long initialMaxSize;
   private final BitmapTracker tracker;
 
-  private int maxSize;
-  private int currentSize;
+  private long maxSize;
+  private long currentSize;
   private int hits;
   private int misses;
   private int puts;
   private int evictions;
 
   // Exposed for testing only.
-  LruBitmapPool(int maxSize, LruPoolStrategy strategy, Set<Bitmap.Config> allowedConfigs) {
+  LruBitmapPool(long maxSize, LruPoolStrategy strategy, Set<Bitmap.Config> allowedConfigs) {
     this.initialMaxSize = maxSize;
     this.maxSize = maxSize;
     this.strategy = strategy;
@@ -50,7 +50,7 @@
    *
    * @param maxSize The initial maximum size of the pool in bytes.
    */
-  public LruBitmapPool(int maxSize) {
+  public LruBitmapPool(long maxSize) {
     this(maxSize, getDefaultStrategy(), getDefaultAllowedConfigs());
   }
 
@@ -62,12 +62,14 @@ public LruBitmapPool(int maxSize) {
    *                       allowed to be put into the pool. Configs not in the allowed put will be
    *                       rejected.
    */
-  public LruBitmapPool(int maxSize, Set<Bitmap.Config> allowedConfigs) {
+  // Public API.
+  @SuppressWarnings("unused")
+  public LruBitmapPool(long maxSize, Set<Bitmap.Config> allowedConfigs) {
     this(maxSize, getDefaultStrategy(), allowedConfigs);
   }
 
   @Override
-  public int getMaxSize() {
+  public long getMaxSize() {
     return maxSize;
   }
 
@@ -126,7 +128,7 @@ public Bitmap get(int width, int height, Bitmap.Config config) {
       // contents individually, so we do so here. See issue #131.
       result.eraseColor(Color.TRANSPARENT);
     } else {
-      result = Bitmap.createBitmap(width, height, config);
+      result = createBitmap(width, height, config);
     }
 
     return result;
@@ -137,11 +139,16 @@ public Bitmap get(int width, int height, Bitmap.Config config) {
   public Bitmap getDirty(int width, int height, Bitmap.Config config) {
     Bitmap result = getDirtyOrNull(width, height, config);
     if (result == null) {
-      result = Bitmap.createBitmap(width, height, config);
+      result = createBitmap(width, height, config);
     }
     return result;
   }
 
+  @NonNull
+  private static Bitmap createBitmap(int width, int height, @Nullable Bitmap.Config config) {
+    return Bitmap.createBitmap(width, height, config != null ? config : DEFAULT_CONFIG);
+  }
+
   @TargetApi(Build.VERSION_CODES.O)
   private static void assertNotHardwareConfig(Bitmap.Config config) {
     // Avoid short circuiting on sdk int since it breaks on some versions of Android.
@@ -157,7 +164,8 @@ private static void assertNotHardwareConfig(Bitmap.Config config) {
   }
 
   @Nullable
-  private synchronized Bitmap getDirtyOrNull(int width, int height, Bitmap.Config config) {
+  private synchronized Bitmap getDirtyOrNull(
+      int width, int height, @Nullable Bitmap.Config config) {
     assertNotHardwareConfig(config);
     // Config will be null for non public config types, which can lead to transformations naively
     // passing in null as the requested config here. See issue #194.
@@ -216,7 +224,7 @@ public void trimMemory(int level) {
     }
   }
 
-  private synchronized void trimToSize(int size) {
+  private synchronized void trimToSize(long size) {
     while (currentSize > size) {
       final Bitmap removed = strategy.removeLast();
       // TODO: This shouldn't ever happen, see #331.
@@ -262,8 +270,7 @@ private static LruPoolStrategy getDefaultStrategy() {
 
   @TargetApi(Build.VERSION_CODES.O)
   private static Set<Bitmap.Config> getDefaultAllowedConfigs() {
-    Set<Bitmap.Config> configs = new HashSet<>();
-    configs.addAll(Arrays.asList(Bitmap.Config.values()));
+    Set<Bitmap.Config> configs = new HashSet<>(Arrays.asList(Bitmap.Config.values()));
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
       // GIFs, among other types, end up with a native Bitmap config that doesn't map to a java
       // config and is treated as null in java code. On KitKat+ these Bitmaps can be reconfigured
@@ -306,7 +313,7 @@ public void remove(Bitmap bitmap) {
     }
   }
 
-  private static class NullBitmapTracker implements BitmapTracker {
+  private static final class NullBitmapTracker implements BitmapTracker {
 
     @Synthetic
     NullBitmapTracker() { }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/PrettyPrintTreeMap.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/PrettyPrintTreeMap.java
index 5d4176f3c..220d3beff 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/PrettyPrintTreeMap.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/PrettyPrintTreeMap.java
@@ -2,6 +2,8 @@
 
 import java.util.TreeMap;
 
+// Never serialized.
+@SuppressWarnings("serial")
 class PrettyPrintTreeMap<K, V> extends TreeMap<K, V> {
   @Override
   public String toString() {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
index 05964ba05..e496fde4e 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
@@ -1,11 +1,14 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
-import android.annotation.TargetApi;
 import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
 import android.os.Build;
 import android.support.annotation.Nullable;
+import android.support.annotation.RequiresApi;
+import android.support.annotation.VisibleForTesting;
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
+import java.util.Arrays;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.NavigableMap;
@@ -22,15 +25,26 @@
  * the performance of applications. This class works around #301 by only allowing re-use of
  * {@link android.graphics.Bitmap Bitmaps} with a matching number of bytes per pixel. </p>
  */
-@TargetApi(Build.VERSION_CODES.KITKAT)
+@RequiresApi(Build.VERSION_CODES.KITKAT)
 public class SizeConfigStrategy implements LruPoolStrategy {
   private static final int MAX_SIZE_MULTIPLE = 8;
-  private static final Bitmap.Config[] ARGB_8888_IN_CONFIGS =
-      new Bitmap.Config[] {
-          Bitmap.Config.ARGB_8888,
-          // The value returned by Bitmaps with the hidden Bitmap config.
-          null,
-      };
+
+  private static final Bitmap.Config[] ARGB_8888_IN_CONFIGS;
+  static {
+    Bitmap.Config[] result =
+        new Bitmap.Config[] {
+            Bitmap.Config.ARGB_8888,
+            // The value returned by Bitmaps with the hidden Bitmap config.
+            null,
+        };
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+      result = Arrays.copyOf(result, result.length + 1);
+      result[result.length - 1] = Config.RGBA_F16;
+    }
+    ARGB_8888_IN_CONFIGS = result;
+  }
+  private static final Bitmap.Config[] RGBA_F16_IN_CONFIGS = ARGB_8888_IN_CONFIGS;
+
   // We probably could allow ARGB_4444 and RGB_565 to decode into each other, but ARGB_4444 is
   // deprecated and we'd rather be safe.
   private static final Bitmap.Config[] RGB_565_IN_CONFIGS =
@@ -160,7 +174,7 @@ public String toString() {
     return sb.append(")}").toString();
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class KeyPool extends BaseKeyPool<Key> {
 
     public Key get(int size, Bitmap.Config config) {
@@ -175,7 +189,7 @@ protected Key create() {
     }
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static final class Key implements Poolable {
     private final KeyPool pool;
 
@@ -186,7 +200,7 @@ public Key(KeyPool pool) {
       this.pool = pool;
     }
 
-    // Visible for testing.
+    @VisibleForTesting
     Key(KeyPool pool, int size, Bitmap.Config config) {
       this(pool);
       init(size, config);
@@ -231,6 +245,12 @@ static String getBitmapString(int size, Bitmap.Config config) {
   }
 
   private static Bitmap.Config[] getInConfigs(Bitmap.Config requested) {
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+      if (Bitmap.Config.RGBA_F16.equals(requested)) { // NOPMD - Avoid short circuiting sdk checks.
+        return RGBA_F16_IN_CONFIGS;
+      }
+    }
+
     switch (requested) {
       case ARGB_8888:
         return ARGB_8888_IN_CONFIGS;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java
index 205ec7e4f..5536b75db 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java
@@ -1,12 +1,13 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
-import android.annotation.TargetApi;
 import android.graphics.Bitmap;
 import android.os.Build;
 import android.support.annotation.Nullable;
+import android.support.annotation.RequiresApi;
+import android.support.annotation.VisibleForTesting;
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
-import java.util.TreeMap;
+import java.util.NavigableMap;
 
 /**
  * A strategy for reusing bitmaps that relies on
@@ -14,12 +15,12 @@
  *
  * <p> Requires {@link Build.VERSION_CODES#KITKAT KitKat} or higher. </p>
  */
-@TargetApi(Build.VERSION_CODES.KITKAT)
-class SizeStrategy implements LruPoolStrategy {
+@RequiresApi(Build.VERSION_CODES.KITKAT)
+final class SizeStrategy implements LruPoolStrategy {
   private static final int MAX_SIZE_MULTIPLE = 8;
   private final KeyPool keyPool = new KeyPool();
   private final GroupedLinkedMap<Key, Bitmap> groupedMap = new GroupedLinkedMap<>();
-  private final TreeMap<Integer, Integer> sortedSizes = new PrettyPrintTreeMap<>();
+  private final NavigableMap<Integer, Integer> sortedSizes = new PrettyPrintTreeMap<>();
 
   @Override
   public void put(Bitmap bitmap) {
@@ -101,16 +102,16 @@ private static String getBitmapString(Bitmap bitmap) {
     return getBitmapString(size);
   }
 
-  @Synthetic
-  static String getBitmapString(int size) {
+  @Synthetic static String getBitmapString(int size) {
     return "[" + size + "]";
   }
 
-  // Visible for testing.
+  // Non-final for mocking.
+  @VisibleForTesting
   static class KeyPool extends BaseKeyPool<Key> {
 
     public Key get(int size) {
-      Key result = get();
+      Key result = super.get();
       result.init(size);
       return result;
     }
@@ -121,7 +122,7 @@ protected Key create() {
     }
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static final class Key implements Poolable {
     private final KeyPool pool;
     @Synthetic int size;
@@ -148,6 +149,8 @@ public int hashCode() {
       return size;
     }
 
+    // PMD.AccessorMethodGeneration: https://github.com/pmd/pmd/issues/807
+    @SuppressWarnings("PMD.AccessorMethodGeneration")
     @Override
     public String toString() {
       return getBitmapString(size);
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java
index 31cdcf025..7bcfd02e4 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.engine.cache;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import com.bumptech.glide.load.Key;
 import java.io.File;
@@ -13,16 +14,13 @@
    * An interface for lazily creating a disk cache.
    */
   interface Factory {
+    /** 250 MB of cache. */
+    int DEFAULT_DISK_CACHE_SIZE = 250 * 1024 * 1024;
+    String DEFAULT_DISK_CACHE_DIR = "image_manager_disk_cache";
 
-      /** 250 MB of cache. */
-      int DEFAULT_DISK_CACHE_SIZE = 250 * 1024 * 1024;
-      String DEFAULT_DISK_CACHE_DIR = "image_manager_disk_cache";
-
-      /**
-       * Returns a new disk cache, or {@code null} if no disk cache could be created.
-       */
-      @Nullable
-      DiskCache build();
+    /** Returns a new disk cache, or {@code null} if no disk cache could be created. */
+    @Nullable
+    DiskCache build();
   }
 
   /**
@@ -35,7 +33,7 @@
      *
      * @param file The File the Writer should write to.
      */
-    boolean write(File file);
+    boolean write(@NonNull File file);
   }
 
   /**
@@ -64,6 +62,8 @@
    *
    * @param key The key to remove.
    */
+  // Public API.
+  @SuppressWarnings("unused")
   void delete(Key key);
 
   /**
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheFactory.java
index f24fa6dd2..9518b4c85 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheFactory.java
@@ -7,10 +7,12 @@
  * disk cache directory.
  *
  * <p>If you need to make I/O access before returning the cache directory use the {@link
- * DiskLruCacheFactory#DiskLruCacheFactory(CacheDirectoryGetter, int)} constructor variant.
+ * DiskLruCacheFactory#DiskLruCacheFactory(CacheDirectoryGetter, long)} constructor variant.
  */
+// Public API.
+@SuppressWarnings("unused")
 public class DiskLruCacheFactory implements DiskCache.Factory {
-  private final int diskCacheSize;
+  private final long diskCacheSize;
   private final CacheDirectoryGetter cacheDirectoryGetter;
 
   /**
@@ -20,7 +22,7 @@
     File getCacheDirectory();
   }
 
-  public DiskLruCacheFactory(final String diskCacheFolder, int diskCacheSize) {
+  public DiskLruCacheFactory(final String diskCacheFolder, long diskCacheSize) {
     this(new CacheDirectoryGetter() {
       @Override
       public File getCacheDirectory() {
@@ -30,7 +32,7 @@ public File getCacheDirectory() {
   }
 
   public DiskLruCacheFactory(final String diskCacheFolder, final String diskCacheName,
-      int diskCacheSize) {
+                             long diskCacheSize) {
     this(new CacheDirectoryGetter() {
       @Override
       public File getCacheDirectory() {
@@ -46,7 +48,9 @@ public File getCacheDirectory() {
    * @param cacheDirectoryGetter Interface called out of UI thread to get the cache folder.
    * @param diskCacheSize        Desired max bytes size for the LRU disk cache.
    */
-  public DiskLruCacheFactory(CacheDirectoryGetter cacheDirectoryGetter, int diskCacheSize) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public DiskLruCacheFactory(CacheDirectoryGetter cacheDirectoryGetter, long diskCacheSize) {
     this.diskCacheSize = diskCacheSize;
     this.cacheDirectoryGetter = cacheDirectoryGetter;
   }
@@ -63,6 +67,6 @@ public DiskCache build() {
       return null;
     }
 
-    return DiskLruCacheWrapper.get(cacheDir, diskCacheSize);
+    return DiskLruCacheWrapper.create(cacheDir, diskCacheSize);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
index 8cd104d02..2cedfe0b2 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
@@ -15,18 +15,18 @@
  * The default DiskCache implementation. There must be no more than one active instance for a given
  * directory at a time.
  *
- * @see #get(java.io.File, int)
+ * @see #get(java.io.File, long)
  */
 public class DiskLruCacheWrapper implements DiskCache {
   private static final String TAG = "DiskLruCacheWrapper";
 
   private static final int APP_VERSION = 1;
   private static final int VALUE_COUNT = 1;
-  private static DiskLruCacheWrapper wrapper = null;
+  private static DiskLruCacheWrapper wrapper;
 
   private final SafeKeyGenerator safeKeyGenerator;
   private final File directory;
-  private final int maxSize;
+  private final long maxSize;
   private final DiskCacheWriteLocker writeLocker = new DiskCacheWriteLocker();
   private DiskLruCache diskLruCache;
 
@@ -38,8 +38,12 @@
    * @param directory The directory for the disk cache
    * @param maxSize   The max size for the disk cache
    * @return The new disk cache with the given arguments, or the current cache if one already exists
+   *
+   * @deprecated Use {@link #create(File, long)} to create a new cache with the specified arguments.
    */
-  public static synchronized DiskCache get(File directory, int maxSize) {
+  @SuppressWarnings("deprecation")
+  @Deprecated
+  public static synchronized DiskCache get(File directory, long maxSize) {
     // TODO calling twice with different arguments makes it return the cache for the same
     // directory, it's public!
     if (wrapper == null) {
@@ -48,7 +52,25 @@ public static synchronized DiskCache get(File directory, int maxSize) {
     return wrapper;
   }
 
-  protected DiskLruCacheWrapper(File directory, int maxSize) {
+  /**
+   * Create a new DiskCache in the given directory with a specified max size.
+   *
+   * @param directory The directory for the disk cache
+   * @param maxSize   The max size for the disk cache
+   * @return The new disk cache with the given arguments
+   */
+  @SuppressWarnings("deprecation")
+  public static DiskCache create(File directory, long maxSize) {
+    return new DiskLruCacheWrapper(directory, maxSize);
+  }
+
+  /**
+   * @deprecated Do not extend this class.
+   */
+  @Deprecated
+  // Deprecated public API.
+  @SuppressWarnings({"WeakerAccess", "DeprecatedIsStillUsed"})
+  protected DiskLruCacheWrapper(File directory, long maxSize) {
     this.directory = directory;
     this.maxSize = maxSize;
     this.safeKeyGenerator = new SafeKeyGenerator();
@@ -141,11 +163,15 @@ public void delete(Key key) {
   public synchronized void clear() {
     try {
       getDiskCache().delete();
-      resetDiskCache();
     } catch (IOException e) {
       if (Log.isLoggable(TAG, Log.WARN)) {
-        Log.w(TAG, "Unable to clear disk cache", e);
+        Log.w(TAG, "Unable to clear disk cache or disk cache cleared externally", e);
       }
+    } finally {
+      // Delete can close the cache but still throw. If we don't null out the disk cache here, every
+      // subsequent request will try to act on a closed disk cache and fail. By nulling out the disk
+      // cache we at least allow for attempts to open the cache in the future. See #2465.
+      resetDiskCache();
     }
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalCacheDiskCacheFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalCacheDiskCacheFactory.java
index ab4ca652c..08b8d4dde 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalCacheDiskCacheFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalCacheDiskCacheFactory.java
@@ -8,7 +8,12 @@
  * disk cache directory.
  *
  * <p><b>Images can be read by everyone when using external disk cache.</b>
+ *
+ * @deprecated use {@link ExternalPreferredCacheDiskCacheFactory} instead.
  */
+// Public API.
+@SuppressWarnings({"unused", "WeakerAccess"})
+@Deprecated
 public final class ExternalCacheDiskCacheFactory extends DiskLruCacheFactory {
 
   public ExternalCacheDiskCacheFactory(Context context) {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalPreferredCacheDiskCacheFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalPreferredCacheDiskCacheFactory.java
new file mode 100644
index 000000000..4f2743b1e
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalPreferredCacheDiskCacheFactory.java
@@ -0,0 +1,65 @@
+package com.bumptech.glide.load.engine.cache;
+
+import android.content.Context;
+import android.support.annotation.Nullable;
+import java.io.File;
+
+/**
+ * Creates an {@link com.bumptech.glide.disklrucache.DiskLruCache} based disk cache in the external
+ * disk cache directory, which falls back to the internal disk cache if no external storage is
+ * available. If ever fell back to the internal disk cache, will use that one from that moment on.
+ *
+ * <p><b>Images can be read by everyone when using external disk cache.</b>
+ */
+// Public API.
+@SuppressWarnings({"unused", "WeakerAccess"})
+public final class ExternalPreferredCacheDiskCacheFactory extends DiskLruCacheFactory {
+
+  public ExternalPreferredCacheDiskCacheFactory(Context context) {
+    this(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR,
+        DiskCache.Factory.DEFAULT_DISK_CACHE_SIZE);
+  }
+
+  public ExternalPreferredCacheDiskCacheFactory(Context context, long diskCacheSize) {
+    this(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR, diskCacheSize);
+  }
+
+  public ExternalPreferredCacheDiskCacheFactory(final Context context, final String diskCacheName,
+                                                final long diskCacheSize) {
+    super(new CacheDirectoryGetter() {
+      @Nullable
+      private File getInternalCacheDirectory() {
+        File cacheDirectory = context.getCacheDir();
+        if (cacheDirectory == null) {
+          return null;
+        }
+        if (diskCacheName != null) {
+          return new File(cacheDirectory, diskCacheName);
+        }
+        return cacheDirectory;
+      }
+
+      @Override
+      public File getCacheDirectory() {
+        File internalCacheDirectory = getInternalCacheDirectory();
+
+        // Already used internal cache, so keep using that one,
+        // thus avoiding using both external and internal with transient errors.
+        if ((null != internalCacheDirectory) && internalCacheDirectory.exists()) {
+          return internalCacheDirectory;
+        }
+
+        File cacheDirectory = context.getExternalCacheDir();
+
+        // Shared storage is not available.
+        if ((cacheDirectory == null) || (!cacheDirectory.canWrite())) {
+          return internalCacheDirectory;
+        }
+        if (diskCacheName != null) {
+          return new File(cacheDirectory, diskCacheName);
+        }
+        return cacheDirectory;
+      }
+    }, diskCacheSize);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java
index 225743b89..18afb52f0 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java
@@ -7,6 +7,8 @@
  * Creates an {@link com.bumptech.glide.disklrucache.DiskLruCache} based disk cache in the internal
  * disk cache directory.
  */
+// Public API.
+@SuppressWarnings({"WeakerAccess", "unused"})
 public final class InternalCacheDiskCacheFactory extends DiskLruCacheFactory {
 
   public InternalCacheDiskCacheFactory(Context context) {
@@ -14,12 +16,12 @@ public InternalCacheDiskCacheFactory(Context context) {
         DiskCache.Factory.DEFAULT_DISK_CACHE_SIZE);
   }
 
-  public InternalCacheDiskCacheFactory(Context context, int diskCacheSize) {
+  public InternalCacheDiskCacheFactory(Context context, long diskCacheSize) {
     this(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR, diskCacheSize);
   }
 
   public InternalCacheDiskCacheFactory(final Context context, final String diskCacheName,
-      int diskCacheSize) {
+                                       long diskCacheSize) {
     super(new CacheDirectoryGetter() {
       @Override
       public File getCacheDirectory() {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java
index 44071a869..9c26b83df 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java
@@ -1,6 +1,8 @@
 package com.bumptech.glide.load.engine.cache;
 
 import android.annotation.SuppressLint;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.util.LruCache;
@@ -16,25 +18,29 @@
    *
    * @param size The maximum size in bytes the in memory cache can use.
    */
-  public LruResourceCache(int size) {
+  public LruResourceCache(long size) {
     super(size);
   }
 
   @Override
-  public void setResourceRemovedListener(ResourceRemovedListener listener) {
+  public void setResourceRemovedListener(@NonNull ResourceRemovedListener listener) {
     this.listener = listener;
   }
 
   @Override
-  protected void onItemEvicted(Key key, Resource<?> item) {
-    if (listener != null) {
+  protected void onItemEvicted(@NonNull Key key, @Nullable Resource<?> item) {
+    if (listener != null && item != null) {
       listener.onResourceRemoved(item);
     }
   }
 
   @Override
-  protected int getSize(Resource<?> item) {
-    return item.getSize();
+  protected int getSize(@Nullable Resource<?> item) {
+    if (item == null) {
+      return super.getSize(null);
+    } else {
+      return item.getSize();
+    }
   }
 
   @SuppressLint("InlinedApi")
@@ -47,7 +53,7 @@ public void trimMemory(int level) {
     } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {
       // Entering list of cached background apps
       // Evict oldest half of our bitmap cache
-      trimToSize(getCurrentSize() / 2);
+      trimToSize(getMaxSize() / 2);
     }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCache.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCache.java
index 3cf56d4c5..3210e6821 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCache.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.engine.cache;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.Resource;
@@ -12,18 +13,18 @@
    * An interface that will be called whenever a bitmap is removed from the cache.
    */
   interface ResourceRemovedListener {
-    void onResourceRemoved(Resource<?> removed);
+    void onResourceRemoved(@NonNull Resource<?> removed);
   }
 
   /**
    * Returns the sum of the sizes of all the contents of the cache in bytes.
    */
-  int getCurrentSize();
+  long getCurrentSize();
 
   /**
    * Returns the current maximum size in bytes of the cache.
    */
-  int getMaxSize();
+  long getMaxSize();
 
   /**
    * Adjust the maximum size of the cache by multiplying the original size of the cache by the given
@@ -42,7 +43,7 @@
    * @param key The key.
    */
   @Nullable
-  Resource<?> remove(Key key);
+  Resource<?> remove(@NonNull Key key);
 
   /**
    * Add bitmap to the cache with the given key.
@@ -52,14 +53,14 @@
    * @return The old value of key (null if key is not in map).
    */
   @Nullable
-  Resource<?> put(Key key, Resource<?> resource);
+  Resource<?> put(@NonNull Key key, @Nullable Resource<?> resource);
 
   /**
    * Set the listener to be called when a bitmap is removed from the cache.
    *
    * @param listener The listener.
    */
-  void setResourceRemovedListener(ResourceRemovedListener listener);
+  void setResourceRemovedListener(@NonNull ResourceRemovedListener listener);
 
   /**
    * Evict all items from the memory cache.
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCacheAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCacheAdapter.java
index e2f92de07..70deb5ce6 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCacheAdapter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCacheAdapter.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.load.engine.cache;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.Resource;
 
@@ -11,12 +13,12 @@
   private ResourceRemovedListener listener;
 
   @Override
-  public int getCurrentSize() {
+  public long getCurrentSize() {
     return 0;
   }
 
   @Override
-  public int getMaxSize() {
+  public long getMaxSize() {
     return 0;
   }
 
@@ -25,19 +27,23 @@ public void setSizeMultiplier(float multiplier) {
     // Do nothing.
   }
 
+  @Nullable
   @Override
-  public Resource<?> remove(Key key) {
+  public Resource<?> remove(@NonNull Key key) {
     return null;
   }
 
+  @Nullable
   @Override
-  public Resource<?> put(Key key, Resource<?> resource) {
-    listener.onResourceRemoved(resource);
+  public Resource<?> put(@NonNull Key key, @Nullable Resource<?> resource) {
+    if (resource != null) {
+      listener.onResourceRemoved(resource);
+    }
     return null;
   }
 
   @Override
-  public void setResourceRemovedListener(ResourceRemovedListener listener) {
+  public void setResourceRemovedListener(@NonNull ResourceRemovedListener listener) {
     this.listener = listener;
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
index 4489744e2..1418c466b 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
@@ -1,12 +1,15 @@
 package com.bumptech.glide.load.engine.cache;
 
+import android.annotation.TargetApi;
 import android.app.ActivityManager;
 import android.content.Context;
 import android.os.Build;
+import android.support.annotation.VisibleForTesting;
 import android.text.format.Formatter;
 import android.util.DisplayMetrics;
 import android.util.Log;
 import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Synthetic;
 
 /**
  * A calculator that tries to intelligently determine cache sizes for a given device based on some
@@ -14,9 +17,9 @@
  */
 public final class MemorySizeCalculator {
   private static final String TAG = "MemorySizeCalculator";
-  // Visible for testing.
+  @VisibleForTesting
   static final int BYTES_PER_ARGB_8888_PIXEL = 4;
-  static final int LOW_MEMORY_BYTE_ARRAY_POOL_DIVISOR = 2;
+  private static final int LOW_MEMORY_BYTE_ARRAY_POOL_DIVISOR = 2;
 
   private final int bitmapPoolSize;
   private final int memoryCacheSize;
@@ -112,13 +115,15 @@ private String toMb(int bytes) {
     return Formatter.formatFileSize(context, bytes);
   }
 
-  private static boolean isLowMemoryDevice(ActivityManager activityManager) {
+  @TargetApi(Build.VERSION_CODES.KITKAT)
+  @Synthetic static boolean isLowMemoryDevice(ActivityManager activityManager) {
     // Explicitly check with an if statement, on some devices both parts of boolean expressions
     // can be evaluated even if we'd normally expect a short circuit.
+    //noinspection SimplifiableIfStatement
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
       return activityManager.isLowRamDevice();
     } else {
-      return false;
+      return true;
     }
   }
 
@@ -126,8 +131,10 @@ private static boolean isLowMemoryDevice(ActivityManager activityManager) {
    * Constructs an {@link MemorySizeCalculator} with reasonable defaults that can be optionally
    * overridden.
    */
+  // Public API.
+  @SuppressWarnings({"WeakerAccess", "unused"})
   public static final class Builder {
-    // Visible for testing.
+    @VisibleForTesting
     static final int MEMORY_CACHE_TARGET_SCREENS = 2;
 
     /**
@@ -143,17 +150,17 @@ private static boolean isLowMemoryDevice(ActivityManager activityManager) {
     // 4MB.
     static final int ARRAY_POOL_SIZE_BYTES = 4 * 1024 * 1024;
 
-    private final Context context;
+    @Synthetic final Context context;
 
-    // Modifiable for testing.
-    private ActivityManager activityManager;
-    private ScreenDimensions screenDimensions;
+    // Modifiable (non-final) for testing.
+    @Synthetic ActivityManager activityManager;
+    @Synthetic ScreenDimensions screenDimensions;
 
-    private float memoryCacheScreens = MEMORY_CACHE_TARGET_SCREENS;
-    private float bitmapPoolScreens = BITMAP_POOL_TARGET_SCREENS;
-    private float maxSizeMultiplier = MAX_SIZE_MULTIPLIER;
-    private float lowMemoryMaxSizeMultiplier = LOW_MEMORY_MAX_SIZE_MULTIPLIER;
-    private int arrayPoolSizeBytes = ARRAY_POOL_SIZE_BYTES;
+    @Synthetic float memoryCacheScreens = MEMORY_CACHE_TARGET_SCREENS;
+    @Synthetic float bitmapPoolScreens = BITMAP_POOL_TARGET_SCREENS;
+    @Synthetic float maxSizeMultiplier = MAX_SIZE_MULTIPLIER;
+    @Synthetic float lowMemoryMaxSizeMultiplier = LOW_MEMORY_MAX_SIZE_MULTIPLIER;
+    @Synthetic int arrayPoolSizeBytes = ARRAY_POOL_SIZE_BYTES;
 
     public Builder(Context context) {
       this.context = context;
@@ -177,7 +184,7 @@ public Builder(Context context) {
      * returns this Builder.
      */
     public Builder setMemoryCacheScreens(float memoryCacheScreens) {
-      Preconditions.checkArgument(bitmapPoolScreens >= 0,
+      Preconditions.checkArgument(memoryCacheScreens >= 0,
           "Memory cache screens must be greater than or equal to 0");
       this.memoryCacheScreens = memoryCacheScreens;
       return this;
@@ -237,13 +244,13 @@ public Builder setArrayPoolSize(int arrayPoolSizeBytes) {
       return this;
     }
 
-    // Visible for testing.
+    @VisibleForTesting
     Builder setActivityManager(ActivityManager activityManager) {
       this.activityManager = activityManager;
       return this;
     }
 
-    // Visible for testing.
+    @VisibleForTesting
     Builder setScreenDimensions(ScreenDimensions screenDimensions) {
       this.screenDimensions = screenDimensions;
       return this;
@@ -257,7 +264,7 @@ public MemorySizeCalculator build() {
   private static final class DisplayMetricsScreenDimensions implements ScreenDimensions {
     private final DisplayMetrics displayMetrics;
 
-    public DisplayMetricsScreenDimensions(DisplayMetrics displayMetrics) {
+    DisplayMetricsScreenDimensions(DisplayMetrics displayMetrics) {
       this.displayMetrics = displayMetrics;
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java
index 2a81c4d9a..f726ef10e 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java
@@ -1,8 +1,10 @@
 package com.bumptech.glide.load.engine.cache;
 
+import android.support.annotation.NonNull;
 import android.support.v4.util.Pools;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.util.LruCache;
+import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
 import com.bumptech.glide.util.pool.FactoryPools;
@@ -14,6 +16,8 @@
  * A class that generates and caches safe and unique string file names from {@link
  * com.bumptech.glide.load.Key}s.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public class SafeKeyGenerator {
   private final LruCache<Key, String> loadIdToSafeHash = new LruCache<>(1000);
   private final Pools.Pool<PoolableDigestContainer> digestPool = FactoryPools.threadSafe(10,
@@ -43,7 +47,7 @@ public String getSafeKey(Key key) {
   }
 
   private String calculateHexStringDigest(Key key) {
-    PoolableDigestContainer container = digestPool.acquire();
+    PoolableDigestContainer container = Preconditions.checkNotNull(digestPool.acquire());
     try {
       key.updateDiskCacheKey(container.messageDigest);
       // calling digest() will automatically reset()
@@ -62,6 +66,7 @@ private String calculateHexStringDigest(Key key) {
       this.messageDigest = messageDigest;
     }
 
+    @NonNull
     @Override
     public StateVerifier getVerifier() {
       return stateVerifier;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
index d80ff2059..7f8845534 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
@@ -3,59 +3,67 @@
 import android.os.StrictMode;
 import android.os.StrictMode.ThreadPolicy;
 import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
 import android.util.Log;
 import com.bumptech.glide.util.Synthetic;
-import java.io.File;
-import java.io.FilenameFilter;
-import java.util.concurrent.BlockingQueue;
+import java.util.Collection;
+import java.util.List;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Future;
 import java.util.concurrent.PriorityBlockingQueue;
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
-import java.util.regex.Pattern;
+import java.util.concurrent.TimeoutException;
 
 /**
  * A prioritized {@link ThreadPoolExecutor} for running jobs in Glide.
  */
-public final class GlideExecutor extends ThreadPoolExecutor {
-
+public final class GlideExecutor implements ExecutorService {
   /**
    * The default thread name prefix for executors used to load/decode/transform data not found in
    * cache.
    */
-  public static final String DEFAULT_SOURCE_EXECUTOR_NAME = "source";
+  private static final String DEFAULT_SOURCE_EXECUTOR_NAME = "source";
+
   /**
    * The default thread name prefix for executors used to load/decode/transform data found in
    * Glide's cache.
    */
-  public static final String DEFAULT_DISK_CACHE_EXECUTOR_NAME = "disk-cache";
+  private static final String DEFAULT_DISK_CACHE_EXECUTOR_NAME = "disk-cache";
+
   /**
    * The default thread count for executors used to load/decode/transform data found in Glide's
    * cache.
    */
-  public static final int DEFAULT_DISK_CACHE_EXECUTOR_THREADS = 1;
+  private static final int DEFAULT_DISK_CACHE_EXECUTOR_THREADS = 1;
 
   private static final String TAG = "GlideExecutor";
-  private static final String CPU_NAME_REGEX = "cpu[0-9]+";
-  private static final String CPU_LOCATION = "/sys/devices/system/cpu/";
-  // Don't use more than four threads when automatically determining thread count..
-  private static final int MAXIMUM_AUTOMATIC_THREAD_COUNT = 4;
-  private final boolean executeSynchronously;
 
   /**
    * The default thread name prefix for executors from unlimited thread pool used to
    * load/decode/transform data not found in cache.
    */
   private static final String SOURCE_UNLIMITED_EXECUTOR_NAME = "source-unlimited";
+
+  private static final String ANIMATION_EXECUTOR_NAME = "animation";
+
   /**
-   * The default keep alive time for threads in source unlimited executor pool in milliseconds.
+   * The default keep alive time for threads in our cached thread pools in milliseconds.
    */
-  private static final long SOURCE_UNLIMITED_EXECUTOR_KEEP_ALIVE_TIME_MS =
-      TimeUnit.SECONDS.toMillis(10);
+  private static final long KEEP_ALIVE_TIME_MS = TimeUnit.SECONDS.toMillis(10);
+
+  // Don't use more than four threads when automatically determining thread count..
+  private static final int MAXIMUM_AUTOMATIC_THREAD_COUNT = 4;
+
+  // May be accessed on other threads, but this is an optimization only so it's ok if we set its
+  // value more than once.
+  private static volatile int bestThreadCount;
+
+  private final ExecutorService delegate;
 
   /**
    * Returns a new fixed thread pool with the default thread count returned from
@@ -67,8 +75,10 @@
    * <p>Disk cache executors do not allow network operations on their threads.
    */
   public static GlideExecutor newDiskCacheExecutor() {
-    return newDiskCacheExecutor(DEFAULT_DISK_CACHE_EXECUTOR_THREADS,
-        DEFAULT_DISK_CACHE_EXECUTOR_NAME, UncaughtThrowableStrategy.DEFAULT);
+    return newDiskCacheExecutor(
+        DEFAULT_DISK_CACHE_EXECUTOR_THREADS,
+        DEFAULT_DISK_CACHE_EXECUTOR_NAME,
+        UncaughtThrowableStrategy.DEFAULT);
   }
 
   /**
@@ -83,10 +93,14 @@ public static GlideExecutor newDiskCacheExecutor() {
    * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
    *                                  handle uncaught exceptions.
    */
+  // Public API.
+  @SuppressWarnings("unused")
   public static GlideExecutor newDiskCacheExecutor(
           UncaughtThrowableStrategy uncaughtThrowableStrategy) {
-    return newDiskCacheExecutor(DEFAULT_DISK_CACHE_EXECUTOR_THREADS,
-                                DEFAULT_DISK_CACHE_EXECUTOR_NAME, uncaughtThrowableStrategy);
+    return newDiskCacheExecutor(
+        DEFAULT_DISK_CACHE_EXECUTOR_THREADS,
+        DEFAULT_DISK_CACHE_EXECUTOR_NAME,
+        uncaughtThrowableStrategy);
   }
 
   /**
@@ -101,10 +115,18 @@ public static GlideExecutor newDiskCacheExecutor(
    * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
    *                                  handle uncaught exceptions.
    */
-  public static GlideExecutor newDiskCacheExecutor(int threadCount, String name,
-      UncaughtThrowableStrategy uncaughtThrowableStrategy) {
-    return new GlideExecutor(threadCount, name, uncaughtThrowableStrategy,
-        true /*preventNetworkOperations*/, false /*executeSynchronously*/);
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public static GlideExecutor newDiskCacheExecutor(
+      int threadCount, String name, UncaughtThrowableStrategy uncaughtThrowableStrategy) {
+    return new GlideExecutor(
+        new ThreadPoolExecutor(
+            threadCount /* corePoolSize */,
+            threadCount /* maximumPoolSize */,
+            0 /* keepAliveTime */,
+            TimeUnit.MILLISECONDS,
+            new PriorityBlockingQueue<Runnable>(),
+            new DefaultThreadFactory(name, uncaughtThrowableStrategy, true)));
   }
 
   /**
@@ -117,7 +139,9 @@ public static GlideExecutor newDiskCacheExecutor(int threadCount, String name,
    * <p>Source executors allow network operations on their threads.
    */
   public static GlideExecutor newSourceExecutor() {
-    return newSourceExecutor(calculateBestThreadCount(), DEFAULT_SOURCE_EXECUTOR_NAME,
+    return newSourceExecutor(
+        calculateBestThreadCount(),
+        DEFAULT_SOURCE_EXECUTOR_NAME,
         UncaughtThrowableStrategy.DEFAULT);
   }
 
@@ -134,10 +158,14 @@ public static GlideExecutor newSourceExecutor() {
    * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
    *                                  handle uncaught exceptions.
    */
+  // Public API.
+  @SuppressWarnings("unused")
   public static GlideExecutor newSourceExecutor(
-          UncaughtThrowableStrategy uncaughtThrowableStrategy) {
-    return newDiskCacheExecutor(DEFAULT_DISK_CACHE_EXECUTOR_THREADS,
-                                DEFAULT_DISK_CACHE_EXECUTOR_NAME, uncaughtThrowableStrategy);
+      UncaughtThrowableStrategy uncaughtThrowableStrategy) {
+    return newSourceExecutor(
+        calculateBestThreadCount(),
+        DEFAULT_SOURCE_EXECUTOR_NAME,
+        uncaughtThrowableStrategy);
   }
 
   /**
@@ -152,15 +180,23 @@ public static GlideExecutor newSourceExecutor(
    * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
    *                                  handle uncaught exceptions.
    */
-  public static GlideExecutor newSourceExecutor(int threadCount, String name,
-      UncaughtThrowableStrategy uncaughtThrowableStrategy) {
-    return new GlideExecutor(threadCount, name, uncaughtThrowableStrategy,
-        false /*preventNetworkOperations*/, false /*executeSynchronously*/);
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public static GlideExecutor newSourceExecutor(
+      int threadCount, String name, UncaughtThrowableStrategy uncaughtThrowableStrategy) {
+    return new GlideExecutor(
+        new ThreadPoolExecutor(
+            threadCount /* corePoolSize */,
+            threadCount /* maximumPoolSize */,
+            0 /* keepAliveTime */,
+            TimeUnit.MILLISECONDS,
+            new PriorityBlockingQueue<Runnable>(),
+            new DefaultThreadFactory(name, uncaughtThrowableStrategy, false)));
   }
 
   /**
    * Returns a new unlimited thread pool with zero core thread count to make sure no threads are
-   * created by default, {@link #SOURCE_UNLIMITED_EXECUTOR_KEEP_ALIVE_TIME_MS} keep alive
+   * created by default, {@link #KEEP_ALIVE_TIME_MS} keep alive
    * time, the {@link #SOURCE_UNLIMITED_EXECUTOR_NAME} thread name prefix, the
    * {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy#DEFAULT}
    * uncaught throwable strategy, and the {@link SynchronousQueue} since using default unbounded
@@ -173,138 +209,156 @@ public static GlideExecutor newSourceExecutor(int threadCount, String name,
    * <p>Source executors allow network operations on their threads.
    */
   public static GlideExecutor newUnlimitedSourceExecutor() {
-    return new GlideExecutor(0 /* corePoolSize */,
-        Integer.MAX_VALUE /* maximumPoolSize */,
-        SOURCE_UNLIMITED_EXECUTOR_KEEP_ALIVE_TIME_MS,
-        SOURCE_UNLIMITED_EXECUTOR_NAME,
-        UncaughtThrowableStrategy.DEFAULT,
-        false /*preventNetworkOperations*/,
-        false /*executeSynchronously*/,
-        new SynchronousQueue<Runnable>());
+    return new GlideExecutor(new ThreadPoolExecutor(
+        0,
+        Integer.MAX_VALUE,
+        KEEP_ALIVE_TIME_MS,
+        TimeUnit.MILLISECONDS,
+        new SynchronousQueue<Runnable>(),
+        new DefaultThreadFactory(
+            SOURCE_UNLIMITED_EXECUTOR_NAME,
+            UncaughtThrowableStrategy.DEFAULT,
+            false)));
   }
 
-  // Visible for testing.
-  GlideExecutor(int poolSize, String name,
-      UncaughtThrowableStrategy uncaughtThrowableStrategy, boolean preventNetworkOperations,
-      boolean executeSynchronously) {
-    this(
-        poolSize /* corePoolSize */,
-        poolSize /* maximumPoolSize */,
-        0 /* keepAliveTimeInMs */,
-        name,
-        uncaughtThrowableStrategy,
-        preventNetworkOperations,
-        executeSynchronously);
+  /**
+   * Returns a new cached thread pool that defaults to either one or two threads depending on the
+   * number of available cores to use when loading frames of animations.
+   */
+  public static GlideExecutor newAnimationExecutor() {
+    int bestThreadCount = calculateBestThreadCount();
+    // We don't want to add a ton of threads running animations in parallel with our source and
+    // disk cache executors. Doing so adds unnecessary CPU load and can also dramatically increase
+    // our maximum memory usage. Typically one thread is sufficient here, but for higher end devices
+    // with more cores, two threads can provide better performance if lots of GIFs are showing at
+    // once.
+    int maximumPoolSize = bestThreadCount >= 4 ? 2 : 1;
+
+    return newAnimationExecutor(maximumPoolSize, UncaughtThrowableStrategy.DEFAULT);
   }
 
-  GlideExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTimeInMs, String name,
-      UncaughtThrowableStrategy uncaughtThrowableStrategy, boolean preventNetworkOperations,
-      boolean executeSynchronously) {
-    this(
-        corePoolSize,
-        maximumPoolSize,
-        keepAliveTimeInMs,
-        name,
-        uncaughtThrowableStrategy,
-        preventNetworkOperations,
-        executeSynchronously,
-        new PriorityBlockingQueue<Runnable>());
+  /**
+   * Returns a new cached thread pool with the given thread count and
+   * {@link UncaughtThrowableStrategy} to use when loading frames of animations.
+   */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public static GlideExecutor newAnimationExecutor(
+      int threadCount, UncaughtThrowableStrategy uncaughtThrowableStrategy) {
+     return new GlideExecutor(
+        new ThreadPoolExecutor(
+            0 /* corePoolSize */,
+            threadCount,
+            KEEP_ALIVE_TIME_MS,
+            TimeUnit.MILLISECONDS,
+            new PriorityBlockingQueue<Runnable>(),
+            new DefaultThreadFactory(
+                ANIMATION_EXECUTOR_NAME,
+                uncaughtThrowableStrategy,
+                true)));
   }
 
-  GlideExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTimeInMs, String name,
-      UncaughtThrowableStrategy uncaughtThrowableStrategy, boolean preventNetworkOperations,
-      boolean executeSynchronously, BlockingQueue<Runnable> queue) {
-    super(
-        corePoolSize,
-        maximumPoolSize,
-        keepAliveTimeInMs,
-        TimeUnit.MILLISECONDS,
-        queue,
-        new DefaultThreadFactory(name, uncaughtThrowableStrategy, preventNetworkOperations));
-    this.executeSynchronously = executeSynchronously;
+  @VisibleForTesting
+  GlideExecutor(ExecutorService delegate) {
+    this.delegate = delegate;
   }
 
   @Override
-  public void execute(Runnable command) {
-    if (executeSynchronously) {
-      command.run();
-    } else {
-      super.execute(command);
-    }
+  public void execute(@NonNull Runnable command) {
+    delegate.execute(command);
   }
 
   @NonNull
   @Override
-  public Future<?> submit(Runnable task) {
-    return maybeWait(super.submit(task));
+  public Future<?> submit(@NonNull Runnable task) {
+    return delegate.submit(task);
   }
 
-  private <T> Future<T> maybeWait(Future<T> future) {
-    if (executeSynchronously) {
-      boolean interrupted = false;
-      try {
-        while (!future.isDone()) {
-          try {
-            future.get();
-          } catch (ExecutionException e) {
-            throw new RuntimeException(e);
-          } catch (InterruptedException e) {
-            interrupted = true;
-          }
-        }
-      } finally {
-        if (interrupted) {
-          Thread.currentThread().interrupt();
-        }
-      }
-    }
-    return future;
+  @NonNull
+  @Override
+  public <T> List<Future<T>> invokeAll(@NonNull Collection<? extends Callable<T>> tasks)
+      throws InterruptedException {
+    return delegate.invokeAll(tasks);
   }
 
   @NonNull
   @Override
-  public <T> Future<T> submit(Runnable task, T result) {
-    return maybeWait(super.submit(task, result));
+  public <T> List<Future<T>> invokeAll(
+      @NonNull Collection<? extends Callable<T>> tasks,
+      long timeout,
+      @NonNull TimeUnit unit) throws InterruptedException {
+    return delegate.invokeAll(tasks, timeout, unit);
   }
 
+  @NonNull
   @Override
-  public <T> Future<T> submit(Callable<T> task) {
-    return maybeWait(super.submit(task));
+  public <T> T invokeAny(@NonNull Collection<? extends Callable<T>> tasks)
+      throws InterruptedException, ExecutionException {
+    return delegate.invokeAny(tasks);
+  }
+
+  @Override
+  public <T> T invokeAny(
+      @NonNull Collection<? extends Callable<T>> tasks,
+      long timeout,
+      @NonNull TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
+    return delegate.invokeAny(tasks, timeout, unit);
+  }
+
+  @NonNull
+  @Override
+  public <T> Future<T> submit(@NonNull Runnable task, T result) {
+    return delegate.submit(task, result);
+  }
+
+  @Override
+  public <T> Future<T> submit(@NonNull Callable<T> task) {
+    return delegate.submit(task);
+  }
+
+  @Override
+  public void shutdown() {
+    delegate.shutdown();
+  }
+
+  @NonNull
+  @Override
+  public List<Runnable> shutdownNow() {
+    return delegate.shutdownNow();
+  }
+
+  @Override
+  public boolean isShutdown() {
+    return delegate.isShutdown();
+  }
+
+  @Override
+  public boolean isTerminated() {
+    return delegate.isTerminated();
+  }
+
+  @Override
+  public boolean awaitTermination(long timeout, @NonNull TimeUnit unit)
+      throws InterruptedException {
+    return delegate.awaitTermination(timeout, unit);
+  }
+
+  @Override
+  public String toString() {
+    return delegate.toString();
   }
 
   /**
    * Determines the number of cores available on the device.
-   *
-   * <p>{@link Runtime#availableProcessors()} returns the number of awake cores, which may not
-   * be the number of available cores depending on the device's current state. See
-   * http://goo.gl/8H670N.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public static int calculateBestThreadCount() {
-    // We override the current ThreadPolicy to allow disk reads.
-    // This shouldn't actually do disk-IO and accesses a device file.
-    // See: https://github.com/bumptech/glide/issues/1170
-    ThreadPolicy originalPolicy = StrictMode.allowThreadDiskReads();
-    File[] cpus = null;
-    try {
-      File cpuInfo = new File(CPU_LOCATION);
-      final Pattern cpuNamePattern = Pattern.compile(CPU_NAME_REGEX);
-      cpus = cpuInfo.listFiles(new FilenameFilter() {
-        @Override
-        public boolean accept(File file, String s) {
-          return cpuNamePattern.matcher(s).matches();
-        }
-      });
-    } catch (Throwable t) {
-      if (Log.isLoggable(TAG, Log.ERROR)) {
-        Log.e(TAG, "Failed to calculate accurate cpu count", t);
-      }
-    } finally {
-      StrictMode.setThreadPolicy(originalPolicy);
+    if (bestThreadCount == 0) {
+      bestThreadCount =
+          Math.min(MAXIMUM_AUTOMATIC_THREAD_COUNT, RuntimeCompat.availableProcessors());
     }
-
-    int cpuCount = cpus != null ? cpus.length : 0;
-    int availableProcessors = Math.max(1, Runtime.getRuntime().availableProcessors());
-    return Math.min(MAXIMUM_AUTOMATIC_THREAD_COUNT, Math.max(availableProcessors, cpuCount));
+    return bestThreadCount;
   }
 
   /**
@@ -315,6 +369,8 @@ public boolean accept(File file, String s) {
     /**
      * Silently catches and ignores the uncaught {@link Throwable}s.
      */
+    // Public API.
+    @SuppressWarnings("unused")
     UncaughtThrowableStrategy IGNORE = new UncaughtThrowableStrategy() {
       @Override
       public void handle(Throwable t) {
@@ -335,6 +391,8 @@ public void handle(Throwable t) {
     /**
      * Rethrows the uncaught {@link Throwable}s to crash the app.
      */
+    // Public API.
+    @SuppressWarnings("unused")
     UncaughtThrowableStrategy THROW = new UncaughtThrowableStrategy() {
       @Override
       public void handle(Throwable t) {
@@ -355,6 +413,9 @@ public void handle(Throwable t) {
    * android.os.Process#THREAD_PRIORITY_BACKGROUND}.
    */
   private static final class DefaultThreadFactory implements ThreadFactory {
+    private static final int DEFAULT_PRIORITY = android.os.Process.THREAD_PRIORITY_BACKGROUND
+        + android.os.Process.THREAD_PRIORITY_MORE_FAVORABLE;
+
     private final String name;
     @Synthetic final UncaughtThrowableStrategy uncaughtThrowableStrategy;
     @Synthetic final boolean preventNetworkOperations;
@@ -372,9 +433,8 @@ public synchronized Thread newThread(@NonNull Runnable runnable) {
       final Thread result = new Thread(runnable, "glide-" + name + "-thread-" + threadNum) {
         @Override
         public void run() {
-          android.os.Process.setThreadPriority(
-              android.os.Process.THREAD_PRIORITY_BACKGROUND
-              + android.os.Process.THREAD_PRIORITY_MORE_FAVORABLE);
+          // why PMD suppression is needed: https://github.com/pmd/pmd/issues/808
+          android.os.Process.setThreadPriority(DEFAULT_PRIORITY); //NOPMD AccessorMethodGeneration
           if (preventNetworkOperations) {
             StrictMode.setThreadPolicy(
                 new ThreadPolicy.Builder()
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/executor/RuntimeCompat.java b/library/src/main/java/com/bumptech/glide/load/engine/executor/RuntimeCompat.java
new file mode 100644
index 000000000..8dc69bdeb
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/RuntimeCompat.java
@@ -0,0 +1,68 @@
+package com.bumptech.glide.load.engine.executor;
+
+import android.os.Build;
+import android.os.StrictMode;
+import android.os.StrictMode.ThreadPolicy;
+import android.util.Log;
+import java.io.File;
+import java.io.FilenameFilter;
+import java.util.regex.Pattern;
+
+/**
+ * Compatibility methods for {@link java.lang.Runtime}.
+ */
+final class RuntimeCompat {
+  private static final String TAG = "GlideRuntimeCompat";
+  private static final String CPU_NAME_REGEX = "cpu[0-9]+";
+  private static final String CPU_LOCATION = "/sys/devices/system/cpu/";
+
+  private RuntimeCompat() {
+    // Utility class.
+  }
+
+  /**
+   * Determines the number of cores available on the device.
+   */
+  static int availableProcessors() {
+    int cpus = Runtime.getRuntime().availableProcessors();
+    if (Build.VERSION.SDK_INT < 17) {
+      cpus = Math.max(getCoreCountPre17(), cpus);
+    }
+    return cpus;
+  }
+
+  /**
+   * Determines the number of cores available on the device (pre-v17).
+   *
+   * <p>Before Jellybean, {@link Runtime#availableProcessors()} returned the number of awake cores,
+   * which may not be the number of available cores depending on the device's current state. See
+   * https://stackoverflow.com/a/30150409.
+   *
+   * @return the maximum number of processors available to the VM; never smaller than one
+   */
+  @SuppressWarnings("PMD")
+  private static int getCoreCountPre17() {
+    // We override the current ThreadPolicy to allow disk reads.
+    // This shouldn't actually do disk-IO and accesses a device file.
+    // See: https://github.com/bumptech/glide/issues/1170
+    File[] cpus = null;
+    ThreadPolicy originalPolicy = StrictMode.allowThreadDiskReads();
+    try {
+      File cpuInfo = new File(CPU_LOCATION);
+      final Pattern cpuNamePattern = Pattern.compile(CPU_NAME_REGEX);
+      cpus = cpuInfo.listFiles(new FilenameFilter() {
+        @Override
+        public boolean accept(File file, String s) {
+          return cpuNamePattern.matcher(s).matches();
+        }
+      });
+    } catch (Throwable t) {
+      if (Log.isLoggable(TAG, Log.ERROR)) {
+        Log.e(TAG, "Failed to calculate accurate cpu count", t);
+      }
+    } finally {
+      StrictMode.setThreadPolicy(originalPolicy);
+    }
+    return Math.max(1, cpus != null ? cpus.length : 0);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java
index a2f92a9db..a8c5d641c 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java
@@ -4,6 +4,8 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.os.SystemClock;
+import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
 import android.util.Log;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
@@ -28,7 +30,8 @@
  * limit, we assume a GC has occurred, stop the current allocations, and try again after a delay.
  */
 final class BitmapPreFillRunner implements Runnable {
-  private static final String TAG = "PreFillRunner";
+  @VisibleForTesting
+  static final String TAG = "PreFillRunner";
   private static final Clock DEFAULT_CLOCK = new Clock();
 
   /**
@@ -62,15 +65,25 @@
   private long currentDelay = INITIAL_BACKOFF_MS;
   private boolean isCancelled;
 
-  public BitmapPreFillRunner(BitmapPool bitmapPool, MemoryCache memoryCache,
-      PreFillQueue allocationOrder) {
-    this(bitmapPool, memoryCache, allocationOrder, DEFAULT_CLOCK,
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public BitmapPreFillRunner(
+      BitmapPool bitmapPool, MemoryCache memoryCache, PreFillQueue allocationOrder) {
+    this(
+        bitmapPool,
+        memoryCache,
+        allocationOrder,
+        DEFAULT_CLOCK,
         new Handler(Looper.getMainLooper()));
   }
 
-  // Visible for testing.
-  BitmapPreFillRunner(BitmapPool bitmapPool, MemoryCache memoryCache, PreFillQueue allocationOrder,
-      Clock clock, Handler handler) {
+  @VisibleForTesting
+  BitmapPreFillRunner(
+      BitmapPool bitmapPool,
+      MemoryCache memoryCache,
+      PreFillQueue allocationOrder,
+      Clock clock,
+      Handler handler) {
     this.bitmapPool = bitmapPool;
     this.memoryCache = memoryCache;
     this.toPrefill = allocationOrder;
@@ -86,33 +99,44 @@ public void cancel() {
    * Attempts to allocate {@link android.graphics.Bitmap}s and returns {@code true} if there are
    * more {@link android.graphics.Bitmap}s to allocate and {@code false} otherwise.
    */
-  private boolean allocate() {
+  @VisibleForTesting
+  boolean allocate() {
     long start = clock.now();
     while (!toPrefill.isEmpty() && !isGcDetected(start)) {
       PreFillType toAllocate = toPrefill.remove();
       final Bitmap bitmap;
       if (!seenTypes.contains(toAllocate)) {
         seenTypes.add(toAllocate);
-        bitmap = bitmapPool.getDirty(toAllocate.getWidth(), toAllocate.getHeight(),
-            toAllocate.getConfig());
+        bitmap =
+            bitmapPool.getDirty(
+                toAllocate.getWidth(), toAllocate.getHeight(), toAllocate.getConfig());
       } else {
-        bitmap = Bitmap.createBitmap(toAllocate.getWidth(), toAllocate.getHeight(),
-            toAllocate.getConfig());
+        bitmap =
+            Bitmap.createBitmap(
+                toAllocate.getWidth(), toAllocate.getHeight(), toAllocate.getConfig());
       }
 
+      // Order matters here! If the Bitmap is too large or the BitmapPool is too full, it may be
+      // recycled after the call to bitmapPool#put below.
+      int bitmapSize = Util.getBitmapByteSize(bitmap);
+
       // Don't over fill the memory cache to avoid evicting useful resources, but make sure it's
-      // not empty so
-      // we use all available space.
-      if (getFreeMemoryCacheBytes() >= Util.getBitmapByteSize(bitmap)) {
-        memoryCache.put(new UniqueKey(), BitmapResource.obtain(bitmap, bitmapPool));
+      // not empty so that we use all available space.
+      if (getFreeMemoryCacheBytes() >= bitmapSize) {
+        // We could probably make UniqueKey just always return false from equals,
+        // but the allocation of the Key is not nearly as expensive as the allocation of the Bitmap,
+        // so it's probably not worth it.
+        @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")
+        Key uniqueKey = new UniqueKey();
+        memoryCache.put(uniqueKey, BitmapResource.obtain(bitmap, bitmapPool));
       } else {
         bitmapPool.put(bitmap);
       }
 
       if (Log.isLoggable(TAG, Log.DEBUG)) {
         Log.d(TAG,
-            "allocated [" + toAllocate.getWidth() + "x" + toAllocate.getHeight() + "] " + toAllocate
-                .getConfig() + " size: " + Util.getBitmapByteSize(bitmap));
+            "allocated [" + toAllocate.getWidth() + "x" + toAllocate.getHeight() + "] "
+                + toAllocate.getConfig() + " size: " + bitmapSize);
       }
     }
 
@@ -123,7 +147,7 @@ private boolean isGcDetected(long startTimeMs) {
     return clock.now() - startTimeMs >= MAX_DURATION_MS;
   }
 
-  private int getFreeMemoryCacheBytes() {
+  private long getFreeMemoryCacheBytes() {
     return memoryCache.getMaxSize() - memoryCache.getCurrentSize();
   }
 
@@ -140,20 +164,21 @@ private long getNextDelay() {
     return result;
   }
 
-  private static class UniqueKey implements Key {
+  private static final class UniqueKey implements Key {
 
     @Synthetic
+    @SuppressWarnings("WeakerAccess")
     UniqueKey() { }
 
     @Override
-    public void updateDiskCacheKey(MessageDigest messageDigest) {
+    public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
       throw new UnsupportedOperationException();
     }
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class Clock {
-    public long now() {
+    long now() {
       return SystemClock.currentThreadTimeMillis();
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java
index c5caa3cc7..9ddc221ed 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java
@@ -3,6 +3,7 @@
 import android.graphics.Bitmap;
 import android.os.Handler;
 import android.os.Looper;
+import android.support.annotation.VisibleForTesting;
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
@@ -53,9 +54,9 @@ public void preFill(PreFillType.Builder... bitmapAttributeBuilders) {
     handler.post(current);
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   PreFillQueue generateAllocationOrder(PreFillType... preFillSizes) {
-    final int maxSize =
+    final long maxSize =
         memoryCache.getMaxSize() - memoryCache.getCurrentSize() + bitmapPool.getMaxSize();
 
     int totalWeight = 0;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillType.java b/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillType.java
index 9c07fb07c..31a8b529a 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillType.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillType.java
@@ -2,6 +2,7 @@
 
 import android.graphics.Bitmap;
 import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 import com.bumptech.glide.util.Preconditions;
 
 /**
@@ -10,7 +11,7 @@
  * single size and configuration.
  */
 public final class PreFillType {
-  // Visible for testing.
+  @VisibleForTesting
   static final Bitmap.Config DEFAULT_CONFIG = Bitmap.Config.RGB_565;
   private final int width;
   private final int height;
diff --git a/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java
index 7083de7bc..9eea06323 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java
@@ -4,6 +4,7 @@
 import android.content.res.AssetManager;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.FileDescriptorAssetPathFetcher;
@@ -25,20 +26,22 @@
   private final AssetManager assetManager;
   private final AssetFetcherFactory<Data> factory;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public AssetUriLoader(AssetManager assetManager, AssetFetcherFactory<Data> factory) {
     this.assetManager = assetManager;
     this.factory = factory;
   }
 
   @Override
-  public LoadData<Data> buildLoadData(Uri model, int width, int height,
-      Options options) {
+  public LoadData<Data> buildLoadData(@NonNull Uri model, int width, int height,
+      @NonNull Options options) {
     String assetPath = model.toString().substring(ASSET_PREFIX_LENGTH);
     return new LoadData<>(new ObjectKey(model), factory.buildFetcher(assetManager, assetPath));
   }
 
   @Override
-  public boolean handles(Uri model) {
+  public boolean handles(@NonNull Uri model) {
     return ContentResolver.SCHEME_FILE.equals(model.getScheme()) && !model.getPathSegments()
         .isEmpty() && ASSET_PATH_SEGMENT.equals(model.getPathSegments().get(0));
   }
@@ -64,6 +67,7 @@ public StreamFactory(AssetManager assetManager) {
       this.assetManager = assetManager;
     }
 
+    @NonNull
     @Override
     public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new AssetUriLoader<>(assetManager, this);
@@ -93,6 +97,7 @@ public FileDescriptorFactory(AssetManager assetManager) {
       this.assetManager = assetManager;
     }
 
+    @NonNull
     @Override
     public ModelLoader<Uri, ParcelFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
       return new AssetUriLoader<>(assetManager, this);
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
index 60c4a9452..bb8213fc1 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
@@ -5,7 +5,7 @@
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
-import com.bumptech.glide.signature.EmptySignature;
+import com.bumptech.glide.signature.ObjectKey;
 import java.io.ByteArrayInputStream;
 import java.io.InputStream;
 import java.nio.ByteBuffer;
@@ -20,28 +20,30 @@
 public class ByteArrayLoader<Data> implements ModelLoader<byte[], Data> {
   private final Converter<Data> converter;
 
+  @SuppressWarnings("WeakerAccess") // Public API
   public ByteArrayLoader(Converter<Data> converter) {
     this.converter = converter;
   }
 
   @Override
-  public LoadData<Data> buildLoadData(byte[] model, int width, int height,
-      Options options) {
-    // TODO: compare the actual bytes?
-    return new LoadData<>(EmptySignature.obtain(), new Fetcher<>(model, converter));
+  public LoadData<Data> buildLoadData(
+      @NonNull byte[] model, int width, int height, @NonNull Options options) {
+    return new LoadData<>(new ObjectKey(model), new Fetcher<>(model, converter));
   }
 
   @Override
-  public boolean handles(byte[] model) {
+  public boolean handles(@NonNull byte[] model) {
     return true;
   }
 
   /**
    * Converts between a byte array a desired model class.
+   *
    * @param <Data> The type of data to convert to.
    */
   public interface Converter<Data> {
     Data convert(byte[] model);
+
     Class<Data> getDataClass();
   }
 
@@ -49,13 +51,19 @@ public boolean handles(byte[] model) {
     private final byte[] model;
     private final Converter<Data> converter;
 
-    public Fetcher(byte[] model, Converter<Data> converter) {
+    /**
+     * @param model We really ought to copy the model, but doing so can be hugely expensive and/or
+     *              lead to OOMs. In practice it's unlikely that users would pass an array into
+     *              Glide and then mutate it.
+     */
+    @SuppressWarnings("PMD.ArrayIsStoredDirectly")
+    Fetcher(byte[] model, Converter<Data> converter) {
       this.model = model;
       this.converter = converter;
     }
 
     @Override
-    public void loadData(Priority priority, DataCallback<? super Data> callback) {
+    public void loadData(@NonNull Priority priority, @NonNull DataCallback<? super Data> callback) {
       Data result = converter.convert(model);
       callback.onDataReady(result);
     }
@@ -89,8 +97,9 @@ public DataSource getDataSource() {
    */
   public static class ByteBufferFactory implements ModelLoaderFactory<byte[], ByteBuffer> {
 
+    @NonNull
     @Override
-    public ModelLoader<byte[], ByteBuffer> build(MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<byte[], ByteBuffer> build(@NonNull MultiModelLoaderFactory multiFactory) {
       return new ByteArrayLoader<>(new Converter<ByteBuffer>() {
         @Override
         public ByteBuffer convert(byte[] model) {
@@ -115,8 +124,9 @@ public void teardown() {
    */
   public static class StreamFactory implements ModelLoaderFactory<byte[], InputStream> {
 
+    @NonNull
     @Override
-    public ModelLoader<byte[], InputStream> build(MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<byte[], InputStream> build(@NonNull MultiModelLoaderFactory multiFactory) {
       return new ByteArrayLoader<>(new Converter<InputStream>() {
         @Override
         public InputStream convert(byte[] model) {
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferEncoder.java b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferEncoder.java
index 278d16f2f..9c8b6a121 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferEncoder.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.model;
 
+import android.support.annotation.NonNull;
 import android.util.Log;
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.Options;
@@ -15,7 +16,7 @@
   private static final String TAG = "ByteBufferEncoder";
 
   @Override
-  public boolean encode(ByteBuffer data, File file, Options options) {
+  public boolean encode(@NonNull ByteBuffer data, @NonNull File file, @NonNull Options options) {
     boolean success = false;
     try {
       ByteBufferUtil.toFile(data, file);
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java
index 82a787898..c56d04b08 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java
@@ -8,6 +8,7 @@
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.signature.ObjectKey;
 import com.bumptech.glide.util.ByteBufferUtil;
+import com.bumptech.glide.util.Synthetic;
 import java.io.File;
 import java.io.IOException;
 import java.nio.ByteBuffer;
@@ -19,13 +20,13 @@
   private static final String TAG = "ByteBufferFileLoader";
 
   @Override
-  public LoadData<ByteBuffer> buildLoadData(File file, int width, int height,
-      Options options) {
+  public LoadData<ByteBuffer> buildLoadData(@NonNull File file, int width, int height,
+      @NonNull Options options) {
     return new LoadData<>(new ObjectKey(file), new ByteBufferFetcher(file));
   }
 
   @Override
-  public boolean handles(File file) {
+  public boolean handles(@NonNull File file) {
     return true;
   }
 
@@ -34,8 +35,9 @@ public boolean handles(File file) {
    */
   public static class Factory implements ModelLoaderFactory<File, ByteBuffer> {
 
+    @NonNull
     @Override
-    public ModelLoader<File, ByteBuffer> build(MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<File, ByteBuffer> build(@NonNull MultiModelLoaderFactory multiFactory) {
       return new ByteBufferFileLoader();
     }
 
@@ -45,17 +47,20 @@ public void teardown() {
     }
   }
 
-  private static class ByteBufferFetcher implements DataFetcher<ByteBuffer> {
+  private static final class ByteBufferFetcher implements DataFetcher<ByteBuffer> {
 
     private final File file;
 
-    public ByteBufferFetcher(File file) {
+    @Synthetic
+    @SuppressWarnings("WeakerAccess")
+    ByteBufferFetcher(File file) {
       this.file = file;
     }
 
     @Override
-    public void loadData(Priority priority, DataCallback<? super ByteBuffer> callback) {
-      ByteBuffer result = null;
+    public void loadData(@NonNull Priority priority,
+        @NonNull DataCallback<? super ByteBuffer> callback) {
+      ByteBuffer result;
       try {
         result = ByteBufferUtil.fromFile(file);
       } catch (IOException e) {
diff --git a/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java
index 4f522f4ac..646c43907 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java
@@ -20,26 +20,33 @@
  *
  * <p>Briefly, a 'data' URL has the form: <pre>data:[mediatype][;base64],some_data</pre>
  *
- * @param <Data> The type of data that can be opened.
+ * @param <Model> The type of Model that we can retrieve data for, e.g. {@link String}.
+ * @param <Data> The type of data that can be opened, e.g. {@link InputStream}.
  */
-public final class DataUrlLoader<Data> implements ModelLoader<String, Data> {
+public final class DataUrlLoader<Model, Data> implements ModelLoader<Model, Data> {
 
   private static final String DATA_SCHEME_IMAGE = "data:image";
   private static final String BASE64_TAG = ";base64";
   private final DataDecoder<Data> dataDecoder;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public DataUrlLoader(DataDecoder<Data> dataDecoder) {
     this.dataDecoder = dataDecoder;
   }
 
   @Override
-  public LoadData<Data> buildLoadData(String model, int width, int height, Options options) {
-    return new LoadData<>(new ObjectKey(model), new DataUriFetcher<Data>(model, dataDecoder));
+  public LoadData<Data> buildLoadData(@NonNull Model model, int width, int height,
+      @NonNull Options options) {
+    return new LoadData<>(
+        new ObjectKey(model), new DataUriFetcher<>(model.toString(), dataDecoder));
   }
 
   @Override
-  public boolean handles(String url) {
-    return url.startsWith(DATA_SCHEME_IMAGE);
+  public boolean handles(@NonNull Model model) {
+    // We expect Model to be a Uri or a String, both of which implement toString() efficiently. We
+    // should reconsider this implementation before adding any new Model types.
+    return model.toString().startsWith(DATA_SCHEME_IMAGE);
   }
 
   /**
@@ -62,13 +69,13 @@ public boolean handles(String url) {
     private final DataDecoder<Data> reader;
     private Data data;
 
-    public DataUriFetcher(String dataUri, DataDecoder<Data> reader) {
+    DataUriFetcher(String dataUri, DataDecoder<Data> reader) {
       this.dataUri = dataUri;
       this.reader = reader;
     }
 
     @Override
-    public void loadData(Priority priority, DataCallback<? super Data> callback) {
+    public void loadData(@NonNull Priority priority, @NonNull DataCallback<? super Data> callback) {
       try {
         data = reader.decode(dataUri);
         callback.onDataReady(data);
@@ -105,9 +112,11 @@ public DataSource getDataSource() {
   }
 
   /**
-   * Factory for loading {@link InputStream} from Data URL string.
+   * Factory for loading {@link InputStream}s from data uris.
+   *
+   * @param <Model> The type of Model we can obtain data for, e.g. String.
    */
-  public static final class StreamFactory implements ModelLoaderFactory<String, InputStream> {
+  public static final class StreamFactory<Model> implements ModelLoaderFactory<Model, InputStream> {
 
     private final DataDecoder<InputStream> opener;
 
@@ -147,13 +156,15 @@ public void close(InputStream inputStream) throws IOException {
       };
     }
 
+    @NonNull
     @Override
-    public final ModelLoader<String, InputStream> build(MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Model, InputStream> build(
+        @NonNull MultiModelLoaderFactory multiFactory) {
       return new DataUrlLoader<>(opener);
     }
 
     @Override
-    public final void teardown() {
+    public void teardown() {
       // Do nothing.
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
index 3d6fb70c3..e4f0d9178 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
@@ -25,18 +25,20 @@
 
   private final FileOpener<Data> fileOpener;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public FileLoader(FileOpener<Data> fileOpener) {
     this.fileOpener = fileOpener;
   }
 
   @Override
-  public LoadData<Data> buildLoadData(File model, int width, int height,
-      Options options) {
+  public LoadData<Data> buildLoadData(@NonNull File model, int width, int height,
+      @NonNull Options options) {
     return new LoadData<>(new ObjectKey(model), new FileFetcher<>(model, fileOpener));
   }
 
   @Override
-  public boolean handles(File model) {
+  public boolean handles(@NonNull File model) {
     return true;
   }
 
@@ -50,18 +52,18 @@ public boolean handles(File model) {
     Class<Data> getDataClass();
   }
 
-  private static class FileFetcher<Data> implements DataFetcher<Data> {
+  private static final class FileFetcher<Data> implements DataFetcher<Data> {
     private final File file;
     private final FileOpener<Data> opener;
     private Data data;
 
-    public FileFetcher(File file, FileOpener<Data> opener) {
+    FileFetcher(File file, FileOpener<Data> opener) {
       this.file = file;
       this.opener = opener;
     }
 
     @Override
-    public void loadData(Priority priority, DataCallback<? super Data> callback) {
+    public void loadData(@NonNull Priority priority, @NonNull DataCallback<? super Data> callback) {
       try {
         data = opener.open(file);
       } catch (FileNotFoundException e) {
@@ -114,8 +116,9 @@ public Factory(FileOpener<Data> opener) {
       this.opener = opener;
     }
 
+    @NonNull
     @Override
-    public final ModelLoader<File, Data> build(MultiModelLoaderFactory multiFactory) {
+    public final ModelLoader<File, Data> build(@NonNull MultiModelLoaderFactory multiFactory) {
       return new FileLoader<>(opener);
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java
index 02a26aa26..4661d3b0d 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.model;
 
 import android.net.Uri;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.text.TextUtils;
 import com.bumptech.glide.load.Key;
@@ -26,7 +27,7 @@
  * convenience. </p>
  */
 public class GlideUrl implements Key {
-  private static final String ALLOWED_URI_CHARS = "@#&=*+-_.,:!?()/~'%";
+  private static final String ALLOWED_URI_CHARS = "@#&=*+-_.,:!?()/~'%;$";
   private final Headers headers;
   @Nullable private final URL url;
   @Nullable private final String stringUrl;
@@ -86,7 +87,7 @@ private String getSafeStringUrl() {
     if (TextUtils.isEmpty(safeStringUrl)) {
       String unsafeStringUrl = stringUrl;
       if (TextUtils.isEmpty(unsafeStringUrl)) {
-        unsafeStringUrl = url.toString();
+        unsafeStringUrl = Preconditions.checkNotNull(url).toString();
       }
       safeStringUrl = Uri.encode(unsafeStringUrl, ALLOWED_URI_CHARS);
     }
@@ -103,13 +104,15 @@ private String getSafeStringUrl() {
   /**
    * Returns an inexpensive to calculate {@link String} suitable for use as a disk cache key.
    *
-   * <p> This method does not include headers. </p>
+   * <p>This method does not include headers.
    *
-   * <p> Unlike {@link #toStringUrl()}} and {@link #toURL()}, this method does not escape
-   * input. </p>
+   * <p>Unlike {@link #toStringUrl()}} and {@link #toURL()}, this method does not escape
+   * input.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public String getCacheKey() {
-    return stringUrl != null ? stringUrl : url.toString();
+    return stringUrl != null ? stringUrl : Preconditions.checkNotNull(url).toString();
   }
 
   @Override
@@ -118,7 +121,7 @@ public String toString() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     messageDigest.update(getCacheKeyBytes());
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java
index 66a76cd11..c00cc434f 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java
@@ -9,16 +9,14 @@
  * <p> Implementations should implement equals() and hashcode() </p> .
  */
 public interface LazyHeaderFactory {
-
-    /**
-     * Returns an http header, or {@code null} if no header could be built.
-     *
-     * <p>Returning {@code null} or an empty String from this method will result in this particular
-     * key/value being excluded from the headers provided in the request. If there are multiple
-     * factories or values for a particular key, any non-null values will still be included for that
-     * key.
-     */
-    @Nullable
-    String buildHeader();
-
+  /**
+   * Returns an http header, or {@code null} if no header could be built.
+   *
+   * <p>Returning {@code null} or an empty String from this method will result in this particular
+   * key/value being excluded from the headers provided in the request. If there are multiple
+   * factories or values for a particular key, any non-null values will still be included for that
+   * key.
+   */
+  @Nullable
+  String buildHeader();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
index 5f4b4c85d..e7f446ca5 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.model;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.VisibleForTesting;
 import android.text.TextUtils;
 import java.util.ArrayList;
@@ -42,28 +43,32 @@
     Map<String, String> combinedHeaders = new HashMap<>();
 
     for (Map.Entry<String, List<LazyHeaderFactory>> entry : headers.entrySet()) {
-      StringBuilder sb = new StringBuilder();
-      List<LazyHeaderFactory> factories = entry.getValue();
-      int size = factories.size();
-      for (int i = 0; i < size; i++) {
-        LazyHeaderFactory factory = factories.get(i);
-        String header = factory.buildHeader();
-        if (!TextUtils.isEmpty(header)) {
-          sb.append(header);
-          if (i != factories.size() - 1) {
-            sb.append(',');
-          }
-        }
-      }
-      String values = sb.toString();
+      String values = buildHeaderValue(entry.getValue());
       if (!TextUtils.isEmpty(values)) {
-        combinedHeaders.put(entry.getKey(), sb.toString());
+        combinedHeaders.put(entry.getKey(), values);
       }
     }
 
     return combinedHeaders;
   }
 
+  @NonNull
+  private String buildHeaderValue(@NonNull List<LazyHeaderFactory> factories) {
+    StringBuilder sb = new StringBuilder();
+    int size = factories.size();
+    for (int i = 0; i < size; i++) {
+      LazyHeaderFactory factory = factories.get(i);
+      String header = factory.buildHeader();
+      if (!TextUtils.isEmpty(header)) {
+        sb.append(header);
+        if (i != factories.size() - 1) {
+          sb.append(',');
+        }
+      }
+    }
+    return sb.toString();
+  }
+
   @Override
   public String toString() {
     return "LazyHeaders{"
@@ -96,8 +101,6 @@ public int hashCode() {
    * {@link #addHeader(String, String)}, even though {@link #addHeader(String, LazyHeaderFactory)}
    * would usually append an additional value. </p>
    */
-   // PMD doesn't like the necessary static block to initialize DEFAULT_HEADERS.
-  @SuppressWarnings("PMD.FieldDeclarationsShouldBeAtStartOfClass")
   public static final class Builder {
     private static final String USER_AGENT_HEADER = "User-Agent";
     private static final String DEFAULT_USER_AGENT = getSanitizedUserAgent();
@@ -128,7 +131,6 @@ public int hashCode() {
      * (i.e. an OAuth token). </p>
      *
      * @see #addHeader(String, LazyHeaderFactory)
-
      */
     public Builder addHeader(String key, String value) {
       return addHeader(key, new StringHeaderFactory(value));
@@ -163,6 +165,7 @@ public Builder addHeader(String key, LazyHeaderFactory factory) {
      * <p> Use {@link #setHeader(String, LazyHeaderFactory)} if obtaining the value requires I/O
      * (i.e. an OAuth token). </p>
      */
+    @SuppressWarnings({"UnusedReturnValue", "WeakerAccess"}) // Public API
     public Builder setHeader(String key, String value) {
       return setHeader(key, value == null ? null : new StringHeaderFactory(value));
     }
@@ -215,10 +218,11 @@ public LazyHeaders build() {
     }
 
     private Map<String, List<LazyHeaderFactory>> copyHeaders() {
-      Map<String, List<LazyHeaderFactory>> result =
-          new HashMap<>(headers.size());
+      Map<String, List<LazyHeaderFactory>> result = new HashMap<>(headers.size());
       for (Map.Entry<String, List<LazyHeaderFactory>> entry : headers.entrySet()) {
-        result.put(entry.getKey(), new ArrayList<>(entry.getValue()));
+        @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")
+        List<LazyHeaderFactory> valueCopy = new ArrayList<>(entry.getValue());
+        result.put(entry.getKey(), valueCopy);
       }
       return result;
     }
@@ -226,7 +230,7 @@ public LazyHeaders build() {
     /**
      * Ensures that the default header will pass OkHttp3's checks for header values.
      *
-     * <p>See #2331.
+     * @see <a href="https://github.com/bumptech/glide/issues/2331">#2331</a>
      */
     @VisibleForTesting
     static String getSanitizedUserAgent() {
diff --git a/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java
index 7d389f197..6b36fb0ec 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java
@@ -18,21 +18,24 @@
 /**
  * Loads the file path for {@link MediaStore} owned {@link Uri uris}.
  */
-public final class MediaStoreFileLoader implements ModelLoader<Uri, File>  {
+public final class MediaStoreFileLoader implements ModelLoader<Uri, File> {
 
   private final Context context;
 
-  MediaStoreFileLoader(Context context) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public MediaStoreFileLoader(Context context) {
     this.context = context;
   }
 
   @Override
-  public LoadData<File> buildLoadData(Uri uri, int width, int height, Options options) {
+  public LoadData<File> buildLoadData(@NonNull Uri uri, int width, int height,
+      @NonNull Options options) {
     return new LoadData<>(new ObjectKey(uri), new FilePathFetcher(context, uri));
   }
 
   @Override
-  public boolean handles(Uri uri) {
+  public boolean handles(@NonNull Uri uri) {
     return MediaStoreUtil.isMediaStoreUri(uri);
   }
 
@@ -50,7 +53,7 @@ public boolean handles(Uri uri) {
     }
 
     @Override
-    public void loadData(Priority priority, DataCallback<? super File> callback) {
+    public void loadData(@NonNull Priority priority, @NonNull DataCallback<? super File> callback) {
       Cursor cursor = context.getContentResolver().query(uri, PROJECTION, null /*selection*/,
           null /*selectionArgs*/, null /*sortOrder*/);
 
@@ -106,6 +109,7 @@ public Factory(Context context) {
       this.context = context;
     }
 
+    @NonNull
     @Override
     public ModelLoader<Uri, File> build(MultiModelLoaderFactory multiFactory) {
       return new MediaStoreFileLoader(context);
diff --git a/library/src/main/java/com/bumptech/glide/load/model/Model.java b/library/src/main/java/com/bumptech/glide/load/model/Model.java
index 616b9f390..b82f75f55 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/Model.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/Model.java
@@ -1,28 +1,30 @@
 package com.bumptech.glide.load.model;
 
+import android.support.annotation.Nullable;
+
 /**
  * An optional interface that models can implement to enhance control over Glide behaviors.
  */
 public interface Model {
 
-    /**
-     * Returns {@code true} if this model produces the same image using the same mechanism
-     * (server, authentication, source etc) as the given model.
-     * <p>
-     * Models must also implement {@link #equals(Object other)} and {@link #hashCode()}
-     * to ensure that caching functions correctly.
-     * If this object returns {@code true} from this method for a given Model,
-     * it must also be equal to and have the same hash code as the given model.
-     * <p>
-     * However, this model may be equal to and have the same hash code as a given model
-     * but still return {@code false} from this method.
-     * This method optionally allows you to differentiate between Models that load the same image
-     * via multiple different means.
-     * For example one Model might load the image from server A and another model might load
-     * the same image from server B.
-     * The models must be equal to each other with the same hash code because they load
-     * the same image. However two requests made with the different models are not exactly the
-     * same because the way the image is loaded will differ.
-     */
-    boolean isEquivalentTo(Object other);
+  /**
+   * Returns {@code true} if this model produces the same image using the same mechanism
+   * (server, authentication, source etc) as the given model.
+   * <p>
+   * Models must also override {@link Object#equals(Object other)} and {@link Object#hashCode()}
+   * to ensure that caching functions correctly.
+   * If this object returns {@code true} from this method for a given Model,
+   * it must also be equal to and have the same hash code as the given model.
+   * <p>
+   * However, this model may be equal to and have the same hash code as a given model
+   * but still return {@code false} from this method.
+   * This method optionally allows you to differentiate between Models that load the same image
+   * via multiple different means.
+   * For example one Model might load the image from server A and another model might load
+   * the same image from server B.
+   * The models must be equal to each other with the same hash code because they load
+   * the same image. However two requests made with the different models are not exactly the
+   * same because the way the image is loaded will differ.
+   */
+  boolean isEquivalentTo(@Nullable Object other);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java b/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java
index a4f10978a..c654de2fc 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java
@@ -1,6 +1,8 @@
 package com.bumptech.glide.load.model;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 import com.bumptech.glide.util.LruCache;
 import com.bumptech.glide.util.Util;
 import java.util.Queue;
@@ -19,14 +21,16 @@
 
   private final LruCache<ModelKey<A>, B> cache;
 
+  // Public API.
+  @SuppressWarnings("unused")
   public ModelCache() {
     this(DEFAULT_SIZE);
   }
 
-  public ModelCache(int size) {
+  public ModelCache(long size) {
     cache = new LruCache<ModelKey<A>, B>(size) {
       @Override
-      protected void onItemEvicted(ModelKey<A> key, B item) {
+      protected void onItemEvicted(@NonNull ModelKey<A> key, @Nullable B item) {
         key.release();
       }
     };
@@ -68,7 +72,7 @@ public void clear() {
     cache.clearMemory();
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static final class ModelKey<A> {
     private static final Queue<ModelKey<?>> KEY_QUEUE = Util.createQueue(0);
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java
index 230551c5d..2ef8de0dc 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.model;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
@@ -46,11 +47,12 @@
     public final List<Key> alternateKeys;
     public final DataFetcher<Data> fetcher;
 
-    public LoadData(Key sourceKey, DataFetcher<Data> fetcher) {
+    public LoadData(@NonNull Key sourceKey, @NonNull DataFetcher<Data> fetcher) {
       this(sourceKey, Collections.<Key>emptyList(), fetcher);
     }
 
-    public LoadData(Key sourceKey, List<Key> alternateKeys, DataFetcher<Data> fetcher) {
+    public LoadData(@NonNull Key sourceKey, @NonNull List<Key> alternateKeys,
+        @NonNull DataFetcher<Data> fetcher) {
       this.sourceKey = Preconditions.checkNotNull(sourceKey);
       this.alternateKeys = Preconditions.checkNotNull(alternateKeys);
       this.fetcher = Preconditions.checkNotNull(fetcher);
@@ -77,7 +79,8 @@ public LoadData(Key sourceKey, List<Key> alternateKeys, DataFetcher<Data> fetche
    *               the resource should be loaded at its original height.
    */
   @Nullable
-  LoadData<Data> buildLoadData(Model model, int width, int height, Options options);
+  LoadData<Data> buildLoadData(@NonNull Model model, int width, int height,
+      @NonNull Options options);
 
   /**
    * Returns true if the given model is a of a recognized type that this loader can probably load.
@@ -89,5 +92,5 @@ public LoadData(Key sourceKey, List<Key> alternateKeys, DataFetcher<Data> fetche
    * results are acceptable. {@link ModelLoader ModelLoaders} that return true from this method may
    * return {@code null} from {@link #buildLoadData(Object, int, int, Options)} </p>
    */
-  boolean handles(Model model);
+  boolean handles(@NonNull Model model);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java
index 19e126019..321077144 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.model;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 
 /**
  * An interface for creating a {@link ModelLoader} for a given model type. Will be retained
@@ -22,7 +23,8 @@
    *                     {@link ModelLoader}s that this factory's {@link ModelLoader} may depend on
    * @return A new {@link ModelLoader}
    */
-  ModelLoader<T, Y> build(MultiModelLoaderFactory multiFactory);
+  @NonNull
+  ModelLoader<T, Y> build(@NonNull MultiModelLoaderFactory multiFactory);
 
   /**
    * A lifecycle method that will be called when this factory is about to replaced.
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java
index 77923f2c4..ef11d7a21 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.load.model;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.support.v4.util.Pools.Pool;
 import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayList;
@@ -12,53 +14,64 @@
  * Maintains an ordered put of {@link ModelLoader}s and the model and data types they handle in
  * order from highest priority to lowest.
  */
+// Hides Model throughout.
+@SuppressWarnings("TypeParameterHidesVisibleType")
 public class ModelLoaderRegistry {
 
   private final MultiModelLoaderFactory multiModelLoaderFactory;
   private final ModelLoaderCache cache = new ModelLoaderCache();
 
-  public ModelLoaderRegistry(Pool<List<Exception>> exceptionListPool) {
-    this(new MultiModelLoaderFactory(exceptionListPool));
+  public ModelLoaderRegistry(@NonNull Pool<List<Throwable>> throwableListPool) {
+    this(new MultiModelLoaderFactory(throwableListPool));
   }
 
-  // Visible for testing.
-  ModelLoaderRegistry(MultiModelLoaderFactory multiModelLoaderFactory) {
+  private ModelLoaderRegistry(@NonNull MultiModelLoaderFactory multiModelLoaderFactory) {
     this.multiModelLoaderFactory = multiModelLoaderFactory;
   }
 
-  public synchronized <Model, Data> void append(Class<Model> modelClass, Class<Data> dataClass,
-      ModelLoaderFactory<Model, Data> factory) {
+  public synchronized <Model, Data> void append(
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<? extends Model, ? extends Data> factory) {
     multiModelLoaderFactory.append(modelClass, dataClass, factory);
     cache.clear();
   }
 
-  public synchronized <Model, Data> void prepend(Class<Model> modelClass, Class<Data> dataClass,
-      ModelLoaderFactory<Model, Data> factory) {
+  public synchronized <Model, Data> void prepend(
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<? extends Model, ? extends Data> factory) {
     multiModelLoaderFactory.prepend(modelClass, dataClass, factory);
     cache.clear();
   }
 
-  public synchronized <Model, Data> void remove(Class<Model> modelClass, Class<Data> dataClass) {
+  public synchronized <Model, Data> void remove(@NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass) {
     tearDown(multiModelLoaderFactory.remove(modelClass, dataClass));
     cache.clear();
   }
 
-  public synchronized <Model, Data> void replace(Class<Model> modelClass, Class<Data> dataClass,
-      ModelLoaderFactory<Model, Data> factory) {
+  public synchronized <Model, Data> void replace(
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<? extends Model, ? extends Data> factory) {
     tearDown(multiModelLoaderFactory.replace(modelClass, dataClass, factory));
     cache.clear();
   }
 
-  private <Model, Data> void tearDown(List<ModelLoaderFactory<Model, Data>> factories) {
-    for (ModelLoaderFactory<?, ?> factory : factories) {
+  private <Model, Data> void tearDown(
+      @NonNull List<ModelLoaderFactory<? extends Model, ? extends Data>> factories) {
+    for (ModelLoaderFactory<? extends Model, ? extends Data> factory : factories) {
       factory.teardown();
     }
   }
 
-  public synchronized <A> List<ModelLoader<A, ?>> getModelLoaders(A model) {
+  @NonNull
+  public synchronized <A> List<ModelLoader<A, ?>> getModelLoaders(@NonNull A model) {
     List<ModelLoader<A, ?>> modelLoaders = getModelLoadersForClass(getClass(model));
     int size = modelLoaders.size();
     List<ModelLoader<A, ?>> filteredLoaders = new ArrayList<>(size);
+    //noinspection ForLoopReplaceableByForEach to improve perf
     for (int i = 0; i < size; i++) {
       ModelLoader<A, ?> loader = modelLoaders.get(i);
       if (loader.handles(model)) {
@@ -68,16 +81,18 @@ public ModelLoaderRegistry(Pool<List<Exception>> exceptionListPool) {
     return filteredLoaders;
   }
 
-  public synchronized <Model, Data> ModelLoader<Model, Data> build(Class<Model> modelClass,
-      Class<Data> dataClass) {
+  public synchronized <Model, Data> ModelLoader<Model, Data> build(@NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass) {
     return multiModelLoaderFactory.build(modelClass, dataClass);
   }
 
-  public synchronized List<Class<?>> getDataClasses(Class<?> modelClass) {
+  @NonNull
+  public synchronized List<Class<?>> getDataClasses(@NonNull Class<?> modelClass) {
     return multiModelLoaderFactory.getDataClasses(modelClass);
   }
 
-  private <A> List<ModelLoader<A, ?>> getModelLoadersForClass(Class<A> modelClass) {
+  @NonNull
+  private <A> List<ModelLoader<A, ?>> getModelLoadersForClass(@NonNull Class<A> modelClass) {
     List<ModelLoader<A, ?>> loaders = cache.get(modelClass);
     if (loaders == null) {
       loaders = Collections.unmodifiableList(multiModelLoaderFactory.build(modelClass));
@@ -86,8 +101,9 @@ public ModelLoaderRegistry(Pool<List<Exception>> exceptionListPool) {
     return loaders;
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
-  private static <A> Class<A> getClass(A model) {
+  private static <A> Class<A> getClass(@NonNull A model) {
     return (Class<A>) model.getClass();
   }
 
@@ -108,6 +124,7 @@ public void clear() {
       }
     }
 
+    @Nullable
     @SuppressWarnings("unchecked")
     public <Model> List<ModelLoader<Model, ?>> get(Class<Model> modelClass) {
       Entry<Model> entry = (Entry<Model>) cachedModelLoaders.get(modelClass);
diff --git a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java
index d18d12e46..443304fcc 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java
@@ -27,20 +27,21 @@
 class MultiModelLoader<Model, Data> implements ModelLoader<Model, Data> {
 
   private final List<ModelLoader<Model, Data>> modelLoaders;
-  private final Pool<List<Exception>> exceptionListPool;
+  private final Pool<List<Throwable>> exceptionListPool;
 
-  MultiModelLoader(List<ModelLoader<Model, Data>> modelLoaders,
-      Pool<List<Exception>> exceptionListPool) {
+  MultiModelLoader(@NonNull List<ModelLoader<Model, Data>> modelLoaders,
+      @NonNull Pool<List<Throwable>> exceptionListPool) {
     this.modelLoaders = modelLoaders;
     this.exceptionListPool = exceptionListPool;
   }
 
   @Override
-  public LoadData<Data> buildLoadData(Model model, int width, int height,
-      Options options) {
+  public LoadData<Data> buildLoadData(@NonNull Model model, int width, int height,
+      @NonNull Options options) {
     Key sourceKey = null;
     int size = modelLoaders.size();
     List<DataFetcher<Data>> fetchers = new ArrayList<>(size);
+    //noinspection ForLoopReplaceableByForEach to improve perf
     for (int i = 0; i < size; i++) {
       ModelLoader<Model, Data> modelLoader = modelLoaders.get(i);
       if (modelLoader.handles(model)) {
@@ -56,7 +57,7 @@
   }
 
   @Override
-  public boolean handles(Model model) {
+  public boolean handles(@NonNull Model model) {
     for (ModelLoader<Model, Data> modelLoader : modelLoaders) {
       if (modelLoader.handles(model)) {
         return true;
@@ -67,39 +68,39 @@ public boolean handles(Model model) {
 
   @Override
   public String toString() {
-    return "MultiModelLoader{" + "modelLoaders=" + Arrays
-        .toString(modelLoaders.toArray(new ModelLoader[modelLoaders.size()])) + '}';
+    return "MultiModelLoader{" + "modelLoaders=" + Arrays.toString(modelLoaders.toArray()) + '}';
   }
 
   static class MultiFetcher<Data> implements DataFetcher<Data>, DataCallback<Data> {
 
     private final List<DataFetcher<Data>> fetchers;
-    private final Pool<List<Exception>> exceptionListPool;
+    private final Pool<List<Throwable>> throwableListPool;
     private int currentIndex;
     private Priority priority;
     private DataCallback<? super Data> callback;
     @Nullable
-    private List<Exception> exceptions;
+    private List<Throwable> exceptions;
 
-    MultiFetcher(List<DataFetcher<Data>> fetchers, Pool<List<Exception>> exceptionListPool) {
-      this.exceptionListPool = exceptionListPool;
+    MultiFetcher(@NonNull List<DataFetcher<Data>> fetchers,
+        @NonNull Pool<List<Throwable>> throwableListPool) {
+      this.throwableListPool = throwableListPool;
       Preconditions.checkNotEmpty(fetchers);
       this.fetchers = fetchers;
       currentIndex = 0;
     }
 
     @Override
-    public void loadData(Priority priority, DataCallback<? super Data> callback) {
+    public void loadData(@NonNull Priority priority, @NonNull DataCallback<? super Data> callback) {
       this.priority = priority;
       this.callback = callback;
-      exceptions = exceptionListPool.acquire();
+      exceptions = throwableListPool.acquire();
       fetchers.get(currentIndex).loadData(priority, this);
     }
 
     @Override
     public void cleanup() {
       if (exceptions != null) {
-        exceptionListPool.release(exceptions);
+        throwableListPool.release(exceptions);
       }
       exceptions = null;
       for (DataFetcher<Data> fetcher : fetchers) {
@@ -127,7 +128,7 @@ public DataSource getDataSource() {
     }
 
     @Override
-    public void onDataReady(Data data) {
+    public void onDataReady(@Nullable Data data) {
       if (data != null) {
         callback.onDataReady(data);
       } else {
@@ -136,8 +137,8 @@ public void onDataReady(Data data) {
     }
 
     @Override
-    public void onLoadFailed(Exception e) {
-      exceptions.add(e);
+    public void onLoadFailed(@NonNull Exception e) {
+      Preconditions.checkNotNull(exceptions).add(e);
       startNextOrFail();
     }
 
@@ -146,6 +147,7 @@ private void startNextOrFail() {
         currentIndex++;
         loadData(priority, callback);
       } else {
+        Preconditions.checkNotNull(exceptions);
         callback.onLoadFailed(new GlideException("Fetch failed", new ArrayList<>(exceptions)));
       }
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java
index 4c63136a5..a286bc09d 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java
@@ -1,6 +1,8 @@
 package com.bumptech.glide.load.model;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 import android.support.v4.util.Pools.Pool;
 import com.bumptech.glide.Registry.NoModelLoaderAvailableException;
 import com.bumptech.glide.load.Options;
@@ -16,51 +18,66 @@
  * Capable of building an {@link ModelLoader} that wraps one or more other {@link ModelLoader}s for
  * a given model and data class.
  */
+// Hides Model throughout.
+@SuppressWarnings("TypeParameterHidesVisibleType")
 public class MultiModelLoaderFactory {
   private static final Factory DEFAULT_FACTORY = new Factory();
   private static final ModelLoader<Object, Object> EMPTY_MODEL_LOADER = new EmptyModelLoader();
   private final List<Entry<?, ?>> entries = new ArrayList<>();
   private final Factory factory;
   private final Set<Entry<?, ?>> alreadyUsedEntries = new HashSet<>();
-  private final Pool<List<Exception>> exceptionListPool;
+  private final Pool<List<Throwable>> throwableListPool;
 
-  public MultiModelLoaderFactory(Pool<List<Exception>> exceptionListPool) {
-    this(exceptionListPool, DEFAULT_FACTORY);
+  public MultiModelLoaderFactory(@NonNull Pool<List<Throwable>> throwableListPool) {
+    this(throwableListPool, DEFAULT_FACTORY);
   }
 
-  // Visible for testing.
-  MultiModelLoaderFactory(Pool<List<Exception>> exceptionListPool,
-      Factory factory) {
-    this.exceptionListPool = exceptionListPool;
+  @VisibleForTesting
+  MultiModelLoaderFactory(@NonNull Pool<List<Throwable>> throwableListPool,
+      @NonNull Factory factory) {
+    this.throwableListPool = throwableListPool;
     this.factory = factory;
   }
 
-  synchronized <Model, Data> void append(Class<Model> modelClass, Class<Data> dataClass,
-      ModelLoaderFactory<Model, Data> factory) {
-    add(modelClass, dataClass, factory, true /*append*/);
+  synchronized <Model, Data> void append(
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<? extends Model, ? extends Data> factory) {
+    add(modelClass, dataClass, factory, /*append=*/ true);
   }
 
-  synchronized <Model, Data> void prepend(Class<Model> modelClass, Class<Data> dataClass,
-      ModelLoaderFactory<Model, Data> factory) {
-    add(modelClass, dataClass, factory, false /*append*/);
+  synchronized <Model, Data> void prepend(
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<? extends Model, ? extends Data> factory) {
+    add(modelClass, dataClass, factory, /*append=*/ false);
   }
 
-  private <Model, Data> void add(Class<Model> modelClass, Class<Data> dataClass,
-      ModelLoaderFactory<Model, Data> factory, boolean append) {
+  private <Model, Data> void add(
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<? extends Model, ? extends Data> factory,
+      boolean append) {
     Entry<Model, Data> entry = new Entry<>(modelClass, dataClass, factory);
     entries.add(append ? entries.size() : 0, entry);
   }
 
-  synchronized <Model, Data> List<ModelLoaderFactory<Model, Data>> replace(Class<Model> modelClass,
-      Class<Data> dataClass, ModelLoaderFactory<Model, Data> factory) {
-    List<ModelLoaderFactory<Model, Data>> removed = remove(modelClass, dataClass);
+  @NonNull
+  synchronized <Model, Data> List<ModelLoaderFactory<? extends Model, ? extends Data>> replace(
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<? extends Model, ? extends Data> factory) {
+    List<ModelLoaderFactory<? extends Model, ? extends Data>> removed =
+        remove(modelClass, dataClass);
     append(modelClass, dataClass, factory);
     return removed;
   }
 
-  synchronized <Model, Data> List<ModelLoaderFactory<Model, Data>> remove(Class<Model> modelClass,
-      Class<Data> dataClass) {
-    List<ModelLoaderFactory<Model, Data>> factories = new ArrayList<>();
+  @NonNull
+  synchronized <Model, Data> List<ModelLoaderFactory<? extends Model, ? extends Data>> remove(
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass) {
+    List<ModelLoaderFactory<? extends Model, ? extends Data>> factories = new ArrayList<>();
     for (Iterator<Entry<?, ?>> iterator = entries.iterator(); iterator.hasNext(); ) {
       Entry<?, ?> entry = iterator.next();
       if (entry.handles(modelClass, dataClass)) {
@@ -71,7 +88,8 @@ public MultiModelLoaderFactory(Pool<List<Exception>> exceptionListPool) {
     return factories;
   }
 
-  synchronized <Model> List<ModelLoader<Model, ?>> build(Class<Model> modelClass) {
+  @NonNull
+  synchronized <Model> List<ModelLoader<Model, ?>> build(@NonNull Class<Model> modelClass) {
     try {
       List<ModelLoader<Model, ?>> loaders = new ArrayList<>();
       for (Entry<?, ?> entry : entries) {
@@ -96,7 +114,8 @@ public MultiModelLoaderFactory(Pool<List<Exception>> exceptionListPool) {
     }
   }
 
-  synchronized List<Class<?>> getDataClasses(Class<?> modelClass) {
+  @NonNull
+  synchronized List<Class<?>> getDataClasses(@NonNull Class<?> modelClass) {
     List<Class<?>> result = new ArrayList<>();
     for (Entry<?, ?> entry : entries) {
       if (!result.contains(entry.dataClass) && entry.handles(modelClass)) {
@@ -106,8 +125,9 @@ public MultiModelLoaderFactory(Pool<List<Exception>> exceptionListPool) {
     return result;
   }
 
-  public synchronized <Model, Data> ModelLoader<Model, Data> build(Class<Model> modelClass,
-      Class<Data> dataClass) {
+  @NonNull
+  public synchronized <Model, Data> ModelLoader<Model, Data> build(@NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass) {
     try {
       List<ModelLoader<Model, Data>> loaders = new ArrayList<>();
       boolean ignoredAnyEntries = false;
@@ -128,7 +148,7 @@ public MultiModelLoaderFactory(Pool<List<Exception>> exceptionListPool) {
         }
       }
       if (loaders.size() > 1) {
-        return factory.build(loaders, exceptionListPool);
+        return factory.build(loaders, throwableListPool);
       } else if (loaders.size() == 1) {
         return loaders.get(0);
       } else {
@@ -147,16 +167,19 @@ public MultiModelLoaderFactory(Pool<List<Exception>> exceptionListPool) {
     }
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
-  private <Model, Data> ModelLoaderFactory<Model, Data> getFactory(Entry<?, ?> entry) {
+  private <Model, Data> ModelLoaderFactory<Model, Data> getFactory(@NonNull Entry<?, ?> entry) {
     return (ModelLoaderFactory<Model, Data>) entry.factory;
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
-  private <Model, Data> ModelLoader<Model, Data> build(Entry<?, ?> entry) {
+  private <Model, Data> ModelLoader<Model, Data> build(@NonNull Entry<?, ?> entry) {
     return (ModelLoader<Model, Data>) Preconditions.checkNotNull(entry.factory.build(this));
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
   private static <Model, Data> ModelLoader<Model, Data> emptyModelLoader() {
     return (ModelLoader<Model, Data>) EMPTY_MODEL_LOADER;
@@ -165,44 +188,48 @@ public MultiModelLoaderFactory(Pool<List<Exception>> exceptionListPool) {
   private static class Entry<Model, Data> {
     private final Class<Model> modelClass;
     @Synthetic final Class<Data> dataClass;
-    @Synthetic final ModelLoaderFactory<Model, Data> factory;
+    @Synthetic final ModelLoaderFactory<? extends Model, ? extends Data> factory;
 
-    public Entry(Class<Model> modelClass, Class<Data> dataClass,
-        ModelLoaderFactory<Model, Data> factory) {
+    public Entry(
+        @NonNull Class<Model> modelClass,
+        @NonNull Class<Data> dataClass,
+        @NonNull ModelLoaderFactory<? extends Model, ? extends Data> factory) {
       this.modelClass = modelClass;
       this.dataClass = dataClass;
       this.factory = factory;
     }
 
-    public boolean handles(Class<?> modelClass, Class<?> dataClass) {
+    public boolean handles(@NonNull Class<?> modelClass, @NonNull Class<?> dataClass) {
       return handles(modelClass) && this.dataClass.isAssignableFrom(dataClass);
     }
 
-    public boolean handles(Class<?> modelClass) {
+    public boolean handles(@NonNull Class<?> modelClass) {
       return this.modelClass.isAssignableFrom(modelClass);
     }
   }
 
   static class Factory {
+    @NonNull
     public <Model, Data> MultiModelLoader<Model, Data> build(
-        List<ModelLoader<Model, Data>> modelLoaders, Pool<List<Exception>> exceptionListPool) {
-      return new MultiModelLoader<>(modelLoaders, exceptionListPool);
+        @NonNull List<ModelLoader<Model, Data>> modelLoaders,
+        @NonNull Pool<List<Throwable>> throwableListPool) {
+      return new MultiModelLoader<>(modelLoaders, throwableListPool);
     }
   }
 
   private static class EmptyModelLoader implements ModelLoader<Object, Object> {
-
     @Synthetic
     EmptyModelLoader() { }
 
     @Nullable
     @Override
-    public LoadData<Object> buildLoadData(Object o, int width, int height, Options options) {
+    public LoadData<Object> buildLoadData(@NonNull Object o, int width, int height,
+        @NonNull Options options) {
       return null;
     }
 
     @Override
-    public boolean handles(Object o) {
+    public boolean handles(@NonNull Object o) {
       return false;
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
index 24fc4b6ef..1abc1fab4 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
@@ -1,9 +1,11 @@
 package com.bumptech.glide.load.model;
 
 import android.content.ContentResolver;
+import android.content.res.AssetFileDescriptor;
 import android.content.res.Resources;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.util.Log;
 import com.bumptech.glide.load.Options;
@@ -20,14 +22,16 @@
   private final ModelLoader<Uri, Data> uriLoader;
   private final Resources resources;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public ResourceLoader(Resources resources, ModelLoader<Uri, Data> uriLoader) {
     this.resources = resources;
     this.uriLoader = uriLoader;
   }
 
   @Override
-  public LoadData<Data> buildLoadData(Integer model, int width, int height, Options options) {
-
+  public LoadData<Data> buildLoadData(@NonNull Integer model, int width, int height,
+      @NonNull Options options) {
     Uri uri = getResourceUri(model);
     return uri == null ? null : uriLoader.buildLoadData(uri, width, height, options);
   }
@@ -48,7 +52,7 @@ private Uri getResourceUri(Integer model) {
   }
 
   @Override
-  public boolean handles(Integer model) {
+  public boolean handles(@NonNull Integer model) {
     // TODO: check that this is in fact a resource id.
     return true;
   }
@@ -64,6 +68,7 @@ public StreamFactory(Resources resources) {
       this.resources = resources;
     }
 
+    @NonNull
     @Override
     public ModelLoader<Integer, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new ResourceLoader<>(resources, multiFactory.build(Uri.class, InputStream.class));
@@ -87,6 +92,7 @@ public FileDescriptorFactory(Resources resources) {
       this.resources = resources;
     }
 
+    @NonNull
     @Override
     public ModelLoader<Integer, ParcelFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
       return new ResourceLoader<>(
@@ -98,4 +104,51 @@ public void teardown() {
       // Do nothing.
     }
   }
+
+  /**
+   * Loads {@link AssetFileDescriptor}s from resource ids.
+   */
+  public static final class AssetFileDescriptorFactory
+      implements ModelLoaderFactory<Integer, AssetFileDescriptor> {
+
+    private final Resources resources;
+
+    public AssetFileDescriptorFactory(Resources resources) {
+      this.resources = resources;
+    }
+
+    @Override
+    public ModelLoader<Integer, AssetFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
+      return new ResourceLoader<>(
+          resources, multiFactory.build(Uri.class, AssetFileDescriptor.class));
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+  }
+
+  /**
+   * Factory for loading resource {@link Uri}s from Android resource ids.
+   */
+  public static class UriFactory implements ModelLoaderFactory<Integer, Uri> {
+
+    private final Resources resources;
+
+    public UriFactory(Resources resources) {
+      this.resources = resources;
+    }
+
+    @NonNull
+    @Override
+    public ModelLoader<Integer, Uri> build(MultiModelLoaderFactory multiFactory) {
+      return new ResourceLoader<>(resources, UnitModelLoader.<Uri>getInstance());
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java
index 28a06ca9e..9fa8a0ec7 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.model;
 
+import android.support.annotation.NonNull;
 import android.util.Log;
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.Options;
@@ -23,7 +24,7 @@ public StreamEncoder(ArrayPool byteArrayPool) {
   }
 
   @Override
-  public boolean encode(InputStream data, File file, Options options) {
+  public boolean encode(@NonNull InputStream data, @NonNull File file, @NonNull Options options) {
     byte[] buffer = byteArrayPool.get(ArrayPool.STANDARD_BUFFER_SIZE_BYTES, byte[].class);
     boolean success = false;
     OutputStream os = null;
@@ -47,7 +48,7 @@ public boolean encode(InputStream data, File file, Options options) {
           // Do nothing.
         }
       }
-      byteArrayPool.put(buffer, byte[].class);
+      byteArrayPool.put(buffer);
     }
     return success;
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java b/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
index 62061cf16..16bb6cfde 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
@@ -1,7 +1,9 @@
 package com.bumptech.glide.load.model;
 
+import android.content.res.AssetFileDescriptor;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.text.TextUtils;
 import com.bumptech.glide.load.Options;
@@ -17,19 +19,21 @@
 public class StringLoader<Data> implements ModelLoader<String, Data> {
   private final ModelLoader<Uri, Data> uriLoader;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public StringLoader(ModelLoader<Uri, Data> uriLoader) {
     this.uriLoader = uriLoader;
   }
 
   @Override
-  public LoadData<Data> buildLoadData(String model, int width, int height,
-      Options options) {
+  public LoadData<Data> buildLoadData(@NonNull String model, int width, int height,
+      @NonNull Options options) {
     Uri uri = parseUri(model);
     return uri == null ? null : uriLoader.buildLoadData(uri, width, height, options);
   }
 
   @Override
-  public boolean handles(String model) {
+  public boolean handles(@NonNull String model) {
     return true;
   }
 
@@ -38,7 +42,8 @@ private static Uri parseUri(String model) {
     Uri uri;
     if (TextUtils.isEmpty(model)) {
       return null;
-    } else if (model.startsWith("/")) {
+    // See https://pmd.github.io/pmd-6.0.0/pmd_rules_java_performance.html#simplifystartswith
+    } else if (model.charAt(0) == '/') {
       uri = toFileUri(model);
     } else {
       uri = Uri.parse(model);
@@ -59,6 +64,7 @@ private static Uri toFileUri(String path) {
    */
   public static class StreamFactory implements ModelLoaderFactory<String, InputStream> {
 
+    @NonNull
     @Override
     public ModelLoader<String, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new StringLoader<>(multiFactory.build(Uri.class, InputStream.class));
@@ -76,6 +82,7 @@ public void teardown() {
   public static class FileDescriptorFactory
       implements ModelLoaderFactory<String, ParcelFileDescriptor> {
 
+    @NonNull
     @Override
     public ModelLoader<String, ParcelFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
       return new StringLoader<>(multiFactory.build(Uri.class, ParcelFileDescriptor.class));
@@ -86,4 +93,21 @@ public void teardown() {
       // Do nothing.
     }
   }
+
+  /**
+   * Loads {@link AssetFileDescriptor}s from Strings.
+   */
+  public static final class AssetFileDescriptorFactory
+      implements ModelLoaderFactory<String, AssetFileDescriptor> {
+
+    @Override
+    public ModelLoader<String, AssetFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
+      return new StringLoader<>(multiFactory.build(Uri.class, AssetFileDescriptor.class));
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
index 8a3eca114..670e86986 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
@@ -14,15 +14,32 @@
  * @param <Model> The type of model that will also be returned as decodable data.
  */
 public class UnitModelLoader<Model> implements ModelLoader<Model, Model> {
+  @SuppressWarnings("deprecation")
+  private static final UnitModelLoader<?> INSTANCE = new UnitModelLoader<>();
+
+  @SuppressWarnings("unchecked")
+  public static <T> UnitModelLoader<T> getInstance() {
+    return (UnitModelLoader<T>) INSTANCE;
+  }
+
+  /**
+   * @deprecated Use {@link #getInstance()} instead.
+   */
+  // Need constructor to document deprecation, will be removed, when constructor is privatized.
+  @SuppressWarnings({"PMD.UnnecessaryConstructor", "DeprecatedIsStillUsed"})
+  @Deprecated
+  public UnitModelLoader() {
+    // Intentionally empty.
+  }
 
   @Override
-  public LoadData<Model> buildLoadData(Model model, int width, int height,
-      Options options) {
+  public LoadData<Model> buildLoadData(@NonNull Model model, int width, int height,
+      @NonNull Options options) {
     return new LoadData<>(new ObjectKey(model), new UnitFetcher<>(model));
   }
 
   @Override
-  public boolean handles(Model model) {
+  public boolean handles(@NonNull Model model) {
     return true;
   }
 
@@ -30,12 +47,13 @@ public boolean handles(Model model) {
 
     private final Model resource;
 
-    public UnitFetcher(Model resource) {
+    UnitFetcher(Model resource) {
       this.resource = resource;
     }
 
     @Override
-    public void loadData(Priority priority, DataCallback<? super Model> callback) {
+    public void loadData(@NonNull Priority priority,
+        @NonNull DataCallback<? super Model> callback) {
       callback.onDataReady(resource);
     }
 
@@ -68,11 +86,29 @@ public DataSource getDataSource() {
    *
    * @param <Model> The type of model that will also be returned as decodable data.
    */
+  // PMD.SingleMethodSingleton false positive: https://github.com/pmd/pmd/issues/816
+  @SuppressWarnings("PMD.SingleMethodSingleton")
   public static class Factory<Model> implements ModelLoaderFactory<Model, Model> {
+    @SuppressWarnings("deprecation")
+    private static final Factory<?> FACTORY = new Factory<>();
 
+    @SuppressWarnings("unchecked")
+    public static <T> Factory<T> getInstance() {
+      return (Factory<T>) FACTORY;
+    }
+
+    /** @deprecated Use {@link #getInstance()} instead. */
+    // Need constructor to document deprecation, will be removed, when constructor is privatized.
+    @SuppressWarnings("PMD.UnnecessaryConstructor")
+    @Deprecated
+    public Factory() {
+      // Intentionally empty.
+    }
+
+    @NonNull
     @Override
     public ModelLoader<Model, Model> build(MultiModelLoaderFactory multiFactory) {
-      return new UnitModelLoader<>();
+      return UnitModelLoader.getInstance();
     }
 
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java
index 26cc3be5f..77a316dd4 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java
@@ -1,9 +1,12 @@
 package com.bumptech.glide.load.model;
 
 import android.content.ContentResolver;
+import android.content.res.AssetFileDescriptor;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.AssetFileDescriptorLocalUriFetcher;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.FileDescriptorLocalUriFetcher;
 import com.bumptech.glide.load.data.StreamLocalUriFetcher;
@@ -35,18 +38,20 @@
 
   private final LocalUriFetcherFactory<Data> factory;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public UriLoader(LocalUriFetcherFactory<Data> factory) {
     this.factory = factory;
   }
 
   @Override
-  public LoadData<Data> buildLoadData(Uri model, int width, int height,
-      Options options) {
+  public LoadData<Data> buildLoadData(@NonNull Uri model, int width, int height,
+      @NonNull Options options) {
     return new LoadData<>(new ObjectKey(model), factory.build(model));
   }
 
   @Override
-  public boolean handles(Uri model) {
+  public boolean handles(@NonNull Uri model) {
     return SCHEMES.contains(model.getScheme());
   }
 
@@ -76,6 +81,7 @@ public StreamFactory(ContentResolver contentResolver) {
       return new StreamLocalUriFetcher(contentResolver, uri);
     }
 
+    @NonNull
     @Override
     public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new UriLoader<>(this);
@@ -90,8 +96,8 @@ public void teardown() {
   /**
    * Loads {@link ParcelFileDescriptor}s from {@link Uri}s.
    */
-  public static class FileDescriptorFactory implements ModelLoaderFactory<Uri,
-      ParcelFileDescriptor>,
+  public static class FileDescriptorFactory
+      implements ModelLoaderFactory<Uri, ParcelFileDescriptor>,
       LocalUriFetcherFactory<ParcelFileDescriptor> {
 
     private final ContentResolver contentResolver;
@@ -105,6 +111,7 @@ public FileDescriptorFactory(ContentResolver contentResolver) {
       return new FileDescriptorLocalUriFetcher(contentResolver, uri);
     }
 
+    @NonNull
     @Override
     public ModelLoader<Uri, ParcelFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
       return new UriLoader<>(this);
@@ -115,4 +122,33 @@ public void teardown() {
       // Do nothing.
     }
   }
+
+  /**
+   * Loads {@link AssetFileDescriptor}s from {@link Uri}s.
+   */
+  public static final class AssetFileDescriptorFactory
+      implements ModelLoaderFactory<Uri, AssetFileDescriptor>,
+      LocalUriFetcherFactory<AssetFileDescriptor> {
+
+    private final ContentResolver contentResolver;
+
+    public AssetFileDescriptorFactory(ContentResolver contentResolver) {
+      this.contentResolver = contentResolver;
+    }
+
+    @Override
+    public ModelLoader<Uri, AssetFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
+      return new UriLoader<>(this);
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+
+    @Override
+    public DataFetcher<AssetFileDescriptor> build(Uri uri) {
+      return new AssetFileDescriptorLocalUriFetcher(contentResolver, uri);
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java
index af2f2459a..f51b8698f 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.model;
 
 import android.net.Uri;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import java.io.InputStream;
 import java.util.Arrays;
@@ -25,18 +26,21 @@
   );
   private final ModelLoader<GlideUrl, Data> urlLoader;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public UrlUriLoader(ModelLoader<GlideUrl, Data> urlLoader) {
     this.urlLoader = urlLoader;
   }
 
   @Override
-  public LoadData<Data> buildLoadData(Uri uri, int width, int height, Options options) {
+  public LoadData<Data> buildLoadData(@NonNull Uri uri, int width, int height,
+      @NonNull Options options) {
     GlideUrl glideUrl = new GlideUrl(uri.toString());
     return urlLoader.buildLoadData(glideUrl, width, height, options);
   }
 
   @Override
-  public boolean handles(Uri uri) {
+  public boolean handles(@NonNull Uri uri) {
     return SCHEMES.contains(uri.getScheme());
   }
 
@@ -46,6 +50,7 @@ public boolean handles(Uri uri) {
    */
   public static class StreamFactory implements ModelLoaderFactory<Uri, InputStream> {
 
+    @NonNull
     @Override
     public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new UrlUriLoader<>(multiFactory.build(GlideUrl.class, InputStream.class));
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java
index d2944e47e..20c765776 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.model.stream;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.text.TextUtils;
 import com.bumptech.glide.load.Key;
@@ -10,6 +11,7 @@
 import com.bumptech.glide.load.model.ModelLoader;
 import java.io.InputStream;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
 
@@ -35,7 +37,8 @@ protected BaseGlideUrlLoader(ModelLoader<GlideUrl, InputStream> concreteLoader,
 
   @Override
   @Nullable
-  public LoadData<InputStream> buildLoadData(Model model, int width, int height, Options options) {
+  public LoadData<InputStream> buildLoadData(@NonNull Model model, int width, int height,
+      @NonNull Options options) {
     GlideUrl result = null;
     if (modelCache != null) {
       result = modelCache.get(model, width, height);
@@ -59,7 +62,7 @@ protected BaseGlideUrlLoader(ModelLoader<GlideUrl, InputStream> concreteLoader,
     List<String> alternateUrls = getAlternateUrls(model, width, height, options);
     LoadData<InputStream> concreteLoaderData = concreteLoader.buildLoadData(result, width, height,
         options);
-    if (alternateUrls.isEmpty()) {
+    if (concreteLoaderData == null || alternateUrls.isEmpty()) {
       return concreteLoaderData;
     } else {
       return new LoadData<>(concreteLoaderData.sourceKey, getAlternateKeys(alternateUrls),
@@ -67,7 +70,9 @@ protected BaseGlideUrlLoader(ModelLoader<GlideUrl, InputStream> concreteLoader,
     }
   }
 
-  private static List<Key> getAlternateKeys(List<String> alternateUrls) {
+  // Creating a limited number of objects as the sole purpose of the loop.
+  @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")
+  private static List<Key> getAlternateKeys(Collection<String> alternateUrls) {
     List<Key> result = new ArrayList<>(alternateUrls.size());
     for (String alternate : alternateUrls) {
       result.add(new GlideUrl(alternate));
@@ -108,6 +113,8 @@ protected BaseGlideUrlLoader(ModelLoader<GlideUrl, InputStream> concreteLoader,
    * @param width The width in pixels of the view/target the image will be loaded into.
    * @param height The height in pixels of the view/target the image will be loaded into.
    */
+  // Public API.
+  @SuppressWarnings({"unused", "WeakerAccess"})
   @Nullable
   protected Headers getHeaders(Model model, int width, int height, Options options) {
     return Headers.DEFAULT;
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java
index d29625946..e149e1916 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.model.stream;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
@@ -15,6 +16,8 @@
  * An {@link com.bumptech.glide.load.model.ModelLoader} for translating {@link
  * com.bumptech.glide.load.model.GlideUrl} (http/https URLS) into {@link java.io.InputStream} data.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public class HttpGlideUrlLoader implements ModelLoader<GlideUrl, InputStream> {
   /**
    * An integer option that is used to determine the maximum connect and read timeout durations (in
@@ -31,13 +34,13 @@ public HttpGlideUrlLoader() {
     this(null);
   }
 
-  public HttpGlideUrlLoader(ModelCache<GlideUrl, GlideUrl> modelCache) {
+  public HttpGlideUrlLoader(@Nullable ModelCache<GlideUrl, GlideUrl> modelCache) {
     this.modelCache = modelCache;
   }
 
   @Override
-  public LoadData<InputStream> buildLoadData(GlideUrl model, int width, int height,
-      Options options) {
+  public LoadData<InputStream> buildLoadData(@NonNull GlideUrl model, int width, int height,
+      @NonNull Options options) {
     // GlideUrls memoize parsed URLs so caching them saves a few object instantiations and time
     // spent parsing urls.
     GlideUrl url = model;
@@ -53,7 +56,7 @@ public HttpGlideUrlLoader(ModelCache<GlideUrl, GlideUrl> modelCache) {
   }
 
   @Override
-  public boolean handles(GlideUrl model) {
+  public boolean handles(@NonNull GlideUrl model) {
     return true;
   }
 
@@ -63,6 +66,7 @@ public boolean handles(GlideUrl model) {
   public static class Factory implements ModelLoaderFactory<GlideUrl, InputStream> {
     private final ModelCache<GlideUrl, GlideUrl> modelCache = new ModelCache<>(500);
 
+    @NonNull
     @Override
     public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new HttpGlideUrlLoader(modelCache);
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java
index 37b1e12fa..7ff6639b2 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.model.stream;
 
 import android.net.Uri;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
@@ -21,17 +22,20 @@
 
   private final ModelLoader<GlideUrl, InputStream> urlLoader;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public HttpUriLoader(ModelLoader<GlideUrl, InputStream> urlLoader) {
     this.urlLoader = urlLoader;
   }
 
   @Override
-  public LoadData<InputStream> buildLoadData(Uri model, int width, int height, Options options) {
+  public LoadData<InputStream> buildLoadData(@NonNull Uri model, int width, int height,
+      @NonNull Options options) {
     return urlLoader.buildLoadData(new GlideUrl(model.toString()), width, height, options);
   }
 
   @Override
-  public boolean handles(Uri model) {
+  public boolean handles(@NonNull Uri model) {
     return SCHEMES.contains(model.getScheme());
   }
 
@@ -40,6 +44,7 @@ public boolean handles(Uri model) {
    */
   public static class Factory implements ModelLoaderFactory<Uri, InputStream> {
 
+    @NonNull
     @Override
     public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new HttpUriLoader(multiFactory.build(GlideUrl.class, InputStream.class));
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java
index c10cfc90a..aba0fe3cf 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java
@@ -2,6 +2,7 @@
 
 import android.content.Context;
 import android.net.Uri;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.mediastore.MediaStoreUtil;
 import com.bumptech.glide.load.data.mediastore.ThumbFetcher;
@@ -16,14 +17,17 @@
  * thumbnails for those {@link Uri}s in the media store.
  */
 public class MediaStoreImageThumbLoader implements ModelLoader<Uri, InputStream> {
-  public final Context context;
+  private final Context context;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public MediaStoreImageThumbLoader(Context context) {
     this.context = context.getApplicationContext();
   }
 
   @Override
-  public LoadData<InputStream> buildLoadData(Uri model, int width, int height, Options options) {
+  public LoadData<InputStream> buildLoadData(@NonNull Uri model, int width, int height,
+      @NonNull Options options) {
     if (MediaStoreUtil.isThumbnailSize(width, height)) {
       return new LoadData<>(new ObjectKey(model), ThumbFetcher.buildImageFetcher(context, model));
     } else {
@@ -32,7 +36,7 @@ public MediaStoreImageThumbLoader(Context context) {
   }
 
   @Override
-  public boolean handles(Uri model) {
+  public boolean handles(@NonNull Uri model) {
     return MediaStoreUtil.isMediaStoreImageUri(model);
   }
 
@@ -47,6 +51,7 @@ public Factory(Context context) {
       this.context = context;
     }
 
+    @NonNull
     @Override
     public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new MediaStoreImageThumbLoader(context);
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java
index 2263f1cc5..0685decb1 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java
@@ -2,6 +2,7 @@
 
 import android.content.Context;
 import android.net.Uri;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.mediastore.MediaStoreUtil;
@@ -9,7 +10,7 @@
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoaderFactory;
 import com.bumptech.glide.load.model.MultiModelLoaderFactory;
-import com.bumptech.glide.load.resource.bitmap.VideoBitmapDecoder;
+import com.bumptech.glide.load.resource.bitmap.VideoDecoder;
 import com.bumptech.glide.signature.ObjectKey;
 import java.io.InputStream;
 
@@ -17,23 +18,25 @@
  * Loads {@link InputStream}s from media store video {@link Uri}s that point to pre-generated
  * thumbnails for those {@link Uri}s in the media store.
  *
- * <p>If {@link VideoBitmapDecoder#TARGET_FRAME} is set with a non-null value that is not equal to
- * {@link VideoBitmapDecoder#DEFAULT_FRAME}, this loader will always return {@code null}. The media
+ * <p>If {@link VideoDecoder#TARGET_FRAME} is set with a non-null value that is not equal to
+ * {@link VideoDecoder#DEFAULT_FRAME}, this loader will always return {@code null}. The media
  * store does not use a defined frame to generate the thumbnail, so we cannot accurately fulfill
  * requests for specific frames.
  */
 public class MediaStoreVideoThumbLoader implements ModelLoader<Uri, InputStream> {
   private final Context context;
 
-  MediaStoreVideoThumbLoader(Context context) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public MediaStoreVideoThumbLoader(Context context) {
     this.context = context.getApplicationContext();
   }
 
   @Override
   @Nullable
-  public LoadData<InputStream> buildLoadData(Uri model, int width, int height, Options options) {
+  public LoadData<InputStream> buildLoadData(@NonNull Uri model, int width, int height,
+      @NonNull Options options) {
     if (MediaStoreUtil.isThumbnailSize(width, height) && isRequestingDefaultFrame(options)) {
-      // TODO(nnaze): Tighten down this call to just the dependencies neede by buildVideoFetcher
       return new LoadData<>(new ObjectKey(model), ThumbFetcher.buildVideoFetcher(context, model));
     } else {
       return null;
@@ -41,12 +44,12 @@
   }
 
   private boolean isRequestingDefaultFrame(Options options) {
-    Long specifiedFrame = options.get(VideoBitmapDecoder.TARGET_FRAME);
-    return specifiedFrame != null && specifiedFrame == VideoBitmapDecoder.DEFAULT_FRAME;
+    Long specifiedFrame = options.get(VideoDecoder.TARGET_FRAME);
+    return specifiedFrame != null && specifiedFrame == VideoDecoder.DEFAULT_FRAME;
   }
 
   @Override
-  public boolean handles(Uri model) {
+  public boolean handles(@NonNull Uri model) {
     return MediaStoreUtil.isMediaStoreVideoUri(model);
   }
 
@@ -62,6 +65,7 @@ public Factory(Context context) {
       this.context = context;
     }
 
+    @NonNull
     @Override
     public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new MediaStoreVideoThumbLoader(context);
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java
index 1dc7951d4..c3995affa 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.model.stream;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
@@ -17,17 +18,20 @@
 public class UrlLoader implements ModelLoader<URL, InputStream> {
   private final ModelLoader<GlideUrl, InputStream> glideUrlLoader;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public UrlLoader(ModelLoader<GlideUrl, InputStream> glideUrlLoader) {
     this.glideUrlLoader = glideUrlLoader;
   }
 
   @Override
-  public LoadData<InputStream> buildLoadData(URL model, int width, int height, Options options) {
+  public LoadData<InputStream> buildLoadData(@NonNull URL model, int width, int height,
+      @NonNull Options options) {
     return glideUrlLoader.buildLoadData(new GlideUrl(model), width, height, options);
   }
 
   @Override
-  public boolean handles(URL model) {
+  public boolean handles(@NonNull URL model) {
     return true;
   }
 
@@ -36,6 +40,7 @@ public boolean handles(URL model) {
    */
   public static class StreamFactory implements ModelLoaderFactory<URL, InputStream> {
 
+    @NonNull
     @Override
     public ModelLoader<URL, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new UrlLoader(multiFactory.build(GlideUrl.class, InputStream.class));
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/SimpleResource.java b/library/src/main/java/com/bumptech/glide/load/resource/SimpleResource.java
index 5291061e0..9b6c8e465 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/SimpleResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/SimpleResource.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.resource;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.util.Preconditions;
 
@@ -14,16 +15,18 @@
 public class SimpleResource<T> implements Resource<T> {
   protected final T data;
 
-  public SimpleResource(T data) {
+  public SimpleResource(@NonNull T data) {
     this.data = Preconditions.checkNotNull(data);
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
   @Override
   public Class<T> getResourceClass() {
     return (Class<T>) data.getClass();
   }
 
+  @NonNull
   @Override
   public final T get() {
     return data;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java
index 023e2d978..9602c2564 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java
@@ -1,17 +1,18 @@
 package com.bumptech.glide.load.resource;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import java.security.MessageDigest;
 
 /**
- * A noop Transformation that simply returns the given resource.
+ * A no-op Transformation that simply returns the given resource.
  *
  * @param <T> The type of the resource that will always be returned unmodified.
  */
 public final class UnitTransformation<T> implements Transformation<T> {
-  private static final Transformation<?> TRANSFORMATION = new UnitTransformation<Object>();
+  private static final Transformation<?> TRANSFORMATION = new UnitTransformation<>();
 
   /**
    * Returns a UnitTransformation for the given type.
@@ -19,6 +20,7 @@
    * @param <T> The type of the resource to be transformed.
    */
   @SuppressWarnings("unchecked")
+  @NonNull
   public static <T> UnitTransformation<T> get() {
     return (UnitTransformation<T>) TRANSFORMATION;
   }
@@ -27,13 +29,15 @@ private UnitTransformation() {
     // Only accessible as a singleton.
   }
 
+  @NonNull
   @Override
-  public Resource<T> transform(Context context, Resource<T> resource, int outWidth, int outHeight) {
+  public Resource<T> transform(@NonNull Context context, @NonNull Resource<T> resource,
+      int outWidth, int outHeight) {
     return resource;
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     // Do nothing.
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java
index 5a0f9064d..40a2d4c92 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java
@@ -4,7 +4,7 @@
 import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
-import com.bumptech.glide.Glide;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
@@ -21,32 +21,41 @@
 
   private final ResourceDecoder<DataType, Bitmap> decoder;
   private final Resources resources;
-  private final BitmapPool bitmapPool;
 
+  // Public API.
+  @SuppressWarnings({"unused", "WeakerAccess"})
   public BitmapDrawableDecoder(Context context, ResourceDecoder<DataType, Bitmap> decoder) {
-    this(context.getResources(), Glide.get(context).getBitmapPool(), decoder);
+    this(context.getResources(), decoder);
   }
 
-  public BitmapDrawableDecoder(Resources resources, BitmapPool bitmapPool,
+  /**
+   * @deprecated Use {@link #BitmapDrawableDecoder(Context, ResourceDecoder)}, {@code bitmapPool}
+   * is ignored.
+   */
+  @Deprecated
+  public BitmapDrawableDecoder(
+      Resources resources,
+      @SuppressWarnings("unused") BitmapPool bitmapPool,
       ResourceDecoder<DataType, Bitmap> decoder) {
+    this(resources, decoder);
+  }
+
+  public BitmapDrawableDecoder(
+      @NonNull Resources resources, @NonNull ResourceDecoder<DataType, Bitmap> decoder) {
     this.resources = Preconditions.checkNotNull(resources);
-    this.bitmapPool = Preconditions.checkNotNull(bitmapPool);
     this.decoder = Preconditions.checkNotNull(decoder);
   }
 
   @Override
-  public boolean handles(DataType source, Options options) throws IOException {
+  public boolean handles(@NonNull DataType source, @NonNull Options options) throws IOException {
     return decoder.handles(source, options);
   }
 
   @Override
-  public Resource<BitmapDrawable> decode(DataType source, int width, int height, Options options)
+  public Resource<BitmapDrawable> decode(@NonNull DataType source, int width, int height,
+      @NonNull Options options)
       throws IOException {
     Resource<Bitmap> bitmapResource = decoder.decode(source, width, height, options);
-    if (bitmapResource == null) {
-      return null;
-    }
-
-    return LazyBitmapDrawableResource.obtain(resources, bitmapPool, bitmapResource.get());
+    return LazyBitmapDrawableResource.obtain(resources, bitmapResource);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableEncoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableEncoder.java
index a414e6dd0..a955d9d05 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableEncoder.java
@@ -2,6 +2,7 @@
 
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.EncodeStrategy;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceEncoder;
@@ -23,12 +24,14 @@ public BitmapDrawableEncoder(BitmapPool bitmapPool, ResourceEncoder<Bitmap> enco
   }
 
   @Override
-  public boolean encode(Resource<BitmapDrawable> data, File file, Options options) {
+  public boolean encode(@NonNull Resource<BitmapDrawable> data, @NonNull File file,
+      @NonNull Options options) {
     return encoder.encode(new BitmapResource(data.get().getBitmap(), bitmapPool), file, options);
   }
 
+  @NonNull
   @Override
-  public EncodeStrategy getEncodeStrategy(Options options) {
+  public EncodeStrategy getEncodeStrategy(@NonNull Options options) {
     return encoder.getEncodeStrategy(options);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java
index 989664e20..736c02ea6 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.drawable.BitmapDrawable;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.drawable.DrawableResource;
@@ -20,11 +21,14 @@
     implements Initializable {
   private final BitmapPool bitmapPool;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public BitmapDrawableResource(BitmapDrawable drawable, BitmapPool bitmapPool) {
     super(drawable);
     this.bitmapPool = bitmapPool;
   }
 
+  @NonNull
   @Override
   public Class<BitmapDrawable> getResourceClass() {
     return BitmapDrawable.class;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java
index 299e31d42..a783e616c 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java
@@ -3,7 +3,8 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
-import com.bumptech.glide.Glide;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
@@ -12,13 +13,19 @@
 
 /**
  * Transforms {@link android.graphics.drawable.BitmapDrawable}s.
+ *
+ * @deprecated Use {@link DrawableTransformation} instead.
  */
+@Deprecated
 public class BitmapDrawableTransformation implements Transformation<BitmapDrawable> {
 
-  private final Transformation<Bitmap> wrapped;
+  private final Transformation<Drawable> wrapped;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public BitmapDrawableTransformation(Transformation<Bitmap> wrapped) {
-    this.wrapped = Preconditions.checkNotNull(wrapped);
+    this.wrapped =
+        Preconditions.checkNotNull(new DrawableTransformation(wrapped, /*isRequired=*/ false));
   }
 
   /**
@@ -41,25 +48,34 @@ public BitmapDrawableTransformation(
     this(wrapped);
   }
 
+  @NonNull
   @Override
   public Resource<BitmapDrawable> transform(
-      Context context, Resource<BitmapDrawable> drawableResourceToTransform, int outWidth,
-      int outHeight) {
-    BitmapDrawable drawableToTransform = drawableResourceToTransform.get();
-    Bitmap bitmapToTransform = drawableToTransform.getBitmap();
-
-    BitmapPool bitmapPool = Glide.get(context).getBitmapPool();
-    BitmapResource bitmapResourceToTransform = BitmapResource.obtain(bitmapToTransform, bitmapPool);
-    Resource<Bitmap> transformedBitmapResource =
-        wrapped.transform(context, bitmapResourceToTransform, outWidth, outHeight);
+      @NonNull Context context, @NonNull Resource<BitmapDrawable> drawableResourceToTransform,
+      int outWidth, int outHeight) {
+    Resource<Drawable> toTransform = convertToDrawableResource(drawableResourceToTransform);
+    Resource<Drawable> transformed = wrapped.transform(context, toTransform, outWidth, outHeight);
+    return convertToBitmapDrawableResource(transformed);
+  }
 
-    if (transformedBitmapResource.equals(bitmapResourceToTransform)) {
-      return drawableResourceToTransform;
-    } else {
-      return LazyBitmapDrawableResource.obtain(context, transformedBitmapResource.get());
+  @SuppressWarnings("unchecked")
+  private static Resource<BitmapDrawable> convertToBitmapDrawableResource(
+      Resource<Drawable> resource) {
+    if (!(resource.get() instanceof BitmapDrawable)) {
+      throw new IllegalArgumentException(
+          "Wrapped transformation unexpectedly returned a non BitmapDrawable resource: "
+              + resource.get());
     }
+    return (Resource<BitmapDrawable>) (Resource<?>) resource;
+  }
+
+  @SuppressWarnings("unchecked")
+  private static Resource<Drawable> convertToDrawableResource(
+      Resource<BitmapDrawable> toConvert) {
+    return (Resource<Drawable>) (Resource<? extends Drawable>) toConvert;
   }
 
+  @SuppressWarnings("deprecation")
   @Override
   public boolean equals(Object o) {
     if (o instanceof BitmapDrawableTransformation) {
@@ -75,7 +91,7 @@ public int hashCode() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     wrapped.updateDiskCacheKey(messageDigest);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java
index 8a2fdf327..5c949e6e3 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java
@@ -1,13 +1,17 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.support.v4.os.TraceCompat;
 import android.util.Log;
 import com.bumptech.glide.load.EncodeStrategy;
 import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceEncoder;
+import com.bumptech.glide.load.data.BufferedOutputStream;
 import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.util.LogTime;
 import com.bumptech.glide.util.Util;
 import java.io.File;
@@ -48,9 +52,24 @@
       "com.bumptech.glide.load.resource.bitmap.BitmapEncoder.CompressionFormat");
 
   private static final String TAG = "BitmapEncoder";
+  @Nullable
+  private final ArrayPool arrayPool;
+
+  public BitmapEncoder(@NonNull ArrayPool arrayPool) {
+    this.arrayPool = arrayPool;
+  }
+
+  /**
+   * @deprecated Use {@link #BitmapEncoder(ArrayPool)} instead.
+   */
+  @Deprecated
+  public BitmapEncoder() {
+    arrayPool = null;
+  }
 
   @Override
-  public boolean encode(Resource<Bitmap> resource, File file, Options options) {
+  public boolean encode(@NonNull Resource<Bitmap> resource, @NonNull File file,
+      @NonNull Options options) {
     final Bitmap bitmap = resource.get();
     Bitmap.CompressFormat format = getFormat(bitmap, options);
     TraceCompat.beginSection(
@@ -63,6 +82,9 @@ public boolean encode(Resource<Bitmap> resource, File file, Options options) {
       OutputStream os = null;
       try {
         os = new FileOutputStream(file);
+        if (arrayPool != null) {
+          os = new BufferedOutputStream(os, arrayPool);
+        }
         bitmap.compress(format, quality, os);
         os.close();
         success = true;
@@ -103,8 +125,9 @@ public boolean encode(Resource<Bitmap> resource, File file, Options options) {
     }
   }
 
+  @NonNull
   @Override
-  public EncodeStrategy getEncodeStrategy(Options options) {
+  public EncodeStrategy getEncodeStrategy(@NonNull Options options) {
     return EncodeStrategy.TRANSFORMED;
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java
index 102c688c0..49e57a956 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.engine.Resource;
@@ -24,7 +25,7 @@
    * @param bitmapPool A non-null {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool}.
    */
   @Nullable
-  public static BitmapResource obtain(@Nullable Bitmap bitmap, BitmapPool bitmapPool) {
+  public static BitmapResource obtain(@Nullable Bitmap bitmap, @NonNull BitmapPool bitmapPool) {
     if (bitmap == null) {
       return null;
     } else {
@@ -32,16 +33,18 @@ public static BitmapResource obtain(@Nullable Bitmap bitmap, BitmapPool bitmapPo
     }
   }
 
-  public BitmapResource(Bitmap bitmap, BitmapPool bitmapPool) {
+  public BitmapResource(@NonNull Bitmap bitmap, @NonNull BitmapPool bitmapPool) {
     this.bitmap = Preconditions.checkNotNull(bitmap, "Bitmap must not be null");
     this.bitmapPool = Preconditions.checkNotNull(bitmapPool, "BitmapPool must not be null");
   }
 
+  @NonNull
   @Override
   public Class<Bitmap> getResourceClass() {
     return Bitmap.class;
   }
 
+  @NonNull
   @Override
   public Bitmap get() {
     return bitmap;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java
index f204cc54e..8dd0827ba 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java
@@ -9,6 +9,8 @@
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.util.Util;
+import java.nio.charset.Charset;
+import java.security.MessageDigest;
 
 /**
  * A simple {@link com.bumptech.glide.load.Transformation} for transforming
@@ -18,7 +20,7 @@
  * Use cases will look something like this:
  * <pre>
  * <code>
- * public class FillSpace extends BaseBitmapTransformation {
+ * public class FillSpace extends BitmapTransformation {
  *     private static final String ID = "com.bumptech.glide.transformations.FillSpace";
  *     private static final String ID_BYTES = ID.getBytes(STRING_CHARSET_NAME);
  *
@@ -49,26 +51,40 @@
  * }
  * </code>
  * </pre>
+ *
+ * <p>Using the fully qualified class name as a static final {@link String} (not
+ * {@link Class#getName()} to avoid proguard obfuscation) is an easy way to implement
+ * {@link #updateDiskCacheKey(java.security.MessageDigest)}} correctly. If additional arguments are
+ * required they can be passed in to the constructor of the {@code Transformation} and then used to
+ * update the {@link java.security.MessageDigest} passed in to
+ * {@link #updateDiskCacheKey(MessageDigest)}. If arguments are primitive types, they can typically
+ * easily be serialized using {@link java.nio.ByteBuffer}. {@link String} types can be serialized
+ * with {@link String#getBytes(Charset)} using the constant {@link #CHARSET}.
+ *
+ * <p>As with all {@link Transformation}s, all subclasses <em>must</em> implement
+ * {@link #equals(Object)} and {@link #hashCode()} for memory caching to work correctly.
  */
 public abstract class BitmapTransformation implements Transformation<Bitmap> {
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public BitmapTransformation() {
     // Intentionally empty.
   }
 
+  /**
+   * @deprecated Use {@link #BitmapTransformation()}.
+   * @param context Ignored.
+   */
   @Deprecated
   public BitmapTransformation(@SuppressWarnings("unused") Context context) {
     this();
   }
 
-  @Deprecated
-  public BitmapTransformation(@SuppressWarnings("unused") BitmapPool bitmapPool) {
-    this();
-  }
-
+  @NonNull
   @Override
   public final Resource<Bitmap> transform(
-      Context context, Resource<Bitmap> resource, int outWidth, int outHeight) {
+      @NonNull Context context, @NonNull Resource<Bitmap> resource, int outWidth, int outHeight) {
     if (!Util.isValidDimensions(outWidth, outHeight)) {
       throw new IllegalArgumentException(
           "Cannot apply transformation on width: " + outWidth + " or height: " + outHeight
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java
index 61900b789..e5e335bc4 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java
@@ -2,6 +2,7 @@
 
 import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.TransitionOptions;
 import com.bumptech.glide.request.transition.BitmapTransitionFactory;
 import com.bumptech.glide.request.transition.DrawableCrossFadeFactory;
@@ -10,6 +11,8 @@
 /**
  * Contains {@link Bitmap} specific animation options.
  */
+// Public API.
+@SuppressWarnings({"unused", "WeakerAccess"})
 public final class BitmapTransitionOptions extends
     TransitionOptions<BitmapTransitionOptions, Bitmap> {
 
@@ -18,6 +21,7 @@
    *
    * @see #crossFade()
    */
+  @NonNull
   public static BitmapTransitionOptions withCrossFade() {
     return new BitmapTransitionOptions().crossFade();
   }
@@ -27,6 +31,7 @@ public static BitmapTransitionOptions withCrossFade() {
    *
    * @see #crossFade(int)
    */
+  @NonNull
   public static BitmapTransitionOptions withCrossFade(int duration) {
     return new BitmapTransitionOptions().crossFade(duration);
   }
@@ -36,8 +41,9 @@ public static BitmapTransitionOptions withCrossFade(int duration) {
    *
    * @see #crossFade(DrawableCrossFadeFactory)
    */
+  @NonNull
   public static BitmapTransitionOptions withCrossFade(
-      DrawableCrossFadeFactory drawableCrossFadeFactory) {
+      @NonNull DrawableCrossFadeFactory drawableCrossFadeFactory) {
     return new BitmapTransitionOptions().crossFade(drawableCrossFadeFactory);
   }
 
@@ -46,8 +52,9 @@ public static BitmapTransitionOptions withCrossFade(
    *
    * @see #crossFade(DrawableCrossFadeFactory.Builder)
    */
+  @NonNull
   public static BitmapTransitionOptions withCrossFade(
-      DrawableCrossFadeFactory.Builder builder) {
+      @NonNull DrawableCrossFadeFactory.Builder builder) {
     return new BitmapTransitionOptions().crossFade(builder);
   }
 
@@ -57,8 +64,9 @@ public static BitmapTransitionOptions withCrossFade(
    *
    * @see #transitionUsing(TransitionFactory)
    */
+  @NonNull
   public static BitmapTransitionOptions withWrapped(
-      TransitionFactory<Drawable> drawableCrossFadeFactory) {
+      @NonNull TransitionFactory<Drawable> drawableCrossFadeFactory) {
     return new BitmapTransitionOptions().transitionUsing(drawableCrossFadeFactory);
   }
 
@@ -67,8 +75,9 @@ public static BitmapTransitionOptions withWrapped(
    *
    * @see com.bumptech.glide.GenericTransitionOptions#with(TransitionFactory)
    */
+  @NonNull
   public static BitmapTransitionOptions with(
-      TransitionFactory<Bitmap> transitionFactory) {
+      @NonNull TransitionFactory<Bitmap> transitionFactory) {
     return new BitmapTransitionOptions().transition(transitionFactory);
   }
 
@@ -76,6 +85,7 @@ public static BitmapTransitionOptions with(
    * Enables a cross fade animation between both the placeholder and the first resource and between
    * subsequent resources (if thumbnails are used).
    */
+  @NonNull
   public BitmapTransitionOptions crossFade() {
     return crossFade(new DrawableCrossFadeFactory.Builder());
   }
@@ -88,6 +98,7 @@ public BitmapTransitionOptions crossFade() {
    *     {@code DrawableCrossFadeFactory.Builder(int)}.
    * @see com.bumptech.glide.request.transition.DrawableCrossFadeFactory.Builder
    */
+  @NonNull
   public BitmapTransitionOptions crossFade(int duration) {
     return crossFade(new DrawableCrossFadeFactory.Builder(duration));
   }
@@ -96,15 +107,18 @@ public BitmapTransitionOptions crossFade(int duration) {
    * Enables a cross fade animation between both the placeholder and the first resource and between
    * subsequent resources (if thumbnails are used).
    */
-  public BitmapTransitionOptions crossFade(DrawableCrossFadeFactory drawableCrossFadeFactory) {
+  @NonNull
+  public BitmapTransitionOptions crossFade(
+      @NonNull DrawableCrossFadeFactory drawableCrossFadeFactory) {
     return transitionUsing(drawableCrossFadeFactory);
   }
 
   /**
    * Enables a any Drawable based animation to run on Bitmaps as well.
    */
+  @NonNull
   public BitmapTransitionOptions transitionUsing(
-      TransitionFactory<Drawable> drawableCrossFadeFactory) {
+      @NonNull TransitionFactory<Drawable> drawableCrossFadeFactory) {
     return transition(new BitmapTransitionFactory(drawableCrossFadeFactory));
   }
 
@@ -112,7 +126,8 @@ public BitmapTransitionOptions transitionUsing(
    * Enables a cross fade animation between both the placeholder and the first resource and between
    * subsequent resources (if thumbnails are used).
    */
-  public BitmapTransitionOptions crossFade(DrawableCrossFadeFactory.Builder builder) {
+  @NonNull
+  public BitmapTransitionOptions crossFade(@NonNull DrawableCrossFadeFactory.Builder builder) {
     return transitionUsing(builder.build());
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ByteBufferBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ByteBufferBitmapDecoder.java
index 6a6c9ec8f..97084a025 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ByteBufferBitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ByteBufferBitmapDecoder.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
@@ -20,12 +21,13 @@ public ByteBufferBitmapDecoder(Downsampler downsampler) {
   }
 
   @Override
-  public boolean handles(ByteBuffer source, Options options) throws IOException {
+  public boolean handles(@NonNull ByteBuffer source, @NonNull Options options) {
     return downsampler.handles(source);
   }
 
   @Override
-  public Resource<Bitmap> decode(ByteBuffer source, int width, int height, Options options)
+  public Resource<Bitmap> decode(@NonNull ByteBuffer source, int width, int height,
+      @NonNull Options options)
       throws IOException {
     InputStream is = ByteBufferUtil.toStream(source);
     return downsampler.decode(is, width, height, options);
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java
index bdc38562a..da0d1a1ec 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.load.resource.bitmap;
 
-import android.content.Context;
 import android.graphics.Bitmap;
 import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
@@ -17,22 +16,6 @@
   private static final String ID = "com.bumptech.glide.load.resource.bitmap.CenterCrop";
   private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
 
-  public CenterCrop() {
-    // Intentionally empty.
-  }
-
-  @Deprecated
-  public CenterCrop(@SuppressWarnings("unused") Context context) {
-    this();
-  }
-
-  @Deprecated
-  public CenterCrop(@SuppressWarnings("unused") BitmapPool bitmapPool) {
-    this();
-  }
-
-  // Bitmap doesn't implement equals, so == and .equals are equivalent here.
-  @SuppressWarnings("PMD.CompareObjectsWithEquals")
   @Override
   protected Bitmap transform(
       @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {
@@ -50,7 +33,7 @@ public int hashCode() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     messageDigest.update(ID_BYTES);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java
index 6efdbad47..b707b0fc8 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.load.resource.bitmap;
 
-import android.content.Context;
 import android.graphics.Bitmap;
 import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
@@ -17,26 +16,6 @@
   private static final String ID = "com.bumptech.glide.load.resource.bitmap.CenterInside";
   private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
 
-  public CenterInside() {
-    // Intentionally empty.
-  }
-
-  /**
-   * Use {@link #CenterInside()}.
-   */
-  @Deprecated
-  public CenterInside(@SuppressWarnings("unused") Context context) {
-    this();
-  }
-
-  /**
-   * Use {@link #CenterInside()}.
-   */
-  @Deprecated
-  public CenterInside(@SuppressWarnings("unused") BitmapPool bitmapPool) {
-    this();
-  }
-
   @Override
   protected Bitmap transform(
       @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {
@@ -54,7 +33,7 @@ public int hashCode() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     messageDigest.update(ID_BYTES);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java
index 655487175..7d5d5968b 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.load.resource.bitmap;
 
-import android.content.Context;
 import android.graphics.Bitmap;
 import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
@@ -19,26 +18,6 @@
   private static final String ID = "com.bumptech.glide.load.resource.bitmap.CircleCrop." + VERSION;
   private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
 
-  public CircleCrop() {
-    // Intentionally empty.
-  }
-
-  /**
-   * @deprecated Use {@link #CircleCrop()}.
-   */
-  @Deprecated
-  public CircleCrop(@SuppressWarnings("unused") Context context) {
-    this();
-  }
-
-  /**
-   * @deprecated Use {@link #CircleCrop()}
-   */
-  @Deprecated
-  public CircleCrop(@SuppressWarnings("unused") BitmapPool bitmapPool) {
-    this();
-  }
-
   // Bitmap doesn't implement equals, so == and .equals are equivalent here.
   @SuppressWarnings("PMD.CompareObjectsWithEquals")
   @Override
@@ -58,7 +37,7 @@ public int hashCode() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     messageDigest.update(ID_BYTES);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParser.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParser.java
index 5bfe67f8c..a6e7c10cb 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParser.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParser.java
@@ -6,6 +6,7 @@
 import static com.bumptech.glide.load.ImageHeaderParser.ImageType.PNG_A;
 import static com.bumptech.glide.load.ImageHeaderParser.ImageType.UNKNOWN;
 
+import android.support.annotation.NonNull;
 import android.util.Log;
 import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
@@ -31,7 +32,7 @@
   private static final int MOTOROLA_TIFF_MAGIC_NUMBER = 0x4D4D;
   // "II".
   private static final int INTEL_TIFF_MAGIC_NUMBER = 0x4949;
-  static final String JPEG_EXIF_SEGMENT_PREAMBLE = "Exif\0\0";
+  private static final String JPEG_EXIF_SEGMENT_PREAMBLE = "Exif\0\0";
   static final byte[] JPEG_EXIF_SEGMENT_PREAMBLE_BYTES =
       JPEG_EXIF_SEGMENT_PREAMBLE.getBytes(Charset.forName("UTF-8"));
   private static final int SEGMENT_SOS = 0xDA;
@@ -56,37 +57,42 @@
   private static final int WEBP_EXTENDED_ALPHA_FLAG = 1 << 4;
   private static final int WEBP_LOSSLESS_ALPHA_FLAG = 1 << 3;
 
+  @NonNull
   @Override
-  public ImageType getType(InputStream is) throws IOException {
+  public ImageType getType(@NonNull InputStream is) throws IOException {
     return getType(new StreamReader(Preconditions.checkNotNull(is)));
   }
 
+  @NonNull
   @Override
-  public ImageType getType(ByteBuffer byteBuffer) throws IOException {
+  public ImageType getType(@NonNull ByteBuffer byteBuffer) throws IOException {
     return getType(new ByteBufferReader(Preconditions.checkNotNull(byteBuffer)));
   }
 
   @Override
-  public int getOrientation(InputStream is, ArrayPool byteArrayPool) throws IOException {
+  public int getOrientation(@NonNull InputStream is, @NonNull ArrayPool byteArrayPool)
+      throws IOException {
     return getOrientation(new StreamReader(Preconditions.checkNotNull(is)),
         Preconditions.checkNotNull(byteArrayPool));
   }
 
   @Override
-  public int getOrientation(ByteBuffer byteBuffer, ArrayPool byteArrayPool) throws IOException {
+  public int getOrientation(@NonNull ByteBuffer byteBuffer, @NonNull ArrayPool byteArrayPool)
+      throws IOException {
     return getOrientation(new ByteBufferReader(Preconditions.checkNotNull(byteBuffer)),
         Preconditions.checkNotNull(byteArrayPool));
   }
 
+  @NonNull
   private ImageType getType(Reader reader) throws IOException {
-    int firstTwoBytes = reader.getUInt16();
+    final int firstTwoBytes = reader.getUInt16();
 
     // JPEG.
     if (firstTwoBytes == EXIF_MAGIC_NUMBER) {
       return JPEG;
     }
 
-    final int firstFourBytes = firstTwoBytes << 16 & 0xFFFF0000 | reader.getUInt16() & 0xFFFF;
+    final int firstFourBytes = (firstTwoBytes << 16 & 0xFFFF0000) | (reader.getUInt16() & 0xFFFF);
     // PNG.
     if (firstFourBytes == PNG_HEADER) {
       // See: http://stackoverflow.com/questions/2057923/how-to-check-a-png-for-grayscale-alpha
@@ -109,11 +115,13 @@ private ImageType getType(Reader reader) throws IOException {
     }
     // Bytes 4 - 7 contain length information. Skip these.
     reader.skip(4);
-    final int thirdFourBytes = reader.getUInt16() << 16 & 0xFFFF0000 | reader.getUInt16() & 0xFFFF;
+    final int thirdFourBytes =
+        (reader.getUInt16() << 16 & 0xFFFF0000) | (reader.getUInt16() & 0xFFFF);
     if (thirdFourBytes != WEBP_HEADER) {
       return UNKNOWN;
     }
-    final int fourthFourBytes = reader.getUInt16() << 16 & 0xFFFF0000 | reader.getUInt16() & 0xFFFF;
+    final int fourthFourBytes =
+        (reader.getUInt16() << 16 & 0xFFFF0000) | (reader.getUInt16() & 0xFFFF);
     if ((fourthFourBytes & VP8_HEADER_MASK) != VP8_HEADER) {
       return UNKNOWN;
     }
@@ -137,7 +145,6 @@ private ImageType getType(Reader reader) throws IOException {
    *
    * @return The exif orientation if present or -1 if the header couldn't be parsed or doesn't
    * contain an orientation
-   * @throws IOException
    */
   private int getOrientation(Reader reader, ArrayPool byteArrayPool) throws IOException {
     final int magicNumber = reader.getUInt16();
@@ -160,7 +167,7 @@ private int getOrientation(Reader reader, ArrayPool byteArrayPool) throws IOExce
       try {
         return parseExifSegment(reader, exifData, exifSegmentLength);
       } finally {
-        byteArrayPool.put(exifData, byte[].class);
+        byteArrayPool.put(exifData);
       }
     }
   }
@@ -207,10 +214,8 @@ private boolean hasJpegExifPreamble(byte[] exifData, int exifSegmentLength) {
    * {@code -1} if no exif segment is found.
    */
   private int moveToExifSegmentAndGetLength(Reader reader) throws IOException {
-    short segmentId, segmentType;
-    int segmentLength;
     while (true) {
-      segmentId = reader.getUInt8();
+      short segmentId = reader.getUInt8();
       if (segmentId != SEGMENT_START_ID) {
         if (Log.isLoggable(TAG, Log.DEBUG)) {
           Log.d(TAG, "Unknown segmentId=" + segmentId);
@@ -218,8 +223,7 @@ private int moveToExifSegmentAndGetLength(Reader reader) throws IOException {
         return -1;
       }
 
-      segmentType = reader.getUInt8();
-
+      short segmentType = reader.getUInt8();
       if (segmentType == SEGMENT_SOS) {
         return -1;
       } else if (segmentType == MARKER_EOI) {
@@ -230,18 +234,17 @@ private int moveToExifSegmentAndGetLength(Reader reader) throws IOException {
       }
 
       // Segment length includes bytes for segment length.
-      segmentLength = reader.getUInt16() - 2;
-
+      int segmentLength = reader.getUInt16() - 2;
       if (segmentType != EXIF_SEGMENT_TYPE) {
         long skipped = reader.skip(segmentLength);
         if (skipped != segmentLength) {
-            if (Log.isLoggable(TAG, Log.DEBUG)) {
-                Log.d(TAG, "Unable to skip enough data"
-                    + ", type: " + segmentType
-                    + ", wanted to skip: " + segmentLength
-                    + ", but actually skipped: " + skipped);
-            }
-            return -1;
+          if (Log.isLoggable(TAG, Log.DEBUG)) {
+            Log.d(TAG, "Unable to skip enough data"
+                + ", type: " + segmentType
+                + ", wanted to skip: " + segmentLength
+                + ", but actually skipped: " + skipped);
+          }
+          return -1;
         }
       } else {
         return segmentLength;
@@ -254,34 +257,35 @@ private static int parseExifSegment(RandomAccessReader segmentData) {
 
     short byteOrderIdentifier = segmentData.getInt16(headerOffsetSize);
     final ByteOrder byteOrder;
-    if (byteOrderIdentifier == MOTOROLA_TIFF_MAGIC_NUMBER) {
-      byteOrder = ByteOrder.BIG_ENDIAN;
-    } else if (byteOrderIdentifier == INTEL_TIFF_MAGIC_NUMBER) {
-      byteOrder = ByteOrder.LITTLE_ENDIAN;
-    } else {
-      if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "Unknown endianness = " + byteOrderIdentifier);
-      }
-      byteOrder = ByteOrder.BIG_ENDIAN;
+    switch (byteOrderIdentifier) {
+      case MOTOROLA_TIFF_MAGIC_NUMBER:
+        byteOrder = ByteOrder.BIG_ENDIAN;
+        break;
+      case INTEL_TIFF_MAGIC_NUMBER:
+        byteOrder = ByteOrder.LITTLE_ENDIAN;
+        break;
+      default:
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "Unknown endianness = " + byteOrderIdentifier);
+        }
+        byteOrder = ByteOrder.BIG_ENDIAN;
+        break;
     }
 
     segmentData.order(byteOrder);
 
     int firstIfdOffset = segmentData.getInt32(headerOffsetSize + 4) + headerOffsetSize;
     int tagCount = segmentData.getInt16(firstIfdOffset);
-
-    int tagOffset, tagType, formatCode, componentCount;
     for (int i = 0; i < tagCount; i++) {
-      tagOffset = calcTagOffset(firstIfdOffset, i);
-      tagType = segmentData.getInt16(tagOffset);
+      final int tagOffset = calcTagOffset(firstIfdOffset, i);
 
+      final int tagType = segmentData.getInt16(tagOffset);
       // We only want orientation.
       if (tagType != ORIENTATION_TAG_TYPE) {
         continue;
       }
 
-      formatCode = segmentData.getInt16(tagOffset + 2);
-
+      final int formatCode = segmentData.getInt16(tagOffset + 2);
       // 12 is max format code.
       if (formatCode < 1 || formatCode > 12) {
         if (Log.isLoggable(TAG, Log.DEBUG)) {
@@ -290,8 +294,7 @@ private static int parseExifSegment(RandomAccessReader segmentData) {
         continue;
       }
 
-      componentCount = segmentData.getInt32(tagOffset + 4);
-
+      final int componentCount = segmentData.getInt32(tagOffset + 4);
       if (componentCount < 0) {
         if (Log.isLoggable(TAG, Log.DEBUG)) {
           Log.d(TAG, "Negative tiff component count");
@@ -305,7 +308,6 @@ private static int parseExifSegment(RandomAccessReader segmentData) {
       }
 
       final int byteCount = componentCount + BYTES_PER_FORMAT[formatCode];
-
       if (byteCount > 4) {
         if (Log.isLoggable(TAG, Log.DEBUG)) {
           Log.d(TAG, "Got byte count > 4, not orientation, continuing, formatCode=" + formatCode);
@@ -314,7 +316,6 @@ private static int parseExifSegment(RandomAccessReader segmentData) {
       }
 
       final int tagValueOffset = tagOffset + 8;
-
       if (tagValueOffset < 0 || tagValueOffset > segmentData.length()) {
         if (Log.isLoggable(TAG, Log.DEBUG)) {
           Log.d(TAG, "Illegal tagValueOffset=" + tagValueOffset + " tagType=" + tagType);
@@ -394,24 +395,24 @@ private boolean isAvailable(int offset, int byteSize) {
     }
 
     @Override
-    public int getUInt16() throws IOException {
+    public int getUInt16() {
       return (getByte() << 8 & 0xFF00) | (getByte() & 0xFF);
     }
 
     @Override
-    public short getUInt8() throws IOException {
+    public short getUInt8() {
       return (short) (getByte() & 0xFF);
     }
 
     @Override
-    public long skip(long total) throws IOException {
+    public long skip(long total) {
       int toSkip = (int) Math.min(byteBuffer.remaining(), total);
       byteBuffer.position(byteBuffer.position() + toSkip);
       return toSkip;
     }
 
     @Override
-    public int read(byte[] buffer, int byteCount) throws IOException {
+    public int read(byte[] buffer, int byteCount) {
       int toRead = Math.min(byteCount, byteBuffer.remaining());
       if (toRead == 0) {
         return -1;
@@ -421,7 +422,7 @@ public int read(byte[] buffer, int byteCount) throws IOException {
     }
 
     @Override
-    public int getByte() throws IOException {
+    public int getByte() {
       if (byteBuffer.remaining() < 1) {
         return -1;
       }
@@ -431,6 +432,7 @@ public int getByte() throws IOException {
 
   private static final class StreamReader implements Reader {
     private final InputStream is;
+
     // Motorola / big endian byte order.
     StreamReader(InputStream is) {
       this.is = is;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java
index 71548c5e9..c60666adf 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java
@@ -5,6 +5,8 @@
 /**
  * Indicates the algorithm to use when downsampling images.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public abstract class DownsampleStrategy {
 
   /**
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
index 963348f9d..51e9be79a 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
@@ -53,7 +53,7 @@
    */
   public static final Option<DownsampleStrategy> DOWNSAMPLE_STRATEGY =
       Option.memory("com.bumptech.glide.load.resource.bitmap.Downsampler.DownsampleStrategy",
-          DownsampleStrategy.AT_LEAST);
+          DownsampleStrategy.DEFAULT);
   /**
    * Ensure that the size of the bitmap is fixed to the requested width and height of the
    * resource from the caller.  The final resource dimensions may differ from the requested
@@ -64,6 +64,8 @@
    * bitmap for a collection of requested resources so that the bitmap pool will not need to
    * allocate new bitmaps for images of different sizes.
    */
+  // Public API
+  @SuppressWarnings("WeakerAccess")
   public static final Option<Boolean> FIX_BITMAP_SIZE_TO_REQUESTED_DIMENSIONS =
       Option.memory("com.bumptech.glide.load.resource.bitmap.Downsampler.FixBitmapSize", false);
 
@@ -85,8 +87,7 @@
    * <p>This option is ignored unless we're on Android O+.
    */
   public static final Option<Boolean> ALLOW_HARDWARE_CONFIG =
-      Option.memory(
-          "com.bumtpech.glide.load.resource.bitmap.Downsampler.AllowHardwareDecode", null);
+      Option.memory("com.bumtpech.glide.load.resource.bitmap.Downsampler.AllowHardwareDecode");
 
   private static final String WBMP_MIME_TYPE = "image/vnd.wap.wbmp";
   private static final String ICO_MIME_TYPE = "image/x-ico";
@@ -106,7 +107,7 @@ public void onObtainBounds() {
     }
 
     @Override
-    public void onDecodeComplete(BitmapPool bitmapPool, Bitmap downsampled) throws IOException {
+    public void onDecodeComplete(BitmapPool bitmapPool, Bitmap downsampled) {
       // Do nothing.
     }
   };
@@ -122,9 +123,6 @@ public void onDecodeComplete(BitmapPool bitmapPool, Bitmap downsampled) throws I
   // 10MB. This is the max image header size we can handle, we preallocate a much smaller buffer
   // but will resize up to this amount if necessary.
   private static final int MARK_POSITION = 10 * 1024 * 1024;
-  // Defines the level of precision we get when using inDensity/inTargetDensity to calculate an
-  // arbitrary float scale factor.
-  private static final int DENSITY_PRECISION_MULTIPLIER = 1000000000;
 
   private final BitmapPool bitmapPool;
   private final DisplayMetrics displayMetrics;
@@ -140,12 +138,12 @@ public Downsampler(List<ImageHeaderParser> parsers, DisplayMetrics displayMetric
     this.byteArrayPool = Preconditions.checkNotNull(byteArrayPool);
   }
 
-  public boolean handles(InputStream is) {
+  public boolean handles(@SuppressWarnings("unused") InputStream is) {
     // We expect Downsampler to handle any available type Android supports.
     return true;
   }
 
-  public boolean handles(ByteBuffer byteBuffer) {
+  public boolean handles(@SuppressWarnings("unused") ByteBuffer byteBuffer) {
     // We expect downsampler to handle any available type Android supports.
     return true;
   }
@@ -212,7 +210,7 @@ public boolean handles(ByteBuffer byteBuffer) {
       return BitmapResource.obtain(result, bitmapPool);
     } finally {
       releaseOptions(bitmapFactoryOptions);
-      byteArrayPool.put(bytesForOptions, byte[].class);
+      byteArrayPool.put(bytesForOptions);
     }
   }
 
@@ -271,7 +269,8 @@ private Bitmap decodeFromWrappedStreams(InputStream is,
     if ((options.inSampleSize == 1 || isKitKatOrGreater) && shouldUsePool(imageType)) {
       int expectedWidth;
       int expectedHeight;
-      if (fixBitmapToRequestedDimensions && isKitKatOrGreater) {
+      if (sourceWidth >= 0 && sourceHeight >= 0
+          && fixBitmapToRequestedDimensions && isKitKatOrGreater) {
         expectedWidth = targetWidth;
         expectedHeight = targetHeight;
       } else {
@@ -321,8 +320,7 @@ private Bitmap decodeFromWrappedStreams(InputStream is,
     return rotated;
   }
 
-  // Visible for testing.
-  static void calculateScaling(
+  private static void calculateScaling(
       ImageType imageType,
       InputStream is,
       DecodeCallbacks decodeCallbacks,
@@ -336,6 +334,10 @@ static void calculateScaling(
       BitmapFactory.Options options) throws IOException {
     // We can't downsample source content if we can't determine its dimensions.
     if (sourceWidth <= 0 || sourceHeight <= 0) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Unable to determine dimensions for: " + imageType
+            + " with target [" + targetWidth + "x" + targetHeight + "]");
+      }
       return;
     }
 
@@ -441,7 +443,7 @@ static void calculateScaling(
     // densities here so we calculate the final Bitmap size correctly.
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
       options.inTargetDensity = adjustTargetDensityForError(adjustedScaleFactor);
-      options.inDensity = DENSITY_PRECISION_MULTIPLIER;
+      options.inDensity = getDensityMultiplier(adjustedScaleFactor);
     }
     if (isScaling(options)) {
       options.inScaled = true;
@@ -468,19 +470,26 @@ static void calculateScaling(
    * the final scale factor is as close to our target as possible.
    */
   private static int adjustTargetDensityForError(double adjustedScaleFactor) {
-    int targetDensity = round(DENSITY_PRECISION_MULTIPLIER * adjustedScaleFactor);
-    float scaleFactorWithError = targetDensity / (float) DENSITY_PRECISION_MULTIPLIER;
+    int densityMultiplier = getDensityMultiplier(adjustedScaleFactor);
+    int targetDensity = round(densityMultiplier * adjustedScaleFactor);
+    float scaleFactorWithError = targetDensity / (float) densityMultiplier;
     double difference = adjustedScaleFactor / scaleFactorWithError;
     return round(difference * targetDensity);
   }
 
+  private static int getDensityMultiplier(double adjustedScaleFactor) {
+    return (int) Math.round(
+        Integer.MAX_VALUE
+            * (adjustedScaleFactor <= 1D ? adjustedScaleFactor : 1 / adjustedScaleFactor));
+  }
+
   // This is weird, but it matches the logic in a bunch of Android views/framework classes for
   // rounding.
   private static int round(double value) {
     return (int) (value + 0.5d);
   }
 
-  private boolean shouldUsePool(ImageType imageType) throws IOException {
+  private boolean shouldUsePool(ImageType imageType) {
     // On KitKat+, any bitmap (of a given config) can be used to decode any other bitmap
     // (with the same config).
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
@@ -500,8 +509,7 @@ private void calculateConfig(
       boolean isExifOrientationRequired,
       BitmapFactory.Options optionsWithScaling,
       int targetWidth,
-      int targetHeight)
-      throws IOException {
+      int targetHeight) {
 
     if (hardwareConfigState.setHardwareConfigIfAllowed(
         targetWidth,
@@ -533,9 +541,7 @@ private void calculateConfig(
 
     optionsWithScaling.inPreferredConfig =
         hasAlpha ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
-    if (optionsWithScaling.inPreferredConfig == Config.RGB_565
-        || optionsWithScaling.inPreferredConfig == Config.ARGB_4444
-        || optionsWithScaling.inPreferredConfig == Config.ALPHA_8) {
+    if (optionsWithScaling.inPreferredConfig == Config.RGB_565) {
       optionsWithScaling.inDither = true;
     }
   }
@@ -565,7 +571,7 @@ private static Bitmap decodeStream(InputStream is, BitmapFactory.Options options
       // size. To avoid unnecessary allocations reading image data, we fix the mark limit so that it
       // is no larger than our current buffer size here. We need to do so immediately before
       // decoding the full image to avoid having our mark limit overridden by other calls to
-      // markand reset. See issue #225.
+      // mark and reset. See issue #225.
       callbacks.onObtainBounds();
     }
     // BitmapFactory.Options out* variables are reset by most calls to decodeStream, successful or
@@ -657,16 +663,29 @@ private static IOException newIoExceptionForInBitmapAssertion(IllegalArgumentExc
 
   @SuppressWarnings("PMD.CollapsibleIfStatements")
   @TargetApi(Build.VERSION_CODES.O)
-  private static void setInBitmap(BitmapFactory.Options options, BitmapPool bitmapPool, int width,
-      int height) {
+  private static void setInBitmap(
+      BitmapFactory.Options options, BitmapPool bitmapPool, int width, int height) {
+    @Nullable Bitmap.Config expectedConfig = null;
     // Avoid short circuiting, it appears to break on some devices.
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
       if (options.inPreferredConfig == Config.HARDWARE) {
         return;
       }
+      // On API 26 outConfig may be null for some images even if the image is valid, can be decoded
+      // and outWidth/outHeight/outColorSpace are populated (see b/71513049).
+      expectedConfig = options.outConfig;
+    }
+
+    if (expectedConfig == null) {
+      // We're going to guess that BitmapFactory will return us the config we're requesting. This
+      // isn't always the case, even though our guesses tend to be conservative and prefer configs
+      // of larger sizes so that the Bitmap will fit our image anyway. If we're wrong here and the
+      // config we choose is too small, our initial decode will fail, but we will retry with no
+      // inBitmap which will succeed so if we're wrong here, we're less efficient but still correct.
+      expectedConfig = options.inPreferredConfig;
     }
     // BitmapFactory will clear out the Bitmap before writing to it, so getDirty is safe.
-    options.inBitmap = bitmapPool.getDirty(width, height, options.inPreferredConfig);
+    options.inBitmap = bitmapPool.getDirty(width, height, expectedConfig);
   }
 
   private static synchronized BitmapFactory.Options getDefaultOptions() {
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableToBitmapConverter.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableToBitmapConverter.java
new file mode 100644
index 000000000..2ed84484d
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableToBitmapConverter.java
@@ -0,0 +1,79 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.drawable.Animatable;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.Nullable;
+import android.util.Log;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
+import com.bumptech.glide.request.target.Target;
+import java.util.concurrent.locks.Lock;
+
+final class DrawableToBitmapConverter {
+  private static final String TAG = "DrawableToBitmap";
+  private static final BitmapPool NO_RECYCLE_BITMAP_POOL = new BitmapPoolAdapter() {
+    @Override
+    public void put(Bitmap bitmap) {
+      // Avoid calling super to avoid recycling the given Bitmap.
+    }
+  };
+  private DrawableToBitmapConverter() {
+    // Utility class.
+  }
+
+  @Nullable
+  static Resource<Bitmap> convert(BitmapPool bitmapPool, Drawable drawable, int width, int height) {
+    // Handle DrawableContainer or StateListDrawables that may contain one or more BitmapDrawables.
+    drawable = drawable.getCurrent();
+    Bitmap result = null;
+    boolean isRecycleable = false;
+    if (drawable instanceof BitmapDrawable) {
+      result = ((BitmapDrawable) drawable).getBitmap();
+    } else if (!(drawable instanceof Animatable)) {
+      result = drawToBitmap(bitmapPool, drawable, width, height);
+      // We created and drew to the Bitmap, so it's safe for us to recycle or re-use.
+      isRecycleable = true;
+    }
+
+    BitmapPool toUse = isRecycleable ? bitmapPool : NO_RECYCLE_BITMAP_POOL;
+    return BitmapResource.obtain(result, toUse);
+  }
+
+  @Nullable
+  private static Bitmap drawToBitmap(
+      BitmapPool bitmapPool, Drawable drawable, int width, int height) {
+    if (width == Target.SIZE_ORIGINAL && drawable.getIntrinsicWidth() <= 0) {
+      if (Log.isLoggable(TAG, Log.WARN)) {
+        Log.w(TAG, "Unable to draw " + drawable + " to Bitmap with Target.SIZE_ORIGINAL because the"
+            + " Drawable has no intrinsic width");
+      }
+      return null;
+    }
+    if (height == Target.SIZE_ORIGINAL && drawable.getIntrinsicHeight() <= 0) {
+      if (Log.isLoggable(TAG, Log.WARN)) {
+        Log.w(TAG, "Unable to draw " + drawable + " to Bitmap with Target.SIZE_ORIGINAL because the"
+            + " Drawable has no intrinsic height");
+      }
+      return null;
+    }
+    int targetWidth = drawable.getIntrinsicWidth() > 0 ? drawable.getIntrinsicWidth() : width;
+    int targetHeight = drawable.getIntrinsicHeight() > 0 ? drawable.getIntrinsicHeight() : height;
+
+    Lock lock = TransformationUtils.getBitmapDrawableLock();
+    lock.lock();
+    Bitmap result = bitmapPool.get(targetWidth, targetHeight, Bitmap.Config.ARGB_8888);
+    try {
+      Canvas canvas = new Canvas(result);
+      drawable.setBounds(0, 0, targetWidth, targetHeight);
+      drawable.draw(canvas);
+      canvas.setBitmap(null);
+    } finally {
+      lock.unlock();
+    }
+    return result;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformation.java
new file mode 100644
index 000000000..dee51f7a2
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformation.java
@@ -0,0 +1,99 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import java.security.MessageDigest;
+
+/**
+ * Applies a {@link Bitmap} {@link Transformation} to {@link Drawable}s by first attempting to
+ * convert the {@link Drawable} to a {@link Bitmap} and then running the {@link Transformation}
+ * on the converted {@link Bitmap}.
+ *
+ * <p>This class is relatively efficient for {@link BitmapDrawable} where the {@link Bitmap} is
+ * readily accessible. For non-{@link Bitmap} based {@link Drawable}s, this class must first try to
+ * draw the {@link Drawable} to a {@link Bitmap} using {@link android.graphics.Canvas}, which is
+ * less efficient. {@link Drawable}s that implement {@link android.graphics.drawable.Animatable}
+ * will fail with an exception. {@link Drawable}s that return <= 0 for
+ * {@link Drawable#getIntrinsicHeight()} and/or {@link Drawable#getIntrinsicWidth()} will fail
+ * with an exception if the requested size is
+ * {@link com.bumptech.glide.request.target.Target#SIZE_ORIGINAL}. {@link Drawable}s without
+ * intrinsic dimensions are drawn using the dimensions provided in
+ * {@link Transformation#transform(Context, Resource, int, int)}. As a result, they may be
+ * transformed incorrectly or in unexpected ways.
+ */
+public class DrawableTransformation implements Transformation<Drawable> {
+
+  private final Transformation<Bitmap> wrapped;
+  private final boolean isRequired;
+
+  public DrawableTransformation(Transformation<Bitmap> wrapped, boolean isRequired) {
+    this.wrapped = wrapped;
+    this.isRequired = isRequired;
+  }
+
+  @SuppressWarnings("unchecked")
+  public Transformation<BitmapDrawable> asBitmapDrawable() {
+    return (Transformation<BitmapDrawable>) (Transformation<?>) this;
+  }
+
+  @NonNull
+  @Override
+  public Resource<Drawable> transform(@NonNull Context context,
+      @NonNull Resource<Drawable> resource, int outWidth, int outHeight) {
+    BitmapPool bitmapPool = Glide.get(context).getBitmapPool();
+    Drawable drawable = resource.get();
+    Resource<Bitmap> bitmapResourceToTransform =
+        DrawableToBitmapConverter.convert(bitmapPool, drawable, outWidth, outHeight);
+    if (bitmapResourceToTransform == null) {
+      if (isRequired) {
+        throw new IllegalArgumentException("Unable to convert " + drawable + " to a Bitmap");
+      } else {
+        return resource;
+      }
+    }
+    Resource<Bitmap> transformedBitmapResource =
+        wrapped.transform(context, bitmapResourceToTransform, outWidth, outHeight);
+
+    if (transformedBitmapResource.equals(bitmapResourceToTransform)) {
+      transformedBitmapResource.recycle();
+      return resource;
+    } else {
+      return newDrawableResource(context, transformedBitmapResource);
+    }
+  }
+
+  // It's clearer to cast the result in a separate line from obtaining it.
+  @SuppressWarnings({"unchecked", "PMD.UnnecessaryLocalBeforeReturn"})
+  private Resource<Drawable> newDrawableResource(
+      Context context, Resource<Bitmap> transformed) {
+    Resource<? extends Drawable> result =
+        LazyBitmapDrawableResource.obtain(context.getResources(), transformed);
+    return (Resource<Drawable>) result;
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (o instanceof DrawableTransformation) {
+      DrawableTransformation other = (DrawableTransformation) o;
+      return wrapped.equals(other.wrapped);
+    }
+    return false;
+  }
+
+  @Override
+  public int hashCode() {
+    return wrapped.hashCode();
+  }
+
+  @Override
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
+    wrapped.updateDiskCacheKey(messageDigest);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java
index c29ef691d..9c2ae89c1 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.load.resource.bitmap;
 
-import android.content.Context;
 import android.graphics.Bitmap;
 import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
@@ -15,26 +14,6 @@
   private static final String ID = "com.bumptech.glide.load.resource.bitmap.FitCenter";
   private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
 
-  public FitCenter() {
-    // Intentionally empty.
-  }
-
-  /**
-   * @deprecated Use {@link #FitCenter()}.
-   */
-  @Deprecated
-  public FitCenter(@SuppressWarnings("unused") Context context) {
-    this();
-  }
-
-  /**
-   * @deprecated Use {@link #FitCenter()}.
-   */
-  @Deprecated
-  public FitCenter(@SuppressWarnings("unused") BitmapPool bitmapPool) {
-    this();
-  }
-
   @Override
   protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,
       int outHeight) {
@@ -52,7 +31,7 @@ public int hashCode() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     messageDigest.update(ID_BYTES);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java
index 412c5cc5b..92855b5ba 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java
@@ -4,61 +4,90 @@
 import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
-import com.bumptech.glide.util.Util;
 
 /**
  * Lazily allocates a {@link android.graphics.drawable.BitmapDrawable} from a given
  * {@link android.graphics.Bitmap} on the first call to {@link #get()}.
  */
-public class LazyBitmapDrawableResource implements Resource<BitmapDrawable>,
+public final class LazyBitmapDrawableResource implements Resource<BitmapDrawable>,
     Initializable {
 
-  private final Bitmap bitmap;
   private final Resources resources;
-  private final BitmapPool bitmapPool;
+  private final Resource<Bitmap> bitmapResource;
 
+  /**
+   * @deprecated Use {@link #obtain(Resources, Resource)} instead, it can be unsafe to extract
+   * {@link Bitmap}s from their wrapped {@link Resource}.
+   */
+  @Deprecated
   public static LazyBitmapDrawableResource obtain(Context context, Bitmap bitmap) {
-    return obtain(context.getResources(), Glide.get(context).getBitmapPool(), bitmap);
+    return
+        (LazyBitmapDrawableResource)
+            obtain(
+                context.getResources(),
+                BitmapResource.obtain(bitmap, Glide.get(context).getBitmapPool()));
   }
 
+  /**
+   * @deprecated Use {@link #obtain(Resources, Resource)} instead, it can be unsafe to extract
+   * {@link Bitmap}s from their wrapped {@link Resource}.
+   */
+  @Deprecated
   public static LazyBitmapDrawableResource obtain(Resources resources, BitmapPool bitmapPool,
       Bitmap bitmap) {
-    return new LazyBitmapDrawableResource(resources, bitmapPool, bitmap);
+    return
+        (LazyBitmapDrawableResource) obtain(resources, BitmapResource.obtain(bitmap, bitmapPool));
   }
 
-  LazyBitmapDrawableResource(Resources resources, BitmapPool bitmapPool, Bitmap bitmap) {
+  @Nullable
+  public static Resource<BitmapDrawable> obtain(
+      @NonNull Resources resources, @Nullable Resource<Bitmap> bitmapResource) {
+    if (bitmapResource == null) {
+      return null;
+    }
+    return new LazyBitmapDrawableResource(resources, bitmapResource);
+
+  }
+
+  private LazyBitmapDrawableResource(@NonNull Resources resources,
+      @NonNull Resource<Bitmap> bitmapResource) {
     this.resources = Preconditions.checkNotNull(resources);
-    this.bitmapPool = Preconditions.checkNotNull(bitmapPool);
-    this.bitmap = Preconditions.checkNotNull(bitmap);
+    this.bitmapResource = Preconditions.checkNotNull(bitmapResource);
   }
 
+  @NonNull
   @Override
   public Class<BitmapDrawable> getResourceClass() {
     return BitmapDrawable.class;
   }
 
+  @NonNull
   @Override
   public BitmapDrawable get() {
-    return new BitmapDrawable(resources, bitmap);
+    return new BitmapDrawable(resources, bitmapResource.get());
   }
 
   @Override
   public int getSize() {
-    return Util.getBitmapByteSize(bitmap);
+    return bitmapResource.getSize();
   }
 
   @Override
   public void recycle() {
-    bitmapPool.put(bitmap);
+    bitmapResource.recycle();
   }
 
   @Override
   public void initialize() {
-    bitmap.prepareToDraw();
+    if (bitmapResource instanceof Initializable) {
+      ((Initializable) bitmapResource).initialize();
+    }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java
index 24f2f35ef..c8139383f 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java
@@ -17,6 +17,8 @@
  *  limitations under the License.
  */
 
+import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import java.io.FilterInputStream;
 import java.io.IOException;
@@ -63,12 +65,12 @@
   private int pos;
   private final ArrayPool byteArrayPool;
 
-  public RecyclableBufferedInputStream(InputStream in, ArrayPool byteArrayPool) {
+  public RecyclableBufferedInputStream(@NonNull InputStream in, @NonNull ArrayPool byteArrayPool) {
     this(in, byteArrayPool, ArrayPool.STANDARD_BUFFER_SIZE_BYTES);
   }
 
-  // Visible for testing
-  RecyclableBufferedInputStream(InputStream in, ArrayPool byteArrayPool,
+  @VisibleForTesting
+  RecyclableBufferedInputStream(@NonNull InputStream in, @NonNull ArrayPool byteArrayPool,
       int bufferSize) {
     super(in);
     this.byteArrayPool = byteArrayPool;
@@ -104,13 +106,15 @@ private static IOException streamClosed() throws IOException {
    * <p>Subsequent calls to {@link #mark(int)} will be obeyed and may cause the buffer size to
    * increase.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public synchronized void fixMarkLimit() {
     marklimit = buf.length;
   }
 
   public synchronized void release() {
     if (buf != null) {
-      byteArrayPool.put(buf, byte[].class);
+      byteArrayPool.put(buf);
       buf = null;
     }
   }
@@ -124,7 +128,7 @@ public synchronized void release() {
   @Override
   public void close() throws IOException {
     if (buf != null) {
-      byteArrayPool.put(buf, byte[].class);
+      byteArrayPool.put(buf);
       buf = null;
     }
     InputStream localIn = in;
@@ -166,7 +170,7 @@ private int fillbuf(InputStream localIn, byte[] localBuf) throws IOException {
       // Reassign buf, which will invalidate any local references
       // FIXME: what if buf was null?
       localBuf = buf = newbuf;
-      byteArrayPool.put(oldbuf, byte[].class);
+      byteArrayPool.put(oldbuf);
     } else if (markpos > 0) {
       System.arraycopy(localBuf, markpos, localBuf, 0, localBuf.length - markpos);
     }
@@ -266,7 +270,8 @@ public synchronized int read() throws IOException {
    *                                   occurs.
    */
   @Override
-  public synchronized int read(byte[] buffer, int offset, int byteCount) throws IOException {
+  public synchronized int read(@NonNull byte[] buffer, int offset, int byteCount)
+      throws IOException {
     // Use local ref since buf may be invalidated by an unsynchronized close()
     byte[] localBuf = buf;
     if (localBuf == null) {
@@ -356,31 +361,32 @@ public synchronized void reset() throws IOException {
    * Skips {@code byteCount} bytes in this stream. Subsequent calls to {@link #read} will not return
    * these bytes unless {@link #reset} is used.
    *
-   * @param byteCount the number of bytes to skip. {@link #skip} does nothing and returns 0 if
+   * @param byteCount the number of bytes to skip. This method does nothing and returns 0 if
    *                  {@code byteCount} is less than zero.
    * @return the number of bytes actually skipped.
    * @throws IOException if this stream is closed or another IOException occurs.
    */
   @Override
   public synchronized long skip(long byteCount) throws IOException {
+    if (byteCount < 1) {
+      return 0;
+    }
     // Use local refs since buf and in may be invalidated by an unsynchronized close()
     byte[] localBuf = buf;
-    InputStream localIn = in;
     if (localBuf == null) {
       throw streamClosed();
     }
-    if (byteCount < 1) {
-      return 0;
-    }
+    InputStream localIn = in;
     if (localIn == null) {
       throw streamClosed();
     }
 
     if (count - pos >= byteCount) {
-      pos += byteCount;
+      pos = (int) (pos + byteCount);
       return byteCount;
     }
-    long read = count - pos;
+    // See http://errorprone.info/bugpattern/IntLongMath.
+    long read = (long) count - pos;
     pos = count;
 
     if (markpos != -1 && byteCount <= marklimit) {
@@ -388,7 +394,8 @@ public synchronized long skip(long byteCount) throws IOException {
         return read;
       }
       if (count - pos >= byteCount - read) {
-        pos += byteCount - read;
+        // See http://errorprone.info/bugpattern/NarrowingCompoundAssignment.
+        pos = (int) (pos + byteCount - read);
         return byteCount;
       }
       // Couldn't get all the bytes, skip what we read.
@@ -403,10 +410,10 @@ public synchronized long skip(long byteCount) throws IOException {
    * An exception thrown when a mark can no longer be obeyed because the underlying buffer size is
    * smaller than the amount of data read after the mark position.
    */
-  public static class InvalidMarkException extends IOException {
+  static class InvalidMarkException extends IOException {
     private static final long serialVersionUID = -4338378848813561757L;
 
-    public InvalidMarkException(String detailMessage) {
+    InvalidMarkException(String detailMessage) {
       super(detailMessage);
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ResourceBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ResourceBitmapDecoder.java
new file mode 100644
index 000000000..3ef5b5b3e
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ResourceBitmapDecoder.java
@@ -0,0 +1,57 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.content.ContentResolver;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.resource.drawable.ResourceDrawableDecoder;
+import com.bumptech.glide.request.target.Target;
+
+/**
+ * Decodes {@link Bitmap}s from resource ids.
+ *
+ * <p>The framework will decode some resources as {@link Drawable}s that do not wrap
+ * {@link Bitmap}s. This decoder will attempt to return a {@link Bitmap} for those
+ * {@link Drawable}s anyway by drawing the {@link Drawable} to a {@link Canvas}s using
+ * the {@link Drawable}'s intrinsic bounds or the dimensions provided to
+ * {@link #decode(Object, int, int, Options)}.
+ *
+ * <p>For non-{@link Bitmap} {@link Drawable}s that return <= 0 for
+ * {@link Drawable#getIntrinsicWidth()} and/or {@link Drawable#getIntrinsicHeight()}, this
+ * decoder will fail if the width and height provided to {@link #decode(Object, int, int, Options)}
+ * are {@link Target#SIZE_ORIGINAL}.
+ */
+public class ResourceBitmapDecoder implements ResourceDecoder<Uri, Bitmap> {
+
+  private final ResourceDrawableDecoder drawableDecoder;
+  private final BitmapPool bitmapPool;
+
+  public ResourceBitmapDecoder(ResourceDrawableDecoder drawableDecoder, BitmapPool bitmapPool) {
+    this.drawableDecoder = drawableDecoder;
+    this.bitmapPool = bitmapPool;
+  }
+
+  @Override
+  public boolean handles(@NonNull Uri source, @NonNull Options options) {
+    return ContentResolver.SCHEME_ANDROID_RESOURCE.equals(source.getScheme());
+  }
+
+  @Nullable
+  @Override
+  public Resource<Bitmap> decode(@NonNull Uri source, int width, int height,
+      @NonNull Options options) {
+    Resource<Drawable> drawableResource = drawableDecoder.decode(source, width, height, options);
+    if (drawableResource == null) {
+      return null;
+    }
+    Drawable drawable = drawableResource.get();
+    return DrawableToBitmapConverter.convert(bitmapPool, drawable, width, height);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java
index be3e804a2..ae5552152 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java
@@ -1,10 +1,10 @@
 package com.bumptech.glide.load.resource.bitmap;
 
-import android.content.Context;
 import android.graphics.Bitmap;
 import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Util;
 import java.nio.ByteBuffer;
 import java.security.MessageDigest;
 
@@ -26,47 +26,29 @@ public RoundedCorners(int roundingRadius) {
     this.roundingRadius = roundingRadius;
   }
 
-  /**
-   * @param roundingRadius the corner radius (in device-specific pixels).
-   * @throws IllegalArgumentException if rounding radius is 0 or less.
-   *
-   * @deprecated Use {@link #RoundedCorners(int)}
-   */
-  @Deprecated
-  public RoundedCorners(@SuppressWarnings("unused") BitmapPool bitmapPool, int roundingRadius) {
-    this(roundingRadius);
-  }
-
-  /**
-   * @param roundingRadius the corner radius (in device-specific pixels).
-   * @throws IllegalArgumentException if rounding radius is 0 or less.
-   *
-   * @deprecated Use {@link #RoundedCorners(int)}
-   */
-  @Deprecated
-  public RoundedCorners(@SuppressWarnings("unused") Context context, int roundingRadius) {
-    this(roundingRadius);
-  }
-
   @Override
   protected Bitmap transform(
       @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {
-    return TransformationUtils.roundedCorners(pool, toTransform, outWidth, outHeight,
-        roundingRadius);
+    return TransformationUtils.roundedCorners(pool, toTransform, roundingRadius);
   }
 
   @Override
   public boolean equals(Object o) {
-    return (o instanceof RoundedCorners) && ((RoundedCorners) o).roundingRadius == roundingRadius;
+    if (o instanceof RoundedCorners) {
+      RoundedCorners other = (RoundedCorners) o;
+      return roundingRadius == other.roundingRadius;
+    }
+    return false;
   }
 
   @Override
   public int hashCode() {
-    return ID.hashCode() + roundingRadius;
+    return Util.hashCode(ID.hashCode(),
+        Util.hashCode(roundingRadius));
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     messageDigest.update(ID_BYTES);
 
     byte[] radiusData = ByteBuffer.allocate(4).putInt(roundingRadius).array();
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java
index 78ec0ff8b..00cc6f3c1 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
@@ -25,12 +26,13 @@ public StreamBitmapDecoder(Downsampler downsampler, ArrayPool byteArrayPool) {
   }
 
   @Override
-  public boolean handles(InputStream source, Options options) throws IOException {
+  public boolean handles(@NonNull InputStream source, @NonNull Options options) {
     return downsampler.handles(source);
   }
 
   @Override
-  public Resource<Bitmap> decode(InputStream source, int width, int height, Options options)
+  public Resource<Bitmap> decode(@NonNull InputStream source, int width, int height,
+      @NonNull Options options)
       throws IOException {
 
     // Use to fix the mark limit to avoid allocating buffers that fit entire images.
@@ -74,7 +76,7 @@ public boolean handles(InputStream source, Options options) throws IOException {
     private final RecyclableBufferedInputStream bufferedStream;
     private final ExceptionCatchingInputStream exceptionStream;
 
-    public UntrustedCallbacks(RecyclableBufferedInputStream bufferedStream,
+    UntrustedCallbacks(RecyclableBufferedInputStream bufferedStream,
         ExceptionCatchingInputStream exceptionStream) {
       this.bufferedStream = bufferedStream;
       this.exceptionStream = exceptionStream;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
index c81ad3554..1c4d4812c 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
 import android.graphics.BitmapShader;
 import android.graphics.Canvas;
 import android.graphics.Color;
@@ -13,12 +14,15 @@
 import android.media.ExifInterface;
 import android.os.Build;
 import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
 import android.util.Log;
+import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
 import java.util.Arrays;
-import java.util.List;
+import java.util.HashSet;
+import java.util.Set;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.locks.Condition;
 import java.util.concurrent.locks.Lock;
@@ -27,6 +31,8 @@
 /**
  * A class with methods to efficiently resize Bitmaps.
  */
+// Legacy Public APIs.
+@SuppressWarnings("WeakerAccess")
 public final class TransformationUtils {
   private static final String TAG = "TransformationUtils";
   public static final int PAINT_FLAGS = Paint.DITHER_FLAG | Paint.FILTER_BITMAP_FLAG;
@@ -36,19 +42,52 @@
   private static final Paint CIRCLE_CROP_BITMAP_PAINT;
 
   // See #738.
-  private static final List<String> MODELS_REQUIRING_BITMAP_LOCK =
-      Arrays.asList(
-          "XT1097",
-          "XT1085");
+  private static final Set<String> MODELS_REQUIRING_BITMAP_LOCK =
+      new HashSet<>(
+          Arrays.asList(
+              // Moto X gen 2
+              "XT1085",
+              "XT1092",
+              "XT1093",
+              "XT1094",
+              "XT1095",
+              "XT1096",
+              "XT1097",
+              "XT1098",
+              // Moto G gen 1
+              "XT1031",
+              "XT1028",
+              "XT937C",
+              "XT1032",
+              "XT1008",
+              "XT1033",
+              "XT1035",
+              "XT1034",
+              "XT939G",
+              "XT1039",
+              "XT1040",
+              "XT1042",
+              "XT1045",
+              // Moto G gen 2
+              "XT1063",
+              "XT1064",
+              "XT1068",
+              "XT1069",
+              "XT1072",
+              "XT1077",
+              "XT1078",
+              "XT1079"
+          )
+      );
+
   /**
-   * https://github.com/bumptech/glide/issues/738 On some devices (Moto X with android 5.1) bitmap
-   * drawing is not thread safe.
+   * https://github.com/bumptech/glide/issues/738 On some devices, bitmap drawing is not thread
+   * safe.
    * This lock only locks for these specific devices. For other types of devices the lock is always
    * available and therefore does not impact performance
    */
   private static final Lock BITMAP_DRAWABLE_LOCK =
       MODELS_REQUIRING_BITMAP_LOCK.contains(Build.MODEL)
-          && Build.VERSION.SDK_INT == Build.VERSION_CODES.LOLLIPOP_MR1
           ? new ReentrantLock() : new NoLock();
 
   static {
@@ -83,20 +122,23 @@ public static Bitmap centerCrop(@NonNull BitmapPool pool, @NonNull Bitmap inBitm
     }
     // From ImageView/Bitmap.createScaledBitmap.
     final float scale;
-    float dx = 0, dy = 0;
+    final float dx;
+    final float dy;
     Matrix m = new Matrix();
     if (inBitmap.getWidth() * height > width * inBitmap.getHeight()) {
       scale = (float) height / (float) inBitmap.getHeight();
       dx = (width - inBitmap.getWidth() * scale) * 0.5f;
+      dy = 0;
     } else {
       scale = (float) width / (float) inBitmap.getWidth();
+      dx = 0;
       dy = (height - inBitmap.getHeight() * scale) * 0.5f;
     }
 
     m.setScale(scale, scale);
     m.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
 
-    Bitmap result = pool.get(width, height, getSafeConfig(inBitmap));
+    Bitmap result = pool.get(width, height, getNonNullConfig(inBitmap));
     // We don't add or remove alpha, so keep the alpha setting of the Bitmap we were given.
     TransformationUtils.setAlpha(inBitmap, result);
 
@@ -145,7 +187,7 @@ public static Bitmap fitCenter(@NonNull BitmapPool pool, @NonNull Bitmap inBitma
     targetWidth = (int) (minPercentage * inBitmap.getWidth());
     targetHeight = (int) (minPercentage * inBitmap.getHeight());
 
-    Bitmap.Config config = getSafeConfig(inBitmap);
+    Bitmap.Config config = getNonNullConfig(inBitmap);
     Bitmap toReuse = pool.get(targetWidth, targetHeight, config);
 
     // We don't add or remove alpha, so keep the alpha setting of the Bitmap we were given.
@@ -283,7 +325,7 @@ public static Bitmap rotateImageExif(@NonNull BitmapPool pool, @NonNull Bitmap i
     final int newWidth = Math.round(newRect.width());
     final int newHeight = Math.round(newRect.height());
 
-    Bitmap.Config config = getSafeConfig(inBitmap);
+    Bitmap.Config config = getNonNullConfig(inBitmap);
     Bitmap result = pool.get(newWidth, newHeight, config);
 
     matrix.postTranslate(-newRect.left, -newRect.top);
@@ -343,7 +385,8 @@ public static Bitmap circleCrop(@NonNull BitmapPool pool, @NonNull Bitmap inBitm
     // Alpha is required for this transformation.
     Bitmap toTransform = getAlphaSafeBitmap(pool, inBitmap);
 
-    Bitmap result = pool.get(destMinEdge, destMinEdge, Bitmap.Config.ARGB_8888);
+    Bitmap.Config outConfig = getAlphaSafeConfig(inBitmap);
+    Bitmap result = pool.get(destMinEdge, destMinEdge, outConfig);
     result.setHasAlpha(true);
 
     BITMAP_DRAWABLE_LOCK.lock();
@@ -365,14 +408,15 @@ public static Bitmap circleCrop(@NonNull BitmapPool pool, @NonNull Bitmap inBitm
     return result;
   }
 
-  private static Bitmap getAlphaSafeBitmap(@NonNull BitmapPool pool,
-      @NonNull Bitmap maybeAlphaSafe) {
-    if (Bitmap.Config.ARGB_8888.equals(maybeAlphaSafe.getConfig())) {
+  private static Bitmap getAlphaSafeBitmap(
+      @NonNull BitmapPool pool, @NonNull Bitmap maybeAlphaSafe) {
+    Bitmap.Config safeConfig = getAlphaSafeConfig(maybeAlphaSafe);
+    if (safeConfig.equals(maybeAlphaSafe.getConfig())) {
       return maybeAlphaSafe;
     }
 
-    Bitmap argbBitmap = pool.get(maybeAlphaSafe.getWidth(), maybeAlphaSafe.getHeight(),
-        Bitmap.Config.ARGB_8888);
+    Bitmap argbBitmap =
+        pool.get(maybeAlphaSafe.getWidth(), maybeAlphaSafe.getHeight(), safeConfig);
     new Canvas(argbBitmap).drawBitmap(maybeAlphaSafe, 0 /*left*/, 0 /*top*/, null /*paint*/);
 
     // We now own this Bitmap. It's our responsibility to replace it in the pool outside this method
@@ -380,6 +424,18 @@ private static Bitmap getAlphaSafeBitmap(@NonNull BitmapPool pool,
     return argbBitmap;
   }
 
+  @NonNull
+  private static Config getAlphaSafeConfig(@NonNull Bitmap inBitmap) {
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+      // Avoid short circuiting the sdk check.
+      if (Bitmap.Config.RGBA_F16.equals(inBitmap.getConfig())) { // NOPMD
+        return Bitmap.Config.RGBA_F16;
+      }
+    }
+
+    return Bitmap.Config.ARGB_8888;
+  }
+
   /**
    * Creates a bitmap from a source bitmap and rounds the corners.
    *
@@ -389,16 +445,41 @@ private static Bitmap getAlphaSafeBitmap(@NonNull BitmapPool pool,
    * @param roundingRadius the corner radius to be applied (in device-specific pixels).
    * @return a {@link Bitmap} similar to inBitmap but with rounded corners.
    * @throws IllegalArgumentException if roundingRadius, width or height is 0 or less.
+   *
+   * @deprecated Width and height are unused and ignored. Use
+   * {@link #roundedCorners(BitmapPool, Bitmap, int)} instead.
+   */
+  @Deprecated
+  public static Bitmap roundedCorners(
+      @NonNull BitmapPool pool,
+      @NonNull Bitmap inBitmap,
+      @SuppressWarnings("unused") int width,
+      @SuppressWarnings("unused") int height,
+      int roundingRadius) {
+    return roundedCorners(pool, inBitmap, roundingRadius);
+  }
+
+  /**
+   * Creates a bitmap from a source bitmap and rounds the corners.
+   *
+   * <p>This method does <em>NOT</em> resize the given {@link Bitmap}, it only rounds it's corners.
+   * To both resize and round the corners of an image, consider
+   * {@link com.bumptech.glide.request.RequestOptions#transforms(Transformation[])} and/or
+   * {@link com.bumptech.glide.load.MultiTransformation}.
+   *
+   * @param inBitmap the source bitmap to use as a basis for the created bitmap.
+   * @param roundingRadius the corner radius to be applied (in device-specific pixels).
+   * @return a {@link Bitmap} similar to inBitmap but with rounded corners.
+   * @throws IllegalArgumentException if roundingRadius, width or height is 0 or less.
    */
-  public static Bitmap roundedCorners(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap,
-      int width, int height, int roundingRadius) {
-    Preconditions.checkArgument(width > 0, "width must be greater than 0.");
-    Preconditions.checkArgument(height > 0, "height must be greater than 0.");
+  public static Bitmap roundedCorners(
+      @NonNull BitmapPool pool, @NonNull Bitmap inBitmap, int roundingRadius) {
     Preconditions.checkArgument(roundingRadius > 0, "roundingRadius must be greater than 0.");
 
     // Alpha is required for this transformation.
+    Bitmap.Config safeConfig = getAlphaSafeConfig(inBitmap);
     Bitmap toTransform = getAlphaSafeBitmap(pool, inBitmap);
-    Bitmap result = pool.get(width, height, Bitmap.Config.ARGB_8888);
+    Bitmap result = pool.get(toTransform.getWidth(), toTransform.getHeight(), safeConfig);
 
     result.setHasAlpha(true);
 
@@ -430,7 +511,8 @@ private static void clear(Canvas canvas) {
     canvas.setBitmap(null);
   }
 
-  private static Bitmap.Config getSafeConfig(Bitmap bitmap) {
+  @NonNull
+  private static Bitmap.Config getNonNullConfig(@NonNull Bitmap bitmap) {
     return bitmap.getConfig() != null ? bitmap.getConfig() : Bitmap.Config.ARGB_8888;
   }
 
@@ -446,7 +528,7 @@ private static void applyMatrix(@NonNull Bitmap inBitmap, @NonNull Bitmap target
     }
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static void initializeMatrixForRotation(int exifOrientation, Matrix matrix) {
     switch (exifOrientation) {
       case ExifInterface.ORIENTATION_FLIP_HORIZONTAL:
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/UnitBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/UnitBitmapDecoder.java
new file mode 100644
index 000000000..63e804bb1
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/UnitBitmapDecoder.java
@@ -0,0 +1,57 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.util.Util;
+
+/**
+ * Passes through a (hopefully) non-owned {@link Bitmap} as a {@link Bitmap} based {@link Resource}
+ * so that the given {@link Bitmap} is not recycled.
+ */
+public final class UnitBitmapDecoder implements ResourceDecoder<Bitmap, Bitmap> {
+
+  @Override
+  public boolean handles(@NonNull Bitmap source, @NonNull Options options) {
+    return true;
+  }
+
+  @Override
+  public Resource<Bitmap> decode(@NonNull Bitmap source, int width, int height,
+      @NonNull Options options) {
+    return new NonOwnedBitmapResource(source);
+  }
+
+  private static final class NonOwnedBitmapResource implements Resource<Bitmap> {
+
+    private final Bitmap bitmap;
+
+    NonOwnedBitmapResource(@NonNull Bitmap bitmap) {
+      this.bitmap = bitmap;
+    }
+
+    @NonNull
+    @Override
+    public Class<Bitmap> getResourceClass() {
+      return Bitmap.class;
+    }
+
+    @NonNull
+    @Override
+    public Bitmap get() {
+      return bitmap;
+    }
+
+    @Override
+    public int getSize() {
+      return Util.getBitmapByteSize(bitmap);
+    }
+
+    @Override
+    public void recycle() {
+      // Do nothing.
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
index 7be917bf2..226765e2d 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
@@ -1,18 +1,9 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.content.Context;
-import android.graphics.Bitmap;
-import android.media.MediaMetadataRetriever;
 import android.os.ParcelFileDescriptor;
 import com.bumptech.glide.Glide;
-import com.bumptech.glide.load.Option;
-import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.security.MessageDigest;
 
 /**
  * An {@link com.bumptech.glide.load.ResourceDecoder} that can decode a thumbnail frame
@@ -20,128 +11,21 @@
  * video.
  *
  * @see android.media.MediaMetadataRetriever
+ *
+ * @deprecated Use {@link VideoDecoder#parcel(BitmapPool)} instead. This class may be removed and
+ * {@link VideoDecoder} may become final in a future version of Glide.
  */
-public class VideoBitmapDecoder implements ResourceDecoder<ParcelFileDescriptor, Bitmap> {
-  /**
-   * A constant indicating we should use whatever frame we consider best, frequently not the first
-   * frame.
-   */
-  public static final long DEFAULT_FRAME = -1;
-
-  /**
-   * A long indicating the time position (in microseconds) of the target frame which will be
-   * retrieved. {@link android.media.MediaMetadataRetriever#getFrameAtTime(long)} is used to
-   * extract the video frame.
-   *
-   * <p>When retrieving the frame at the given time position, there is no guarantee that the data
-   * source has a frame located at the position. When this happens, a frame nearby will be returned.
-   * If the long is negative, time position and option will ignored, and any frame that the
-   * implementation considers as representative may be returned.
-   */
-  public static final Option<Long> TARGET_FRAME = Option.disk(
-      "com.bumptech.glide.load.resource.bitmap.VideoBitmapDecode.TargetFrame", DEFAULT_FRAME,
-      new Option.CacheKeyUpdater<Long>() {
-        private final ByteBuffer buffer = ByteBuffer.allocate(Long.SIZE / Byte.SIZE);
-        @Override
-        public void update(byte[] keyBytes, Long value, MessageDigest messageDigest) {
-          messageDigest.update(keyBytes);
-          synchronized (buffer) {
-            buffer.position(0);
-            messageDigest.update(buffer.putLong(value).array());
-          }
-        }
-      });
-
-  /**
-   * An integer indicating the frame option used to retrieve a target frame.
-   *
-   * <p>This option will be ignored if {@link #TARGET_FRAME} is not set or is set to
-   * {@link #DEFAULT_FRAME}.
-   *
-   * @see MediaMetadataRetriever#getFrameAtTime(long, int)
-   */
-  public static final Option<Integer> FRAME_OPTION = Option.disk(
-      "com.bumptech.glide.load.resource.bitmap.VideoBitmapDecode.FrameOption",
-      null /*defaultValue*/,
-      new Option.CacheKeyUpdater<Integer>() {
-        private final ByteBuffer buffer = ByteBuffer.allocate(Integer.SIZE / Byte.SIZE);
-        @Override
-        public void update(byte[] keyBytes, Integer value, MessageDigest messageDigest) {
-          if (value == null) {
-            return;
-          }
-          messageDigest.update(keyBytes);
-          synchronized (buffer) {
-            buffer.position(0);
-            messageDigest.update(buffer.putInt(value).array());
-          }
-        }
-      }
-  );
-
-  private static final MediaMetadataRetrieverFactory DEFAULT_FACTORY =
-      new MediaMetadataRetrieverFactory();
-
-  private final BitmapPool bitmapPool;
-  private final MediaMetadataRetrieverFactory factory;
+@Deprecated
+public class VideoBitmapDecoder extends VideoDecoder<ParcelFileDescriptor> {
 
+  @SuppressWarnings("unused")
   public VideoBitmapDecoder(Context context) {
     this(Glide.get(context).getBitmapPool());
   }
 
+  // Public API
+  @SuppressWarnings("WeakerAccess")
   public VideoBitmapDecoder(BitmapPool bitmapPool) {
-    this(bitmapPool, DEFAULT_FACTORY);
-  }
-
-  // Visible for testing.
-  VideoBitmapDecoder(BitmapPool bitmapPool, MediaMetadataRetrieverFactory factory) {
-    this.bitmapPool = bitmapPool;
-    this.factory = factory;
-  }
-
-  @Override
-  public boolean handles(ParcelFileDescriptor data, Options options) {
-    // Calling setDataSource is expensive so avoid doing so unless we're actually called.
-    // For non-videos this isn't any cheaper, but for videos it safes the redundant call and
-    // 50-100ms.
-    return true;
-  }
-
-  @Override
-  public Resource<Bitmap> decode(ParcelFileDescriptor resource, int outWidth, int outHeight,
-      Options options) throws IOException {
-    long frameTimeMicros = options.get(TARGET_FRAME);
-    if (frameTimeMicros < 0 && frameTimeMicros != DEFAULT_FRAME) {
-      throw new IllegalArgumentException(
-          "Requested frame must be non-negative, or DEFAULT_FRAME, given: " + frameTimeMicros);
-    }
-    Integer frameOption = options.get(FRAME_OPTION);
-
-    final Bitmap result;
-    MediaMetadataRetriever mediaMetadataRetriever = factory.build();
-    try {
-      mediaMetadataRetriever.setDataSource(resource.getFileDescriptor());
-      if (frameTimeMicros == DEFAULT_FRAME) {
-        result = mediaMetadataRetriever.getFrameAtTime();
-      } else if (frameOption == null) {
-        result = mediaMetadataRetriever.getFrameAtTime(frameTimeMicros);
-      } else {
-        result = mediaMetadataRetriever.getFrameAtTime(frameTimeMicros, frameOption);
-      }
-    } catch (RuntimeException e) {
-      // MediaMetadataRetriever APIs throw generic runtime exceptions when given invalid data.
-      throw new IOException(e);
-    } finally {
-      mediaMetadataRetriever.release();
-    }
-    resource.close();
-    return BitmapResource.obtain(result, bitmapPool);
-  }
-
-  // Visible for testing.
-  static class MediaMetadataRetrieverFactory {
-    public MediaMetadataRetriever build() {
-      return new MediaMetadataRetriever();
-    }
+    super(bitmapPool, new ParcelFileDescriptorInitializer());
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoDecoder.java
new file mode 100644
index 000000000..509e83e10
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoDecoder.java
@@ -0,0 +1,222 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.annotation.TargetApi;
+import android.content.res.AssetFileDescriptor;
+import android.graphics.Bitmap;
+import android.media.MediaMetadataRetriever;
+import android.os.Build;
+import android.os.Build.VERSION_CODES;
+import android.os.ParcelFileDescriptor;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.request.target.Target;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.security.MessageDigest;
+
+/**
+ * Decodes video data to Bitmaps from {@link ParcelFileDescriptor}s and
+ * {@link AssetFileDescriptor}s.
+ *
+ * @param <T> The type of data, currently either {@link ParcelFileDescriptor} or
+ * {@link AssetFileDescriptor}.
+ */
+public class VideoDecoder<T> implements ResourceDecoder<T, Bitmap> {
+
+  /**
+   * A constant indicating we should use whatever frame we consider best, frequently not the first
+   * frame.
+   */
+  public static final long DEFAULT_FRAME = -1;
+
+  /** Matches the behavior of {@link MediaMetadataRetriever#getFrameAtTime(long)}. */
+  @VisibleForTesting
+  static final int DEFAULT_FRAME_OPTION = MediaMetadataRetriever.OPTION_CLOSEST_SYNC;
+
+  /**
+   * A long indicating the time position (in microseconds) of the target frame which will be
+   * retrieved. {@link android.media.MediaMetadataRetriever#getFrameAtTime(long)} is used to
+   * extract the video frame.
+   *
+   * <p>When retrieving the frame at the given time position, there is no guarantee that the data
+   * source has a frame located at the position. When this happens, a frame nearby will be returned.
+   * If the long is negative, time position and option will ignored, and any frame that the
+   * implementation considers as representative may be returned.
+   */
+  public static final Option<Long> TARGET_FRAME = Option.disk(
+      "com.bumptech.glide.load.resource.bitmap.VideoBitmapDecode.TargetFrame", DEFAULT_FRAME,
+      new Option.CacheKeyUpdater<Long>() {
+        private final ByteBuffer buffer = ByteBuffer.allocate(Long.SIZE / Byte.SIZE);
+
+        @Override
+        public void update(@NonNull byte[] keyBytes, @NonNull Long value,
+            @NonNull MessageDigest messageDigest) {
+          messageDigest.update(keyBytes);
+          synchronized (buffer) {
+            buffer.position(0);
+            messageDigest.update(buffer.putLong(value).array());
+          }
+        }
+      });
+
+  /**
+   * An integer indicating the frame option used to retrieve a target frame.
+   *
+   * <p>This option will be ignored if {@link #TARGET_FRAME} is not set or is set to
+   * {@link #DEFAULT_FRAME}.
+   *
+   * @see MediaMetadataRetriever#getFrameAtTime(long, int)
+   */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public static final Option<Integer> FRAME_OPTION = Option.disk(
+      "com.bumptech.glide.load.resource.bitmap.VideoBitmapDecode.FrameOption",
+      /*defaultValue=*/ MediaMetadataRetriever.OPTION_CLOSEST_SYNC,
+      new Option.CacheKeyUpdater<Integer>() {
+        private final ByteBuffer buffer = ByteBuffer.allocate(Integer.SIZE / Byte.SIZE);
+
+        @Override
+        public void update(@NonNull byte[] keyBytes, @NonNull Integer value,
+            @NonNull MessageDigest messageDigest) {
+          //noinspection ConstantConditions public API, people could have been doing it wrong
+          if (value == null) {
+            return;
+          }
+          messageDigest.update(keyBytes);
+          synchronized (buffer) {
+            buffer.position(0);
+            messageDigest.update(buffer.putInt(value).array());
+          }
+        }
+      }
+  );
+
+  private static final MediaMetadataRetrieverFactory DEFAULT_FACTORY =
+      new MediaMetadataRetrieverFactory();
+
+  private final MediaMetadataRetrieverInitializer<T> initializer;
+  private final BitmapPool bitmapPool;
+  private final MediaMetadataRetrieverFactory factory;
+
+  public static ResourceDecoder<AssetFileDescriptor, Bitmap> asset(BitmapPool bitmapPool) {
+    return new VideoDecoder<>(bitmapPool, new AssetFileDescriptorInitializer());
+  }
+
+  public static ResourceDecoder<ParcelFileDescriptor, Bitmap> parcel(BitmapPool bitmapPool) {
+    return new VideoDecoder<>(bitmapPool, new ParcelFileDescriptorInitializer());
+  }
+
+  VideoDecoder(
+      BitmapPool bitmapPool, MediaMetadataRetrieverInitializer<T> initializer) {
+    this(bitmapPool, initializer, DEFAULT_FACTORY);
+  }
+
+  @VisibleForTesting
+  VideoDecoder(
+      BitmapPool bitmapPool,
+      MediaMetadataRetrieverInitializer<T> initializer,
+      MediaMetadataRetrieverFactory factory) {
+    this.bitmapPool = bitmapPool;
+    this.initializer = initializer;
+    this.factory = factory;
+  }
+
+  @Override
+  public boolean handles(@NonNull T data, @NonNull Options options) {
+    // Calling setDataSource is expensive so avoid doing so unless we're actually called.
+    // For non-videos this isn't any cheaper, but for videos it safes the redundant call and
+    // 50-100ms.
+    return true;
+  }
+
+  @Override
+  public Resource<Bitmap> decode(
+      @NonNull T resource, int outWidth, int outHeight, @NonNull Options options)
+      throws IOException {
+    long frameTimeMicros = options.get(TARGET_FRAME);
+    if (frameTimeMicros < 0 && frameTimeMicros != DEFAULT_FRAME) {
+      throw new IllegalArgumentException(
+          "Requested frame must be non-negative, or DEFAULT_FRAME, given: " + frameTimeMicros);
+    }
+    Integer frameOption = options.get(FRAME_OPTION);
+    if (frameOption == null) {
+      frameOption = DEFAULT_FRAME_OPTION;
+    }
+
+    final Bitmap result;
+    MediaMetadataRetriever mediaMetadataRetriever = factory.build();
+    try {
+      initializer.initialize(mediaMetadataRetriever, resource);
+      result =
+          decodeFrame(mediaMetadataRetriever, frameTimeMicros, frameOption, outWidth, outHeight);
+    } catch (RuntimeException e) {
+      // MediaMetadataRetriever APIs throw generic runtime exceptions when given invalid data.
+      throw new IOException(e);
+    } finally {
+      mediaMetadataRetriever.release();
+    }
+
+    return BitmapResource.obtain(result, bitmapPool);
+  }
+
+  @TargetApi(Build.VERSION_CODES.O_MR1)
+  @Nullable
+  private static Bitmap decodeFrame(
+      MediaMetadataRetriever mediaMetadataRetriever,
+      long frameTimeMicros,
+      int frameOption,
+      int outWidth,
+      int outHeight) {
+    // Arguably we should handle the case where just width or just height is set to
+    // Target.SIZE_ORIGINAL. Up to and including OMR1, MediaMetadataRetriever defaults to setting
+    // the dimensions to the display width and height if they aren't specified (ie
+    // getScaledFrameAtTime is not used). Given that this is an optimization only if
+    // Target.SIZE_ORIGINAL is not used and not using getScaledFrameAtTime ever would match the
+    // behavior of Glide in all versions of Android prior to OMR1, it's probably fine for now.
+    if (Build.VERSION.SDK_INT >= VERSION_CODES.O_MR1
+        && outWidth != Target.SIZE_ORIGINAL
+        && outHeight != Target.SIZE_ORIGINAL) {
+      return mediaMetadataRetriever.getScaledFrameAtTime(
+          frameTimeMicros, frameOption, outWidth, outHeight);
+    } else {
+      return mediaMetadataRetriever.getFrameAtTime(frameTimeMicros, frameOption);
+    }
+  }
+
+  @VisibleForTesting
+  static class MediaMetadataRetrieverFactory {
+    public MediaMetadataRetriever build() {
+      return new MediaMetadataRetriever();
+    }
+  }
+
+  @VisibleForTesting
+  interface MediaMetadataRetrieverInitializer<T> {
+    void initialize(MediaMetadataRetriever retriever, T data);
+  }
+
+  private static final class AssetFileDescriptorInitializer
+      implements MediaMetadataRetrieverInitializer<AssetFileDescriptor> {
+
+    @Override
+    public void initialize(MediaMetadataRetriever retriever, AssetFileDescriptor data) {
+      retriever.setDataSource(data.getFileDescriptor(), data.getStartOffset(), data.getLength());
+    }
+  }
+
+  // Visible for VideoBitmapDecoder.
+  static final class ParcelFileDescriptorInitializer
+      implements MediaMetadataRetrieverInitializer<ParcelFileDescriptor> {
+
+    @Override
+    public void initialize(MediaMetadataRetriever retriever, ParcelFileDescriptor data) {
+      retriever.setDataSource(data.getFileDescriptor());
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bytes/ByteBufferRewinder.java b/library/src/main/java/com/bumptech/glide/load/resource/bytes/ByteBufferRewinder.java
index 41315a302..a154faafb 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bytes/ByteBufferRewinder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bytes/ByteBufferRewinder.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.load.resource.bytes;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.data.DataRewinder;
-import java.io.IOException;
 import java.nio.ByteBuffer;
 
 /**
@@ -10,12 +10,15 @@
 public class ByteBufferRewinder implements DataRewinder<ByteBuffer> {
   private final ByteBuffer buffer;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public ByteBufferRewinder(ByteBuffer buffer) {
     this.buffer = buffer;
   }
 
+  @NonNull
   @Override
-  public ByteBuffer rewindAndGet() throws IOException {
+  public ByteBuffer rewindAndGet() {
     buffer.position(0);
     return buffer;
   }
@@ -30,11 +33,13 @@ public void cleanup() {
    */
   public static class Factory implements DataRewinder.Factory<ByteBuffer> {
 
+    @NonNull
     @Override
     public DataRewinder<ByteBuffer> build(ByteBuffer data) {
       return new ByteBufferRewinder(data);
     }
 
+    @NonNull
     @Override
     public Class<ByteBuffer> getDataClass() {
       return ByteBuffer.class;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bytes/BytesResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bytes/BytesResource.java
index 6b0d7a2be..88068855d 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bytes/BytesResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bytes/BytesResource.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.resource.bytes;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.util.Preconditions;
 
@@ -13,12 +14,24 @@ public BytesResource(byte[] bytes) {
     this.bytes = Preconditions.checkNotNull(bytes);
   }
 
+  @NonNull
   @Override
   public Class<byte[]> getResourceClass() {
     return byte[].class;
   }
 
+  /**
+   * In most cases it will only be retrieved once (see linked methods).
+   *
+   * @return the same array every time, do not mutate the contents. Not a copy returned, because
+   * copying the array can be prohibitively expensive and/or lead to OOMs.
+   * @see com.bumptech.glide.load.ResourceEncoder
+   * @see com.bumptech.glide.load.resource.transcode.ResourceTranscoder
+   * @see com.bumptech.glide.request.SingleRequest#onResourceReady
+   */
+  @NonNull
   @Override
+  @SuppressWarnings("PMD.MethodReturnsInternalArray")
   public byte[] get() {
     return bytes;
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableDecoderCompat.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableDecoderCompat.java
new file mode 100644
index 000000000..2f90275c7
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableDecoderCompat.java
@@ -0,0 +1,62 @@
+package com.bumptech.glide.load.resource.drawable;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.content.res.Resources.Theme;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.Nullable;
+import android.support.v4.content.res.ResourcesCompat;
+import android.support.v7.content.res.AppCompatResources;
+
+/**
+ * Handles decoding Drawables with the v7 support library if present and falling back to the v4
+ * support library otherwise.
+ */
+public final class DrawableDecoderCompat {
+  private static volatile boolean shouldCallAppCompatResources = true;
+  private DrawableDecoderCompat() {
+    // Utility class.
+  }
+
+  /**
+   * See {@code getDrawable(Context, int, Theme)}.
+   */
+  public static Drawable getDrawable(Context context, @DrawableRes int id) {
+    return getDrawable(context, id, /*theme=*/ null);
+  }
+
+  /**
+   * Loads a Drawable using {@link AppCompatResources} if available and {@link ResourcesCompat}
+   * otherwise, depending on whether or not the v7 support library is included in the application.
+   *
+   * @param theme Used instead of the {@link Theme} returned from the given {@link Context} if
+   * non-null when loading the {@link Drawable}.
+   */
+  public static Drawable getDrawable(Context context, @DrawableRes int id, @Nullable Theme theme) {
+    try {
+      // Race conditions may cause us to attempt to load using v7 more than once. That's ok since
+      // this check is a modest optimization and the output will be correct anyway.
+      if (shouldCallAppCompatResources) {
+        return loadDrawableV7(context, id);
+      }
+    } catch (NoClassDefFoundError error) {
+      shouldCallAppCompatResources = false;
+    } catch (Resources.NotFoundException e) {
+      // Ignored, this can be thrown when drawable compat attempts to decode a canary resource. If
+      // that decode attempt fails, we still want to try with the v4 ResourcesCompat below.
+    }
+
+    return loadDrawableV4(context, id, theme != null ? theme : context.getTheme());
+  }
+
+  private static Drawable loadDrawableV7(Context context, @DrawableRes int id) {
+    return AppCompatResources.getDrawable(context, id);
+  }
+
+  private static Drawable loadDrawableV4(
+      Context context, @DrawableRes int id, @Nullable Theme theme) {
+    Resources resources = context.getResources();
+    return ResourcesCompat.getDrawable(resources, id, theme);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java
index 163cbe50a..17b74f2cc 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java
@@ -2,6 +2,9 @@
 
 import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
+import android.graphics.drawable.Drawable.ConstantState;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
@@ -25,14 +28,19 @@ public DrawableResource(T drawable) {
     this.drawable = Preconditions.checkNotNull(drawable);
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
   @Override
   public final T get() {
+    @Nullable ConstantState state = drawable.getConstantState();
+    if (state == null) {
+      return drawable;
+    }
     // Drawables contain temporary state related to how they're being displayed
     // (alpha, color filter etc), so return a new copy each time.
     // If we ever return the original drawable, it's temporary state may be changed
     // and subsequent copies may end up with that temporary state. See #276.
-    return (T) drawable.getConstantState().newDrawable();
+    return (T) state.newDrawable();
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java
index 88eeeaffa..8eec67561 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.drawable;
 
 import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.TransitionOptions;
 import com.bumptech.glide.request.transition.DrawableCrossFadeFactory;
 import com.bumptech.glide.request.transition.TransitionFactory;
@@ -8,6 +9,8 @@
 /**
  * Contains {@link Drawable} specific animation options.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public final class DrawableTransitionOptions extends
     TransitionOptions<DrawableTransitionOptions, Drawable> {
 
@@ -16,6 +19,7 @@
    *
    * @see #crossFade()
    */
+  @NonNull
   public static DrawableTransitionOptions withCrossFade() {
     return new DrawableTransitionOptions().crossFade();
   }
@@ -25,6 +29,7 @@ public static DrawableTransitionOptions withCrossFade() {
    *
    * @see #crossFade(int)
    */
+  @NonNull
   public static DrawableTransitionOptions withCrossFade(int duration) {
     return new DrawableTransitionOptions().crossFade(duration);
   }
@@ -34,8 +39,9 @@ public static DrawableTransitionOptions withCrossFade(int duration) {
    *
    * @see #crossFade(DrawableCrossFadeFactory)
    */
+  @NonNull
   public static DrawableTransitionOptions withCrossFade(
-      DrawableCrossFadeFactory drawableCrossFadeFactory) {
+      @NonNull DrawableCrossFadeFactory drawableCrossFadeFactory) {
     return new DrawableTransitionOptions().crossFade(drawableCrossFadeFactory);
   }
 
@@ -44,8 +50,9 @@ public static DrawableTransitionOptions withCrossFade(
    *
    * @see #crossFade(DrawableCrossFadeFactory.Builder)
    */
+  @NonNull
   public static DrawableTransitionOptions withCrossFade(
-      DrawableCrossFadeFactory.Builder builder) {
+      @NonNull DrawableCrossFadeFactory.Builder builder) {
     return new DrawableTransitionOptions().crossFade(builder);
   }
 
@@ -54,8 +61,9 @@ public static DrawableTransitionOptions withCrossFade(
    *
    * @see com.bumptech.glide.GenericTransitionOptions#with(TransitionFactory)
    */
+  @NonNull
   public static DrawableTransitionOptions with(
-      TransitionFactory<Drawable> transitionFactory) {
+      @NonNull TransitionFactory<Drawable> transitionFactory) {
     return new DrawableTransitionOptions().transition(transitionFactory);
   }
 
@@ -63,6 +71,7 @@ public static DrawableTransitionOptions with(
    * Enables a cross fade animation between both the placeholder and the first resource and between
    * subsequent resources (if thumbnails are used).
    */
+  @NonNull
   public DrawableTransitionOptions crossFade() {
     return crossFade(new DrawableCrossFadeFactory.Builder());
   }
@@ -75,6 +84,7 @@ public DrawableTransitionOptions crossFade() {
    *     {@code DrawableCrossFadeFactory.Builder(int)}
    * @see com.bumptech.glide.request.transition.DrawableCrossFadeFactory.Builder
    */
+  @NonNull
   public DrawableTransitionOptions crossFade(int duration) {
     return crossFade(new DrawableCrossFadeFactory.Builder(duration));
   }
@@ -83,7 +93,9 @@ public DrawableTransitionOptions crossFade(int duration) {
    * Enables a cross fade animation between both the placeholder and the first resource and between
    * subsequent resources (if thumbnails are used).
    */
-  public DrawableTransitionOptions crossFade(DrawableCrossFadeFactory drawableCrossFadeFactory) {
+  @NonNull
+  public DrawableTransitionOptions crossFade(
+      @NonNull DrawableCrossFadeFactory drawableCrossFadeFactory) {
     return transition(drawableCrossFadeFactory);
   }
 
@@ -91,7 +103,8 @@ public DrawableTransitionOptions crossFade(DrawableCrossFadeFactory drawableCros
    * Enables a cross fade animation between both the placeholder and the first resource and between
    * subsequent resources (if thumbnails are used).
    */
-  public DrawableTransitionOptions crossFade(DrawableCrossFadeFactory.Builder builder) {
+  @NonNull
+  public DrawableTransitionOptions crossFade(@NonNull DrawableCrossFadeFactory.Builder builder) {
     return crossFade(builder.build());
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/NonOwnedDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/NonOwnedDrawableResource.java
new file mode 100644
index 000000000..2cba88462
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/NonOwnedDrawableResource.java
@@ -0,0 +1,42 @@
+package com.bumptech.glide.load.resource.drawable;
+
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.engine.Resource;
+
+/**
+ * Handles generic {@link Drawable} types where we may be uncertain of their size or type and
+ * where we don't know that it's safe for us to recycle or re-use the Drawable.
+ */
+final class NonOwnedDrawableResource extends DrawableResource<Drawable> {
+
+  @SuppressWarnings("unchecked")
+  @Nullable
+  static Resource<Drawable> newInstance(@Nullable Drawable drawable) {
+    return drawable != null ? new NonOwnedDrawableResource(drawable) : null;
+  }
+
+  private NonOwnedDrawableResource(Drawable drawable) {
+    super(drawable);
+  }
+
+  @NonNull
+  @SuppressWarnings("unchecked")
+  @Override
+  public Class<Drawable> getResourceClass() {
+    return (Class<Drawable>) drawable.getClass();
+  }
+
+  @Override
+  public int getSize() {
+    // 4 bytes per pixel for ARGB_8888 Bitmaps is something of a reasonable approximation. If
+    // there are no intrinsic bounds, we can fall back just to 1.
+    return Math.max(1, drawable.getIntrinsicWidth() * drawable.getIntrinsicHeight() * 4);
+  }
+
+  @Override
+  public void recycle() {
+    // Do nothing.
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/ResourceDrawableDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/ResourceDrawableDecoder.java
new file mode 100644
index 000000000..1550ef519
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/ResourceDrawableDecoder.java
@@ -0,0 +1,91 @@
+package com.bumptech.glide.load.resource.drawable;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.Resource;
+import java.util.List;
+
+/**
+ * Decodes {@link Drawable}s given resource {@link Uri}s.
+ *
+ * <p>This is typically used as a fallback for resource types that either aren't Bitmaps (see #350)
+ * or for resource types that we can't obtain an {@link java.io.InputStream} for using a standard
+ * {@link ContentResolver}, including some types of application icons and resources loaded from
+ * other packages.
+ */
+public class ResourceDrawableDecoder implements ResourceDecoder<Uri, Drawable> {
+  // android.resource://<package_name>/<type>/<name>.
+  private static final int NAME_URI_PATH_SEGMENTS = 2;
+  private static final int TYPE_PATH_SEGMENT_INDEX = 0;
+  private static final int NAME_PATH_SEGMENT_INDEX = 1;
+  // android.resource://<package_name>/<resource_id>
+  private static final int ID_PATH_SEGMENTS = 1;
+  private static final int RESOURCE_ID_SEGMENT_INDEX = 0;
+
+  private final Context context;
+
+  public ResourceDrawableDecoder(Context context) {
+    this.context = context.getApplicationContext();
+  }
+
+  @Override
+  public boolean handles(@NonNull Uri source, @NonNull Options options) {
+    return source.getScheme().equals(ContentResolver.SCHEME_ANDROID_RESOURCE);
+  }
+
+  @Nullable
+  @Override
+  public Resource<Drawable> decode(@NonNull Uri source, int width, int height,
+      @NonNull Options options) {
+    @DrawableRes int resId = loadResourceIdFromUri(source);
+    String packageName = source.getAuthority();
+    Context toUse = packageName.equals(context.getPackageName())
+        ? context : getContextForPackage(source, packageName);
+    // We can't get a theme from another application.
+    Drawable drawable = DrawableDecoderCompat.getDrawable(toUse, resId);
+    return NonOwnedDrawableResource.newInstance(drawable);
+  }
+
+  @NonNull
+  private Context getContextForPackage(Uri source, String packageName) {
+    try {
+      return context.createPackageContext(packageName, /*flags=*/ 0);
+    } catch (NameNotFoundException e) {
+      throw new IllegalArgumentException(
+          "Failed to obtain context or unrecognized Uri format for: " + source, e);
+    }
+  }
+
+  @DrawableRes
+  private int loadResourceIdFromUri(Uri source) {
+    List<String> segments = source.getPathSegments();
+    @DrawableRes Integer result = null;
+    if (segments.size() == NAME_URI_PATH_SEGMENTS) {
+      String packageName = source.getAuthority();
+      String typeName = segments.get(TYPE_PATH_SEGMENT_INDEX);
+      String resourceName = segments.get(NAME_PATH_SEGMENT_INDEX);
+      result = context.getResources().getIdentifier(resourceName, typeName, packageName);
+    } else if (segments.size() == ID_PATH_SEGMENTS) {
+      try {
+        result = Integer.valueOf(segments.get(RESOURCE_ID_SEGMENT_INDEX));
+      } catch (NumberFormatException e) {
+        // Ignored.
+      }
+    }
+
+    if (result == null) {
+      throw new IllegalArgumentException("Unrecognized Uri format: " + source);
+    } else if (result == 0) {
+      throw new IllegalArgumentException("Failed to obtain resource id for: " + source);
+    }
+    return result;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/UnitDrawableDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/UnitDrawableDecoder.java
new file mode 100644
index 000000000..7ac9450c7
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/UnitDrawableDecoder.java
@@ -0,0 +1,25 @@
+package com.bumptech.glide.load.resource.drawable;
+
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.Resource;
+
+/**
+ * Passes through a {@link Drawable} as a {@link Drawable} based {@link Resource}.
+ */
+public class UnitDrawableDecoder implements ResourceDecoder<Drawable, Drawable> {
+  @Override
+  public boolean handles(@NonNull Drawable source, @NonNull Options options) {
+    return true;
+  }
+
+  @Nullable
+  @Override
+  public Resource<Drawable> decode(@NonNull Drawable source, int width, int height,
+      @NonNull Options options) {
+    return NonOwnedDrawableResource.newInstance(source);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/file/FileDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/file/FileDecoder.java
index e932f3caf..a5b3e13dd 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/file/FileDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/file/FileDecoder.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.resource.file;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
@@ -12,12 +13,13 @@
 public class FileDecoder implements ResourceDecoder<File, File> {
 
   @Override
-  public boolean handles(File source, Options options) {
+  public boolean handles(@NonNull File source, @NonNull Options options) {
     return true;
   }
 
   @Override
-  public Resource<File> decode(File source, int width, int height, Options options) {
+  public Resource<File> decode(@NonNull File source, int width, int height,
+      @NonNull Options options) {
     return new FileResource(source);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/file/FileResource.java b/library/src/main/java/com/bumptech/glide/load/resource/file/FileResource.java
index beeec792e..790f33b53 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/file/FileResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/file/FileResource.java
@@ -6,6 +6,8 @@
 /**
  * A simple {@link com.bumptech.glide.load.engine.Resource} that wraps a {@link File}.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public class FileResource extends SimpleResource<File> {
   public FileResource(File file) {
     super(file);
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
index 2b56d271e..dbab1827c 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
@@ -2,16 +2,19 @@
 
 import android.content.Context;
 import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 import android.util.Log;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.gifdecoder.GifHeader;
 import com.bumptech.glide.gifdecoder.GifHeaderParser;
 import com.bumptech.glide.gifdecoder.StandardGifDecoder;
+import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.ImageHeaderParser.ImageType;
 import com.bumptech.glide.load.ImageHeaderParserUtils;
-import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.Transformation;
@@ -32,24 +35,16 @@
 public class ByteBufferGifDecoder implements ResourceDecoder<ByteBuffer, GifDrawable> {
   private static final String TAG = "BufferGifDecoder";
   private static final GifDecoderFactory GIF_DECODER_FACTORY = new GifDecoderFactory();
-
-  /**
-   *  If set to {@code true}, disables this decoder
-   *  ({@link #handles(ByteBuffer, Options)} will return {@code false}). Defaults to
-   * {@code false}.
-   */
-  public static final Option<Boolean> DISABLE_ANIMATION = Option.memory(
-      "com.bumptech.glide.load.resource.gif.ByteBufferGifDecoder.DisableAnimation", false);
-
   private static final GifHeaderParserPool PARSER_POOL = new GifHeaderParserPool();
 
   private final Context context;
   private final List<ImageHeaderParser> parsers;
   private final GifHeaderParserPool parserPool;
-  private final BitmapPool bitmapPool;
   private final GifDecoderFactory gifDecoderFactory;
   private final GifBitmapProvider provider;
 
+  // Public API.
+  @SuppressWarnings("unused")
   public ByteBufferGifDecoder(Context context) {
     this(context, Glide.get(context).getRegistry().getImageHeaderParsers(),
         Glide.get(context).getBitmapPool(), Glide.get(context).getArrayPool());
@@ -61,7 +56,7 @@ public ByteBufferGifDecoder(
     this(context, parsers, bitmapPool, arrayPool, PARSER_POOL, GIF_DECODER_FACTORY);
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   ByteBufferGifDecoder(
       Context context,
       List<ImageHeaderParser> parsers,
@@ -71,57 +66,62 @@ public ByteBufferGifDecoder(
       GifDecoderFactory gifDecoderFactory) {
     this.context = context.getApplicationContext();
     this.parsers = parsers;
-    this.bitmapPool = bitmapPool;
     this.gifDecoderFactory = gifDecoderFactory;
     this.provider = new GifBitmapProvider(bitmapPool, arrayPool);
     this.parserPool = parserPool;
   }
 
   @Override
-  public boolean handles(ByteBuffer source, Options options) throws IOException {
-    return !options.get(DISABLE_ANIMATION)
+  public boolean handles(@NonNull ByteBuffer source, @NonNull Options options) throws IOException {
+    return !options.get(GifOptions.DISABLE_ANIMATION)
         && ImageHeaderParserUtils.getType(parsers, source) == ImageType.GIF;
   }
 
   @Override
-  public GifDrawableResource decode(ByteBuffer source, int width, int height, Options options) {
+  public GifDrawableResource decode(@NonNull ByteBuffer source, int width, int height,
+      @NonNull Options options) {
     final GifHeaderParser parser = parserPool.obtain(source);
     try {
-      return decode(source, width, height, parser);
+      return decode(source, width, height, parser, options);
     } finally {
       parserPool.release(parser);
     }
   }
 
-  private GifDrawableResource decode(ByteBuffer byteBuffer, int width, int height,
-      GifHeaderParser parser) {
+  @Nullable
+  private GifDrawableResource decode(
+      ByteBuffer byteBuffer, int width, int height, GifHeaderParser parser, Options options) {
     long startTime = LogTime.getLogTime();
-    final GifHeader header = parser.parseHeader();
-    if (header.getNumFrames() <= 0 || header.getStatus() != GifDecoder.STATUS_OK) {
-      // If we couldn't decode the GIF, we will end up with a frame count of 0.
-      return null;
-    }
+    try {
+      final GifHeader header = parser.parseHeader();
+      if (header.getNumFrames() <= 0 || header.getStatus() != GifDecoder.STATUS_OK) {
+        // If we couldn't decode the GIF, we will end up with a frame count of 0.
+        return null;
+      }
 
+      Bitmap.Config config = options.get(GifOptions.DECODE_FORMAT) == DecodeFormat.PREFER_RGB_565
+          ? Bitmap.Config.RGB_565 : Bitmap.Config.ARGB_8888;
 
-    int sampleSize = getSampleSize(header, width, height);
-    GifDecoder gifDecoder = gifDecoderFactory.build(provider, header, byteBuffer, sampleSize);
-    gifDecoder.advance();
-    Bitmap firstFrame = gifDecoder.getNextFrame();
-    if (firstFrame == null) {
-      return null;
-    }
+      int sampleSize = getSampleSize(header, width, height);
+      GifDecoder gifDecoder = gifDecoderFactory.build(provider, header, byteBuffer, sampleSize);
+      gifDecoder.setDefaultBitmapConfig(config);
+      gifDecoder.advance();
+      Bitmap firstFrame = gifDecoder.getNextFrame();
+      if (firstFrame == null) {
+        return null;
+      }
 
-    Transformation<Bitmap> unitTransformation = UnitTransformation.get();
+      Transformation<Bitmap> unitTransformation = UnitTransformation.get();
 
-    GifDrawable gifDrawable =
-        new GifDrawable(context, gifDecoder, bitmapPool, unitTransformation, width, height,
-            firstFrame);
+      GifDrawable gifDrawable =
+          new GifDrawable(context, gifDecoder, unitTransformation, width, height, firstFrame);
 
-    if (Log.isLoggable(TAG, Log.VERBOSE)) {
-      Log.v(TAG, "Decoded GIF from stream in " + LogTime.getElapsedMillis(startTime));
+      return new GifDrawableResource(gifDrawable);
+    } finally {
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+        Log.v(TAG, "Decoded GIF from stream in " + LogTime.getElapsedMillis(startTime));
+      }
     }
-
-    return new GifDrawableResource(gifDrawable);
   }
 
   private static int getSampleSize(GifHeader gifHeader, int targetWidth, int targetHeight) {
@@ -131,7 +131,7 @@ private static int getSampleSize(GifHeader gifHeader, int targetWidth, int targe
     // Although functionally equivalent to 0 for BitmapFactory, 1 is a safer default for our code
     // than 0.
     int sampleSize = Math.max(1, powerOfTwoSampleSize);
-    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+    if (Log.isLoggable(TAG, Log.VERBOSE) && sampleSize > 1) {
       Log.v(TAG, "Downsampling GIF"
           + ", sampleSize: " + sampleSize
           + ", target dimens: [" + targetWidth + "x" + targetHeight + "]"
@@ -140,19 +140,19 @@ private static int getSampleSize(GifHeader gifHeader, int targetWidth, int targe
     return sampleSize;
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class GifDecoderFactory {
-    public GifDecoder build(GifDecoder.BitmapProvider provider, GifHeader header,
+    GifDecoder build(GifDecoder.BitmapProvider provider, GifHeader header,
         ByteBuffer data, int sampleSize) {
       return new StandardGifDecoder(provider, header, data, sampleSize);
     }
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class GifHeaderParserPool {
     private final Queue<GifHeaderParser> pool = Util.createQueue(0);
 
-    public synchronized GifHeaderParser obtain(ByteBuffer buffer) {
+    synchronized GifHeaderParser obtain(ByteBuffer buffer) {
       GifHeaderParser result = pool.poll();
       if (result == null) {
         result = new GifHeaderParser();
@@ -160,7 +160,7 @@ public synchronized GifHeaderParser obtain(ByteBuffer buffer) {
       return result.setData(buffer);
     }
 
-    public synchronized void release(GifHeaderParser parser) {
+    synchronized void release(GifHeaderParser parser) {
       parser.clear();
       pool.offer(parser);
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java
index a9d231006..400530d79 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java
@@ -21,29 +21,32 @@
    * when requested.
    */
   public GifBitmapProvider(BitmapPool bitmapPool) {
-    this(bitmapPool, null /* arrayPool */);
+    this(bitmapPool, /*arrayPool=*/ null);
   }
 
   /**
    * Constructs an instance with a shared array pool. Arrays will be reused where
    * possible.
    */
-  public GifBitmapProvider(BitmapPool bitmapPool, ArrayPool arrayPool) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public GifBitmapProvider(BitmapPool bitmapPool, @Nullable ArrayPool arrayPool) {
     this.bitmapPool = bitmapPool;
     this.arrayPool = arrayPool;
   }
 
   @NonNull
   @Override
-  public Bitmap obtain(int width, int height, Bitmap.Config config) {
+  public Bitmap obtain(int width, int height, @NonNull Bitmap.Config config) {
     return bitmapPool.getDirty(width, height, config);
   }
 
   @Override
-  public void release(Bitmap bitmap) {
+  public void release(@NonNull Bitmap bitmap) {
     bitmapPool.put(bitmap);
   }
 
+  @NonNull
   @Override
   public byte[] obtainByteArray(int size) {
     if (arrayPool == null) {
@@ -52,15 +55,15 @@ public void release(Bitmap bitmap) {
     return arrayPool.get(size, byte[].class);
   }
 
-  @SuppressWarnings("PMD.UseVarargs")
   @Override
-  public void release(byte[] bytes) {
+  public void release(@NonNull byte[] bytes) {
     if (arrayPool == null) {
       return;
     }
-    arrayPool.put(bytes, byte[].class);
+    arrayPool.put(bytes);
   }
 
+  @NonNull
   @Override
   public int[] obtainIntArray(int size) {
     if (arrayPool == null) {
@@ -71,10 +74,10 @@ public void release(byte[] bytes) {
 
   @SuppressWarnings("PMD.UseVarargs")
   @Override
-  public void release(int[] array) {
+  public void release(@NonNull int[] array) {
     if (arrayPool == null) {
       return;
     }
-    arrayPool.put(array, int[].class);
+    arrayPool.put(array);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
index 5e6f98eed..cd0aa5248 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
@@ -12,6 +12,7 @@
 import android.graphics.Rect;
 import android.graphics.drawable.Animatable;
 import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
 import android.support.annotation.VisibleForTesting;
 import android.view.Gravity;
 import com.bumptech.glide.Glide;
@@ -29,13 +30,18 @@
   /**
    * A constant indicating that an animated drawable should loop continuously.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public static final int LOOP_FOREVER = -1;
   /**
    * A constant indicating that an animated drawable should loop for its default number of times.
    * For animated GIFs, this constant indicates the GIF should use the netscape loop count if
    * present.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public static final int LOOP_INTRINSIC = 0;
+  private static final int GRAVITY = Gravity.FILL;
 
   private final GifState state;
   /**
@@ -74,9 +80,40 @@
    * Constructor for GifDrawable.
    *
    * @param context             A context.
-   * @param bitmapPool          A {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool}
-   *                            that can be used to return the first frame when this drawable is
-   *                            recycled.
+   * @param bitmapPool          Ignored, see deprecation note.
+   * @param frameTransformation An {@link com.bumptech.glide.load.Transformation} that can be
+   *                            applied to each frame.
+   * @param targetFrameWidth    The desired width of the frames displayed by this drawable (the
+   *                            width of the view or
+   *                            {@link com.bumptech.glide.request.target.Target}
+   *                            this drawable is being loaded into).
+   * @param targetFrameHeight   The desired height of the frames displayed by this drawable (the
+   *                            height of the view or
+   *                            {@link com.bumptech.glide.request.target.Target}
+   *                            this drawable is being loaded into).
+   * @param gifDecoder          The decoder to use to decode GIF data.
+   * @param firstFrame          The decoded and transformed first frame of this GIF.
+   * @see #setFrameTransformation(com.bumptech.glide.load.Transformation, android.graphics.Bitmap)
+   *
+   * @deprecated Use {@link #GifDrawable(Context, GifDecoder, Transformation, int, int, Bitmap)}
+   */
+  @SuppressWarnings("deprecation")
+  @Deprecated
+  public GifDrawable(
+      Context context,
+      GifDecoder gifDecoder,
+      @SuppressWarnings("unused") BitmapPool bitmapPool,
+      Transformation<Bitmap> frameTransformation,
+      int targetFrameWidth,
+      int targetFrameHeight,
+      Bitmap firstFrame) {
+    this(context, gifDecoder, frameTransformation, targetFrameWidth, targetFrameHeight, firstFrame);
+  }
+
+   /**
+   * Constructor for GifDrawable.
+   *
+   * @param context             A context.
    * @param frameTransformation An {@link com.bumptech.glide.load.Transformation} that can be
    *                            applied to each frame.
    * @param targetFrameWidth    The desired width of the frames displayed by this drawable (the
@@ -91,12 +128,15 @@
    * @param firstFrame          The decoded and transformed first frame of this GIF.
    * @see #setFrameTransformation(com.bumptech.glide.load.Transformation, android.graphics.Bitmap)
    */
-  public GifDrawable(Context context, GifDecoder gifDecoder, BitmapPool bitmapPool,
-      Transformation<Bitmap> frameTransformation, int targetFrameWidth, int targetFrameHeight,
+  public GifDrawable(
+      Context context,
+      GifDecoder gifDecoder,
+      Transformation<Bitmap> frameTransformation,
+      int targetFrameWidth,
+      int targetFrameHeight,
       Bitmap firstFrame) {
     this(
         new GifState(
-            bitmapPool,
             new GifFrameLoader(
                 // TODO(b/27524013): Factor out this call to Glide.get()
                 Glide.get(context),
@@ -112,8 +152,8 @@ public GifDrawable(Context context, GifDecoder gifDecoder, BitmapPool bitmapPool
   }
 
   @VisibleForTesting
-  GifDrawable(GifFrameLoader frameLoader, BitmapPool bitmapPool, Paint paint) {
-    this(new GifState(bitmapPool, frameLoader));
+  GifDrawable(GifFrameLoader frameLoader, Paint paint) {
+    this(new GifState(frameLoader));
     this.paint = paint;
   }
 
@@ -125,6 +165,8 @@ public Bitmap getFirstFrame() {
     return state.frameLoader.getFirstFrame();
   }
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public void setFrameTransformation(Transformation<Bitmap> frameTransformation,
       Bitmap firstFrame) {
     state.frameLoader.setFrameTransformation(frameTransformation, firstFrame);
@@ -146,6 +188,8 @@ public int getFrameCount() {
    * Returns the current frame index in the range 0..{@link #getFrameCount()} - 1, or -1 if no frame
    * is displayed.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public int getFrameIndex() {
     return state.frameLoader.getCurrentIndex();
   }
@@ -157,6 +201,8 @@ private void resetLoopCount() {
   /**
    * Starts the animation from the first frame. Can only be called while animation is not running.
    */
+  // Public API.
+  @SuppressWarnings("unused")
   public void startFromFirstFrame() {
     Preconditions.checkArgument(!isRunning, "You cannot restart a currently running animation.");
     state.frameLoader.setNextStartFromFirstFrame();
@@ -237,14 +283,13 @@ protected void onBoundsChange(Rect bounds) {
   }
 
   @Override
-  public void draw(Canvas canvas) {
+  public void draw(@NonNull Canvas canvas) {
     if (isRecycled) {
       return;
     }
 
     if (applyGravity) {
-      Gravity.apply(GifState.GRAVITY, getIntrinsicWidth(), getIntrinsicHeight(), getBounds(),
-          getDestRect());
+      Gravity.apply(GRAVITY, getIntrinsicWidth(), getIntrinsicHeight(), getBounds(), getDestRect());
       applyGravity = false;
     }
 
@@ -282,9 +327,18 @@ public int getOpacity() {
     return PixelFormat.TRANSPARENT;
   }
 
+  // See #1087.
+  private Callback findCallback() {
+    Callback callback = getCallback();
+    while (callback instanceof Drawable) {
+      callback = ((Drawable) callback).getCallback();
+    }
+    return callback;
+  }
+
   @Override
   public void onFrameReady() {
-    if (getCallback() == null) {
+    if (findCallback() == null) {
       stop();
       invalidateSelf();
       return;
@@ -319,6 +373,8 @@ boolean isRecycled() {
     return isRecycled;
   }
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public void setLoopCount(int loopCount) {
     if (loopCount <= 0 && loopCount != LOOP_FOREVER && loopCount != LOOP_INTRINSIC) {
       throw new IllegalArgumentException("Loop count must be greater than 0, or equal to "
@@ -334,21 +390,21 @@ public void setLoopCount(int loopCount) {
     }
   }
 
-  static class GifState extends ConstantState {
-    static final int GRAVITY = Gravity.FILL;
-    final BitmapPool bitmapPool;
+  static final class GifState extends ConstantState {
+    @VisibleForTesting
     final GifFrameLoader frameLoader;
 
-    public GifState(BitmapPool bitmapPool, GifFrameLoader frameLoader) {
-      this.bitmapPool = bitmapPool;
+    GifState(GifFrameLoader frameLoader) {
       this.frameLoader = frameLoader;
     }
 
+    @NonNull
     @Override
     public Drawable newDrawable(Resources res) {
       return newDrawable();
     }
 
+    @NonNull
     @Override
     public Drawable newDrawable() {
       return new GifDrawable(this);
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableEncoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableEncoder.java
index f2f842381..e73f713dc 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableEncoder.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.resource.gif;
 
+import android.support.annotation.NonNull;
 import android.util.Log;
 import com.bumptech.glide.load.EncodeStrategy;
 import com.bumptech.glide.load.Options;
@@ -16,13 +17,15 @@
 public class GifDrawableEncoder implements ResourceEncoder<GifDrawable> {
   private static final String TAG = "GifEncoder";
 
+  @NonNull
   @Override
-  public EncodeStrategy getEncodeStrategy(Options options) {
+  public EncodeStrategy getEncodeStrategy(@NonNull Options options) {
     return EncodeStrategy.SOURCE;
   }
 
   @Override
-  public boolean encode(Resource<GifDrawable> data, File file, Options options) {
+  public boolean encode(@NonNull Resource<GifDrawable> data, @NonNull File file,
+      @NonNull Options options) {
     GifDrawable drawable = data.get();
     boolean success = false;
     try {
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java
index d0275e023..090f279b8 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.resource.gif;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.resource.drawable.DrawableResource;
 
@@ -8,10 +9,13 @@
  */
 public class GifDrawableResource extends DrawableResource<GifDrawable>
     implements Initializable {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public GifDrawableResource(GifDrawable drawable) {
     super(drawable);
   }
 
+  @NonNull
   @Override
   public Class<GifDrawable> getResourceClass() {
     return GifDrawable.class;
@@ -19,7 +23,7 @@ public GifDrawableResource(GifDrawable drawable) {
 
   @Override
   public int getSize() {
-   return drawable.getSize();
+    return drawable.getSize();
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java
index 06b1a4fb4..8c39e60cb 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java
@@ -2,6 +2,7 @@
 
 import android.content.Context;
 import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
@@ -40,9 +41,11 @@ public GifDrawableTransformation(
     this(wrapped);
   }
 
+  @NonNull
   @Override
   public Resource<GifDrawable> transform(
-      Context context, Resource<GifDrawable> resource, int outWidth, int outHeight) {
+      @NonNull Context context, @NonNull Resource<GifDrawable> resource,
+      int outWidth, int outHeight) {
     GifDrawable drawable = resource.get();
 
     // The drawable needs to be initialized with the correct width and height in order for a view
@@ -78,7 +81,7 @@ public int hashCode() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     wrapped.updateDiskCacheKey(messageDigest);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
index 9c51ba3ed..c46775bd2 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
@@ -8,6 +8,9 @@
 import android.os.Looper;
 import android.os.Message;
 import android.os.SystemClock;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.RequestManager;
@@ -31,24 +34,27 @@
   private final GifDecoder gifDecoder;
   private final Handler handler;
   private final List<FrameCallback> callbacks = new ArrayList<>();
-  @Synthetic final RequestManager requestManager;
+  @SuppressWarnings("WeakerAccess") @Synthetic final RequestManager requestManager;
   private final BitmapPool bitmapPool;
 
-  private boolean isRunning = false;
-  private boolean isLoadPending = false;
-  private boolean startFromFirstFrame = false;
+  private boolean isRunning;
+  private boolean isLoadPending;
+  private boolean startFromFirstFrame;
   private RequestBuilder<Bitmap> requestBuilder;
   private DelayTarget current;
   private boolean isCleared;
   private DelayTarget next;
   private Bitmap firstFrame;
   private Transformation<Bitmap> transformation;
+  private DelayTarget pendingTarget;
+  @Nullable
+  private GifFrameLoader.OnEveryFrameListener onEveryFrameListener;
 
   public interface FrameCallback {
     void onFrameReady();
   }
 
-  public GifFrameLoader(
+  GifFrameLoader(
       Glide glide,
       GifDecoder gifDecoder,
       int width,
@@ -105,10 +111,10 @@ void subscribe(FrameCallback frameCallback) {
     if (isCleared) {
       throw new IllegalStateException("Cannot subscribe to a cleared frame loader");
     }
-    boolean start = callbacks.isEmpty();
     if (callbacks.contains(frameCallback)) {
       throw new IllegalStateException("Cannot subscribe twice in a row");
     }
+    boolean start = callbacks.isEmpty();
     callbacks.add(frameCallback);
     if (start) {
       start();
@@ -181,6 +187,10 @@ void clear() {
       requestManager.clear(next);
       next = null;
     }
+    if (pendingTarget != null) {
+      requestManager.clear(pendingTarget);
+      pendingTarget = null;
+    }
     gifDecoder.clear();
     isCleared = true;
   }
@@ -194,9 +204,17 @@ private void loadNextFrame() {
       return;
     }
     if (startFromFirstFrame) {
+      Preconditions.checkArgument(
+          pendingTarget == null, "Pending target must be null when starting from the first frame");
       gifDecoder.resetFrameIndex();
       startFromFirstFrame = false;
     }
+    if (pendingTarget != null) {
+      DelayTarget temp = pendingTarget;
+      pendingTarget = null;
+      onFrameReady(temp);
+      return;
+    }
     isLoadPending = true;
     // Get the delay before incrementing the pointer because the delay indicates the amount of time
     // we want to spend on the current frame.
@@ -205,7 +223,7 @@ private void loadNextFrame() {
 
     gifDecoder.advance();
     next = new DelayTarget(handler, gifDecoder.getCurrentFrameIndex(), targetTime);
-    requestBuilder.clone().apply(signatureOf(getFrameSignature())).load(gifDecoder).into(next);
+    requestBuilder.apply(signatureOf(getFrameSignature())).load(gifDecoder).into(next);
   }
 
   private void recycleFirstFrame() {
@@ -218,14 +236,35 @@ private void recycleFirstFrame() {
   void setNextStartFromFirstFrame() {
     Preconditions.checkArgument(!isRunning, "Can't restart a running animation");
     startFromFirstFrame = true;
+    if (pendingTarget != null) {
+      requestManager.clear(pendingTarget);
+      pendingTarget = null;
+    }
+  }
+
+  @VisibleForTesting
+  void setOnEveryFrameReadyListener(@Nullable OnEveryFrameListener onEveryFrameListener) {
+    this.onEveryFrameListener = onEveryFrameListener;
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   void onFrameReady(DelayTarget delayTarget) {
+    if (onEveryFrameListener != null) {
+      onEveryFrameListener.onFrameReady();
+    }
+    isLoadPending = false;
     if (isCleared) {
       handler.obtainMessage(FrameLoaderCallback.MSG_CLEAR, delayTarget).sendToTarget();
       return;
     }
+    // If we're not running, notifying here will recycle the frame that we might currently be
+    // showing, which breaks things (see #2526). We also can't discard this frame because we've
+    // already incremented the frame pointer and can't decode the same frame again. Instead we'll
+    // just hang on to this next frame until start() or clear() are called.
+    if (!isRunning) {
+      pendingTarget = delayTarget;
+      return;
+    }
 
     if (delayTarget.getResource() != null) {
       recycleFirstFrame();
@@ -242,13 +281,12 @@ void onFrameReady(DelayTarget delayTarget) {
       }
     }
 
-    isLoadPending = false;
     loadNextFrame();
   }
 
   private class FrameLoaderCallback implements Handler.Callback {
-    public static final int MSG_DELAY = 1;
-    public static final int MSG_CLEAR = 2;
+    static final int MSG_DELAY = 1;
+    static final int MSG_CLEAR = 2;
 
     @Synthetic
     FrameLoaderCallback() { }
@@ -267,7 +305,7 @@ public boolean handleMessage(Message msg) {
     }
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class DelayTarget extends SimpleTarget<Bitmap> {
     private final Handler handler;
     @Synthetic final int index;
@@ -285,7 +323,8 @@ Bitmap getResource() {
     }
 
     @Override
-    public void onResourceReady(Bitmap resource, Transition<? super Bitmap> transition) {
+    public void onResourceReady(@NonNull Bitmap resource,
+        @Nullable Transition<? super Bitmap> transition) {
       this.resource = resource;
       Message msg = handler.obtainMessage(FrameLoaderCallback.MSG_DELAY, this);
       handler.sendMessageAtTime(msg, targetTime);
@@ -298,13 +337,19 @@ public void onResourceReady(Bitmap resource, Transition<? super Bitmap> transiti
         .asBitmap()
         .apply(
             diskCacheStrategyOf(DiskCacheStrategy.NONE)
+                .useAnimationPool(true)
                 .skipMemoryCache(true)
                 .override(width, height));
   }
 
-  static Key getFrameSignature() {
+  private static Key getFrameSignature() {
     // Some devices seem to have crypto bugs that throw exceptions when you create a new UUID.
     // See #1510.
     return new ObjectKey(Math.random());
   }
+
+  @VisibleForTesting
+  interface OnEveryFrameListener {
+    void onFrameReady();
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java
index 4e887ed11..0fa7e28d5 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.gif;
 
 import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
@@ -20,12 +21,13 @@ public GifFrameResourceDecoder(BitmapPool bitmapPool) {
   }
 
   @Override
-  public boolean handles(GifDecoder source, Options options) {
+  public boolean handles(@NonNull GifDecoder source, @NonNull Options options) {
     return true;
   }
 
   @Override
-  public Resource<Bitmap> decode(GifDecoder source, int width, int height, Options options) {
+  public Resource<Bitmap> decode(@NonNull GifDecoder source, int width, int height,
+      @NonNull Options options) {
     Bitmap bitmap = source.getNextFrame();
     return BitmapResource.obtain(bitmap, bitmapPool);
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifOptions.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifOptions.java
new file mode 100644
index 000000000..cb2f71e5e
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifOptions.java
@@ -0,0 +1,32 @@
+package com.bumptech.glide.load.resource.gif;
+
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceDecoder;
+
+/**
+ * Options related to decoding GIFs.
+ */
+public final class GifOptions {
+
+  /**
+   * Indicates the {@link com.bumptech.glide.load.DecodeFormat} that will be used in conjunction
+   * with the particular GIF to determine the {@link android.graphics.Bitmap.Config} to use when
+   * decoding frames of GIFs.
+   */
+  public static final Option<DecodeFormat> DECODE_FORMAT = Option.memory(
+      "com.bumptech.glide.load.resource.gif.GifOptions.DecodeFormat", DecodeFormat.DEFAULT);
+
+  /**
+   * If set to {@code true}, disables the GIF {@link com.bumptech.glide.load.ResourceDecoder}s
+   * ({@link ResourceDecoder#handles(Object, Options)} will return {@code false}). Defaults to
+   * {@code false}.
+   */
+  public static final Option<Boolean> DISABLE_ANIMATION = Option.memory(
+      "com.bumptech.glide.load.resource.gif.GifOptions.DisableAnimation", false);
+
+  private GifOptions() {
+    // Utility class.
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java
index baf4abc43..2cc3b848b 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java
@@ -1,10 +1,10 @@
 package com.bumptech.glide.load.resource.gif;
 
+import android.support.annotation.NonNull;
 import android.util.Log;
 import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.ImageHeaderParser.ImageType;
 import com.bumptech.glide.load.ImageHeaderParserUtils;
-import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
@@ -22,13 +22,6 @@
  */
 public class StreamGifDecoder implements ResourceDecoder<InputStream, GifDrawable> {
   private static final String TAG = "StreamGifDecoder";
-  /**
-   * If set to {@code true}, disables this decoder
-   * ({@link #handles(InputStream, Options)} will return {@code false}). Defaults to
-   * {@code false}.
-   */
-  public static final Option<Boolean> DISABLE_ANIMATION = Option.memory(
-      "com.bumptech.glide.load.resource.gif.ByteBufferGifDecoder.DisableAnimation", false);
 
   private final List<ImageHeaderParser> parsers;
   private final ResourceDecoder<ByteBuffer, GifDrawable> byteBufferDecoder;
@@ -42,14 +35,14 @@ public StreamGifDecoder(List<ImageHeaderParser> parsers, ResourceDecoder<ByteBuf
   }
 
   @Override
-  public boolean handles(InputStream source, Options options) throws IOException {
-    return !options.get(DISABLE_ANIMATION)
+  public boolean handles(@NonNull InputStream source, @NonNull Options options) throws IOException {
+    return !options.get(GifOptions.DISABLE_ANIMATION)
         && ImageHeaderParserUtils.getType(parsers, source, byteArrayPool) == ImageType.GIF;
   }
 
   @Override
-  public Resource<GifDrawable> decode(InputStream source, int width, int height,
-      Options options) throws IOException {
+  public Resource<GifDrawable> decode(@NonNull InputStream source, int width, int height,
+      @NonNull Options options) throws IOException {
     byte[] data = inputStreamToBytes(source);
     if (data == null) {
       return null;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java
index 2b09adb40..9274b56ff 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java
@@ -1,6 +1,8 @@
 package com.bumptech.glide.load.resource.transcode;
 
 import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.bytes.BytesResource;
@@ -20,13 +22,17 @@ public BitmapBytesTranscoder() {
     this(Bitmap.CompressFormat.JPEG, 100);
   }
 
-  public BitmapBytesTranscoder(Bitmap.CompressFormat compressFormat, int quality) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public BitmapBytesTranscoder(@NonNull Bitmap.CompressFormat compressFormat, int quality) {
     this.compressFormat = compressFormat;
     this.quality = quality;
   }
 
+  @Nullable
   @Override
-  public Resource<byte[]> transcode(Resource<Bitmap> toTranscode, Options options) {
+  public Resource<byte[]> transcode(@NonNull Resource<Bitmap> toTranscode,
+      @NonNull Options options) {
     ByteArrayOutputStream os = new ByteArrayOutputStream();
     toTranscode.get().compress(compressFormat, quality, os);
     toTranscode.recycle();
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java
index 03642bbe4..b9dc68bb5 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java
@@ -4,7 +4,8 @@
 import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
-import com.bumptech.glide.Glide;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
@@ -17,19 +18,30 @@
  */
 public class BitmapDrawableTranscoder implements ResourceTranscoder<Bitmap, BitmapDrawable> {
   private final Resources resources;
-  private final BitmapPool bitmapPool;
 
-  public BitmapDrawableTranscoder(Context context) {
-    this(context.getResources(), Glide.get(context).getBitmapPool());
+  // Public API.
+  @SuppressWarnings("unused")
+  public BitmapDrawableTranscoder(@NonNull Context context) {
+    this(context.getResources());
   }
 
-  public BitmapDrawableTranscoder(Resources resources, BitmapPool bitmapPool) {
+  /**
+   * @deprecated Use {@link #BitmapDrawableTranscoder(Resources)}, {@code bitmapPool} is unused.
+   */
+  @Deprecated
+  public BitmapDrawableTranscoder(
+      @NonNull Resources resources, @SuppressWarnings("unused") BitmapPool bitmapPool) {
+    this(resources);
+  }
+
+  public BitmapDrawableTranscoder(@NonNull Resources resources) {
     this.resources = Preconditions.checkNotNull(resources);
-    this.bitmapPool = Preconditions.checkNotNull(bitmapPool);
   }
 
+  @Nullable
   @Override
-  public Resource<BitmapDrawable> transcode(Resource<Bitmap> toTranscode, Options options) {
-    return LazyBitmapDrawableResource.obtain(resources, bitmapPool, toTranscode.get());
+  public Resource<BitmapDrawable> transcode(@NonNull Resource<Bitmap> toTranscode,
+      @NonNull Options options) {
+    return LazyBitmapDrawableResource.obtain(resources, toTranscode);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/DrawableBytesTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/DrawableBytesTranscoder.java
new file mode 100644
index 000000000..a37e16ff6
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/DrawableBytesTranscoder.java
@@ -0,0 +1,52 @@
+package com.bumptech.glide.load.resource.transcode;
+
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.resource.bitmap.BitmapResource;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
+
+/**
+ * Obtains {@code byte[]} from {@link BitmapDrawable}s by delegating to a
+ * {@link ResourceTranscoder} for {@link Bitmap}s to {@code byte[]}s.
+ */
+public final class DrawableBytesTranscoder implements ResourceTranscoder<Drawable, byte[]> {
+  private final BitmapPool bitmapPool;
+  private final ResourceTranscoder<Bitmap, byte[]> bitmapBytesTranscoder;
+  private final ResourceTranscoder<GifDrawable, byte[]> gifDrawableBytesTranscoder;
+
+  public DrawableBytesTranscoder(
+      @NonNull BitmapPool bitmapPool,
+      @NonNull ResourceTranscoder<Bitmap, byte[]> bitmapBytesTranscoder,
+      @NonNull ResourceTranscoder<GifDrawable, byte[]> gifDrawableBytesTranscoder) {
+    this.bitmapPool = bitmapPool;
+    this.bitmapBytesTranscoder = bitmapBytesTranscoder;
+    this.gifDrawableBytesTranscoder = gifDrawableBytesTranscoder;
+  }
+
+  @Nullable
+  @Override
+  public Resource<byte[]> transcode(@NonNull Resource<Drawable> toTranscode,
+      @NonNull Options options) {
+    Drawable drawable = toTranscode.get();
+    if (drawable instanceof BitmapDrawable) {
+      return bitmapBytesTranscoder.transcode(
+          BitmapResource.obtain(((BitmapDrawable) drawable).getBitmap(), bitmapPool), options);
+    } else if (drawable instanceof GifDrawable) {
+      return gifDrawableBytesTranscoder.transcode(toGifDrawableResource(toTranscode), options);
+    }
+    return null;
+  }
+
+  @SuppressWarnings("unchecked")
+  @NonNull
+  private static Resource<GifDrawable> toGifDrawableResource(@NonNull Resource<Drawable> resource) {
+    return (Resource<GifDrawable>) (Resource<?>) resource;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java
index 0bc3c12b3..69e82202d 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.bytes.BytesResource;
@@ -13,8 +15,10 @@
  * the GIF from the {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
  */
 public class GifDrawableBytesTranscoder implements ResourceTranscoder<GifDrawable, byte[]> {
+  @Nullable
   @Override
-  public Resource<byte[]> transcode(Resource<GifDrawable> toTranscode, Options options) {
+  public Resource<byte[]> transcode(@NonNull Resource<GifDrawable> toTranscode,
+      @NonNull Options options) {
     GifDrawable gifData = toTranscode.get();
     ByteBuffer byteBuffer = gifData.getBuffer();
     return new BytesResource(ByteBufferUtil.toBytes(byteBuffer));
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java
index e84bd6b00..fbd4631bd 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 
@@ -16,5 +18,6 @@
    *
    * @param toTranscode The resource to transcode.
    */
-  Resource<R> transcode(Resource<Z> toTranscode, Options options);
+  @Nullable
+  Resource<R> transcode(@NonNull Resource<Z> toTranscode, @NonNull Options options);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistry.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistry.java
index b632c35ad..9c907b65f 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistry.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayList;
 import java.util.List;
@@ -21,8 +22,9 @@
    * @param <Z>             The type of the resource that the transcoder transcodes from.
    * @param <R>             The type of the resource that the transcoder transcodes to.
    */
-  public synchronized <Z, R> void register(Class<Z> decodedClass, Class<R> transcodedClass,
-      ResourceTranscoder<Z, R> transcoder) {
+  public synchronized <Z, R> void register(
+      @NonNull Class<Z> decodedClass, @NonNull Class<R> transcodedClass,
+      @NonNull ResourceTranscoder<Z, R> transcoder) {
     transcoders.add(new Entry<>(decodedClass, transcodedClass, transcoder));
   }
 
@@ -35,9 +37,10 @@
    * @param <Z>             The type of the resource that the transcoder transcodes from.
    * @param <R>             The type of the resource that the transcoder transcodes to.
    */
+  @NonNull
   @SuppressWarnings("unchecked")
-  public synchronized <Z, R> ResourceTranscoder<Z, R> get(Class<Z> resourceClass,
-      Class<R> transcodedClass) {
+  public synchronized <Z, R> ResourceTranscoder<Z, R> get(
+      @NonNull Class<Z> resourceClass, @NonNull Class<R> transcodedClass) {
     // For example, there may be a transcoder that can convert a GifDrawable to a Drawable, which
     // will be caught above. However, if there is no registered transcoder, we can still just use
     // the UnitTranscoder to return the Drawable because the transcode class (Drawable) is
@@ -55,8 +58,9 @@
         "No transcoder registered to transcode from " + resourceClass + " to " + transcodedClass);
   }
 
-  public synchronized <Z, R> List<Class<R>> getTranscodeClasses(Class<Z> resourceClass,
-      Class<R> transcodeClass) {
+  @NonNull
+  public synchronized <Z, R> List<Class<R>> getTranscodeClasses(
+      @NonNull Class<Z> resourceClass, @NonNull Class<R> transcodeClass) {
     List<Class<R>> transcodeClasses = new ArrayList<>();
     // GifDrawable -> Drawable is just the UnitTranscoder, as is GifDrawable -> GifDrawable.
     if (transcodeClass.isAssignableFrom(resourceClass)) {
@@ -78,7 +82,8 @@
     private final Class<R> toClass;
     @Synthetic final ResourceTranscoder<Z, R> transcoder;
 
-    Entry(Class<Z> fromClass, Class<R> toClass, ResourceTranscoder<Z, R> transcoder) {
+    Entry(@NonNull Class<Z> fromClass, @NonNull Class<R> toClass,
+        @NonNull ResourceTranscoder<Z, R> transcoder) {
       this.fromClass = fromClass;
       this.toClass = toClass;
       this.transcoder = transcoder;
@@ -90,7 +95,7 @@
      * we can fulfill requests for a more generic parent class (like Drawable). As a result, we
      * check fromClass and toClass in different orders.
      */
-    public boolean handles(Class<?> fromClass, Class<?> toClass) {
+    public boolean handles(@NonNull Class<?> fromClass, @NonNull Class<?> toClass) {
       return this.fromClass.isAssignableFrom(fromClass) && toClass.isAssignableFrom(this.toClass);
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/UnitTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/UnitTranscoder.java
index 0fd6d0964..45efdf5a1 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/UnitTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/UnitTranscoder.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 
@@ -9,15 +11,16 @@
  * @param <Z> The type of the resource that will be transcoded from and to.
  */
 public class UnitTranscoder<Z> implements ResourceTranscoder<Z, Z> {
-  private static final UnitTranscoder<?> UNIT_TRANSCODER = new UnitTranscoder<Object>();
+  private static final UnitTranscoder<?> UNIT_TRANSCODER = new UnitTranscoder<>();
 
   @SuppressWarnings("unchecked")
   public static <Z> ResourceTranscoder<Z, Z> get() {
     return (ResourceTranscoder<Z, Z>) UNIT_TRANSCODER;
   }
 
+  @Nullable
   @Override
-  public Resource<Z> transcode(Resource<Z> toTranscode, Options options) {
+  public Resource<Z> transcode(@NonNull Resource<Z> toTranscode, @NonNull Options options) {
     return toTranscode;
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java b/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java
index fd88428e8..8bb528050 100644
--- a/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java
+++ b/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.manager;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.util.Util;
 import java.util.Collections;
 import java.util.Set;
@@ -27,7 +28,7 @@
    * avoid adding listeners multiple times. </p>
    */
   @Override
-  public void addListener(LifecycleListener listener) {
+  public void addListener(@NonNull LifecycleListener listener) {
     lifecycleListeners.add(listener);
 
     if (isDestroyed) {
@@ -40,7 +41,7 @@ public void addListener(LifecycleListener listener) {
   }
 
   @Override
-  public void removeListener(LifecycleListener listener) {
+  public void removeListener(@NonNull LifecycleListener listener) {
     lifecycleListeners.remove(listener);
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/manager/ApplicationLifecycle.java b/library/src/main/java/com/bumptech/glide/manager/ApplicationLifecycle.java
index 5911d5234..7bf69da7e 100644
--- a/library/src/main/java/com/bumptech/glide/manager/ApplicationLifecycle.java
+++ b/library/src/main/java/com/bumptech/glide/manager/ApplicationLifecycle.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.manager;
 
+import android.support.annotation.NonNull;
+
 /**
  * A {@link com.bumptech.glide.manager.Lifecycle} implementation for tracking and notifying
  * listeners of {@link android.app.Application} lifecycle events.
@@ -9,12 +11,12 @@
  */
 class ApplicationLifecycle implements Lifecycle {
   @Override
-  public void addListener(LifecycleListener listener) {
+  public void addListener(@NonNull LifecycleListener listener) {
     listener.onStart();
   }
 
   @Override
-  public void removeListener(LifecycleListener listener) {
+  public void removeListener(@NonNull LifecycleListener listener) {
     // Do nothing.
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java
index d2967bffa..bea4b3673 100644
--- a/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java
+++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java
@@ -1,35 +1,44 @@
 package com.bumptech.glide.manager;
 
+import android.annotation.SuppressLint;
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
+import android.support.annotation.NonNull;
+import android.util.Log;
+import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
 
 /**
  * Uses {@link android.net.ConnectivityManager} to identify connectivity changes.
  */
-class DefaultConnectivityMonitor implements ConnectivityMonitor {
+final class DefaultConnectivityMonitor implements ConnectivityMonitor {
+  private static final String TAG = "ConnectivityMonitor";
   private final Context context;
-  @Synthetic final ConnectivityListener listener;
+  @SuppressWarnings("WeakerAccess") @Synthetic final ConnectivityListener listener;
 
-  @Synthetic boolean isConnected;
+  @SuppressWarnings("WeakerAccess") @Synthetic boolean isConnected;
   private boolean isRegistered;
 
   private final BroadcastReceiver connectivityReceiver = new BroadcastReceiver() {
     @Override
-    public void onReceive(Context context, Intent intent) {
+    public void onReceive(@NonNull Context context, Intent intent) {
       boolean wasConnected = isConnected;
       isConnected = isConnected(context);
       if (wasConnected != isConnected) {
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "connectivity changed, isConnected: " + isConnected);
+        }
+
         listener.onConnectivityChanged(isConnected);
       }
     }
   };
 
-  public DefaultConnectivityMonitor(Context context, ConnectivityListener listener) {
+  DefaultConnectivityMonitor(@NonNull Context context, @NonNull ConnectivityListener listener) {
     this.context = context.getApplicationContext();
     this.listener = listener;
   }
@@ -39,10 +48,19 @@ private void register() {
       return;
     }
 
+    // Initialize isConnected.
     isConnected = isConnected(context);
-    context.registerReceiver(connectivityReceiver,
-        new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION));
-    isRegistered = true;
+    try {
+      // See #1405
+      context.registerReceiver(connectivityReceiver,
+          new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION));
+      isRegistered = true;
+    } catch (SecurityException e) {
+      // See #1417, registering the receiver can throw SecurityException.
+      if (Log.isLoggable(TAG, Log.WARN)) {
+        Log.w(TAG, "Failed to register", e);
+      }
+    }
   }
 
   private void unregister() {
@@ -54,11 +72,27 @@ private void unregister() {
     isRegistered = false;
   }
 
+  @SuppressWarnings("WeakerAccess")
   @Synthetic
-  boolean isConnected(Context context) {
+  // Permissions are checked in the factory instead.
+  @SuppressLint("MissingPermission")
+  boolean isConnected(@NonNull Context context) {
     ConnectivityManager connectivityManager =
-        (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
-    NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();
+        Preconditions.checkNotNull(
+            (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE));
+    NetworkInfo networkInfo;
+    try {
+      networkInfo = connectivityManager.getActiveNetworkInfo();
+    } catch (RuntimeException e) {
+      // #1405 shows that this throws a SecurityException.
+      // b/70869360 shows that this throws NullPointerException on APIs 22, 23, and 24.
+      // b/70869360 also shows that this throws RuntimeException on API 24 and 25.
+      if (Log.isLoggable(TAG, Log.WARN)) {
+        Log.w(TAG, "Failed to determine connectivity status when connectivity changed", e);
+      }
+      // Default to true;
+      return true;
+    }
     return networkInfo != null && networkInfo.isConnected();
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactory.java b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactory.java
index 2d6702e53..6858eb370 100644
--- a/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactory.java
+++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactory.java
@@ -4,6 +4,7 @@
 import android.content.pm.PackageManager;
 import android.support.annotation.NonNull;
 import android.support.v4.content.ContextCompat;
+import android.util.Log;
 
 /**
  * A factory class that produces a functional {@link com.bumptech.glide.manager.ConnectivityMonitor}
@@ -12,14 +13,23 @@
  * the required permission.
  */
 public class DefaultConnectivityMonitorFactory implements ConnectivityMonitorFactory {
+  private static final String TAG = "ConnectivityMonitor";
   private static final String NETWORK_PERMISSION = "android.permission.ACCESS_NETWORK_STATE";
 
   @NonNull
+  @Override
   public ConnectivityMonitor build(
       @NonNull Context context,
       @NonNull ConnectivityMonitor.ConnectivityListener listener) {
     int permissionResult = ContextCompat.checkSelfPermission(context, NETWORK_PERMISSION);
     boolean hasPermission = permissionResult == PackageManager.PERMISSION_GRANTED;
+    if (Log.isLoggable(TAG, Log.DEBUG)) {
+      Log.d(
+          TAG,
+          hasPermission
+              ? "ACCESS_NETWORK_STATE permission granted, registering connectivity monitor"
+              : "ACCESS_NETWORK_STATE permission missing, cannot register connectivity monitor");
+    }
     return hasPermission
         ? new DefaultConnectivityMonitor(context, listener) : new NullConnectivityMonitor();
   }
diff --git a/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java b/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java
index 5d811cc49..7297680cd 100644
--- a/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java
+++ b/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.manager;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.RequestManager;
 import java.util.Collections;
 import java.util.Set;
@@ -8,6 +9,7 @@
  * A {@link RequestManagerTreeNode} that returns no relatives.
  */
 final class EmptyRequestManagerTreeNode implements RequestManagerTreeNode {
+    @NonNull
     @Override
     public Set<RequestManager> getDescendants() {
         return Collections.emptySet();
diff --git a/library/src/main/java/com/bumptech/glide/manager/Lifecycle.java b/library/src/main/java/com/bumptech/glide/manager/Lifecycle.java
index 53044cee1..434b5dcab 100644
--- a/library/src/main/java/com/bumptech/glide/manager/Lifecycle.java
+++ b/library/src/main/java/com/bumptech/glide/manager/Lifecycle.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.manager;
 
+import android.support.annotation.NonNull;
+
 /**
  * An interface for listening to Activity/Fragment lifecycle events.
  */
@@ -7,7 +9,7 @@
   /**
    * Adds the given listener to the set of listeners managed by this Lifecycle implementation.
    */
-  void addListener(LifecycleListener listener);
+  void addListener(@NonNull LifecycleListener listener);
 
   /**
    * Removes the given listener from the set of listeners managed by this Lifecycle implementation,
@@ -16,5 +18,5 @@
    * <p>This is an optimization only, there is no guarantee that every added listener will
    * eventually be removed.
    */
-  void removeListener(LifecycleListener listener);
+  void removeListener(@NonNull LifecycleListener listener);
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
index 44dfb5979..272064fa4 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
@@ -5,7 +5,9 @@
 import android.app.Activity;
 import android.app.Fragment;
 import android.os.Build;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 import android.util.Log;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestManager;
@@ -28,8 +30,7 @@
   private final ActivityFragmentLifecycle lifecycle;
   private final RequestManagerTreeNode requestManagerTreeNode =
       new FragmentRequestManagerTreeNode();
-  private final HashSet<RequestManagerFragment> childRequestManagerFragments =
-      new HashSet<>();
+  private final Set<RequestManagerFragment> childRequestManagerFragments = new HashSet<>();
 
   @Nullable private RequestManager requestManager;
   @Nullable private RequestManagerFragment rootRequestManagerFragment;
@@ -39,9 +40,9 @@ public RequestManagerFragment() {
     this(new ActivityFragmentLifecycle());
   }
 
-  // For testing only.
+  @VisibleForTesting
   @SuppressLint("ValidFragment")
-  RequestManagerFragment(ActivityFragmentLifecycle lifecycle) {
+  RequestManagerFragment(@NonNull ActivityFragmentLifecycle lifecycle) {
     this.lifecycle = lifecycle;
   }
 
@@ -50,10 +51,11 @@ public RequestManagerFragment() {
    *
    * @param requestManager The request manager to use.
    */
-  public void setRequestManager(RequestManager requestManager) {
+  public void setRequestManager(@Nullable RequestManager requestManager) {
     this.requestManager = requestManager;
   }
 
+  @NonNull
   ActivityFragmentLifecycle getGlideLifecycle() {
     return lifecycle;
   }
@@ -69,6 +71,7 @@ public RequestManager getRequestManager() {
   /**
    * Returns the {@link RequestManagerTreeNode} for this fragment.
    */
+  @NonNull
   public RequestManagerTreeNode getRequestManagerTreeNode() {
     return requestManagerTreeNode;
   }
@@ -86,8 +89,10 @@ private void removeChildRequestManagerFragment(RequestManagerFragment child) {
    * our parent is the fragment that we are annotating).
    */
   @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
-  public Set<RequestManagerFragment> getDescendantRequestManagerFragments() {
-    if (rootRequestManagerFragment == this) {
+  @Synthetic
+  @NonNull
+  Set<RequestManagerFragment> getDescendantRequestManagerFragments() {
+    if (equals(rootRequestManagerFragment)) {
       return Collections.unmodifiableSet(childRequestManagerFragments);
     } else if (rootRequestManagerFragment == null
         || Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {
@@ -95,7 +100,7 @@ private void removeChildRequestManagerFragment(RequestManagerFragment child) {
       // so just return an empty set.
       return Collections.emptySet();
     } else {
-      HashSet<RequestManagerFragment> descendants = new HashSet<>();
+      Set<RequestManagerFragment> descendants = new HashSet<>();
       for (RequestManagerFragment fragment : rootRequestManagerFragment
           .getDescendantRequestManagerFragments()) {
         if (isDescendant(fragment.getParentFragment())) {
@@ -110,13 +115,14 @@ private void removeChildRequestManagerFragment(RequestManagerFragment child) {
    * Sets a hint for which fragment is our parent which allows the fragment to return correct
    * information about its parents before pending fragment transactions have been executed.
    */
-  void setParentFragmentHint(Fragment parentFragmentHint) {
+  void setParentFragmentHint(@Nullable Fragment parentFragmentHint) {
     this.parentFragmentHint = parentFragmentHint;
     if (parentFragmentHint != null && parentFragmentHint.getActivity() != null) {
       registerFragmentWithRoot(parentFragmentHint.getActivity());
     }
   }
 
+  @Nullable
   @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
   private Fragment getParentFragmentUsingHint() {
     final Fragment fragment;
@@ -132,10 +138,11 @@ private Fragment getParentFragmentUsingHint() {
    * Returns true if the fragment is a descendant of our parent.
    */
   @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
-  private boolean isDescendant(Fragment fragment) {
-    Fragment root = this.getParentFragment();
-    while (fragment.getParentFragment() != null) {
-      if (fragment.getParentFragment() == root) {
+  private boolean isDescendant(@NonNull Fragment fragment) {
+    Fragment root = getParentFragment();
+    Fragment parentFragment;
+    while ((parentFragment = fragment.getParentFragment()) != null) {
+      if (parentFragment.equals(root)) {
         return true;
       }
       fragment = fragment.getParentFragment();
@@ -143,11 +150,11 @@ private boolean isDescendant(Fragment fragment) {
     return false;
   }
 
-  private void registerFragmentWithRoot(Activity activity) {
+  private void registerFragmentWithRoot(@NonNull Activity activity) {
     unregisterFragmentWithRoot();
     rootRequestManagerFragment = Glide.get(activity).getRequestManagerRetriever()
         .getRequestManagerFragment(activity.getFragmentManager(), null);
-    if (rootRequestManagerFragment != this) {
+    if (!equals(rootRequestManagerFragment)) {
       rootRequestManagerFragment.addChildRequestManagerFragment(this);
     }
   }
@@ -208,10 +215,11 @@ public String toString() {
     @Synthetic
     FragmentRequestManagerTreeNode() { }
 
+    @NonNull
     @Override
     public Set<RequestManager> getDescendants() {
       Set<RequestManagerFragment> descendantFragments = getDescendantRequestManagerFragments();
-      HashSet<RequestManager> descendants = new HashSet<>(descendantFragments.size());
+      Set<RequestManager> descendants = new HashSet<>(descendantFragments.size());
       for (RequestManagerFragment fragment : descendantFragments) {
         if (fragment.getRequestManager() != null) {
           descendants.add(fragment.getRequestManager());
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
index 81c3749fb..7d25d760b 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
@@ -12,7 +12,9 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
 import android.support.v4.app.FragmentManager;
@@ -32,7 +34,7 @@
  * retrieving existing ones from activities and fragment.
  */
 public class RequestManagerRetriever implements Handler.Callback {
-  // Visible for testing.
+  @VisibleForTesting
   static final String FRAGMENT_TAG = "com.bumptech.glide.manager";
   private static final String TAG = "RMRetriever";
 
@@ -48,17 +50,17 @@
    */
   private volatile RequestManager applicationManager;
 
-  // Visible for testing.
   /**
    * Pending adds for RequestManagerFragments.
    */
+  @VisibleForTesting
   final Map<android.app.FragmentManager, RequestManagerFragment> pendingRequestManagerFragments =
       new HashMap<>();
 
-  // Visible for testing.
   /**
    * Pending adds for SupportRequestManagerFragments.
    */
+  @VisibleForTesting
   final Map<FragmentManager, SupportRequestManagerFragment> pendingSupportRequestManagerFragments =
       new HashMap<>();
 
@@ -73,13 +75,13 @@
   private final ArrayMap<View, android.app.Fragment> tempViewToFragment = new ArrayMap<>();
   private final Bundle tempBundle = new Bundle();
 
-  // Visible for testing.
   public RequestManagerRetriever(@Nullable RequestManagerFactory factory) {
     this.factory = factory != null ? factory : DEFAULT_FACTORY;
     handler = new Handler(Looper.getMainLooper(), this /* Callback */);
   }
 
-  private RequestManager getApplicationManager(Context context) {
+  @NonNull
+  private RequestManager getApplicationManager(@NonNull Context context) {
     // Either an application context or we're on a background thread.
     if (applicationManager == null) {
       synchronized (this) {
@@ -90,9 +92,13 @@ private RequestManager getApplicationManager(Context context) {
           // ApplicationLifecycle.
 
           // TODO(b/27524013): Factor out this Glide.get() call.
-          Glide glide = Glide.get(context);
+          Glide glide = Glide.get(context.getApplicationContext());
           applicationManager =
-              factory.build(glide, new ApplicationLifecycle(), new EmptyRequestManagerTreeNode());
+              factory.build(
+                  glide,
+                  new ApplicationLifecycle(),
+                  new EmptyRequestManagerTreeNode(),
+                  context.getApplicationContext());
         }
       }
     }
@@ -100,7 +106,8 @@ private RequestManager getApplicationManager(Context context) {
     return applicationManager;
   }
 
-  public RequestManager get(Context context) {
+  @NonNull
+  public RequestManager get(@NonNull Context context) {
     if (context == null) {
       throw new IllegalArgumentException("You cannot start a load on a null Context");
     } else if (Util.isOnMainThread() && !(context instanceof Application)) {
@@ -116,7 +123,8 @@ public RequestManager get(Context context) {
     return getApplicationManager(context);
   }
 
-  public RequestManager get(FragmentActivity activity) {
+  @NonNull
+  public RequestManager get(@NonNull FragmentActivity activity) {
     if (Util.isOnBackgroundThread()) {
       return get(activity.getApplicationContext());
     } else {
@@ -126,7 +134,8 @@ public RequestManager get(FragmentActivity activity) {
     }
   }
 
-  public RequestManager get(Fragment fragment) {
+  @NonNull
+  public RequestManager get(@NonNull Fragment fragment) {
     Preconditions.checkNotNull(fragment.getActivity(),
           "You cannot start a load on a fragment before it is attached or after it is destroyed");
     if (Util.isOnBackgroundThread()) {
@@ -137,7 +146,8 @@ public RequestManager get(Fragment fragment) {
     }
   }
 
-  public RequestManager get(Activity activity) {
+  @NonNull
+  public RequestManager get(@NonNull Activity activity) {
     if (Util.isOnBackgroundThread()) {
       return get(activity.getApplicationContext());
     } else {
@@ -147,7 +157,8 @@ public RequestManager get(Activity activity) {
     }
   }
 
-  public RequestManager get(View view) {
+  @NonNull
+  public RequestManager get(@NonNull View view) {
     if (Util.isOnBackgroundThread()) {
       return get(view.getContext().getApplicationContext());
     }
@@ -180,7 +191,7 @@ public RequestManager get(View view) {
 
   private static void findAllSupportFragmentsWithViews(
       @Nullable Collection<Fragment> topLevelFragments,
-      Map<View, Fragment> result) {
+      @NonNull Map<View, Fragment> result) {
     if (topLevelFragments == null) {
       return;
     }
@@ -195,7 +206,7 @@ private static void findAllSupportFragmentsWithViews(
   }
 
   @Nullable
-  private Fragment findSupportFragment(View target, FragmentActivity activity) {
+  private Fragment findSupportFragment(@NonNull View target, @NonNull FragmentActivity activity) {
     tempViewToSupportFragment.clear();
     findAllSupportFragmentsWithViews(
         activity.getSupportFragmentManager().getFragments(), tempViewToSupportFragment);
@@ -219,7 +230,7 @@ private Fragment findSupportFragment(View target, FragmentActivity activity) {
   }
 
   @Nullable
-  private android.app.Fragment findFragment(View target, Activity activity) {
+  private android.app.Fragment findFragment(@NonNull View target, @NonNull Activity activity) {
     tempViewToFragment.clear();
     findAllFragmentsWithViews(activity.getFragmentManager(), tempViewToFragment);
 
@@ -227,7 +238,7 @@ private Fragment findSupportFragment(View target, FragmentActivity activity) {
 
     View activityRoot = activity.findViewById(android.R.id.content);
     View current = target;
-     while (!current.equals(activityRoot)) {
+    while (!current.equals(activityRoot)) {
       result = tempViewToFragment.get(current);
       if (result != null) {
         break;
@@ -246,7 +257,8 @@ private Fragment findSupportFragment(View target, FragmentActivity activity) {
   // non-support Fragments.
   @TargetApi(Build.VERSION_CODES.O)
   private void findAllFragmentsWithViews(
-      android.app.FragmentManager fragmentManager, ArrayMap<View, android.app.Fragment> result) {
+      @NonNull android.app.FragmentManager fragmentManager,
+      @NonNull ArrayMap<View, android.app.Fragment> result) {
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
       for (android.app.Fragment fragment : fragmentManager.getFragments()) {
         if (fragment.getView() != null) {
@@ -260,7 +272,8 @@ private void findAllFragmentsWithViews(
   }
 
   private void findAllFragmentsWithViewsPreO(
-      android.app.FragmentManager fragmentManager, ArrayMap<View, android.app.Fragment> result) {
+      @NonNull android.app.FragmentManager fragmentManager,
+      @NonNull ArrayMap<View, android.app.Fragment> result) {
     int index = 0;
     while (true) {
       tempBundle.putInt(FRAGMENT_INDEX_KEY, index++);
@@ -282,7 +295,8 @@ private void findAllFragmentsWithViewsPreO(
     }
   }
 
-  private Activity findActivity(Context context) {
+  @Nullable
+  private Activity findActivity(@NonNull Context context) {
     if (context instanceof Activity) {
       return (Activity) context;
     } else if (context instanceof ContextWrapper) {
@@ -293,14 +307,15 @@ private Activity findActivity(Context context) {
   }
 
   @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
-  private static void assertNotDestroyed(Activity activity) {
+  private static void assertNotDestroyed(@NonNull Activity activity) {
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1 && activity.isDestroyed()) {
       throw new IllegalArgumentException("You cannot start a load for a destroyed activity");
     }
   }
 
+  @NonNull
   @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
-  public RequestManager get(android.app.Fragment fragment) {
+  public RequestManager get(@NonNull android.app.Fragment fragment) {
     if (fragment.getActivity() == null) {
       throw new IllegalArgumentException(
           "You cannot start a load on a fragment before it is attached");
@@ -313,9 +328,9 @@ public RequestManager get(android.app.Fragment fragment) {
     }
   }
 
-  @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+  @NonNull
   RequestManagerFragment getRequestManagerFragment(
-      final android.app.FragmentManager fm, android.app.Fragment parentHint) {
+      @NonNull final android.app.FragmentManager fm, @Nullable android.app.Fragment parentHint) {
     RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);
     if (current == null) {
       current = pendingRequestManagerFragments.get(fm);
@@ -330,22 +345,26 @@ RequestManagerFragment getRequestManagerFragment(
     return current;
   }
 
-  private RequestManager fragmentGet(Context context, android.app.FragmentManager fm,
-      android.app.Fragment parentHint) {
+  @NonNull
+  private RequestManager fragmentGet(@NonNull Context context,
+      @NonNull android.app.FragmentManager fm,
+      @Nullable android.app.Fragment parentHint) {
     RequestManagerFragment current = getRequestManagerFragment(fm, parentHint);
     RequestManager requestManager = current.getRequestManager();
     if (requestManager == null) {
       // TODO(b/27524013): Factor out this Glide.get() call.
       Glide glide = Glide.get(context);
       requestManager =
-          factory.build(glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode());
+          factory.build(
+              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);
       current.setRequestManager(requestManager);
     }
     return requestManager;
   }
 
+  @NonNull
   SupportRequestManagerFragment getSupportRequestManagerFragment(
-      final FragmentManager fm, Fragment parentHint) {
+      @NonNull final FragmentManager fm, @Nullable Fragment parentHint) {
     SupportRequestManagerFragment current =
         (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);
     if (current == null) {
@@ -361,15 +380,17 @@ SupportRequestManagerFragment getSupportRequestManagerFragment(
     return current;
   }
 
-  private RequestManager supportFragmentGet(Context context, FragmentManager fm,
-      Fragment parentHint) {
+  @NonNull
+  private RequestManager supportFragmentGet(@NonNull Context context, @NonNull FragmentManager fm,
+      @Nullable Fragment parentHint) {
     SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint);
     RequestManager requestManager = current.getRequestManager();
     if (requestManager == null) {
       // TODO(b/27524013): Factor out this Glide.get() call.
       Glide glide = Glide.get(context);
       requestManager =
-          factory.build(glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode());
+          factory.build(
+              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);
       current.setRequestManager(requestManager);
     }
     return requestManager;
@@ -405,15 +426,20 @@ public boolean handleMessage(Message message) {
    * Used internally to create {@link RequestManager}s.
    */
   public interface RequestManagerFactory {
+    @NonNull
     RequestManager build(
-        Glide glide, Lifecycle lifecycle, RequestManagerTreeNode requestManagerTreeNode);
+        @NonNull Glide glide,
+        @NonNull Lifecycle lifecycle,
+        @NonNull RequestManagerTreeNode requestManagerTreeNode,
+        @NonNull Context context);
   }
 
   private static final RequestManagerFactory DEFAULT_FACTORY = new RequestManagerFactory() {
+    @NonNull
     @Override
-    public RequestManager build(Glide glide, Lifecycle lifecycle,
-        RequestManagerTreeNode requestManagerTreeNode) {
-      return new RequestManager(glide, lifecycle, requestManagerTreeNode);
+    public RequestManager build(@NonNull Glide glide, @NonNull Lifecycle lifecycle,
+        @NonNull RequestManagerTreeNode requestManagerTreeNode, @NonNull Context context) {
+      return new RequestManager(glide, lifecycle, requestManagerTreeNode, context);
     }
   };
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java
index 38d341b3a..20666d093 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.manager;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.RequestManager;
 import java.util.Set;
 
@@ -13,5 +14,6 @@
    * Returns all descendant {@link RequestManager}s relative to the context of the current
    * {@link RequestManager}.
    */
+  @NonNull
   Set<RequestManager> getDescendants();
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
index f735e3618..45fa25c17 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
@@ -1,5 +1,8 @@
 package com.bumptech.glide.manager;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.util.Util;
 import java.util.ArrayList;
@@ -33,7 +36,7 @@
   /**
    * Starts tracking the given request.
    */
-  public void runRequest(Request request) {
+  public void runRequest(@NonNull Request request) {
     requests.add(request);
     if (!isPaused) {
       request.begin();
@@ -42,25 +45,35 @@ public void runRequest(Request request) {
     }
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   void addRequest(Request request) {
     requests.add(request);
   }
 
   /**
    * Stops tracking the given request, clears, and recycles it, and returns {@code true} if the
-   * request was removed or {@code false} if the request was not found.
+   * request was removed or invalid or {@code false} if the request was not found.
    */
-  public boolean clearRemoveAndRecycle(Request request) {
-    if (request == null) {
-      return false;
+  public boolean clearRemoveAndRecycle(@Nullable Request request) {
+    // It's safe for us to recycle because this is only called when the user is explicitly clearing
+    // a Target so we know that there are no remaining references to the Request.
+    return clearRemoveAndMaybeRecycle(request, /*isSafeToRecycle=*/ true);
+  }
+
+  private boolean clearRemoveAndMaybeRecycle(@Nullable Request request, boolean isSafeToRecycle) {
+     if (request == null) {
+       // If the Request is null, the request is already cleared and we don't need to search further
+       // for its owner.
+      return true;
     }
     boolean isOwnedByUs = requests.remove(request);
     // Avoid short circuiting.
     isOwnedByUs = pendingRequests.remove(request) || isOwnedByUs;
     if (isOwnedByUs) {
       request.clear();
-      request.recycle();
+      if (isSafeToRecycle) {
+        request.recycle();
+      }
     }
     return isOwnedByUs;
   }
@@ -85,6 +98,17 @@ public void pauseRequests() {
     }
   }
 
+  /** Stops any in progress requests and releases bitmaps associated with completed requests. */
+  public void pauseAllRequests() {
+    isPaused = true;
+    for (Request request : Util.getSnapshot(requests)) {
+      if (request.isRunning() || request.isComplete()) {
+        request.pause();
+        pendingRequests.add(request);
+      }
+    }
+  }
+
   /**
    * Starts any not yet completed or failed requests.
    */
@@ -105,7 +129,9 @@ public void resumeRequests() {
    */
   public void clearRequests() {
     for (Request request : Util.getSnapshot(requests)) {
-      clearRemoveAndRecycle(request);
+      // It's unsafe to recycle the Request here because we don't know who might else have a
+      // reference to it.
+      clearRemoveAndMaybeRecycle(request, /*isSafeToRecycle=*/ false);
     }
     pendingRequests.clear();
   }
diff --git a/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java b/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java
index 8bf7c0ec0..b6b2f28dc 100644
--- a/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java
+++ b/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java
@@ -2,7 +2,9 @@
 
 import android.annotation.SuppressLint;
 import android.content.Context;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
 import android.util.Log;
@@ -27,8 +29,7 @@
   private final ActivityFragmentLifecycle lifecycle;
   private final RequestManagerTreeNode requestManagerTreeNode =
       new SupportFragmentRequestManagerTreeNode();
-  private final HashSet<SupportRequestManagerFragment> childRequestManagerFragments =
-      new HashSet<>();
+  private final Set<SupportRequestManagerFragment> childRequestManagerFragments = new HashSet<>();
 
   @Nullable private SupportRequestManagerFragment rootRequestManagerFragment;
   @Nullable private RequestManager requestManager;
@@ -38,9 +39,9 @@ public SupportRequestManagerFragment() {
     this(new ActivityFragmentLifecycle());
   }
 
-  // For testing only.
+  @VisibleForTesting
   @SuppressLint("ValidFragment")
-  public SupportRequestManagerFragment(ActivityFragmentLifecycle lifecycle) {
+  public SupportRequestManagerFragment(@NonNull ActivityFragmentLifecycle lifecycle) {
     this.lifecycle = lifecycle;
   }
 
@@ -49,10 +50,11 @@ public SupportRequestManagerFragment(ActivityFragmentLifecycle lifecycle) {
    *
    * @param requestManager The manager to put.
    */
-  public void setRequestManager(RequestManager requestManager) {
+  public void setRequestManager(@Nullable RequestManager requestManager) {
     this.requestManager = requestManager;
   }
 
+  @NonNull
   ActivityFragmentLifecycle getGlideLifecycle() {
     return lifecycle;
   }
@@ -70,6 +72,7 @@ public RequestManager getRequestManager() {
    * to the
    * associated {@link RequestManager}.
    */
+  @NonNull
   public RequestManagerTreeNode getRequestManagerTreeNode() {
     return requestManagerTreeNode;
   }
@@ -86,13 +89,15 @@ private void removeChildRequestManagerFragment(SupportRequestManagerFragment chi
    * Returns the set of fragments that this RequestManagerFragment's parent is a parent to. (i.e.
    * our parent is the fragment that we are annotating).
    */
-  public Set<SupportRequestManagerFragment> getDescendantRequestManagerFragments() {
+  @Synthetic
+  @NonNull
+  Set<SupportRequestManagerFragment> getDescendantRequestManagerFragments() {
     if (rootRequestManagerFragment == null) {
       return Collections.emptySet();
-    } else if (rootRequestManagerFragment == this) {
+    } else if (equals(rootRequestManagerFragment)) {
       return Collections.unmodifiableSet(childRequestManagerFragments);
     } else {
-      HashSet<SupportRequestManagerFragment> descendants = new HashSet<>();
+      Set<SupportRequestManagerFragment> descendants = new HashSet<>();
       for (SupportRequestManagerFragment fragment : rootRequestManagerFragment
           .getDescendantRequestManagerFragments()) {
         if (isDescendant(fragment.getParentFragmentUsingHint())) {
@@ -107,13 +112,14 @@ private void removeChildRequestManagerFragment(SupportRequestManagerFragment chi
    * Sets a hint for which fragment is our parent which allows the fragment to return correct
    * information about its parents before pending fragment transactions have been executed.
    */
-  void setParentFragmentHint(Fragment parentFragmentHint) {
+  void setParentFragmentHint(@Nullable Fragment parentFragmentHint) {
     this.parentFragmentHint = parentFragmentHint;
     if (parentFragmentHint != null && parentFragmentHint.getActivity() != null) {
       registerFragmentWithRoot(parentFragmentHint.getActivity());
     }
   }
 
+  @Nullable
   private Fragment getParentFragmentUsingHint() {
     Fragment fragment = getParentFragment();
     return fragment != null ? fragment : parentFragmentHint;
@@ -122,10 +128,11 @@ private Fragment getParentFragmentUsingHint() {
   /**
    * Returns true if the fragment is a descendant of our parent.
    */
-  private boolean isDescendant(Fragment fragment) {
-    Fragment root = this.getParentFragmentUsingHint();
-    while (fragment.getParentFragment() != null) {
-      if (fragment.getParentFragment() == root) {
+  private boolean isDescendant(@NonNull Fragment fragment) {
+    Fragment root = getParentFragmentUsingHint();
+    Fragment parentFragment;
+    while ((parentFragment = fragment.getParentFragment()) != null) {
+      if (parentFragment.equals(root)) {
         return true;
       }
       fragment = fragment.getParentFragment();
@@ -133,11 +140,11 @@ private boolean isDescendant(Fragment fragment) {
     return false;
   }
 
-  private void registerFragmentWithRoot(FragmentActivity activity) {
+  private void registerFragmentWithRoot(@NonNull FragmentActivity activity) {
     unregisterFragmentWithRoot();
     rootRequestManagerFragment = Glide.get(activity).getRequestManagerRetriever()
         .getSupportRequestManagerFragment(activity.getSupportFragmentManager(), null);
-    if (rootRequestManagerFragment != this) {
+    if (!equals(rootRequestManagerFragment)) {
       rootRequestManagerFragment.addChildRequestManagerFragment(this);
     }
   }
@@ -198,11 +205,12 @@ public String toString() {
     @Synthetic
     SupportFragmentRequestManagerTreeNode() { }
 
+    @NonNull
     @Override
     public Set<RequestManager> getDescendants() {
       Set<SupportRequestManagerFragment> descendantFragments =
           getDescendantRequestManagerFragments();
-      HashSet<RequestManager> descendants = new HashSet<>(descendantFragments.size());
+      Set<RequestManager> descendants = new HashSet<>(descendantFragments.size());
       for (SupportRequestManagerFragment fragment : descendantFragments) {
         if (fragment.getRequestManager() != null) {
           descendants.add(fragment.getRequestManager());
diff --git a/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java b/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java
index 64dd276db..45ad1252a 100644
--- a/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java
+++ b/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java
@@ -1,8 +1,8 @@
 package com.bumptech.glide.manager;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.util.Util;
-import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.Set;
@@ -16,11 +16,11 @@
   private final Set<Target<?>> targets =
       Collections.newSetFromMap(new WeakHashMap<Target<?>, Boolean>());
 
-  public void track(Target<?> target) {
+  public void track(@NonNull Target<?> target) {
     targets.add(target);
   }
 
-  public void untrack(Target<?> target) {
+  public void untrack(@NonNull Target<?> target) {
     targets.remove(target);
   }
 
@@ -45,8 +45,9 @@ public void onDestroy() {
     }
   }
 
+  @NonNull
   public List<Target<?>> getAll() {
-    return new ArrayList<>(targets);
+    return Util.getSnapshot(targets);
   }
 
   public void clear() {
diff --git a/library/src/main/java/com/bumptech/glide/module/AppGlideModule.java b/library/src/main/java/com/bumptech/glide/module/AppGlideModule.java
index 9d40b969c..77f124670 100644
--- a/library/src/main/java/com/bumptech/glide/module/AppGlideModule.java
+++ b/library/src/main/java/com/bumptech/glide/module/AppGlideModule.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.module;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.GlideBuilder;
 
 /**
@@ -20,6 +21,8 @@
  * annotation processor, {@link AppGlideModule} implementations should override
  * {@link #isManifestParsingEnabled()} and return {@code false}.
  */
+// Used only in javadoc.
+@SuppressWarnings("deprecation")
 public abstract class AppGlideModule extends LibraryGlideModule implements AppliesOptions {
   /**
    * Returns {@code true} if Glide should check the AndroidManifest for {@link GlideModule}s.
@@ -34,7 +37,7 @@ public boolean isManifestParsingEnabled() {
   }
 
   @Override
-  public void applyOptions(Context context, GlideBuilder builder) {
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
     // Default empty impl.
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/module/AppliesOptions.java b/library/src/main/java/com/bumptech/glide/module/AppliesOptions.java
index 923d364f7..c92e0da64 100644
--- a/library/src/main/java/com/bumptech/glide/module/AppliesOptions.java
+++ b/library/src/main/java/com/bumptech/glide/module/AppliesOptions.java
@@ -1,11 +1,13 @@
 package com.bumptech.glide.module;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.GlideBuilder;
 
 /**
  * An internal interface, to be removed when {@link GlideModule}s are removed.
  */
+@Deprecated
 interface AppliesOptions {
   /**
    * Lazily apply options to a {@link com.bumptech.glide.GlideBuilder} immediately before the Glide
@@ -16,5 +18,5 @@
    * @param context An Application {@link android.content.Context}.
    * @param builder The {@link com.bumptech.glide.GlideBuilder} that will be used to create Glide.
    */
-  void applyOptions(Context context, GlideBuilder builder);
+  void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder);
 }
diff --git a/library/src/main/java/com/bumptech/glide/module/LibraryGlideModule.java b/library/src/main/java/com/bumptech/glide/module/LibraryGlideModule.java
index ccf368671..612dc8c13 100644
--- a/library/src/main/java/com/bumptech/glide/module/LibraryGlideModule.java
+++ b/library/src/main/java/com/bumptech/glide/module/LibraryGlideModule.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.module;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.Registry;
 
@@ -15,9 +16,11 @@
  * {@link com.bumptech.glide.annotation.Excludes} annotation to selectively remove one or more of
  * the conflicting modules.
  */
+@SuppressWarnings("deprecation")
 public abstract class LibraryGlideModule implements RegistersComponents {
   @Override
-  public void registerComponents(Context context, Glide glide, Registry registry) {
+  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry) {
     // Default empty impl.
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/module/ManifestParser.java b/library/src/main/java/com/bumptech/glide/module/ManifestParser.java
index 9b0eb69a8..6304f179a 100644
--- a/library/src/main/java/com/bumptech/glide/module/ManifestParser.java
+++ b/library/src/main/java/com/bumptech/glide/module/ManifestParser.java
@@ -4,12 +4,16 @@
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
 import android.util.Log;
+import java.lang.reflect.InvocationTargetException;
 import java.util.ArrayList;
 import java.util.List;
 
 /**
  * Parses {@link com.bumptech.glide.module.GlideModule} references out of the AndroidManifest file.
  */
+// Used only in javadoc.
+@SuppressWarnings("deprecation")
+@Deprecated
 public final class ManifestParser {
   private static final String TAG = "ManifestParser";
   private static final String GLIDE_MODULE_VALUE = "GlideModule";
@@ -65,16 +69,18 @@ private static GlideModule parseModule(String className) {
       throw new IllegalArgumentException("Unable to find GlideModule implementation", e);
     }
 
-    Object module;
+    Object module = null;
     try {
-      module = clazz.newInstance();
+      module = clazz.getDeclaredConstructor().newInstance();
+    // These can't be combined until API minimum is 19.
     } catch (InstantiationException e) {
-      throw new RuntimeException("Unable to instantiate GlideModule implementation for " + clazz,
-              e);
-      // These can't be combined until API minimum is 19.
+      throwInstantiateGlideModuleException(clazz, e);
     } catch (IllegalAccessException e) {
-      throw new RuntimeException("Unable to instantiate GlideModule implementation for " + clazz,
-              e);
+      throwInstantiateGlideModuleException(clazz, e);
+    } catch (NoSuchMethodException e) {
+      throwInstantiateGlideModuleException(clazz, e);
+    } catch (InvocationTargetException e) {
+      throwInstantiateGlideModuleException(clazz, e);
     }
 
     if (!(module instanceof GlideModule)) {
@@ -82,4 +88,8 @@ private static GlideModule parseModule(String className) {
     }
     return (GlideModule) module;
   }
+
+  private static void throwInstantiateGlideModuleException(Class<?> clazz, Exception e) {
+    throw new RuntimeException("Unable to instantiate GlideModule implementation for " + clazz, e);
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/module/RegistersComponents.java b/library/src/main/java/com/bumptech/glide/module/RegistersComponents.java
index f87a7409a..9461ee341 100644
--- a/library/src/main/java/com/bumptech/glide/module/RegistersComponents.java
+++ b/library/src/main/java/com/bumptech/glide/module/RegistersComponents.java
@@ -1,12 +1,16 @@
 package com.bumptech.glide.module;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.Registry;
 
 /**
  * An internal interface, to be removed when {@link GlideModule}s are removed.
  */
+// Used only in javadocs.
+@SuppressWarnings("deprecation")
+@Deprecated
 interface RegistersComponents {
 
   /**
@@ -19,5 +23,6 @@
    * @param glide The Glide singleton that is in the process of being initialized.
    * @param registry An {@link com.bumptech.glide.Registry} to use to register components.
    */
-  void registerComponents(Context context, Glide glide, Registry registry);
+  void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry);
 }
diff --git a/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java b/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java
index 1cc3bba81..ca5148a0f 100644
--- a/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.provider;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.util.Synthetic;
@@ -15,7 +16,7 @@
 
   @SuppressWarnings("unchecked")
   @Nullable
-  public synchronized <T> Encoder<T> getEncoder(Class<T> dataClass) {
+  public synchronized <T> Encoder<T> getEncoder(@NonNull Class<T> dataClass) {
     for (Entry<?> entry : encoders) {
       if (entry.handles(dataClass)) {
         return (Encoder<T>) entry.encoder;
@@ -24,24 +25,24 @@
     return null;
   }
 
-  public synchronized <T> void append(Class<T> dataClass, Encoder<T> encoder) {
+  public synchronized <T> void append(@NonNull Class<T> dataClass, @NonNull Encoder<T> encoder) {
     encoders.add(new Entry<>(dataClass, encoder));
   }
 
-  public synchronized <T> void prepend(Class<T> dataClass, Encoder<T> encoder) {
+  public synchronized <T> void prepend(@NonNull Class<T> dataClass, @NonNull Encoder<T> encoder) {
     encoders.add(0, new Entry<>(dataClass, encoder));
   }
 
   private static final class Entry<T> {
     private final Class<T> dataClass;
-    @Synthetic final Encoder<T> encoder;
+    @Synthetic @SuppressWarnings("WeakerAccess") final Encoder<T> encoder;
 
-    public Entry(Class<T> dataClass, Encoder<T> encoder) {
+    Entry(@NonNull Class<T> dataClass, @NonNull Encoder<T> encoder) {
       this.dataClass = dataClass;
       this.encoder = encoder;
     }
 
-    public boolean handles(Class<?> dataClass) {
+    boolean handles(@NonNull Class<?> dataClass) {
       return this.dataClass.isAssignableFrom(dataClass);
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/provider/ImageHeaderParserRegistry.java b/library/src/main/java/com/bumptech/glide/provider/ImageHeaderParserRegistry.java
index af329320e..902fc1bd4 100644
--- a/library/src/main/java/com/bumptech/glide/provider/ImageHeaderParserRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/provider/ImageHeaderParserRegistry.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.provider;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.ImageHeaderParser;
 import java.util.ArrayList;
 import java.util.List;
@@ -10,11 +11,12 @@
 public final class ImageHeaderParserRegistry {
   private final List<ImageHeaderParser> parsers = new ArrayList<>();
 
+  @NonNull
   public synchronized List<ImageHeaderParser> getParsers() {
     return parsers;
   }
 
-  public synchronized void add(ImageHeaderParser parser) {
+  public synchronized void add(@NonNull ImageHeaderParser parser) {
     parsers.add(parser);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/provider/LoadPathCache.java b/library/src/main/java/com/bumptech/glide/provider/LoadPathCache.java
index 6cc5d9630..89d2525af 100644
--- a/library/src/main/java/com/bumptech/glide/provider/LoadPathCache.java
+++ b/library/src/main/java/com/bumptech/glide/provider/LoadPathCache.java
@@ -2,8 +2,12 @@
 
 import android.support.annotation.Nullable;
 import android.support.v4.util.ArrayMap;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.DecodePath;
 import com.bumptech.glide.load.engine.LoadPath;
+import com.bumptech.glide.load.resource.transcode.UnitTranscoder;
 import com.bumptech.glide.util.MultiClassKey;
+import java.util.Collections;
 import java.util.concurrent.atomic.AtomicReference;
 
 /**
@@ -11,19 +15,38 @@
  * {@link com.bumptech.glide.load.engine.LoadPath}s capable of decoding with the requested types.
  */
 public class LoadPathCache {
+  private static final LoadPath<?, ?, ?> NO_PATHS_SIGNAL =
+      new LoadPath<>(
+          Object.class,
+          Object.class,
+          Object.class,
+          Collections.singletonList(
+              new DecodePath<>(
+                  Object.class,
+                  Object.class,
+                  Object.class,
+                  Collections.<ResourceDecoder<Object, Object>>emptyList(),
+                  new UnitTranscoder<>(),
+                  /*listPool=*/ null)),
+          /*listPool=*/ null);
+
   private final ArrayMap<MultiClassKey, LoadPath<?, ?, ?>> cache = new ArrayMap<>();
   private final AtomicReference<MultiClassKey> keyRef = new AtomicReference<>();
 
-  public boolean contains(Class<?> dataClass, Class<?> resourceClass, Class<?> transcodeClass) {
-    MultiClassKey key = getKey(dataClass, resourceClass, transcodeClass);
-    boolean result;
-    synchronized (cache) {
-      result = cache.containsKey(key);
-    }
-    keyRef.set(key);
-    return result;
+  /**
+   * Returns {@code} true if the given {@link LoadPath} is the signal object returned from
+   * {@link #get(Class, Class, Class)} that indicates that we've previously found that there are
+   * no available paths to load the requested resources and {@code false} otherwise.
+   */
+  public boolean isEmptyLoadPath(@Nullable LoadPath<?, ?, ?> path) {
+    return NO_PATHS_SIGNAL.equals(path);
   }
 
+  /**
+   * May return {@link #NO_PATHS_SIGNAL} to indicate that we've previously found that there are 0
+   * available load paths for the requested types. Callers must check using
+   * {@link #isEmptyLoadPath(LoadPath)} before using any load path returned by this method.
+   */
   @SuppressWarnings("unchecked")
   @Nullable
   public <Data, TResource, Transcode> LoadPath<Data, TResource, Transcode> get(
@@ -38,10 +61,14 @@ public boolean contains(Class<?> dataClass, Class<?> resourceClass, Class<?> tra
     return (LoadPath<Data, TResource, Transcode>) result;
   }
 
-  public void put(Class<?> dataClass, Class<?> resourceClass, Class<?> transcodeClass,
-      LoadPath<?, ?, ?> loadPath) {
+  public void put(
+      Class<?> dataClass, Class<?> resourceClass,
+      Class<?> transcodeClass,
+      @Nullable LoadPath<?, ?, ?> loadPath) {
     synchronized (cache) {
-      cache.put(new MultiClassKey(dataClass, resourceClass, transcodeClass), loadPath);
+      cache.put(
+          new MultiClassKey(dataClass, resourceClass, transcodeClass),
+          loadPath != null ? loadPath : NO_PATHS_SIGNAL);
     }
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/provider/ModelToResourceClassCache.java b/library/src/main/java/com/bumptech/glide/provider/ModelToResourceClassCache.java
index 076661dfa..ac417c13f 100644
--- a/library/src/main/java/com/bumptech/glide/provider/ModelToResourceClassCache.java
+++ b/library/src/main/java/com/bumptech/glide/provider/ModelToResourceClassCache.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.provider;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.support.v4.util.ArrayMap;
 import com.bumptech.glide.util.MultiClassKey;
@@ -16,7 +17,7 @@
       new ArrayMap<>();
 
   @Nullable
-  public List<Class<?>> get(Class<?> modelClass, Class<?> resourceClass) {
+  public List<Class<?>> get(@NonNull Class<?> modelClass, @NonNull Class<?> resourceClass) {
     MultiClassKey key = resourceClassKeyRef.getAndSet(null);
     if (key == null) {
       key = new MultiClassKey(modelClass, resourceClass);
@@ -25,13 +26,14 @@
     }
     final List<Class<?>> result;
     synchronized (registeredResourceClassCache) {
-       result = registeredResourceClassCache.get(key);
+      result = registeredResourceClassCache.get(key);
     }
     resourceClassKeyRef.set(key);
     return result;
   }
 
-  public void put(Class<?> modelClass, Class<?> resourceClass, List<Class<?>> resourceClasses) {
+  public void put(@NonNull Class<?> modelClass, @NonNull Class<?> resourceClass,
+      @NonNull List<Class<?>> resourceClasses) {
     synchronized (registeredResourceClassCache) {
       registeredResourceClassCache
           .put(new MultiClassKey(modelClass, resourceClass), resourceClasses);
diff --git a/library/src/main/java/com/bumptech/glide/provider/ResourceDecoderRegistry.java b/library/src/main/java/com/bumptech/glide/provider/ResourceDecoderRegistry.java
index b7e95fd40..bc3ce0d93 100644
--- a/library/src/main/java/com/bumptech/glide/provider/ResourceDecoderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/provider/ResourceDecoderRegistry.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.provider;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayList;
@@ -16,7 +17,7 @@
   private final List<String> bucketPriorityList = new ArrayList<>();
   private final Map<String, List<Entry<?, ?>>> decoders = new HashMap<>();
 
-  public synchronized void setBucketPriorityList(List<String> buckets) {
+  public synchronized void setBucketPriorityList(@NonNull List<String> buckets) {
     List<String> previousBuckets = new ArrayList<>(bucketPriorityList);
     bucketPriorityList.clear();
     bucketPriorityList.addAll(buckets);
@@ -29,9 +30,10 @@ public synchronized void setBucketPriorityList(List<String> buckets) {
     }
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
-  public synchronized <T, R> List<ResourceDecoder<T, R>> getDecoders(Class<T> dataClass,
-      Class<R> resourceClass) {
+  public synchronized <T, R> List<ResourceDecoder<T, R>> getDecoders(@NonNull Class<T> dataClass,
+      @NonNull Class<R> resourceClass) {
     List<ResourceDecoder<T, R>> result = new ArrayList<>();
     for (String bucket : bucketPriorityList) {
       List<Entry<?, ?>> entries = decoders.get(bucket);
@@ -49,9 +51,10 @@ public synchronized void setBucketPriorityList(List<String> buckets) {
     return result;
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
-  public synchronized <T, R> List<Class<R>> getResourceClasses(Class<T> dataClass,
-      Class<R> resourceClass) {
+  public synchronized <T, R> List<Class<R>> getResourceClasses(@NonNull Class<T> dataClass,
+      @NonNull Class<R> resourceClass) {
     List<Class<R>> result = new ArrayList<>();
     for (String bucket : bucketPriorityList) {
       List<Entry<?, ?>> entries = decoders.get(bucket);
@@ -59,7 +62,8 @@ public synchronized void setBucketPriorityList(List<String> buckets) {
         continue;
       }
       for (Entry<?, ?> entry : entries) {
-        if (entry.handles(dataClass, resourceClass)) {
+        if (entry.handles(dataClass, resourceClass)
+            && !result.contains((Class<R>) entry.resourceClass)) {
           result.add((Class<R>) entry.resourceClass);
         }
       }
@@ -67,17 +71,20 @@ public synchronized void setBucketPriorityList(List<String> buckets) {
     return result;
   }
 
-  public synchronized <T, R> void append(
-      String bucket, ResourceDecoder<T, R> decoder, Class<T> dataClass, Class<R> resourceClass) {
+  public synchronized <T, R> void append(@NonNull String bucket,
+      @NonNull ResourceDecoder<T, R> decoder,
+      @NonNull Class<T> dataClass, @NonNull Class<R> resourceClass) {
     getOrAddEntryList(bucket).add(new Entry<>(dataClass, resourceClass, decoder));
   }
 
-  public synchronized <T, R> void prepend(
-      String bucket, ResourceDecoder<T, R> decoder, Class<T> dataClass, Class<R> resourceClass) {
+  public synchronized <T, R> void prepend(@NonNull String bucket,
+      @NonNull ResourceDecoder<T, R> decoder,
+      @NonNull Class<T> dataClass, @NonNull Class<R> resourceClass) {
     getOrAddEntryList(bucket).add(0, new Entry<>(dataClass, resourceClass, decoder));
   }
 
-  private synchronized List<Entry<?, ?>> getOrAddEntryList(String bucket) {
+  @NonNull
+  private synchronized List<Entry<?, ?>> getOrAddEntryList(@NonNull String bucket) {
     if (!bucketPriorityList.contains(bucket)) {
       // Add this unspecified bucket as a low priority bucket.
       bucketPriorityList.add(bucket);
@@ -95,13 +102,14 @@ public synchronized void setBucketPriorityList(List<String> buckets) {
     @Synthetic final Class<R> resourceClass;
     @Synthetic final ResourceDecoder<T, R> decoder;
 
-    public Entry(Class<T> dataClass, Class<R> resourceClass, ResourceDecoder<T, R> decoder) {
+    public Entry(@NonNull Class<T> dataClass, @NonNull Class<R> resourceClass,
+        ResourceDecoder<T, R> decoder) {
       this.dataClass = dataClass;
       this.resourceClass = resourceClass;
       this.decoder = decoder;
     }
 
-    public boolean handles(Class<?> dataClass, Class<?> resourceClass) {
+    public boolean handles(@NonNull Class<?> dataClass, @NonNull Class<?> resourceClass) {
       return this.dataClass.isAssignableFrom(dataClass) && resourceClass
           .isAssignableFrom(this.resourceClass);
     }
diff --git a/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java b/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java
index a0e9e32d2..b1bd2977a 100644
--- a/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.provider;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import com.bumptech.glide.load.ResourceEncoder;
 import com.bumptech.glide.util.Synthetic;
@@ -12,21 +13,23 @@
  */
 public class ResourceEncoderRegistry {
   // TODO: this should probably be a put.
-  final List<Entry<?>> encoders = new ArrayList<>();
+  private final List<Entry<?>> encoders = new ArrayList<>();
 
-  public synchronized <Z> void append(Class<Z> resourceClass, ResourceEncoder<Z> encoder) {
+  public synchronized <Z> void append(@NonNull Class<Z> resourceClass,
+      @NonNull ResourceEncoder<Z> encoder) {
     encoders.add(new Entry<>(resourceClass, encoder));
   }
 
-  public synchronized <Z> void prepend(Class<Z> resourceClass, ResourceEncoder<Z> encoder) {
+  public synchronized <Z> void prepend(@NonNull Class<Z> resourceClass,
+      @NonNull ResourceEncoder<Z> encoder) {
     encoders.add(0, new Entry<>(resourceClass, encoder));
   }
 
   @SuppressWarnings("unchecked")
   @Nullable
-  public synchronized <Z> ResourceEncoder<Z> get(Class<Z> resourceClass) {
-    int size = encoders.size();
-    for (int i = 0; i < size; i++) {
+  public synchronized <Z> ResourceEncoder<Z> get(@NonNull Class<Z> resourceClass) {
+    //noinspection ForLoopReplaceableByForEach to improve perf
+    for (int i = 0, size = encoders.size(); i < size; i++) {
       Entry<?> entry = encoders.get(i);
       if (entry.handles(resourceClass)) {
         return (ResourceEncoder<Z>) entry.encoder;
@@ -40,13 +43,13 @@
     private final Class<T> resourceClass;
     @Synthetic final ResourceEncoder<T> encoder;
 
-    Entry(Class<T> resourceClass, ResourceEncoder<T> encoder) {
+    Entry(@NonNull Class<T> resourceClass, @NonNull ResourceEncoder<T> encoder) {
       this.resourceClass = resourceClass;
       this.encoder = encoder;
     }
 
     @Synthetic
-    boolean handles(Class<?> resourceClass) {
+    boolean handles(@NonNull Class<?> resourceClass) {
       return this.resourceClass.isAssignableFrom(resourceClass);
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java b/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java
new file mode 100644
index 000000000..cd6a43151
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java
@@ -0,0 +1,158 @@
+package com.bumptech.glide.request;
+
+import android.support.annotation.Nullable;
+
+/**
+ * Runs a single primary {@link Request} until it completes and then a fallback error request only
+ * if the single primary request fails.
+ */
+public final class ErrorRequestCoordinator implements RequestCoordinator,
+    Request {
+
+  @Nullable
+  private final RequestCoordinator parent;
+  private Request primary;
+  private Request error;
+
+  public ErrorRequestCoordinator(@Nullable RequestCoordinator parent) {
+    this.parent = parent;
+  }
+
+  public void setRequests(Request primary, Request error) {
+    this.primary = primary;
+    this.error = error;
+  }
+
+  @Override
+  public void begin() {
+    if (!primary.isRunning()) {
+      primary.begin();
+    }
+  }
+
+  @Override
+  public void pause() {
+    if (!primary.isFailed()) {
+      primary.pause();
+    }
+    if (error.isRunning()) {
+      error.pause();
+    }
+  }
+
+  @Override
+  public void clear() {
+    primary.clear();
+    // Don't check primary.isFailed() here because it will have been reset by the clear call
+    // immediately before this.
+    if (error.isRunning()) {
+      error.clear();
+    }
+  }
+
+  @Override
+  public boolean isPaused() {
+    return primary.isFailed() ? error.isPaused() : primary.isPaused();
+  }
+
+  @Override
+  public boolean isRunning() {
+    return primary.isFailed() ? error.isRunning() : primary.isRunning();
+  }
+
+  @Override
+  public boolean isComplete() {
+    return primary.isFailed() ? error.isComplete() : primary.isComplete();
+  }
+
+  @Override
+  public boolean isResourceSet() {
+    return primary.isFailed() ? error.isResourceSet() : primary.isResourceSet();
+  }
+
+  @Override
+  public boolean isCancelled() {
+    return primary.isFailed() ? error.isCancelled() : primary.isCancelled();
+  }
+
+  @Override
+  public boolean isFailed() {
+    return primary.isFailed() && error.isFailed();
+  }
+
+  @Override
+  public void recycle() {
+    primary.recycle();
+    error.recycle();
+  }
+
+  @Override
+  public boolean isEquivalentTo(Request o) {
+    if (o instanceof ErrorRequestCoordinator) {
+      ErrorRequestCoordinator other = (ErrorRequestCoordinator) o;
+      return primary.isEquivalentTo(other.primary) && error.isEquivalentTo(other.error);
+    }
+    return false;
+  }
+
+  @Override
+  public boolean canSetImage(Request request) {
+    return parentCanSetImage() && isValidRequest(request);
+  }
+
+  private boolean parentCanSetImage() {
+    return parent == null || parent.canSetImage(this);
+  }
+
+  @Override
+  public boolean canNotifyStatusChanged(Request request) {
+    return parentCanNotifyStatusChanged() && isValidRequest(request);
+  }
+
+  @Override
+  public boolean canNotifyCleared(Request request) {
+    return parentCanNotifyCleared() && isValidRequest(request);
+  }
+
+  private boolean parentCanNotifyCleared() {
+    return parent == null || parent.canNotifyCleared(this);
+  }
+
+  private boolean parentCanNotifyStatusChanged() {
+    return parent == null || parent.canNotifyStatusChanged(this);
+  }
+
+  private boolean isValidRequest(Request request) {
+    return request.equals(primary) || (primary.isFailed() && request.equals(error));
+  }
+
+  @Override
+  public boolean isAnyResourceSet() {
+    return parentIsAnyResourceSet() || isResourceSet();
+  }
+
+  private boolean parentIsAnyResourceSet() {
+    return parent != null && parent.isAnyResourceSet();
+  }
+
+  @Override
+  public void onRequestSuccess(Request request) {
+    if (parent != null) {
+      parent.onRequestSuccess(this);
+    }
+  }
+
+  @Override
+  public void onRequestFailed(Request request) {
+    if (!request.equals(error)) {
+      if (!error.isRunning()) {
+        error.begin();
+      }
+      return;
+    }
+
+    if (parent != null) {
+      parent.onRequestFailed(this);
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/Request.java b/library/src/main/java/com/bumptech/glide/request/Request.java
index 7427ca434..ad89792fb 100644
--- a/library/src/main/java/com/bumptech/glide/request/Request.java
+++ b/library/src/main/java/com/bumptech/glide/request/Request.java
@@ -62,10 +62,10 @@
    * Returns {@code true} if this {@link Request} is equivalent to the given {@link Request} (has
    * all of the same options and sizes).
    *
-   * <p>This method is identical to {@link #equals(Object)} except that it's specific to
-   * {@link Request} subclasses. We do not use {@link #equals(Object)} directly because we track
-   * {@link Request}s in collections like {@link java.util.Set} and it's perfectly legitimate to
-   * have two different {@link Request} objects for two different
+   * <p>This method is identical to {@link Object#equals(Object)} except that it's specific to
+   * {@link Request} subclasses. We do not use {@link Object#equals(Object)} directly because we
+   * track {@link Request}s in collections like {@link java.util.Set} and it's perfectly legitimate
+   * to have two different {@link Request} objects for two different
    * {@link com.bumptech.glide.request.target.Target}s (for example). Using a similar but different
    * method let's us selectively compare {@link Request} objects to each other when it's useful in
    * specific scenarios.
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestCoordinator.java b/library/src/main/java/com/bumptech/glide/request/RequestCoordinator.java
index 2143366eb..4aa69b394 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestCoordinator.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestCoordinator.java
@@ -20,6 +20,12 @@
    */
   boolean canNotifyStatusChanged(Request request);
 
+  /**
+   * Returns {@code true} if the {@link Request} can clear the
+   * {@link com.bumptech.glide.request.target.Target}.
+   */
+  boolean canNotifyCleared(Request request);
+
   /**
    * Returns true if any coordinated {@link Request} has successfully completed.
    *
@@ -28,7 +34,10 @@
   boolean isAnyResourceSet();
 
   /**
-   * Must be called when a request coordinated by this object completes successfully.
+   * Must be called when a {@link Request} coordinated by this object completes successfully.
    */
   void onRequestSuccess(Request request);
+
+  /** Must be called when a {@link Request} coordinated by this object fails. */
+  void onRequestFailed(Request request);
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java b/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
index e5a1ec152..77dad3e09 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
@@ -2,8 +2,13 @@
 
 import android.graphics.drawable.Drawable;
 import android.os.Handler;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.GlideException;
 import com.bumptech.glide.request.target.SizeReadyCallback;
+import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.util.Util;
 import java.util.concurrent.CancellationException;
@@ -47,6 +52,7 @@
  * @param <R> The type of the resource that will be loaded.
  */
 public class RequestFutureTarget<R> implements FutureTarget<R>,
+    RequestListener<R>,
     Runnable {
   private static final Waiter DEFAULT_WAITER = new Waiter();
 
@@ -62,6 +68,7 @@
   private boolean isCancelled;
   private boolean resultReceived;
   private boolean loadFailed;
+  @Nullable private GlideException exception;
 
   /**
    * Constructor for a RequestFutureTarget. Should not be used directly.
@@ -112,7 +119,7 @@ public R get() throws InterruptedException, ExecutionException {
   }
 
   @Override
-  public R get(long time, TimeUnit timeUnit)
+  public R get(long time, @NonNull TimeUnit timeUnit)
       throws InterruptedException, ExecutionException, TimeoutException {
     return doGet(timeUnit.toMillis(time));
   }
@@ -121,18 +128,15 @@ public R get(long time, TimeUnit timeUnit)
    * A callback that should never be invoked directly.
    */
   @Override
-  public void getSize(SizeReadyCallback cb) {
+  public void getSize(@NonNull SizeReadyCallback cb) {
     cb.onSizeReady(width, height);
   }
 
   @Override
-  public void removeCallback(SizeReadyCallback cb) {
+  public void removeCallback(@NonNull SizeReadyCallback cb) {
     // Do nothing because we do not retain references to SizeReadyCallbacks.
   }
 
-  /**
-   * {@inheritDoc}
-   */
   @Override
   public void setRequest(@Nullable Request request) {
     this.request = request;
@@ -148,7 +152,7 @@ public Request getRequest() {
    * A callback that should never be invoked directly.
    */
   @Override
-  public void onLoadCleared(Drawable placeholder) {
+  public void onLoadCleared(@Nullable Drawable placeholder) {
     // Do nothing.
   }
 
@@ -156,7 +160,7 @@ public void onLoadCleared(Drawable placeholder) {
    * A callback that should never be invoked directly.
    */
   @Override
-  public void onLoadStarted(Drawable placeholder) {
+  public void onLoadStarted(@Nullable Drawable placeholder) {
     // Do nothing.
   }
 
@@ -164,20 +168,17 @@ public void onLoadStarted(Drawable placeholder) {
    * A callback that should never be invoked directly.
    */
   @Override
-  public synchronized void onLoadFailed(Drawable errorDrawable) {
-    loadFailed = true;
-    waiter.notifyAll(this);
+  public synchronized void onLoadFailed(@Nullable Drawable errorDrawable) {
+    // Ignored, synchronized for backwards compatibility.
   }
 
   /**
    * A callback that should never be invoked directly.
    */
   @Override
-  public synchronized void onResourceReady(R resource, Transition<? super R> transition) {
-    // We might get a null result.
-    resultReceived = true;
-    this.resource = resource;
-    waiter.notifyAll(this);
+  public synchronized void onResourceReady(@NonNull R resource,
+      @Nullable Transition<? super R> transition) {
+    // Ignored, synchronized for backwards compatibility.
   }
 
   private synchronized R doGet(Long timeoutMillis)
@@ -189,7 +190,7 @@ private synchronized R doGet(Long timeoutMillis)
     if (isCancelled) {
       throw new CancellationException();
     } else if (loadFailed) {
-      throw new ExecutionException(new IllegalStateException("Load failed"));
+      throw new ExecutionException(exception);
     } else if (resultReceived) {
       return resource;
     }
@@ -197,13 +198,18 @@ private synchronized R doGet(Long timeoutMillis)
     if (timeoutMillis == null) {
       waiter.waitForTimeout(this, 0);
     } else if (timeoutMillis > 0) {
-      waiter.waitForTimeout(this, timeoutMillis);
+      long now = System.currentTimeMillis();
+      long deadline = now + timeoutMillis;
+      while (!isDone() && now < deadline) {
+        waiter.waitForTimeout(this, deadline - now);
+        now = System.currentTimeMillis();
+      }
     }
 
     if (Thread.interrupted()) {
       throw new InterruptedException();
     } else if (loadFailed) {
-      throw new ExecutionException(new IllegalStateException("Load failed"));
+      throw new ExecutionException(exception);
     } else if (isCancelled) {
       throw new CancellationException();
     } else if (!resultReceived) {
@@ -243,14 +249,35 @@ public void onDestroy() {
     // Do nothing.
   }
 
-  // Visible for testing.
-  static class Waiter {
+  @Override
+  public synchronized boolean onLoadFailed(
+      @Nullable GlideException e, Object model, Target<R> target, boolean isFirstResource) {
+    loadFailed = true;
+    exception = e;
+    waiter.notifyAll(this);
+    return false;
+  }
+
+  @Override
+  public synchronized boolean onResourceReady(
+      R resource, Object model, Target<R> target, DataSource dataSource, boolean isFirstResource) {
+    // We might get a null result.
+    resultReceived = true;
+    this.resource = resource;
+    waiter.notifyAll(this);
+    return false;
+  }
 
-    public void waitForTimeout(Object toWaitOn, long timeoutMillis) throws InterruptedException {
+  @VisibleForTesting
+  static class Waiter {
+    // This is a simple wrapper class that is used to enable testing. The call to the wrapping class
+    // is waited on appropriately.
+    @SuppressWarnings("WaitNotInLoop")
+    void waitForTimeout(Object toWaitOn, long timeoutMillis) throws InterruptedException {
       toWaitOn.wait(timeoutMillis);
     }
 
-    public void notifyAll(Object toNotify) {
+    void notifyAll(Object toNotify) {
       toNotify.notifyAll();
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestListener.java b/library/src/main/java/com/bumptech/glide/request/RequestListener.java
index a6156b495..74b33246c 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestListener.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestListener.java
@@ -2,6 +2,7 @@
 
 import android.graphics.drawable.Drawable;
 import android.support.annotation.Nullable;
+import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.engine.GlideException;
 import com.bumptech.glide.request.target.Target;
@@ -18,33 +19,38 @@
    * {@link Target#onLoadFailed(Drawable)}. Will only be called if we currently want to display an
    * image for the given model in the given target. It is recommended to create a single instance
    * per activity/fragment rather than instantiate a new object for each call to {@code
-   * Glide.load()} to avoid object churn.
+   * Glide.with(fragment/activity).load()} to avoid object churn.
    *
-   * <p> It is safe to reload this or a different model or change what is displayed in the target at
-   * this point. For example:
+   * <p>It is not safe to reload this or a different model in this callback. If you need to do so
+   * use {@link com.bumptech.glide.RequestBuilder#error(RequestBuilder)} instead.
+   *
+   * <p>Although you can't start an entirely new load, it is safe to change what is displayed in the
+   * {@link Target} at this point, as long as you return {@code true} from the method to prevent
+   * {@link Target#onLoadFailed(Drawable)} from being called.
+   *
+   * For example:
    * <pre>
    * {@code
-   * public void onLoadFailed(Exception e, T model, Target target, boolean isFirstResource) {
+   * public boolean onLoadFailed(Exception e, T model, Target target, boolean isFirstResource) {
    *     target.setPlaceholder(R.drawable.a_specific_error_for_my_exception);
-   *     Glide.load(model).into(target);
+   *     return true; // Prevent onLoadFailed from being called on the Target.
    * }
    * }
    * </pre>
    * </p>
    *
-   * <p> Note - if you want to reload this or any other model after an exception, you will need to
-   * include all relevant builder calls (like centerCrop, placeholder etc).
-   *
    * @param e               The maybe {@code null} exception containing information about why the
    *                        request failed.
    * @param model           The model we were trying to load when the exception occurred.
    * @param target          The {@link Target} we were trying to load the image into.
    * @param isFirstResource {@code true} if this exception is for the first resource to load.
-   * @return {@code true} if the listener has handled updating the target for the given exception,
-   *         {@code false} to allow Glide's request to update the target.
+   * @return {@code true} to prevent {@link Target#onLoadFailed(Drawable)} from being called on
+   * {@code target}, typically because the listener wants to update the {@code target} or the object
+   * the {@code target} wraps itself or {@code false} to allow {@link Target#onLoadFailed(Drawable)}
+   * to be called on {@code target}.
    */
-  boolean onLoadFailed(@Nullable GlideException e, Object model, Target<R> target,
-      boolean isFirstResource);
+  boolean onLoadFailed(
+      @Nullable GlideException e, Object model, Target<R> target, boolean isFirstResource);
 
   /**
    * Called when a load completes successfully, immediately before {@link
@@ -58,10 +64,12 @@ boolean onLoadFailed(@Nullable GlideException e, Object model, Target<R> target,
    *                          loaded into the target. For example when loading a thumbnail and a
    *                          full-sized image, this will be {@code true} for the first image to
    *                          load and {@code false} for the second.
-   * @return {@code true} if the listener has handled setting the resource on the target,
-   *         {@code false} to allow Glide's request to update the target.
-   *         Setting the resource includes handling animations, be sure to take that into account.
+   *
+   * @return {@code true} to prevent {@link Target#onLoadFailed(Drawable)} from being called on
+   * {@code target}, typically because the listener wants to update the {@code target} or the object
+   * the {@code target} wraps itself or {@code false} to allow {@link Target#onLoadFailed(Drawable)}
+   * to be called on {@code target}.
    */
-  boolean onResourceReady(R resource, Object model, Target<R> target, DataSource dataSource,
-      boolean isFirstResource);
+  boolean onResourceReady(
+      R resource, Object model, Target<R> target, DataSource dataSource, boolean isFirstResource);
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
index a5cbcc053..4e416b649 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
@@ -5,6 +5,9 @@
 import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
 import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import com.bumptech.glide.Priority;
@@ -16,19 +19,18 @@
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
 import com.bumptech.glide.load.model.stream.HttpGlideUrlLoader;
-import com.bumptech.glide.load.resource.bitmap.BitmapDrawableTransformation;
 import com.bumptech.glide.load.resource.bitmap.BitmapEncoder;
 import com.bumptech.glide.load.resource.bitmap.CenterCrop;
 import com.bumptech.glide.load.resource.bitmap.CenterInside;
 import com.bumptech.glide.load.resource.bitmap.CircleCrop;
 import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
 import com.bumptech.glide.load.resource.bitmap.Downsampler;
+import com.bumptech.glide.load.resource.bitmap.DrawableTransformation;
 import com.bumptech.glide.load.resource.bitmap.FitCenter;
-import com.bumptech.glide.load.resource.bitmap.VideoBitmapDecoder;
-import com.bumptech.glide.load.resource.gif.ByteBufferGifDecoder;
+import com.bumptech.glide.load.resource.bitmap.VideoDecoder;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 import com.bumptech.glide.load.resource.gif.GifDrawableTransformation;
-import com.bumptech.glide.load.resource.gif.StreamGifDecoder;
+import com.bumptech.glide.load.resource.gif.GifOptions;
 import com.bumptech.glide.signature.EmptySignature;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Util;
@@ -60,6 +62,7 @@
   private static final int TRANSFORMATION_REQUIRED = 1 << 17;
   private static final int USE_UNLIMITED_SOURCE_GENERATORS_POOL = 1 << 18;
   private static final int ONLY_RETRIEVE_FROM_CACHE = 1 << 19;
+  private static final int USE_ANIMATION_POOL = 1 << 20;
 
   @Nullable
   private static RequestOptions skipMemoryCacheTrueOptions;
@@ -113,19 +116,23 @@
   private boolean useUnlimitedSourceGeneratorsPool;
   private boolean onlyRetrieveFromCache;
   private boolean isScaleOnlyOrNoTransform = true;
+  private boolean useAnimationPool;
 
   /**
    * Returns a {@link RequestOptions} object with {@link #sizeMultiplier(float)} set.
    */
   @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
   @CheckResult
-  public static RequestOptions sizeMultiplierOf(float sizeMultiplier) {
+  public static RequestOptions sizeMultiplierOf(
+      @FloatRange(from = 0, to = 1) float sizeMultiplier) {
     return new RequestOptions().sizeMultiplier(sizeMultiplier);
   }
 
   /**
    * Returns a {@link RequestOptions} object with {@link #diskCacheStrategy(DiskCacheStrategy)} set.
    */
+  @NonNull
   @CheckResult
   public static RequestOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy diskCacheStrategy) {
     return new RequestOptions().diskCacheStrategy(diskCacheStrategy);
@@ -135,6 +142,7 @@ public static RequestOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy disk
    * Returns a {@link RequestOptions} object with {@link #priority(Priority)}} set.
    */
   @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
   @CheckResult
   public static RequestOptions priorityOf(@NonNull Priority priority) {
     return new RequestOptions().priority(priority);
@@ -143,6 +151,7 @@ public static RequestOptions priorityOf(@NonNull Priority priority) {
   /**
    * Returns a {@link RequestOptions} object with {@link #placeholder(Drawable)} set.
    */
+  @NonNull
   @CheckResult
   public static RequestOptions placeholderOf(@Nullable Drawable placeholder) {
     return new RequestOptions().placeholder(placeholder);
@@ -151,14 +160,16 @@ public static RequestOptions placeholderOf(@Nullable Drawable placeholder) {
   /**
    * Returns a {@link RequestOptions} object with {@link #placeholder(int)} set.
    */
+  @NonNull
   @CheckResult
-  public static RequestOptions placeholderOf(int placeholderId) {
+  public static RequestOptions placeholderOf(@DrawableRes int placeholderId) {
     return new RequestOptions().placeholder(placeholderId);
   }
 
   /**
    * Returns a {@link RequestOptions} object with {@link #error(Drawable)} set.
    */
+  @NonNull
   @CheckResult
   public static RequestOptions errorOf(@Nullable Drawable errorDrawable) {
     return new RequestOptions().error(errorDrawable);
@@ -167,14 +178,16 @@ public static RequestOptions errorOf(@Nullable Drawable errorDrawable) {
   /**
    * Returns a {@link RequestOptions} object with {@link #error(int)}} set.
    */
+  @NonNull
   @CheckResult
-  public static RequestOptions errorOf(int errorId) {
+  public static RequestOptions errorOf(@DrawableRes int errorId) {
     return new RequestOptions().error(errorId);
   }
 
   /**
    * Returns a {@link RequestOptions} object with {@link #skipMemoryCache(boolean)} set.
    */
+  @NonNull
   @CheckResult
   public static RequestOptions skipMemoryCacheOf(boolean skipMemoryCache) {
     if (skipMemoryCache) {
@@ -194,8 +207,11 @@ public static RequestOptions skipMemoryCacheOf(boolean skipMemoryCache) {
    * Returns a {@link RequestOptions} object with {@link #override(int, int)}} set.
    */
   @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
   @CheckResult
-  public static RequestOptions overrideOf(int width, int height) {
+  public static RequestOptions overrideOf(
+      @IntRange(from = 0) int width,
+      @IntRange(from = 0) int height) {
     return new RequestOptions().override(width, height);
   }
 
@@ -204,14 +220,16 @@ public static RequestOptions overrideOf(int width, int height) {
    * height are the given size.
    */
   @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
   @CheckResult
-  public static RequestOptions overrideOf(int size) {
+  public static RequestOptions overrideOf(@IntRange(from = 0) int size) {
     return overrideOf(size, size);
   }
 
   /**
    * Returns a {@link RequestOptions} object with {@link #signature} set.
    */
+  @NonNull
   @CheckResult
   public static RequestOptions signatureOf(@NonNull Key signature) {
     return new RequestOptions().signature(signature);
@@ -220,6 +238,7 @@ public static RequestOptions signatureOf(@NonNull Key signature) {
   /**
    * Returns a {@link RequestOptions} object with {@link #fitCenter()} set.
    */
+  @NonNull
   @CheckResult
   public static RequestOptions fitCenterTransform() {
     if (fitCenterOptions == null) {
@@ -234,6 +253,7 @@ public static RequestOptions fitCenterTransform() {
    * Returns a {@link RequestOptions} object with {@link #centerInside()} set.
    */
   @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
   @CheckResult
   public static RequestOptions centerInsideTransform() {
     if (centerInsideOptions == null) {
@@ -248,6 +268,7 @@ public static RequestOptions centerInsideTransform() {
    * Returns a {@link RequestOptions} object with {@link #centerCrop()} set.
    */
   @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
   @CheckResult
   public static RequestOptions centerCropTransform() {
     if (centerCropOptions == null) {
@@ -262,6 +283,7 @@ public static RequestOptions centerCropTransform() {
    * Returns a {@link RequestOptions} object with {@link RequestOptions#circleCrop()} set.
    */
   @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
   @CheckResult
   public static RequestOptions circleCropTransform() {
     if (circleCropOptions == null) {
@@ -276,6 +298,7 @@ public static RequestOptions circleCropTransform() {
    * Returns a {@link RequestOptions} object with {@link #transform(Transformation)} set.
    */
   @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
   @CheckResult
   public static RequestOptions bitmapTransform(@NonNull Transformation<Bitmap> transformation) {
     return new RequestOptions().transform(transformation);
@@ -285,6 +308,7 @@ public static RequestOptions bitmapTransform(@NonNull Transformation<Bitmap> tra
    * Returns a {@link RequestOptions} object with {@link #dontTransform()} set.
    */
   @SuppressWarnings("WeakerAccess")
+  @NonNull
   @CheckResult
   public static RequestOptions noTransformation() {
     if (noTransformOptions == null) {
@@ -299,6 +323,7 @@ public static RequestOptions noTransformation() {
    * Returns a {@link RequestOptions} object with the given {@link Option} set via
    * {@link #set(Option, Object)}.
    */
+  @NonNull
   @CheckResult
   public static <T> RequestOptions option(@NonNull Option<T> option, @NonNull T value) {
     return new RequestOptions().set(option, value);
@@ -307,6 +332,7 @@ public static RequestOptions noTransformation() {
   /**
    * Returns a {@link RequestOptions} object with {@link #decode(Class)} set.
    */
+  @NonNull
   @CheckResult
   public static RequestOptions decodeTypeOf(@NonNull Class<?> resourceClass) {
     return new RequestOptions().decode(resourceClass);
@@ -316,6 +342,7 @@ public static RequestOptions decodeTypeOf(@NonNull Class<?> resourceClass) {
    * Returns a {@link RequestOptions} object with {@link #format(DecodeFormat)} set.
    */
   @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
   @CheckResult
   public static RequestOptions formatOf(@NonNull DecodeFormat format) {
     return new RequestOptions().format(format);
@@ -325,8 +352,9 @@ public static RequestOptions formatOf(@NonNull DecodeFormat format) {
    * Returns a {@link RequestOptions} object with {@link #frame(long)} set.
    */
   @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
   @CheckResult
-  public static RequestOptions frameOf(long frameTimeMicros) {
+  public static RequestOptions frameOf(@IntRange(from = 0) long frameTimeMicros) {
     return new RequestOptions().frame(frameTimeMicros);
   }
 
@@ -334,6 +362,7 @@ public static RequestOptions frameOf(long frameTimeMicros) {
    * Returns a {@link RequestOptions} object with {@link #downsample(DownsampleStrategy)} set.
    */
   @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
   @CheckResult
   public static RequestOptions downsampleOf(@NonNull DownsampleStrategy strategy) {
     return new RequestOptions().downsample(strategy);
@@ -342,8 +371,9 @@ public static RequestOptions downsampleOf(@NonNull DownsampleStrategy strategy)
   /**
    * Returns a {@link RequestOptions} object with {@link #timeout(int)} set.
    */
+  @NonNull
   @CheckResult
-  public static RequestOptions timeoutOf(int timeout) {
+  public static RequestOptions timeoutOf(@IntRange(from = 0) int timeout) {
     return new RequestOptions().timeout(timeout);
   }
 
@@ -352,8 +382,9 @@ public static RequestOptions timeoutOf(int timeout) {
    * #encodeQuality(int)} called with the given quality.
    */
   @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
   @CheckResult
-  public static RequestOptions encodeQualityOf(int quality) {
+  public static RequestOptions encodeQualityOf(@IntRange(from = 0, to = 100) int quality) {
     return new RequestOptions().encodeQuality(quality);
   }
 
@@ -362,6 +393,7 @@ public static RequestOptions encodeQualityOf(int quality) {
    * #encodeFormat(android.graphics.Bitmap.CompressFormat)} called with the given format.
    */
   @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
   @CheckResult
   public static RequestOptions encodeFormatOf(@NonNull Bitmap.CompressFormat format) {
     return new RequestOptions().encodeFormat(format);
@@ -372,6 +404,7 @@ public static RequestOptions encodeFormatOf(@NonNull Bitmap.CompressFormat forma
    * called.
    */
   @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
   @CheckResult
   public static RequestOptions noAnimation() {
     if (noAnimationOptions == null) {
@@ -396,8 +429,9 @@ private static boolean isSet(int fields, int flag) {
    *                       loading the resource.
    * @return This request builder.
    */
+  @NonNull
   @CheckResult
-  public RequestOptions sizeMultiplier(float sizeMultiplier) {
+  public RequestOptions sizeMultiplier(@FloatRange(from = 0, to = 1) float sizeMultiplier) {
     if (isAutoCloneEnabled) {
       return clone().sizeMultiplier(sizeMultiplier);
     }
@@ -411,6 +445,19 @@ public RequestOptions sizeMultiplier(float sizeMultiplier) {
     return selfOrThrowIfLocked();
   }
 
+  /**
+   * If set to {@code true}, uses a cached unlimited {@link java.util.concurrent.Executor} to run
+   * the request.
+   *
+   * <p>This method should <em>ONLY</em> be used when a Glide load is started recursively on one
+   * of Glide's threads as part of another request. Using this method in other scenarios can lead
+   * to excessive memory usage and OOMs and/or a significant decrease in performance across an
+   * application.
+   *
+   * <p>If both this method and {@link #useAnimationPool(boolean)} are set, this method will be
+   * preferred and {@link #useAnimationPool(boolean)} will be ignored.
+   */
+  @NonNull
   @CheckResult
   public RequestOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
     if (isAutoCloneEnabled) {
@@ -424,8 +471,36 @@ public RequestOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
   }
 
   /**
+   * If set to {@code true}, uses a special {@link java.util.concurrent.Executor} that is used
+   * exclusively for decoding frames of animated resources, like GIFs.
+   *
+   * <p>The animation executor disallows network operations and must not be used for loads that
+   * may load remote data. The animation executor has fewer threads available to it than Glide's
+   * normal executors and is only useful as a way of avoiding blocking on longer and more expensive
+   * reads for critical requests like those in an animating GIF.
+   *
+   * <p>If both {@link #useUnlimitedSourceGeneratorsPool(boolean)} and this method are set,
+   * {@link #useUnlimitedSourceGeneratorsPool(boolean)} will be preferred and this method will be
+   * ignored.
+   */
+  @NonNull
+  @CheckResult
+  public RequestOptions useAnimationPool(boolean flag) {
+    if (isAutoCloneEnabled) {
+      return clone().useAnimationPool(flag);
+    }
+
+    useAnimationPool = flag;
+    fields |= USE_ANIMATION_POOL;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   *
    * If set to true, will only load an item if found in the cache, and will not fetch from source.
    */
+  @NonNull
   @CheckResult
   public RequestOptions onlyRetrieveFromCache(boolean flag) {
     if (isAutoCloneEnabled) {
@@ -452,6 +527,7 @@ public RequestOptions onlyRetrieveFromCache(boolean flag) {
    * @param strategy The strategy to use.
    * @return This request builder.
    */
+  @NonNull
   @CheckResult
   public RequestOptions diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
     if (isAutoCloneEnabled) {
@@ -469,6 +545,7 @@ public RequestOptions diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
    * @param priority A priority.
    * @return This request builder.
    */
+  @NonNull
   @CheckResult
   public RequestOptions priority(@NonNull Priority priority) {
     if (isAutoCloneEnabled) {
@@ -487,6 +564,7 @@ public RequestOptions priority(@NonNull Priority priority) {
    * @param drawable The drawable to display as a placeholder.
    * @return This request builder.
    */
+  @NonNull
   @CheckResult
   public RequestOptions placeholder(@Nullable Drawable drawable) {
     if (isAutoCloneEnabled) {
@@ -506,8 +584,9 @@ public RequestOptions placeholder(@Nullable Drawable drawable) {
    * @param resourceId The id of the resource to use as a placeholder
    * @return This request builder.
    */
+  @NonNull
   @CheckResult
-  public RequestOptions placeholder(int resourceId) {
+  public RequestOptions placeholder(@DrawableRes int resourceId) {
     if (isAutoCloneEnabled) {
       return clone().placeholder(resourceId);
     }
@@ -531,8 +610,9 @@ public RequestOptions placeholder(int resourceId) {
    * @param drawable The drawable to display as a placeholder.
    * @return This request builder.
    */
+  @NonNull
   @CheckResult
-  public RequestOptions fallback(Drawable drawable) {
+  public RequestOptions fallback(@Nullable Drawable drawable) {
     if (isAutoCloneEnabled) {
       return clone().fallback(drawable);
     }
@@ -556,8 +636,9 @@ public RequestOptions fallback(Drawable drawable) {
    * @param resourceId The id of the resource to use as a fallback.
    * @return This request builder.
    */
+  @NonNull
   @CheckResult
-  public RequestOptions fallback(int resourceId) {
+  public RequestOptions fallback(@DrawableRes int resourceId) {
     if (isAutoCloneEnabled) {
       return clone().fallback(resourceId);
     }
@@ -574,6 +655,7 @@ public RequestOptions fallback(int resourceId) {
    * @param drawable The drawable to display.
    * @return This request builder.
    */
+  @NonNull
   @CheckResult
   public RequestOptions error(@Nullable Drawable drawable) {
     if (isAutoCloneEnabled) {
@@ -592,8 +674,9 @@ public RequestOptions error(@Nullable Drawable drawable) {
    * @param resourceId The id of the resource to use as a placeholder.
    * @return This request builder.
    */
+  @NonNull
   @CheckResult
-  public RequestOptions error(int resourceId) {
+  public RequestOptions error(@DrawableRes int resourceId) {
     if (isAutoCloneEnabled) {
       return clone().error(resourceId);
     }
@@ -608,11 +691,22 @@ public RequestOptions error(int resourceId) {
    * for resource ids provided via {@link #error(int)}, {@link #placeholder(int)}, and
    * {@link #fallback(Drawable)}.
    *
+   * <p>The theme is <em>NOT</em> applied in the decoder that will attempt to decode a given
+   * resource id model on Glide's background threads. The theme is used exclusively on the main
+   * thread to obtain placeholder/error/fallback drawables to avoid leaking Activities.
+   *
+   * <p>If the {@link android.content.Context} of the {@link android.app.Fragment} or
+   * {@link android.app.Activity} used to start this load has a different
+   * {@link android.content.res.Resources.Theme}, the {@link android.content.res.Resources.Theme}
+   * provided here will override the {@link android.content.res.Resources.Theme} of the
+   * {@link android.content.Context}.
+   *
    * @param theme The theme to use when loading Drawables.
    * @return this request builder.
    */
+  @NonNull
   @CheckResult
-  public RequestOptions theme(Resources.Theme theme) {
+  public RequestOptions theme(@Nullable Resources.Theme theme) {
     if (isAutoCloneEnabled) {
       return clone().theme(theme);
     }
@@ -632,6 +726,7 @@ public RequestOptions theme(Resources.Theme theme) {
    * @param skip True to allow the resource to skip the memory cache.
    * @return This request builder.
    */
+  @NonNull
   @CheckResult
   public RequestOptions skipMemoryCache(boolean skip) {
     if (isAutoCloneEnabled) {
@@ -653,6 +748,7 @@ public RequestOptions skipMemoryCache(boolean skip) {
    * @param height The height in pixels to use to load the resource.
    * @return This request builder.
    */
+  @NonNull
   @CheckResult
   public RequestOptions override(int width, int height) {
     if (isAutoCloneEnabled) {
@@ -674,6 +770,7 @@ public RequestOptions override(int width, int height) {
    * @param size The width and height to use.
    * @return This request builder.
    */
+  @NonNull
   @CheckResult
   public RequestOptions override(int size) {
     return override(size, size);
@@ -690,6 +787,7 @@ public RequestOptions override(int size) {
    * @return This request builder.
    * @see com.bumptech.glide.signature.ObjectKey
    */
+  @NonNull
   @CheckResult
   public RequestOptions signature(@NonNull Key signature) {
     if (isAutoCloneEnabled) {
@@ -712,7 +810,11 @@ public RequestOptions signature(@NonNull Key signature) {
    * <p> Even if this object was locked, the cloned object returned from this method will not be
    * locked. </p>
    */
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings({
+      "unchecked",
+      // we don't want to throw to be user friendly
+      "PMD.CloneThrowsCloneNotSupportedException"
+  })
   @CheckResult
   @Override
   public RequestOptions clone() {
@@ -730,6 +832,7 @@ public RequestOptions clone() {
     }
   }
 
+  @NonNull
   @CheckResult
   public <T> RequestOptions set(@NonNull Option<T> option, @NonNull T value) {
     if (isAutoCloneEnabled) {
@@ -742,6 +845,7 @@ public RequestOptions clone() {
     return selfOrThrowIfLocked();
   }
 
+  @NonNull
   @CheckResult
   public RequestOptions decode(@NonNull Class<?> resourceClass) {
     if (isAutoCloneEnabled) {
@@ -769,6 +873,7 @@ public final boolean isLocked() {
    * Sets the value for key
    * {@link com.bumptech.glide.load.resource.bitmap.BitmapEncoder#COMPRESSION_FORMAT}.
    */
+  @NonNull
   @CheckResult
   public RequestOptions encodeFormat(@NonNull Bitmap.CompressFormat format) {
     return set(BitmapEncoder.COMPRESSION_FORMAT, Preconditions.checkNotNull(format));
@@ -778,29 +883,31 @@ public RequestOptions encodeFormat(@NonNull Bitmap.CompressFormat format) {
    * Sets the value for key
    * {@link BitmapEncoder#COMPRESSION_QUALITY}.
    */
+  @NonNull
   @CheckResult
-  public RequestOptions encodeQuality(int quality) {
+  public RequestOptions encodeQuality(@IntRange(from = 0, to = 100) int quality) {
     return set(BitmapEncoder.COMPRESSION_QUALITY, quality);
   }
 
   /**
    * Sets the time position of the frame to extract from a video.
    *
-   * <p>This is a component option specific to {@link VideoBitmapDecoder}. If the default video
+   * <p>This is a component option specific to {@link VideoDecoder}. If the default video
    * decoder is replaced or skipped because of your configuration, this option may be ignored.
    *
-   * @see VideoBitmapDecoder#TARGET_FRAME
+   * @see VideoDecoder#TARGET_FRAME
    * @param frameTimeMicros The time position in microseconds of the desired frame. If negative, the
    *                        Android framework implementation return a representative frame.
    */
+  @NonNull
   @CheckResult
-  public RequestOptions frame(long frameTimeMicros) {
-    return set(VideoBitmapDecoder.TARGET_FRAME, frameTimeMicros);
+  public RequestOptions frame(@IntRange(from = 0) long frameTimeMicros) {
+    return set(VideoDecoder.TARGET_FRAME, frameTimeMicros);
   }
 
   /**
    * Sets the {@link DecodeFormat} to use when decoding {@link Bitmap} objects using
-   * {@link Downsampler}.
+   * {@link Downsampler} and Glide's default GIF decoders.
    *
    * <p>{@link DecodeFormat} is a request, not a requirement. It's possible the resource will be
    * decoded using a decoder that cannot control the format
@@ -808,14 +915,24 @@ public RequestOptions frame(long frameTimeMicros) {
    * ignore the requested format if it can't display the image (i.e. RGB_565 is requested, but the
    * image has alpha).
    *
-   * <p>This is a component option specific to {@link Downsampler}. If the defautlt Bitmap decoder
-   * is replaced or skipped because of your configuration, this option may be ignored.
+   * <p>This is a component option specific to {@link Downsampler} and Glide's GIF decoders. If the
+   * default Bitmap decoders are replaced or skipped because of your configuration, this option may
+   * be ignored.
+   *
+   * <p>To set only the format used when decoding {@link Bitmap}s, use
+   * {@link #option(Option, Object)} and {@link Downsampler#DECODE_FORMAT}. To set only the format
+   * used when decoding GIF frames, use {@link #option(Option, Object)} and
+   * {@link GifOptions#DECODE_FORMAT}.
    *
    * @see Downsampler#DECODE_FORMAT
+   * @see GifOptions#DECODE_FORMAT
    */
+  @NonNull
   @CheckResult
   public RequestOptions format(@NonNull DecodeFormat format) {
-    return set(Downsampler.DECODE_FORMAT, Preconditions.checkNotNull(format));
+    Preconditions.checkNotNull(format);
+    return set(Downsampler.DECODE_FORMAT, format)
+        .set(GifOptions.DECODE_FORMAT, format);
   }
 
   /**
@@ -835,6 +952,7 @@ public RequestOptions format(@NonNull DecodeFormat format) {
    * {@link android.graphics.Bitmap.Config#HARDWARE} cannot be drawn to
    * {@link android.graphics.Canvas}s, which is required by most {@link Transformation}s.
    */
+  @NonNull
   @CheckResult
   public RequestOptions disallowHardwareConfig() {
     return set(Downsampler.ALLOW_HARDWARE_CONFIG, false);
@@ -847,6 +965,7 @@ public RequestOptions disallowHardwareConfig() {
    * <p>This is a component option specific to {@link Downsampler}. If the defautlt Bitmap decoder
    * is replaced or skipped because of your configuration, this option may be ignored.
    */
+  @NonNull
   @CheckResult
   public RequestOptions downsample(@NonNull DownsampleStrategy strategy) {
     return set(Downsampler.DOWNSAMPLE_STRATEGY, Preconditions.checkNotNull(strategy));
@@ -863,8 +982,9 @@ public RequestOptions downsample(@NonNull DownsampleStrategy strategy) {
    * @see com.bumptech.glide.load.model.stream.HttpGlideUrlLoader#TIMEOUT
    * @param timeoutMs The read and write timeout in milliseconds.
    */
+  @NonNull
   @CheckResult
-  public RequestOptions timeout(int timeoutMs) {
+  public RequestOptions timeout(@IntRange(from = 0) int timeoutMs) {
     return set(HttpGlideUrlLoader.TIMEOUT, timeoutMs);
   }
 
@@ -877,6 +997,7 @@ public RequestOptions timeout(int timeoutMs) {
    * @see #optionalTransform(Class, Transformation)
    * @see #centerCrop()
    */
+  @NonNull
   @CheckResult
   public RequestOptions optionalCenterCrop() {
     return optionalTransform(DownsampleStrategy.CENTER_OUTSIDE, new CenterCrop());
@@ -891,6 +1012,7 @@ public RequestOptions optionalCenterCrop() {
    * @see #transform(Class, Transformation)
    * @see #optionalCenterCrop()
    */
+  @NonNull
   @CheckResult
   public RequestOptions centerCrop() {
     return transform(DownsampleStrategy.CENTER_OUTSIDE, new CenterCrop());
@@ -907,6 +1029,7 @@ public RequestOptions centerCrop() {
    * @see #optionalTransform(Class, Transformation)
    * @see #fitCenter()
    */
+  @NonNull
   @CheckResult
   public RequestOptions optionalFitCenter() {
     return optionalScaleOnlyTransform(DownsampleStrategy.FIT_CENTER, new FitCenter());
@@ -923,6 +1046,7 @@ public RequestOptions optionalFitCenter() {
    * @see #transform(Class, Transformation)
    * @see #optionalFitCenter()
    */
+  @NonNull
   @CheckResult
   public RequestOptions fitCenter() {
     return scaleOnlyTransform(DownsampleStrategy.FIT_CENTER, new FitCenter());
@@ -938,6 +1062,7 @@ public RequestOptions fitCenter() {
    * @see #optionalTransform(Class, Transformation)
    * @see #centerInside()
    */
+  @NonNull
   @CheckResult
   public RequestOptions optionalCenterInside() {
     return optionalScaleOnlyTransform(DownsampleStrategy.CENTER_INSIDE, new CenterInside());
@@ -953,6 +1078,7 @@ public RequestOptions optionalCenterInside() {
    * @see #transform(Class, Transformation)
    * @see #optionalCenterInside()
    */
+  @NonNull
   @CheckResult
   public RequestOptions centerInside() {
     return scaleOnlyTransform(DownsampleStrategy.CENTER_INSIDE, new CenterInside());
@@ -966,6 +1092,7 @@ public RequestOptions centerInside() {
    * @see #optionalTransform(Transformation)
    * @see #circleCrop()
    */
+  @NonNull
   @CheckResult
   public RequestOptions optionalCircleCrop() {
     return optionalTransform(DownsampleStrategy.CENTER_OUTSIDE, new CircleCrop());
@@ -980,6 +1107,7 @@ public RequestOptions optionalCircleCrop() {
    * @see #transform(Class, Transformation)
    * @see #optionalCenterCrop()
    */
+  @NonNull
   @CheckResult
   public RequestOptions circleCrop() {
     return transform(DownsampleStrategy.CENTER_INSIDE, new CircleCrop());
@@ -988,22 +1116,24 @@ public RequestOptions circleCrop() {
   // calling optionalTransform() on the result of clone() requires greater access.
   // calling downsample is guaranteed to modify the current object by the isAutoCloneEnabledCheck.
   @SuppressWarnings({"WeakerAccess", "CheckResult"})
-  final RequestOptions optionalTransform(DownsampleStrategy downsampleStrategy,
-      Transformation<Bitmap> transformation) {
+  @NonNull
+  final RequestOptions optionalTransform(@NonNull DownsampleStrategy downsampleStrategy,
+      @NonNull Transformation<Bitmap> transformation) {
     if (isAutoCloneEnabled) {
       return clone().optionalTransform(downsampleStrategy, transformation);
     }
 
     downsample(downsampleStrategy);
-    return optionalTransform(transformation);
+    return transform(transformation, /*isRequired=*/ false);
   }
 
   // calling transform() on the result of clone() requires greater access.
   // calling downsample is guaranteed to modify the current object by the isAutoCloneEnabledCheck.
   @SuppressWarnings({"WeakerAccess", "CheckResult"})
+  @NonNull
   @CheckResult
-  final RequestOptions transform(DownsampleStrategy downsampleStrategy,
-      Transformation<Bitmap> transformation) {
+  final RequestOptions transform(@NonNull DownsampleStrategy downsampleStrategy,
+      @NonNull Transformation<Bitmap> transformation) {
     if (isAutoCloneEnabled) {
       return clone().transform(downsampleStrategy, transformation);
     }
@@ -1012,19 +1142,22 @@ final RequestOptions transform(DownsampleStrategy downsampleStrategy,
     return transform(transformation);
   }
 
+  @NonNull
   private RequestOptions scaleOnlyTransform(
-      DownsampleStrategy strategy, Transformation<Bitmap> transformation) {
+      @NonNull DownsampleStrategy strategy, @NonNull Transformation<Bitmap> transformation) {
     return scaleOnlyTransform(strategy, transformation, true /*isTransformationRequired*/);
   }
 
+  @NonNull
   private RequestOptions optionalScaleOnlyTransform(
-      DownsampleStrategy strategy, Transformation<Bitmap> transformation) {
+      @NonNull DownsampleStrategy strategy, @NonNull Transformation<Bitmap> transformation) {
     return scaleOnlyTransform(strategy, transformation, false /*isTransformationRequired*/);
   }
 
+  @NonNull
   private RequestOptions scaleOnlyTransform(
-      DownsampleStrategy strategy,
-      Transformation<Bitmap> transformation,
+      @NonNull DownsampleStrategy strategy,
+      @NonNull Transformation<Bitmap> transformation,
       boolean isTransformationRequired) {
     RequestOptions result = isTransformationRequired
           ? transform(strategy, transformation) : optionalTransform(strategy, transformation);
@@ -1047,16 +1180,10 @@ private RequestOptions scaleOnlyTransform(
    */
   // Guaranteed to modify the current object by the isAutoCloneEnabledCheck.
   @SuppressWarnings("CheckResult")
+  @NonNull
   @CheckResult
   public RequestOptions transform(@NonNull Transformation<Bitmap> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().transform(transformation);
-    }
-
-    optionalTransform(transformation);
-    isTransformationRequired = true;
-    fields |= TRANSFORMATION_REQUIRED;
-    return selfOrThrowIfLocked();
+    return transform(transformation, /*isRequired=*/ true);
   }
 
   /**
@@ -1074,16 +1201,10 @@ public RequestOptions transform(@NonNull Transformation<Bitmap> transformation)
    */
   // Guaranteed to modify the current object by the isAutoCloneEnabledCheck.
   @SuppressWarnings({"unchecked", "varargs", "CheckResult"})
+  @NonNull
   @CheckResult
   public RequestOptions transforms(@NonNull Transformation<Bitmap>... transformations) {
-    if (isAutoCloneEnabled) {
-      return clone().transforms(transformations);
-    }
-
-    optionalTransform(new MultiTransformation<>(transformations));
-    isTransformationRequired = true;
-    fields |= TRANSFORMATION_REQUIRED;
-    return selfOrThrowIfLocked();
+    return transform(new MultiTransformation<>(transformations), /*isRequired=*/ true);
   }
 
   /**
@@ -1100,16 +1221,29 @@ public RequestOptions transforms(@NonNull Transformation<Bitmap>... transformati
    */
   // Guaranteed to modify the current object by the isAutoCloneEnabledCheck.
   @SuppressWarnings("CheckResult")
+  @NonNull
   @CheckResult
-  public RequestOptions optionalTransform(Transformation<Bitmap> transformation) {
+  public RequestOptions optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return transform(transformation, /*isRequired=*/ false);
+  }
+
+  @NonNull
+  private RequestOptions transform(
+      @NonNull Transformation<Bitmap> transformation, boolean isRequired) {
     if (isAutoCloneEnabled) {
-      return clone().optionalTransform(transformation);
+      return clone().transform(transformation, isRequired);
     }
 
-    optionalTransform(Bitmap.class, transformation);
+    DrawableTransformation drawableTransformation =
+        new DrawableTransformation(transformation, isRequired);
+    transform(Bitmap.class, transformation, isRequired);
+    transform(Drawable.class, drawableTransformation, isRequired);
     // TODO: remove BitmapDrawable decoder and this transformation.
-    optionalTransform(BitmapDrawable.class, new BitmapDrawableTransformation(transformation));
-    optionalTransform(GifDrawable.class, new GifDrawableTransformation(transformation));
+    // Registering as BitmapDrawable is simply an optimization to avoid some iteration and
+    // isAssignableFrom checks when obtaining the transformation later on. It can be removed without
+    // affecting the functionality.
+    transform(BitmapDrawable.class, drawableTransformation.asBitmapDrawable(), isRequired);
+    transform(GifDrawable.class, new GifDrawableTransformation(transformation), isRequired);
     return selfOrThrowIfLocked();
   }
 
@@ -1130,11 +1264,20 @@ public RequestOptions optionalTransform(Transformation<Bitmap> transformation) {
    * @param resourceClass  The type of resource to transform.
    * @param transformation The {@link Transformation} to apply.
    */
+  @NonNull
   @CheckResult
-  public <T> RequestOptions optionalTransform(Class<T> resourceClass,
-      Transformation<T> transformation) {
+  public <T> RequestOptions optionalTransform(
+      @NonNull Class<T> resourceClass, @NonNull Transformation<T> transformation) {
+    return transform(resourceClass, transformation, /*isRequired=*/ false);
+  }
+
+  @NonNull
+  private <T> RequestOptions transform(
+      @NonNull Class<T> resourceClass,
+      @NonNull Transformation<T> transformation,
+      boolean isRequired) {
     if (isAutoCloneEnabled) {
-      return clone().optionalTransform(resourceClass, transformation);
+      return clone().transform(resourceClass, transformation, isRequired);
     }
 
     Preconditions.checkNotNull(resourceClass);
@@ -1146,6 +1289,10 @@ public RequestOptions optionalTransform(Transformation<Bitmap> transformation) {
     // Always set to false here. Known scale only transformations will call this method and then
     // set isScaleOnlyOrNoTransform to true immediately after.
     isScaleOnlyOrNoTransform = false;
+    if (isRequired) {
+      fields |= TRANSFORMATION_REQUIRED;
+      isTransformationRequired = true;
+    }
     return selfOrThrowIfLocked();
   }
 
@@ -1161,17 +1308,11 @@ public RequestOptions optionalTransform(Transformation<Bitmap> transformation) {
    */
   // Guaranteed to modify the current object by the isAutoCloneEnabledCheck.
   @SuppressWarnings("CheckResult")
+  @NonNull
   @CheckResult
   public <T> RequestOptions transform(
-      Class<T> resourceClass, Transformation<T> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().transform(resourceClass, transformation);
-    }
-
-    optionalTransform(resourceClass, transformation);
-    isTransformationRequired = true;
-    fields |= TRANSFORMATION_REQUIRED;
-    return selfOrThrowIfLocked();
+      @NonNull Class<T> resourceClass, @NonNull Transformation<T> transformation) {
+    return transform(resourceClass, transformation, /*isRequired=*/ true);
   }
 
   /**
@@ -1179,6 +1320,7 @@ public RequestOptions optionalTransform(Transformation<Bitmap> transformation) {
    * resource classes and allows unknown resource types to be transformed without throwing an
    * exception.
    */
+  @NonNull
   @CheckResult
   public RequestOptions dontTransform() {
     if (isAutoCloneEnabled) {
@@ -1204,19 +1346,30 @@ public RequestOptions dontTransform() {
    */
   // Guaranteed to modify the current object by the isAutoCloneEnabledCheck.
   @SuppressWarnings("CheckResult")
+  @NonNull
   @CheckResult
   public RequestOptions dontAnimate() {
-    if (isAutoCloneEnabled) {
-      return clone().dontAnimate();
-    }
-
-    set(ByteBufferGifDecoder.DISABLE_ANIMATION, true);
-    set(StreamGifDecoder.DISABLE_ANIMATION, true);
-    return selfOrThrowIfLocked();
+    return set(GifOptions.DISABLE_ANIMATION, true);
   }
 
+  /**
+   * Updates this options set with any options that are explicitly set in the given
+   * {@code RequestOptions} object and returns this object if {@link #autoClone()} is disabled or
+   * a new {@code RequestOptions} object if {@link #autoClone()} is enabled.
+   *
+   * <p>{@code #apply} only replaces those values that are explicitly set in the given
+   * {@code RequestOptions}. If you need to completely reset all previously set options, create a
+   * new {@code RequestOptions} object instead of using this method.
+   *
+   * <p>The options that will be set to values in the returned {@code RequestOptions} object is the
+   * intersection of the set of options in this {@code RequestOptions} object and the given
+   * {@code RequestOptions} object that were explicitly set. If the values of any of the options
+   * conflict, the values in the returned {@code RequestOptions} object will be set to those in the
+   * given {@code RequestOptions} object.
+   */
+  @NonNull
   @CheckResult
-  public RequestOptions apply(RequestOptions other) {
+  public RequestOptions apply(@NonNull RequestOptions other) {
     if (isAutoCloneEnabled) {
       return clone().apply(other);
     }
@@ -1227,6 +1380,9 @@ public RequestOptions apply(RequestOptions other) {
     if (isSet(other.fields, USE_UNLIMITED_SOURCE_GENERATORS_POOL)) {
       useUnlimitedSourceGeneratorsPool = other.useUnlimitedSourceGeneratorsPool;
     }
+    if (isSet(other.fields, USE_ANIMATION_POOL)) {
+      useAnimationPool = other.useAnimationPool;
+    }
     if (isSet(other.fields, DISK_CACHE_STRATEGY)) {
       diskCacheStrategy = other.diskCacheStrategy;
     }
@@ -1357,6 +1513,7 @@ public int hashCode() {
    *
    * <p> Once locked, the only way to unlock is to use {@link #clone()} </p>
    */
+  @NonNull
   @SuppressWarnings("unchecked")
   public RequestOptions lock() {
     isLocked = true;
@@ -1372,6 +1529,7 @@ public RequestOptions lock() {
    * <p>Auto clone is not retained by cloned objects returned from mutations. The cloned objects
    * are mutable and are not locked.
    */
+  @NonNull
   public RequestOptions autoClone() {
     if (isLocked && !isAutoCloneEnabled) {
       throw new IllegalStateException("You cannot auto lock an already locked options object"
@@ -1381,6 +1539,7 @@ public RequestOptions autoClone() {
     return lock();
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
   private RequestOptions selfOrThrowIfLocked() {
     if (isLocked) {
@@ -1393,6 +1552,14 @@ protected boolean isAutoCloneEnabled() {
     return isAutoCloneEnabled;
   }
 
+  public final boolean isDiskCacheStrategySet() {
+    return isSet(DISK_CACHE_STRATEGY);
+  }
+
+  public final boolean isSkipMemoryCacheSet() {
+    return isSet(IS_CACHEABLE);
+  }
+
   @NonNull
   public final Map<Class<?>, Transformation<?>> getTransformations() {
     return transformations;
@@ -1491,7 +1658,7 @@ public final float getSizeMultiplier() {
     return sizeMultiplier;
   }
 
-  public boolean isScaleOnlyOrNoTransform() {
+  boolean isScaleOnlyOrNoTransform() {
     return isScaleOnlyOrNoTransform;
   }
 
@@ -1499,10 +1666,20 @@ private boolean isSet(int flag) {
     return isSet(fields, flag);
   }
 
+  // get is just as clear.
+  @SuppressWarnings("PMD.BooleanGetMethodName")
   public final boolean getUseUnlimitedSourceGeneratorsPool() {
     return useUnlimitedSourceGeneratorsPool;
   }
 
+  // get is just as clear.
+  @SuppressWarnings("PMD.BooleanGetMethodName")
+  public final boolean getUseAnimationPool() {
+    return useAnimationPool;
+  }
+
+  // get is just as clear.
+  @SuppressWarnings("PMD.BooleanGetMethodName")
   public final boolean getOnlyRetrieveFromCache() {
     return onlyRetrieveFromCache;
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
index 6951e10d6..1cc122df3 100644
--- a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
@@ -1,12 +1,12 @@
 package com.bumptech.glide.request;
 
-import android.content.res.Resources;
+import android.content.Context;
+import android.content.res.Resources.Theme;
 import android.graphics.drawable.Drawable;
 import android.support.annotation.DrawableRes;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-import android.support.v4.content.res.ResourcesCompat;
 import android.support.v4.util.Pools;
-import android.support.v7.content.res.AppCompatResources;
 import android.util.Log;
 import com.bumptech.glide.GlideContext;
 import com.bumptech.glide.Priority;
@@ -14,6 +14,7 @@
 import com.bumptech.glide.load.engine.Engine;
 import com.bumptech.glide.load.engine.GlideException;
 import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.resource.drawable.DrawableDecoderCompat;
 import com.bumptech.glide.request.target.SizeReadyCallback;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.request.transition.Transition;
@@ -47,6 +48,9 @@
       });
   private boolean isCallingCallbacks;
 
+  private static final boolean IS_VERBOSE_LOGGABLE =
+      Log.isLoggable(TAG, Log.VERBOSE);
+
   private enum Status {
     /**
      * Created but not yet running.
@@ -82,10 +86,14 @@
     PAUSED,
   }
 
-  private final String tag = String.valueOf(super.hashCode());
+  @Nullable
+  private final String tag = IS_VERBOSE_LOGGABLE ? String.valueOf(super.hashCode()) : null;
   private final StateVerifier stateVerifier = StateVerifier.newInstance();
 
+  @Nullable
+  private RequestListener<R> targetListener;
   private RequestCoordinator requestCoordinator;
+  private Context context;
   private GlideContext glideContext;
   @Nullable
   private Object model;
@@ -107,9 +115,9 @@
   private Drawable fallbackDrawable;
   private int width;
   private int height;
-  private static boolean shouldCallAppCompatResources = true;
 
   public static <R> SingleRequest<R> obtain(
+      Context context,
       GlideContext glideContext,
       Object model,
       Class<R> transcodeClass,
@@ -118,6 +126,7 @@
       int overrideHeight,
       Priority priority,
       Target<R> target,
+      RequestListener<R> targetListener,
       RequestListener<R> requestListener,
       RequestCoordinator requestCoordinator,
       Engine engine,
@@ -128,6 +137,7 @@
       request = new SingleRequest<>();
     }
     request.init(
+        context,
         glideContext,
         model,
         transcodeClass,
@@ -136,6 +146,7 @@
         overrideHeight,
         priority,
         target,
+        targetListener,
         requestListener,
         requestCoordinator,
         engine,
@@ -143,12 +154,14 @@
     return request;
   }
 
+  @SuppressWarnings("WeakerAccess")
   @Synthetic
   SingleRequest() {
     // just create, instances are reused with recycle/init
   }
 
   private void init(
+      Context context,
       GlideContext glideContext,
       Object model,
       Class<R> transcodeClass,
@@ -157,10 +170,12 @@ private void init(
       int overrideHeight,
       Priority priority,
       Target<R> target,
+      RequestListener<R> targetListener,
       RequestListener<R> requestListener,
       RequestCoordinator requestCoordinator,
       Engine engine,
       TransitionFactory<? super R> animationFactory) {
+    this.context = context;
     this.glideContext = glideContext;
     this.model = model;
     this.transcodeClass = transcodeClass;
@@ -169,6 +184,7 @@ private void init(
     this.overrideHeight = overrideHeight;
     this.priority = priority;
     this.target = target;
+    this.targetListener = targetListener;
     this.requestListener = requestListener;
     this.requestCoordinator = requestCoordinator;
     this.engine = engine;
@@ -176,6 +192,7 @@ private void init(
     status = Status.PENDING;
   }
 
+  @NonNull
   @Override
   public StateVerifier getVerifier() {
     return stateVerifier;
@@ -184,6 +201,7 @@ public StateVerifier getVerifier() {
   @Override
   public void recycle() {
     assertNotCallingCallbacks();
+    context = null;
     glideContext = null;
     model = null;
     transcodeClass = null;
@@ -192,6 +210,7 @@ public void recycle() {
     overrideHeight = -1;
     target = null;
     requestListener = null;
+    targetListener = null;
     requestCoordinator = null;
     animationFactory = null;
     loadStatus = null;
@@ -249,7 +268,7 @@ public void begin() {
         && canNotifyStatusChanged()) {
       target.onLoadStarted(getPlaceholderDrawable());
     }
-    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+    if (IS_VERBOSE_LOGGABLE) {
       logV("finished run method in " + LogTime.getElapsedMillis(startTime));
     }
   }
@@ -277,8 +296,9 @@ void cancel() {
   private void assertNotCallingCallbacks() {
     if (isCallingCallbacks) {
       throw new IllegalStateException("You can't start or clear loads in RequestListener or"
-          + " Target callbacks. If you must do so, consider posting your into() or clear() calls"
-          + " to the main thread using a Handler instead.");
+          + " Target callbacks. If you're trying to start a fallback request when a load fails, use"
+          + " RequestBuilder#error(RequestBuilder). Otherwise consider posting your into() or"
+          + " clear() calls to the main thread using a Handler instead.");
     }
   }
 
@@ -294,6 +314,7 @@ private void assertNotCallingCallbacks() {
   public void clear() {
     Util.assertMainThread();
     assertNotCallingCallbacks();
+    stateVerifier.throwIfRecycled();
     if (status == Status.CLEARED) {
       return;
     }
@@ -302,7 +323,7 @@ public void clear() {
     if (resource != null) {
       releaseResource(resource);
     }
-    if (canNotifyStatusChanged()) {
+    if (canNotifyCleared()) {
       target.onLoadCleared(getPlaceholderDrawable());
     }
     // Must be after cancel().
@@ -381,29 +402,9 @@ private Drawable getFallbackDrawable() {
   }
 
   private Drawable loadDrawable(@DrawableRes int resourceId) {
-    if (shouldCallAppCompatResources) {
-      return loadDrawableV7(resourceId);
-    } else {
-      return loadDrawableBase(resourceId);
-    }
-  }
-
-  /**
-   * Tries to load the drawable thanks to AppCompatResources.<br>
-   * This allows to parse VectorDrawables on legacy devices if the appcompat v7 is in the classpath.
-   */
-  private Drawable loadDrawableV7(@DrawableRes int resourceId) {
-    try {
-      return AppCompatResources.getDrawable(glideContext, resourceId);
-    } catch (NoClassDefFoundError error) {
-      shouldCallAppCompatResources = false;
-      return loadDrawableBase(resourceId);
-    }
-  }
-
-  private Drawable loadDrawableBase(@DrawableRes int resourceId) {
-    Resources resources = glideContext.getResources();
-    return ResourcesCompat.getDrawable(resources, resourceId, requestOptions.getTheme());
+    Theme theme = requestOptions.getTheme() != null
+        ? requestOptions.getTheme() : context.getTheme();
+    return DrawableDecoderCompat.getDrawable(glideContext, resourceId, theme);
   }
 
   private void setErrorPlaceholder() {
@@ -432,7 +433,7 @@ private void setErrorPlaceholder() {
   @Override
   public void onSizeReady(int width, int height) {
     stateVerifier.throwIfRecycled();
-    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+    if (IS_VERBOSE_LOGGABLE) {
       logV("Got onSizeReady in " + LogTime.getElapsedMillis(startTime));
     }
     if (status != Status.WAITING_FOR_SIZE) {
@@ -444,7 +445,7 @@ public void onSizeReady(int width, int height) {
     this.width = maybeApplySizeMultiplier(width, sizeMultiplier);
     this.height = maybeApplySizeMultiplier(height, sizeMultiplier);
 
-    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+    if (IS_VERBOSE_LOGGABLE) {
       logV("finished setup for calling load in " + LogTime.getElapsedMillis(startTime));
     }
     loadStatus = engine.load(
@@ -463,9 +464,17 @@ public void onSizeReady(int width, int height) {
         requestOptions.getOptions(),
         requestOptions.isMemoryCacheable(),
         requestOptions.getUseUnlimitedSourceGeneratorsPool(),
+        requestOptions.getUseAnimationPool(),
         requestOptions.getOnlyRetrieveFromCache(),
         this);
-    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+
+    // This is a hack that's only useful for testing right now where loads complete synchronously
+    // even though under any executor running on any thread but the main thread, the load would
+    // have completed asynchronously.
+    if (status != Status.RUNNING) {
+      loadStatus = null;
+    }
+    if (IS_VERBOSE_LOGGABLE) {
       logV("finished onSizeReady in " + LogTime.getElapsedMillis(startTime));
     }
   }
@@ -478,6 +487,10 @@ private boolean canSetResource() {
     return requestCoordinator == null || requestCoordinator.canSetImage(this);
   }
 
+  private boolean canNotifyCleared() {
+    return requestCoordinator == null || requestCoordinator.canNotifyCleared(this);
+  }
+
   private boolean canNotifyStatusChanged() {
     return requestCoordinator == null || requestCoordinator.canNotifyStatusChanged(this);
   }
@@ -492,6 +505,12 @@ private void notifyLoadSuccess() {
     }
   }
 
+  private void notifyLoadFailed() {
+    if (requestCoordinator != null) {
+      requestCoordinator.onRequestFailed(this);
+    }
+  }
+
   /**
    * A callback method that should never be invoked directly.
    */
@@ -551,8 +570,10 @@ private void onResourceReady(Resource<R> resource, R result, DataSource dataSour
 
     isCallingCallbacks = true;
     try {
-      if (requestListener == null
-          || !requestListener.onResourceReady(result, model, target, dataSource, isFirstResource)) {
+      if ((requestListener == null
+          || !requestListener.onResourceReady(result, model, target, dataSource, isFirstResource))
+          && (targetListener == null
+          || !targetListener.onResourceReady(result, model, target, dataSource, isFirstResource))) {
         Transition<? super R> animation =
             animationFactory.build(dataSource, isFirstResource);
         target.onResourceReady(result, animation);
@@ -588,25 +609,34 @@ private void onLoadFailed(GlideException e, int maxLogLevel) {
     isCallingCallbacks = true;
     try {
       //TODO: what if this is a thumbnail request?
-      if (requestListener == null
-          || !requestListener.onLoadFailed(e, model, target, isFirstReadyResource())) {
+      if ((requestListener == null
+          || !requestListener.onLoadFailed(e, model, target, isFirstReadyResource()))
+          && (targetListener == null
+          || !targetListener.onLoadFailed(e, model, target, isFirstReadyResource()))) {
         setErrorPlaceholder();
       }
     } finally {
       isCallingCallbacks = false;
     }
+
+    notifyLoadFailed();
   }
 
   @Override
   public boolean isEquivalentTo(Request o) {
     if (o instanceof SingleRequest) {
-      SingleRequest that = (SingleRequest) o;
+      SingleRequest<?> that = (SingleRequest<?>) o;
       return overrideWidth == that.overrideWidth
           && overrideHeight == that.overrideHeight
           && Util.bothModelsNullEquivalentOrEquals(model, that.model)
           && transcodeClass.equals(that.transcodeClass)
           && requestOptions.equals(that.requestOptions)
-          && priority == that.priority;
+          && priority == that.priority
+          // We do not want to require that RequestListeners implement equals/hashcode, so we don't
+          // compare them using equals(). We can however, at least assert that the request listener
+          // is either present or not present in both requests.
+          && (requestListener != null
+          ? that.requestListener != null : that.requestListener == null);
     }
     return false;
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
index 6b62270e2..ec172f848 100644
--- a/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
+++ b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.request;
 
 import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 
 /**
  * A coordinator that coordinates two individual {@link Request}s that load a small thumbnail
@@ -8,17 +9,19 @@
  */
 public class ThumbnailRequestCoordinator implements RequestCoordinator,
     Request {
+  @Nullable private final RequestCoordinator parent;
+
   private Request full;
   private Request thumb;
-  @Nullable private RequestCoordinator coordinator;
   private boolean isRunning;
 
-  public ThumbnailRequestCoordinator() {
-    this(null);
+  @VisibleForTesting
+  ThumbnailRequestCoordinator() {
+    this(/*parent=*/ null);
   }
 
-  public ThumbnailRequestCoordinator(RequestCoordinator coordinator) {
-    this.coordinator = coordinator;
+  public ThumbnailRequestCoordinator(@Nullable RequestCoordinator parent) {
+    this.parent = parent;
   }
 
   public void setRequests(Request full, Request thumb) {
@@ -38,7 +41,7 @@ public boolean canSetImage(Request request) {
   }
 
   private boolean parentCanSetImage() {
-    return coordinator == null || coordinator.canSetImage(this);
+    return parent == null || parent.canSetImage(this);
   }
 
   /**
@@ -52,8 +55,17 @@ public boolean canNotifyStatusChanged(Request request) {
     return parentCanNotifyStatusChanged() && request.equals(full) && !isAnyResourceSet();
   }
 
+  @Override
+  public boolean canNotifyCleared(Request request) {
+    return parentCanNotifyCleared() && request.equals(full);
+  }
+
+  private boolean parentCanNotifyCleared() {
+    return parent == null || parent.canNotifyCleared(this);
+  }
+
   private boolean parentCanNotifyStatusChanged() {
-    return coordinator == null || coordinator.canNotifyStatusChanged(this);
+    return parent == null || parent.canNotifyStatusChanged(this);
   }
 
   @Override
@@ -66,8 +78,8 @@ public void onRequestSuccess(Request request) {
     if (request.equals(thumb)) {
       return;
     }
-    if (coordinator != null) {
-      coordinator.onRequestSuccess(this);
+    if (parent != null) {
+      parent.onRequestSuccess(this);
     }
     // Clearing the thumb is not necessarily safe if the thumb is being displayed in the Target,
     // as a layer in a cross fade for example. The only way we know the thumb is not being
@@ -77,8 +89,19 @@ public void onRequestSuccess(Request request) {
     }
   }
 
+  @Override
+  public void onRequestFailed(Request request) {
+    if (!request.equals(full)) {
+      return;
+    }
+
+    if (parent != null) {
+      parent.onRequestFailed(this);
+    }
+  }
+
   private boolean parentIsAnyResourceSet() {
-    return coordinator != null && coordinator.isAnyResourceSet();
+    return parent != null && parent.isAnyResourceSet();
   }
 
   /**
@@ -87,7 +110,9 @@ private boolean parentIsAnyResourceSet() {
   @Override
   public void begin() {
     isRunning = true;
-    if (!thumb.isRunning()) {
+    // If the request has completed previously, there's no need to restart both the full and the
+    // thumb, we can just restart the full.
+    if (!full.isComplete() && !thumb.isRunning()) {
       thumb.begin();
     }
     if (isRunning && !full.isRunning()) {
@@ -102,9 +127,6 @@ public void pause() {
     thumb.pause();
   }
 
-  /**
-   * {@inheritDoc}
-   */
   @Override
   public void clear() {
     isRunning = false;
@@ -151,9 +173,6 @@ public boolean isFailed() {
     return full.isFailed();
   }
 
-  /**
-   * {@inheritDoc}.
-   */
   @Override
   public void recycle() {
     full.recycle();
diff --git a/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java b/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java
index 5259a5973..85ebda0de 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java
@@ -4,6 +4,8 @@
 import android.content.ComponentName;
 import android.content.Context;
 import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.widget.RemoteViews;
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.util.Preconditions;
@@ -15,6 +17,8 @@
  * <p> Note - For cancellation to work correctly, you must pass in the same instance of this class
  * for every subsequent load. </p>
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public class AppWidgetTarget extends SimpleTarget<Bitmap> {
   private final int[] widgetIds;
   private final ComponentName componentName;
@@ -116,7 +120,8 @@ private void update() {
   }
 
   @Override
-  public void onResourceReady(Bitmap resource, Transition<? super Bitmap> transition) {
+  public void onResourceReady(@NonNull Bitmap resource,
+      @Nullable Transition<? super Bitmap> transition) {
     this.remoteViews.setImageViewBitmap(this.viewId, resource);
     this.update();
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java
index 42c701091..386a6a1cf 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java
@@ -8,10 +8,18 @@
  * android.graphics.Bitmap} in an {@link android.widget.ImageView}.
  */
 public class BitmapImageViewTarget extends ImageViewTarget<Bitmap> {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public BitmapImageViewTarget(ImageView view) {
     super(view);
   }
 
+  /**
+   * @deprecated Use {@link #waitForLayout()} instead.
+   */
+  // Public API.
+  @SuppressWarnings({"unused", "deprecation"})
+  @Deprecated
   public BitmapImageViewTarget(ImageView view, boolean waitForLayout) {
     super(view, waitForLayout);
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java
index 46b909ffa..90b03a62f 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java
@@ -8,11 +8,18 @@
 /**
  * Efficiently displays multiple Bitmaps loaded serially into a single {@link android.view.View}.
  */
+// Public API.
+@SuppressWarnings("unused")
 public class BitmapThumbnailImageViewTarget extends ThumbnailImageViewTarget<Bitmap> {
   public BitmapThumbnailImageViewTarget(ImageView view) {
     super(view);
   }
 
+  /**
+   * @deprecated Use {@link #waitForLayout()} instead.
+   */
+  @SuppressWarnings("deprecation")
+  @Deprecated
   public BitmapThumbnailImageViewTarget(ImageView view, boolean waitForLayout) {
     super(view, waitForLayout);
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java
index 58119e4df..ca9c6528d 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java
@@ -13,6 +13,12 @@ public DrawableImageViewTarget(ImageView view) {
     super(view);
   }
 
+  /**
+   * @deprecated Use {@link #waitForLayout()} instead.
+   */
+  // Public API.
+  @SuppressWarnings({"unused", "deprecation"})
+  @Deprecated
   public DrawableImageViewTarget(ImageView view, boolean waitForLayout) {
     super(view, waitForLayout);
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/DrawableThumbnailImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/DrawableThumbnailImageViewTarget.java
index 34a99302f..40ff2dad4 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/DrawableThumbnailImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableThumbnailImageViewTarget.java
@@ -6,11 +6,18 @@
 /**
  * Efficiently displays multiple Drawables loaded serially into a single {@link android.view.View}.
  */
+// Public API.
+@SuppressWarnings("unused")
 public class DrawableThumbnailImageViewTarget extends ThumbnailImageViewTarget<Drawable> {
   public DrawableThumbnailImageViewTarget(ImageView view) {
     super(view);
   }
 
+  /**
+   * @deprecated Use {@link #waitForLayout()} instead.
+   */
+  @Deprecated
+  @SuppressWarnings("deprecation")
   public DrawableThumbnailImageViewTarget(ImageView view, boolean waitForLayout) {
     super(view, waitForLayout);
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/FixedSizeDrawable.java b/library/src/main/java/com/bumptech/glide/request/target/FixedSizeDrawable.java
index a1f56e1af..154bdc3eb 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/FixedSizeDrawable.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/FixedSizeDrawable.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.request.target;
 
-import android.annotation.TargetApi;
 import android.content.res.Resources;
 import android.graphics.Canvas;
 import android.graphics.ColorFilter;
@@ -10,6 +9,8 @@
 import android.graphics.RectF;
 import android.graphics.drawable.Drawable;
 import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.annotation.RequiresApi;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
 
@@ -27,6 +28,8 @@
   private State state;
   private boolean mutated;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public FixedSizeDrawable(Drawable wrapped, int width, int height) {
     this(new State(wrapped.getConstantState(), width, height), wrapped);
   }
@@ -51,7 +54,7 @@ public void setBounds(int left, int top, int right, int bottom) {
   }
 
   @Override
-  public void setBounds(Rect bounds) {
+  public void setBounds(@NonNull Rect bounds) {
     super.setBounds(bounds);
     this.bounds.set(bounds);
     updateMatrix();
@@ -87,14 +90,14 @@ public Callback getCallback() {
     return wrapped.getCallback();
   }
 
-  @TargetApi(Build.VERSION_CODES.KITKAT)
+  @RequiresApi(Build.VERSION_CODES.KITKAT)
   @Override
   public int getAlpha() {
     return wrapped.getAlpha();
   }
 
   @Override
-  public void setColorFilter(int color, PorterDuff.Mode mode) {
+  public void setColorFilter(int color, @NonNull PorterDuff.Mode mode) {
     wrapped.setColorFilter(color, mode);
   }
 
@@ -103,6 +106,7 @@ public void clearColorFilter() {
     wrapped.clearColorFilter();
   }
 
+  @NonNull
   @Override
   public Drawable getCurrent() {
     return wrapped.getCurrent();
@@ -134,7 +138,7 @@ public int getMinimumHeight() {
   }
 
   @Override
-  public boolean getPadding(Rect padding) {
+  public boolean getPadding(@NonNull Rect padding) {
     return wrapped.getPadding(padding);
   }
 
@@ -145,19 +149,19 @@ public void invalidateSelf() {
   }
 
   @Override
-  public void unscheduleSelf(Runnable what) {
+  public void unscheduleSelf(@NonNull Runnable what) {
     super.unscheduleSelf(what);
     wrapped.unscheduleSelf(what);
   }
 
   @Override
-  public void scheduleSelf(Runnable what, long when) {
+  public void scheduleSelf(@NonNull Runnable what, long when) {
     super.scheduleSelf(what, when);
     wrapped.scheduleSelf(what, when);
   }
 
   @Override
-  public void draw(Canvas canvas) {
+  public void draw(@NonNull Canvas canvas) {
     canvas.save();
     canvas.concat(matrix);
     wrapped.draw(canvas);
@@ -179,6 +183,7 @@ public int getOpacity() {
     return wrapped.getOpacity();
   }
 
+  @NonNull
   @Override
   public Drawable mutate() {
     if (!mutated && super.mutate() == this) {
@@ -194,7 +199,7 @@ public ConstantState getConstantState() {
     return state;
   }
 
-  static class State extends ConstantState {
+  static final class State extends ConstantState {
     private final ConstantState wrapped;
     @Synthetic final int width;
     @Synthetic final int height;
@@ -209,11 +214,13 @@ public ConstantState getConstantState() {
       this.height = height;
     }
 
+    @NonNull
     @Override
     public Drawable newDrawable() {
       return new FixedSizeDrawable(this, wrapped.newDrawable());
     }
 
+    @NonNull
     @Override
     public Drawable newDrawable(Resources res) {
       return new FixedSizeDrawable(this, wrapped.newDrawable(res));
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java
index 68a37e401..6f270b9a6 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java
@@ -2,6 +2,7 @@
 
 import android.graphics.drawable.Animatable;
 import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.widget.ImageView;
 import com.bumptech.glide.request.transition.Transition;
@@ -13,6 +14,8 @@
  * @param <Z> The type of resource that this target will display in the wrapped {@link
  *            android.widget.ImageView}.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public abstract class ImageViewTarget<Z> extends ViewTarget<ImageView, Z>
     implements Transition.ViewAdapter {
 
@@ -23,6 +26,11 @@ public ImageViewTarget(ImageView view) {
     super(view);
   }
 
+  /**
+   * @deprecated Use {@link #waitForLayout()} instead.
+   */
+  @SuppressWarnings({"deprecation"})
+  @Deprecated
   public ImageViewTarget(ImageView view, boolean waitForLayout) {
     super(view, waitForLayout);
   }
@@ -83,12 +91,15 @@ public void onLoadFailed(@Nullable Drawable errorDrawable) {
   @Override
   public void onLoadCleared(@Nullable Drawable placeholder) {
     super.onLoadCleared(placeholder);
+    if (animatable != null) {
+      animatable.stop();
+    }
     setResourceInternal(null);
     setDrawable(placeholder);
   }
 
   @Override
-  public void onResourceReady(Z resource, @Nullable Transition<? super Z> transition) {
+  public void onResourceReady(@NonNull Z resource, @Nullable Transition<? super Z> transition) {
     if (transition == null || !transition.transition(resource, this)) {
       setResourceInternal(resource);
     } else {
@@ -111,8 +122,10 @@ public void onStop() {
   }
 
   private void setResourceInternal(@Nullable Z resource) {
-    maybeUpdateAnimatable(resource);
+    // Order matters here. Set the resource first to make sure that the Drawable has a valid and
+    // non-null Callback before starting it.
     setResource(resource);
+    maybeUpdateAnimatable(resource);
   }
 
   private void maybeUpdateAnimatable(@Nullable Z resource) {
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java
index 33454b46a..2e91ac594 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java
@@ -2,6 +2,7 @@
 
 import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
 import android.widget.ImageView;
 
 /**
@@ -9,13 +10,14 @@
  * {@link com.bumptech.glide.request.target.Target} for a given {@link android.view.View} subclass.
  */
 public class ImageViewTargetFactory {
-
+  @NonNull
   @SuppressWarnings("unchecked")
-  public <Z> Target<Z> buildTarget(ImageView view, Class<Z> clazz) {
+  public <Z> ViewTarget<ImageView, Z> buildTarget(@NonNull ImageView view,
+      @NonNull Class<Z> clazz) {
     if (Bitmap.class.equals(clazz)) {
-      return (Target<Z>) new BitmapImageViewTarget(view);
+      return (ViewTarget<ImageView, Z>) new BitmapImageViewTarget(view);
     } else if (Drawable.class.isAssignableFrom(clazz)) {
-      return (Target<Z>) new DrawableImageViewTarget(view);
+      return (ViewTarget<ImageView, Z>) new DrawableImageViewTarget(view);
     } else {
       throw new IllegalArgumentException(
           "Unhandled class: " + clazz + ", try .as*(Class).transcode(ResourceTranscoder)");
diff --git a/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java b/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java
index 481523111..393b40cf1 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java
@@ -5,6 +5,8 @@
 import android.app.NotificationManager;
 import android.content.Context;
 import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.widget.RemoteViews;
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.util.Preconditions;
@@ -16,6 +18,8 @@
  * <p> Note - For cancellation to work correctly, you must pass in the same instance of this class
  * for every subsequent load. </p>
  */
+// Public API.
+@SuppressWarnings({"WeakerAccess", "unused"})
 public class NotificationTarget extends SimpleTarget<Bitmap> {
   private final RemoteViews remoteViews;
   private final Context context;
@@ -29,12 +33,12 @@
    * Notification in order to update it that uses {@link #SIZE_ORIGINAL} as the target width and
    * height.
    *
-   * @param context         Context to use in the AppWidgetManager initialization.
-   * @param viewId          The id of the ImageView view that will load the image.
-   * @param remoteViews     RemoteViews object which contains the ImageView that will load the
-   *                        bitmap.
-   * @param notification    The Notification object that we want to update.
-   * @param notificationId  The notificationId of the Notification that we want to load the Bitmap.
+   * @param context        Context to use in the AppWidgetManager initialization.
+   * @param viewId         The id of the ImageView view that will load the image.
+   * @param remoteViews    RemoteViews object which contains the ImageView that will load the
+   *                       bitmap.
+   * @param notification   The Notification object that we want to update.
+   * @param notificationId The notificationId of the Notification that we want to load the Bitmap.
    */
   public NotificationTarget(Context context,
       int viewId, RemoteViews remoteViews, Notification notification, int notificationId) {
@@ -58,7 +62,7 @@ public NotificationTarget(Context context,
   public NotificationTarget(Context context, int viewId, RemoteViews remoteViews,
       Notification notification, int notificationId, String notificationTag) {
     this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, notification, notificationId,
-      notificationTag);
+        notificationTag);
   }
 
   /**
@@ -98,11 +102,13 @@ public NotificationTarget(Context context, int width, int height, int viewId,
   private void update() {
     NotificationManager manager =
         (NotificationManager) this.context.getSystemService(Context.NOTIFICATION_SERVICE);
-    manager.notify(this.notificationTag, this.notificationId, this.notification);
+    Preconditions.checkNotNull(manager)
+        .notify(this.notificationTag, this.notificationId, this.notification);
   }
 
   @Override
-  public void onResourceReady(Bitmap resource, Transition<? super Bitmap> transition) {
+  public void onResourceReady(@NonNull Bitmap resource,
+      @Nullable Transition<? super Bitmap> transition) {
     this.remoteViews.setImageViewBitmap(this.viewId, resource);
     this.update();
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/PreloadTarget.java b/library/src/main/java/com/bumptech/glide/request/target/PreloadTarget.java
index caab4ac19..903522fc0 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/PreloadTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/PreloadTarget.java
@@ -4,8 +4,11 @@
 import android.os.Handler.Callback;
 import android.os.Looper;
 import android.os.Message;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.util.Synthetic;
 
 /**
  * A one time use {@link com.bumptech.glide.request.target.Target} class that loads a resource into
@@ -45,11 +48,12 @@ private PreloadTarget(RequestManager requestManager, int width, int height) {
   }
 
   @Override
-  public void onResourceReady(Z resource, Transition<? super Z> transition) {
+  public void onResourceReady(@NonNull Z resource, @Nullable Transition<? super Z> transition) {
     HANDLER.obtainMessage(MESSAGE_CLEAR, this).sendToTarget();
   }
 
-  private void clear() {
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic void clear() {
     requestManager.clear(this);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java b/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java
index fd1baf5b7..4c2143ab1 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java
@@ -1,28 +1,64 @@
 package com.bumptech.glide.request.target;
 
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+import android.view.View;
 import com.bumptech.glide.util.Util;
 
 /**
- * A simple {@link com.bumptech.glide.request.target.Target} base class with default (usually noop)
+ * A simple {@link com.bumptech.glide.request.target.Target} base class with default (usually no-op)
  * implementations of non essential methods that allows the caller to specify an exact width/height.
  * Typically use cases look something like this:
  * <pre>
  * <code>
- * Glide.load("http://somefakeurl.com/fakeImage.jpeg")
- *      .asBitmap()
- *      .withFitCenter()
- *      .into(new SimpleTarget<Bitmap>(250, 250) {
+ * Target<Bitmap> target =
+ *     Glide.with(fragment)
+ *       .asBitmap()
+ *       .load("http://somefakeurl.com/fakeImage.jpeg")
+ *       .apply(fitCenterTransform())
+ *       .into(new SimpleTarget<Bitmap>(250, 250) {
  *
- *          {@literal @Override}
- *          public void onResourceReady(Bitmap resource, GlideAnimation<Bitmap> glideAnimation) {
- *              // Do something with bitmap here.
- *          }
+ *         {@literal @Override}
+ *         public void onResourceReady(Bitmap resource, Transition<? super Bitmap> transition) {
+ *           // Do something with bitmap here.
+ *         }
  *
- *      });
+ *       });
  * }
+ * // At some later point, clear the Target to release the resources, prevent load queues from
+ * // blowing out proportion, and to improve load times for future requests:
+ * Glide.with(fragment).clear(target);
  * </code>
  * </pre>
  *
+ * <p><em>Warning!</em> this class is extremely prone to mis-use. Use SimpleTarget only as a last
+ * resort. {@link ViewTarget} or a subclass of {@link ViewTarget} is almost always a better choice.
+ *
+ * <p><em>Don't forget to clear instances of this class!</em>. If you must use this class, keep in
+ * mind that unlike {@link ViewTarget} it is not safe to load into new instances of this class
+ * repeatedly if every instance updates the same underlying {@link View} or caller. If you need to
+ * load into the same {@link View} or caller repeatedly using this class, always retain a reference
+ * to the previous instance and either call {@link com.bumptech.glide.RequestManager#clear(Target)}
+ * on the old instance before starting a new load or you must re-use the old instance for the new
+ * load. Glide's {@link com.bumptech.glide.RequestBuilder#into(Target)} method returns the
+ * {@link Target} instance you provided to make retaining a reference to the {@link Target} as easy
+ * as possible. That said, you must wait until you're completely finished with the resource before
+ * calling {@link com.bumptech.glide.RequestManager#clear(Target)} and you should always null out
+ * references to any loaded resources in {@link Target#onLoadCleared(Drawable)}.
+ *
+ * <p>Always try to provide a size when using this class. Use
+ * {@link SimpleTarget#SimpleTarget(int, int)} whenever possible with values that are <em>not</em>
+ * {@link Target#SIZE_ORIGINAL}. Using {@link Target#SIZE_ORIGINAL} is unsafe if you're loading
+ * large images or are running your application on older or memory constrained devices because it
+ * can cause Glide to load very large images into memory. In some cases those images may throw
+ * {@link OutOfMemoryError} and in others they may exceed the texture limit for the device, which
+ * will prevent them from being rendered. Providing a valid size allows Glide to downsample large
+ * images, which can avoid issues with texture size or memory limitations. You don't have to worry
+ * about providing a size in most cases if you use {@link ViewTarget} so prefer {@link ViewTarget}
+ * over this class whenver possible.
+ *
+ * @see <a href="http://bumptech.github.io/glide/doc/targets.html">Glide's Target docs page</a>
+ *
  * @param <Z> The type of resource that this target will receive.
  */
 public abstract class SimpleTarget<Z> extends BaseTarget<Z> {
@@ -33,6 +69,8 @@
    * Constructor for the target that uses {@link Target#SIZE_ORIGINAL} as the target width and
    * height.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public SimpleTarget() {
     this(SIZE_ORIGINAL, SIZE_ORIGINAL);
   }
@@ -44,6 +82,8 @@ public SimpleTarget() {
    * @param width  The width in pixels of the desired resource.
    * @param height The height in pixels of the desired resource.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public SimpleTarget(int width, int height) {
     this.width = width;
     this.height = height;
@@ -55,7 +95,7 @@ public SimpleTarget(int width, int height) {
    * @param cb {@inheritDoc}
    */
   @Override
-  public final void getSize(SizeReadyCallback cb) {
+  public final void getSize(@NonNull SizeReadyCallback cb) {
     if (!Util.isValidDimensions(width, height)) {
       throw new IllegalArgumentException(
           "Width and height must both be > 0 or Target#SIZE_ORIGINAL, but given" + " width: "
@@ -66,7 +106,7 @@ public final void getSize(SizeReadyCallback cb) {
   }
 
   @Override
-  public void removeCallback(SizeReadyCallback cb) {
+  public void removeCallback(@NonNull SizeReadyCallback cb) {
     // Do nothing, we never retain a reference to the callback.
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/Target.java b/library/src/main/java/com/bumptech/glide/request/target/Target.java
index dbdbc4779..3aa385ce5 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/Target.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/Target.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.request.target;
 
 import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import com.bumptech.glide.manager.LifecycleListener;
 import com.bumptech.glide.request.Request;
@@ -63,7 +64,7 @@
    *
    * @param resource the loaded resource.
    */
-  void onResourceReady(R resource, Transition<? super R> transition);
+  void onResourceReady(@NonNull R resource, @Nullable Transition<? super R> transition);
 
   /**
    * A lifecycle callback that is called when a load is cancelled and its resources are freed.
@@ -81,14 +82,14 @@
    *
    * @param cb The callback that must be called when the size of the target has been determined
    */
-  void getSize(SizeReadyCallback cb);
+  void getSize(@NonNull SizeReadyCallback cb);
 
   /**
    * Removes the given callback from the pending set if it's still retained.
    *
    * @param cb The callback to remove.
    */
-  void removeCallback(SizeReadyCallback cb);
+  void removeCallback(@NonNull SizeReadyCallback cb);
 
   /**
    * Sets the current request for this target to retain, should not be called outside of Glide.
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ThumbnailImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/ThumbnailImageViewTarget.java
index 0bce1750d..043d31daf 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ThumbnailImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ThumbnailImageViewTarget.java
@@ -20,12 +20,19 @@
  *
  * @param <T> The type of resource that will be displayed in the ImageView.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public abstract class ThumbnailImageViewTarget<T> extends ImageViewTarget<T> {
 
   public ThumbnailImageViewTarget(ImageView view) {
     super(view);
   }
 
+  /**
+   * @deprecated Use {@link #waitForLayout()} insetad.
+   */
+  @Deprecated
+  @SuppressWarnings({"deprecation"})
   public ThumbnailImageViewTarget(ImageView view, boolean waitForLayout) {
     super(view, waitForLayout);
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
index d2f97dca2..635b6b5d0 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
@@ -3,11 +3,14 @@
 import android.content.Context;
 import android.graphics.Point;
 import android.graphics.drawable.Drawable;
+import android.support.annotation.CallSuper;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.support.annotation.VisibleForTesting;
 import android.util.Log;
 import android.view.Display;
 import android.view.View;
+import android.view.View.OnAttachStateChangeListener;
 import android.view.ViewGroup.LayoutParams;
 import android.view.ViewTreeObserver;
 import android.view.WindowManager;
@@ -40,17 +43,23 @@
  */
 public abstract class ViewTarget<T extends View, Z> extends BaseTarget<Z> {
   private static final String TAG = "ViewTarget";
-  private static boolean isTagUsedAtLeastOnce = false;
-  @Nullable private static Integer tagId = null;
+  private static boolean isTagUsedAtLeastOnce;
+  @Nullable private static Integer tagId;
 
   protected final T view;
   private final SizeDeterminer sizeDeterminer;
+  @Nullable
+  private OnAttachStateChangeListener attachStateListener;
+  private boolean isClearedByUs;
+  private boolean isAttachStateListenerAdded;
+
 
   /**
    * Constructor that defaults {@code waitForLayout} to {@code false}.
    */
-  public ViewTarget(T view) {
-    this(view, false /*waitForLayout*/);
+  public ViewTarget(@NonNull T view) {
+    this.view = Preconditions.checkNotNull(view);
+    sizeDeterminer = new SizeDeterminer(view);
   }
 
   /**
@@ -62,15 +71,131 @@ public ViewTarget(T view) {
    * some cases and should be used sparingly. If layout parameters are set to fixed sizes, they will
    * still be used instead of the View's dimensions even if this parameter is set to {@code true}.
    * This parameter is a fallback only.
+   *
+   * @deprecated Use {@link #waitForLayout()} instead.
    */
-  public ViewTarget(T view, boolean waitForLayout) {
-    this.view = Preconditions.checkNotNull(view);
-    sizeDeterminer = new SizeDeterminer(view, waitForLayout);
+  @SuppressWarnings("WeakerAccess") // Public API
+  @Deprecated
+  public ViewTarget(@NonNull T view, boolean waitForLayout) {
+    this(view);
+    if (waitForLayout) {
+      waitForLayout();
+    }
+  }
+
+  /**
+   * Clears the {@link View}'s {@link Request} when the {@link View} is detached from its
+   * {@link android.view.Window} and restarts the {@link Request} when the {@link View} is
+   * re-attached from its {@link android.view.Window}.
+   *
+   * <p>This is an experimental API that may be removed in a future version.
+   *
+   * <p>Using this method can save memory by allowing Glide to more eagerly clear resources when
+   * transitioning screens or swapping adapters in scrolling views. However it also substantially
+   * increases the odds that images will not be in memory if users subsequently return to a screen
+   * where images were previously loaded. Whether or not this happens will depend on the number
+   * of images loaded in the new screen and the size of the memory cache. Increasing the size of
+   * the memory cache can improve this behavior but it largely negates the memory benefits of using
+   * this method.
+   *
+   * <p>Use this method with caution and measure your memory usage to ensure that it's actually
+   * improving your memory usage in the cases you care about.
+   */
+  // Public API.
+  @NonNull
+  @SuppressWarnings({"UnusedReturnValue", "WeakerAccess"})
+  public final ViewTarget<T, Z> clearOnDetach() {
+    if (attachStateListener != null) {
+      return this;
+    }
+    attachStateListener = new OnAttachStateChangeListener() {
+      @Override
+      public void onViewAttachedToWindow(View v) {
+        resumeMyRequest();
+      }
+
+      @Override
+      public void onViewDetachedFromWindow(View v) {
+        pauseMyRequest();
+      }
+    };
+    maybeAddAttachStateListener();
+    return this;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic void resumeMyRequest() {
+    Request request = getRequest();
+    if (request != null && request.isPaused()) {
+      request.begin();
+    }
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic void pauseMyRequest() {
+    Request request = getRequest();
+    if (request != null && !request.isCancelled() && !request.isPaused()) {
+      isClearedByUs = true;
+      request.pause();
+      isClearedByUs = false;
+    }
+  }
+
+  /**
+   * Indicates that Glide should always wait for any pending layout pass before checking
+   * for the size an {@link View}.
+   *
+   * <p>By default, Glide will only wait for a pending layout pass if it's unable to resolve the
+   * size from the {@link LayoutParams} or valid non-zero values for {@link View#getWidth()} and
+   * {@link View#getHeight()}.
+   *
+   * <p>Because calling this method forces Glide to wait for the layout pass to occur before
+   * starting loads, setting this parameter to {@code true} can cause Glide to asynchronous load
+   * an image even if it's in the memory cache. The load will happen asynchronously because Glide
+   * has to wait for a layout pass to occur, which won't necessarily happen in the same frame as
+   * when the image is requested. As a result, using this method can resulting in flashing in some
+   * cases and should be used sparingly.
+   *
+   * <p>If the {@link LayoutParams} of the wrapped {@link View} are set to fixed sizes, they will
+   * still be used instead of the {@link View}'s dimensions even if this method is called. This
+   * parameter is a fallback only.
+   */
+  @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
+  public final ViewTarget<T, Z> waitForLayout() {
+    sizeDeterminer.waitForLayout = true;
+    return this;
+  }
+
+  @CallSuper
+  @Override
+  public void onLoadStarted(@Nullable Drawable placeholder) {
+    super.onLoadStarted(placeholder);
+    maybeAddAttachStateListener();
+  }
+
+  private void maybeAddAttachStateListener() {
+    if (attachStateListener == null || isAttachStateListenerAdded) {
+      return;
+    }
+
+    view.addOnAttachStateChangeListener(attachStateListener);
+    isAttachStateListenerAdded = true;
+  }
+
+  private void maybeRemoveAttachStateListener() {
+    if (attachStateListener == null || !isAttachStateListenerAdded) {
+      return;
+    }
+
+    view.removeOnAttachStateChangeListener(attachStateListener);
+    isAttachStateListenerAdded = false;
   }
 
   /**
    * Returns the wrapped {@link android.view.View}.
    */
+  @NonNull
   public T getView() {
     return view;
   }
@@ -84,20 +209,27 @@ public T getView() {
    *
    * @param cb {@inheritDoc}
    */
+  @CallSuper
   @Override
-  public void getSize(SizeReadyCallback cb) {
+  public void getSize(@NonNull SizeReadyCallback cb) {
     sizeDeterminer.getSize(cb);
   }
 
+  @CallSuper
   @Override
-  public void removeCallback(SizeReadyCallback cb) {
+  public void removeCallback(@NonNull SizeReadyCallback cb) {
     sizeDeterminer.removeCallback(cb);
   }
 
+  @CallSuper
   @Override
-  public void onLoadCleared(Drawable placeholder) {
+  public void onLoadCleared(@Nullable Drawable placeholder) {
     super.onLoadCleared(placeholder);
     sizeDeterminer.clearCallbacksAndListener();
+
+    if (!isClearedByUs) {
+      maybeRemoveAttachStateListener();
+    }
   }
 
   /**
@@ -178,12 +310,14 @@ private Object getTag() {
    *
    * @param tagId The android resource to use.
    */
+  // Public API.
+  @SuppressWarnings("unused")
   public static void setTagId(int tagId) {
-      if (ViewTarget.tagId != null || isTagUsedAtLeastOnce) {
-          throw new IllegalArgumentException("You cannot set the tag id more than once or change"
-              + " the tag id after the first request has been made");
-      }
-      ViewTarget.tagId = tagId;
+    if (ViewTarget.tagId != null || isTagUsedAtLeastOnce) {
+      throw new IllegalArgumentException("You cannot set the tag id more than once or change"
+          + " the tag id after the first request has been made");
+    }
+    ViewTarget.tagId = tagId;
   }
 
   @VisibleForTesting
@@ -194,22 +328,21 @@ public static void setTagId(int tagId) {
     @Nullable
     static Integer maxDisplayLength;
     private final View view;
-    private final boolean waitForLayout;
     private final List<SizeReadyCallback> cbs = new ArrayList<>();
+    @Synthetic boolean waitForLayout;
 
     @Nullable private SizeDeterminerLayoutListener layoutListener;
 
-    SizeDeterminer(View view, boolean waitForLayout) {
+    SizeDeterminer(@NonNull View view) {
       this.view = view;
-      this.waitForLayout = waitForLayout;
     }
 
     // Use the maximum to avoid depending on the device's current orientation.
-    private static int getMaxDisplayLength(Context context) {
+    private static int getMaxDisplayLength(@NonNull Context context) {
       if (maxDisplayLength == null) {
         WindowManager windowManager =
             (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
-        Display display = windowManager.getDefaultDisplay();
+        Display display = Preconditions.checkNotNull(windowManager).getDefaultDisplay();
         Point displayDimensions = new Point();
         display.getSize(displayDimensions);
         maxDisplayLength = Math.max(displayDimensions.x, displayDimensions.y);
@@ -243,7 +376,7 @@ void checkCurrentDimens() {
       clearCallbacksAndListener();
     }
 
-    void getSize(SizeReadyCallback cb) {
+    void getSize(@NonNull SizeReadyCallback cb) {
       int currentWidth = getTargetWidth();
       int currentHeight = getTargetHeight();
       if (isViewStateAndSizeValid(currentWidth, currentHeight)) {
@@ -269,16 +402,16 @@ void getSize(SizeReadyCallback cb) {
      *
      * <p>See #2237.
      */
-    void removeCallback(SizeReadyCallback cb) {
+    void removeCallback(@NonNull SizeReadyCallback cb) {
       cbs.remove(cb);
     }
 
     void clearCallbacksAndListener() {
-      // Keep a reference to the layout listener and remove it here
+      // Keep a reference to the layout attachStateListener and remove it here
       // rather than having the observer remove itself because the observer
-      // we add the listener to will be almost immediately merged into
+      // we add the attachStateListener to will be almost immediately merged into
       // another observer and will therefore never be alive. If we instead
-      // keep a reference to the listener and remove it here, we get the
+      // keep a reference to the attachStateListener and remove it here, we get the
       // current view tree observer and should succeed.
       ViewTreeObserver observer = view.getViewTreeObserver();
       if (observer.isAlive()) {
@@ -371,14 +504,14 @@ private boolean isDimensionValid(int size) {
         implements ViewTreeObserver.OnPreDrawListener {
       private final WeakReference<SizeDeterminer> sizeDeterminerRef;
 
-      SizeDeterminerLayoutListener(SizeDeterminer sizeDeterminer) {
+      SizeDeterminerLayoutListener(@NonNull SizeDeterminer sizeDeterminer) {
         sizeDeterminerRef = new WeakReference<>(sizeDeterminer);
       }
 
       @Override
       public boolean onPreDraw() {
         if (Log.isLoggable(TAG, Log.VERBOSE)) {
-          Log.v(TAG, "OnGlobalLayoutListener called listener=" + this);
+          Log.v(TAG, "OnGlobalLayoutListener called attachStateListener=" + this);
         }
         SizeDeterminer sizeDeterminer = sizeDeterminerRef.get();
         if (sizeDeterminer != null) {
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/BitmapContainerTransitionFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/BitmapContainerTransitionFactory.java
index 012d2009b..8bec74e45 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/BitmapContainerTransitionFactory.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/BitmapContainerTransitionFactory.java
@@ -17,6 +17,8 @@
 public abstract class BitmapContainerTransitionFactory<R> implements TransitionFactory<R> {
   private final TransitionFactory<Drawable> realFactory;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public BitmapContainerTransitionFactory(TransitionFactory<Drawable> realFactory) {
     this.realFactory = realFactory;
   }
@@ -37,10 +39,10 @@ public BitmapContainerTransitionFactory(TransitionFactory<Drawable> realFactory)
    */
   protected abstract Bitmap getBitmap(R current);
 
-  private class BitmapGlideAnimation implements Transition<R> {
+  private final class BitmapGlideAnimation implements Transition<R> {
     private final Transition<Drawable> transition;
 
-    public BitmapGlideAnimation(Transition<Drawable> transition) {
+    BitmapGlideAnimation(Transition<Drawable> transition) {
       this.transition = transition;
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java
index 3aeab1922..0a8da3056 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java
@@ -13,6 +13,8 @@
  * user typically does not expect to see a transition. As a result, when the resource is loaded from
  * the memory cache this factory produces an {@link NoTransition}.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public class DrawableCrossFadeFactory implements TransitionFactory<Drawable> {
   private final int duration;
   private final boolean isCrossFadeEnabled;
@@ -39,9 +41,10 @@ protected DrawableCrossFadeFactory(int duration, boolean isCrossFadeEnabled) {
   /**
    * A Builder for {@link DrawableCrossFadeFactory}.
    */
+  @SuppressWarnings("unused")
   public static class Builder {
     private static final int DEFAULT_DURATION_MS = 300;
-    private int durationMillis;
+    private final int durationMillis;
     private boolean isCrossFadeEnabled;
 
     public Builder() {
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java
index cfdf30b31..730d84f30 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java
@@ -25,6 +25,8 @@
    *                         alpha at 100. See
    *                         {@link TransitionDrawable#setCrossFadeEnabled(boolean)}.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public DrawableCrossFadeTransition(int duration,
       boolean isCrossFadeEnabled) {
     this.duration = duration;
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java b/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java
index d5a1c1e33..1ef48eb2b 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java
@@ -10,7 +10,7 @@
  * {@link com.bumptech.glide.request.target.Target}.
  */
 public class NoTransition<R> implements Transition<R> {
-  @Synthetic static final NoTransition<?> NO_ANIMATION = new NoTransition<Object>();
+  @Synthetic static final NoTransition<?> NO_ANIMATION = new NoTransition<>();
   @SuppressWarnings("rawtypes")
   private static final TransitionFactory<?> NO_ANIMATION_FACTORY = new NoAnimationFactory();
 
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/ViewAnimationFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/ViewAnimationFactory.java
index 661c27715..e5a2cec05 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/ViewAnimationFactory.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/ViewAnimationFactory.java
@@ -14,6 +14,8 @@
   private final ViewTransition.ViewTransitionAnimationFactory viewTransitionAnimationFactory;
   private Transition<R> transition;
 
+  // Public API.
+  @SuppressWarnings("unused")
   public ViewAnimationFactory(Animation animation) {
     this(new ConcreteViewTransitionAnimationFactory(animation));
   }
@@ -52,7 +54,7 @@ public ViewAnimationFactory(int animationId) {
       .ViewTransitionAnimationFactory {
     private final Animation animation;
 
-    public ConcreteViewTransitionAnimationFactory(Animation animation) {
+    ConcreteViewTransitionAnimationFactory(Animation animation) {
       this.animation = animation;
     }
 
@@ -66,7 +68,7 @@ public Animation build(Context context) {
       .ViewTransitionAnimationFactory {
     private final int animationId;
 
-    public ResourceViewTransitionAnimationFactory(int animationId) {
+    ResourceViewTransitionAnimationFactory(int animationId) {
       this.animationId = animationId;
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/ViewPropertyTransition.java b/library/src/main/java/com/bumptech/glide/request/transition/ViewPropertyTransition.java
index e863a83be..45e75f760 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/ViewPropertyTransition.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/ViewPropertyTransition.java
@@ -19,6 +19,8 @@
    *
    * @param animator The animator to use.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public ViewPropertyTransition(Animator animator) {
     this.animator = animator;
   }
diff --git a/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java b/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java
index 974dc0abd..21d86931d 100644
--- a/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java
+++ b/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java
@@ -3,23 +3,29 @@
 import android.content.Context;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
+import android.util.Log;
 import com.bumptech.glide.load.Key;
 import java.util.UUID;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 
 /**
  * A utility class for obtaining a {@link com.bumptech.glide.load.Key} signature containing the
  * application version name using {@link android.content.pm.PackageInfo#versionCode}.
  */
 public final class ApplicationVersionSignature {
-  private static final ConcurrentHashMap<String, Key> PACKAGE_NAME_TO_KEY =
-      new ConcurrentHashMap<>();
+  private static final String TAG = "AppVersionSignature";
+  private static final ConcurrentMap<String, Key> PACKAGE_NAME_TO_KEY = new ConcurrentHashMap<>();
 
   /**
    * Returns the signature {@link com.bumptech.glide.load.Key} for version code of the Application
    * of the given Context.
    */
-  public static Key obtain(Context context) {
+  @NonNull
+  public static Key obtain(@NonNull Context context) {
     String packageName = context.getPackageName();
     Key result = PACKAGE_NAME_TO_KEY.get(packageName);
     if (result == null) {
@@ -34,26 +40,37 @@ public static Key obtain(Context context) {
     return result;
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static void reset() {
     PACKAGE_NAME_TO_KEY.clear();
   }
 
-  private static Key obtainVersionSignature(Context context) {
-    PackageInfo pInfo = null;
-    try {
-      pInfo = context.getPackageManager().getPackageInfo(context.getPackageName(), 0);
-    } catch (PackageManager.NameNotFoundException e) {
-      // Should never happen.
-      e.printStackTrace();
-    }
-    final String versionCode;
-    if (pInfo != null) {
-      versionCode = String.valueOf(pInfo.versionCode);
+  @NonNull
+  private static Key obtainVersionSignature(@NonNull Context context) {
+    PackageInfo packageInfo = getPackageInfo(context);
+    String versionCode = getVersionCode(packageInfo);
+    return new ObjectKey(versionCode);
+  }
+
+  @NonNull
+  private static String getVersionCode(@Nullable PackageInfo packageInfo) {
+    String versionCode;
+    if (packageInfo != null) {
+      versionCode = String.valueOf(packageInfo.versionCode);
     } else {
       versionCode = UUID.randomUUID().toString();
     }
-    return new ObjectKey(versionCode);
+    return versionCode;
+  }
+
+  @Nullable
+  private static PackageInfo getPackageInfo(@NonNull Context context) {
+    try {
+      return context.getPackageManager().getPackageInfo(context.getPackageName(), 0);
+    } catch (PackageManager.NameNotFoundException e) {
+      Log.e(TAG, "Cannot resolve info for" + context.getPackageName(), e);
+      return null;
+    }
   }
 
   private ApplicationVersionSignature() {
diff --git a/library/src/main/java/com/bumptech/glide/signature/EmptySignature.java b/library/src/main/java/com/bumptech/glide/signature/EmptySignature.java
index 93f572c0f..2763433aa 100644
--- a/library/src/main/java/com/bumptech/glide/signature/EmptySignature.java
+++ b/library/src/main/java/com/bumptech/glide/signature/EmptySignature.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.signature;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Key;
 import java.security.MessageDigest;
 
@@ -9,6 +10,7 @@
 public final class EmptySignature implements Key {
   private static final EmptySignature EMPTY_KEY = new EmptySignature();
 
+  @NonNull
   public static EmptySignature obtain() {
     return EMPTY_KEY;
   }
@@ -23,7 +25,7 @@ public String toString() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     // Do nothing.
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java b/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java
index e14e1a573..bb0e06b6e 100644
--- a/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java
+++ b/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java
@@ -1,7 +1,8 @@
 package com.bumptech.glide.signature;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.load.Key;
-import com.bumptech.glide.util.Util;
 import java.nio.ByteBuffer;
 import java.security.MessageDigest;
 
@@ -10,7 +11,7 @@
  * media store files like edits, rotations, and temporary file replacement.
  */
 public class MediaStoreSignature implements Key {
-  private final String mimeType;
+  @NonNull private final String mimeType;
   private final long dateModified;
   private final int orientation;
 
@@ -26,8 +27,8 @@
    * @param orientation  The orientation of the media store media. Ok to default to 0. See {@link
    *                     android.provider.MediaStore.Images.ImageColumns#ORIENTATION}.
    */
-  public MediaStoreSignature(String mimeType, long dateModified, int orientation) {
-    this.mimeType = mimeType;
+  public MediaStoreSignature(@Nullable String mimeType, long dateModified, int orientation) {
+    this.mimeType = mimeType == null ? "" : mimeType;
     this.dateModified = dateModified;
     this.orientation = orientation;
   }
@@ -50,7 +51,7 @@ public boolean equals(Object o) {
     if (orientation != that.orientation) {
       return false;
     }
-    if (!Util.bothNullOrEqual(mimeType, that.mimeType)) {
+    if (!mimeType.equals(that.mimeType)) {
       return false;
     }
     return true;
@@ -58,14 +59,14 @@ public boolean equals(Object o) {
 
   @Override
   public int hashCode() {
-    int result = mimeType != null ? mimeType.hashCode() : 0;
+    int result = mimeType.hashCode();
     result = 31 * result + (int) (dateModified ^ (dateModified >>> 32));
     result = 31 * result + orientation;
     return result;
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     byte[] data = ByteBuffer.allocate(12).putLong(dateModified).putInt(orientation).array();
     messageDigest.update(data);
     messageDigest.update(mimeType.getBytes(CHARSET));
diff --git a/library/src/main/java/com/bumptech/glide/signature/ObjectKey.java b/library/src/main/java/com/bumptech/glide/signature/ObjectKey.java
index 50ccc9f3f..ed3ea19e8 100644
--- a/library/src/main/java/com/bumptech/glide/signature/ObjectKey.java
+++ b/library/src/main/java/com/bumptech/glide/signature/ObjectKey.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.signature;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.util.Preconditions;
 import java.security.MessageDigest;
@@ -16,7 +17,7 @@
 public final class ObjectKey implements Key {
   private final Object object;
 
-  public ObjectKey(Object object) {
+  public ObjectKey(@NonNull Object object) {
     this.object = Preconditions.checkNotNull(object);
   }
 
@@ -42,7 +43,7 @@ public int hashCode() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     messageDigest.update(object.toString().getBytes(CHARSET));
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java b/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
index fca34c71a..8f0bee837 100644
--- a/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
+++ b/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.util;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.IOException;
@@ -13,6 +15,7 @@
 /**
  * Utilities for interacting with {@link java.nio.ByteBuffer}s.
  */
+@SuppressWarnings({"unused", "WeakerAccess"}) // Public API
 public final class ByteBufferUtil {
   // 16 Kb
   private static final int BUFFER_SIZE = 16384;
@@ -22,7 +25,8 @@ private ByteBufferUtil() {
     // Utility class.
   }
 
-  public static ByteBuffer fromFile(File file) throws IOException {
+  @NonNull
+  public static ByteBuffer fromFile(@NonNull File file) throws IOException {
     RandomAccessFile raf = null;
     FileChannel channel = null;
     try {
@@ -31,6 +35,11 @@ public static ByteBuffer fromFile(File file) throws IOException {
       if (fileLength > Integer.MAX_VALUE) {
         throw new IOException("File too large to map into memory");
       }
+      // See b/67710449.
+      if (fileLength == 0) {
+        throw new IOException("File unsuitable for memory mapping");
+      }
+
       raf = new RandomAccessFile(file, "r");
       channel = raf.getChannel();
       return channel.map(FileChannel.MapMode.READ_ONLY, 0, fileLength).load();
@@ -52,7 +61,7 @@ public static ByteBuffer fromFile(File file) throws IOException {
     }
   }
 
-  public static void toFile(ByteBuffer buffer, File file) throws IOException {
+  public static void toFile(@NonNull ByteBuffer buffer, @NonNull File file) throws IOException {
     buffer.position(0);
     RandomAccessFile raf = null;
     FileChannel channel = null;
@@ -81,7 +90,8 @@ public static void toFile(ByteBuffer buffer, File file) throws IOException {
     }
   }
 
-  public static void toStream(ByteBuffer byteBuffer, OutputStream os) throws IOException {
+  public static void toStream(@NonNull ByteBuffer byteBuffer,
+      @NonNull OutputStream os) throws IOException {
     SafeArray safeArray = getSafeArray(byteBuffer);
     if (safeArray != null) {
       os.write(safeArray.data, safeArray.offset, safeArray.offset + safeArray.limit);
@@ -101,7 +111,8 @@ public static void toStream(ByteBuffer byteBuffer, OutputStream os) throws IOExc
     }
   }
 
-  public static byte[] toBytes(ByteBuffer byteBuffer) {
+  @NonNull
+  public static byte[] toBytes(@NonNull ByteBuffer byteBuffer) {
     final byte[] result;
     SafeArray safeArray = getSafeArray(byteBuffer);
     if (safeArray != null && safeArray.offset == 0 && safeArray.limit == safeArray.data.length) {
@@ -115,11 +126,13 @@ public static void toStream(ByteBuffer byteBuffer, OutputStream os) throws IOExc
     return result;
   }
 
-  public static InputStream toStream(ByteBuffer buffer) {
+  @NonNull
+  public static InputStream toStream(@NonNull ByteBuffer buffer) {
     return new ByteBufferStream(buffer);
   }
 
-  public static ByteBuffer fromStream(InputStream stream) throws IOException {
+  @NonNull
+  public static ByteBuffer fromStream(@NonNull InputStream stream) throws IOException {
     ByteArrayOutputStream outStream = new ByteArrayOutputStream(BUFFER_SIZE);
 
     byte[] buffer = BUFFER_REF.getAndSet(null);
@@ -127,7 +140,7 @@ public static ByteBuffer fromStream(InputStream stream) throws IOException {
       buffer = new byte[BUFFER_SIZE];
     }
 
-    int n = -1;
+    int n;
     while ((n = stream.read(buffer)) >= 0) {
       outStream.write(buffer, 0, n);
     }
@@ -140,7 +153,8 @@ public static ByteBuffer fromStream(InputStream stream) throws IOException {
     return (ByteBuffer) ByteBuffer.allocateDirect(bytes.length).put(bytes).position(0);
   }
 
-  private static SafeArray getSafeArray(ByteBuffer byteBuffer) {
+  @Nullable
+  private static SafeArray getSafeArray(@NonNull ByteBuffer byteBuffer) {
     if (!byteBuffer.isReadOnly() && byteBuffer.hasArray()) {
       return new SafeArray(byteBuffer.array(), byteBuffer.arrayOffset(), byteBuffer.limit());
     }
@@ -152,7 +166,9 @@ private static SafeArray getSafeArray(ByteBuffer byteBuffer) {
     @Synthetic final int limit;
     @Synthetic final byte[] data;
 
-    public SafeArray(byte[] data, int offset, int limit) {
+    // PMD.ArrayIsStoredDirectly Copying would be prohibitively expensive and/or lead to OOMs.
+    @SuppressWarnings("PMD.ArrayIsStoredDirectly")
+    SafeArray(@NonNull byte[] data, int offset, int limit) {
       this.data = data;
       this.offset = offset;
       this.limit = limit;
@@ -161,20 +177,20 @@ public SafeArray(byte[] data, int offset, int limit) {
 
   private static class ByteBufferStream extends InputStream {
     private static final int UNSET = -1;
-    private final ByteBuffer byteBuffer;
+    @NonNull private final ByteBuffer byteBuffer;
     private int markPos = UNSET;
 
-    public ByteBufferStream(ByteBuffer byteBuffer) {
+    ByteBufferStream(@NonNull ByteBuffer byteBuffer) {
       this.byteBuffer = byteBuffer;
     }
 
     @Override
-    public int available() throws IOException {
+    public int available() {
       return byteBuffer.remaining();
     }
 
     @Override
-    public int read() throws IOException {
+    public int read() {
       if (!byteBuffer.hasRemaining()) {
         return -1;
       }
@@ -182,7 +198,7 @@ public int read() throws IOException {
     }
 
     @Override
-    public synchronized void mark(int readlimit) {
+    public synchronized void mark(int readLimit) {
       markPos = byteBuffer.position();
     }
 
@@ -192,7 +208,7 @@ public boolean markSupported() {
     }
 
     @Override
-    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
+    public int read(@NonNull byte[] buffer, int byteOffset, int byteCount) throws IOException {
       if (!byteBuffer.hasRemaining()) {
         return -1;
       }
diff --git a/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java b/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java
index 0f4803ace..2b0283e03 100644
--- a/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java
+++ b/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.util;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.text.TextUtils;
 import android.util.Log;
 import java.io.FilterInputStream;
@@ -17,15 +19,18 @@
   private final long contentLength;
   private int readSoFar;
 
-  public static InputStream obtain(InputStream other, String contentLengthHeader) {
+  @NonNull
+  public static InputStream obtain(@NonNull InputStream other,
+      @Nullable String contentLengthHeader) {
     return obtain(other, parseContentLength(contentLengthHeader));
   }
 
-  public static InputStream obtain(InputStream other, long contentLength) {
+  @NonNull
+  public static InputStream obtain(@NonNull InputStream other, long contentLength) {
     return new ContentLengthInputStream(other, contentLength);
   }
 
-  private static int parseContentLength(String contentLengthHeader) {
+  private static int parseContentLength(@Nullable String contentLengthHeader) {
     int result = UNKNOWN;
     if (!TextUtils.isEmpty(contentLengthHeader)) {
       try {
@@ -39,7 +44,7 @@ private static int parseContentLength(String contentLengthHeader) {
     return result;
   }
 
-  ContentLengthInputStream(InputStream in, long contentLength) {
+  private ContentLengthInputStream(@NonNull InputStream in, long contentLength) {
     super(in);
     this.contentLength = contentLength;
   }
@@ -62,7 +67,8 @@ public int read(byte[] buffer) throws IOException {
   }
 
   @Override
-  public synchronized int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
+  public synchronized int read(byte[] buffer, int byteOffset, int byteCount)
+      throws IOException {
     return checkReadSoFarOrThrow(super.read(buffer, byteOffset, byteCount));
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/util/ExceptionCatchingInputStream.java b/library/src/main/java/com/bumptech/glide/util/ExceptionCatchingInputStream.java
index c64b8572b..3f5b05fb0 100644
--- a/library/src/main/java/com/bumptech/glide/util/ExceptionCatchingInputStream.java
+++ b/library/src/main/java/com/bumptech/glide/util/ExceptionCatchingInputStream.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.util;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.Queue;
@@ -19,7 +21,8 @@
   private InputStream wrapped;
   private IOException exception;
 
-  public static ExceptionCatchingInputStream obtain(InputStream toWrap) {
+  @NonNull
+  public static ExceptionCatchingInputStream obtain(@NonNull InputStream toWrap) {
     ExceptionCatchingInputStream result;
     synchronized (QUEUE) {
       result = QUEUE.poll();
@@ -42,7 +45,7 @@ static void clearQueue() {
     // Do nothing.
   }
 
-  void setInputStream(InputStream toWrap) {
+  void setInputStream(@NonNull InputStream toWrap) {
     wrapped = toWrap;
   }
 
@@ -57,8 +60,8 @@ public void close() throws IOException {
   }
 
   @Override
-  public void mark(int readlimit) {
-    wrapped.mark(readlimit);
+  public void mark(int readLimit) {
+    wrapped.mark(readLimit);
   }
 
   @Override
@@ -67,7 +70,7 @@ public boolean markSupported() {
   }
 
   @Override
-  public int read(byte[] buffer) throws IOException {
+  public int read(byte[] buffer) {
     int read;
     try {
       read = wrapped.read(buffer);
@@ -79,7 +82,7 @@ public int read(byte[] buffer) throws IOException {
   }
 
   @Override
-  public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
+  public int read(byte[] buffer, int byteOffset, int byteCount) {
     int read;
     try {
       read = wrapped.read(buffer, byteOffset, byteCount);
@@ -96,7 +99,7 @@ public synchronized void reset() throws IOException {
   }
 
   @Override
-  public long skip(long byteCount) throws IOException {
+  public long skip(long byteCount) {
     long skipped;
     try {
       skipped = wrapped.skip(byteCount);
@@ -108,7 +111,7 @@ public long skip(long byteCount) throws IOException {
   }
 
   @Override
-  public int read() throws IOException {
+  public int read() {
     int result;
     try {
       result = wrapped.read();
@@ -119,6 +122,7 @@ public int read() throws IOException {
     return result;
   }
 
+  @Nullable
   public IOException getException() {
     return exception;
   }
diff --git a/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java b/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java
index b6c9e40d4..08b7ed3ba 100644
--- a/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java
+++ b/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java
@@ -1,7 +1,8 @@
 package com.bumptech.glide.util;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.ListPreloader;
-import java.util.Arrays;
 
 /**
  * A {@link com.bumptech.glide.ListPreloader.PreloadSizeProvider} with a fixed width and height.
@@ -22,8 +23,12 @@ public FixedPreloadSizeProvider(int width, int height) {
     this.size = new int[] { width, height };
   }
 
+  @Nullable
   @Override
-  public int[] getPreloadSize(T item, int adapterPosition, int itemPosition) {
-    return Arrays.copyOf(this.size, this.size.length);
+  // It's better to take on the risk that callers may mutate the array when there isn't any reason
+  // for them to do so than it the performance overhead of copying the array with every call.
+  @SuppressWarnings("PMD.MethodReturnsInternalArray")
+  public int[] getPreloadSize(@NonNull T item, int adapterPosition, int itemPosition) {
+    return size;
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/util/LogTime.java b/library/src/main/java/com/bumptech/glide/util/LogTime.java
index 344dbaa12..58ddd6269 100644
--- a/library/src/main/java/com/bumptech/glide/util/LogTime.java
+++ b/library/src/main/java/com/bumptech/glide/util/LogTime.java
@@ -9,7 +9,7 @@
  */
 public final class LogTime {
   private static final double MILLIS_MULTIPLIER =
-      Build.VERSION_CODES.JELLY_BEAN_MR1 <= Build.VERSION.SDK_INT ? 1d / Math.pow(10, 6) : 1d;
+      Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1 ? 1d / Math.pow(10, 6) : 1d;
 
   private LogTime() {
     // Utility class.
@@ -21,7 +21,7 @@ private LogTime() {
    */
   @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
   public static long getLogTime() {
-    if (Build.VERSION_CODES.JELLY_BEAN_MR1 <= Build.VERSION.SDK_INT) {
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
       return SystemClock.elapsedRealtimeNanos();
     } else {
       return SystemClock.uptimeMillis();
diff --git a/library/src/main/java/com/bumptech/glide/util/LruCache.java b/library/src/main/java/com/bumptech/glide/util/LruCache.java
index 1311fa176..a2cd7d822 100644
--- a/library/src/main/java/com/bumptech/glide/util/LruCache.java
+++ b/library/src/main/java/com/bumptech/glide/util/LruCache.java
@@ -1,6 +1,8 @@
 package com.bumptech.glide.util;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.Map;
 
@@ -13,10 +15,10 @@
  * @param <Y> The type of the values.
  */
 public class LruCache<T, Y> {
-  private final LinkedHashMap<T, Y> cache = new LinkedHashMap<>(100, 0.75f, true);
-  private final int initialMaxSize;
-  private int maxSize;
-  private int currentSize = 0;
+  private final Map<T, Y> cache = new LinkedHashMap<>(100, 0.75f, true);
+  private final long initialMaxSize;
+  private long maxSize;
+  private long currentSize;
 
   /**
    * Constructor for LruCache.
@@ -24,7 +26,7 @@
    * @param size The maximum size of the cache, the units must match the units used in {@link
    *             #getSize(Object)}.
    */
-  public LruCache(int size) {
+  public LruCache(long size) {
     this.initialMaxSize = size;
     this.maxSize = size;
   }
@@ -51,7 +53,7 @@ public synchronized void setSizeMultiplier(float multiplier) {
    *
    * @param item The item to get the size of.
    */
-  protected int getSize(Y item) {
+  protected int getSize(@Nullable Y item) {
     return 1;
   }
 
@@ -68,21 +70,21 @@ protected synchronized int getCount() {
    * @param key  The key of the evicted item.
    * @param item The evicted item.
    */
-  protected void onItemEvicted(T key, Y item) {
+  protected void onItemEvicted(@NonNull T key, @Nullable Y item) {
     // optional override
   }
 
   /**
    * Returns the current maximum size of the cache in bytes.
    */
-  public synchronized int getMaxSize() {
+  public synchronized long getMaxSize() {
     return maxSize;
   }
 
   /**
    * Returns the sum of the sizes of all items in the cache.
    */
-  public synchronized int getCurrentSize() {
+  public synchronized long getCurrentSize() {
     return currentSize;
   }
 
@@ -92,7 +94,7 @@ public synchronized int getCurrentSize() {
    * @param key The key to check.
    */
 
-  public synchronized boolean contains(T key) {
+  public synchronized boolean contains(@NonNull T key) {
     return cache.containsKey(key);
   }
 
@@ -102,7 +104,7 @@ public synchronized boolean contains(T key) {
    * @param key The key to check.
    */
   @Nullable
-  public synchronized Y get(T key) {
+  public synchronized Y get(@NonNull T key) {
     return cache.get(key);
   }
 
@@ -110,31 +112,35 @@ public synchronized Y get(T key) {
    * Adds the given item to the cache with the given key and returns any previous entry for the
    * given key that may have already been in the cache.
    *
-   * <p> If the size of the item is larger than the total cache size, the item will not be added to
+   * <p>If the size of the item is larger than the total cache size, the item will not be added to
    * the cache and instead {@link #onItemEvicted(Object, Object)} will be called synchronously with
-   * the given key and item. </p>
+   * the given key and item.
    *
    * @param key  The key to add the item at.
    * @param item The item to add.
    */
-  public synchronized Y put(T key, Y item) {
+  @Nullable
+  public synchronized Y put(@NonNull T key, @Nullable Y item) {
     final int itemSize = getSize(item);
     if (itemSize >= maxSize) {
       onItemEvicted(key, item);
       return null;
     }
 
-    final Y result = cache.put(key, item);
     if (item != null) {
-      currentSize += getSize(item);
+      currentSize += itemSize;
     }
-    if (result != null) {
-      // TODO: should we call onItemEvicted here?
-      currentSize -= getSize(result);
+    @Nullable final Y old = cache.put(key, item);
+    if (old != null) {
+      currentSize -= getSize(old);
+
+      if (!old.equals(item)) {
+        onItemEvicted(key, old);
+      }
     }
     evict();
 
-    return result;
+    return old;
   }
 
   /**
@@ -143,7 +149,7 @@ public synchronized Y put(T key, Y item) {
    * @param key The key to remove the item at.
    */
   @Nullable
-  public synchronized Y remove(T key) {
+  public synchronized Y remove(@NonNull T key) {
     final Y value = cache.remove(key);
     if (value != null) {
       currentSize -= getSize(value);
@@ -164,14 +170,16 @@ public void clearMemory() {
    *
    * @param size The size the cache should be less than.
    */
-  protected synchronized void trimToSize(int size) {
+  protected synchronized void trimToSize(long size) {
     Map.Entry<T, Y> last;
+    Iterator<Map.Entry<T, Y>> cacheIterator;
     while (currentSize > size) {
-      last = cache.entrySet().iterator().next();
+      cacheIterator  = cache.entrySet().iterator();
+      last = cacheIterator.next();
       final Y toRemove = last.getValue();
       currentSize -= getSize(toRemove);
       final T key = last.getKey();
-      cache.remove(key);
+      cacheIterator.remove();
       onItemEvicted(key, toRemove);
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/util/MarkEnforcingInputStream.java b/library/src/main/java/com/bumptech/glide/util/MarkEnforcingInputStream.java
index bec16fa67..bf8cee9a1 100644
--- a/library/src/main/java/com/bumptech/glide/util/MarkEnforcingInputStream.java
+++ b/library/src/main/java/com/bumptech/glide/util/MarkEnforcingInputStream.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.util;
 
+import android.support.annotation.NonNull;
 import java.io.FilterInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -14,14 +15,14 @@
 
   private int availableBytes = UNSET;
 
-  public MarkEnforcingInputStream(InputStream in) {
+  public MarkEnforcingInputStream(@NonNull InputStream in) {
     super(in);
   }
 
   @Override
-  public void mark(int readlimit) {
-    super.mark(readlimit);
-    availableBytes = readlimit;
+  public synchronized void mark(int readLimit) {
+    super.mark(readLimit);
+    availableBytes = readLimit;
   }
 
   @Override
@@ -36,7 +37,7 @@ public int read() throws IOException {
   }
 
   @Override
-  public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
+  public int read(@NonNull byte[] buffer, int byteOffset, int byteCount) throws IOException {
     int toRead = (int) getBytesToRead(byteCount);
     if (toRead == END_OF_STREAM) {
       return END_OF_STREAM;
@@ -48,7 +49,7 @@ public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException
   }
 
   @Override
-  public void reset() throws IOException {
+  public synchronized void reset() throws IOException {
     super.reset();
     availableBytes = UNSET;
   }
@@ -57,7 +58,7 @@ public void reset() throws IOException {
   public long skip(long byteCount) throws IOException {
     long toSkip = getBytesToRead(byteCount);
     if (toSkip == END_OF_STREAM) {
-      return END_OF_STREAM;
+      return 0;
     }
 
     long read = super.skip(toSkip);
@@ -83,7 +84,8 @@ private long getBytesToRead(long targetByteCount) {
 
   private void updateAvailableBytesAfterRead(long bytesRead) {
     if (availableBytes != UNSET && bytesRead != END_OF_STREAM) {
-      availableBytes -= bytesRead;
+      // See http://errorprone.info/bugpattern/NarrowingCompoundAssignment.
+      availableBytes = (int) (availableBytes - bytesRead);
     }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/util/MultiClassKey.java b/library/src/main/java/com/bumptech/glide/util/MultiClassKey.java
index 18fd5e04e..54fac7310 100644
--- a/library/src/main/java/com/bumptech/glide/util/MultiClassKey.java
+++ b/library/src/main/java/com/bumptech/glide/util/MultiClassKey.java
@@ -1,5 +1,8 @@
 package com.bumptech.glide.util;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
 /**
  * A key of two {@link Class}es to be used in hashed collections.
  */
@@ -13,19 +16,20 @@ public MultiClassKey() {
     // leave them null
   }
 
-  public MultiClassKey(Class<?> first, Class<?> second) {
+  public MultiClassKey(@NonNull Class<?> first, @NonNull Class<?> second) {
     set(first, second);
   }
 
-  public MultiClassKey(Class<?> first, Class<?> second, Class<?> third) {
+  public MultiClassKey(@NonNull Class<?> first, @NonNull Class<?> second,
+      @Nullable Class<?> third) {
     set(first, second, third);
   }
 
-  public void set(Class<?> first, Class<?> second) {
+  public void set(@NonNull Class<?> first, @NonNull Class<?> second) {
     set(first, second, null);
   }
 
-  public void set(Class<?> first, Class<?> second, Class<?> third) {
+  public void set(@NonNull Class<?> first, @NonNull Class<?> second, @Nullable Class<?> third) {
     this.first = first;
     this.second = second;
     this.third = third;
diff --git a/library/src/main/java/com/bumptech/glide/util/Preconditions.java b/library/src/main/java/com/bumptech/glide/util/Preconditions.java
index 121ead84c..4ca650fc7 100644
--- a/library/src/main/java/com/bumptech/glide/util/Preconditions.java
+++ b/library/src/main/java/com/bumptech/glide/util/Preconditions.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.util;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.text.TextUtils;
 import java.util.Collection;
 
@@ -12,31 +14,35 @@ private Preconditions() {
     // Utility class.
   }
 
-  public static void checkArgument(boolean expression, String message) {
+  public static void checkArgument(boolean expression, @NonNull String message) {
     if (!expression) {
       throw new IllegalArgumentException(message);
     }
   }
 
-  public static <T> T checkNotNull(T arg) {
+  @NonNull
+  public static <T> T checkNotNull(@Nullable T arg) {
     return checkNotNull(arg, "Argument must not be null");
   }
 
-  public static <T> T checkNotNull(T arg, String message) {
+  @NonNull
+  public static <T> T checkNotNull(@Nullable T arg, @NonNull String message) {
     if (arg == null) {
       throw new NullPointerException(message);
     }
     return arg;
   }
 
-  public static String checkNotEmpty(String string) {
+  @NonNull
+  public static String checkNotEmpty(@Nullable String string) {
     if (TextUtils.isEmpty(string)) {
       throw new IllegalArgumentException("Must not be null or empty");
     }
     return string;
   }
 
-  public static <T extends Collection<Y>, Y> T checkNotEmpty(T collection) {
+  @NonNull
+  public static <T extends Collection<Y>, Y> T checkNotEmpty(@NonNull T collection) {
     if (collection.isEmpty()) {
       throw new IllegalArgumentException("Must not be empty.");
     }
diff --git a/library/src/main/java/com/bumptech/glide/util/Util.java b/library/src/main/java/com/bumptech/glide/util/Util.java
index ed5224809..de4b3784b 100644
--- a/library/src/main/java/com/bumptech/glide/util/Util.java
+++ b/library/src/main/java/com/bumptech/glide/util/Util.java
@@ -4,6 +4,8 @@
 import android.graphics.Bitmap;
 import android.os.Build;
 import android.os.Looper;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.load.model.Model;
 import com.bumptech.glide.request.target.Target;
 import java.util.ArrayDeque;
@@ -29,7 +31,8 @@ private Util() {
   /**
    * Returns the hex string of the given byte array representing a SHA256 hash.
    */
-  public static String sha256BytesToHex(byte[] bytes) {
+  @NonNull
+  public static String sha256BytesToHex(@NonNull byte[] bytes) {
     synchronized (SHA_256_CHARS) {
       return bytesToHex(bytes, SHA_256_CHARS);
     }
@@ -39,7 +42,8 @@ public static String sha256BytesToHex(byte[] bytes) {
   // http://stackoverflow.com/questions/9655181/convert-from-byte-array-to-hex-string-in-java
   // /9655275#9655275
   @SuppressWarnings("PMD.UseVarargs")
-  private static String bytesToHex(byte[] bytes, char[] hexChars) {
+  @NonNull
+  private static String bytesToHex(@NonNull byte[] bytes, @NonNull char[] hexChars) {
     int v;
     for (int j = 0; j < bytes.length; j++) {
       v = bytes[j] & 0xFF;
@@ -57,7 +61,7 @@ private static String bytesToHex(byte[] bytes, char[] hexChars) {
    * removed in Glide 4.0.
    */
   @Deprecated
-  public static int getSize(Bitmap bitmap) {
+  public static int getSize(@NonNull Bitmap bitmap) {
     return getBitmapByteSize(bitmap);
   }
 
@@ -65,7 +69,7 @@ public static int getSize(Bitmap bitmap) {
    * Returns the in memory size of the given {@link Bitmap} in bytes.
    */
   @TargetApi(Build.VERSION_CODES.KITKAT)
-  public static int getBitmapByteSize(Bitmap bitmap) {
+  public static int getBitmapByteSize(@NonNull Bitmap bitmap) {
     // The return value of getAllocationByteCount silently changes for recycled bitmaps from the
     // internal buffer size to row bytes * height. To avoid random inconsistencies in caches, we
     // instead assert here.
@@ -77,7 +81,7 @@ public static int getBitmapByteSize(Bitmap bitmap) {
       // Workaround for KitKat initial release NPE in Bitmap, fixed in MR1. See issue #148.
       try {
         return bitmap.getAllocationByteCount();
-      } catch (NullPointerException e) {
+      } catch (@SuppressWarnings("PMD.AvoidCatchingNPE") NullPointerException e) {
         // Do nothing.
       }
     }
@@ -88,11 +92,11 @@ public static int getBitmapByteSize(Bitmap bitmap) {
    * Returns the in memory size of {@link android.graphics.Bitmap} with the given width, height, and
    * {@link android.graphics.Bitmap.Config}.
    */
-  public static int getBitmapByteSize(int width, int height, Bitmap.Config config) {
+  public static int getBitmapByteSize(int width, int height, @Nullable Bitmap.Config config) {
     return width * height * getBytesPerPixel(config);
   }
 
-  private static int getBytesPerPixel(Bitmap.Config config) {
+  private static int getBytesPerPixel(@Nullable Bitmap.Config config) {
     // A bitmap by decoding a GIF has null "config" in certain environments.
     if (config == null) {
       config = Bitmap.Config.ARGB_8888;
@@ -107,6 +111,9 @@ private static int getBytesPerPixel(Bitmap.Config config) {
       case ARGB_4444:
         bytesPerPixel = 2;
         break;
+      case RGBA_F16:
+        bytesPerPixel = 8;
+        break;
       case ARGB_8888:
       default:
         bytesPerPixel = 4;
@@ -162,6 +169,7 @@ public static boolean isOnBackgroundThread() {
   /**
    * Creates a {@link java.util.Queue} of the given size using Glide's preferred implementation.
    */
+  @NonNull
   public static <T> Queue<T> createQueue(int size) {
     return new ArrayDeque<>(size);
   }
@@ -170,14 +178,20 @@ public static boolean isOnBackgroundThread() {
    * Returns a copy of the given list that is safe to iterate over and perform actions that may
    * modify the original list.
    *
-   * <p> See #303 and #375. </p>
+   * <p>See #303, #375, #322, #2262.
    */
-  public static <T> List<T> getSnapshot(Collection<T> other) {
-    // toArray creates a new ArrayList internally and this way we can guarantee entries will not
-    // be null. See #322.
-    List<T> result = new ArrayList<T>(other.size());
+  @NonNull
+  @SuppressWarnings("UseBulkOperation")
+  public static <T> List<T> getSnapshot(@NonNull Collection<T> other) {
+    // toArray creates a new ArrayList internally and does not guarantee that the values it contains
+    // are non-null. Collections.addAll in ArrayList uses toArray internally and therefore also
+    // doesn't guarantee that entries are non-null. WeakHashMap's iterator does avoid returning null
+    // and is therefore safe to use. See #322, #2262.
+    List<T> result = new ArrayList<>(other.size());
     for (T item : other) {
-      result.add(item);
+      if (item != null) {
+        result.add(item);
+      }
     }
     return result;
   }
@@ -187,11 +201,11 @@ public static boolean isOnBackgroundThread() {
    *
    * @see java.util.Objects#equals
    */
-  public static boolean bothNullOrEqual(Object a, Object b) {
+  public static boolean bothNullOrEqual(@Nullable Object a, @Nullable Object b) {
     return a == null ? b == null : a.equals(b);
   }
 
-  public static boolean bothModelsNullEquivalentOrEquals(Object a, Object b) {
+  public static boolean bothModelsNullEquivalentOrEquals(@Nullable Object a, @Nullable Object b) {
     if (a == null) {
       return b == null;
     }
@@ -217,7 +231,7 @@ public static int hashCode(float value, int accumulator) {
     return hashCode(Float.floatToIntBits(value), accumulator);
   }
 
-  public static int hashCode(Object object, int accumulator) {
+  public static int hashCode(@Nullable Object object, int accumulator) {
     return hashCode(object == null ? 0 : object.hashCode(), accumulator);
   }
 
@@ -228,5 +242,4 @@ public static int hashCode(boolean value, int accumulator) {
   public static int hashCode(boolean value) {
     return hashCode(value, HASH_ACCUMULATOR);
   }
-
 }
diff --git a/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java b/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java
index 5f341a5b4..90580d544 100644
--- a/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java
+++ b/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.util;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 import com.bumptech.glide.ListPreloader;
 import com.bumptech.glide.request.target.SizeReadyCallback;
@@ -37,22 +39,25 @@ public ViewPreloadSizeProvider() {
    * @param view A not null View the size will be extracted from async using an {@link
    *             android.view.ViewTreeObserver .OnPreDrawListener}
    */
-  public ViewPreloadSizeProvider(View view) {
-    this.viewTarget = new SizeViewTarget(view, this);
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public ViewPreloadSizeProvider(@NonNull View view) {
+    viewTarget = new SizeViewTarget(view, this);
   }
 
+  @Nullable
   @Override
-  public int[] getPreloadSize(T item, int adapterPosition, int itemPosition) {
+  public int[] getPreloadSize(@NonNull T item, int adapterPosition, int itemPosition) {
     if (size == null) {
       return null;
     } else {
-      return Arrays.copyOf(this.size, this.size.length);
+      return Arrays.copyOf(size, size.length);
     }
   }
 
   @Override
   public void onSizeReady(int width, int height) {
-    this.size = new int[] { width, height };
+    size = new int[]{width, height};
     viewTarget = null;
   }
 
@@ -65,21 +70,22 @@ public void onSizeReady(int width, int height) {
    * @param view A not null View the size will be extracted async with an {@link
    *             android.view.ViewTreeObserver .OnPreDrawListener}
    */
-  public void setView(View view) {
-    if (this.size != null || viewTarget != null) {
+  public void setView(@NonNull View view) {
+    if (size != null || viewTarget != null) {
       return;
     }
-    this.viewTarget = new SizeViewTarget(view, this);
+    viewTarget = new SizeViewTarget(view, this);
   }
 
   private static final class SizeViewTarget extends ViewTarget<View, Object> {
-    public SizeViewTarget(View view, SizeReadyCallback callback) {
+    SizeViewTarget(@NonNull View view, @NonNull SizeReadyCallback callback) {
       super(view);
       getSize(callback);
     }
 
     @Override
-    public void onResourceReady(Object resource, Transition<? super Object> transition) {
+    public void onResourceReady(@NonNull Object resource,
+        @Nullable Transition<? super Object> transition) {
       // Do nothing
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java b/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java
index 23416d80d..12e641dc5 100644
--- a/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java
+++ b/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.util.pool;
 
+import android.support.annotation.NonNull;
 import android.support.v4.util.Pools.Pool;
 import android.support.v4.util.Pools.SimplePool;
 import android.support.v4.util.Pools.SynchronizedPool;
@@ -17,7 +18,7 @@
   private static final int DEFAULT_POOL_SIZE = 20;
   private static final Resetter<Object> EMPTY_RESETTER = new Resetter<Object>() {
     @Override
-    public void reset(Object object) {
+    public void reset(@NonNull Object object) {
       // Do nothing.
     }
   };
@@ -34,7 +35,8 @@ private FactoryPools() { }
    *
    * @param <T> The type of object the pool will contains.
    */
-  public static <T extends Poolable> Pool<T> simple(int size, Factory<T> factory) {
+  @NonNull
+  public static <T extends Poolable> Pool<T> simple(int size, @NonNull Factory<T> factory) {
     return build(new SimplePool<T>(size), factory);
   }
 
@@ -48,7 +50,8 @@ private FactoryPools() { }
    *
    * @param <T> The type of object the pool will contains.
    */
-  public static <T extends Poolable> Pool<T> threadSafe(int size, Factory<T> factory) {
+  @NonNull
+  public static <T extends Poolable> Pool<T> threadSafe(int size, @NonNull Factory<T> factory) {
     return build(new SynchronizedPool<T>(size), factory);
   }
 
@@ -61,6 +64,7 @@ private FactoryPools() { }
    *
    * @param <T> The type of object that the {@link List Lists} will contain.
    */
+  @NonNull
   public static <T> Pool<List<T>> threadSafeList() {
     return threadSafeList(DEFAULT_POOL_SIZE);
   }
@@ -74,29 +78,37 @@ private FactoryPools() { }
    *
    * @param <T> The type of object that the {@link List Lists} will contain.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  @NonNull
   public static <T> Pool<List<T>> threadSafeList(int size) {
     return build(new SynchronizedPool<List<T>>(size), new Factory<List<T>>() {
+      @NonNull
       @Override
       public List<T> create() {
         return new ArrayList<>();
       }
     }, new Resetter<List<T>>() {
       @Override
-      public void reset(List<T> object) {
+      public void reset(@NonNull List<T> object) {
         object.clear();
       }
     });
   }
 
-  private static <T extends Poolable> Pool<T> build(Pool<T> pool, Factory<T> factory) {
+  @NonNull
+  private static <T extends Poolable> Pool<T> build(@NonNull Pool<T> pool,
+      @NonNull Factory<T> factory) {
     return build(pool, factory, FactoryPools.<T>emptyResetter());
   }
 
-  private static <T> Pool<T> build(Pool<T> pool, Factory<T> factory,
-      Resetter<T> resetter) {
+  @NonNull
+  private static <T> Pool<T> build(@NonNull Pool<T> pool, @NonNull Factory<T> factory,
+      @NonNull Resetter<T> resetter) {
     return new FactoryPool<>(pool, factory, resetter);
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
   private static <T> Resetter<T> emptyResetter() {
     return (Resetter<T>) EMPTY_RESETTER;
@@ -117,7 +129,7 @@ public void reset(List<T> object) {
    * @param <T> The type of Object that will be reset.
    */
   public interface Resetter<T> {
-    void reset(T object);
+    void reset(@NonNull T object);
   }
 
   /**
@@ -125,6 +137,7 @@ public void reset(List<T> object) {
    * an object pool.
    */
   public interface Poolable {
+    @NonNull
     StateVerifier getVerifier();
   }
 
@@ -133,7 +146,7 @@ public void reset(List<T> object) {
     private final Resetter<T> resetter;
     private final Pool<T> pool;
 
-    FactoryPool(Pool<T> pool, Factory<T> factory, Resetter<T> resetter) {
+    FactoryPool(@NonNull Pool<T> pool, @NonNull Factory<T> factory, @NonNull Resetter<T> resetter) {
       this.pool = pool;
       this.factory = factory;
       this.resetter = resetter;
@@ -155,7 +168,7 @@ public T acquire() {
     }
 
     @Override
-    public boolean release(T instance) {
+    public boolean release(@NonNull T instance) {
       if (instance instanceof Poolable) {
         ((Poolable) instance).getVerifier().setRecycled(true /*isRecycled*/);
       }
diff --git a/library/src/main/java/com/bumptech/glide/util/pool/StateVerifier.java b/library/src/main/java/com/bumptech/glide/util/pool/StateVerifier.java
index 7e6577dd3..79e0b40aa 100644
--- a/library/src/main/java/com/bumptech/glide/util/pool/StateVerifier.java
+++ b/library/src/main/java/com/bumptech/glide/util/pool/StateVerifier.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.util.pool;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.util.Synthetic;
 
 /**
@@ -11,6 +12,7 @@
   /**
    * Creates a new {@link StateVerifier} instance.
    */
+  @NonNull
   public static StateVerifier newInstance() {
     if (DEBUG) {
       return new DebugStateVerifier();
@@ -68,9 +70,9 @@ public void throwIfRecycled() {
     @Override
     void setRecycled(boolean isRecycled) {
       if (isRecycled) {
-        this.recycledAtStackTraceException = new RuntimeException("Released");
+        recycledAtStackTraceException = new RuntimeException("Released");
       } else {
-        this.recycledAtStackTraceException = null;
+        recycledAtStackTraceException = null;
       }
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/OptionsTest.java b/library/src/test/java/com/bumptech/glide/load/OptionsTest.java
deleted file mode 100644
index bac793e3b..000000000
--- a/library/src/test/java/com/bumptech/glide/load/OptionsTest.java
+++ /dev/null
@@ -1,35 +0,0 @@
-package com.bumptech.glide.load;
-
-import com.google.common.testing.EqualsTester;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
-public class OptionsTest {
-
-  @Test
-  public void testEquals() {
-    Option<Object> firstOption = Option.memory("firstKey");
-    Object firstValue = new Object();
-    Option<Object> secondOption = Option.memory("secondKey");
-    Object secondValue = new Object();
-    new EqualsTester()
-        .addEqualityGroup(new Options(), new Options())
-        .addEqualityGroup(
-            new Options().set(firstOption, firstValue),
-            new Options().set(firstOption, firstValue)
-        )
-        .addEqualityGroup(
-            new Options().set(secondOption, secondValue),
-            new Options().set(secondOption, secondValue)
-        )
-        .addEqualityGroup(
-            new Options().set(firstOption, firstValue).set(secondOption, secondValue),
-            new Options().set(firstOption, firstValue).set(secondOption, secondValue)
-        ).testEquals();
-  }
-
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java b/library/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java
deleted file mode 100644
index 0e691225f..000000000
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java
+++ /dev/null
@@ -1,153 +0,0 @@
-package com.bumptech.glide.load.engine;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.Option;
-import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.tests.KeyAssertions;
-import com.bumptech.glide.tests.Util;
-import java.io.UnsupportedEncodingException;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-import java.util.Collections;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-/**
- * Tests if {@link EngineKey} {@link Object#hashCode() hashCode} and {@link Object#equals(Object)
- * equals} and SHA-1 disk cache key are different on any difference in ID or existence of a certain
- * workflow part. Also checking whether the equals method is symmetric.
- */
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
-public class EngineKeyTest {
-  private Harness harness;
-
-  @Before
-  public void setUp() {
-    harness = new Harness();
-  }
-
-  private static class Harness {
-    String id = "testId";
-    int width = 1;
-    int height = 2;
-    Class<?> resourceClass = Object.class;
-    Class<?> transcodeClass = Integer.class;
-    Key signature = mock(Key.class);
-    @SuppressWarnings("unchecked")
-    Transformation<Object> transformation = mock(Transformation.class);
-    Options options = new Options();
-
-    public Harness() {
-      doAnswer(new Util.WriteDigest("transformation")).when(transformation)
-          .updateDiskCacheKey(any(MessageDigest.class));
-    }
-
-    public EngineKey build() {
-      return new EngineKey(id, signature, width, height,
-          Collections.<Class<?>, Transformation<?>>singletonMap(Object.class, transformation),
-          resourceClass, transcodeClass, options);
-    }
-  }
-
-  @Test
-  public void testIsIdenticalWithSameArguments() {
-    assertEquals(harness.build(), harness.build());
-  }
-
-  @Test
-  public void testDiffersIfIdDiffers() throws Exception {
-    EngineKey first = harness.build();
-    harness.id = harness.id + "2";
-    EngineKey second = harness.build();
-
-    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
-  }
-
-  @Test
-  public void testDiffersIfHeightDiffers() throws Exception {
-    EngineKey first = harness.build();
-    harness.height += 1;
-    EngineKey second = harness.build();
-
-    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
-  }
-
-  @Test
-  public void testDiffersIfWidthDiffers() throws Exception {
-    EngineKey first = harness.build();
-    harness.width += 1;
-    EngineKey second = harness.build();
-
-    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
-  }
-
-  @Test
-  public void testDiffersIfSignatureDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    EngineKey first = harness.build();
-    Key signature = mock(Key.class);
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        MessageDigest digest = (MessageDigest) invocationOnMock.getArguments()[0];
-        digest.update("signature".getBytes("UTF-8"));
-        return null;
-      }
-    }).when(signature).updateDiskCacheKey(any(MessageDigest.class));
-    harness.signature = signature;
-    EngineKey second = harness.build();
-
-    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
-  }
-
-  @Test
-  public void testDiffersIfResourceClassDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    EngineKey first = harness.build();
-    harness.resourceClass = Long.class;
-    EngineKey second = harness.build();
-    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
-  }
-
-  @Test
-  public void testDiffersIfTranscodeClassDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    EngineKey first = harness.build();
-    harness.transcodeClass = Long.class;
-    EngineKey second = harness.build();
-    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
-  }
-
-  @Test
-  public void testDiffersIfTransformationsDiffer() throws NoSuchAlgorithmException {
-    EngineKey first = harness.build();
-
-    @SuppressWarnings("unchecked") Transformation<Object> other = mock(Transformation.class);
-    doAnswer(new Util.WriteDigest("other")).when(other)
-        .updateDiskCacheKey(any(MessageDigest.class));
-    harness.transformation = other;
-    EngineKey second = harness.build();
-    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
-  }
-
-  @Test
-  public void testDiffersIfOptionsDiffer() throws NoSuchAlgorithmException {
-    EngineKey first = harness.build();
-    harness.options = new Options();
-    harness.options.set(Option.memory("fakeKey"), "someValue");
-    EngineKey second = harness.build();
-    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java b/library/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java
deleted file mode 100644
index b2d467fac..000000000
--- a/library/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java
+++ /dev/null
@@ -1,135 +0,0 @@
-package com.bumptech.glide.load.engine;
-
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.signature.ObjectKey;
-import com.bumptech.glide.tests.KeyAssertions;
-import com.bumptech.glide.tests.Util;
-import java.io.UnsupportedEncodingException;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class ResourceCacheKeyTest {
-
-  private Factory factory;
-
-  @Before
-  public void setUp() {
-    factory = new Factory();
-  }
-
-  @Test
-  public void testIdenticalWithSameArguments()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    KeyAssertions.assertSame(factory.build(), factory.build());
-  }
-
-  @Test
-  public void testDifferIfSourceKeyDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    mutateAndAssertDifferent(new FactoryMutation() {
-      @Override
-      public void mutate(Factory factory) {
-        factory.sourceKey = new ObjectKey("secondKey");
-      }
-    });
-  }
-
-  @Test
-  public void testDiffersIfSignatureDiffers() {
-    mutateAndAssertDifferent(new FactoryMutation() {
-      @Override
-      public void mutate(Factory factory) {
-        factory.signature = new ObjectKey("secondSignature");
-      }
-    });
-  }
-
-  @Test
-  public void testDiffersIfWidthDiffers() {
-    mutateAndAssertDifferent(new FactoryMutation() {
-      @Override
-      public void mutate(Factory factory) {
-        factory.width = factory.width * 2;
-      }
-    });
-  }
-
-  @Test
-  public void testDiffersIfHeightDiffers() {
-    mutateAndAssertDifferent(new FactoryMutation() {
-      @Override
-      public void mutate(Factory factory) {
-        factory.height = factory.height * 2;
-      }
-    });
-  }
-
-  @Test
-  public void tesDiffersIfTransformationDiffers() {
-    mutateAndAssertDifferent(new FactoryMutation() {
-      @Override
-      public void mutate(Factory factory) {
-        factory.transformation = mock(Transformation.class);
-        doAnswer(new Util.WriteDigest("otherTransformation")).when(factory.transformation)
-            .updateDiskCacheKey(any(MessageDigest.class));
-      }
-    });
-  }
-
-  @Test
-  public void testDiffersIfResourceDiffers() {
-    mutateAndAssertDifferent(new FactoryMutation() {
-      @Override
-      public void mutate(Factory factory) {
-        factory.resourceClass = Integer.class;
-      }
-    });
-  }
-
-  interface FactoryMutation {
-    void mutate(Factory factory);
-  }
-
-  private void mutateAndAssertDifferent(FactoryMutation mutation) {
-    ResourceCacheKey original = factory.build();
-    mutation.mutate(factory);
-    ResourceCacheKey mutated = factory.build();
-
-    try {
-      KeyAssertions.assertDifferent(original, mutated);
-    } catch (NoSuchAlgorithmException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  static class Factory {
-    Key sourceKey = new ObjectKey("sourceKey");
-    Key signature = new ObjectKey("signature");
-    int width = 100;
-    int height = 100;
-    Transformation<?> transformation = mock(Transformation.class);
-    Class<?> resourceClass = Object.class;
-    Options options = new Options();
-
-    Factory() {
-      doAnswer(new Util.WriteDigest("transformation")).when(transformation)
-          .updateDiskCacheKey(any(MessageDigest.class));
-    }
-
-    ResourceCacheKey build() {
-      return new ResourceCacheKey(sourceKey, signature, width, height, transformation,
-          resourceClass, options);
-    }
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMapTest.java b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMapTest.java
deleted file mode 100644
index ab9604ddc..000000000
--- a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMapTest.java
+++ /dev/null
@@ -1,121 +0,0 @@
-package com.bumptech.glide.load.engine.bitmap_recycle;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertNull;
-import static org.mockito.Mockito.mock;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
-public class GroupedLinkedMapTest {
-
-    private GroupedLinkedMap<Key, Object> map;
-
-    @Before
-    public void setUp() {
-        map = new GroupedLinkedMap<Key, Object>();
-    }
-
-    @Test
-    public void testReturnsNullForGetWithNoBitmap() {
-        assertNull(map.get(mock(Key.class)));
-    }
-
-    @Test
-    public void testCanAddAndRemoveABitmap() {
-        Key key = new Key("key", 1, 1);
-        Object expected = new Object();
-
-        map.put(key, expected);
-
-        assertThat(map.get(key)).isEqualTo(expected);
-    }
-
-    @Test
-    public void testCanAddAndRemoveMoreThanOneBitmapForAGivenKey() {
-        Key key = new Key("key", 1, 1);
-        Integer value = 20;
-
-        int numToAdd = 10;
-
-        for (int i = 0; i < numToAdd; i++) {
-            map.put(key, new Integer(value));
-        }
-
-        for (int i = 0; i < numToAdd; i++) {
-            assertThat(map.get(key)).isEqualTo(value);
-        }
-    }
-
-    @Test
-    public void testLeastRecentlyRetrievedKeyIsLeastRecentlyUsed() {
-        Key firstKey = new Key("key", 1, 1);
-        Integer firstValue = 10;
-        map.put(firstKey, firstValue);
-        map.put(firstKey, new Integer(firstValue));
-
-        Key secondKey = new Key("key", 2, 2);
-        Integer secondValue = 20;
-        map.put(secondKey, secondValue);
-
-        map.get(firstKey);
-
-        assertThat(map.removeLast()).isEqualTo(secondValue);
-    }
-
-    @Test
-    public void testAddingAnEntryDoesNotMakeItMostRecentlyUsed() {
-        Key firstKey = new Key("key", 1, 1);
-        Integer firstValue = 10;
-
-        map.put(firstKey, firstValue);
-        map.put(firstKey, new Integer(firstValue));
-
-        map.get(firstKey);
-
-        Integer secondValue = 20;
-        map.put(new Key("key", 2, 2), secondValue);
-
-        assertThat(map.removeLast()).isEqualTo(secondValue);
-    }
-
-    private static class Key implements Poolable {
-
-        private final String key;
-        private final int width;
-        private final int height;
-
-        public Key(String key, int width, int height) {
-            this.key = key;
-            this.width = width;
-            this.height = height;
-        }
-
-        @Override
-        public boolean equals(Object o) {
-            if (o instanceof Key) {
-                Key other = (Key) o;
-                return key.equals(other.key) && width == other.width && height == other.height;
-            }
-            return false;
-        }
-
-        @Override
-        public int hashCode() {
-            int result = key != null ? key.hashCode() : 0;
-            result = 31 * result + width;
-            result = 31 * result + height;
-            return result;
-        }
-
-        @Override
-        public void offer() {
-            // Do nothing.
-        }
-    }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java
deleted file mode 100644
index 2242dcf03..000000000
--- a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java
+++ /dev/null
@@ -1,41 +0,0 @@
-package com.bumptech.glide.load.engine.bitmap_recycle;
-
-import android.graphics.Bitmap;
-import com.google.common.testing.EqualsTester;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-
-@RunWith(JUnit4.class)
-public class SizeConfigStrategyTest {
-
-    @Mock SizeConfigStrategy.KeyPool pool;
-
-    @Before
-    public void setUp() {
-        MockitoAnnotations.initMocks(this);
-    }
-
-    @Test
-    public void testKeyEquals() {
-        new EqualsTester()
-                .addEqualityGroup(
-                        new SizeConfigStrategy.Key(pool, 100, Bitmap.Config.ARGB_8888),
-                        new SizeConfigStrategy.Key(pool, 100, Bitmap.Config.ARGB_8888)
-                )
-                .addEqualityGroup(
-                        new SizeConfigStrategy.Key(pool, 101, Bitmap.Config.ARGB_8888)
-                )
-                .addEqualityGroup(
-                        new SizeConfigStrategy.Key(pool, 100, Bitmap.Config.RGB_565)
-                )
-                .addEqualityGroup(
-                        new SizeConfigStrategy.Key(pool, 100, null /*config*/)
-                )
-                .testEquals();
-
-    }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java b/library/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
deleted file mode 100644
index 00ffc8295..000000000
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
+++ /dev/null
@@ -1,120 +0,0 @@
-package com.bumptech.glide.load.engine.cache;
-
-import static com.bumptech.glide.load.engine.cache.MemoryCache.ResourceRemovedListener;
-import static com.bumptech.glide.tests.Util.mockResource;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.annotation.TargetApi;
-import android.content.ComponentCallbacks2;
-import android.os.Build;
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.engine.Resource;
-import java.security.MessageDigest;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-public class LruResourceCacheTest {
-  private static class TrimClearMemoryCacheHarness {
-    LruResourceCache resourceCache = new LruResourceCache(100);
-    Resource<?> first = mockResource();
-    Resource<?> second = mockResource();
-
-    ResourceRemovedListener listener = mock(ResourceRemovedListener.class);
-
-    public TrimClearMemoryCacheHarness() {
-      when(first.getSize()).thenReturn(50);
-      when(second.getSize()).thenReturn(50);
-      resourceCache.put(new MockKey(), first);
-      resourceCache.put(new MockKey(), second);
-      resourceCache.setResourceRemovedListener(listener);
-    }
-  }
-
-  @Test
-  public void testTrimMemoryBackground() {
-    TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
-
-    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
-
-    verify(harness.listener).onResourceRemoved(eq(harness.first));
-    verify(harness.listener).onResourceRemoved(eq(harness.second));
-  }
-
-  @Test
-  public void testTrimMemoryModerate() {
-    TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
-
-    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_MODERATE);
-
-    verify(harness.listener).onResourceRemoved(harness.first);
-    verify(harness.listener).onResourceRemoved(harness.second);
-  }
-
-  @Test
-  public void testTrimMemoryUiHidden() {
-    TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
-
-    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
-
-    verify(harness.listener).onResourceRemoved(harness.first);
-    verify(harness.listener, never()).onResourceRemoved(harness.second);
-  }
-
-  @Test
-  public void testResourceRemovedListenerIsNotifiedWhenResourceIsRemoved() {
-    LruResourceCache resourceCache = new LruResourceCache(100);
-    Resource<?> resource = mockResource();
-    when(resource.getSize()).thenReturn(200);
-
-    ResourceRemovedListener listener = mock(ResourceRemovedListener.class);
-
-    resourceCache.setResourceRemovedListener(listener);
-    resourceCache.put(new MockKey(), resource);
-
-    verify(listener).onResourceRemoved(eq(resource));
-  }
-
-  @Test
-  public void testSizeIsBasedOnResource() {
-    LruResourceCache resourceCache = new LruResourceCache(100);
-    Resource<?> first = getResource(50);
-    MockKey firstKey = new MockKey();
-    resourceCache.put(firstKey, first);
-    Resource<?> second = getResource(50);
-    MockKey secondKey = new MockKey();
-    resourceCache.put(secondKey, second);
-
-    assertTrue(resourceCache.contains(firstKey));
-    assertTrue(resourceCache.contains(secondKey));
-
-    Resource<?> third = getResource(50);
-    MockKey thirdKey = new MockKey();
-    resourceCache.put(thirdKey, third);
-
-    assertFalse(resourceCache.contains(firstKey));
-    assertTrue(resourceCache.contains(secondKey));
-    assertTrue(resourceCache.contains(thirdKey));
-  }
-
-  private Resource<?> getResource(int size) {
-    Resource<?> resource = mockResource();
-    when(resource.getSize()).thenReturn(size);
-    return resource;
-  }
-
-  private static class MockKey implements Key {
-    @Override
-    public void updateDiskCacheKey(MessageDigest messageDigest) {
-      messageDigest.update(toString().getBytes(CHARSET));
-    }
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java b/library/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
deleted file mode 100644
index af0dce220..000000000
--- a/library/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package com.bumptech.glide.load.engine.executor;
-
-/**
- * Creates mock {@link GlideExecutor}s.
- */
-public final class MockGlideExecutor {
-
-  private MockGlideExecutor() { }
-
-  public static GlideExecutor newMainThreadExecutor() {
-    return new GlideExecutor(1 /*poolSize*/, "mock-glide-executor",
-        GlideExecutor.UncaughtThrowableStrategy.THROW, false /*preventNetworkOperations*/,
-        true /*runAllOnMainThread*/);
-  }
-
-  public static GlideExecutor newMainThreadUnlimitedExecutor() {
-    return new GlideExecutor(0 /* corePoolSize */,
-        Integer.MAX_VALUE /* maximumPoolSize */,
-        java.util.concurrent.TimeUnit.SECONDS.toMillis(10) /* keepAliveTimeInMs */,
-        "mock-unlimited-glide-executor",
-        GlideExecutor.UncaughtThrowableStrategy.THROW, false /*preventNetworkOperations*/,
-        true /*runAllOnMainThread*/);
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoderTest.java
deleted file mode 100644
index 4b034d2fc..000000000
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoderTest.java
+++ /dev/null
@@ -1,97 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.anyLong;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Bitmap;
-import android.media.MediaMetadataRetriever;
-import android.os.ParcelFileDescriptor;
-import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import java.io.FileDescriptor;
-import java.io.IOException;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
-public class VideoBitmapDecoderTest {
-  @Mock private ParcelFileDescriptor resource;
-  @Mock private VideoBitmapDecoder.MediaMetadataRetrieverFactory factory;
-  @Mock private MediaMetadataRetriever retriever;
-  @Mock private BitmapPool bitmapPool;
-  private VideoBitmapDecoder decoder;
-  private Options options;
-
-  @Before
-  public void setup() {
-    MockitoAnnotations.initMocks(this);
-    when(factory.build()).thenReturn(retriever);
-    decoder = new VideoBitmapDecoder(bitmapPool, factory);
-    options = new Options();
-  }
-
-  @Test
-  public void testReturnsRetrievedFrameForResource() throws IOException {
-    Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    when(retriever.getFrameAtTime()).thenReturn(expected);
-
-    FileDescriptor toSet = FileDescriptor.in;
-    when(resource.getFileDescriptor()).thenReturn(toSet);
-    Resource<Bitmap> result = decoder.decode(resource, 100, 100, options);
-
-    verify(retriever).setDataSource(eq(toSet));
-    assertEquals(expected, result.get());
-  }
-
-  @Test
-  public void testReleasesMediaMetadataRetriever() throws IOException {
-    decoder.decode(resource, 1, 2, options);
-
-    verify(retriever).release();
-  }
-
-  @Test
-  public void testClosesResource() throws IOException {
-    decoder.decode(resource, 1, 2, options);
-
-    verify(resource).close();
-  }
-
-  @Test(expected = IllegalArgumentException.class)
-  public void testThrowsExceptionIfCalledWithInvalidFrame() throws IOException {
-    options.set(VideoBitmapDecoder.TARGET_FRAME, -5L);
-    new VideoBitmapDecoder(bitmapPool, factory).decode(resource, 100, 100, options);
-  }
-
-  @Test
-  public void testSpecifiesThumbnailFrameIfICalledWithFrameNumber() throws IOException {
-    long frame = 5;
-    options.set(VideoBitmapDecoder.TARGET_FRAME, frame);
-    decoder = new VideoBitmapDecoder(bitmapPool, factory);
-
-    decoder.decode(resource, 100, 100, options);
-
-    verify(retriever).getFrameAtTime(frame);
-    verify(retriever, never()).getFrameAtTime();
-  }
-
-  @Test
-  public void testDoesNotSpecifyThumbnailFrameIfCalledWithoutFrameNumber() throws IOException {
-    decoder = new VideoBitmapDecoder(bitmapPool, factory);
-    decoder.decode(resource, 100, 100, options);
-
-    verify(retriever).getFrameAtTime();
-    verify(retriever, never()).getFrameAtTime(anyLong());
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java b/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
deleted file mode 100644
index fc06b4087..000000000
--- a/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
+++ /dev/null
@@ -1,917 +0,0 @@
-package com.bumptech.glide.request;
-
-import static com.bumptech.glide.tests.Util.isADataSource;
-import static com.bumptech.glide.tests.Util.mockResource;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyBoolean;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Matchers.isA;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Color;
-import android.graphics.drawable.ColorDrawable;
-import android.graphics.drawable.Drawable;
-import com.bumptech.glide.GlideContext;
-import com.bumptech.glide.Priority;
-import com.bumptech.glide.load.DataSource;
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.engine.DiskCacheStrategy;
-import com.bumptech.glide.load.engine.Engine;
-import com.bumptech.glide.load.engine.GlideException;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.request.target.SizeReadyCallback;
-import com.bumptech.glide.request.target.Target;
-import com.bumptech.glide.request.transition.Transition;
-import com.bumptech.glide.request.transition.TransitionFactory;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
-@SuppressWarnings("rawtypes")
-public class SingleRequestTest {
-  private RequestHarness harness = new RequestHarness();
-
-  /**
-   * {@link Number} and {@link List} are arbitrarily chosen types to test some type safety as well.
-   * Both are in the middle of the hierarchy having multiple descendants and ancestors.
-   */
-  private static class RequestHarness {
-    Engine engine = mock(Engine.class);
-    Number model = 123456;
-    @SuppressWarnings("unchecked")
-    Target<List> target = mock(Target.class);
-    Resource<List> resource = mockResource();
-    RequestCoordinator requestCoordinator = mock(RequestCoordinator.class);
-    Drawable placeholderDrawable = null;
-    Drawable errorDrawable = null;
-    Drawable fallbackDrawable = null;
-    @SuppressWarnings("unchecked")
-    RequestListener<List> requestListener = mock(RequestListener.class);
-    @SuppressWarnings("unchecked")
-    TransitionFactory<List> factory = mock(TransitionFactory.class);
-    int overrideWidth = -1;
-    int overrideHeight = -1;
-    List<?> result = new ArrayList<>();
-    GlideContext glideContext = mock(GlideContext.class);
-    Key signature = mock(Key.class);
-    Priority priority = Priority.HIGH;
-    boolean useUnlimitedSourceGeneratorsPool = false;
-    Class<List> transcodeClass = List.class;
-
-    Map<Class<?>, Transformation<?>>  transformations = new HashMap<>();
-
-    public RequestHarness() {
-      when(requestCoordinator.canSetImage(any(Request.class))).thenReturn(true);
-      when(requestCoordinator.canNotifyStatusChanged(any(Request.class))).thenReturn(true);
-      when(resource.get()).thenReturn(result);
-    }
-
-    public SingleRequest<List> getRequest() {
-       RequestOptions requestOptions = new RequestOptions()
-        .error(errorDrawable)
-        .placeholder(placeholderDrawable)
-        .fallback(fallbackDrawable)
-        .override(overrideWidth, overrideHeight)
-        .priority(priority)
-        .signature(signature)
-        .useUnlimitedSourceGeneratorsPool(useUnlimitedSourceGeneratorsPool);
-      return SingleRequest
-          .obtain(glideContext, model, transcodeClass, requestOptions, overrideWidth,
-              overrideHeight, priority, target, requestListener, requestCoordinator, engine,
-              factory);
-    }
-  }
-
-  @Before
-  public void setUp() {
-    harness = new RequestHarness();
-  }
-
-  @Test
-  public void testIsNotCompleteBeforeReceivingResource() {
-    SingleRequest<List> request = harness.getRequest();
-
-    assertFalse(request.isComplete());
-  }
-
-  @Test
-  public void testCanHandleNullResources() {
-    SingleRequest<List> request = harness.getRequest();
-
-    request.onResourceReady(null, DataSource.LOCAL);
-
-    assertTrue(request.isFailed());
-    verify(harness.requestListener).onLoadFailed(isAGlideException(), isA(Number.class),
-        eq(harness.target), anyBoolean());
-  }
-
-  @Test
-  public void testCanHandleEmptyResources() {
-    SingleRequest<List> request = harness.getRequest();
-    when(harness.resource.get()).thenReturn(null);
-
-    request.onResourceReady(harness.resource, DataSource.REMOTE);
-
-    assertTrue(request.isFailed());
-    verify(harness.engine).release(eq(harness.resource));
-    verify(harness.requestListener).onLoadFailed(isAGlideException(), any(Number.class),
-        eq(harness.target), anyBoolean());
-  }
-
-  @Test
-  public void testCanHandleNonConformingResources() {
-    SingleRequest<List> request = harness.getRequest();
-    when(((Resource) (harness.resource)).get())
-        .thenReturn("Invalid mocked String, this should be a List");
-
-    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
-
-    assertTrue(request.isFailed());
-    verify(harness.engine).release(eq(harness.resource));
-    verify(harness.requestListener).onLoadFailed(isAGlideException(), any(Number.class),
-        eq(harness.target), anyBoolean());
-  }
-
-  @Test
-  public void testIsNotFailedAfterClear() {
-    SingleRequest<List> request = harness.getRequest();
-
-    request.onResourceReady(null, DataSource.DATA_DISK_CACHE);
-    request.clear();
-
-    assertFalse(request.isFailed());
-  }
-
-  @Test
-  public void testIsPausedAfterPause() {
-    SingleRequest<List> request = harness.getRequest();
-    request.pause();
-
-    assertTrue(request.isPaused());
-  }
-
-  @Test
-  public void testIsNotCancelledAfterPause() {
-    SingleRequest<List> request = harness.getRequest();
-    request.pause();
-
-    assertFalse(request.isCancelled());
-  }
-
-  @Test
-  public void testIsNotPausedAfterBeginningWhilePaused() {
-    SingleRequest<List> request = harness.getRequest();
-    request.pause();
-    request.begin();
-
-    assertFalse(request.isPaused());
-    assertTrue(request.isRunning());
-  }
-
-  @Test
-  public void testIsNotFailedAfterBegin() {
-    SingleRequest<List> request = harness.getRequest();
-
-    request.onResourceReady(null, DataSource.DATA_DISK_CACHE);
-    request.begin();
-
-    assertFalse(request.isFailed());
-  }
-
-  @Test
-  public void testIsCompleteAfterReceivingResource() {
-    SingleRequest<List> request = harness.getRequest();
-
-    request.onResourceReady(harness.resource, DataSource.LOCAL);
-
-    assertTrue(request.isComplete());
-  }
-
-  @Test
-  public void testIsNotCompleteAfterClear() {
-    SingleRequest<List> request = harness.getRequest();
-    request.onResourceReady(harness.resource, DataSource.REMOTE);
-    request.clear();
-
-    assertFalse(request.isComplete());
-  }
-
-  @Test
-  public void testIsCancelledAfterClear() {
-    SingleRequest<List> request = harness.getRequest();
-    request.clear();
-
-    assertTrue(request.isCancelled());
-  }
-
-  @Test
-  public void testDoesNotNotifyTargetTwiceIfClearedTwiceInARow() {
-    SingleRequest<List> request = harness.getRequest();
-    request.clear();
-    request.clear();
-
-    verify(harness.target, times(1)).onLoadCleared(any(Drawable.class));
-  }
-
-  @Test
-  public void testResourceIsNotCompleteWhenAskingCoordinatorIfCanSetImage() {
-    RequestCoordinator requestCoordinator = mock(RequestCoordinator.class);
-    doAnswer(new Answer() {
-      @Override
-      public Object answer(InvocationOnMock invocation) throws Throwable {
-        Request request = (Request) invocation.getArguments()[0];
-        assertFalse(request.isComplete());
-        return true;
-      }
-    }).when(requestCoordinator).canSetImage(any(Request.class));
-
-    harness.requestCoordinator = requestCoordinator;
-    SingleRequest<List> request = harness.getRequest();
-
-    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
-
-    verify(requestCoordinator).canSetImage(eq(request));
-  }
-
-  @Test
-  public void testIsNotFailedWithoutException() {
-    SingleRequest<List> request = harness.getRequest();
-
-    assertFalse(request.isFailed());
-  }
-
-  @Test
-  public void testIsFailedAfterException() {
-    SingleRequest<List> request = harness.getRequest();
-
-    request.onLoadFailed(new GlideException("test"));
-    assertTrue(request.isFailed());
-  }
-
-  @Test
-  public void testIgnoresOnSizeReadyIfNotWaitingForSize() {
-    SingleRequest<List> request = harness.getRequest();
-    request.begin();
-    request.onSizeReady(100, 100);
-    request.onSizeReady(100, 100);
-
-    verify(harness.engine, times(1))
-        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), eq(100), eq(100),
-            eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),
-            eq(harness.transformations), anyBoolean(), anyBoolean(), any(Options.class),
-            anyBoolean(), anyBoolean(), anyBoolean(), any(ResourceCallback.class));
-  }
-
-  @Test
-  public void testIsFailedAfterNoResultAndNullException() {
-    SingleRequest<List> request = harness.getRequest();
-
-    request.onLoadFailed(new GlideException("test"));
-    assertTrue(request.isFailed());
-  }
-
-  @Test
-  public void testEngineLoadCancelledOnCancel() {
-    Engine.LoadStatus loadStatus = mock(Engine.LoadStatus.class);
-
-    when(harness.engine
-       .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(), anyInt(),
-          eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),
-          eq(harness.transformations), anyBoolean(), anyBoolean(), any(Options.class),
-          anyBoolean(), anyBoolean(), anyBoolean(), any(ResourceCallback.class)))
-        .thenReturn(loadStatus);
-
-    SingleRequest<List> request = harness.getRequest();
-    request.begin();
-
-    request.onSizeReady(100, 100);
-    request.cancel();
-
-    verify(loadStatus).cancel();
-  }
-
-  @Test
-  public void testResourceIsRecycledOnClear() {
-    SingleRequest<List> request = harness.getRequest();
-
-    request.onResourceReady(harness.resource, DataSource.REMOTE);
-    request.clear();
-
-    verify(harness.engine).release(eq(harness.resource));
-  }
-
-  @Test
-  public void testPlaceholderDrawableIsSet() {
-    Drawable expected = new ColorDrawable(Color.RED);
-
-    MockTarget target = new MockTarget();
-
-    harness.placeholderDrawable = expected;
-    harness.target = target;
-    SingleRequest<List> request = harness.getRequest();
-    request.begin();
-
-    assertEquals(expected, target.currentPlaceholder);
-  }
-
-  @Test
-  public void testErrorDrawableIsSetOnLoadFailed() {
-    Drawable expected = new ColorDrawable(Color.RED);
-
-    MockTarget target = new MockTarget();
-
-    harness.errorDrawable = expected;
-    harness.target = target;
-    SingleRequest<List> request = harness.getRequest();
-
-    request.onLoadFailed(new GlideException("test"));
-
-    assertEquals(expected, target.currentPlaceholder);
-  }
-
-  @Test
-  public void testPlaceholderDrawableSetOnNullModelWithNoErrorDrawable() {
-    Drawable placeholder = new ColorDrawable(Color.RED);
-
-    MockTarget target = new MockTarget();
-
-    harness.errorDrawable = placeholder;
-    harness.target = target;
-    harness.model = null;
-    SingleRequest<List> request = harness.getRequest();
-
-    request.begin();
-
-    assertEquals(placeholder, target.currentPlaceholder);
-  }
-
-  @Test
-  public void testErrorDrawableSetOnNullModelWithErrorDrawable() {
-    Drawable placeholder = new ColorDrawable(Color.RED);
-    Drawable errorPlaceholder = new ColorDrawable(Color.GREEN);
-
-    MockTarget target = new MockTarget();
-
-    harness.placeholderDrawable = placeholder;
-    harness.errorDrawable = errorPlaceholder;
-    harness.target = target;
-    harness.model = null;
-    SingleRequest<List> request = harness.getRequest();
-
-    request.begin();
-
-    assertEquals(errorPlaceholder, target.currentPlaceholder);
-  }
-
-
-  @Test
-  public void testFallbackDrawableSetOnNullModelWithErrorAndFallbackDrawables() {
-    Drawable placeholder = new ColorDrawable(Color.RED);
-    Drawable errorPlaceholder = new ColorDrawable(Color.GREEN);
-    Drawable fallback = new ColorDrawable(Color.BLUE);
-
-    MockTarget target = new MockTarget();
-    harness.placeholderDrawable = placeholder;
-    harness.errorDrawable = errorPlaceholder;
-    harness.fallbackDrawable = fallback;
-    harness.target = target;
-    harness.model = null;
-    SingleRequest<List> request = harness.getRequest();
-    request.begin();
-    assertEquals(fallback, target.currentPlaceholder);
-  }
-
-
-  @Test
-  public void testIsNotRunningBeforeRunCalled() {
-    assertFalse(harness.getRequest().isRunning());
-  }
-
-  @Test
-  public void testIsRunningAfterRunCalled() {
-    Request request = harness.getRequest();
-    request.begin();
-    assertTrue(request.isRunning());
-  }
-
-  @Test
-  public void testIsNotRunningAfterComplete() {
-    SingleRequest<List> request = harness.getRequest();
-    request.begin();
-    request.onResourceReady(harness.resource, DataSource.REMOTE);
-
-    assertFalse(request.isRunning());
-  }
-
-  @Test
-  public void testIsNotRunningAfterFailing() {
-    SingleRequest<List> request = harness.getRequest();
-    request.begin();
-    request.onLoadFailed(new GlideException("test"));
-
-    assertFalse(request.isRunning());
-  }
-
-  @Test
-  public void testIsNotRunningAfterClear() {
-    SingleRequest<List> request = harness.getRequest();
-    request.begin();
-    request.clear();
-
-    assertFalse(request.isRunning());
-  }
-
-  @Test
-  public void testCallsTargetOnResourceReadyIfNoRequestListener() {
-    harness.requestListener = null;
-    SingleRequest<List> request = harness.getRequest();
-    request.onResourceReady(harness.resource, DataSource.LOCAL);
-
-    verify(harness.target).onResourceReady(eq(harness.result), anyTransition());
-  }
-
-  @Test
-  public void testCallsTargetOnResourceReadyIfRequestListenerReturnsFalse() {
-    SingleRequest<List> request = harness.getRequest();
-    when(harness.requestListener
-        .onResourceReady(any(List.class), any(Number.class), eq(harness.target), isADataSource(),
-            anyBoolean())).thenReturn(false);
-    request.onResourceReady(harness.resource, DataSource.LOCAL);
-
-    verify(harness.target).onResourceReady(eq(harness.result), anyTransition());
-  }
-
-  @Test
-  public void testDoesNotCallTargetOnResourceReadyIfRequestListenerReturnsTrue() {
-    SingleRequest<List> request = harness.getRequest();
-    when(harness.requestListener
-        .onResourceReady(any(List.class), any(Number.class), eq(harness.target), isADataSource(),
-            anyBoolean())).thenReturn(true);
-    request.onResourceReady(harness.resource, DataSource.REMOTE);
-
-    verify(harness.target, never()).onResourceReady(any(List.class), anyTransition());
-  }
-
-  @Test
-  public void testCallsTargetOnExceptionIfNoRequestListener() {
-    harness.requestListener = null;
-    SingleRequest<List> request = harness.getRequest();
-    request.onLoadFailed(new GlideException("test"));
-
-    verify(harness.target).onLoadFailed(eq(harness.errorDrawable));
-  }
-
-  @Test
-  public void testCallsTargetOnExceptionIfRequestListenerReturnsFalse() {
-    SingleRequest<List> request = harness.getRequest();
-    when(harness.requestListener.onLoadFailed(isAGlideException(), any(Number.class),
-        eq(harness.target), anyBoolean()))
-        .thenReturn(false);
-    request.onLoadFailed(new GlideException("test"));
-
-    verify(harness.target).onLoadFailed(eq(harness.errorDrawable));
-  }
-
-  @Test
-  public void testDoesNotCallTargetOnExceptionIfRequestListenerReturnsTrue() {
-    SingleRequest<List> request = harness.getRequest();
-    when(harness.requestListener.onLoadFailed(isAGlideException(), any(Number.class),
-        eq(harness.target), anyBoolean()))
-        .thenReturn(true);
-
-    request.onLoadFailed(new GlideException("test"));
-
-    verify(harness.target, never()).onLoadFailed(any(Drawable.class));
-  }
-
-  @Test
-  public void testRequestListenerIsCalledWithResourceResult() {
-    SingleRequest<List> request = harness.getRequest();
-    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
-
-    verify(harness.requestListener)
-        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(), isADataSource(),
-            anyBoolean());
-  }
-
-  @Test
-  public void testRequestListenerIsCalledWithModel() {
-    SingleRequest<List> request = harness.getRequest();
-    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
-
-    verify(harness.requestListener)
-        .onResourceReady(any(List.class), eq(harness.model), isAListTarget(), isADataSource(),
-            anyBoolean());
-  }
-
-  @Test
-  public void testRequestListenerIsCalledWithTarget() {
-    SingleRequest<List> request = harness.getRequest();
-    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
-
-    verify(harness.requestListener)
-        .onResourceReady(any(List.class), any(Number.class), eq(harness.target), isADataSource(),
-            anyBoolean());
-  }
-
-  @Test
-  public void testRequestListenerIsCalledWithLoadedFromMemoryIfLoadCompletesSynchronously() {
-    final SingleRequest<List> request = harness.getRequest();
-
-    when(harness.engine
-        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
-            anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
-            any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            anyBoolean(), any(Options.class), anyBoolean(), anyBoolean(), anyBoolean(),
-            any(ResourceCallback.class)))
-        .thenAnswer(new Answer<Object>() {
-          @Override
-          public Object answer(InvocationOnMock invocation) throws Throwable {
-            request.onResourceReady(harness.resource, DataSource.MEMORY_CACHE);
-            return null;
-          }
-        });
-
-    request.begin();
-    request.onSizeReady(100, 100);
-    verify(harness.requestListener)
-        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(),
-            eq(DataSource.MEMORY_CACHE), anyBoolean());
-  }
-
-  @Test
-  public void
-  testRequestListenerIsCalledWithNotLoadedFromMemoryCacheIfLoadCompletesAsynchronously() {
-    SingleRequest<List> request = harness.getRequest();
-    request.onSizeReady(100, 100);
-    request.onResourceReady(harness.resource, DataSource.LOCAL);
-
-    verify(harness.requestListener)
-        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(),
-            eq(DataSource.LOCAL), anyBoolean());
-  }
-
-  @Test
-  public void testRequestListenerIsCalledWithIsFirstResourceIfNoRequestCoordinator() {
-    harness.requestCoordinator = null;
-    SingleRequest<List> request = harness.getRequest();
-    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
-
-    verify(harness.requestListener)
-        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(), isADataSource(),
-            eq(true));
-  }
-
-  @Test
-  public void testRequestListenerIsCalledWithFirstImageIfRequestCoordinatorReturnsNoResourceSet() {
-    SingleRequest<List> request = harness.getRequest();
-    when(harness.requestCoordinator.isAnyResourceSet()).thenReturn(false);
-    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
-
-    verify(harness.requestListener)
-        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(), isADataSource(),
-            eq(true));
-  }
-
-  @Test
-  public void
-  testRequestListenerIsCalledWithNotIsFirstRequestIfRequestCoordinatorReturnsResourceSet() {
-    SingleRequest<List> request = harness.getRequest();
-    when(harness.requestCoordinator.isAnyResourceSet()).thenReturn(true);
-    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
-
-    verify(harness.requestListener)
-        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(),
-            isADataSource(), eq(false));
-  }
-
-  @Test
-  public void testTargetIsCalledWithAnimationFromFactory() {
-    SingleRequest<List> request = harness.getRequest();
-    Transition<List> transition = mockTransition();
-    when(harness.factory.build(any(DataSource.class), anyBoolean())).thenReturn(transition);
-    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
-
-    verify(harness.target).onResourceReady(eq(harness.result), eq(transition));
-  }
-
-  @Test
-  public void testCallsGetSizeIfOverrideWidthIsLessThanZero() {
-    harness.overrideWidth = -1;
-    harness.overrideHeight = 100;
-    SingleRequest<List> request = harness.getRequest();
-    request.begin();
-
-    verify(harness.target).getSize(any(SizeReadyCallback.class));
-  }
-
-  @Test
-  public void testCallsGetSizeIfOverrideHeightIsLessThanZero() {
-    harness.overrideHeight = -1;
-    harness.overrideWidth = 100;
-    SingleRequest<List> request = harness.getRequest();
-    request.begin();
-
-    verify(harness.target).getSize(any(SizeReadyCallback.class));
-  }
-
-  @Test
-  public void testDoesNotCallGetSizeIfOverrideWidthAndHeightAreSet() {
-    harness.overrideWidth = 100;
-    harness.overrideHeight = 100;
-    SingleRequest<List> request = harness.getRequest();
-    request.begin();
-
-    verify(harness.target, never()).getSize(any(SizeReadyCallback.class));
-  }
-
-  @Test
-  public void testCallsEngineWithOverrideWidthAndHeightIfSet() {
-    harness.overrideWidth = 1;
-    harness.overrideHeight = 2;
-
-    SingleRequest<List> request = harness.getRequest();
-    request.begin();
-
-    verify(harness.engine)
-        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
-            anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
-            any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            anyBoolean(), any(Options.class), anyBoolean(), anyBoolean(), anyBoolean(),
-            any(ResourceCallback.class));
-  }
-
-  @Test
-  public void testDoesNotSetErrorDrawableIfRequestCoordinatorDoesntAllowIt() {
-    harness.errorDrawable = new ColorDrawable(Color.RED);
-    SingleRequest<List> request = harness.getRequest();
-    when(harness.requestCoordinator.canNotifyStatusChanged(any(Request.class))).thenReturn(false);
-    request.onLoadFailed(new GlideException("test"));
-
-    verify(harness.target, never()).onLoadFailed(any(Drawable.class));
-  }
-
-  @Test
-  public void testCanReRunCancelledRequests() {
-    doAnswer(new CallSizeReady(100, 100)).when(harness.target)
-        .getSize(any(SizeReadyCallback.class));
-
-    when(harness.engine
-        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), eq(100), eq(100),
-            eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),
-            eq(harness.transformations), anyBoolean(), anyBoolean(), any(Options.class),
-            anyBoolean(), anyBoolean(), anyBoolean(), any(ResourceCallback.class)))
-        .thenAnswer(new CallResourceCallback(harness.resource));
-    SingleRequest<List> request = harness.getRequest();
-
-    request.begin();
-    request.cancel();
-    request.begin();
-
-    verify(harness.target, times(2)).onResourceReady(eq(harness.result), anyTransition());
-  }
-
-  @Test
-  public void testResourceOnlyReceivesOneGetOnResourceReady() {
-    SingleRequest<List> request = harness.getRequest();
-    request.onResourceReady(harness.resource, DataSource.LOCAL);
-
-    verify(harness.resource, times(1)).get();
-  }
-
-  @Test
-  public void testDoesNotStartALoadIfOnSizeReadyIsCalledAfterCancel() {
-    SingleRequest<List> request = harness.getRequest();
-    request.cancel();
-    request.onSizeReady(100, 100);
-
-    verify(harness.engine, never())
-        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
-            anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
-            any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            anyBoolean(), any(Options.class), anyBoolean(), anyBoolean(), anyBoolean(),
-            any(ResourceCallback.class));
-  }
-
-
-  @Test
-  public void testCallsSourceUnlimitedExecutorEngineIfOptionsIsSet() {
-    doAnswer(new CallSizeReady(100, 100)).when(harness.target)
-        .getSize(any(SizeReadyCallback.class));
-
-    harness.useUnlimitedSourceGeneratorsPool = true;
-
-    SingleRequest<List> request = harness.getRequest();
-    request.begin();
-
-    verify(harness.engine)
-        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
-            anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
-            any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            anyBoolean(), any(Options.class), anyBoolean(), eq(Boolean.TRUE), anyBoolean(),
-            any(ResourceCallback.class));
-  }
-
-  @Test
-  public void testCallsSourceExecutorEngineIfOptionsIsSet() {
-    doAnswer(new CallSizeReady(100, 100)).when(harness.target)
-        .getSize(any(SizeReadyCallback.class));
-
-    harness.useUnlimitedSourceGeneratorsPool = false;
-
-    SingleRequest<List> request = harness.getRequest();
-    request.begin();
-
-    verify(harness.engine)
-        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
-            anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
-            any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            anyBoolean(), any(Options.class), anyBoolean(), eq(Boolean.FALSE), anyBoolean(),
-            any(ResourceCallback.class));
-  }
-
-  @Test
-  public void testIsEquivalentTo() {
-    SingleRequest<List> originalRequest1 = harness.getRequest();
-    SingleRequest<List> originalRequest2 = harness.getRequest();
-    assertTrue(originalRequest1.isEquivalentTo(originalRequest2));
-
-    harness = new RequestHarness();
-    harness.overrideWidth = harness.overrideWidth * 2;
-    SingleRequest<List> widthRequest = harness.getRequest();
-    assertTrue(widthRequest.isEquivalentTo(widthRequest));
-    assertFalse(widthRequest.isEquivalentTo(originalRequest1));
-    assertFalse(originalRequest1.isEquivalentTo(widthRequest));
-
-    harness = new RequestHarness();
-    harness.overrideHeight = harness.overrideHeight * 2;
-    SingleRequest<List> heightRequest = harness.getRequest();
-    assertTrue(heightRequest.isEquivalentTo(heightRequest));
-    assertFalse(heightRequest.isEquivalentTo(originalRequest1));
-    assertFalse(originalRequest1.isEquivalentTo(heightRequest));
-
-    harness = new RequestHarness();
-    harness.model = 12345679;
-    SingleRequest<List> modelRequest = harness.getRequest();
-    assertTrue(modelRequest.isEquivalentTo(modelRequest));
-    assertFalse(modelRequest.isEquivalentTo(originalRequest1));
-    assertFalse(originalRequest1.isEquivalentTo(modelRequest));
-
-    harness = new RequestHarness();
-    harness.model = null;
-    SingleRequest<List> nullModelRequest = harness.getRequest();
-    assertTrue(nullModelRequest.isEquivalentTo(nullModelRequest));
-    assertFalse(nullModelRequest.isEquivalentTo(originalRequest1));
-    assertFalse(originalRequest1.isEquivalentTo(nullModelRequest));
-
-    harness = new RequestHarness();
-    harness.errorDrawable = new ColorDrawable(Color.GRAY);
-    SingleRequest<List> errorRequest = harness.getRequest();
-    assertTrue(errorRequest.isEquivalentTo(errorRequest));
-    assertFalse(errorRequest.isEquivalentTo(originalRequest1));
-    assertFalse(originalRequest1.isEquivalentTo(errorRequest));
-
-    harness = new RequestHarness();
-    harness.priority = Priority.LOW;
-    SingleRequest<List> priorityRequest = harness.getRequest();
-    assertTrue(priorityRequest.isEquivalentTo(priorityRequest));
-    assertFalse(priorityRequest.isEquivalentTo(originalRequest1));
-    assertFalse(originalRequest1.isEquivalentTo(priorityRequest));
-  }
-
-  // TODO do we want to move these to Util?
-  @SuppressWarnings("unchecked")
-  private static <T> Transition<T> mockTransition() {
-    return mock(Transition.class);
-  }
-
-  @SuppressWarnings("unchecked")
-  private static Target<List> isAListTarget() {
-    return isA(Target.class);
-  }
-
-  private static GlideException isAGlideException() {
-    return isA(GlideException.class);
-  }
-
-  @SuppressWarnings("unchecked")
-  private static <T> Transition<T> anyTransition() {
-    return any(Transition.class);
-  }
-
-  private static class CallResourceCallback implements Answer {
-
-    private Resource resource;
-
-    public CallResourceCallback(Resource resource) {
-      this.resource = resource;
-    }
-
-    @Override
-    public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-      ResourceCallback cb =
-          (ResourceCallback) invocationOnMock.getArguments()[invocationOnMock.getArguments().length
-              - 1];
-      cb.onResourceReady(resource, DataSource.REMOTE);
-      return null;
-    }
-  }
-
-  private static class CallSizeReady implements Answer {
-
-    private int width;
-    private int height;
-
-    public CallSizeReady(int width, int height) {
-      this.width = width;
-      this.height = height;
-    }
-
-    @Override
-    public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-      SizeReadyCallback cb = (SizeReadyCallback) invocationOnMock.getArguments()[0];
-      cb.onSizeReady(width, height);
-      return null;
-    }
-  }
-
-  private static class MockTarget implements Target<List> {
-    private Drawable currentPlaceholder;
-
-    @Override
-    public void onLoadCleared(Drawable placeholder) {
-      currentPlaceholder = placeholder;
-    }
-
-    @Override
-    public void onLoadStarted(Drawable placeholder) {
-      currentPlaceholder = placeholder;
-
-    }
-
-    @Override
-    public void onLoadFailed(Drawable errorDrawable) {
-      currentPlaceholder = errorDrawable;
-
-    }
-
-    @Override
-    public void onResourceReady(List resource, Transition<? super List> transition) {
-      currentPlaceholder = null;
-    }
-
-
-    @Override
-    public void getSize(SizeReadyCallback cb) {
-    }
-
-    @Override
-    public void removeCallback(SizeReadyCallback cb) {
-      // Do nothing.
-    }
-
-    @Override
-    public void setRequest(Request request) {
-    }
-
-    @Override
-    public Request getRequest() {
-      return null;
-    }
-
-    @Override
-    public void onStart() {
-    }
-
-    @Override
-    public void onStop() {
-
-    }
-
-    @Override
-    public void onDestroy() {
-
-    }
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java b/library/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java
deleted file mode 100644
index 7a55e9990..000000000
--- a/library/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java
+++ /dev/null
@@ -1,38 +0,0 @@
-package com.bumptech.glide.signature;
-
-import static org.junit.Assert.assertNotNull;
-
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.tests.KeyAssertions;
-import java.io.UnsupportedEncodingException;
-import java.security.NoSuchAlgorithmException;
-import org.junit.After;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
-public class ApplicationVersionSignatureTest {
-
-  @After
-  public void tearDown() {
-    ApplicationVersionSignature.reset();
-  }
-
-  @Test
-  public void testCanGetKeyForSignature() {
-    Key key = ApplicationVersionSignature.obtain(RuntimeEnvironment.application);
-    assertNotNull(key);
-  }
-
-  @Test
-  public void testKeyForSignatureIsTheSameAcrossCallsInTheSamePackage()
-      throws NoSuchAlgorithmException, UnsupportedEncodingException {
-    Key first = ApplicationVersionSignature.obtain(RuntimeEnvironment.application);
-    Key second = ApplicationVersionSignature.obtain(RuntimeEnvironment.application);
-    KeyAssertions.assertSame(first, second);
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java b/library/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java
deleted file mode 100644
index 7f465fb23..000000000
--- a/library/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java
+++ /dev/null
@@ -1,48 +0,0 @@
-package com.bumptech.glide.signature;
-
-import com.bumptech.glide.tests.KeyAssertions;
-import java.io.UnsupportedEncodingException;
-import java.security.NoSuchAlgorithmException;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class MediaStoreSignatureTest {
-
-  @Test
-  public void testSignaturesDifferIfMimeTypeDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    MediaStoreSignature first = new MediaStoreSignature("first", 100, 1);
-    MediaStoreSignature second = new MediaStoreSignature("second", 100, 1);
-
-    KeyAssertions.assertDifferent(first, second);
-  }
-
-  @Test
-  public void testSignaturesDifferIfDateModifiedDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    MediaStoreSignature first = new MediaStoreSignature("mimeType", 100, 1);
-    MediaStoreSignature second = new MediaStoreSignature("mimeType", 999, 1);
-
-    KeyAssertions.assertDifferent(first, second);
-  }
-
-  @Test
-  public void testSignaturesDifferIfOrientationDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    MediaStoreSignature first = new MediaStoreSignature("mimeType", 100, 1);
-    MediaStoreSignature second = new MediaStoreSignature("mimeType", 100, 9);
-
-    KeyAssertions.assertDifferent(first, second);
-  }
-
-  @Test
-  public void testSignaturesAreTheSameIfAllArgsAreTheSame()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    MediaStoreSignature first = new MediaStoreSignature("mimeType", 100, 1);
-    MediaStoreSignature second = new MediaStoreSignature("mimeType", 100, 1);
-
-    KeyAssertions.assertSame(first, second);
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/signature/ObjectKeyTest.java b/library/src/test/java/com/bumptech/glide/signature/ObjectKeyTest.java
deleted file mode 100644
index 21570323c..000000000
--- a/library/src/test/java/com/bumptech/glide/signature/ObjectKeyTest.java
+++ /dev/null
@@ -1,18 +0,0 @@
-package com.bumptech.glide.signature;
-
-import com.bumptech.glide.tests.KeyAssertions;
-import java.security.NoSuchAlgorithmException;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class ObjectKeyTest {
-
-  @Test
-  public void testEquals() throws NoSuchAlgorithmException {
-    Object object = new Object();
-    KeyAssertions.assertSame(new ObjectKey(object), new ObjectKey(object));
-    KeyAssertions.assertDifferent(new ObjectKey(object), new ObjectKey(new Object()));
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/tests/KeyAssertions.java b/library/src/test/java/com/bumptech/glide/tests/KeyAssertions.java
deleted file mode 100644
index 5ee17790a..000000000
--- a/library/src/test/java/com/bumptech/glide/tests/KeyAssertions.java
+++ /dev/null
@@ -1,52 +0,0 @@
-package com.bumptech.glide.tests;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import com.bumptech.glide.load.Key;
-import com.google.common.testing.EqualsTester;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-
-public class KeyAssertions {
-
-  public static void assertSame(Key first, Key second) throws NoSuchAlgorithmException {
-    assertSameOrdered(first, second);
-    assertSameOrdered(second, first);
-  }
-
-  private static void assertSameOrdered(Key first, Key second) throws NoSuchAlgorithmException {
-    new EqualsTester()
-        .addEqualityGroup(first, second)
-        .testEquals();
-
-    assertThat(getDigest(first)).isEqualTo(getDigest(second));
-  }
-
-  public static void assertDifferent(Key first, Key second) throws NoSuchAlgorithmException {
-    assertDifferent(first, second, true);
-    assertDifferent(second, first, true);
-  }
-
-  public static void assertDifferent(Key first, Key second, boolean checkDiskCacheKey)
-      throws NoSuchAlgorithmException {
-    new EqualsTester()
-        .addEqualityGroup(first)
-        .addEqualityGroup(second)
-        .testEquals();
-
-    if (checkDiskCacheKey) {
-      MessageDigest firstDigest = MessageDigest.getInstance("SHA-1");
-      first.updateDiskCacheKey(firstDigest);
-      MessageDigest secondDigest = MessageDigest.getInstance("SHA-1");
-      second.updateDiskCacheKey(secondDigest);
-
-      assertThat(getDigest(first)).isNotEqualTo(getDigest(second));
-    }
-  }
-
-  private static byte[] getDigest(Key key) throws NoSuchAlgorithmException {
-    MessageDigest md = MessageDigest.getInstance("SHA-1");
-    key.updateDiskCacheKey(md);
-    return md.digest();
-  }
-}
diff --git a/library/src/test/resources/exif-orientation-examples b/library/src/test/resources/exif-orientation-examples
deleted file mode 160000
index 85c6e142e..000000000
--- a/library/src/test/resources/exif-orientation-examples
+++ /dev/null
@@ -1 +0,0 @@
-Subproject commit 85c6e142ee57d1c5c7a29b2efcd5980a584758e2
diff --git a/library/test/build.gradle b/library/test/build.gradle
new file mode 100644
index 000000000..67c391819
--- /dev/null
+++ b/library/test/build.gradle
@@ -0,0 +1,51 @@
+apply plugin: 'com.android.library'
+
+dependencies {
+    testImplementation "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}"
+    testImplementation project(':library')
+    testImplementation project(':testutil')
+    testImplementation 'com.google.guava:guava-testlib:18.0'
+    testImplementation "com.google.truth:truth:${TRUTH_VERSION}"
+    testImplementation "junit:junit:${JUNIT_VERSION}"
+    testImplementation "org.mockito:mockito-core:${MOCKITO_VERSION}"
+    testImplementation "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
+    testImplementation "com.squareup.okhttp3:mockwebserver:${MOCKWEBSERVER_VERSION}"
+    testImplementation "com.android.support:support-v4:${ANDROID_SUPPORT_VERSION}"
+}
+
+tasks.withType(JavaCompile) {
+    options.fork = true
+}
+
+afterEvaluate {
+    lint.enabled = false
+    compileDebugJavaWithJavac.enabled = false
+}
+
+android.testOptions.unitTests.all { Test testTask ->
+    // configure max heap size of the test JVM
+    testTask.maxHeapSize = TEST_JVM_MEMORY_SIZE as String
+    if (JavaVersion.current() <= JavaVersion.VERSION_1_7) {
+        // Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize=2048m; support was removed in 8.0
+        testTask.jvmArgs "-XX:MaxPermSize=${TEST_JVM_MEMORY_SIZE}"
+    }
+
+    // Initializing Robolectric is expensive, two threads seem to be around the only level where any
+    // improvement is seen.
+    testTask.maxParallelForks = 2
+}
+
+android {
+    compileSdkVersion COMPILE_SDK_VERSION as int
+
+    defaultConfig {
+        minSdkVersion MIN_SDK_VERSION as int
+        targetSdkVersion TARGET_SDK_VERSION as int
+        versionName VERSION_NAME as String
+    }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
+}
diff --git a/library/test/src/main/AndroidManifest.xml b/library/test/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..600ac91f9
--- /dev/null
+++ b/library/test/src/main/AndroidManifest.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest package="com.bumptech.glide.test">
+    <application/>
+</manifest>
diff --git a/library/src/test/java/com/bumptech/glide/GlideContextTest.java b/library/test/src/test/java/com/bumptech/glide/GlideContextTest.java
similarity index 89%
rename from library/src/test/java/com/bumptech/glide/GlideContextTest.java
rename to library/test/src/test/java/com/bumptech/glide/GlideContextTest.java
index 199ecb38e..2281d5706 100644
--- a/library/src/test/java/com/bumptech/glide/GlideContextTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/GlideContextTest.java
@@ -9,6 +9,7 @@
 import android.graphics.drawable.Drawable;
 import android.util.Log;
 import com.bumptech.glide.load.engine.Engine;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
 import com.bumptech.glide.load.resource.drawable.DrawableTransitionOptions;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 import com.bumptech.glide.request.RequestOptions;
@@ -33,9 +34,15 @@ public void setUp() {
     Application app = RuntimeEnvironment.application;
 
     transitionOptions = new HashMap<>();
-    context = new GlideContext(app, new Registry(),
-        new ImageViewTargetFactory(), new RequestOptions(),
-        transitionOptions, mock(Engine.class), Log.DEBUG);
+    context = new GlideContext(
+        app,
+        new LruArrayPool(),
+        new Registry(),
+        new ImageViewTargetFactory(),
+        new RequestOptions(),
+        transitionOptions,
+        mock(Engine.class),
+        Log.DEBUG);
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/GlideTest.java b/library/test/src/test/java/com/bumptech/glide/GlideTest.java
similarity index 66%
rename from library/src/test/java/com/bumptech/glide/GlideTest.java
rename to library/test/src/test/java/com/bumptech/glide/GlideTest.java
index 93f70d040..68ee3870f 100644
--- a/library/src/test/java/com/bumptech/glide/GlideTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/GlideTest.java
@@ -3,7 +3,10 @@
 import static com.bumptech.glide.request.RequestOptions.decodeTypeOf;
 import static com.bumptech.glide.request.RequestOptions.errorOf;
 import static com.bumptech.glide.request.RequestOptions.placeholderOf;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
+import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Matchers.isA;
@@ -13,11 +16,9 @@
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
-import static org.robolectric.Shadows.shadowOf;
 
 import android.content.ContentResolver;
 import android.content.Context;
-import android.content.pm.ApplicationInfo;
 import android.content.res.AssetFileDescriptor;
 import android.graphics.Bitmap;
 import android.graphics.Color;
@@ -26,9 +27,10 @@
 import android.graphics.drawable.Drawable;
 import android.media.MediaMetadataRetriever;
 import android.net.Uri;
-import android.os.Bundle;
 import android.os.Handler;
 import android.os.ParcelFileDescriptor;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.ViewGroup;
 import android.widget.ImageView;
 import com.bumptech.glide.load.DataSource;
@@ -48,28 +50,33 @@
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 import com.bumptech.glide.manager.Lifecycle;
 import com.bumptech.glide.manager.RequestManagerTreeNode;
-import com.bumptech.glide.module.GlideModule;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.RequestOptions;
+import com.bumptech.glide.request.target.SimpleTarget;
 import com.bumptech.glide.request.target.SizeReadyCallback;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.tests.GlideShadowLooper;
+import com.bumptech.glide.tests.TearDownGlide;
 import com.bumptech.glide.tests.Util;
 import com.bumptech.glide.testutil.TestResourceUtil;
+import com.bumptech.glide.util.Preconditions;
 import java.io.ByteArrayInputStream;
 import java.io.File;
-import java.io.IOException;
 import java.io.InputStream;
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.nio.ByteBuffer;
 import java.util.HashMap;
 import java.util.Map;
-import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.RobolectricTestRunner;
@@ -81,7 +88,6 @@
 import org.robolectric.annotation.Resetter;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowBitmap;
-import org.robolectric.shadows.ShadowPackageManager;
 
 /**
  * Tests for the {@link Glide} interface and singleton.
@@ -91,74 +97,135 @@
     GlideTest.ShadowFileDescriptorContentResolver.class,
     GlideTest.ShadowMediaMetadataRetriever.class, GlideShadowLooper.class,
     GlideTest.MutableShadowBitmap.class })
-@SuppressWarnings({"unchecked", "deprecation"})
+@SuppressWarnings("unchecked")
 public class GlideTest {
+  // Fixes method overload confusion.
+  private static final Object NULL = null;
+
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+
   @SuppressWarnings("rawtypes")
-  private Target target = null;
+  @Mock private Target target;
+  @Mock private DiskCache.Factory diskCacheFactory;
+  @Mock private DiskCache diskCache;
+  @Mock private MemoryCache memoryCache;
+  @Mock private Handler bgHandler;
+  @Mock private Lifecycle lifecycle;
+  @Mock private RequestManagerTreeNode treeNode;
+  @Mock private BitmapPool bitmapPool;
+
   private ImageView imageView;
   private RequestManager requestManager;
+  private Context context;
 
   @Before
-  public void setUp() throws Exception {
-    Glide.tearDown();
-
-    ShadowPackageManager pm = shadowOf(RuntimeEnvironment.application.getPackageManager());
-    ApplicationInfo info =
-        pm.getApplicationInfo(RuntimeEnvironment.application.getPackageName(), 0);
-    info.metaData = new Bundle();
-    info.metaData.putString(SetupModule.class.getName(), "GlideModule");
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    context = RuntimeEnvironment.application;
+
+    // Run all tasks on the main thread so they complete synchronously.
+    GlideExecutor executor = MockGlideExecutor.newMainThreadExecutor();
+    when(diskCacheFactory.build()).thenReturn(diskCache);
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setMemoryCache(memoryCache)
+            .setDiskCache(diskCacheFactory)
+            .setSourceExecutor(executor)
+            .setDiskCacheExecutor(executor));
+    Registry registry = Glide.get(context).getRegistry();
+    registerMockModelLoader(
+        GlideUrl.class, InputStream.class, new ByteArrayInputStream(new byte[0]), registry);
+    registerMockModelLoader(
+        File.class, InputStream.class, new ByteArrayInputStream(new byte[0]), registry);
+    registerMockModelLoader(
+        File.class, ParcelFileDescriptor.class, mock(ParcelFileDescriptor.class), registry);
+    registerMockModelLoader(File.class, ByteBuffer.class, ByteBuffer.allocate(10), registry);
 
     // Ensure that target's size ready callback will be called synchronously.
-    target = mock(Target.class);
-    imageView = new ImageView(RuntimeEnvironment.application);
+    imageView = new ImageView(context);
     imageView.setLayoutParams(new ViewGroup.LayoutParams(100, 100));
     imageView.layout(0, 0, 100, 100);
     doAnswer(new CallSizeReady()).when(target).getSize(isA(SizeReadyCallback.class));
 
-    Handler bgHandler = mock(Handler.class);
     when(bgHandler.post(isA(Runnable.class))).thenAnswer(new Answer<Boolean>() {
       @Override
-      public Boolean answer(InvocationOnMock invocation) throws Throwable {
+      public Boolean answer(InvocationOnMock invocation) {
         Runnable runnable = (Runnable) invocation.getArguments()[0];
         runnable.run();
         return true;
       }
     });
 
-    Lifecycle lifecycle = mock(Lifecycle.class);
-    RequestManagerTreeNode treeNode = mock(RequestManagerTreeNode.class);
-    requestManager = new RequestManager(Glide.get(getContext()), lifecycle, treeNode);
+    requestManager = new RequestManager(Glide.get(context), lifecycle, treeNode, context);
     requestManager.resumeRequests();
   }
 
-  @After
-  public void tearDown() {
-    Glide.tearDown();
+  @Test
+  public void testCanSetMemoryCategory() {
+    MemoryCategory memoryCategory = MemoryCategory.NORMAL;
+    Glide glide =
+        new GlideBuilder()
+            .setBitmapPool(bitmapPool)
+            .setMemoryCache(memoryCache)
+            .build(context);
+    glide.setMemoryCategory(memoryCategory);
+
+    verify(memoryCache).setSizeMultiplier(eq(memoryCategory.getMultiplier()));
+    verify(bitmapPool).setSizeMultiplier(eq(memoryCategory.getMultiplier()));
   }
 
   @Test
-  public void testCanSetMemoryCategory() {
-    MemoryCache memoryCache = mock(MemoryCache.class);
-    BitmapPool bitmapPool = mock(BitmapPool.class);
+  public void testCanIncreaseMemoryCategory() {
+    MemoryCategory memoryCategory = MemoryCategory.NORMAL;
+    Glide glide =
+        new GlideBuilder()
+            .setBitmapPool(bitmapPool)
+            .setMemoryCache(memoryCache)
+            .build(context);
+    glide.setMemoryCategory(memoryCategory);
 
+    verify(memoryCache).setSizeMultiplier(eq(memoryCategory.getMultiplier()));
+    verify(bitmapPool).setSizeMultiplier(eq(memoryCategory.getMultiplier()));
+
+    MemoryCategory newMemoryCategory = MemoryCategory.HIGH;
+    MemoryCategory oldMemoryCategory = glide.setMemoryCategory(newMemoryCategory);
+
+    assertEquals(memoryCategory, oldMemoryCategory);
+
+    verify(memoryCache).setSizeMultiplier(eq(newMemoryCategory.getMultiplier()));
+    verify(bitmapPool).setSizeMultiplier(eq(newMemoryCategory.getMultiplier()));
+  }
+
+  @Test
+  public void testCanDecreaseMemoryCategory() {
     MemoryCategory memoryCategory = MemoryCategory.NORMAL;
     Glide glide =
-        new GlideBuilder().setMemoryCache(memoryCache).setBitmapPool(bitmapPool)
-            .build(getContext());
+        new GlideBuilder()
+            .setBitmapPool(bitmapPool)
+            .setMemoryCache(memoryCache)
+            .build(context);
     glide.setMemoryCategory(memoryCategory);
 
     verify(memoryCache).setSizeMultiplier(eq(memoryCategory.getMultiplier()));
     verify(bitmapPool).setSizeMultiplier(eq(memoryCategory.getMultiplier()));
+
+    MemoryCategory newMemoryCategory = MemoryCategory.LOW;
+    MemoryCategory oldMemoryCategory = glide.setMemoryCategory(newMemoryCategory);
+
+    assertEquals(memoryCategory, oldMemoryCategory);
+
+    verify(memoryCache).setSizeMultiplier(eq(newMemoryCategory.getMultiplier()));
+    verify(bitmapPool).setSizeMultiplier(eq(newMemoryCategory.getMultiplier()));
   }
 
   @Test
   public void testClearMemory() {
-    BitmapPool bitmapPool = mock(BitmapPool.class);
-    MemoryCache memoryCache = mock(MemoryCache.class);
-
     Glide glide =
-        new GlideBuilder().setBitmapPool(bitmapPool).setMemoryCache(memoryCache)
-            .build(getContext());
+        new GlideBuilder()
+            .setBitmapPool(bitmapPool)
+            .setMemoryCache(memoryCache)
+            .build(context);
 
     glide.clearMemory();
 
@@ -168,12 +235,11 @@ public void testClearMemory() {
 
   @Test
   public void testTrimMemory() {
-    BitmapPool bitmapPool = mock(BitmapPool.class);
-    MemoryCache memoryCache = mock(MemoryCache.class);
-
     Glide glide =
-        new GlideBuilder().setBitmapPool(bitmapPool).setMemoryCache(memoryCache)
-            .build(getContext());
+        new GlideBuilder()
+            .setBitmapPool(bitmapPool)
+            .setMemoryCache(memoryCache)
+            .build(context);
 
     final int level = 123;
 
@@ -184,13 +250,13 @@ public void testTrimMemory() {
   }
 
   @Test
-  public void testFileDefaultLoaderWithInputStream() throws Exception {
+  public void testFileDefaultLoaderWithInputStream() {
     registerFailFactory(File.class, ParcelFileDescriptor.class);
     runTestFileDefaultLoader();
   }
 
   @Test
-  public void testFileDefaultLoaderWithFileDescriptor() throws Exception {
+  public void testFileDefaultLoaderWithFileDescriptor() {
     registerFailFactory(File.class, InputStream.class);
     runTestFileDefaultLoader();
   }
@@ -213,6 +279,7 @@ private void runTestFileDefaultLoader() {
     assertNotNull(imageView.getDrawable());
   }
 
+  @SuppressWarnings("deprecation")
   @Test
   public void testUrlDefaultLoader() throws MalformedURLException {
     URL url = new URL("http://www.google.com");
@@ -247,13 +314,53 @@ public void testToBytesOption() {
   }
 
   @Test
-  public void testUriDefaultLoaderWithInputStream() throws Exception {
+  public void testLoadColorDrawable_withUnitBitmapTransformation_returnsColorDrawable() {
+    ColorDrawable colorDrawable = new ColorDrawable(Color.RED);
+    requestManager
+        .load(colorDrawable)
+        .apply(new RequestOptions()
+            .override(100, 100)
+            .centerCrop())
+        .into(target);
+
+    ArgumentCaptor<Object> argumentCaptor = ArgumentCaptor.forClass(Object.class);
+    verify(target).onResourceReady(argumentCaptor.capture(), isA(Transition.class));
+
+    Object result = argumentCaptor.getValue();
+
+    assertThat(result).isInstanceOf(ColorDrawable.class);
+    assertThat(((ColorDrawable) result).getColor()).isEqualTo(Color.RED);
+  }
+
+  @Test
+  public void testLoadColorDrawable_withNonUnitBitmapTransformation_returnsBitmapDrawable() {
+    ColorDrawable colorDrawable = new ColorDrawable(Color.RED);
+    requestManager
+        .load(colorDrawable)
+        .apply(new RequestOptions()
+            .override(100, 100)
+            .circleCrop())
+        .into(target);
+
+    ArgumentCaptor<Object> argumentCaptor = ArgumentCaptor.forClass(Object.class);
+    verify(target).onResourceReady(argumentCaptor.capture(), isA(Transition.class));
+
+    Object result = argumentCaptor.getValue();
+
+    assertThat(result).isInstanceOf(BitmapDrawable.class);
+    Bitmap bitmap = ((BitmapDrawable) result).getBitmap();
+    assertThat(bitmap.getWidth()).isEqualTo(100);
+    assertThat(bitmap.getHeight()).isEqualTo(100);
+  }
+
+  @Test
+  public void testUriDefaultLoaderWithInputStream() {
     registerFailFactory(Uri.class, ParcelFileDescriptor.class);
     runTestUriDefaultLoader();
   }
 
   @Test
-  public void testUriDefaultLoaderWithFileDescriptor() throws Exception {
+  public void testUriDefaultLoaderWithFileDescriptor() {
     registerFailFactory(Uri.class, InputStream.class);
     runTestUriDefaultLoader();
   }
@@ -282,13 +389,13 @@ public void testStringDefaultLoaderWithUrl() {
   }
 
   @Test
-  public void testFileStringDefaultLoaderWithInputStream() throws Exception {
+  public void testFileStringDefaultLoaderWithInputStream() {
     registerFailFactory(String.class, ParcelFileDescriptor.class);
     runTestFileStringDefaultLoader();
   }
 
   @Test
-  public void testFileStringDefaultLoaderWithFileDescriptor() throws Exception {
+  public void testFileStringDefaultLoaderWithFileDescriptor() {
     registerFailFactory(String.class, ParcelFileDescriptor.class);
     runTestFileStringDefaultLoader();
   }
@@ -305,13 +412,13 @@ private void runTestFileStringDefaultLoader() {
   }
 
   @Test
-  public void testUriStringDefaultLoaderWithInputStream() throws Exception {
+  public void testUriStringDefaultLoaderWithInputStream() {
     registerFailFactory(String.class, ParcelFileDescriptor.class);
     runTestUriStringDefaultLoader();
   }
 
   @Test
-  public void testUriStringDefaultLoaderWithFileDescriptor() throws Exception {
+  public void testUriStringDefaultLoaderWithFileDescriptor() {
     registerFailFactory(String.class, InputStream.class);
     runTestUriStringDefaultLoader();
   }
@@ -350,13 +457,13 @@ public boolean onResourceReady(Drawable resource, Object model, Target<Drawable>
   }
 
   @Test
-  public void testIntegerDefaultLoaderWithInputStream() throws Exception {
+  public void testIntegerDefaultLoaderWithInputStream() {
     registerFailFactory(Integer.class, ParcelFileDescriptor.class);
     runTestIntegerDefaultLoader();
   }
 
   @Test
-  public void testIntegerDefaultLoaderWithFileDescriptor() throws Exception {
+  public void testIntegerDefaultLoaderWithFileDescriptor() {
     registerFailFactory(Integer.class, InputStream.class);
     runTestIntegerDefaultLoader();
   }
@@ -407,9 +514,9 @@ public void testNonDefaultModelWithRegisteredFactoryDoesNotThrow() {
   }
 
   @Test
-  public void testReceivesGif() throws IOException {
+  public void testReceivesGif() {
     String fakeUri = "content://fake";
-    InputStream testGifData = openResource("test.gif");
+    InputStream testGifData = openGif();
     mockUri(Uri.parse(fakeUri), testGifData);
 
     requestManager.asGif().load(fakeUri).into(target);
@@ -418,9 +525,9 @@ public void testReceivesGif() throws IOException {
   }
 
   @Test
-  public void testReceivesGifBytes() throws IOException {
+  public void testReceivesGifBytes() {
     String fakeUri = "content://fake";
-    InputStream testGifData = openResource("test.gif");
+    InputStream testGifData = openGif();
     mockUri(Uri.parse(fakeUri), testGifData);
 
     requestManager.as(byte[].class).apply(decodeTypeOf(GifDrawable.class)).load(fakeUri)
@@ -470,24 +577,24 @@ public void testReceivesRecursiveThumbnailWithPercentage() {
 
   @Test
   public void testNullModelInGenericImageLoadDoesNotThrow() {
-    requestManager.load(null).into(target);
+    requestManager.load(NULL).into(target);
   }
 
   @Test
   public void testNullModelInGenericVideoLoadDoesNotThrow() {
-    requestManager.load(null).into(target);
+    requestManager.load(NULL).into(target);
   }
 
   @Test
   public void testNullModelInGenericLoadDoesNotThrow() {
-    requestManager.load(null).into(target);
+    requestManager.load(NULL).into(target);
   }
 
   @Test
   public void testNullModelDoesNotThrow() {
     Drawable drawable = new ColorDrawable(Color.RED);
     requestManager
-        .load(null)
+        .load(NULL)
         .apply(errorOf(drawable))
         .into(target);
 
@@ -500,7 +607,7 @@ public void testNullModelPrefersErrorDrawable() {
     Drawable error = new ColorDrawable(Color.RED);
 
     requestManager
-        .load(null)
+        .load(NULL)
         .apply(placeholderOf(placeholder)
             .error(error))
         .into(target);
@@ -508,6 +615,40 @@ public void testNullModelPrefersErrorDrawable() {
     verify(target).onLoadFailed(eq(error));
   }
 
+  @Test
+  public void testLoadBitmap_asBitmap() {
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    requestManager
+        .asBitmap()
+        .load(bitmap)
+        .into(target);
+
+    verify(target).onResourceReady(eq(bitmap), any(Transition.class));
+  }
+
+  @Test
+  public void testLoadBitmap_asDrawable() {
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    requestManager
+        .load(bitmap)
+        .into(target);
+
+    ArgumentCaptor<Object> captor = ArgumentCaptor.forClass(Object.class);
+    verify(target).onResourceReady(captor.capture(), any(Transition.class));
+    BitmapDrawable drawable = (BitmapDrawable) captor.getValue();
+    assertThat(drawable.getBitmap()).isEqualTo(bitmap);
+  }
+
+  @Test
+  public void testLoadDrawable() {
+    Drawable drawable = new ColorDrawable(Color.RED);
+    requestManager
+        .load(drawable)
+        .into(target);
+
+    verify(target).onResourceReady(eq(drawable), any(Transition.class));
+  }
+
   @Test
   public void testNullModelPrefersFallbackDrawable() {
     Drawable placeholder = new ColorDrawable(Color.GREEN);
@@ -515,7 +656,7 @@ public void testNullModelPrefersFallbackDrawable() {
     Drawable fallback = new ColorDrawable(Color.BLUE);
 
     requestManager
-        .load(null)
+        .load(NULL)
         .apply(placeholderOf(placeholder)
             .error(error)
             .fallback(fallback))
@@ -529,7 +670,7 @@ public void testNullModelResolvesToUsePlaceholder() {
     Drawable placeholder = new ColorDrawable(Color.GREEN);
 
     requestManager
-        .load(null)
+        .load(NULL)
         .apply(placeholderOf(placeholder))
         .into(target);
 
@@ -543,7 +684,25 @@ public void testByteData() {
   }
 
   @Test
-  public void testClone() throws IOException {
+  public void removeFromManagers_afterRequestManagerRemoved_clearsRequest() {
+    target = requestManager.load(mockUri("content://uri")).into(new SimpleTarget<Drawable>() {
+      @Override
+      public void onResourceReady(@NonNull Drawable resource,
+          @Nullable Transition<? super Drawable> transition) {
+        // Do nothing.
+      }
+    });
+    Request request = Preconditions.checkNotNull(target.getRequest());
+
+    requestManager.onDestroy();
+    requestManager.clear(target);
+
+    assertThat(target.getRequest()).isNull();
+    assertThat(request.isCancelled()).isTrue();
+  }
+
+  @Test
+  public void testClone() {
     Target<Drawable> firstTarget = mock(Target.class);
     doAnswer(new CallSizeReady(100, 100)).when(firstTarget).getSize(isA(SizeReadyCallback.class));
     Target<Drawable> secondTarget = mock(Target.class);
@@ -562,8 +721,7 @@ public void testClone() throws IOException {
   }
 
   @SuppressWarnings("unchecked")
-  private <T, Z> void registerFailFactory(Class<T> failModel, Class<Z> failResource)
-      throws Exception {
+  private <T, Z> void registerFailFactory(Class<T> failModel, Class<Z> failResource) {
     DataFetcher<Z> failFetcher = mock(DataFetcher.class);
     doAnswer(new Util.CallDataReady<>(null))
         .when(failFetcher)
@@ -576,24 +734,23 @@ public void testClone() throws IOException {
     ModelLoaderFactory<T, Z> failFactory = mock(ModelLoaderFactory.class);
     when(failFactory.build(isA(MultiModelLoaderFactory.class))).thenReturn(failLoader);
 
-    Glide.get(getContext()).getRegistry().prepend(failModel, failResource, failFactory);
+    Glide.get(context).getRegistry().prepend(failModel, failResource, failFactory);
   }
 
   private String mockUri(String uriString) {
     return mockUri(Uri.parse(uriString), null);
   }
 
-  private String mockUri(Uri uri) {
-    return mockUri(uri, null);
+  private void mockUri(Uri uri) {
+    mockUri(uri, null);
   }
 
   private String mockUri(Uri uri, InputStream is) {
     if (is == null) {
       is = new ByteArrayInputStream(new byte[0]);
     }
-    ContentResolver contentResolver = RuntimeEnvironment.application.getContentResolver();
-    ShadowFileDescriptorContentResolver shadowContentResolver =
-        (ShadowFileDescriptorContentResolver) Shadow.extract(contentResolver);
+    ContentResolver contentResolver = context.getContentResolver();
+    ShadowFileDescriptorContentResolver shadowContentResolver = Shadow.extract(contentResolver);
     shadowContentResolver.registerInputStream(uri, is);
 
     AssetFileDescriptor assetFileDescriptor = mock(AssetFileDescriptor.class);
@@ -604,17 +761,13 @@ private String mockUri(Uri uri, InputStream is) {
     return uri.toString();
   }
 
-  private Context getContext() {
-    return RuntimeEnvironment.application;
-  }
-
   @SuppressWarnings("unchecked")
   private <T> void registerMockStreamModelLoader(final Class<T> modelClass) {
     ModelLoader<T, InputStream> modelLoader = mockStreamModelLoader(modelClass);
     ModelLoaderFactory<T, InputStream> modelLoaderFactory = mock(ModelLoaderFactory.class);
     when(modelLoaderFactory.build(isA(MultiModelLoaderFactory.class))).thenReturn(modelLoader);
 
-    Glide.get(RuntimeEnvironment.application).getRegistry()
+    Glide.get(context).getRegistry()
         .prepend(modelClass, InputStream.class, modelLoaderFactory);
   }
 
@@ -636,19 +789,19 @@ private Context getContext() {
     return modelLoader;
   }
 
-  private InputStream openResource(String imageName) throws IOException {
-    return TestResourceUtil.openResource(getClass(), imageName);
+  private InputStream openGif() {
+    return TestResourceUtil.openResource(getClass(), "test.gif");
   }
 
   private static class CallSizeReady implements Answer<Void> {
-    private int width;
-    private int height;
+    private final int width;
+    private final int height;
 
-    public CallSizeReady() {
+    CallSizeReady() {
       this(100, 100);
     }
 
-    public CallSizeReady(int width, int height) {
+    CallSizeReady(int width, int height) {
       this.width = width;
       this.height = height;
     }
@@ -661,53 +814,26 @@ public Void answer(InvocationOnMock invocation) throws Throwable {
     }
   }
 
-  public static class SetupModule implements GlideModule {
-
-    @Override
-    public void applyOptions(Context context, GlideBuilder builder) {
-      // Run all tasks on the main thread so they complete synchronously.
-      GlideExecutor executor = MockGlideExecutor.newMainThreadExecutor();
-
-      DiskCache.Factory diskCacheFactory = mock(DiskCache.Factory.class);
-      when(diskCacheFactory.build()).thenReturn(mock(DiskCache.class));
-
-      builder.setMemoryCache(mock(MemoryCache.class)).setDiskCache(diskCacheFactory)
-          .setResizeExecutor(executor).setDiskCacheExecutor(executor);
-    }
-
-    @Override
-    public void registerComponents(Context context, Glide glide, Registry registry) {
-      registerMockModelLoader(GlideUrl.class, InputStream.class,
-          new ByteArrayInputStream(new byte[0]), registry);
-      registerMockModelLoader(File.class, InputStream.class,
-          new ByteArrayInputStream(new byte[0]), registry);
-      registerMockModelLoader(File.class, ParcelFileDescriptor.class,
-          mock(ParcelFileDescriptor.class), registry);
-      registerMockModelLoader(File.class, ByteBuffer.class,
-          ByteBuffer.allocate(10), registry);
+  private static <X, Y> void registerMockModelLoader(Class<X> modelClass, Class<Y> dataClass,
+      Y loadedData, Registry registry) {
+    DataFetcher<Y> mockStreamFetcher = mock(DataFetcher.class);
+    when(mockStreamFetcher.getDataClass()).thenReturn(dataClass);
+    try {
+      doAnswer(new Util.CallDataReady<>(loadedData))
+          .when(mockStreamFetcher)
+          .loadData(isA(Priority.class), isA(DataFetcher.DataCallback.class));
+    } catch (Exception e) {
+      throw new RuntimeException(e);
     }
+    ModelLoader<X, Y> mockUrlLoader = mock(ModelLoader.class);
+    when(mockUrlLoader.buildLoadData(isA(modelClass), anyInt(), anyInt(), isA(Options.class)))
+        .thenReturn(new ModelLoader.LoadData<>(mock(Key.class), mockStreamFetcher));
+    when(mockUrlLoader.handles(isA(modelClass))).thenReturn(true);
+    ModelLoaderFactory<X, Y> mockUrlLoaderFactory = mock(ModelLoaderFactory.class);
+    when(mockUrlLoaderFactory.build(isA(MultiModelLoaderFactory.class)))
+        .thenReturn(mockUrlLoader);
 
-    private static <X, Y> void registerMockModelLoader(Class<X> modelClass, Class<Y> dataClass,
-          Y loadedData, Registry registry) {
-      DataFetcher<Y> mockStreamFetcher = mock(DataFetcher.class);
-      when(mockStreamFetcher.getDataClass()).thenReturn(dataClass);
-      try {
-        doAnswer(new Util.CallDataReady<>(loadedData))
-            .when(mockStreamFetcher)
-            .loadData(isA(Priority.class), isA(DataFetcher.DataCallback.class));
-      } catch (Exception e) {
-        throw new RuntimeException(e);
-      }
-      ModelLoader<X, Y> mockUrlLoader = mock(ModelLoader.class);
-      when(mockUrlLoader.buildLoadData(isA(modelClass), anyInt(), anyInt(), isA(Options.class)))
-          .thenReturn(new ModelLoader.LoadData<>(mock(Key.class), mockStreamFetcher));
-      when(mockUrlLoader.handles(isA(modelClass))).thenReturn(true);
-      ModelLoaderFactory<X, Y> mockUrlLoaderFactory = mock(ModelLoaderFactory.class);
-      when(mockUrlLoaderFactory.build(isA(MultiModelLoaderFactory.class)))
-          .thenReturn(mockUrlLoader);
-
-      registry.replace(modelClass, dataClass, mockUrlLoaderFactory);
-    }
+    registry.replace(modelClass, dataClass, mockUrlLoaderFactory);
   }
 
   // TODO: Extending ShadowContentResolver results in exceptions because of some state issues
@@ -726,11 +852,11 @@ public static void reset() {
       URI_TO_FILE_DESCRIPTOR.clear();
     }
 
-    public void registerInputStream(Uri uri, InputStream inputStream) {
+    void registerInputStream(Uri uri, InputStream inputStream) {
       URI_TO_INPUT_STREAMS.put(uri, inputStream);
     }
 
-    public void registerAssetFileDescriptor(Uri uri, AssetFileDescriptor assetFileDescriptor) {
+    void registerAssetFileDescriptor(Uri uri, AssetFileDescriptor assetFileDescriptor) {
       URI_TO_FILE_DESCRIPTOR.put(uri, assetFileDescriptor);
     }
 
diff --git a/library/src/test/java/com/bumptech/glide/ListPreloaderTest.java b/library/test/src/test/java/com/bumptech/glide/ListPreloaderTest.java
similarity index 87%
rename from library/src/test/java/com/bumptech/glide/ListPreloaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/ListPreloaderTest.java
index 08517533e..e6c957d27 100644
--- a/library/src/test/java/com/bumptech/glide/ListPreloaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/ListPreloaderTest.java
@@ -9,6 +9,7 @@
 import static org.mockito.Mockito.verify;
 
 import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.request.target.SizeReadyCallback;
 import com.bumptech.glide.request.target.Target;
 import java.util.ArrayList;
@@ -36,7 +37,7 @@
   @Mock private RequestManager requestManager;
 
   @Before
-  public void setUp() throws Exception {
+  public void setUp() {
     MockitoAnnotations.initMocks(this);
   }
 
@@ -73,7 +74,7 @@ public void testGetItemsIsCalledInOrderIncreasing() {
       private int expectedPosition;
 
       @Override
-      public int[] getPreloadSize(Object item, int adapterPosition, int itemPosition) {
+      public int[] getPreloadSize(@NonNull Object item, int adapterPosition, int itemPosition) {
         return new int[] { 10, 10 };
       }
 
@@ -83,10 +84,10 @@ public void testGetItemsIsCalledInOrderIncreasing() {
         return objects.subList(position - 11, position + 1 - 11);
       }
 
-      @NonNull
+      @Nullable
       @Override
       @SuppressWarnings("unchecked")
-      public RequestBuilder<Object> getPreloadRequestBuilder(Object item) {
+      public RequestBuilder<Object> getPreloadRequestBuilder(@NonNull Object item) {
         assertEquals(objects.get(expectedPosition), item);
         expectedPosition++;
         return mock(RequestBuilder.class);
@@ -134,7 +135,7 @@ public void testGetItemsIsCalledInOrderDecreasing() {
       private int expectedPosition = toPreload - 1;
 
       @Override
-      public int[] getPreloadSize(Object item, int adapterPosition, int itemPosition) {
+      public int[] getPreloadSize(@NonNull Object item, int adapterPosition, int itemPosition) {
         return new int[] { 10, 10 };
       }
 
@@ -142,15 +143,15 @@ public void testGetItemsIsCalledInOrderDecreasing() {
       @Override
       public List<Object> getPreloadItems(int position) {
         if (position == 40) {
-          return null;
+          return Collections.emptyList();
         }
         return objects.subList(position, position + 1);
       }
 
-      @NonNull
+      @Nullable
       @Override
       @SuppressWarnings("unchecked")
-      public RequestBuilder<Object> getPreloadRequestBuilder(Object item) {
+      public RequestBuilder<Object> getPreloadRequestBuilder(@NonNull Object item) {
         assertEquals(objects.get(expectedPosition), item);
         expectedPosition--;
         return mock(RequestBuilder.class);
@@ -253,7 +254,7 @@ public void testDontPreloadItemsRepeatedlyWhileDecreasing() {
   }
 
   @Test
-  public void testMultipleItemsForPositionIncreasing() throws NoSuchFieldException {
+  public void testMultipleItemsForPositionIncreasing() {
     final List<Object> objects = new ArrayList<>();
     objects.add(new Object());
     objects.add(new Object());
@@ -267,16 +268,16 @@ public void testMultipleItemsForPositionIncreasing() throws NoSuchFieldException
       }
 
       @Override
-      public int[] getPreloadSize(Object item, int adapterPosition, int itemPosition) {
+      public int[] getPreloadSize(@NonNull Object item, int adapterPosition, int itemPosition) {
         assertEquals(expectedPosition / 2, adapterPosition);
         assertEquals(expectedPosition % 2, itemPosition);
         expectedPosition++;
         return itemPosition == 0 ? new int[] { 10, 11 } : new int[] { 20, 21 };
       }
 
-      @NonNull
+      @Nullable
       @Override
-      public RequestBuilder<Object> getPreloadRequestBuilder(Object item) {
+      public RequestBuilder<Object> getPreloadRequestBuilder(@NonNull Object item) {
         return request;
       }
     };
@@ -291,7 +292,7 @@ public void testMultipleItemsForPositionIncreasing() throws NoSuchFieldException
   }
 
   @Test
-  public void testMultipleItemsForPositionDecreasing() throws NoSuchFieldException {
+  public void testMultipleItemsForPositionDecreasing() {
     final List<Object> objects = new ArrayList<>();
     objects.add(new Object());
     objects.add(new Object());
@@ -305,16 +306,16 @@ public void testMultipleItemsForPositionDecreasing() throws NoSuchFieldException
       }
 
       @Override
-      public int[] getPreloadSize(Object item, int adapterPosition, int itemPosition) {
+      public int[] getPreloadSize(@NonNull Object item, int adapterPosition, int itemPosition) {
         assertEquals(expectedPosition / 2, adapterPosition);
         assertEquals(expectedPosition % 2, itemPosition);
         expectedPosition--;
         return itemPosition == 0 ? new int[] { 10, 11 } : new int[] { 20, 21 };
       }
 
-      @NonNull
+      @Nullable
       @Override
-      public RequestBuilder<Object> getPreloadRequestBuilder(Object item) {
+      public RequestBuilder<Object> getPreloadRequestBuilder(@NonNull Object item) {
         return request;
       }
     };
@@ -329,19 +330,22 @@ public void testMultipleItemsForPositionDecreasing() throws NoSuchFieldException
     assertEquals(expected, allValues);
   }
 
-  private <R> List<Integer> getTargetsSizes(
-      RequestBuilder<R> requestBuilder, VerificationMode mode) {
+  private <Resource> List<Integer> getTargetsSizes(
+      RequestBuilder<Resource> requestBuilder, VerificationMode mode) {
     ArgumentCaptor<Integer> integerArgumentCaptor = ArgumentCaptor.forClass(Integer.class);
-    ArgumentCaptor<Target<R>> targetArgumentCaptor = cast(ArgumentCaptor.forClass(Target.class));
+    ArgumentCaptor<Target<Resource>> targetArgumentCaptor =
+        cast(ArgumentCaptor.forClass(Target.class));
     SizeReadyCallback cb = mock(SizeReadyCallback.class);
     verify(requestBuilder, mode).into(targetArgumentCaptor.capture());
-    for (Target<R> target : targetArgumentCaptor.getAllValues()) {
+    for (Target<Resource> target : targetArgumentCaptor.getAllValues()) {
       target.getSize(cb);
     }
     verify(cb, mode).onSizeReady(integerArgumentCaptor.capture(), integerArgumentCaptor.capture());
     return integerArgumentCaptor.getAllValues();
   }
 
+  // It's safe to ignore the return value of containsAllIn.
+  @SuppressWarnings("ResultOfMethodCallIgnored")
   @Test
   public void testItemsArePreloadedWithGlide() {
     final List<Object> objects = new ArrayList<>();
@@ -355,9 +359,9 @@ public void testItemsArePreloadedWithGlide() {
         return objects.subList(position - 11, position - 10);
       }
 
-      @NonNull
+      @Nullable
       @Override
-      public RequestBuilder<Object> getPreloadRequestBuilder(Object item) {
+      public RequestBuilder<Object> getPreloadRequestBuilder(@NonNull Object item) {
         loadedObjects.add(item);
         return super.getPreloadRequestBuilder(item);
       }
@@ -383,15 +387,16 @@ public ListPreloaderAdapter() {
       return result;
     }
 
-    @NonNull
+    @Nullable
     @Override
     @SuppressWarnings("unchecked")
-    public RequestBuilder<Object> getPreloadRequestBuilder(Object item) {
+    public RequestBuilder<Object> getPreloadRequestBuilder(@NonNull Object item) {
       return mock(RequestBuilder.class);
     }
 
+    @Nullable
     @Override
-    public int[] getPreloadSize(Object item, int adapterPosition, int itemPosition) {
+    public int[] getPreloadSize(@NonNull Object item, int adapterPosition, int itemPosition) {
       return new int[] { 100, 100 };
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java b/library/test/src/test/java/com/bumptech/glide/RequestBuilderTest.java
similarity index 82%
rename from library/src/test/java/com/bumptech/glide/RequestBuilderTest.java
rename to library/test/src/test/java/com/bumptech/glide/RequestBuilderTest.java
index 22bab0325..10a6bc568 100644
--- a/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/RequestBuilderTest.java
@@ -8,13 +8,16 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.app.Application;
 import android.widget.ImageView;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.Target;
-import com.bumptech.glide.tests.BackgroundUtil;
-import org.junit.After;
+import com.bumptech.glide.request.target.ViewTarget;
+import com.bumptech.glide.tests.BackgroundUtil.BackgroundTester;
+import com.bumptech.glide.tests.TearDownGlide;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
@@ -27,24 +30,23 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class RequestBuilderTest {
-  @Mock GlideContext glideContext;
-  @Mock RequestManager requestManager;
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+
+  @Mock private GlideContext glideContext;
+  @Mock private RequestManager requestManager;
   private Glide glide;
+  private Application context;
 
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
     glide = Glide.get(RuntimeEnvironment.application);
-  }
-
-  @After
-  public void tearDown() {
-    Glide.tearDown();
+    context = RuntimeEnvironment.application;
   }
 
   @Test(expected = NullPointerException.class)
   public void testThrowsIfContextIsNull() {
-    new RequestBuilder<>(null /*context*/, requestManager, Object.class);
+    new RequestBuilder<>(null /*context*/, requestManager, Object.class, context);
   }
 
   @Test(expected = NullPointerException.class)
@@ -91,11 +93,10 @@ public void testThrowsIfGivenNullView() {
   @Test(expected = RuntimeException.class)
   public void testThrowsIfIntoViewCalledOnBackgroundThread() throws InterruptedException {
     final ImageView imageView = new ImageView(RuntimeEnvironment.application);
-    testInBackground(new BackgroundUtil.BackgroundTester() {
+    testInBackground(new BackgroundTester() {
       @Override
-      public void runTest() throws Exception {
-        getNullModelRequest().into(imageView);
-
+      public void runTest() {
+       getNullModelRequest().into(imageView);
       }
     });
   }
@@ -103,23 +104,23 @@ public void runTest() throws Exception {
   @Test(expected = RuntimeException.class)
   public void testThrowsIfIntoTargetCalledOnBackgroundThread() throws InterruptedException {
     final Target<Object> target = mock(Target.class);
-    testInBackground(new BackgroundUtil.BackgroundTester() {
+    testInBackground(new BackgroundTester() {
       @Override
-      public void runTest() throws Exception {
-        getNullModelRequest().into(target);
+      public void runTest() {
+         getNullModelRequest().into(target);
       }
     });
   }
 
   private RequestBuilder<Object> getNullModelRequest() {
     when(glideContext.buildImageViewTarget(isA(ImageView.class), isA(Class.class)))
-        .thenReturn(mock(Target.class));
+        .thenReturn(mock(ViewTarget.class));
     when(glideContext.getDefaultRequestOptions()).thenReturn(new RequestOptions());
     when(requestManager.getDefaultRequestOptions())
         .thenReturn(new RequestOptions());
     when(requestManager.getDefaultTransitionOptions(any(Class.class)))
         .thenReturn(new GenericTransitionOptions<>());
-    return new RequestBuilder<>(glide, requestManager, Object.class)
+    return new RequestBuilder<>(glide, requestManager, Object.class, context)
         .load((Object) null);
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/RequestManagerTest.java b/library/test/src/test/java/com/bumptech/glide/RequestManagerTest.java
similarity index 53%
rename from library/src/test/java/com/bumptech/glide/RequestManagerTest.java
rename to library/test/src/test/java/com/bumptech/glide/RequestManagerTest.java
index 68551d56d..a7a73ccae 100644
--- a/library/src/test/java/com/bumptech/glide/RequestManagerTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/RequestManagerTest.java
@@ -10,16 +10,29 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.app.Application;
 import android.content.Context;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.manager.ConnectivityMonitor;
 import com.bumptech.glide.manager.ConnectivityMonitor.ConnectivityListener;
 import com.bumptech.glide.manager.ConnectivityMonitorFactory;
 import com.bumptech.glide.manager.Lifecycle;
 import com.bumptech.glide.manager.RequestManagerTreeNode;
 import com.bumptech.glide.manager.RequestTracker;
+import com.bumptech.glide.request.target.BaseTarget;
+import com.bumptech.glide.request.target.SizeReadyCallback;
+import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.tests.BackgroundUtil;
 import com.bumptech.glide.tests.GlideShadowLooper;
+import com.bumptech.glide.tests.TearDownGlide;
+import java.io.File;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
@@ -33,27 +46,51 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = GlideShadowLooper.class)
 public class RequestManagerTest {
-  @Mock Lifecycle lifecycle = mock(Lifecycle.class);
-  @Mock RequestManagerTreeNode treeNode = mock(RequestManagerTreeNode.class);
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+
+  @Mock private Lifecycle lifecycle = mock(Lifecycle.class);
+  @Mock private RequestManagerTreeNode treeNode = mock(RequestManagerTreeNode.class);
 
   private RequestManager manager;
   private ConnectivityMonitor connectivityMonitor;
   private RequestTracker requestTracker;
   private ConnectivityListener connectivityListener;
+  private Application context;
+  private BaseTarget<Drawable> target;
 
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
+    context = RuntimeEnvironment.application;
     connectivityMonitor = mock(ConnectivityMonitor.class);
     ConnectivityMonitorFactory factory = mock(ConnectivityMonitorFactory.class);
     when(factory.build(isA(Context.class), isA(ConnectivityMonitor.ConnectivityListener.class)))
         .thenAnswer(new Answer<ConnectivityMonitor>() {
           @Override
-          public ConnectivityMonitor answer(InvocationOnMock invocation) throws Throwable {
+          public ConnectivityMonitor answer(InvocationOnMock invocation) {
             connectivityListener = (ConnectivityListener) invocation.getArguments()[1];
             return connectivityMonitor;
           }
         });
+
+    target = new BaseTarget<Drawable>() {
+      @Override
+      public void onResourceReady(@NonNull Drawable resource,
+          @Nullable Transition<? super Drawable> transition) {
+        // Empty.
+      }
+
+      @Override
+      public void getSize(@NonNull SizeReadyCallback cb) {
+        // Empty.
+      }
+
+      @Override
+      public void removeCallback(@NonNull SizeReadyCallback cb) {
+        // Empty.
+      }
+    };
+
     requestTracker = mock(RequestTracker.class);
     manager =
         new RequestManager(
@@ -61,7 +98,8 @@ public ConnectivityMonitor answer(InvocationOnMock invocation) throws Throwable
             lifecycle,
             treeNode,
             requestTracker,
-            factory);
+            factory,
+            context);
   }
 
   @Test
@@ -128,7 +166,7 @@ public void testDoesNotRestartRequestsOnDisconnected() {
   public void testThrowsIfResumeCalledOnBackgroundThread() throws InterruptedException {
     testInBackground(new BackgroundUtil.BackgroundTester() {
       @Override
-      public void runTest() throws Exception {
+      public void runTest() {
         manager.resumeRequests();
       }
     });
@@ -138,7 +176,7 @@ public void runTest() throws Exception {
   public void testThrowsIfPauseCalledOnBackgroundThread() throws InterruptedException {
     testInBackground(new BackgroundUtil.BackgroundTester() {
       @Override
-      public void runTest() throws Exception {
+      public void runTest() {
         manager.pauseRequests();
       }
     });
@@ -151,4 +189,85 @@ public void testDelegatesIsPausedToRequestTracker() {
     when(requestTracker.isPaused()).thenReturn(false);
     assertFalse(manager.isPaused());
   }
+
+  @Test
+  public void clear_withRequestStartedInSiblingManager_doesNotThrow() {
+    final RequestManager child1 = new RequestManager(Glide.get(context), lifecycle,
+        new RequestManagerTreeNode() {
+          @NonNull
+          @Override
+          public Set<RequestManager> getDescendants() {
+            return Collections.emptySet();
+          }
+        }, context);
+    final RequestManager child2 = new RequestManager(Glide.get(context), lifecycle,
+        new RequestManagerTreeNode() {
+          @NonNull
+          @Override
+          public Set<RequestManager> getDescendants() {
+            return Collections.emptySet();
+          }
+        }, context);
+    new RequestManager(Glide.get(context), lifecycle,
+        new RequestManagerTreeNode() {
+          @NonNull
+          @Override
+          public Set<RequestManager> getDescendants() {
+            return new HashSet<>(java.util.Arrays.asList(child1, child2));
+          }
+        }, context);
+
+    File file = new File("fake");
+    child1.load(file).into(target);
+    child2.clear(target);
+  }
+
+  @Test
+  public void clear_withRequestStartedInChildManager_doesNotThrow() {
+    final RequestManager child = new RequestManager(Glide.get(context), lifecycle,
+        new RequestManagerTreeNode() {
+          @NonNull
+          @Override
+          public Set<RequestManager> getDescendants() {
+            return Collections.emptySet();
+          }
+        }, context);
+    RequestManager parent = new RequestManager(Glide.get(context), lifecycle,
+        new RequestManagerTreeNode() {
+          @NonNull
+          @Override
+          public Set<RequestManager> getDescendants() {
+            return Collections.singleton(child);
+          }
+        }, context);
+
+    File file = new File("fake");
+    child.load(file).into(target);
+    parent.clear(target);
+  }
+
+  @Test
+  public void clear_withRequestStartedInParentManager_doesNotThrow() {
+    final RequestManager child = new RequestManager(Glide.get(context), lifecycle,
+        new RequestManagerTreeNode() {
+          @NonNull
+          @Override
+          public Set<RequestManager> getDescendants() {
+            return Collections.emptySet();
+          }
+        }, context);
+    RequestManager parent = new RequestManager(Glide.get(context), lifecycle,
+        new RequestManagerTreeNode() {
+          @NonNull
+          @Override
+          public Set<RequestManager> getDescendants() {
+            return Collections.singleton(child);
+          }
+        }, context);
+
+    File file = new File("fake");
+
+    parent.load(file).into(target);
+    child.clear(target);
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java b/library/test/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java
similarity index 80%
rename from library/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java
index 9a23a4680..6f2fc9d50 100644
--- a/library/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java
@@ -14,11 +14,12 @@
 
 import android.app.Application;
 import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.KeyTester;
 import com.bumptech.glide.tests.Util;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -29,12 +30,13 @@
 @RunWith(JUnit4.class)
 @SuppressWarnings("unchecked")
 public class MultiTransformationTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
 
-  @Mock Transformation<Object> first;
-  @Mock Transformation<Object> second;
-  @Mock Resource<Object> initial;
-  @Mock Resource<Object> firstTransformed;
-  @Mock Resource<Object> secondTransformed;
+  @Mock private Transformation<Object> first;
+  @Mock private Transformation<Object> second;
+  @Mock private Resource<Object> initial;
+  @Mock private Resource<Object> firstTransformed;
+  @Mock private Resource<Object> secondTransformed;
   private Application context;
 
   @Before
@@ -42,6 +44,11 @@ public void setUp() {
     MockitoAnnotations.initMocks(this);
 
     context = RuntimeEnvironment.application;
+
+    doAnswer(new Util.WriteDigest("first")).when(first)
+        .updateDiskCacheKey(any(MessageDigest.class));
+    doAnswer(new Util.WriteDigest("second")).when(second)
+        .updateDiskCacheKey(any(MessageDigest.class));
   }
 
   @Test
@@ -123,13 +130,20 @@ public void testIntermediateResourcesAreRecycled() {
 
   @Test
   public void testEquals() throws NoSuchAlgorithmException {
-    doAnswer(new Util.WriteDigest("first")).when(first)
-        .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertSame(new MultiTransformation<>(first), new MultiTransformation<>(first));
+    keyTester
+        .addEquivalenceGroup(
+            new MultiTransformation<>(first),
+            new MultiTransformation<>(first))
+        .addEquivalenceGroup(new MultiTransformation<>(second))
+        .addEquivalenceGroup(new MultiTransformation<>(first, second))
+        .addEquivalenceGroup(new MultiTransformation<>(second, first))
+        .addRegressionTest(
+            new MultiTransformation<>(first),
+            "a7937b64b8caa58f03721bb6bacf5c78cb235febe0e70b1b84cd99541461a08e")
+        .addRegressionTest(
+            new MultiTransformation<>(first, second),
+            "da83f63e1a473003712c18f5afc5a79044221943d1083c7c5a7ac7236d85e8d2")
+        .test();
 
-    doAnswer(new Util.WriteDigest("second")).when(second)
-        .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertDifferent(
-        new MultiTransformation<>(first), new MultiTransformation<>(second));
   }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/OptionsTest.java b/library/test/src/test/java/com/bumptech/glide/load/OptionsTest.java
new file mode 100644
index 000000000..67ee5b193
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/OptionsTest.java
@@ -0,0 +1,78 @@
+package com.bumptech.glide.load;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.load.Option.CacheKeyUpdater;
+import com.bumptech.glide.tests.KeyTester;
+import java.nio.ByteBuffer;
+import java.security.MessageDigest;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class OptionsTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
+
+  @Test
+  public void testEquals() {
+    Option<Object> firstMemoryOption = Option.memory("firstKey");
+    Object firstValue = new Object();
+    Option<Object> secondMemoryOption = Option.memory("secondKey");
+    Object secondValue = new Object();
+
+    CacheKeyUpdater<Integer> updater = new CacheKeyUpdater<Integer>() {
+      @Override
+      public void update(@NonNull byte[] keyBytes, @NonNull Integer value,
+          @NonNull MessageDigest messageDigest) {
+        messageDigest.update(keyBytes);
+        messageDigest.update(ByteBuffer.allocate(4).putInt(value).array());
+
+      }
+    };
+    Option<Integer> firstDiskOption = Option.disk("firstDisk", updater);
+    Option<Integer> secondDiskOption = Option.disk("secondDisk", updater);
+
+    keyTester
+        .addEquivalenceGroup(new Options(), new Options())
+        .addEquivalenceGroup(
+            new Options().set(firstMemoryOption, firstValue),
+            new Options().set(firstMemoryOption, firstValue))
+        .addEquivalenceGroup(
+            new Options().set(secondMemoryOption, secondValue),
+            new Options().set(secondMemoryOption, secondValue))
+        .addEquivalenceGroup(
+            new Options().set(firstMemoryOption, firstValue).set(secondMemoryOption, secondValue),
+            new Options().set(firstMemoryOption, firstValue).set(secondMemoryOption, secondValue),
+            new Options().set(secondMemoryOption, secondValue).set(firstMemoryOption, firstValue))
+        .addEquivalenceGroup(
+            new Options().set(firstMemoryOption, secondValue))
+        .addEquivalenceGroup(
+            new Options().set(secondMemoryOption, firstValue))
+        .addEquivalenceGroup(
+            new Options().set(firstDiskOption, 1),
+            new Options().set(firstDiskOption, 1))
+        .addEquivalenceGroup(
+            new Options().set(secondDiskOption, 1),
+            new Options().set(secondDiskOption, 1))
+        .addEquivalenceGroup(
+            new Options().set(firstDiskOption, 2))
+        .addEquivalenceGroup(
+            new Options().set(secondDiskOption, 2))
+        .addEquivalenceGroup(
+            new Options().set(firstDiskOption, 1).set(secondDiskOption, 2),
+            new Options().set(secondDiskOption, 2).set(firstDiskOption, 1))
+        .addEmptyDigestRegressionTest(new Options().set(firstMemoryOption, firstValue))
+        .addEmptyDigestRegressionTest(
+            new Options().set(firstMemoryOption, firstValue).set(secondMemoryOption, secondValue))
+        .addRegressionTest(
+            new Options().set(firstDiskOption, 123),
+            "3c87124d1a765dc3d566f947d536ef140a4aca645c0947f702356714855b4a8e")
+        .addRegressionTest(
+            new Options().set(firstDiskOption, 123).set(secondDiskOption, 123),
+            "6697f654686c9a925905db3840e9c99944642c2b91d6200360d77639c1754d51")
+        .test();
+  }
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/load/data/BufferedOutputStreamFuzzTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/BufferedOutputStreamFuzzTest.java
new file mode 100644
index 000000000..21e6120a1
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/BufferedOutputStreamFuzzTest.java
@@ -0,0 +1,172 @@
+package com.bumptech.glide.load.data;
+
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.when;
+
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Random;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+
+/**
+ * Runs some tests based on a random seed that asserts the output of writing to our buffered stream
+ * matches the output of writing to {@link java.io.ByteArrayOutputStream}.
+ */
+@RunWith(JUnit4.class)
+public class BufferedOutputStreamFuzzTest {
+  private static final int TESTS = 500;
+  private static final int BUFFER_SIZE = 10;
+  private static final int WRITES_PER_TEST = 50;
+  private static final int MAX_BYTES_PER_WRITE = BUFFER_SIZE * 6;
+  private static final Random RANDOM = new Random(-3207167907493985134L);
+
+  @Mock private ArrayPool arrayPool;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
+    when(arrayPool.get(anyInt(), eq(byte[].class)))
+        .thenAnswer(new Answer<byte[]>() {
+          @Override
+          public byte[] answer(InvocationOnMock invocation) throws Throwable {
+            int size = (Integer) invocation.getArguments()[0];
+            return new byte[size];
+          }
+        });
+  }
+
+  @Test
+  public void runFuzzTest() throws IOException {
+    for (int i = 0; i < TESTS; i++) {
+      runTest(RANDOM);
+    }
+  }
+
+  private void runTest(Random random) throws IOException {
+    List<Write> writes = new ArrayList<>(WRITES_PER_TEST);
+    for (int i = 0; i < WRITES_PER_TEST; i++) {
+      WriteType writeType = getType(random);
+      writes.add(getWrite(random, writeType));
+    }
+
+    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
+
+    ByteArrayOutputStream wrapped = new ByteArrayOutputStream();
+    BufferedOutputStream bufferedOutputStream =
+        new BufferedOutputStream(wrapped, arrayPool, BUFFER_SIZE);
+
+    for (Write write : writes) {
+      switch (write.writeType) {
+        case BYTE:
+          byteArrayOutputStream.write(write.data[0]);
+          bufferedOutputStream.write(write.data[0]);
+          break;
+        case BUFFER:
+          byteArrayOutputStream.write(write.data);
+          bufferedOutputStream.write(write.data);
+          break;
+        case OFFSET_BUFFER:
+          byteArrayOutputStream.write(write.data, write.offset, write.length);
+          bufferedOutputStream.write(write.data, write.offset, write.length);
+          break;
+        default:
+            throw new IllegalArgumentException();
+      }
+    }
+
+    byte[] fromByteArrayStream = byteArrayOutputStream.toByteArray();
+    bufferedOutputStream.close();
+    byte[] fromWrappedStream = wrapped.toByteArray();
+    if (!Arrays.equals(fromWrappedStream, fromByteArrayStream)) {
+      StringBuilder writesBuilder = new StringBuilder();
+      for (Write write : writes) {
+        writesBuilder.append(write).append("\n");
+      }
+      fail("Expected: " + Arrays.toString(fromByteArrayStream) + "\n"
+          + "but got: " + Arrays.toString(fromWrappedStream) + "\n"
+          + writesBuilder.toString());
+    }
+  }
+
+  private Write getWrite(Random random, WriteType type) {
+    switch (type) {
+      case BYTE:
+        return getByteWrite(random);
+      case BUFFER:
+        return getBufferWrite(random);
+      case OFFSET_BUFFER:
+        return getOffsetBufferWrite(random);
+      default:
+        throw new IllegalArgumentException("Unrecognized type: " + type);
+    }
+  }
+
+  private Write getOffsetBufferWrite(Random random) {
+    int dataSize = random.nextInt(MAX_BYTES_PER_WRITE * 2);
+    byte[] data = new byte[dataSize];
+    int length = dataSize == 0 ? 0 : random.nextInt(dataSize);
+    int offset = dataSize - length <= 0 ? 0 : random.nextInt(dataSize - length);
+    random.nextBytes(data);
+    return new Write(data, length, offset, WriteType.OFFSET_BUFFER);
+  }
+
+  private Write getBufferWrite(Random random) {
+    byte[] data = new byte[random.nextInt(MAX_BYTES_PER_WRITE)];
+    random.nextBytes(data);
+    return new Write(data, /*length=*/ data.length, /*offset=*/ 0, WriteType.BUFFER);
+  }
+
+  private Write getByteWrite(Random random) {
+    byte[] data = new byte[1];
+    random.nextBytes(data);
+    return new Write(data, /*length=*/ 1, /*offset=*/ 0, WriteType.BYTE);
+  }
+
+  private WriteType getType(Random random) {
+    return WriteType.values()[random.nextInt(WriteType.values().length)];
+  }
+
+  private static final class Write {
+    private final byte[] data;
+    private final int length;
+    private final int offset;
+    private final WriteType writeType;
+
+    @Override
+    public String toString() {
+      return "Write{"
+          + "data=" + Arrays.toString(data)
+          + ", length=" + length
+          + ", offset=" + offset
+          + ", writeType=" + writeType
+          + '}';
+    }
+
+    Write(byte[] data, int length, int offset, WriteType writeType) {
+      this.data = data;
+      this.length = length;
+      this.offset = offset;
+      this.writeType = writeType;
+    }
+  }
+
+  private enum WriteType {
+    BYTE,
+    BUFFER,
+    OFFSET_BUFFER
+  }
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/load/data/BufferedOutputStreamTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/BufferedOutputStreamTest.java
new file mode 100644
index 000000000..ab32ce4a5
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/BufferedOutputStreamTest.java
@@ -0,0 +1,940 @@
+package com.bumptech.glide.load.data;
+
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertThrows;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.function.ThrowingRunnable;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(JUnit4.class)
+public class BufferedOutputStreamTest {
+  @Mock private ArrayPool arrayPool;
+  @Mock private OutputStream mockOutputStream;
+
+  private final int bufferSize = 10;
+  private final ByteArrayOutputStream inner = new ByteArrayOutputStream();
+  private int currentValue = 0;
+  private BufferedOutputStream os;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
+    when(arrayPool.get(bufferSize, byte[].class)).thenReturn(new byte[bufferSize]);
+    os = new BufferedOutputStream(inner, arrayPool, bufferSize);
+  }
+
+  @Test
+  public void constructor_obtainsBufferFromArrayPool() {
+    verify(arrayPool).get(bufferSize, byte[].class);
+  }
+
+  @Test
+  public void close_returnsBufferObtainedFromConstructor() throws IOException {
+    byte[] data = new byte[bufferSize];
+    when(arrayPool.get(bufferSize, byte[].class)).thenReturn(data);
+    os = new BufferedOutputStream(inner, arrayPool, bufferSize);
+
+    os.close();
+    verify(arrayPool).put(data);
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andSingleByte_doesNotWriteToStream() throws IOException {
+    os.write(next());
+
+    assertThat(inner.toByteArray()).isEmpty();
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andDataSmallerThanBuffer_doesNotWriteToStream()
+      throws IOException {
+    os.write(next(bufferSize - 1));
+
+    assertThat(inner.toByteArray()).isEmpty();
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andDataWithOffsetSizeSmallerThanBuffer_doesNotWriteToStream()
+    throws IOException {
+    int offset = 1;
+    int length = bufferSize - offset;
+    byte[] data = nextWithOffset(offset, length);
+    os.write(data, offset, length);
+
+    assertThat(inner.toByteArray()).isEmpty();
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andDataWithPaddingSizeSmallerThanBuffer_doesNotWriteToStream()
+    throws IOException {
+    int padding = 1;
+    int length = bufferSize - padding;
+    byte[] data = nextWithPadding(length, padding);
+    os.write(data, 0, length);
+
+    assertThat(inner.toByteArray()).isEmpty();
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andDataEqualToBufferSize_writesDataToStream()
+      throws IOException {
+    os.write(next(bufferSize));
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andDataGreaterThanBufferSize_writesDataToStream()
+      throws IOException {
+    os.write(next(bufferSize + 1));
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andDataWithOffsetAndLengthEqualToBufferSize_writesDataToStream()
+      throws IOException {
+    int offset = 5;
+    int length = bufferSize;
+    byte[] data = nextWithOffset(offset, length);
+    os.write(data, offset, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andDataWithPaddingAndLengthEqualToBufferSize_writesData()
+      throws IOException {
+    int padding = 5;
+    int length = bufferSize;
+    byte[] data = nextWithPadding(length, padding);
+    os.write(data, 0, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andDataWithOffsetAndLengthGreaterThanBuffer_writesDataToStream()
+      throws IOException {
+    int offset = 5;
+    int length = bufferSize + 1;
+    byte[] data = nextWithOffset(offset, length);
+    os.write(data, offset, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andDataWithPaddingAndLengthGreaterThanBuffer_writesData()
+      throws IOException {
+    int padding = 5;
+    int length = bufferSize + 1;
+    byte[] data = nextWithPadding(length, padding);
+    os.write(data, 0, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void writeSingleByte_whenBufferAlmostFull_writesBufferToStream() throws IOException {
+    for (int i = 0; i < bufferSize; i++) {
+      os.write(next());
+    }
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flush_withSingleByteInBuffer_writesBufferToStream() throws IOException {
+    os.write(next());
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flush_afterWritingByteAfterBufferFull_writesByteToStream() throws IOException {
+    for (int i = 0; i < bufferSize; i++) {
+      os.write(next());
+    }
+
+    os.write(next());
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flushAfterPreviousFlush_withSingleByte_writesOnlySingleByte() throws IOException {
+    os.write(next());
+    os.flush();
+    os.write(next());
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_withSingleByteInBuffer_writesBufferToStream() throws IOException {
+    os.write(next());
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWritingByteAfterBufferFull_writesByteToStream() throws IOException {
+    for (int i = 0; i < bufferSize; i++) {
+      os.write(next());
+    }
+
+    os.write(next());
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void closeAfterPreviousFlush_withSingleByte_writesOnlySingleByte() throws IOException {
+    os.write(next());
+    os.flush();
+    os.write(next());
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withDataInBuffer_bufferLessThanRemaining_doesNotWriteToStream()
+      throws IOException {
+    os.write(next());
+    os.write(next(remaining() - 1));
+
+    assertThat(inner.toByteArray()).isEmpty();
+  }
+
+  @Test
+  public void flush_afterWriteWithDataInBuffer_bufferLessThanRemaining_writesToStream()
+      throws IOException {
+    os.write(next());
+    byte[] data = next(remaining() - 1);
+
+    os.write(data);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteWithDataInBuffer_bufferLessThanRemaining_writesToStream()
+      throws IOException {
+    os.write(next());
+    byte[] data = next(remaining());
+
+    os.write(data);
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withBufferEqualToRemaining_lessThanLength_writesToStream() throws IOException {
+    os.write(next());
+    os.write(next(remaining()));
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flush_afterWriteBufferEqualToRemaining_doesNothing() throws IOException {
+    os.write(next());
+    os.write(next(remaining()));
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteBufferEqualToRemaining_doesNothing() throws IOException {
+    os.write(next());
+    os.write(next(remaining()));
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withOffsetBufferEqualToRemaining_lessThanLength_writesToStream()
+      throws IOException {
+    os.write(next());
+    int offset = 5;
+    int length = remaining();
+    os.write(nextWithOffset(offset, length), offset, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flush_afterWriteOffsetBufferEqualToRemaining_lessThanLength_writesToStream()
+      throws IOException {
+    os.write(next());
+    int offset = 5;
+    int length = remaining();
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteOffsetBufferEqualToRemaining_lessThanLength_writesToStream()
+      throws IOException {
+    os.write(next());
+    int offset = 5;
+    int length = remaining();
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withPaddedBufferEqualToRemaining_lessThanLength_writesToStream()
+      throws IOException {
+    os.write(next());
+    int padding = 5;
+    int length = remaining();
+    os.write(nextWithPadding(length, padding), 0, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flush_afterWritePaddedBufferEqualToRemaining_lessThanLength_writesToStream()
+      throws IOException {
+    os.write(next());
+    int padding = 5;
+    int length = remaining();
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWritePaddedBufferEqualToRemaining_lessThanLength_writesToStream()
+      throws IOException {
+    os.write(next());
+    int padding = 5;
+    int length = remaining();
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withBufferGreaterThanRemaining_lessThanLength_writesUpToBufferToStream()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize - 1));
+
+    assertThat(inner.toByteArray()).isEqualTo(upTo(bufferSize));
+  }
+
+  @Test
+  public void flush_afterWriteBufferGreaterThanRemaining_lessThanLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize - 1));
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteBufferGreaterThanRemaining_lessThanLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize - 1));
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withOffsetBufferGreaterThanRemaining_lessThanLength_writesUpToBuffer()
+      throws IOException {
+    os.write(next(2));
+    int offset = 5;
+    int length = bufferSize - 1;
+    os.write(nextWithOffset(offset, length), offset, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(upTo(bufferSize));
+  }
+
+  @Test
+  public void flush_afterWriteOffsetBufferGreaterThanRemaining_lessThanLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int offset = 5;
+    int length = bufferSize - 1;
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteOffsetBufferGreaterThanRemaining_lessThanLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int offset = 5;
+    int length = bufferSize - 1;
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withPaddedBufferGreaterThanRemaining_lessThanLength_writesUpToBuffer()
+      throws IOException {
+    os.write(next(2));
+    int padding = 5;
+    int length = bufferSize - 1;
+    os.write(nextWithPadding(length, padding), 0, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(upTo(bufferSize));
+  }
+
+  @Test
+  public void flush_afterWritePaddedBufferGreaterThanRemaining_lessThanLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int padding = 5;
+    int length = bufferSize - 1;
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWritePaddedBufferGreaterThanRemaining_lessThanLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int padding = 5;
+    int length = bufferSize - 1;
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withBufferGreaterThanRemaining_equalToLength_writesUpToBufferToStream()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize));
+
+    assertThat(inner.toByteArray()).isEqualTo(upTo(bufferSize));
+  }
+
+  @Test
+  public void flush_afterWriteBufferGreaterThanRemaining_equalToLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize));
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteBufferGreaterThanRemaining_equalToLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize));
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withOffsetBufferGreaterThanRemaining_equalToLength_writesUpToBufferToStream()
+      throws IOException {
+    os.write(next(2));
+    int offset = 6;
+    int length = bufferSize;
+    os.write(nextWithOffset(offset, length), offset, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(upTo(bufferSize));
+  }
+
+  @Test
+  public void flush_afterWriteOffsetBufferGreaterThanRemaining_equalToLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int offset = 6;
+    int length = bufferSize;
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteOffsetBufferGreaterThanRemaining_equalToLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int offset = 6;
+    int length = bufferSize;
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withPaddedBufferGreaterThanRemaining_equalToLength_writesUpToBufferToStream()
+      throws IOException {
+    os.write(next(2));
+    int padding = 6;
+    int length = bufferSize;
+    os.write(nextWithPadding(length, padding), 0, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(upTo(bufferSize));
+  }
+
+  @Test
+  public void flush_afterWritePaddedBufferGreaterThanRemaining_equalToLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int padding = 6;
+    int length = bufferSize;
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWritePaddedBufferGreaterThanRemaining_equalToLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int padding = 6;
+    int length = bufferSize;
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withBufferGreaterThanRemaining_greaterThanLength_writesUpToBufferToStream()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize + 1));
+
+    assertThat(inner.toByteArray()).isEqualTo(upTo(bufferSize));
+  }
+
+  @Test
+  public void flush_afterWriteBufferGreaterThanRemaining_greaterThanLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize + 1));
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteBufferGreaterThanRemaining_greaterThanLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize + 1));
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withOffsetBufferGreaterThanRemaining_greaterThanLength_writesUpToBuffer()
+      throws IOException {
+    os.write(next(2));
+    int offset = 2;
+    int length = bufferSize + 1;
+    os.write(nextWithOffset(offset, length), offset, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(upTo(bufferSize));
+  }
+
+  @Test
+  public void flush_afterWriteOffsetBufferGreaterThanRemaining_greaterThanLength_writesAllToStream()
+      throws IOException {
+    os.write(next(2));
+    int offset = 2;
+    int length = bufferSize + 1;
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteOffsetBufferGreaterThanRemaining_greaterThanLength_writesAllToStream()
+      throws IOException {
+    os.write(next(2));
+    int offset = 2;
+    int length = bufferSize + 1;
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withPaddedBufferGreaterThanRemaining_greaterThanLength_writesUpToBuffer()
+      throws IOException {
+    os.write(next(2));
+    int padding = 2;
+    int length = bufferSize + 1;
+    os.write(nextWithPadding(length, padding), 0, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(upTo(bufferSize));
+  }
+
+  @Test
+  public void flush_afterWritePaddedBufferGreaterThanRemaining_greaterThanLength_writesAllToStream()
+      throws IOException {
+    os.write(next(2));
+    int padding = 2;
+    int length = bufferSize + 1;
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWritePaddedBufferGreaterThanRemaining_greaterThanLength_writesAllToStream()
+      throws IOException {
+    os.write(next(2));
+    int padding = 2;
+    int length = bufferSize + 1;
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withBufferMoreThanRemains_greaterThanTwiceLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize * 2 + 1));
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flush_afterWriteBufferMoreThanRemains_greaterThanTwiceLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize * 2 + 1));
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteBufferMoreThanRemains_greaterThanTwiceLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize * 2 + 1));
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withOffsetBufferMoreThanRemains_greaterThanTwiceLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int offset = bufferSize + 1;
+    int length = bufferSize * 2 + 2;
+    os.write(nextWithOffset(offset, length), offset, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flush_afterWriteOffsetBufferMoreThanRemains_greaterThanTwiceLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int offset = bufferSize + 1;
+    int length = bufferSize * 2 + 2;
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteOffsetBufferMoreThanRemains_greaterThanTwiceLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int offset = bufferSize + 1;
+    int length = bufferSize * 2 + 2;
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withPaddedBufferMoreThanRemains_greaterThanTwiceLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int padding = bufferSize + 1;
+    int length = bufferSize * 2 + 2;
+    os.write(nextWithPadding(length, padding), 0, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flush_afterWritePaddedBufferMoreThanRemains_greaterThanTwiceLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int padding = bufferSize + 1;
+    int length = bufferSize * 2 + 2;
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWritePaddedBufferMoreThanRemains_greaterThanTwiceLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int padding = bufferSize + 1;
+    int length = bufferSize * 2 + 2;
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flush_flushesUnderlyingStream() throws IOException {
+    os = new BufferedOutputStream(mockOutputStream, arrayPool, bufferSize);
+    os.flush();
+
+    verify(mockOutputStream).flush();
+  }
+
+  @Test
+  public void overflowBuffer_doesNotFlushUnderlyingStream() throws IOException {
+    os = new BufferedOutputStream(mockOutputStream, arrayPool, bufferSize);
+    os.write(1);
+    os.write(next(remaining() + 1));
+
+    verify(mockOutputStream, never()).flush();
+  }
+
+  @Test
+  public void close_closesUnderlyingStream() throws IOException {
+    os = new BufferedOutputStream(mockOutputStream, arrayPool, bufferSize);
+    os.close();
+
+    verify(mockOutputStream).close();
+  }
+
+  @Test
+  public void close_whenUnderlyingStreamThrows_closesStream() throws IOException {
+    os = new BufferedOutputStream(mockOutputStream, arrayPool, bufferSize);
+    doThrow(new IOException()).when(mockOutputStream).write(any(byte[].class), anyInt(), anyInt());
+
+    os.write(1);
+    try {
+      os.close();
+      fail("Failed to receive expected exception");
+    } catch (IOException e) {
+      // Expected.
+    }
+
+    verify(mockOutputStream).close();
+  }
+
+  @Test
+  public void flush_withZeroBytesWritten_doesNotWriteToStream() throws IOException {
+    os = new BufferedOutputStream(mockOutputStream, arrayPool, bufferSize);
+    os.flush();
+
+    verify(mockOutputStream, never()).write(anyInt());
+    verify(mockOutputStream, never()).write(any(byte[].class));
+    verify(mockOutputStream, never()).write(any(byte[].class), anyInt(), anyInt());
+  }
+
+  @Test
+  public void write_throwsIfOffsetIsLessThanZero() {
+    assertThrows(IndexOutOfBoundsException.class, new ThrowingRunnable() {
+      @Override
+      public void run() throws Throwable {
+        os.write(new byte[0], /*initialOffset=*/ -1, /*length=*/ 0);
+      }
+    });
+  }
+
+  @Test
+  public void write_throwsIfLengthIsLessThanZero() {
+    assertThrows(IndexOutOfBoundsException.class, new ThrowingRunnable() {
+      @Override
+      public void run() throws Throwable {
+        os.write(new byte[0], /*initialOffset=*/ 0, /*length=*/ -1);
+      }
+    });
+  }
+
+  @Test
+  public void write_throwsIfOffsetIsGreaterThanLength() {
+    assertThrows(IndexOutOfBoundsException.class, new ThrowingRunnable() {
+      @Override
+      public void run() throws Throwable {
+        os.write(new byte[0], /*initialOffset=*/ 1, /*length=*/ 0);
+      }
+    });
+  }
+
+  @Test
+  public void write_throwsIfLengthsIsGreaterThanLength() {
+    assertThrows(IndexOutOfBoundsException.class, new ThrowingRunnable() {
+      @Override
+      public void run() throws Throwable {
+        os.write(new byte[0], /*initialOffset=*/ 0, /*length=*/ 1);
+      }
+    });
+  }
+
+
+  @Test
+  public void write_throwsIfLengthAndOffsetsIsGreaterThanLength() {
+    assertThrows(IndexOutOfBoundsException.class, new ThrowingRunnable() {
+      @Override
+      public void run() throws Throwable {
+        os.write(new byte[1], /*initialOffset=*/ 1, /*length=*/ 1);
+      }
+    });
+  }
+
+  @Test
+  public void write_withZeroLengthBuffer_doesNothing() throws IOException {
+    os.write(new byte[0]);
+
+    assertThat(inner.toByteArray()).hasLength(0);
+  }
+
+  @Test
+  public void write_withZeroLengthBufferAndZeroOffsetAndLength_doesNothing() throws IOException {
+    os.write(new byte[0], 0, 0);
+
+    assertThat(inner.toByteArray()).hasLength(0);
+  }
+
+
+  @Test
+  public void write_afterWriteWithZeroLengthBuffer_writesExpected() throws IOException {
+    os.write(new byte[0]);
+    os.write(next());
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_afterWriteZeroLengthBufferAndZeroOffsetAndLength_writesExpected()
+      throws IOException {
+    os.write(new byte[0], 0, 0);
+    os.write(next());
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  private int soFar() {
+    return currentValue;
+  }
+
+  private int remaining() {
+    return bufferSize - soFar();
+  }
+
+  private int next() {
+    return nextWithOffset(0, 1)[0];
+  }
+
+  private byte[] next(int count) {
+    return nextWithOffset(0, count);
+  }
+
+  private byte[] nextWithPadding(int count, int padding) {
+    byte[] result = new byte[count + padding];
+    for (int i = 0; i < count; i++) {
+      result[i] = (byte) ++currentValue;
+    }
+    for (int i = count; i < count + padding; i++) {
+      result[i] = (byte) (i + currentValue);
+    }
+    return result;
+  }
+
+  private byte[] nextWithOffset(int offset, int count) {
+    byte[] result = new byte[offset + count];
+    for (int i = offset - 1; i >= 0; i--) {
+      result[i] = (byte) -offset;
+    }
+    for (int i = offset; i < offset + count; i++) {
+      result[i] = (byte) ++currentValue;
+    }
+    return result;
+  }
+
+  private byte[] upTo(int size) {
+    assertThat(size).isLessThan(currentValue);
+    byte[] result = new byte[size];
+    for (int i = 0; i < size; i++) {
+      result[i] = (byte) (i + 1);
+    }
+    return result;
+  }
+
+  private byte[] all() {
+    byte[] result = new byte[currentValue];
+    for (int i = 0; i < currentValue; i++) {
+      result[i] = (byte) (i + 1);
+    }
+    return result;
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
diff --git a/library/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java
similarity index 90%
rename from library/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java
index ae3982203..ef1bad28b 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java
@@ -23,18 +23,17 @@
 @Config(manifest = Config.NONE, sdk = 18)
 public class FileDescriptorAssetPathFetcherTest {
 
-  @Mock AssetManager assetManager;
-  @Mock AssetFileDescriptor assetFileDescriptor;
-  @Mock DataFetcher.DataCallback<ParcelFileDescriptor> callback;
+  @Mock private AssetManager assetManager;
+  @Mock private AssetFileDescriptor assetFileDescriptor;
+  @Mock private DataFetcher.DataCallback<ParcelFileDescriptor> callback;
 
   private FileDescriptorAssetPathFetcher fetcher;
   private ParcelFileDescriptor expected;
-  private String assetPath;
 
   @Before
   public void setUp() throws IOException {
     MockitoAnnotations.initMocks(this);
-    assetPath = "/some/asset/path";
+    String assetPath = "/some/asset/path";
     fetcher = new FileDescriptorAssetPathFetcher(assetManager, assetPath);
     expected = mock(ParcelFileDescriptor.class);
     when(assetFileDescriptor.getParcelFileDescriptor()).thenReturn(expected);
diff --git a/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
similarity index 90%
rename from library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
index 94fd216bf..044bf30e8 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
@@ -41,7 +41,7 @@
   private static final String DEFAULT_PATH = "/fakepath";
   private static final int TIMEOUT_TIME_MS = 300;
 
-  @Mock DataFetcher.DataCallback<InputStream> callback;
+  @Mock private DataFetcher.DataCallback<InputStream> callback;
 
   private MockWebServer mockWebServer;
   private boolean defaultFollowRedirects;
@@ -72,6 +72,7 @@ public void testReturnsInputStreamOnStatusOk() throws Exception {
     fetcher.loadData(Priority.HIGH, callback);
     verify(callback).onDataReady(streamCaptor.capture());
     TestUtil.assertStreamOf(expected, streamCaptor.getValue());
+    assertThat(mockWebServer.takeRequest().getMethod()).isEqualTo("GET");
   }
 
   @Test
@@ -83,6 +84,8 @@ public void testHandlesRedirect301s() throws Exception {
     getFetcher().loadData(Priority.LOW, callback);
     verify(callback).onDataReady(streamCaptor.capture());
     TestUtil.assertStreamOf(expected, streamCaptor.getValue());
+    assertThat(mockWebServer.takeRequest().getMethod()).isEqualTo("GET");
+    assertThat(mockWebServer.takeRequest().getMethod()).isEqualTo("GET");
   }
 
   @Test
@@ -94,6 +97,8 @@ public void testHandlesRedirect302s() throws Exception {
     getFetcher().loadData(Priority.LOW, callback);
     verify(callback).onDataReady(streamCaptor.capture());
     TestUtil.assertStreamOf(expected, streamCaptor.getValue());
+    assertThat(mockWebServer.takeRequest().getMethod()).isEqualTo("GET");
+    assertThat(mockWebServer.takeRequest().getMethod()).isEqualTo("GET");
   }
 
   @Test
@@ -106,9 +111,11 @@ public void testHandlesRelativeRedirects() throws Exception {
     verify(callback).onDataReady(streamCaptor.capture());
     TestUtil.assertStreamOf(expected, streamCaptor.getValue());
 
-    mockWebServer.takeRequest();
+    RecordedRequest first = mockWebServer.takeRequest();
+    assertThat(first.getMethod()).isEqualTo("GET");
     RecordedRequest second = mockWebServer.takeRequest();
     assertThat(second.getPath()).endsWith("/redirect");
+    assertThat(second.getMethod()).isEqualTo("GET");
   }
 
   @Test
@@ -126,9 +133,13 @@ public void testHandlesUpToFiveRedirects() throws Exception {
     verify(callback).onDataReady(streamCaptor.capture());
     TestUtil.assertStreamOf(expected, streamCaptor.getValue());
 
-    assertThat(mockWebServer.takeRequest().getPath()).contains(DEFAULT_PATH);
+    RecordedRequest request = mockWebServer.takeRequest();
+    assertThat(request.getPath()).contains(DEFAULT_PATH);
+    assertThat(request.getMethod()).isEqualTo("GET");
     for (int i = 0; i < numRedirects; i++) {
-      assertThat(mockWebServer.takeRequest().getPath()).contains(redirectBase + i);
+      RecordedRequest current = mockWebServer.takeRequest();
+      assertThat(current.getPath()).contains(redirectBase + i);
+      assertThat(current.getMethod()).isEqualTo("GET");
     }
   }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
similarity index 92%
rename from library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
index 7ad707409..9cd87e418 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
@@ -26,11 +26,11 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class HttpUrlFetcherTest {
-  @Mock HttpURLConnection urlConnection;
-  @Mock HttpUrlFetcher.HttpUrlConnectionFactory connectionFactory;
-  @Mock GlideUrl glideUrl;
-  @Mock InputStream stream;
-  @Mock DataFetcher.DataCallback<InputStream> callback;
+  @Mock private HttpURLConnection urlConnection;
+  @Mock private HttpUrlFetcher.HttpUrlConnectionFactory connectionFactory;
+  @Mock private GlideUrl glideUrl;
+  @Mock private InputStream stream;
+  @Mock private DataFetcher.DataCallback<InputStream> callback;
 
   private static final int TIMEOUT_MS = 100;
   private HttpUrlFetcher fetcher;
diff --git a/library/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
similarity index 95%
rename from library/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
index c3d818ffc..9ca7a2924 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
@@ -26,7 +26,7 @@
 @Config(manifest = Config.NONE, sdk = 18)
 public class LocalUriFetcherTest {
   private TestLocalUriFetcher fetcher;
-  @Mock DataFetcher.DataCallback<Closeable> callback;
+  @Mock private DataFetcher.DataCallback<Closeable> callback;
 
   @Before
   public void setUp() {
@@ -61,7 +61,7 @@ public void testHandlesExceptionOnClose() throws Exception {
   private static class TestLocalUriFetcher extends LocalUriFetcher<Closeable> {
     final Closeable closeable = mock(Closeable.class);
 
-    public TestLocalUriFetcher(Context context, Uri uri) {
+    TestLocalUriFetcher(Context context, Uri uri) {
       super(context.getContentResolver(), uri);
     }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java
similarity index 89%
rename from library/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java
index 5b03e0f83..fb7e125ac 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java
@@ -20,17 +20,16 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class StreamAssetPathFetcherTest {
-  @Mock AssetManager assetManager;
-  @Mock InputStream expected;
-  @Mock DataFetcher.DataCallback<InputStream> callback;
+  @Mock private AssetManager assetManager;
+  @Mock private InputStream expected;
+  @Mock private DataFetcher.DataCallback<InputStream> callback;
 
   private StreamAssetPathFetcher fetcher;
-  private String assetPath;
 
   @Before
   public void setUp() throws IOException {
     MockitoAnnotations.initMocks(this);
-    assetPath = "/some/asset/path";
+    String assetPath = "/some/asset/path";
     fetcher = new StreamAssetPathFetcher(assetManager, assetPath);
     when(assetManager.open(eq(assetPath))).thenReturn(expected);
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java
similarity index 91%
rename from library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java
index 4ceec4c8f..0b59d74b1 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java
@@ -22,9 +22,9 @@
 @Config(manifest = Config.NONE, sdk = 18)
 public class ThumbFetcherTest {
 
-  @Mock ThumbnailStreamOpener opener;
-  @Mock DataFetcher.DataCallback<InputStream> callback;
-  @Mock InputStream expected;
+  @Mock private ThumbnailStreamOpener opener;
+  @Mock private DataFetcher.DataCallback<InputStream> callback;
+  @Mock private InputStream expected;
 
   private ThumbFetcher fetcher;
   private Uri uri;
diff --git a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
similarity index 92%
rename from library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
index 50535836c..7c25a0580 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
@@ -116,12 +116,12 @@ private static ContentResolver getContentResolver() {
   }
 
   private static class Harness {
-    MatrixCursor cursor = new MatrixCursor(new String[1]);
-    File file = new File("fake/uri");
-    Uri uri = Uri.fromFile(file);
-    ThumbnailQuery query = mock(ThumbnailQuery.class);
-    FileService service = mock(FileService.class);
-    ArrayPool byteArrayPool = new LruArrayPool();
+    final MatrixCursor cursor = new MatrixCursor(new String[1]);
+    final File file = new File("fake/uri");
+    final Uri uri = Uri.fromFile(file);
+    final ThumbnailQuery query = mock(ThumbnailQuery.class);
+    final FileService service = mock(FileService.class);
+    final ArrayPool byteArrayPool = new LruArrayPool();
 
     public Harness() {
       cursor.addRow(new String[] { file.getAbsolutePath() });
@@ -132,7 +132,7 @@ public Harness() {
     }
 
     public ThumbnailStreamOpener get() {
-      List<ImageHeaderParser> parsers = new ArrayList<ImageHeaderParser>();
+      List<ImageHeaderParser> parsers = new ArrayList<>();
       parsers.add(new DefaultImageHeaderParser());
       return new ThumbnailStreamOpener(
           parsers, service, query, byteArrayPool, getContentResolver());
diff --git a/library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
similarity index 91%
rename from library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
index 81687fa35..b4f8e7721 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
@@ -30,7 +30,8 @@
 @Config(manifest = Config.NONE, sdk = 18, shadows = { ContentResolverShadow.class })
 public class FileDescriptorLocalUriFetcherTest {
 
-  @Mock DataFetcher.DataCallback<ParcelFileDescriptor> callback;
+  @Mock
+  private DataFetcher.DataCallback<ParcelFileDescriptor> callback;
 
   @Before
   public void setUp() {
@@ -43,7 +44,7 @@ public void testLoadResource_returnsFileDescriptor() throws Exception {
     Uri uri = Uri.parse("file://nothing");
 
     ContentResolver contentResolver = context.getContentResolver();
-    ContentResolverShadow shadow = (ContentResolverShadow) Shadow.extract(contentResolver);
+    ContentResolverShadow shadow = Shadow.extract(contentResolver);
 
     AssetFileDescriptor assetFileDescriptor = mock(AssetFileDescriptor.class);
     ParcelFileDescriptor parcelFileDescriptor = mock(ParcelFileDescriptor.class);
@@ -62,7 +63,7 @@ public void testLoadResource_withNullFileDescriptor_callsLoadFailed() {
     Uri uri = Uri.parse("file://nothing");
 
     ContentResolver contentResolver = context.getContentResolver();
-    ContentResolverShadow shadow = (ContentResolverShadow) Shadow.extract(contentResolver);
+    ContentResolverShadow shadow = Shadow.extract(contentResolver);
     shadow.registerFileDescriptor(uri, null /*fileDescriptor*/);
 
     FileDescriptorLocalUriFetcher fetcher =
diff --git a/library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
similarity index 90%
rename from library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
index a7fb2d580..a1d83a5f6 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
@@ -27,7 +27,8 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = { ContentResolverShadow.class })
 public class StreamLocalUriFetcherTest {
-  @Mock DataFetcher.DataCallback<InputStream> callback;
+  @Mock
+  private DataFetcher.DataCallback<InputStream> callback;
 
   @Before
   public void setUp() {
@@ -40,7 +41,7 @@ public void testLoadResource_returnsInputStream() throws Exception {
     Uri uri = Uri.parse("file://nothing");
 
     ContentResolver contentResolver = context.getContentResolver();
-    ContentResolverShadow shadow = (ContentResolverShadow) Shadow.extract(contentResolver);
+    ContentResolverShadow shadow = Shadow.extract(contentResolver);
     shadow.registerInputStream(uri, new ByteArrayInputStream(new byte[0]));
 
     StreamLocalUriFetcher fetcher = new StreamLocalUriFetcher(context.getContentResolver(), uri);
@@ -54,7 +55,7 @@ public void testLoadResource_withNullInputStream_callsLoadFailed() {
     Uri uri = Uri.parse("file://nothing");
 
     ContentResolver contentResolver = context.getContentResolver();
-    ContentResolverShadow shadow = (ContentResolverShadow) Shadow.extract(contentResolver);
+    ContentResolverShadow shadow = Shadow.extract(contentResolver);
 
     shadow.registerInputStream(uri, null /*inputStream*/);
 
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/ActiveResourcesTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/ActiveResourcesTest.java
new file mode 100644
index 000000000..288ac29d5
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/ActiveResourcesTest.java
@@ -0,0 +1,395 @@
+package com.bumptech.glide.load.engine;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.verify;
+
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.engine.ActiveResources.DequeuedResourceCallback;
+import com.bumptech.glide.load.engine.ActiveResources.ResourceWeakReference;
+import com.bumptech.glide.load.engine.EngineResource.ResourceListener;
+import com.bumptech.glide.tests.GlideShadowLooper;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLooper;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(shadows = GlideShadowLooper.class)
+public class ActiveResourcesTest {
+
+  @Mock private ResourceListener listener;
+  @Mock private Key key;
+  @Mock private Resource<Object> resource;
+
+  private ActiveResources resources;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    resources = new ActiveResources(/*isActiveResourceRetentionAllowed=*/ true);
+    resources.setListener(listener);
+
+    reset(GlideShadowLooper.queue);
+  }
+
+  @After
+  public void tearDown() {
+    resources.shutdown();
+  }
+
+  @Test
+  public void get_withMissingKey_returnsNull() {
+    assertThat(resources.get(key)).isNull();
+  }
+
+  @Test
+  public void get_withActiveKey_returnsResource() {
+    EngineResource<Object> expected =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, expected);
+    assertThat(resources.get(key)).isEqualTo(expected);
+  }
+
+  @Test
+  public void get_withDeactivatedKey_returnsNull() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+    resources.deactivate(key);
+    assertThat(resources.get(key)).isNull();
+  }
+
+  @Test
+  public void deactivate_withNotActiveKey_doesNotThrow() {
+    resources.deactivate(key);
+  }
+
+  @Test
+  public void get_withActiveAndClearedKey_returnsNull() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+    resources.activeEngineResources.get(key).clear();
+    assertThat(resources.get(key)).isNull();
+  }
+
+  @Test
+  public void get_withActiveAndClearedKey_andCacheableResource_callsListenerWithWrappedResource() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+    resources.activeEngineResources.get(key).clear();
+    resources.get(key);
+
+    ArgumentCaptor<EngineResource<?>> captor = getEngineResourceCaptor();
+
+    verify(listener).onResourceReleased(eq(key), captor.capture());
+
+    assertThat(captor.getValue().getResource()).isEqualTo(resource);
+  }
+
+  @Test
+  public void get_withActiveAndClearedKey_andCacheableResource_callsListenerWithNotRecycleable() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+    resources.activeEngineResources.get(key).clear();
+    resources.get(key);
+
+    ArgumentCaptor<EngineResource<?>> captor = getEngineResourceCaptor();
+
+    verify(listener).onResourceReleased(eq(key), captor.capture());
+
+    captor.getValue().recycle();
+    verify(resource, never()).recycle();
+  }
+
+  @Test
+  public void get_withActiveAndClearedKey_andCacheableResource_callsListenerWithCacheable() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+    resources.activeEngineResources.get(key).clear();
+    resources.get(key);
+
+    ArgumentCaptor<EngineResource<?>> captor = getEngineResourceCaptor();
+
+    verify(listener).onResourceReleased(eq(key), captor.capture());
+
+    assertThat(captor.getValue().isCacheable()).isTrue();
+  }
+
+  @Test
+  public void get_withActiveAndClearedKey_andNotCacheableResource_doesNotCallListener() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ false, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+    resources.activeEngineResources.get(key).clear();
+    resources.get(key);
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  @Test
+  public void queueIdle_afterResourceRemovedFromActive_doesNotCallListener() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    resources.deactivate(key);
+
+    enqueueAndWaitForRef(weakRef);
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  @Test
+  public void queueIdle_withCacheableResourceInActive_callListener() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    enqueueAndWaitForRef(weakRef);
+
+    ArgumentCaptor<EngineResource<?>> captor = getEngineResourceCaptor();
+
+    verify(listener).onResourceReleased(eq(key), captor.capture());
+
+    EngineResource<?> released = captor.getValue();
+    assertThat(released.getResource()).isEqualTo(resource);
+    assertThat(released.isCacheable()).isTrue();
+
+    released.recycle();
+    verify(resource, never()).recycle();
+  }
+
+  @Test
+  public void queueIdle_withNotCacheableResourceInActive_doesNotCallListener() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ false, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    weakRef.enqueue();
+    enqueueAndWaitForRef(weakRef);
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  @Test
+  public void queueIdle_withCacheableResourceInActive_removesResourceFromActive()
+      throws InterruptedException {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    enqueueAndWaitForRef(weakRef);
+
+    assertThat(resources.get(key)).isNull();
+  }
+
+  @Test
+  public void queueIdle_withNotCacheableResourceInActive_removesResourceFromActive() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ false, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    enqueueAndWaitForRef(weakRef);
+
+    assertThat(resources.get(key)).isNull();
+  }
+
+  @Test
+  public void get_withQueuedReference_returnsResource() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    weakRef.enqueue();
+
+    assertThat(resources.get(key)).isEqualTo(engineResource);
+  }
+
+  @Test
+  public void get_withQueuedReference_doesNotNotifyListener() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    weakRef.enqueue();
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  @Test
+  public void queueIdle_withQueuedReferenceRetrievedFromGet_notifiesListener() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+
+    resources.get(key);
+
+    enqueueAndWaitForRef(weakRef);
+
+    ArgumentCaptor<EngineResource<?>> captor = getEngineResourceCaptor();
+    verify(listener).onResourceReleased(eq(key), captor.capture());
+    assertThat(captor.getValue().getResource()).isEqualTo(resource);
+  }
+
+  @Test
+  public void queueIdle_withQueuedReferenceRetrievedFromGetAndNotCacheable_doesNotNotifyListener() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ false, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    CountDownLatch latch = getLatchForClearedRef();
+    weakRef.enqueue();
+
+    resources.get(key);
+
+    waitForLatch(latch);
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  @Test
+  public void queueIdle_withQueuedReferenceDeactivated_doesNotNotifyListener() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    CountDownLatch latch = getLatchForClearedRef();
+    weakRef.enqueue();
+
+    resources.deactivate(key);
+
+    waitForLatch(latch);
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  @Test
+  public void queueIdle_afterReferenceQueuedThenReactivated_doesNotNotifyListener() {
+    EngineResource<Object> first =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, first);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    CountDownLatch latch = getLatchForClearedRef();
+    weakRef.enqueue();
+
+    EngineResource<Object> second =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, second);
+
+    waitForLatch(latch);
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  @Test
+  public void activate_withNonCacheableResource_doesNotSaveResource() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ false, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    assertThat(resources.activeEngineResources.get(key).resource).isNull();
+  }
+
+  @Test
+  public void get_withActiveClearedKey_cacheableResource_retentionDisabled_doesNotCallListener() {
+    resources = new ActiveResources(/*isActiveResourceRetentionAllowed=*/ false);
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+    resources.activeEngineResources.get(key).clear();
+    resources.get(key);
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  @Test
+  public void get_withQueuedReference_retentionDisabled_returnsResource() {
+    resources = new ActiveResources(/*isActiveResourceRetentionAllowed=*/ false);
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    weakRef.enqueue();
+
+    assertThat(resources.get(key)).isEqualTo(engineResource);
+  }
+
+  @Test
+  public void queueIdle_withQueuedReferenceRetrievedFromGet_retentionDisabled_doesNotNotify() {
+    resources = new ActiveResources(/*isActiveResourceRetentionAllowed=*/ false);
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    CountDownLatch latch = getLatchForClearedRef();
+    weakRef.enqueue();
+
+    resources.get(key);
+
+    waitForLatch(latch);
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  private void enqueueAndWaitForRef(ResourceWeakReference ref) {
+    CountDownLatch latch = getLatchForClearedRef();
+    ref.enqueue();
+    waitForLatch(latch);
+  }
+
+  private void waitForLatch(CountDownLatch latch) {
+     try {
+      latch.await(10, TimeUnit.SECONDS);
+    } catch (InterruptedException e) {
+      throw new RuntimeException(e);
+    }
+    ShadowLooper.getShadowMainLooper().runToEndOfTasks();
+  }
+
+  private CountDownLatch getLatchForClearedRef() {
+    final CountDownLatch toWait = new CountDownLatch(1);
+    resources.setDequeuedResourceCallback(new DequeuedResourceCallback() {
+      @Override
+      public void onResourceDequeued() {
+        toWait.countDown();
+      }
+    });
+    return toWait;
+  }
+
+  @SuppressWarnings("unchecked")
+  private static ArgumentCaptor<EngineResource<?>> getEngineResourceCaptor() {
+    return (ArgumentCaptor<EngineResource<?>>) (ArgumentCaptor<?>)
+        ArgumentCaptor.forClass(EngineResource.class);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java
similarity index 52%
rename from library/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java
index 01c767634..2bbc3ad67 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java
@@ -4,12 +4,13 @@
 import static org.mockito.Mockito.doAnswer;
 
 import com.bumptech.glide.load.Key;
-import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.KeyTester;
 import com.bumptech.glide.tests.Util.WriteDigest;
 import java.io.UnsupportedEncodingException;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -18,11 +19,12 @@
 
 @RunWith(JUnit4.class)
 public class DataCacheKeyTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
 
-  @Mock Key firstKey;
-  @Mock Key firstSignature;
-  @Mock Key secondKey;
-  @Mock Key secondSignature;
+  @Mock private Key firstKey;
+  @Mock private Key firstSignature;
+  @Mock private Key secondKey;
+  @Mock private Key secondSignature;
 
   @Before
   public void setUp() throws UnsupportedEncodingException {
@@ -38,29 +40,17 @@ public void setUp() throws UnsupportedEncodingException {
   }
 
   @Test
-  public void testDiffersIfIdDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    DataCacheKey first = new DataCacheKey(firstKey, firstSignature);
-    DataCacheKey second = new DataCacheKey(secondKey, firstSignature);
-
-    KeyAssertions.assertDifferent(first, second);
-  }
-
-  @Test
-  public void testDiffersIfSignatureDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    DataCacheKey first = new DataCacheKey(firstKey, firstSignature);
-    DataCacheKey second = new DataCacheKey(firstKey, secondSignature);
-
-    KeyAssertions.assertDifferent(first, second);
-  }
-
-  @Test
-  public void testSameIfIdAndSignatureAreTheSame()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    DataCacheKey first = new DataCacheKey(firstKey, firstSignature);
-    DataCacheKey second = new DataCacheKey(firstKey, firstSignature);
-
-    KeyAssertions.assertSame(first, second);
+  public void testEqualsHashCodeDigest() throws NoSuchAlgorithmException {
+    keyTester
+        .addEquivalenceGroup(
+            new DataCacheKey(firstKey, firstSignature),
+            new DataCacheKey(firstKey, firstSignature))
+        .addEquivalenceGroup(new DataCacheKey(firstKey, secondSignature))
+        .addEquivalenceGroup(new DataCacheKey(secondKey, firstSignature))
+        .addEquivalenceGroup(new DataCacheKey(secondKey, secondSignature))
+        .addRegressionTest(
+            new DataCacheKey(firstKey, firstSignature),
+            "801d7440d65a0e7c9ad0097d417f346dac4d4c4d5630724110fa3f3fe66236d9")
+        .test();
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
similarity index 81%
rename from library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
index 6a740e638..a3156e2d7 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
@@ -64,7 +64,8 @@ public void testListenerNotifiedJobCompleteOnOnResourceReady() {
 
     ShadowLooper.runUiThreadTasks();
 
-    verify(harness.listener).onEngineJobComplete(eq(harness.key), eq(harness.engineResource));
+    verify(harness.listener)
+        .onEngineJobComplete(eq(job), eq(harness.key), eq(harness.engineResource));
   }
 
   @Test
@@ -107,7 +108,8 @@ public void testListenerNotifiedJobCompleteOnException() {
     job.start(harness.decodeJob);
     job.onLoadFailed(new GlideException("test"));
     ShadowLooper.runUiThreadTasks();
-    verify(harness.listener).onEngineJobComplete(eq(harness.key), isNull(EngineResource.class));
+    verify(harness.listener)
+        .onEngineJobComplete(eq(job), eq(harness.key), isNull(EngineResource.class));
   }
 
   @Test
@@ -220,7 +222,8 @@ public void testDoesNotNotifyCancelledIfReceivedException() {
     job.start(harness.decodeJob);
     job.onLoadFailed(new GlideException("test"));
 
-    verify(harness.listener).onEngineJobComplete(eq(harness.key), isNull(EngineResource.class));
+    verify(harness.listener)
+        .onEngineJobComplete(eq(job), eq(harness.key), isNull(EngineResource.class));
     verify(harness.listener, never()).onEngineJobCancelled(any(EngineJob.class), any(Key.class));
   }
 
@@ -423,7 +426,7 @@ public void testSubmitsDecodeJobToSourceServiceOnSubmitForSource() {
   public void testSubmitsDecodeJobToDiskCacheServiceWhenDecodingFromCacheOnStart() {
     EngineJob<Object> job = harness.getJob();
     when(harness.decodeJob.willDecodeFromCache()).thenReturn(true);
-    harness.diskCacheService.shutdownNow();
+    harness.sourceService.shutdownNow();
     job.start(harness.decodeJob);
 
     verify(harness.decodeJob).run();
@@ -453,27 +456,43 @@ public void testSubmitsDecodeJobToUnlimitedSourceServiceWhenDecodingFromSourceOn
 
   @SuppressWarnings("unchecked")
   private static class MultiCbHarness {
-    Key key = mock(Key.class);
-    Resource<Object> resource = mockResource();
-    EngineResource<Object> engineResource = mock(EngineResource.class);
-    EngineJobListener listener = mock(EngineJobListener.class);
-    boolean isCacheable = true;
-    boolean useUnlimitedSourceGeneratorPool = false;
-    int numCbs = 10;
-    List<ResourceCallback> cbs = new ArrayList<>();
-    EngineJob.EngineResourceFactory factory = mock(EngineJob.EngineResourceFactory.class);
-    EngineJob<Object> job;
-    GlideExecutor diskCacheService = MockGlideExecutor.newMainThreadExecutor();
-    GlideExecutor sourceService = MockGlideExecutor.newMainThreadExecutor();
-    GlideExecutor sourceUnlimitedService = MockGlideExecutor.newMainThreadUnlimitedExecutor();
-    Pools.Pool<EngineJob<?>> pool = new Pools.SimplePool<>(1);
-    DecodeJob<Object> decodeJob = mock(DecodeJob.class);
-    DataSource dataSource = DataSource.LOCAL;
+    final Key key = mock(Key.class);
+    final Resource<Object> resource = mockResource();
+    final EngineResource<Object> engineResource = mock(EngineResource.class);
+    final EngineJobListener listener = mock(EngineJobListener.class);
+    final boolean isCacheable = true;
+    final boolean useUnlimitedSourceGeneratorPool = false;
+    final boolean useAnimationPool = false;
+    final boolean onlyRetrieveFromCache = false;
+    final int numCbs = 10;
+    final List<ResourceCallback> cbs = new ArrayList<>();
+    final EngineJob.EngineResourceFactory factory = mock(EngineJob.EngineResourceFactory.class);
+    final EngineJob<Object> job;
+    final GlideExecutor diskCacheService = MockGlideExecutor.newMainThreadExecutor();
+    final GlideExecutor sourceService = MockGlideExecutor.newMainThreadExecutor();
+    final GlideExecutor sourceUnlimitedService = MockGlideExecutor.newMainThreadExecutor();
+    final GlideExecutor animationService = MockGlideExecutor.newMainThreadExecutor();
+    final Pools.Pool<EngineJob<?>> pool = new Pools.SimplePool<>(1);
+    final DecodeJob<Object> decodeJob = mock(DecodeJob.class);
+    final DataSource dataSource = DataSource.LOCAL;
 
     public MultiCbHarness() {
       when(factory.build(eq(resource), eq(isCacheable))).thenReturn(engineResource);
-      job = new EngineJob<>(diskCacheService, sourceService, sourceUnlimitedService, listener, pool,
-          factory).init(key, isCacheable, useUnlimitedSourceGeneratorPool);
+      job =
+          new EngineJob<>(
+              diskCacheService,
+              sourceService,
+              sourceUnlimitedService,
+              animationService,
+              listener,
+              pool,
+              factory);
+      job.init(
+          key,
+          isCacheable,
+          useUnlimitedSourceGeneratorPool,
+          useAnimationPool,
+          onlyRetrieveFromCache);
       for (int i = 0; i < numCbs; i++) {
         cbs.add(mock(ResourceCallback.class));
       }
@@ -485,27 +504,42 @@ public MultiCbHarness() {
 
   @SuppressWarnings("unchecked")
   private static class EngineJobHarness {
-    EngineJob.EngineResourceFactory factory = mock(EngineJob.EngineResourceFactory.class);
-    Key key = mock(Key.class);
-    Handler mainHandler = new Handler();
-    ResourceCallback cb = mock(ResourceCallback.class);
-    Resource<Object> resource = mockResource();
-    EngineResource<Object> engineResource = mock(EngineResource.class);
-    EngineJobListener listener = mock(EngineJobListener.class);
-    GlideExecutor diskCacheService = MockGlideExecutor.newMainThreadExecutor();
-    GlideExecutor sourceService = MockGlideExecutor.newMainThreadExecutor();
-    GlideExecutor sourceUnlimitedService = MockGlideExecutor.newMainThreadUnlimitedExecutor();
+    final EngineJob.EngineResourceFactory factory = mock(EngineJob.EngineResourceFactory.class);
+    final Key key = mock(Key.class);
+    final Handler mainHandler = new Handler();
+    final ResourceCallback cb = mock(ResourceCallback.class);
+    final Resource<Object> resource = mockResource();
+    final EngineResource<Object> engineResource = mock(EngineResource.class);
+    final EngineJobListener listener = mock(EngineJobListener.class);
+    final GlideExecutor diskCacheService = MockGlideExecutor.newMainThreadExecutor();
+    final GlideExecutor sourceService = MockGlideExecutor.newMainThreadExecutor();
+    final GlideExecutor sourceUnlimitedService = MockGlideExecutor.newMainThreadExecutor();
+    final GlideExecutor animationService = MockGlideExecutor.newMainThreadExecutor();
     boolean isCacheable = true;
     boolean useUnlimitedSourceGeneratorPool = false;
-    DecodeJob<Object> decodeJob = mock(DecodeJob.class);
-    Pools.Pool<EngineJob<?>> pool = new Pools.SimplePool<>(1);
-    DataSource dataSource = DataSource.DATA_DISK_CACHE;
+    final boolean useAnimationPool = false;
+    final boolean onlyRetrieveFromCache = false;
+    final DecodeJob<Object> decodeJob = mock(DecodeJob.class);
+    final Pools.Pool<EngineJob<?>> pool = new Pools.SimplePool<>(1);
+    final DataSource dataSource = DataSource.DATA_DISK_CACHE;
 
-    public EngineJob<Object> getJob() {
+    EngineJob<Object> getJob() {
       when(factory.build(eq(resource), eq(isCacheable))).thenReturn(engineResource);
-      EngineJob<Object> result = new EngineJob<>(
-          diskCacheService, sourceService, sourceUnlimitedService, listener, pool, factory)
-          .init(key, isCacheable, useUnlimitedSourceGeneratorPool);
+      EngineJob<Object> result =
+          new EngineJob<>(
+              diskCacheService,
+              sourceService,
+              sourceUnlimitedService,
+              animationService,
+              listener,
+              pool,
+              factory);
+      result.init(
+          key,
+          isCacheable,
+          useUnlimitedSourceGeneratorPool,
+          useAnimationPool,
+          onlyRetrieveFromCache);
       result.addCallback(cb);
       return result;
     }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java
new file mode 100644
index 000000000..f18a30289
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java
@@ -0,0 +1,179 @@
+package com.bumptech.glide.load.engine;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Option.CacheKeyUpdater;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.signature.ObjectKey;
+import com.google.common.testing.EqualsTester;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.Collections;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class EngineKeyTest {
+  @Rule public final ExpectedException expectedException = ExpectedException.none();
+  @Mock private Transformation<Object> transformation;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+  }
+
+  @Test
+  public void updateDiskCacheKey_throwsException() throws NoSuchAlgorithmException {
+    // If this test fails, update testEqualsAndHashcode to use KeyTester including regression tests.
+    EngineKey key = new EngineKey(
+        "id",
+        new ObjectKey("signature"),
+        100,
+        100,
+        Collections.<Class<?>, Transformation<?>>emptyMap(),
+        Object.class,
+        Object.class,
+        new Options());
+    expectedException.expect(UnsupportedOperationException.class);
+    key.updateDiskCacheKey(MessageDigest.getInstance("SHA-1"));
+  }
+
+  @Test
+  public void testEqualsAndHashCode() {
+    Options memoryOptions = new Options();
+    memoryOptions.set(Option.memory("key", new Object()), new Object());
+
+    Options diskOptions = new Options();
+    diskOptions.set(Option.disk("key", new CacheKeyUpdater<String>() {
+      @Override
+      public void update(@NonNull byte[] keyBytes, @NonNull String value,
+          @NonNull MessageDigest messageDigest) {
+        messageDigest.update(keyBytes);
+        messageDigest.update(value.getBytes(Key.CHARSET));
+
+      }
+    }), "value");
+
+    new EqualsTester()
+        .addEqualityGroup(
+            new EngineKey(
+                "id",
+                new ObjectKey("signature"),
+                100,
+                100,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Object.class,
+                Object.class,
+                new Options()),
+            new EngineKey(
+                "id",
+                new ObjectKey("signature"),
+                100,
+                100,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Object.class,
+                Object.class,
+                new Options()))
+        .addEqualityGroup(
+            new EngineKey(
+                "otherId",
+                new ObjectKey("signature"),
+                100,
+                100,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Object.class,
+                Object.class,
+                new Options()))
+        .addEqualityGroup(
+            new EngineKey(
+                "id",
+                new ObjectKey("otherSignature"),
+                100,
+                100,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Object.class,
+                Object.class,
+                new Options()))
+        .addEqualityGroup(
+            new EngineKey(
+                "id",
+                new ObjectKey("signature"),
+                200,
+                100,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Object.class,
+                Object.class,
+                new Options()))
+        .addEqualityGroup(
+            new EngineKey(
+                "id",
+                new ObjectKey("signature"),
+                100,
+                200,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Object.class,
+                Object.class,
+                new Options()))
+        .addEqualityGroup(
+            new EngineKey(
+                "id",
+                new ObjectKey("signature"),
+                100,
+                100,
+                Collections.<Class<?>, Transformation<?>>singletonMap(Object.class, transformation),
+                Object.class,
+                Object.class,
+                new Options()))
+        .addEqualityGroup(
+            new EngineKey(
+                "id",
+                new ObjectKey("signature"),
+                100,
+                100,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Integer.class,
+                Object.class,
+                new Options()))
+        .addEqualityGroup(
+            new EngineKey(
+                "id",
+                new ObjectKey("signature"),
+                100,
+                100,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Object.class,
+                Integer.class,
+                new Options()))
+        .addEqualityGroup(
+            new EngineKey(
+                "id",
+                new ObjectKey("signature"),
+                100,
+                100,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Object.class,
+                Object.class,
+                memoryOptions))
+        .addEqualityGroup(
+            new EngineKey(
+                "id",
+                new ObjectKey("signature"),
+                100,
+                100,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Object.class,
+                Object.class,
+                diskOptions))
+        .testEquals();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java
similarity index 77%
rename from library/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java
index c4a05be94..3468931eb 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java
@@ -5,8 +5,9 @@
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
@@ -14,6 +15,8 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
@@ -21,15 +24,15 @@
 @Config(manifest = Config.NONE, sdk = 18)
 public class EngineResourceTest {
   private EngineResource<Object> engineResource;
-  private EngineResource.ResourceListener listener;
-  private Key cacheKey = mock(Key.class);
-  private Resource<Object> resource;
+  @Mock private EngineResource.ResourceListener listener;
+  @Mock private Key cacheKey;
+  @Mock private Resource<Object> resource;
 
   @Before
   public void setUp() {
-    resource = mockResource();
-    engineResource = new EngineResource<>(resource, true /*isMemoryCacheable*/);
-    listener = mock(EngineResource.ResourceListener.class);
+    MockitoAnnotations.initMocks(this);
+    engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
     engineResource.setResourceListener(cacheKey, listener);
   }
 
@@ -140,14 +143,27 @@ public void testThrowsIfReleasedMoreThanAcquired() {
 
   @Test(expected = NullPointerException.class)
   public void testThrowsIfWrappedResourceIsNull() {
-    new EngineResource<>(null, false);
+    new EngineResource<>(/*toWrap=*/ null, /*isCacheable=*/ false, /*isRecyclable=*/ true);
   }
 
   @Test
   public void testCanSetAndGetIsCacheable() {
-    engineResource = new EngineResource<>(mockResource(), true);
+    engineResource =
+        new EngineResource<>(mockResource(), /*isCacheable=*/ true, /*isRecyclable=*/ true);
     assertTrue(engineResource.isCacheable());
-    engineResource = new EngineResource<>(mockResource(), false);
+    engineResource =
+        new EngineResource<>(mockResource(), /*isCacheable=*/ false, /*isRecyclable=*/ true);
     assertFalse(engineResource.isCacheable());
   }
+
+  @Test
+  public void release_whenNotRecycleable_doesNotRecycleResource() {
+    resource = mockResource();
+    engineResource = new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ false);
+    engineResource.setResourceListener(cacheKey, listener);
+    engineResource.recycle();
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+    verify(resource, never()).recycle();
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
similarity index 51%
rename from library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
index f442d9684..4decb9a07 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
@@ -11,7 +11,6 @@
 import static org.mockito.Matchers.anyBoolean;
 import static org.mockito.Matchers.anyInt;
 import static org.mockito.Matchers.eq;
-import static org.mockito.Matchers.isNull;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
@@ -26,13 +25,13 @@
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.cache.DiskCache;
+import com.bumptech.glide.load.engine.cache.LruResourceCache;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
 import com.bumptech.glide.load.engine.executor.MockGlideExecutor;
 import com.bumptech.glide.request.ResourceCallback;
 import com.bumptech.glide.tests.BackgroundUtil;
 import com.bumptech.glide.tests.GlideShadowLooper;
-import java.lang.ref.WeakReference;
 import java.util.HashMap;
 import java.util.Map;
 import org.junit.Before;
@@ -58,7 +57,7 @@ public void setUp() {
   public void testNewRunnerIsCreatedAndPostedWithNoExistingLoad() {
     harness.doLoad();
 
-    verify(harness.job).start(any(DecodeJob.class));
+    verify(harness.job).start((DecodeJob) any());
   }
 
   @Test
@@ -85,7 +84,7 @@ public void testEngineJobReceivesRemoveCallbackFromLoadStatus() {
   public void testNewRunnerIsAddedToRunnersMap() {
     harness.doLoad();
 
-    assertThat(harness.jobs).containsKey(harness.cacheKey);
+    assertThat(harness.jobs.getAll()).containsKey(harness.cacheKey);
   }
 
   @Test
@@ -93,7 +92,7 @@ public void testNewRunnerIsNotCreatedAndPostedWithExistingLoad() {
     harness.doLoad();
     harness.doLoad();
 
-    verify(harness.job, times(1)).start(any(DecodeJob.class));
+    verify(harness.job, times(1)).start((DecodeJob) any());
   }
 
   @Test
@@ -117,36 +116,16 @@ public void testLoadStatusIsReturnedForExistingJob() {
 
   @Test
   public void testResourceIsReturnedFromActiveResourcesIfPresent() {
-    harness.activeResources
-        .put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
+    harness.activeResources.activate(harness.cacheKey, harness.resource);
 
     harness.doLoad();
 
     verify(harness.cb).onResourceReady(eq(harness.resource), eq(DataSource.MEMORY_CACHE));
   }
 
-  @Test
-  public void testResourceIsNotReturnedFromActiveResourcesIfRefIsCleared() {
-    harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(null));
-
-    harness.doLoad();
-
-    verify(harness.cb, never()).onResourceReady(isNull(Resource.class), isADataSource());
-  }
-
-  @Test
-  public void testKeyIsRemovedFromActiveResourcesIfRefIsCleared() {
-    harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(null));
-
-    harness.doLoad();
-
-    assertThat(harness.activeResources).doesNotContainKey(harness.cacheKey);
-  }
-
   @Test
   public void testResourceIsAcquiredIfReturnedFromActiveResources() {
-    harness.activeResources
-        .put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
+    harness.activeResources.activate(harness.cacheKey, harness.resource);
 
     harness.doLoad();
 
@@ -155,8 +134,7 @@ public void testResourceIsAcquiredIfReturnedFromActiveResources() {
 
   @Test
   public void testNewLoadIsNotStartedIfResourceIsActive() {
-    harness.activeResources
-        .put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
+    harness.activeResources.activate(harness.cacheKey, harness.resource);
 
     harness.doLoad();
 
@@ -165,34 +143,30 @@ public void testNewLoadIsNotStartedIfResourceIsActive() {
 
   @Test
   public void testNullLoadStatusIsReturnedIfResourceIsActive() {
-    harness.activeResources
-        .put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
+    harness.activeResources.activate(harness.cacheKey, harness.resource);
 
     assertNull(harness.doLoad());
   }
 
   @Test
-  public void testActiveResourcesIsNotCheckedIfReturnedFromCache() {
-    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
-    EngineResource<?> other = mock(EngineResource.class);
-    harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(other));
+  public void load_withResourceInActiveResources_doesNotCheckMemoryCache() {
+    harness.activeResources.activate(harness.cacheKey, harness.resource);
 
     harness.doLoad();
 
     verify(harness.cb).onResourceReady(eq(harness.resource), eq(DataSource.MEMORY_CACHE));
-    verify(harness.cb, never()).onResourceReady(eq(other), isADataSource());
+    verify(harness.cache, never()).remove(any(Key.class));
   }
 
   @Test
   public void testActiveResourcesIsNotCheckedIfNotMemoryCacheable() {
-    harness.activeResources
-        .put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
+    harness.activeResources.activate(harness.cacheKey, harness.resource);
 
     harness.isMemoryCacheable = false;
     harness.doLoad();
 
     verify(harness.resource, never()).acquire();
-    verify(harness.job).start(any(DecodeJob.class));
+    verify(harness.job).start((DecodeJob) any());
   }
 
   @Test
@@ -211,7 +185,7 @@ public void testCacheIsNotCheckedIfNotMemoryCacheable() {
     harness.isMemoryCacheable = false;
     harness.doLoad();
 
-    verify(harness.job).start(any(DecodeJob.class));
+    verify(harness.job).start((DecodeJob) any());
   }
 
   @Test
@@ -249,8 +223,8 @@ public void testResourceIsAddedToActiveResourceIfReturnedFromCache() {
     when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
 
     harness.doLoad();
-
-    assertEquals(harness.resource, harness.activeResources.get(harness.cacheKey).get());
+    EngineResource<?> activeResource = harness.activeResources.get(harness.cacheKey);
+    assertThat(activeResource).isEqualTo(harness.resource);
   }
 
   @Test
@@ -264,7 +238,7 @@ public void testResourceIsAcquiredIfReturnedFromCache() {
 
   @Test
   public void testNewLoadIsNotStartedIfResourceIsCached() {
-    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(mock(EngineResource.class));
+    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
 
     harness.doLoad();
 
@@ -273,7 +247,7 @@ public void testNewLoadIsNotStartedIfResourceIsCached() {
 
   @Test
   public void testNullLoadStatusIsReturnedForCachedResource() {
-    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(mock(EngineResource.class));
+    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
 
     Engine.LoadStatus loadStatus = harness.doLoad();
     assertNull(loadStatus);
@@ -283,65 +257,65 @@ public void testNullLoadStatusIsReturnedForCachedResource() {
   public void testRunnerIsRemovedFromRunnersOnEngineNotifiedJobComplete() {
     harness.doLoad();
 
-    harness.engine.onEngineJobComplete(harness.cacheKey, harness.resource);
+    harness.callOnEngineJobComplete();
 
-    assertThat(harness.jobs).doesNotContainKey(harness.cacheKey);
+    assertThat(harness.jobs.getAll()).doesNotContainKey(harness.cacheKey);
   }
 
   @Test
   public void testEngineIsSetAsResourceListenerOnJobComplete() {
     harness.doLoad();
 
-    harness.engine.onEngineJobComplete(harness.cacheKey, harness.resource);
+    harness.callOnEngineJobComplete();
 
-    verify(harness.resource).setResourceListener(eq(harness.cacheKey), eq(harness.engine));
+    verify(harness.resource).setResourceListener(eq(harness.cacheKey), eq(harness.getEngine()));
   }
 
   @Test
   public void testEngineIsNotSetAsResourceListenerIfResourceIsNullOnJobComplete() {
     harness.doLoad();
 
-    harness.engine.onEngineJobComplete(harness.cacheKey, null);
+    harness.getEngine().onEngineJobComplete(harness.job, harness.cacheKey, /*resource=*/ null);
   }
 
   @Test
   public void testResourceIsAddedToActiveResourcesOnEngineComplete() {
     when(harness.resource.isCacheable()).thenReturn(true);
-    harness.engine.onEngineJobComplete(harness.cacheKey, harness.resource);
+    harness.callOnEngineJobComplete();
 
-    WeakReference<EngineResource<?>> resourceRef = harness.activeResources.get(harness.cacheKey);
-    assertThat(harness.resource).isEqualTo(resourceRef.get());
+    EngineResource<?> resource = harness.activeResources.get(harness.cacheKey);
+    assertThat(harness.resource).isEqualTo(resource);
   }
 
   @Test
   public void testDoesNotPutNullResourceInActiveResourcesOnEngineComplete() {
-    harness.engine.onEngineJobComplete(harness.cacheKey, null);
-    assertThat(harness.activeResources).doesNotContainKey(harness.cacheKey);
+    harness.getEngine().onEngineJobComplete(harness.job, harness.cacheKey, /*resource=*/ null);
+    assertThat(harness.activeResources.get(harness.cacheKey)).isNull();
   }
 
   @Test
   public void testDoesNotPutResourceThatIsNotCacheableInActiveResourcesOnEngineComplete() {
     when(harness.resource.isCacheable()).thenReturn(false);
-    harness.engine.onEngineJobComplete(harness.cacheKey, harness.resource);
-    assertThat(harness.activeResources).doesNotContainKey(harness.cacheKey);
+    harness.callOnEngineJobComplete();
+    assertThat(harness.activeResources.get(harness.cacheKey)).isNull();
   }
 
   @Test
   public void testRunnerIsRemovedFromRunnersOnEngineNotifiedJobCancel() {
     harness.doLoad();
 
-    harness.engine.onEngineJobCancelled(harness.job, harness.cacheKey);
+    harness.getEngine().onEngineJobCancelled(harness.job, harness.cacheKey);
 
-    assertThat(harness.jobs).doesNotContainKey(harness.cacheKey);
+    assertThat(harness.jobs.getAll()).doesNotContainKey(harness.cacheKey);
   }
 
   @Test
   public void testJobIsNotRemovedFromJobsIfOldJobIsCancelled() {
     harness.doLoad();
 
-    harness.engine.onEngineJobCancelled(mock(EngineJob.class), harness.cacheKey);
+    harness.getEngine().onEngineJobCancelled(mock(EngineJob.class), harness.cacheKey);
 
-    assertEquals(harness.job, harness.jobs.get(harness.cacheKey));
+    assertEquals(harness.job, harness.jobs.get(harness.cacheKey, harness.onlyRetrieveFromCache));
   }
 
   @Test
@@ -358,7 +332,7 @@ public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
       }
     }).when(harness.cache).put(eq(harness.cacheKey), anyResource());
 
-    harness.engine.onResourceReleased(harness.cacheKey, harness.resource);
+    harness.getEngine().onResourceReleased(harness.cacheKey, harness.resource);
 
     verify(harness.cache).put(eq(harness.cacheKey), anyResource());
   }
@@ -366,7 +340,7 @@ public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
   @Test
   public void testResourceIsNotAddedToCacheOnReleasedIfNotCacheable() {
     when(harness.resource.isCacheable()).thenReturn(false);
-    harness.engine.onResourceReleased(harness.cacheKey, harness.resource);
+    harness.getEngine().onResourceReleased(harness.cacheKey, harness.resource);
 
     verify(harness.cache, never()).put(eq(harness.cacheKey), eq(harness.resource));
   }
@@ -374,28 +348,28 @@ public void testResourceIsNotAddedToCacheOnReleasedIfNotCacheable() {
   @Test
   public void testResourceIsRecycledIfNotCacheableWhenReleased() {
     when(harness.resource.isCacheable()).thenReturn(false);
-    harness.engine.onResourceReleased(harness.cacheKey, harness.resource);
+    harness.getEngine().onResourceReleased(harness.cacheKey, harness.resource);
     verify(harness.resourceRecycler).recycle(eq(harness.resource));
   }
 
   @Test
   public void testResourceIsRemovedFromActiveResourcesWhenReleased() {
-    harness.activeResources
-        .put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
+    harness.activeResources.activate(harness.cacheKey, harness.resource);
 
-    harness.engine.onResourceReleased(harness.cacheKey, harness.resource);
+    harness.getEngine().onResourceReleased(harness.cacheKey, harness.resource);
 
-    assertThat(harness.activeResources).doesNotContainKey(harness.cacheKey);
+    assertThat(harness.activeResources.get(harness.cacheKey)).isNull();
   }
 
   @Test
   public void testEngineAddedAsListenerToMemoryCache() {
-    verify(harness.cache).setResourceRemovedListener(eq(harness.engine));
+    harness.getEngine();
+    verify(harness.cache).setResourceRemovedListener(eq(harness.getEngine()));
   }
 
   @Test
   public void testResourceIsRecycledWhenRemovedFromCache() {
-    harness.engine.onResourceRemoved(harness.resource);
+    harness.getEngine().onResourceRemoved(harness.resource);
     verify(harness.resourceRecycler).recycle(eq(harness.resource));
   }
 
@@ -403,7 +377,7 @@ public void testResourceIsRecycledWhenRemovedFromCache() {
   public void testJobIsPutInJobWithCacheKeyWithRelevantIds() {
     harness.doLoad();
 
-    assertThat(harness.jobs).containsEntry(harness.cacheKey, harness.job);
+    assertThat(harness.jobs.getAll()).containsEntry(harness.cacheKey, harness.job);
   }
 
   @Test
@@ -422,7 +396,9 @@ public void testFactoryIsGivenNecessaryArguments() {
     verify(harness.engineJobFactory).build(
         eq(harness.cacheKey),
         eq(true) /*isMemoryCacheable*/,
-        eq(false) /*useUnlimitedSourceGeneratorPool*/);
+        eq(false) /*useUnlimitedSourceGeneratorPool*/,
+        /*useAnimationPool=*/ eq(false),
+        /*onlyRetrieveFromCache=*/ eq(false));
   }
 
   @Test
@@ -433,77 +409,268 @@ public void testFactoryIsGivenNecessaryArgumentsWithUnlimitedPool() {
     verify(harness.engineJobFactory).build(
         eq(harness.cacheKey),
         eq(true) /*isMemoryCacheable*/,
-        eq(true) /*useUnlimitedSourceGeneratorPool*/);
+        eq(true) /*useUnlimitedSourceGeneratorPool*/,
+        /*useAnimationPool=*/ eq(false),
+        /*onlyRetrieveFromCache=*/ eq(false));
   }
 
   @Test
   public void testReleaseReleasesEngineResource() {
     EngineResource<Object> engineResource = mock(EngineResource.class);
-    harness.engine.release(engineResource);
+    harness.getEngine().release(engineResource);
     verify(engineResource).release();
   }
 
   @Test(expected = IllegalArgumentException.class)
   public void testThrowsIfAskedToReleaseNonEngineResource() {
-    harness.engine.release(mockResource());
+    harness.getEngine().release(mockResource());
   }
 
   @Test(expected = RuntimeException.class)
   public void testThrowsIfLoadCalledOnBackgroundThread() throws InterruptedException {
     BackgroundUtil.testInBackground(new BackgroundUtil.BackgroundTester() {
       @Override
-      public void runTest() throws Exception {
+      public void runTest() {
         harness.doLoad();
       }
     });
   }
 
+  @Test
+  public void load_afterResourceIsLoadedInActiveResources_returnsFromMemoryCache() {
+    when(harness.resource.isCacheable()).thenReturn(true);
+    doAnswer(new Answer<Object>() {
+      @Override
+      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+        harness.callOnEngineJobComplete();
+        return null;
+      }
+    }).when(harness.job).start(any(DecodeJob.class));
+    harness.doLoad();
+    harness.doLoad();
+    verify(harness.cb).onResourceReady(any(Resource.class), eq(DataSource.MEMORY_CACHE));
+  }
+
+  @Test
+  public void load_afterResourceIsLoadedAndReleased_returnsFromMemoryCache() {
+    harness.cache = new LruResourceCache(100);
+    when(harness.resource.isCacheable()).thenReturn(true);
+    doAnswer(new Answer<Object>() {
+      @Override
+      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+        harness.callOnEngineJobComplete();
+        return null;
+      }
+    }).when(harness.job).start(any(DecodeJob.class));
+    harness.doLoad();
+    harness.getEngine().onResourceReleased(harness.cacheKey, harness.resource);
+    harness.doLoad();
+    verify(harness.cb).onResourceReady(any(Resource.class), eq(DataSource.MEMORY_CACHE));
+  }
+
+  @Test
+  public void load_withOnlyRetrieveFromCache_andPreviousNormalLoad_startsNewLoad() {
+    EngineJob<?> first = harness.job;
+    harness.doLoad();
+    EngineJob<?> second = mock(EngineJob.class);
+    harness.job = second;
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+
+    verify(first).start(any(DecodeJob.class));
+    verify(second).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void load_withNormalLoad_afterPreviousRetrieveFromCache_startsNewLoad() {
+    EngineJob<?> first = harness.job;
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+    EngineJob<?> second = mock(EngineJob.class);
+    harness.job = second;
+    harness.onlyRetrieveFromCache = false;
+    harness.doLoad();
+
+    verify(first).start(any(DecodeJob.class));
+    verify(second).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void load_afterFinishedOnlyRetrieveFromCache_withPendingNormal_doesNotStartNewLoad() {
+    EngineJob<?> firstNormal = harness.job;
+    harness.doLoad();
+
+    harness.job = mock(EngineJob.class);
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+    harness.callOnEngineJobComplete();
+
+    EngineJob<?> secondNormal = mock(EngineJob.class);
+    harness.job = secondNormal;
+    harness.onlyRetrieveFromCache = false;
+    harness.doLoad();
+
+    verify(firstNormal).start(any(DecodeJob.class));
+    verify(secondNormal, never()).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void load_afterCancelledOnlyRetrieveFromCache_withPendingNormal_doesNotStartNewLoad() {
+    EngineJob<?> firstNormal = harness.job;
+    harness.doLoad();
+
+    harness.job = mock(EngineJob.class);
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+    harness.getEngine().onEngineJobCancelled(harness.job, harness.cacheKey);
+
+    EngineJob<?> secondNormal = mock(EngineJob.class);
+    harness.job = secondNormal;
+    harness.onlyRetrieveFromCache = false;
+    harness.doLoad();
+
+    verify(firstNormal).start(any(DecodeJob.class));
+    verify(secondNormal, never()).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void load_withOnlyRetrieveFromCache_withOtherRetrieveFromCachePending_doesNotStartNew() {
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+
+    EngineJob<?> second = mock(EngineJob.class);
+    harness.job = second;
+    harness.doLoad();
+
+    verify(second, never()).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void load_withOnlyRetrieveFromCache_afterPreviousFinishedOnlyFromCacheLoad_startsNew() {
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+    harness.callOnEngineJobComplete();
+
+    EngineJob<?> second = mock(EngineJob.class);
+    harness.job = second;
+    harness.doLoad();
+
+    verify(second).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void load_withOnlyRetrieveFromCache_afterPreviousCancelledOnlyFromCacheLoad_startsNew() {
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+    harness.getEngine().onEngineJobCancelled(harness.job, harness.cacheKey);
+
+    EngineJob<?> second = mock(EngineJob.class);
+    harness.job = second;
+    harness.doLoad();
+
+    verify(second).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void onEngineJobComplete_withOldJobForKey_doesNotRemoveJob() {
+    harness.doLoad();
+    harness.getEngine()
+        .onEngineJobComplete(mock(EngineJob.class), harness.cacheKey, harness.resource);
+
+    harness.job = mock(EngineJob.class);
+    harness.doLoad();
+
+    verify(harness.job, never()).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void onEngineJobCancelled_withOldJobForKey_doesNotRemoveJob() {
+    harness.doLoad();
+    harness.getEngine()
+        .onEngineJobCancelled(mock(EngineJob.class), harness.cacheKey);
+
+    harness.job = mock(EngineJob.class);
+    harness.doLoad();
+
+    verify(harness.job, never()).start(any(DecodeJob.class));
+  }
+
+
+  @Test
+  public void onEngineJobComplete_withOnlyRetrieveFromCacheAndOldJobForKey_doesNotRemoveJob() {
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+    harness.getEngine()
+        .onEngineJobComplete(mock(EngineJob.class), harness.cacheKey, harness.resource);
+
+    harness.job = mock(EngineJob.class);
+    harness.doLoad();
+
+    verify(harness.job, never()).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void onEngineJobCancelled_withOnlyRetrieveFromCacheAndOldJobForKey_doesNotRemoveJob() {
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+    harness.getEngine()
+        .onEngineJobCancelled(mock(EngineJob.class), harness.cacheKey);
+
+    harness.job = mock(EngineJob.class);
+    harness.doLoad();
+
+    verify(harness.job, never()).start(any(DecodeJob.class));
+  }
+
   private static class EngineTestHarness {
-    EngineKey cacheKey = mock(EngineKey.class);
-    EngineKeyFactory keyFactory = mock(EngineKeyFactory.class);
+    final EngineKey cacheKey = mock(EngineKey.class);
+    final EngineKeyFactory keyFactory = mock(EngineKeyFactory.class);
     ResourceCallback cb = mock(ResourceCallback.class);
     @SuppressWarnings("rawtypes")
-    EngineResource resource = mock(EngineResource.class);
-    Map<Key, EngineJob<?>> jobs = new HashMap<>();
-    Map<Key, WeakReference<EngineResource<?>>> activeResources = new HashMap<>();
+    final EngineResource resource = mock(EngineResource.class);
+    final Jobs jobs = new Jobs();
+    final ActiveResources activeResources =
+        new ActiveResources(/*isActiveResourceRetentionAllowed=*/ true);
 
-    int width = 100;
-    int height = 100;
+    final int width = 100;
+    final int height = 100;
 
-    Object model = new Object();
+    final Object model = new Object();
     MemoryCache cache = mock(MemoryCache.class);
     EngineJob<?> job;
-    Engine engine;
-    Engine.EngineJobFactory engineJobFactory = mock(Engine.EngineJobFactory.class);
-    Engine.DecodeJobFactory decodeJobFactory = mock(Engine.DecodeJobFactory.class);
-    ResourceRecycler resourceRecycler = mock(ResourceRecycler.class);
-    Key signature = mock(Key.class);
-    Map<Class<?>, Transformation<?>> transformations = new HashMap<>();
-    Options options = new Options();
-    GlideContext glideContext = mock(GlideContext.class);
+    private Engine engine;
+    final Engine.EngineJobFactory engineJobFactory = mock(Engine.EngineJobFactory.class);
+    final Engine.DecodeJobFactory decodeJobFactory = mock(Engine.DecodeJobFactory.class);
+    final ResourceRecycler resourceRecycler = mock(ResourceRecycler.class);
+    final Key signature = mock(Key.class);
+    final Map<Class<?>, Transformation<?>> transformations = new HashMap<>();
+    final Options options = new Options();
+    final GlideContext glideContext = mock(GlideContext.class);
     boolean isMemoryCacheable = true;
     boolean useUnlimitedSourceGeneratorPool = false;
     boolean onlyRetrieveFromCache = false;
-    boolean isScaleOnlyOrNoTransform = true;
+    final boolean isScaleOnlyOrNoTransform = true;
 
-    public EngineTestHarness() {
+    EngineTestHarness() {
       when(keyFactory.buildKey(eq(model), eq(signature), anyInt(), anyInt(), eq(transformations),
           eq(Object.class), eq(Object.class), eq(options))).thenReturn(cacheKey);
+      when(resource.getResource()).thenReturn(mock(Resource.class));
 
       job = mock(EngineJob.class);
+    }
 
-      engine = new Engine(cache, mock(DiskCache.Factory.class),
-          GlideExecutor.newDiskCacheExecutor(),
-          MockGlideExecutor.newMainThreadExecutor(),
-          MockGlideExecutor.newMainThreadUnlimitedExecutor(),
-          jobs, keyFactory, activeResources,
-          engineJobFactory, decodeJobFactory, resourceRecycler);
+    void callOnEngineJobComplete() {
+      getEngine().onEngineJobComplete(job, cacheKey, resource);
     }
 
-    public Engine.LoadStatus doLoad() {
-      when(engineJobFactory.build(eq(cacheKey), anyBoolean(), anyBoolean()))
+
+    Engine.LoadStatus doLoad() {
+      when(
+          engineJobFactory.build(
+              eq(cacheKey), anyBoolean(), anyBoolean(), anyBoolean(), anyBoolean()))
           .thenReturn((EngineJob<Object>) job);
-      return engine.load(glideContext,
+      when(job.onlyRetrieveFromCache()).thenReturn(onlyRetrieveFromCache);
+      return getEngine().load(glideContext,
           model,
           signature,
           width,
@@ -514,12 +681,35 @@ public EngineTestHarness() {
           DiskCacheStrategy.ALL,
           transformations,
           false /*isTransformationRequired*/,
-          true,
+          isScaleOnlyOrNoTransform,
           options,
           isMemoryCacheable,
           useUnlimitedSourceGeneratorPool,
+          /*useAnimationPool=*/ false,
           onlyRetrieveFromCache,
           cb);
     }
+
+    Engine getEngine() {
+      if (engine == null) {
+        engine =
+            new Engine(
+                cache,
+                mock(DiskCache.Factory.class),
+                GlideExecutor.newDiskCacheExecutor(),
+                MockGlideExecutor.newMainThreadExecutor(),
+                MockGlideExecutor.newMainThreadExecutor(),
+                MockGlideExecutor.newMainThreadExecutor(),
+                jobs,
+                keyFactory,
+                activeResources,
+                engineJobFactory,
+                decodeJobFactory,
+                resourceRecycler,
+                /*isActiveResourceRetentionAllowed=*/ true);
+      }
+      return engine;
+    }
   }
+
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java
new file mode 100644
index 000000000..bcefcbb1a
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java
@@ -0,0 +1,193 @@
+package com.bumptech.glide.load.engine;
+
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doAnswer;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Option.CacheKeyUpdater;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
+import com.bumptech.glide.signature.ObjectKey;
+import com.bumptech.glide.tests.KeyTester;
+import com.bumptech.glide.tests.Util;
+import java.security.MessageDigest;
+import java.util.Arrays;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class ResourceCacheKeyTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
+
+  @Mock private Transformation<Object> transformation1;
+  @Mock private Transformation<Object> transformation2;
+  private LruArrayPool arrayPool;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
+    arrayPool = new LruArrayPool();
+    doAnswer(new Util.WriteDigest("transformation1")).when(transformation1)
+        .updateDiskCacheKey(any(MessageDigest.class));
+    doAnswer(new Util.WriteDigest("transformation1")).when(transformation2)
+        .updateDiskCacheKey(any(MessageDigest.class));
+  }
+
+  @Test
+  public void testEqualsAndHashCode() {
+    Options memoryOptions = new Options();
+    memoryOptions.set(Option.memory("key", new Object()), new Object());
+
+    Options diskOptions = new Options();
+    diskOptions.set(Option.disk("key", new CacheKeyUpdater<String>() {
+      @Override
+      public void update(@NonNull byte[] keyBytes, @NonNull String value,
+          @NonNull MessageDigest messageDigest) {
+        messageDigest.update(keyBytes);
+        messageDigest.update(value.getBytes(Key.CHARSET));
+
+      }
+    }), "value");
+
+    for (int i = 0; i < 20; i++) {
+      byte[] array = new byte[9];
+      Arrays.fill(array, (byte) 2);
+      arrayPool.put(array);
+    }
+
+    keyTester
+        .addEquivalenceGroup(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                100,
+                100,
+                transformation1,
+                Object.class,
+                new Options()),
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                100,
+                100,
+                transformation1,
+                Object.class,
+                new Options()))
+        .addEquivalenceGroup(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("otherSource"),
+                new ObjectKey("signature"),
+                100,
+                100,
+                transformation1,
+                Object.class,
+                new Options()))
+        .addEquivalenceGroup(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("otherSignature"),
+                100,
+                100,
+                transformation1,
+                Object.class,
+                new Options()))
+        .addEquivalenceGroup(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                200,
+                100,
+                transformation1,
+                Object.class,
+                new Options()))
+        .addEquivalenceGroup(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                100,
+                200,
+                transformation1,
+                Object.class,
+                new Options()))
+        .addEquivalenceGroup(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                100,
+                100,
+                transformation2,
+                Object.class,
+                new Options()))
+        .addEquivalenceGroup(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                100,
+                100,
+                transformation1,
+                Integer.class,
+                new Options()))
+        .addEquivalenceGroup(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                100,
+                100,
+                transformation1,
+                Object.class,
+                memoryOptions))
+        .addEquivalenceGroup(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                100,
+                100,
+                transformation1,
+                Object.class,
+                diskOptions))
+        .addRegressionTest(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                100,
+                100,
+                transformation1,
+                Object.class,
+                new Options()),
+            "04d632bfe8e588544909fc44edb7328fa28bea6831b96927ade22b44818654e2")
+        .addRegressionTest(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                100,
+                100,
+                transformation1,
+                Object.class,
+                diskOptions),
+            "781ff8cd30aaaf248134580004ea6d63a1b87ae20ea0f769caf379d7d84986d0")
+        .test();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMapTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMapTest.java
new file mode 100644
index 000000000..3139df1a8
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMapTest.java
@@ -0,0 +1,121 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertNull;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class GroupedLinkedMapTest {
+
+  private GroupedLinkedMap<Key, Object> map;
+
+  @Before
+  public void setUp() {
+    map = new GroupedLinkedMap<>();
+  }
+
+  @Test
+  public void testReturnsNullForGetWithNoBitmap() {
+    Key key =  new Key("key", /*width=*/ 1, /*height=*/ 1);
+    assertNull(map.get(key));
+  }
+
+  @Test
+  public void testCanAddAndRemoveABitmap() {
+    Key key = new Key("key", 1, 1);
+    Object expected = new Object();
+
+    map.put(key, expected);
+
+    assertThat(map.get(key)).isEqualTo(expected);
+  }
+
+  @Test
+  public void testCanAddAndRemoveMoreThanOneBitmapForAGivenKey() {
+    Key key = new Key("key", 1, 1);
+    Integer value = 20;
+
+    int numToAdd = 10;
+
+    for (int i = 0; i < numToAdd; i++) {
+      map.put(key, value);
+    }
+
+    for (int i = 0; i < numToAdd; i++) {
+      assertThat(map.get(key)).isEqualTo(value);
+    }
+  }
+
+  @Test
+  public void testLeastRecentlyRetrievedKeyIsLeastRecentlyUsed() {
+    Key firstKey = new Key("key", 1, 1);
+    Integer firstValue = 10;
+    map.put(firstKey, firstValue);
+    map.put(firstKey, firstValue);
+
+    Key secondKey = new Key("key", 2, 2);
+    Integer secondValue = 20;
+    map.put(secondKey, secondValue);
+
+    map.get(firstKey);
+
+    assertThat(map.removeLast()).isEqualTo(secondValue);
+  }
+
+  @Test
+  public void testAddingAnEntryDoesNotMakeItMostRecentlyUsed() {
+    Key firstKey = new Key("key", 1, 1);
+    Integer firstValue = 10;
+
+    map.put(firstKey, firstValue);
+    map.put(firstKey, firstValue);
+
+    map.get(firstKey);
+
+    Integer secondValue = 20;
+    map.put(new Key("key", 2, 2), secondValue);
+
+    assertThat(map.removeLast()).isEqualTo(secondValue);
+  }
+
+  private static final class Key implements Poolable {
+
+    private final String key;
+    private final int width;
+    private final int height;
+
+    Key(String key, int width, int height) {
+      this.key = key;
+      this.width = width;
+      this.height = height;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (o instanceof Key) {
+        Key other = (Key) o;
+        return key.equals(other.key) && width == other.width && height == other.height;
+      }
+      return false;
+    }
+
+    @Override
+    public int hashCode() {
+      int result = key != null ? key.hashCode() : 0;
+      result = 31 * result + width;
+      result = 31 * result + height;
+      return result;
+    }
+
+    @Override
+    public void offer() {
+      // Do nothing.
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java
similarity index 52%
rename from library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java
index 4f6016cf3..1c037b2f5 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java
@@ -3,13 +3,14 @@
 import static android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
 import static android.content.ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
 import static android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
-import android.annotation.TargetApi;
-import android.os.Build;
 import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Set;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -18,15 +19,15 @@
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
-@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
 public class LruArrayPoolTest {
   private static final int MAX_SIZE = 10;
+  private static final int MAX_PUT_SIZE = MAX_SIZE / 2;
   private static final Class<byte[]> ARRAY_CLASS = byte[].class;
   private static final ArrayAdapterInterface<byte[]> ADAPTER = new ByteArrayAdapter();
   private LruArrayPool pool;
 
   @Before
-  public void setUp() throws Exception {
+  public void setUp() {
     pool = new LruArrayPool(MAX_SIZE);
   }
 
@@ -40,7 +41,7 @@ public void testICanAddAndGetValidArray() {
     int size = 758;
     int value = 564;
     fillPool(pool, size - 1, value);
-    pool.put(createArray(ARRAY_CLASS, size, value), ARRAY_CLASS);
+    pool.put(createArray(ARRAY_CLASS, size, value));
     Object array = pool.get(size, ARRAY_CLASS);
     assertNotNull(array);
     assertTrue(array.getClass() == ARRAY_CLASS);
@@ -57,8 +58,7 @@ public void testItIsSizeLimited() {
   @Test
   public void testArrayLargerThanPoolIsNotAdded() {
     pool = new LruArrayPool(MAX_SIZE);
-    pool.put(createArray(ARRAY_CLASS, MAX_SIZE / ADAPTER.getElementSizeInBytes() + 1, 0),
-        ARRAY_CLASS);
+    pool.put(createArray(ARRAY_CLASS, MAX_SIZE / ADAPTER.getElementSizeInBytes() + 1, 0));
     assertEquals(0, pool.getCurrentSize());
   }
 
@@ -86,6 +86,91 @@ public void testTrimMemoryBackgroundOrGreaterRemovesAllArrays() {
     }
   }
 
+  @Test
+  public void get_withEmptyPool_returnsExactArray() {
+    assertThat(pool.get(MAX_PUT_SIZE, byte[].class)).hasLength(MAX_PUT_SIZE);
+  }
+
+  @Test
+  public void get_withPoolContainingLargerArray_returnsLargerArray() {
+    byte[] expected = new byte[MAX_PUT_SIZE];
+    pool.put(expected);
+    assertThat(pool.get(MAX_PUT_SIZE - 1, byte[].class)).isSameAs(expected);
+  }
+
+  @Test
+  public void get_withPoolContainingSmallerArray_returnsExactArray() {
+    pool.put(new byte[MAX_PUT_SIZE - 1]);
+    assertThat(pool.get(MAX_PUT_SIZE, byte[].class)).hasLength(MAX_PUT_SIZE);
+  }
+
+  @Test
+  public void get_withPoolLessThanHalfFull_returnsFromPools() {
+    int size = MAX_SIZE / 2;
+    byte[] expected = new byte[size];
+    pool.put(expected);
+    assertThat(pool.get(1, byte[].class)).isSameAs(expected);
+  }
+
+  @Test
+  public void get_withPoolMoreThanHalfFull_sizeMoreThanHalfArrayInPool_returnsArray() {
+    Set<byte[]> expected = new HashSet<>();
+    for (int i = 0; i < 3; i++) {
+      byte[] toPut = new byte[MAX_SIZE / 3];
+      expected.add(toPut);
+      pool.put(toPut);
+    }
+    byte[] received = pool.get(2, byte[].class);
+    assertThat(expected).contains(received);
+  }
+
+  @Test
+  public void get_withPoolMoreThanHalfFull_sizeLessThanHalfArrayInPool_returnsNewArray() {
+    pool = new LruArrayPool(100);
+    for (int i = 0; i < 3; i++) {
+      byte[] toPut = new byte[100 / 3];
+      pool.put(toPut);
+    }
+    int requestedSize = 100 / 3 / LruArrayPool.MAX_OVER_SIZE_MULTIPLE;
+    byte[] received = pool.get(requestedSize, byte[].class);
+    assertThat(received).hasLength(requestedSize);
+  }
+
+  @Test
+  public void getExact_withEmptyPool_returnsExactArray() {
+    byte[] result = pool.getExact(MAX_PUT_SIZE, byte[].class);
+    assertThat(result).hasLength(MAX_PUT_SIZE);
+  }
+
+  @Test
+  public void getExact_withPoolContainingLargerArray_returnsExactArray() {
+    pool.put(new byte[MAX_PUT_SIZE]);
+    int expectedSize = MAX_PUT_SIZE - 1;
+    assertThat(pool.getExact(expectedSize, byte[].class)).hasLength(expectedSize);
+  }
+
+  @Test
+  public void getExact_withPoolContainingSmallerArray_returnsExactArray() {
+    pool.put(new byte[MAX_PUT_SIZE - 1]);
+    assertThat(pool.getExact(MAX_PUT_SIZE, byte[].class)).hasLength(MAX_PUT_SIZE);
+  }
+
+  @Test
+  public void getExact_withPoolContainingExactArray_returnsArray() {
+    byte[] expected = new byte[MAX_PUT_SIZE];
+    pool.put(expected);
+    assertThat(pool.getExact(MAX_PUT_SIZE, byte[].class)).isSameAs(expected);
+  }
+
+  @Test
+  public void put_withArrayMoreThanHalfPoolSize_doesNotRetainArray() {
+    int targetSize = (MAX_SIZE / 2) + 1;
+    byte[] toPut = new byte[targetSize];
+    pool.put(toPut);
+    assertThat(pool.getCurrentSize()).isEqualTo(0);
+    assertThat(pool.get(targetSize, byte[].class)).isNotSameAs(toPut);
+  }
+
   private void testTrimMemory(int fillSize, int trimLevel, int expectedSize) {
     pool = new LruArrayPool(MAX_SIZE);
     fillPool(pool, fillSize / ADAPTER.getElementSizeInBytes(), 1);
@@ -95,7 +180,7 @@ private void testTrimMemory(int fillSize, int trimLevel, int expectedSize) {
 
   private void fillPool(LruArrayPool pool, int arrayCount, int arrayLength) {
     for (int i = 0; i < arrayCount; i++) {
-      pool.put(createArray(ARRAY_CLASS, arrayLength, 10), ARRAY_CLASS);
+      pool.put(createArray(ARRAY_CLASS, arrayLength, 10));
     }
   }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
similarity index 92%
rename from library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
index 2b515c771..0b452c214 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
@@ -13,9 +13,9 @@
 import static org.mockito.Mockito.when;
 
 import android.graphics.Bitmap;
+import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.LinkedList;
 import java.util.List;
 import java.util.Set;
 import org.junit.Before;
@@ -88,9 +88,7 @@ public void testClearMemoryRemovesAllBitmaps() {
   public void testEvictedBitmapsAreRecycled() {
     fillPool(pool, MAX_SIZE);
     List<Bitmap> bitmaps = new ArrayList<>(MAX_SIZE);
-    for (Bitmap b : strategy.bitmaps) {
-      bitmaps.add(b);
-    }
+    bitmaps.addAll(strategy.bitmaps);
 
     pool.clearMemory();
 
@@ -140,6 +138,18 @@ public void testPassesArgb8888ToStrategyAsConfigForRequestsWithNullConfigsOnGetD
     assertEquals(expected, result);
   }
 
+  @Test
+  public void get_withNullConfig_andEmptyPool_returnsNewArgb8888Bitmap() {
+    Bitmap result = pool.get(100, 100, /*config=*/ null);
+    assertThat(result.getConfig()).isEqualTo(Bitmap.Config.ARGB_8888);
+  }
+
+  @Test
+  public void getDirty_withNullConfig_andEmptyPool_returnsNewArgb8888Bitmap() {
+    Bitmap result = pool.getDirty(100, 100, /*config=*/ null);
+    assertThat(result.getConfig()).isEqualTo(Bitmap.Config.ARGB_8888);
+  }
+
   private void testTrimMemory(int fillSize, int trimLevel, int expectedSize) {
     MockStrategy strategy = new MockStrategy();
     LruBitmapPool pool = new LruBitmapPool(MAX_SIZE, strategy, ALLOWED_CONFIGS);
@@ -230,7 +240,7 @@ private Bitmap createMutableBitmap(Bitmap.Config config) {
   }
 
   private static class MockStrategy implements LruPoolStrategy {
-    private LinkedList<Bitmap> bitmaps = new LinkedList<>();
+    private final ArrayDeque<Bitmap> bitmaps = new ArrayDeque<>();
     private int numRemoves;
     private int numPuts;
 
@@ -242,7 +252,7 @@ public void put(Bitmap bitmap) {
 
     @Override
     public Bitmap get(int width, int height, Bitmap.Config config) {
-      return bitmaps.removeLast();
+      return bitmaps.isEmpty() ? null : bitmaps.removeLast();
     }
 
     @Override
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java
new file mode 100644
index 000000000..c37b5946a
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java
@@ -0,0 +1,35 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import android.graphics.Bitmap;
+import com.google.common.testing.EqualsTester;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(JUnit4.class)
+public class SizeConfigStrategyTest {
+
+  @Mock
+  private SizeConfigStrategy.KeyPool pool;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+  }
+
+  @Test
+  public void testKeyEquals() {
+    new EqualsTester()
+        .addEqualityGroup(
+            new SizeConfigStrategy.Key(pool, 100, Bitmap.Config.ARGB_8888),
+            new SizeConfigStrategy.Key(pool, 100, Bitmap.Config.ARGB_8888)
+        )
+        .addEqualityGroup(new SizeConfigStrategy.Key(pool, 101, Bitmap.Config.ARGB_8888))
+        .addEqualityGroup(new SizeConfigStrategy.Key(pool, 100, Bitmap.Config.RGB_565))
+        .addEqualityGroup(new SizeConfigStrategy.Key(pool, 100, null /*config*/))
+        .testEquals();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategyKeyTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategyKeyTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategyKeyTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategyKeyTest.java
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
similarity index 53%
rename from library/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
index 29b03a1ec..24a1098e7 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
@@ -3,12 +3,16 @@
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeTrue;
+import static org.mockito.Mockito.mock;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Key;
+import com.bumptech.glide.signature.ObjectKey;
 import com.bumptech.glide.tests.Util;
 import java.io.File;
 import java.io.IOException;
-import java.security.MessageDigest;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -19,23 +23,49 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class DiskLruCacheWrapperTest {
-  private DiskLruCacheWrapper cache;
+  private DiskCache cache;
   private byte[] data;
-  private StringKey key;
+  private ObjectKey key;
+  private File dir;
 
   @Before
   public void setUp() {
-    File dir = RuntimeEnvironment.application.getCacheDir();
-    cache = new DiskLruCacheWrapper(dir, 10 * 1024 * 1024);
-    key = new StringKey("test" + Math.random());
+    dir = RuntimeEnvironment.application.getCacheDir();
+    cache = DiskLruCacheWrapper.create(dir, 10 * 1024 * 1024);
+    key = new ObjectKey("test" + Math.random());
     data = new byte[] { 1, 2, 3, 4, 5, 6 };
   }
 
+  @After
+  public void tearDown() {
+    try {
+      cache.clear();
+    } finally {
+      deleteRecursive(dir);
+    }
+  }
+
+  private static void deleteRecursive(File file) {
+    if (file.isDirectory()) {
+      File[] files = file.listFiles();
+      if (files != null) {
+        for (File f : files) {
+          deleteRecursive(f);
+        }
+      }
+    }
+    // GC before delete() to release files on Windows (https://stackoverflow.com/a/4213208/253468)
+    System.gc();
+    if (!file.delete() && file.exists()) {
+      throw new RuntimeException("Failed to delete: " + file);
+    }
+  }
+
   @Test
   public void testCanInsertAndGet() throws IOException {
     cache.put(key, new DiskCache.Writer() {
       @Override
-      public boolean write(File file) {
+      public boolean write(@NonNull File file) {
         try {
           Util.writeFile(file, data);
         } catch (IOException e) {
@@ -54,7 +84,7 @@ public boolean write(File file) {
   public void testDoesNotCommitIfWriterReturnsFalse() {
     cache.put(key, new DiskCache.Writer() {
       @Override
-      public boolean write(File file) {
+      public boolean write(@NonNull File file) {
         return false;
       }
     });
@@ -66,7 +96,7 @@ public boolean write(File file) {
   public void testDoesNotCommitIfWriterWritesButReturnsFalse() {
     cache.put(key, new DiskCache.Writer() {
       @Override
-      public boolean write(File file) {
+      public boolean write(@NonNull File file) {
         try {
           Util.writeFile(file, data);
         } catch (IOException e) {
@@ -84,7 +114,7 @@ public void testEditIsAbortedIfWriterThrows() throws IOException {
     try {
       cache.put(key, new DiskCache.Writer() {
         @Override
-        public boolean write(File file) {
+        public boolean write(@NonNull File file) {
           throw new RuntimeException("test");
         }
       });
@@ -94,7 +124,7 @@ public boolean write(File file) {
 
     cache.put(key, new DiskCache.Writer() {
       @Override
-      public boolean write(File file) {
+      public boolean write(@NonNull File file) {
         try {
           Util.writeFile(file, data);
         } catch (IOException e) {
@@ -109,16 +139,25 @@ public boolean write(File file) {
     assertArrayEquals(data, received);
   }
 
-  private static class StringKey implements Key {
-    private final String key;
-
-    public StringKey(String key) {
-      this.key = key;
-    }
+  // Tests #2465.
+  @Test
+  public void clearDiskCache_afterOpeningDiskCache_andDeleteDirectoryOutsideGlide_doesNotThrow() {
+    assumeTrue("A file handle is likely open, so cannot delete dir", !Util.isWindows());
+    DiskCache cache = DiskLruCacheWrapper.create(dir, 1024 * 1024);
+    cache.get(mock(Key.class));
+    deleteRecursive(dir);
+    cache.clear();
+  }
 
-    @Override
-    public void updateDiskCacheKey(MessageDigest messageDigest) {
-      messageDigest.update(key.getBytes());
-    }
+  // Tests #2465.
+  @Test
+  public void get_afterDeleteDirectoryOutsideGlideAndClose_doesNotThrow() {
+    assumeTrue("A file handle is likely open, so cannot delete dir", !Util.isWindows());
+    DiskCache cache = DiskLruCacheWrapper.create(dir, 1024 * 1024);
+    cache.get(mock(Key.class));
+    deleteRecursive(dir);
+    cache.clear();
+
+    cache.get(mock(Key.class));
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java
similarity index 86%
rename from library/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java
index 3e3451e81..a1c3f2d55 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java
@@ -4,6 +4,7 @@
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
+import static org.mockito.AdditionalMatchers.not;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyObject;
 import static org.mockito.Matchers.eq;
@@ -13,6 +14,8 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.util.LruCache;
 import org.junit.Before;
 import org.junit.Test;
@@ -28,7 +31,7 @@
   private String currentKey;
 
   @Before
-  public void setUp() throws Exception {
+  public void setUp() {
     currentKey = "";
     listener = mock(CacheListener.class);
     cache = new TestLruCache(SIZE, listener);
@@ -60,14 +63,15 @@ public void testCanPutNullItemWithoutChangingSize() {
   @Test
   public void testReplacingNonNullItemWithNullItemDecreasesSize() {
     String key = getKey();
-    cache.put(key, new Object());
+    Object initialValue = new Object();
+    cache.put(key, initialValue);
     cache.put(key, null);
 
     for (int i = 0; i < SIZE; i++) {
       cache.put(getKey(), new Object());
     }
 
-    verify(listener, never()).onItemRemoved(anyObject());
+    verify(listener).onItemRemoved(initialValue);
   }
 
   @Test
@@ -86,14 +90,16 @@ public void testReplacingNullItemWIthNullItemIncreasesSize() {
   @Test
   public void testReplacingNonNullItemWithNonNullItemUpdatesSize() {
     String key = getKey();
-    cache.put(key, new Object());
+    Object initialValue = new Object();
+    cache.put(key, initialValue);
     cache.put(key, new Object());
 
-    for (int i = 0; i < SIZE; i++) {
+    for (int i = 0; i < SIZE - 1; i++) {
       cache.put(getKey(), new Object());
     }
 
-    verify(listener).onItemRemoved(anyObject());
+    verify(listener).onItemRemoved(initialValue);
+    verify(listener, never()).onItemRemoved(not(eq(initialValue)));
   }
 
   @Test
@@ -191,6 +197,34 @@ public void testCanPutSameItemMultipleTimes() {
     verify(listener, never()).onItemRemoved(anyObject());
   }
 
+  @Test
+  public void put_withSameValueTwice_doesNotEvictItems() {
+    String key = getKey();
+    Object value = new Object();
+    cache.put(key, value);
+    cache.put(key, value);
+
+    verify(listener, never()).onItemRemoved(anyObject());
+  }
+
+  @Test
+  public void put_withExistingNullValue_doesNotNotifyListener() {
+    String key = getKey();
+    cache.put(key, /* item= */ null);
+    cache.put(key, new Object());
+
+    verify(listener, never()).onItemRemoved(anyObject());
+  }
+
+  @Test
+  public void put_withNullValue_withSizeGreaterThanMaximum_notifiesListener() {
+    String key = getKey();
+    when(listener.getSize(null)).thenReturn((int) (cache.getMaxSize() * 2));
+    cache.put(key, null);
+
+    verify(listener).onItemRemoved(anyObject());
+  }
+
   @Test
   public void testCanIncreaseSizeDynamically() {
     int sizeMultiplier = 2;
@@ -259,7 +293,7 @@ public void testDecreasesSizeWhenRemovesKey() {
     Object value = new Object();
     cache.put(key, value);
     for (int i = 0; i < SIZE - 1; i++) {
-      cache.put(key, value);
+      cache.put(getKey(), value);
     }
     cache.remove(key);
     cache.put(key, value);
@@ -326,26 +360,26 @@ private String getKey() {
   }
 
   private interface CacheListener {
-    public void onItemRemoved(Object item);
+    void onItemRemoved(Object item);
 
-    public int getSize(Object item);
+    int getSize(Object item);
   }
 
   private static class TestLruCache extends LruCache<String, Object> {
     private final CacheListener listener;
 
-    public TestLruCache(int size, CacheListener listener) {
+    TestLruCache(int size, CacheListener listener) {
       super(size);
       this.listener = listener;
     }
 
     @Override
-    protected void onItemEvicted(String key, Object item) {
+    protected void onItemEvicted(@NonNull String key, @Nullable Object item) {
       listener.onItemRemoved(item);
     }
 
     @Override
-    protected int getSize(Object item) {
+    protected int getSize(@Nullable Object item) {
       return listener.getSize(item);
     }
   }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
new file mode 100644
index 000000000..8d8e43b1f
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
@@ -0,0 +1,217 @@
+package com.bumptech.glide.load.engine.cache;
+
+import static com.bumptech.glide.load.engine.cache.MemoryCache.ResourceRemovedListener;
+import static com.bumptech.glide.tests.Util.anyResource;
+import static com.bumptech.glide.tests.Util.mockResource;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.content.ComponentCallbacks2;
+import android.support.annotation.NonNull;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.util.LruCache;
+import java.security.MessageDigest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class LruResourceCacheTest {
+
+  @Test
+  public void put_withExistingItem_updatesSizeCorrectly() {
+    PutWithExistingEntryHarness harness = new PutWithExistingEntryHarness();
+    harness.cache.put(harness.key, harness.first);
+    harness.cache.put(harness.key, harness.second);
+
+    assertThat(harness.cache.getCurrentSize()).isEqualTo(harness.second.getSize());
+  }
+
+  @Test
+  public void put_withExistingItem_evictsExistingItem() {
+    PutWithExistingEntryHarness harness = new PutWithExistingEntryHarness();
+    harness.cache.put(harness.key, harness.first);
+    harness.cache.put(harness.key, harness.second);
+
+    verify(harness.listener).onResourceRemoved(harness.first);
+  }
+
+  @Test
+  public void get_afterPutWithExistingItem_returnsNewItem() {
+    PutWithExistingEntryHarness harness = new PutWithExistingEntryHarness();
+    harness.cache.put(harness.key, harness.first);
+    harness.cache.put(harness.key, harness.second);
+
+    assertThat(harness.cache.get(harness.key)).isEqualTo(harness.second);
+  }
+
+  @Test
+  public void onItemEvicted_withNullValue_doesNotNotifyListener() {
+    PutWithExistingEntryHarness harness = new PutWithExistingEntryHarness();
+    harness.cache.onItemEvicted(new MockKey(), null);
+    verify(harness.listener, never()).onResourceRemoved(anyResource());
+  }
+
+  @Test
+  public void clearMemory_afterPutWithExistingItem_evictsOnlyNewItem() {
+    PutWithExistingEntryHarness harness = new PutWithExistingEntryHarness();
+    harness.cache.put(harness.key, harness.first);
+    harness.cache.put(harness.key, harness.second);
+
+    verify(harness.listener).onResourceRemoved(harness.first);
+    verify(harness.listener, never()).onResourceRemoved(harness.second);
+
+    harness.cache.clearMemory();
+
+    verify(harness.listener, times(1)).onResourceRemoved(harness.first);
+    verify(harness.listener).onResourceRemoved(harness.second);
+  }
+
+  @Test
+  public void testTrimMemoryBackground() {
+    TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
+
+    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
+
+    verify(harness.listener).onResourceRemoved(eq(harness.first));
+    verify(harness.listener).onResourceRemoved(eq(harness.second));
+  }
+
+  @Test
+  public void testTrimMemoryModerate() {
+    TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
+
+    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_MODERATE);
+
+    verify(harness.listener).onResourceRemoved(harness.first);
+    verify(harness.listener).onResourceRemoved(harness.second);
+  }
+
+  @Test
+  public void testTrimMemoryUiHidden() {
+    TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
+
+    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
+
+    verify(harness.listener).onResourceRemoved(harness.first);
+    verify(harness.listener, never()).onResourceRemoved(harness.second);
+  }
+
+  @Test
+  public void testResourceRemovedListenerIsNotifiedWhenResourceIsRemoved() {
+    LruResourceCache resourceCache = new LruResourceCache(100);
+    Resource<?> resource = mockResource();
+    when(resource.getSize()).thenReturn(200);
+
+    ResourceRemovedListener listener = mock(ResourceRemovedListener.class);
+
+    resourceCache.setResourceRemovedListener(listener);
+    resourceCache.put(new MockKey(), resource);
+
+    verify(listener).onResourceRemoved(eq(resource));
+  }
+
+  @Test
+  public void testSizeIsBasedOnResource() {
+    LruResourceCache resourceCache = new LruResourceCache(100);
+    Resource<?> first = getResource(50);
+    MockKey firstKey = new MockKey();
+    resourceCache.put(firstKey, first);
+    Resource<?> second = getResource(50);
+    MockKey secondKey = new MockKey();
+    resourceCache.put(secondKey, second);
+
+    assertTrue(resourceCache.contains(firstKey));
+    assertTrue(resourceCache.contains(secondKey));
+
+    Resource<?> third = getResource(50);
+    MockKey thirdKey = new MockKey();
+    resourceCache.put(thirdKey, third);
+
+    assertFalse(resourceCache.contains(firstKey));
+    assertTrue(resourceCache.contains(secondKey));
+    assertTrue(resourceCache.contains(thirdKey));
+  }
+
+  @Test
+  public void testPreventEviction() {
+    final MemoryCache cache = new LruResourceCache(100);
+    final Resource<?> first = getResource(30);
+    final Key firstKey = new MockKey();
+    cache.put(firstKey, first);
+    Resource<?> second = getResource(30);
+    Key secondKey = new MockKey();
+    cache.put(secondKey, second);
+    Resource<?> third = getResource(30);
+    Key thirdKey = new MockKey();
+    cache.put(thirdKey, third);
+    cache.setResourceRemovedListener(new ResourceRemovedListener() {
+      @Override
+      public void onResourceRemoved(@NonNull Resource<?> removed) {
+        if (removed == first) {
+          cache.put(firstKey, first);
+        }
+      }
+    });
+
+    // trims from 100 to 50, having 30+30+30 items, it should trim to 1 item
+    cache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
+
+    // and that 1 item must be first, because it's forced to return to cache in the listener
+    @SuppressWarnings("unchecked")
+    LruCache<Key, Resource<?>> lruCache = (LruCache<Key, Resource<?>>) cache;
+    assertTrue(lruCache.contains(firstKey));
+    assertFalse(lruCache.contains(secondKey));
+    assertFalse(lruCache.contains(thirdKey));
+  }
+
+  private Resource<?> getResource(int size) {
+    Resource<?> resource = mockResource();
+    when(resource.getSize()).thenReturn(size);
+    return resource;
+  }
+
+  private static class MockKey implements Key {
+    @Override
+    public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
+      messageDigest.update(toString().getBytes(CHARSET));
+    }
+  }
+
+  private static class PutWithExistingEntryHarness {
+    final LruResourceCache cache = new LruResourceCache(100);
+    final Resource<?> first = mockResource();
+    final Resource<?> second = mockResource();
+    final ResourceRemovedListener listener = mock(ResourceRemovedListener.class);
+    final Key key = new MockKey();
+
+    PutWithExistingEntryHarness() {
+      when(first.getSize()).thenReturn(50);
+      when(second.getSize()).thenReturn(50);
+      cache.setResourceRemovedListener(listener);
+    }
+  }
+
+  private static class TrimClearMemoryCacheHarness {
+    final LruResourceCache resourceCache = new LruResourceCache(100);
+    final Resource<?> first = mockResource();
+    final Resource<?> second = mockResource();
+    final ResourceRemovedListener listener = mock(ResourceRemovedListener.class);
+
+    TrimClearMemoryCacheHarness() {
+      when(first.getSize()).thenReturn(50);
+      when(second.getSize()).thenReturn(50);
+      resourceCache.put(new MockKey(), first);
+      resourceCache.put(new MockKey(), second);
+      resourceCache.setResourceRemovedListener(listener);
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
similarity index 91%
rename from library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
index 98c4b8371..ae2eb4bd6 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
@@ -32,7 +32,6 @@
   @Before
   public void setUp() {
     initialSdkVersion = Build.VERSION.SDK_INT;
-    Util.setSdkVersionInt(18);
     harness = new MemorySizeHarness();
   }
 
@@ -138,11 +137,9 @@ public void testCumulativePoolAndMemoryCacheSizesAreSmallerOnLowMemoryDevices()
 
   @Test
   public void testByteArrayPoolSize_withLowRamDevice_isHalfTheSpecifiedBytes() {
-    LowRamActivityManager activityManager =
-        (LowRamActivityManager) Shadow.extract(harness.activityManager);
-    Util.setSdkVersionInt(19);
+    LowRamActivityManager activityManager = Shadow.extract(harness.activityManager);
     activityManager.setMemoryClass(getLargeEnoughMemoryClass());
-    activityManager.setIsLowRam(true);
+    activityManager.setIsLowRam();
 
     int byteArrayPoolSize = harness.getCalculator().getArrayPoolSizeInBytes();
     assertThat(byteArrayPoolSize).isEqualTo(harness.byteArrayPoolSizeBytes / 2);
@@ -159,18 +156,18 @@ private int getLargeEnoughMemoryClass() {
   }
 
   private static class MemorySizeHarness {
-    int pixelSize = 500;
-    int bytesPerPixel = MemorySizeCalculator.BYTES_PER_ARGB_8888_PIXEL;
+    final int pixelSize = 500;
+    final int bytesPerPixel = MemorySizeCalculator.BYTES_PER_ARGB_8888_PIXEL;
     float memoryCacheScreens = MemorySizeCalculator.Builder.MEMORY_CACHE_TARGET_SCREENS;
     float bitmapPoolScreens = MemorySizeCalculator.Builder.BITMAP_POOL_TARGET_SCREENS;
-    float sizeMultiplier = MemorySizeCalculator.Builder.MAX_SIZE_MULTIPLIER;
+    final float sizeMultiplier = MemorySizeCalculator.Builder.MAX_SIZE_MULTIPLIER;
     int byteArrayPoolSizeBytes = MemorySizeCalculator.Builder.ARRAY_POOL_SIZE_BYTES;
-    ActivityManager activityManager =
+    final ActivityManager activityManager =
         (ActivityManager) RuntimeEnvironment.application.getSystemService(Context.ACTIVITY_SERVICE);
-    MemorySizeCalculator.ScreenDimensions screenDimensions =
+    final MemorySizeCalculator.ScreenDimensions screenDimensions =
         mock(MemorySizeCalculator.ScreenDimensions.class);
 
-    public MemorySizeCalculator getCalculator() {
+    MemorySizeCalculator getCalculator() {
       when(screenDimensions.getWidthPixels()).thenReturn(pixelSize);
       when(screenDimensions.getHeightPixels()).thenReturn(pixelSize);
       return new MemorySizeCalculator.Builder(RuntimeEnvironment.application)
@@ -183,7 +180,7 @@ public MemorySizeCalculator getCalculator() {
           .build();
     }
 
-    public int getScreenSize() {
+    int getScreenSize() {
       return pixelSize * pixelSize * bytesPerPixel;
     }
   }
@@ -193,11 +190,12 @@ public int getScreenSize() {
 
     private boolean isLowRam;
 
-    void setIsLowRam(boolean isLowRam) {
-      this.isLowRam = isLowRam;
+    void setIsLowRam() {
+      this.isLowRam = true;
     }
 
     @Implementation
+    @Override
     public boolean isLowRamDevice() {
       return isLowRam;
     }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/SafeKeyGeneratorTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/SafeKeyGeneratorTest.java
similarity index 83%
rename from library/src/test/java/com/bumptech/glide/load/engine/cache/SafeKeyGeneratorTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/cache/SafeKeyGeneratorTest.java
index 207ccaf9b..f48c56eaa 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/SafeKeyGeneratorTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/SafeKeyGeneratorTest.java
@@ -2,6 +2,7 @@
 
 import static org.junit.Assert.assertTrue;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Key;
 import java.security.MessageDigest;
 import java.util.regex.Matcher;
@@ -19,7 +20,7 @@
   private int nextId;
 
   @Before
-  public void setUp() throws Exception {
+  public void setUp() {
     nextId = 0;
     keyGenerator = new SafeKeyGenerator();
   }
@@ -42,15 +43,15 @@ private String getNextId() {
     return String.valueOf(nextId++);
   }
 
-  private static class MockKey implements Key {
-    private String id;
+  private static final class MockKey implements Key {
+    private final String id;
 
-    public MockKey(String id) {
+    MockKey(String id) {
       this.id = id;
     }
 
     @Override
-    public void updateDiskCacheKey(MessageDigest messageDigest) {
+    public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
       messageDigest.update(id.getBytes(CHARSET));
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java
similarity index 87%
rename from library/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java
index fa9dba251..7a9e74be1 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java
@@ -2,6 +2,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import android.support.annotation.NonNull;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -36,21 +37,21 @@ public void onRun(int priority) {
     assertThat(resultPriorities).containsExactly(5, 1, 2, 3, 4).inOrder();
   }
 
-  private static class MockRunnable implements Runnable,
+  private static final class MockRunnable implements Runnable,
       Comparable<MockRunnable> {
     private final int priority;
     private final OnRun onRun;
 
     @Override
-    public int compareTo(MockRunnable another) {
+    public int compareTo(@NonNull MockRunnable another) {
       return priority - another.priority;
     }
 
-    public interface OnRun {
+    interface OnRun {
       void onRun(int priority);
     }
 
-    public MockRunnable(int priority, OnRun onRun) {
+    MockRunnable(int priority, OnRun onRun) {
       this.priority = priority;
       this.onRun = onRun;
     }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java b/library/test/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
new file mode 100644
index 000000000..94ef1782c
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
@@ -0,0 +1,116 @@
+package com.bumptech.glide.load.engine.executor;
+
+import android.os.StrictMode;
+import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
+import com.google.common.util.concurrent.ForwardingExecutorService;
+import com.google.common.util.concurrent.MoreExecutors;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Future;
+
+/**
+ * Creates mock {@link GlideExecutor}s.
+ */
+@VisibleForTesting
+public final class MockGlideExecutor {
+  private MockGlideExecutor() {
+    // Utility class.
+  }
+
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public static GlideExecutor newTestExecutor(ExecutorService executorService) {
+    return new GlideExecutor(executorService);
+  }
+
+  public static GlideExecutor newMainThreadExecutor() {
+    return newTestExecutor(new DirectExecutorService());
+  }
+
+  /**
+   * @deprecated Use {@link #newMainThreadExecutor} instead.
+   */
+  @Deprecated
+  public static GlideExecutor newMainThreadUnlimitedExecutor() {
+    return newMainThreadExecutor();
+  }
+
+  /**
+   * DirectExecutorService that enforces StrictMode and converts ExecutionExceptions into
+   * RuntimeExceptions.
+   */
+  private static final class DirectExecutorService extends ForwardingExecutorService {
+    private static final StrictMode.ThreadPolicy THREAD_POLICY =
+        new StrictMode.ThreadPolicy.Builder()
+            .detectNetwork()
+            .penaltyDeath()
+            .build();
+
+    private final ExecutorService delegate;
+
+    DirectExecutorService() {
+      delegate = MoreExecutors.newDirectExecutorService();
+    }
+
+    @Override
+    protected ExecutorService delegate() {
+      return delegate;
+    }
+
+    @NonNull
+    @Override
+    public <T> Future<T> submit(@NonNull Runnable task, @NonNull T result) {
+      return getUninterruptibly(super.submit(task, result));
+    }
+
+    @NonNull
+    @Override
+    public <T> Future<T> submit(@NonNull Callable<T> task) {
+      return getUninterruptibly(super.submit(task));
+    }
+
+    @NonNull
+    @Override
+    public Future<?> submit(@NonNull Runnable task) {
+      return getUninterruptibly(super.submit(task));
+    }
+
+    @Override
+    public void execute(@NonNull final Runnable command) {
+      delegate.execute(new Runnable() {
+        @Override
+        public void run() {
+          StrictMode.ThreadPolicy oldPolicy = StrictMode.getThreadPolicy();
+          StrictMode.setThreadPolicy(THREAD_POLICY);
+          try {
+            command.run();
+          } finally {
+            StrictMode.setThreadPolicy(oldPolicy);
+          }
+        }
+      });
+    }
+
+    private <T> Future<T> getUninterruptibly(Future<T> future) {
+      boolean interrupted = false;
+      try {
+        while (!future.isDone()) {
+          try {
+            future.get();
+          } catch (ExecutionException e) {
+            throw new RuntimeException(e);
+          } catch (InterruptedException e) {
+            interrupted = true;
+          }
+        }
+      } finally {
+        if (interrupted) {
+          Thread.currentThread().interrupt();
+        }
+      }
+      return future;
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
similarity index 87%
rename from library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
index d00b03193..7680c43a7 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
@@ -16,10 +16,13 @@
 
 import android.graphics.Bitmap;
 import android.os.Handler;
+import android.util.Log;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruBitmapPool;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
+import com.bumptech.glide.load.engine.cache.MemoryCacheAdapter;
 import com.bumptech.glide.load.resource.bitmap.BitmapResource;
 import com.bumptech.glide.tests.Util.CreateBitmap;
 import com.bumptech.glide.util.Util;
@@ -37,15 +40,16 @@
 import org.mockito.stubbing.Answer;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLog;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class BitmapPreFillRunnerTest {
-  @Mock BitmapPreFillRunner.Clock clock;
-  @Mock BitmapPool pool;
-  @Mock MemoryCache cache;
-  @Mock Handler mainHandler;
-  private List<Bitmap> addedBitmaps = new ArrayList<>();
+  @Mock private BitmapPreFillRunner.Clock clock;
+  @Mock private BitmapPool pool;
+  @Mock private MemoryCache cache;
+  @Mock private Handler mainHandler;
+  private final List<Bitmap> addedBitmaps = new ArrayList<>();
 
   @Before
   public void setUp() {
@@ -195,7 +199,7 @@ public void testPreFillHandlerDoesNotPostIfHasBitmapsButIsCancelled() {
   @Test
   public void testAddsBitmapsToMemoryCacheIfMemoryCacheHasEnoughSpaceRemaining() {
     Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    when(cache.getMaxSize()).thenReturn(Util.getBitmapByteSize(bitmap));
+    when(cache.getMaxSize()).thenReturn(Long.valueOf(Util.getBitmapByteSize(bitmap)));
 
     PreFillType size =
         new PreFillType.Builder(bitmap.getWidth(), bitmap.getHeight()).setConfig(bitmap.getConfig())
@@ -214,7 +218,7 @@ public void testAddsBitmapsToMemoryCacheIfMemoryCacheHasEnoughSpaceRemaining() {
   @Test
   public void testAddsBitmapsToBitmapPoolIfMemoryCacheIsFull() {
     Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    when(cache.getMaxSize()).thenReturn(0);
+    when(cache.getMaxSize()).thenReturn(0L);
 
     PreFillType size =
         new PreFillType.Builder(bitmap.getWidth(), bitmap.getHeight()).setConfig(bitmap.getConfig())
@@ -233,7 +237,7 @@ public void testAddsBitmapsToBitmapPoolIfMemoryCacheIsFull() {
   @Test
   public void testAddsBitmapsToPoolIfMemoryCacheIsNotFullButCannotFitBitmap() {
     Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    when(cache.getMaxSize()).thenReturn(Util.getBitmapByteSize(bitmap) / 2);
+    when(cache.getMaxSize()).thenReturn((long) Util.getBitmapByteSize(bitmap) / 2);
 
     PreFillType size =
         new PreFillType.Builder(bitmap.getWidth(), bitmap.getHeight()).setConfig(bitmap.getConfig())
@@ -300,10 +304,28 @@ public void testDoesNotGetMoreThanOncePerSize() {
     // order.verify(pool, times(numBitmaps)).put(eq(bitmap));
   }
 
-  private static class AddBitmapPoolAnswer implements Answer<Void> {
-    private List<Bitmap> bitmaps;
+  @Test
+  public void allocate_whenBitmapPoolIsAtCapacity_doesNotLogWithRecycledBitmap() {
+    ShadowLog.setLoggable(BitmapPreFillRunner.TAG, Log.VERBOSE);
+
+    int dimensions = 10;
+    Bitmap.Config config = Bitmap.Config.ARGB_8888;
+    int bitmapByteSize = Util.getBitmapByteSize(dimensions, dimensions, config);
+    PreFillType preFillType = new PreFillType.Builder(dimensions).setConfig(config).build();
+    Map<PreFillType, Integer> allocationOrder = new HashMap<>();
+    allocationOrder.put(preFillType, 1);
+    PreFillQueue queue = new PreFillQueue(allocationOrder);
+    BitmapPreFillRunner runner =
+        new BitmapPreFillRunner(
+            new LruBitmapPool(bitmapByteSize - 1), new MemoryCacheAdapter(), queue);
+
+    runner.allocate();
+  }
+
+  private static final class AddBitmapPoolAnswer implements Answer<Void> {
+    private final List<Bitmap> bitmaps;
 
-    public AddBitmapPoolAnswer(List<Bitmap> bitmaps) {
+    AddBitmapPoolAnswer(List<Bitmap> bitmaps) {
       this.bitmaps = bitmaps;
     }
 
@@ -315,10 +337,10 @@ public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
     }
   }
 
-  private static class AddBitmapCacheAnswer implements Answer<Resource<?>> {
-    private List<Bitmap> bitmaps;
+  private static final class AddBitmapCacheAnswer implements Answer<Resource<?>> {
+    private final List<Bitmap> bitmaps;
 
-    public AddBitmapCacheAnswer(List<Bitmap> bitmaps) {
+    AddBitmapCacheAnswer(List<Bitmap> bitmaps) {
       this.bitmaps = bitmaps;
     }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
similarity index 88%
rename from library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
index 539cefa65..87d0395d3 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
@@ -41,12 +41,12 @@
   private final Bitmap.Config defaultBitmapConfig = PreFillType.DEFAULT_CONFIG;
   private final Bitmap defaultBitmap =
       Bitmap.createBitmap(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT, defaultBitmapConfig);
-  private final int defaultBitmapSize = Util.getBitmapByteSize(defaultBitmap);
-  private final int poolSize = BITMAPS_IN_CACHE * defaultBitmapSize;
-  private final int cacheSize = BITMAPS_IN_POOL * defaultBitmapSize;
+  private final long defaultBitmapSize = Util.getBitmapByteSize(defaultBitmap);
+  private final long poolSize = BITMAPS_IN_CACHE * defaultBitmapSize;
+  private final long cacheSize = BITMAPS_IN_POOL * defaultBitmapSize;
 
-  @Mock BitmapPool pool;
-  @Mock MemoryCache cache;
+  @Mock private BitmapPool pool;
+  @Mock private MemoryCache cache;
   private BitmapPreFiller bitmapPreFiller;
 
   @Before
@@ -62,9 +62,11 @@ public void setUp() {
 
   @Test
   public void testAllocationOrderContainsEnoughSizesToFillPoolAndMemoryCache() {
-    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(new PreFillType[] {
-        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
-            .setConfig(defaultBitmapConfig).build() });
+    PreFillQueue allocationOrder =
+        bitmapPreFiller.generateAllocationOrder(
+            new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
+                .setConfig(defaultBitmapConfig)
+                .build());
 
     assertEquals(BITMAPS_IN_POOL + BITMAPS_IN_CACHE, allocationOrder.getSize());
   }
@@ -88,11 +90,12 @@ public void testAllocationOrderThatDoesNotFitExactlyIntoGivenSizeRoundsDown() {
     }
 
     int expectedSize = 0;
-    int maxSize = poolSize + cacheSize;
+    long maxSize = poolSize + cacheSize;
     for (PreFillType current : sizes) {
       int currentSize =
           Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());
-      expectedSize += currentSize * (maxSize / (3 * currentSize));
+      // See http://errorprone.info/bugpattern/NarrowingCompoundAssignment.
+      expectedSize = (int) (expectedSize + (currentSize * (maxSize / (3 * currentSize))));
     }
 
     assertEquals(expectedSize, byteSize);
@@ -100,15 +103,15 @@ public void testAllocationOrderThatDoesNotFitExactlyIntoGivenSizeRoundsDown() {
 
   @Test
   public void testAllocationOrderDoesNotOverFillWithMultipleSizes() {
-    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(new PreFillType[] {
+    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(
         new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
             .setConfig(defaultBitmapConfig).build(),
         new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
             .setConfig(defaultBitmapConfig).build(),
         new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
-            .setConfig(defaultBitmapConfig).build() });
+            .setConfig(defaultBitmapConfig).build());
 
-    int byteSize = 0;
+    long byteSize = 0;
     while (!allocationOrder.isEmpty()) {
       PreFillType current = allocationOrder.remove();
       byteSize +=
@@ -120,15 +123,15 @@ public void testAllocationOrderDoesNotOverFillWithMultipleSizes() {
 
   @Test
   public void testAllocationOrderDoesNotOverFillWithMultipleSizesAndWeights() {
-    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(new PreFillType[] {
+    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(
         new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
             .setConfig(defaultBitmapConfig).setWeight(4).build(),
         new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
             .setConfig(defaultBitmapConfig).build(),
         new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 3)
-            .setConfig(defaultBitmapConfig).setWeight(3).build() });
+            .setConfig(defaultBitmapConfig).setWeight(3).build());
 
-    int byteSize = 0;
+    long byteSize = 0;
     while (!allocationOrder.isEmpty()) {
       PreFillType current = allocationOrder.remove();
       byteSize +=
@@ -140,9 +143,11 @@ public void testAllocationOrderDoesNotOverFillWithMultipleSizesAndWeights() {
 
   @Test
   public void testAllocationOrderContainsSingleSizeIfSingleSizeIsProvided() {
-    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(new PreFillType[] {
-        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
-            .setConfig(defaultBitmapConfig).build() });
+    PreFillQueue allocationOrder =
+        bitmapPreFiller.generateAllocationOrder(
+            new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
+                .setConfig(defaultBitmapConfig)
+                .build());
 
     while (!allocationOrder.isEmpty()) {
       PreFillType size = allocationOrder.remove();
@@ -161,7 +166,7 @@ public void testAllocationOrderSplitsEvenlyBetweenEqualSizesWithEqualWeights() {
         new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
             .setConfig(defaultBitmapConfig).build();
     PreFillQueue allocationOrder =
-        bitmapPreFiller.generateAllocationOrder(new PreFillType[] { smallWidth, smallHeight, });
+        bitmapPreFiller.generateAllocationOrder(smallWidth, smallHeight);
 
     int numSmallWidth = 0, numSmallHeight = 0;
     while (!allocationOrder.isEmpty()) {
@@ -185,8 +190,7 @@ public void testAllocationOrderSplitsByteSizeEvenlyBetweenUnEqualSizesWithEqualW
             .setConfig(defaultBitmapConfig).build();
     PreFillType normal = new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
         .setConfig(defaultBitmapConfig).build();
-    PreFillQueue allocationOrder =
-        bitmapPreFiller.generateAllocationOrder(new PreFillType[] { smallWidth, normal });
+    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(smallWidth, normal);
 
     int numSmallWidth = 0, numNormal = 0;
     while (!allocationOrder.isEmpty()) {
@@ -210,8 +214,7 @@ public void testAllocationOrderSplitsByteSizeUnevenlyBetweenEqualSizesWithUnequa
             .setConfig(defaultBitmapConfig).setWeight(2).build();
     PreFillType normal = new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
         .setConfig(defaultBitmapConfig).build();
-    PreFillQueue allocationOrder =
-        bitmapPreFiller.generateAllocationOrder(new PreFillType[] { doubleWeight, normal });
+    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(doubleWeight, normal);
 
     int numDoubleWeight = 0, numNormal = 0;
     while (!allocationOrder.isEmpty()) {
@@ -239,8 +242,7 @@ public void testAllocationOrderRoundRobinsDifferentSizes() {
         new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
             .setConfig(defaultBitmapConfig).build();
 
-    PreFillQueue allocationOrder =
-        bitmapPreFiller.generateAllocationOrder(new PreFillType[] { smallWidth, smallHeight, });
+    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(smallWidth, smallHeight);
 
     List<PreFillType> attributes = new ArrayList<>();
     while (!allocationOrder.isEmpty()) {
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java
diff --git a/library/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java
similarity index 80%
rename from library/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java
index 1dd269502..d1670029e 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java
@@ -10,6 +10,7 @@
 import android.net.Uri;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.util.Preconditions;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -24,8 +25,8 @@
 public class AssetUriLoaderTest {
   private static final int IMAGE_SIDE = 10;
 
-  @Mock AssetUriLoader.AssetFetcherFactory<Object> factory;
-  @Mock DataFetcher<Object> fetcher;
+  @Mock private AssetUriLoader.AssetFetcherFactory<Object> factory;
+  @Mock private DataFetcher<Object> fetcher;
   private AssetUriLoader<Object> loader;
 
   @Before
@@ -39,7 +40,9 @@ public void testHandlesAssetUris() {
     Uri assetUri = Uri.parse("file:///android_asset/assetName");
     when(factory.buildFetcher(any(AssetManager.class), eq("assetName"))).thenReturn(fetcher);
     assertTrue(loader.handles(assetUri));
-    assertEquals(fetcher, loader.buildLoadData(assetUri, IMAGE_SIDE, IMAGE_SIDE,
-        new Options()).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(
+            loader.buildLoadData(assetUri, IMAGE_SIDE, IMAGE_SIDE, new Options())).fetcher);
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java
similarity index 68%
rename from library/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java
index e17ecc6b9..80eb81666 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java
@@ -9,6 +9,7 @@
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.util.Preconditions;
 import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
@@ -20,8 +21,8 @@
 @RunWith(JUnit4.class)
 public class ByteArrayLoaderTest {
 
-  @Mock ByteArrayLoader.Converter<Object> converter;
-  @Mock DataFetcher.DataCallback<Object> callback;
+  @Mock private ByteArrayLoader.Converter<Object> converter;
+  @Mock private DataFetcher.DataCallback<Object> callback;
   private ByteArrayLoader<Object> loader;
   private Options options;
 
@@ -35,24 +36,28 @@ public void setUp() {
   @Test
   public void testCanHandleByteArray() {
     byte[] data = new byte[10];
-    DataFetcher<Object> fetcher = loader.buildLoadData(data, -1, -1, options).fetcher;
+    DataFetcher<Object> fetcher =
+        Preconditions.checkNotNull(loader.buildLoadData(data, -1, -1, options)).fetcher;
     assertNotNull(fetcher);
   }
 
   @Test
   public void testFetcherReturnsObjectReceivedFromConverter() throws IOException {
-    byte[] data = "fake".getBytes();
+    byte[] data = "fake".getBytes("UTF-8");
     Object expected = new Object();
     when(converter.convert(eq(data))).thenReturn(expected);
 
-    loader.buildLoadData(data, 10, 10, options).fetcher.loadData(Priority.HIGH, callback);
+    Preconditions.checkNotNull(loader.buildLoadData(data, 10, 10, options)).fetcher
+        .loadData(Priority.HIGH, callback);
     verify(callback).onDataReady(eq(expected));
   }
 
   @Test
   public void testFetcherReturnsDataClassFromConverter() {
     when(converter.getDataClass()).thenReturn(Object.class);
-    assertEquals(Object.class,
-        loader.buildLoadData(new byte[10], 10, 10, options).fetcher.getDataClass());
+    assertEquals(
+        Object.class,
+        Preconditions.checkNotNull(loader.buildLoadData(new byte[10], 10, 10, options)).fetcher
+            .getDataClass());
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java
similarity index 89%
rename from library/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java
index 6665f0720..440516b26 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java
@@ -6,6 +6,7 @@
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.util.Base64;
 import com.bumptech.glide.Priority;
@@ -55,18 +56,17 @@
 
   @Mock
   private MultiModelLoaderFactory multiFactory;
-  private DataUrlLoader<InputStream> dataUrlLoader;
+  private DataUrlLoader<String, InputStream> dataUrlLoader;
   private DataFetcher<InputStream> fetcher;
   private Options options;
 
   @Before
-  public void setUp() throws Exception {
+  public void setUp() {
     MockitoAnnotations.initMocks(this);
-    DataUrlLoader.StreamFactory factory = new DataUrlLoader.StreamFactory();
+    DataUrlLoader.StreamFactory<String> factory = new DataUrlLoader.StreamFactory<>();
     options = new Options();
-    dataUrlLoader = (DataUrlLoader<InputStream>) factory.build(multiFactory);
+    dataUrlLoader = (DataUrlLoader<String, InputStream>) factory.build(multiFactory);
     fetcher = dataUrlLoader.buildLoadData(VALID_PNG, -1, -1, options).fetcher;
-
   }
 
   @Test
@@ -94,7 +94,7 @@ public void testDecode() throws IOException {
   }
 
   @Test
-  public void testDecodeInvalidScheme() throws IOException {
+  public void testDecodeInvalidScheme() {
     fetcher = dataUrlLoader.buildLoadData(INVALID_URL_WRONG_SCHEME1, -1, -1, options).fetcher;
     CallBack callback = new CallBack();
     fetcher.loadData(Priority.HIGH, callback);
@@ -102,7 +102,7 @@ public void testDecodeInvalidScheme() throws IOException {
   }
 
   @Test
-  public void testDecodeMissingComma() throws IOException {
+  public void testDecodeMissingComma() {
     fetcher = dataUrlLoader.buildLoadData(INVALID_URL_MISSING_COMMA, -1, -1, options).fetcher;
     CallBack callback = new CallBack();
     fetcher.loadData(Priority.HIGH, callback);
@@ -110,14 +110,14 @@ public void testDecodeMissingComma() throws IOException {
   }
 
   @Test
-  public void testDecodeWrongEncoding() throws IOException {
+  public void testDecodeWrongEncoding() {
     fetcher = dataUrlLoader.buildLoadData(INVALID_URL_WRONG_ENCODING, -1, -1, options).fetcher;
     CallBack callback = new CallBack();
     fetcher.loadData(Priority.HIGH, callback);
     assertNotNull(callback.exception);
   }
 
-  private class CallBack implements DataFetcher.DataCallback<Object> {
+  private static final class CallBack implements DataFetcher.DataCallback<Object> {
 
     public Object data;
     public Exception exception;
@@ -128,7 +128,7 @@ public void onDataReady(@Nullable Object data) {
     }
 
     @Override
-    public void onLoadFailed(Exception e) {
+    public void onLoadFailed(@NonNull Exception e) {
       this.exception = e;
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java
similarity index 90%
rename from library/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java
index 2548b0e59..6bc1ddd29 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.model;
 
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.mockito.Mockito.mock;
 
@@ -87,6 +88,16 @@ public void testIssue133() throws MalformedURLException {
     assertEquals(escaped, glideUrlFromEscapedUrl.toURL().toString());
   }
 
+  @Test
+  public void issue_2583() throws MalformedURLException {
+    String original =
+        "http://api.met.no/weatherapi/weathericon/1.1/?symbol=9;content_type=image/png";
+
+    GlideUrl glideUrl = new GlideUrl(original);
+    assertThat(glideUrl.toURL().toString()).isEqualTo(original);
+    assertThat(glideUrl.toStringUrl()).isEqualTo(original);
+  }
+
   @Test
   public void testEquals() throws MalformedURLException {
     Headers headers = mock(Headers.class);
diff --git a/library/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
diff --git a/library/src/test/java/com/bumptech/glide/load/model/ModelCacheTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/ModelCacheTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/load/model/ModelCacheTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/ModelCacheTest.java
diff --git a/library/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java
similarity index 92%
rename from library/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java
index b6acd775c..f80441cfb 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java
@@ -23,28 +23,29 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
+// containsExactly produces a spurious warning.
+@SuppressWarnings("ResultOfMethodCallIgnored")
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class MultiModelLoaderFactoryTest {
+  @Rule public final ExpectedException exception = ExpectedException.none();
 
-  @Mock ModelLoaderFactory<String, String> firstFactory;
-  @Mock ModelLoader<String, String> firstModelLoader;
-  @Mock MultiModelLoaderFactory.Factory multiModelLoaderFactory;
-  @Mock ModelLoaderFactory<String, String> secondFactory;
-  @Mock ModelLoader<String, String> secondModelLoader;
+  @Mock private ModelLoaderFactory<String, String> firstFactory;
+  @Mock private ModelLoader<String, String> firstModelLoader;
+  @Mock private MultiModelLoaderFactory.Factory multiModelLoaderFactory;
+  @Mock private ModelLoaderFactory<String, String> secondFactory;
+  @Mock private ModelLoader<String, String> secondModelLoader;
 
-  @Rule public ExpectedException exception = ExpectedException.none();
-
-  private Pool<List<Exception>> exceptionListPool;
+  private Pool<List<Throwable>> throwableListPool;
   private MultiModelLoaderFactory multiFactory;
 
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
-    exceptionListPool = FactoryPools.threadSafeList();
+    throwableListPool = FactoryPools.threadSafeList();
 
-    multiFactory = new MultiModelLoaderFactory(exceptionListPool,
-        multiModelLoaderFactory);
+    multiFactory =
+        new MultiModelLoaderFactory(throwableListPool, multiModelLoaderFactory);
     when(firstFactory.build(eq(multiFactory))).thenReturn(firstModelLoader);
     when(secondFactory.build(eq(multiFactory))).thenReturn(secondModelLoader);
   }
@@ -104,7 +105,7 @@ public void testReplace_returnsPreviouslyRegisteredFactories_withModelAndDataCla
     multiFactory.append(String.class, String.class, firstOtherFactory);
     multiFactory.append(String.class, String.class, secondOtherFactory);
 
-    List<ModelLoaderFactory<String, String>> removed =
+    List<ModelLoaderFactory<? extends String, ? extends String>> removed =
         multiFactory.replace(String.class, String.class, firstFactory);
     assertThat(removed).containsExactly(firstOtherFactory, secondOtherFactory);
   }
@@ -126,7 +127,7 @@ public void testRemove_returnsPreviouslyRegisteredFactories_withModelAndDataClas
     multiFactory.append(String.class, String.class, other);
     multiFactory.append(String.class, String.class, firstFactory);
 
-    List<ModelLoaderFactory<String, String>> removed =
+    List<ModelLoaderFactory<? extends String, ? extends String>> removed =
         multiFactory.remove(String.class, String.class);
     assertThat(removed).containsExactly(firstFactory, other);
   }
@@ -268,13 +269,11 @@ public void testBuild_respectsPrependOrder() {
       Class<Y> dataClass) {
     ArgumentCaptor<List<ModelLoader<X, Y>>> captor = Util.cast(ArgumentCaptor.forClass(List.class));
     multiFactory.build(modelClass, dataClass);
-    verify(multiModelLoaderFactory).build(captor.capture(), eq(exceptionListPool));
+    verify(multiModelLoaderFactory).build(captor.capture(), eq(throwableListPool));
 
     List<ModelLoader<X, Y>> captured = captor.getValue();
     List<ModelLoader<X, Y>> result = new ArrayList<>(captured.size());
-    for (ModelLoader<X, Y> modelLoader : captured) {
-      result.add(modelLoader);
-    }
+    result.addAll(captured);
     return result;
   }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java
similarity index 86%
rename from library/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java
index a5038c23a..ec2c1831e 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java
@@ -14,6 +14,7 @@
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.util.Preconditions;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -30,9 +31,9 @@
 @Config(manifest = Config.NONE, sdk = 18)
 public class ResourceLoaderTest {
 
-  @Mock ModelLoader<Uri, Object> uriLoader;
-  @Mock DataFetcher<Object> fetcher;
-  @Mock Key key;
+  @Mock private ModelLoader<Uri, Object> uriLoader;
+  @Mock private DataFetcher<Object> fetcher;
+  @Mock private Key key;
   private Options options;
 
   private ResourceLoader<Object> loader;
@@ -53,7 +54,9 @@ public void testCanHandleId() {
         .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
 
     assertTrue(loader.handles(id));
-    assertEquals(fetcher, loader.buildLoadData(id, 100, 100, new Options()).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(loader.buildLoadData(id, 100, 100, new Options())).fetcher);
   }
 
     @Test
diff --git a/library/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java
similarity index 81%
rename from library/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java
index 3eecb3718..07dd655dc 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java
@@ -30,17 +30,21 @@ public void setUp() {
 
   @After
   public void tearDown() {
-    file.delete();
+    // GC before delete() to release files on Windows (https://stackoverflow.com/a/4213208/253468)
+    System.gc();
+    if (!file.delete()) {
+      throw new IllegalStateException("Failed to delete: " + file);
+    }
   }
 
   @Test
   public void testWritesDataFromInputStreamToOutputStream() throws IOException {
     String fakeData = "SomeRandomFakeData";
-    ByteArrayInputStream is = new ByteArrayInputStream(fakeData.getBytes());
+    ByteArrayInputStream is = new ByteArrayInputStream(fakeData.getBytes("UTF-8"));
     encoder.encode(is, file, new Options());
 
     byte[] data = ByteBufferUtil.toBytes(ByteBufferUtil.fromFile(file));
 
-    assertEquals(fakeData, new String(data));
+    assertEquals(fakeData, new String(data, "UTF-8"));
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java
similarity index 72%
rename from library/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java
index 42bc40545..b6554eabf 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java
@@ -13,8 +13,8 @@
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.tests.Util;
+import com.bumptech.glide.util.Preconditions;
 import java.io.File;
-import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -33,15 +33,15 @@
   // Not a magic number, just an arbitrary non zero value.
   private static final int IMAGE_SIDE = 100;
 
-  @Mock ModelLoader<Uri, Object> uriLoader;
-  @Mock DataFetcher<Object> fetcher;
-  @Mock Key key;
+  @Mock private ModelLoader<Uri, Object> uriLoader;
+  @Mock private DataFetcher<Object> fetcher;
+  @Mock private Key key;
 
   private StringLoader<Object> loader;
   private Options options;
 
   @Before
-  public void setUp() throws Exception {
+  public void setUp() {
     MockitoAnnotations.initMocks(this);
 
     options = new Options();
@@ -50,9 +50,9 @@ public void setUp() throws Exception {
   }
 
   @Test
-  public void testHandlesPaths() throws IOException {
-    // TODO on windows it will fail with schema being the drive letter (C:\... -> C)
-    assumeTrue(!Util.isWindows());
+  public void testHandlesPaths() {
+    // TODO fix drive letter parsing somehow
+    assumeTrue("it will fail with schema being the drive letter (C:\\... -> C)", !Util.isWindows());
 
     File f = RuntimeEnvironment.application.getCacheDir();
     Uri expected = Uri.fromFile(f);
@@ -60,14 +60,14 @@ public void testHandlesPaths() throws IOException {
         .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
 
     assertTrue(loader.handles(f.getAbsolutePath()));
-    assertEquals(fetcher,
-        loader.buildLoadData(f.getAbsolutePath(), IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(
+            loader.buildLoadData(f.getAbsolutePath(), IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
   }
 
   @Test
   public void testCanHandleComplexFilePaths() {
-    assumeTrue(!Util.isWindows());
-
     String testPath =
         "/storage/emulated/0/DCIM/Camera/IMG_20140520_100001:nopm:.jpg,mimeType=image/jpeg,"
             + "2448x3264,orientation=0,date=Tue";
@@ -76,11 +76,14 @@ public void testCanHandleComplexFilePaths() {
         .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
 
     assertTrue(loader.handles(testPath));
-    assertEquals(fetcher, loader.buildLoadData(testPath, IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(
+            loader.buildLoadData(testPath, IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
   }
 
   @Test
-  public void testHandlesFileUris() throws IOException {
+  public void testHandlesFileUris() {
     File f = RuntimeEnvironment.application.getCacheDir();
 
     Uri expected = Uri.fromFile(f);
@@ -88,20 +91,24 @@ public void testHandlesFileUris() throws IOException {
         .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
 
     assertTrue(loader.handles(f.getAbsolutePath()));
-    assertEquals(fetcher,
-        loader.buildLoadData(expected.toString(), IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(
+            loader.buildLoadData(expected.toString(), IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
   }
 
   @Test
-  public void testHandlesResourceUris() throws IOException {
+  public void testHandlesResourceUris() {
     Uri resourceUri = Uri.parse("android.resource://com.bumptech.glide.tests/raw/ic_launcher");
 
     when(uriLoader.buildLoadData(eq(resourceUri), eq(IMAGE_SIDE), eq(IMAGE_SIDE), eq(options)))
         .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
 
     assertTrue(loader.handles(resourceUri.toString()));
-    assertEquals(fetcher,
-        loader.buildLoadData(resourceUri.toString(), IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(
+            loader.buildLoadData(resourceUri.toString(), IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
   }
 
   @Test
@@ -113,7 +120,10 @@ public void testHandlesHttp() {
         .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
 
     assertTrue(loader.handles(url));
-    assertEquals(fetcher, loader.buildLoadData(url, IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(
+            loader.buildLoadData(url, IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
   }
 
   @Test
@@ -125,7 +135,10 @@ public void testHandlesHttps() {
         .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
 
     assertTrue(loader.handles(url));
-    assertEquals(fetcher, loader.buildLoadData(url, IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(
+            loader.buildLoadData(url, IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
   }
 
   @Test
@@ -137,7 +150,10 @@ public void testHandlesContent() {
         .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
 
     assertTrue(loader.handles(content));
-    assertEquals(fetcher, loader.buildLoadData(content, IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(
+            loader.buildLoadData(content, IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java
similarity index 73%
rename from library/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java
index 846ed783c..b7a4f3859 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java
@@ -8,6 +8,7 @@
 import android.net.Uri;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.util.Preconditions;
 import java.io.File;
 import java.io.IOException;
 import org.junit.Before;
@@ -27,8 +28,8 @@
   // Not a magic number, just arbitrary non zero.
   private static final int IMAGE_SIDE = 120;
 
-  @Mock DataFetcher<Object> localUriFetcher;
-  @Mock UriLoader.LocalUriFetcherFactory<Object> factory;
+  @Mock private DataFetcher<Object> localUriFetcher;
+  @Mock private UriLoader.LocalUriFetcherFactory<Object> factory;
   private UriLoader<Object> loader;
   private Options options;
 
@@ -46,8 +47,10 @@ public void testHandlesFileUris() throws IOException {
     when(factory.build(eq(fileUri))).thenReturn(localUriFetcher);
 
     assertTrue(loader.handles(fileUri));
-    assertEquals(localUriFetcher,
-        loader.buildLoadData(fileUri, IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+    assertEquals(
+        localUriFetcher,
+        Preconditions.checkNotNull(
+            loader.buildLoadData(fileUri, IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
   }
 
   @Test
@@ -56,8 +59,10 @@ public void testHandlesResourceUris() throws IOException {
     when(factory.build(eq(resourceUri))).thenReturn(localUriFetcher);
 
     assertTrue(loader.handles(resourceUri));
-    assertEquals(localUriFetcher,
-        loader.buildLoadData(resourceUri, IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+    assertEquals(
+        localUriFetcher,
+        Preconditions.checkNotNull(
+            loader.buildLoadData(resourceUri, IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
   }
 
   @Test
@@ -66,7 +71,9 @@ public void testHandlesContentUris() {
     when(factory.build(eq(contentUri))).thenReturn(localUriFetcher);
 
     assertTrue(loader.handles(contentUri));
-    assertEquals(localUriFetcher, loader.buildLoadData(contentUri, IMAGE_SIDE, IMAGE_SIDE,
-        options).fetcher);
+    assertEquals(
+        localUriFetcher,
+        Preconditions.checkNotNull(
+            loader.buildLoadData(contentUri, IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java
similarity index 79%
rename from library/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java
index 0c87d5f1b..e635b01a2 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java
@@ -9,12 +9,14 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelCache;
 import com.bumptech.glide.load.model.ModelLoader;
+import com.bumptech.glide.util.Preconditions;
 import java.io.InputStream;
 import org.junit.Before;
 import org.junit.Test;
@@ -30,9 +32,9 @@
 @Config(manifest = Config.NONE, sdk = 18)
 public class BaseGlideUrlLoaderTest {
 
-  @Mock ModelCache<Object, GlideUrl> modelCache;
-  @Mock ModelLoader<GlideUrl, InputStream> wrapped;
-  @Mock DataFetcher<InputStream> fetcher;
+  @Mock private ModelCache<Object, GlideUrl> modelCache;
+  @Mock private ModelLoader<GlideUrl, InputStream> wrapped;
+  @Mock private DataFetcher<InputStream> fetcher;
   private TestLoader urlLoader;
   private Options options;
 
@@ -68,7 +70,9 @@ public void testReturnsUrlFromCacheIfPresent() {
     when(wrapped.buildLoadData(eq(expectedUrl), eq(width), eq(height), eq(options)))
         .thenReturn(new ModelLoader.LoadData<>(mock(Key.class), fetcher));
 
-    assertEquals(fetcher, urlLoader.buildLoadData(model, width, height, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(urlLoader.buildLoadData(model, width, height, options)).fetcher);
   }
 
   @Test
@@ -80,16 +84,18 @@ public void testBuildsNewUrlIfNotPresentInCache() {
     when(wrapped.buildLoadData(any(GlideUrl.class), eq(width), eq(height), eq(options)))
         .thenAnswer(new Answer<ModelLoader.LoadData<InputStream>>() {
           @Override
-          public ModelLoader.LoadData<InputStream> answer(InvocationOnMock invocationOnMock)
-              throws Throwable {
+          public ModelLoader.LoadData<InputStream> answer(InvocationOnMock invocationOnMock) {
             GlideUrl glideUrl = (GlideUrl) invocationOnMock.getArguments()[0];
             assertEquals(urlLoader.resultUrl, glideUrl.toStringUrl());
             return new ModelLoader.LoadData<>(mock(Key.class), fetcher);
 
           }
         });
-    assertEquals(fetcher,
-        urlLoader.buildLoadData(new GlideUrl(urlLoader.resultUrl), width, height, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(
+            urlLoader.buildLoadData(
+                new GlideUrl(urlLoader.resultUrl), width, height, options)).fetcher);
   }
 
   @Test
@@ -101,7 +107,7 @@ public void testAddsNewUrlToCacheIfNotPresentInCache() {
 
     doAnswer(new Answer<Void>() {
       @Override
-      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) {
         GlideUrl glideUrl = (GlideUrl) invocationOnMock.getArguments()[3];
         assertEquals(urlLoader.resultUrl, glideUrl.toStringUrl());
         return null;
@@ -124,13 +130,16 @@ public void testDoesNotInteractWithModelCacheIfNull() {
     when(wrapped.buildLoadData(any(GlideUrl.class), eq(width), eq(height), eq(options)))
         .thenReturn(new ModelLoader.LoadData<>(mock(Key.class), fetcher));
 
-    assertEquals(fetcher, urlLoader.buildLoadData(new Object(), width, height, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(
+            urlLoader.buildLoadData(new Object(), width, height, options)).fetcher);
   }
 
-  private class TestLoader extends BaseGlideUrlLoader<Object> {
-    public String resultUrl;
+  private static final class TestLoader extends BaseGlideUrlLoader<Object> {
+    String resultUrl;
 
-    public TestLoader(ModelLoader<GlideUrl, InputStream> concreteLoader,
+    TestLoader(ModelLoader<GlideUrl, InputStream> concreteLoader,
         ModelCache<Object, GlideUrl> modelCache) {
       super(concreteLoader, modelCache);
     }
@@ -141,7 +150,7 @@ protected String getUrl(Object model, int width, int height, Options options) {
     }
 
     @Override
-    public boolean handles(Object model) {
+    public boolean handles(@NonNull Object model) {
       return true;
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java
similarity index 84%
rename from library/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java
index 92efc86ce..e46c95fcd 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java
@@ -7,6 +7,7 @@
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.HttpUrlFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.util.Preconditions;
 import java.io.InputStream;
 import org.junit.Before;
 import org.junit.Test;
@@ -29,7 +30,8 @@ public void setUp() {
 
   @Test
   public void testReturnsValidFetcher() {
-    DataFetcher<InputStream> result = loader.buildLoadData(model, 100, 100, new Options()).fetcher;
+    DataFetcher<InputStream> result =
+        Preconditions.checkNotNull(loader.buildLoadData(model, 100, 100, new Options())).fetcher;
     assertThat(result).isInstanceOf(HttpUrlFetcher.class);
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java
similarity index 97%
rename from library/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java
index 92dae6dbb..5abc0b23d 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java
@@ -24,7 +24,7 @@
   private static final int IMAGE_SIDE = 100;
   private static final Options OPTIONS = new Options();
 
-  @Mock ModelLoader<GlideUrl, InputStream> urlLoader;
+  @Mock private ModelLoader<GlideUrl, InputStream> urlLoader;
   private HttpUriLoader loader;
 
   @Before
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/SimpleResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/SimpleResourceTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/load/resource/SimpleResourceTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/SimpleResourceTest.java
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
similarity index 75%
rename from library/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
index d5dc77761..087c606d3 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
@@ -9,11 +9,12 @@
 import android.app.Application;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.KeyTester;
 import com.bumptech.glide.tests.Util;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -21,6 +22,7 @@
 
 @RunWith(JUnit4.class)
 public class UnitTransformationTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
 
   private Application app;
 
@@ -37,12 +39,17 @@ public void testReturnsGivenResource() {
   }
 
   @Test
-  public void testEquals() throws NoSuchAlgorithmException {
-    KeyAssertions.assertSame(UnitTransformation.get(), UnitTransformation.get());
-
+  public void testEqualsHashCodeDigest() throws NoSuchAlgorithmException {
     @SuppressWarnings("unchecked") Transformation<Object> other = mock(Transformation.class);
     doAnswer(new Util.WriteDigest("other")).when(other)
         .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertDifferent(UnitTransformation.get(), other);
+
+    keyTester
+        .addEquivalenceGroup(
+            UnitTransformation.get(),
+            UnitTransformation.get())
+        .addEquivalenceGroup(other)
+        .addEmptyDigestRegressionTest(UnitTransformation.get())
+        .test();
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java
similarity index 90%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java
index c65b03707..7fdd33f3c 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java
@@ -54,10 +54,10 @@ public void testBitmapIsReturnedToPoolOnRecycle() {
   }
 
   private static class BitmapDrawableResourceHarness {
-    BitmapPool bitmapPool = mock(BitmapPool.class);
-    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    final BitmapPool bitmapPool = mock(BitmapPool.class);
+    final Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
 
-    public BitmapDrawableResource create() {
+    BitmapDrawableResource create() {
       return new BitmapDrawableResource(
           new BitmapDrawable(RuntimeEnvironment.application.getResources(), bitmap), bitmapPool);
     }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java
similarity index 84%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java
index b5fa17830..2daa5979b 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java
@@ -18,12 +18,13 @@
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.KeyTester;
 import com.bumptech.glide.tests.Util;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
@@ -37,12 +38,13 @@
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
+@SuppressWarnings("deprecation")
 public class BitmapDrawableTransformationTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
 
-  @Mock BitmapPool bitmapPool;
-  @Mock Transformation<Bitmap> wrapped;
-  @Mock Resource<BitmapDrawable> drawableResourceToTransform;
-  @Mock BitmapDrawable drawableToTransform;
+  @Mock private BitmapPool bitmapPool;
+  @Mock private Transformation<Bitmap> wrapped;
+  @Mock private Resource<BitmapDrawable> drawableResourceToTransform;
 
   private BitmapDrawableTransformation transformation;
   private Bitmap bitmapToTransform;
@@ -52,11 +54,11 @@
   public void setUp() {
     MockitoAnnotations.initMocks(this);
     bitmapToTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    BitmapDrawable drawableToTransform = new BitmapDrawable(bitmapToTransform);
 
     context = RuntimeEnvironment.application;
-    Glide.init(new GlideBuilder().setBitmapPool(bitmapPool).build(context));
+    Glide.init(context, new GlideBuilder().setBitmapPool(bitmapPool));
     when(drawableResourceToTransform.get()).thenReturn(drawableToTransform);
-    when(drawableToTransform.getBitmap()).thenReturn(bitmapToTransform);
     transformation = new BitmapDrawableTransformation(wrapped);
   }
 
@@ -124,11 +126,18 @@ public void testProvidesBitmapFromGivenResourceToWrappedTransformation() {
   public void testEquals() throws NoSuchAlgorithmException {
     doAnswer(new Util.WriteDigest("wrapped")).when(wrapped)
         .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertSame(transformation, new BitmapDrawableTransformation(wrapped));
-
     @SuppressWarnings("unchecked") Transformation<Bitmap> other = mock(Transformation.class);
     doAnswer(new Util.WriteDigest("other")).when(other)
         .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertDifferent(transformation, new BitmapDrawableTransformation(other));
+
+    keyTester
+        .addEquivalenceGroup(
+            transformation,
+            new BitmapDrawableTransformation(wrapped))
+        .addEquivalenceGroup(new BitmapDrawableTransformation(other))
+        .addEquivalenceGroup(wrapped)
+        .addRegressionTest(
+            transformation, "adbf45b08ad6468aa147e5b2a23758ef56ab631a2b70ad52501ca358441a34f3")
+        .test();
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
similarity index 74%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
index 876a2bdef..68d4a56c3 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
@@ -6,12 +6,12 @@
 import static org.junit.Assert.assertTrue;
 import static org.mockito.Mockito.when;
 
-import android.annotation.TargetApi;
 import android.graphics.Bitmap;
-import android.os.Build;
 import com.bumptech.glide.load.EncodeStrategy;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
 import com.bumptech.glide.util.ByteBufferUtil;
 import java.io.File;
 import java.io.IOException;
@@ -57,7 +57,6 @@ public void testBitmapIsEncodedWithGivenQuality() throws IOException {
   }
 
   @Test
-  @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
   public void testEncoderObeysNonNullCompressFormat() throws IOException {
     Bitmap.CompressFormat format = Bitmap.CompressFormat.WEBP;
     harness.setFormat(format);
@@ -89,13 +88,13 @@ public void testEncoderEncodesPngWithNullFormatAndBitmapWithAlpha() throws IOExc
 
   @Test
   public void testReturnsTrueFromWrite() {
-    BitmapEncoder encoder = new BitmapEncoder();
+    BitmapEncoder encoder = new BitmapEncoder(harness.arrayPool);
     assertTrue(encoder.encode(harness.resource, harness.file, harness.options));
   }
 
   @Test
   public void testEncodeStrategy_alwaysReturnsTransformed() {
-    BitmapEncoder encoder = new BitmapEncoder();
+    BitmapEncoder encoder = new BitmapEncoder(harness.arrayPool);
     assertEquals(EncodeStrategy.TRANSFORMED, encoder.getEncodeStrategy(harness.options));
   }
 
@@ -104,32 +103,37 @@ private static void assertContains(String string, String expected) {
   }
 
   private static class EncoderHarness {
-    Resource<Bitmap> resource = mockResource();
-    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    Options options = new Options();
-    File file = new File(RuntimeEnvironment.application.getCacheDir(), "test");
+    final Resource<Bitmap> resource = mockResource();
+    final Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    final Options options = new Options();
+    final File file = new File(RuntimeEnvironment.application.getCacheDir(), "test");
+    final ArrayPool arrayPool = new LruArrayPool();
 
-    public EncoderHarness() {
+    EncoderHarness() {
       when(resource.get()).thenReturn(bitmap);
     }
 
-    public void setQuality(int quality) {
+    void setQuality(int quality) {
       options.set(BitmapEncoder.COMPRESSION_QUALITY, quality);
     }
 
-    public void setFormat(Bitmap.CompressFormat format) {
+    void setFormat(Bitmap.CompressFormat format) {
       options.set(BitmapEncoder.COMPRESSION_FORMAT, format);
     }
 
-    public String encode() throws IOException {
-      BitmapEncoder encoder = new BitmapEncoder();
+    String encode() throws IOException {
+      BitmapEncoder encoder = new BitmapEncoder(arrayPool);
       encoder.encode(resource, file, options);
       byte[] data = ByteBufferUtil.toBytes(ByteBufferUtil.fromFile(file));
-      return new String(data);
+      return new String(data, "UTF-8");
     }
 
-    public void tearDown() {
-      file.delete();
+    void tearDown() {
+      // GC before delete() to release files on Windows (https://stackoverflow.com/a/4213208/253468)
+      System.gc();
+      if (file.exists() && !file.delete()) {
+        throw new IllegalStateException("Failed to delete: " + file);
+      }
     }
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java
similarity index 90%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java
index cb567b21f..60f360b16 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java
@@ -69,8 +69,8 @@ public void testThrowsIfBitmapAndBitmapPoolAreNull() {
   }
 
   private static class BitmapResourceHarness {
-    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    BitmapPool bitmapPool = mock(BitmapPool.class);
-    BitmapResource resource = new BitmapResource(bitmap, bitmapPool);
+    final Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    final BitmapPool bitmapPool = mock(BitmapPool.class);
+    final BitmapResource resource = new BitmapResource(bitmap, bitmapPool);
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
similarity index 89%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
index d7d22f0c3..cb7bd2e99 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
@@ -38,7 +38,7 @@ public void setUp() {
     MockitoAnnotations.initMocks(this);
     context = RuntimeEnvironment.application;
 
-    Glide.init(new GlideBuilder().setBitmapPool(bitmapPool).build(context));
+    Glide.init(context, new GlideBuilder().setBitmapPool(bitmapPool));
   }
 
   @After
@@ -50,7 +50,7 @@ public void tearDown() {
   public void testReturnsGivenResourceWhenBitmapNotTransformed() {
     BitmapTransformation transformation = new BitmapTransformation() {
       @Override
-      public void updateDiskCacheKey(MessageDigest messageDigest) { }
+      public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) { }
 
       @Override
       protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform,
@@ -68,7 +68,7 @@ public void testReturnsNewResourceWhenBitmapTransformed() {
     final Bitmap transformed = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
     BitmapTransformation transformation = new BitmapTransformation() {
       @Override
-      public void updateDiskCacheKey(MessageDigest messageDigest) { }
+      public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) { }
 
       @Override
       protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap bitmap, int outWidth,
@@ -88,7 +88,7 @@ public void testPassesGivenArgumentsToTransform() {
     final Resource<Bitmap> resource = mockResource(223, 4123);
     BitmapTransformation transformation = new BitmapTransformation() {
       @Override
-      public void updateDiskCacheKey(MessageDigest messageDigest) { }
+      public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) { }
 
       @Override
       protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform,
@@ -109,7 +109,7 @@ public void testThrowsIfGivenInvalidWidth() {
     BitmapTransformation transformation = new BitmapTransformation() {
 
       @Override
-      public void updateDiskCacheKey(MessageDigest messageDigest) { }
+      public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) { }
 
       @Override
       protected Bitmap transform(@NonNull BitmapPool bitmapPool, @NonNull Bitmap toTransform,
@@ -125,7 +125,7 @@ public void testThrowsIfGivenInvalidHeight() {
     BitmapTransformation transformation = new BitmapTransformation() {
 
       @Override
-      public void updateDiskCacheKey(MessageDigest messageDigest) { }
+      public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) { }
 
       @Override
       protected Bitmap transform(@NonNull BitmapPool bitmapPool, @NonNull Bitmap toTransform,
@@ -142,7 +142,7 @@ public void testReturnsNullIfTransformReturnsNull() {
     BitmapTransformation transform = new BitmapTransformation() {
 
       @Override
-      public void updateDiskCacheKey(MessageDigest messageDigest) {  }
+      public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {  }
 
       @Override
       protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform,
@@ -184,7 +184,7 @@ public void testCallsTransformWithGivenBitmapHeightIfHeightIsSizeOriginal() {
     return resource;
   }
 
-  private class SizeTrackingTransform extends BitmapTransformation {
+  private static final class SizeTrackingTransform extends BitmapTransformation {
     int givenWidth;
     int givenHeight;
 
@@ -197,6 +197,6 @@ protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform
     }
 
     @Override
-    public void updateDiskCacheKey(MessageDigest messageDigest) { }
+    public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) { }
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
similarity index 88%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
index a421660e0..d36b44ebd 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
@@ -18,12 +18,13 @@
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.KeyTester;
 import com.bumptech.glide.tests.Util;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
@@ -36,9 +37,10 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class CenterCropTest {
-  @Mock Resource<Bitmap> resource;
-  @Mock BitmapPool pool;
-  @Mock Transformation<Bitmap> transformation;
+  @Rule public final KeyTester keyTester = new KeyTester();
+  @Mock private Resource<Bitmap> resource;
+  @Mock private BitmapPool pool;
+  @Mock private Transformation<Bitmap> transformation;
 
   private CenterCrop centerCrop;
   private int bitmapWidth;
@@ -57,7 +59,7 @@ public void setUp() {
     when(pool.get(anyInt(), anyInt(), any(Bitmap.Config.class)))
         .thenAnswer(new Util.CreateBitmap());
     context = RuntimeEnvironment.application;
-    Glide.init(new GlideBuilder().setBitmapPool(pool).build(context));
+    Glide.init(context, new GlideBuilder().setBitmapPool(pool));
 
     centerCrop = new CenterCrop();
   }
@@ -147,10 +149,16 @@ public void testReturnsBitmapWithExactlyGivenDimensionsIfBitmapIsSmallerThanTarg
 
   @Test
   public void testEquals() throws NoSuchAlgorithmException {
-    KeyAssertions.assertSame(centerCrop, new CenterCrop());
-
     doAnswer(new Util.WriteDigest("other")).when(transformation)
         .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertDifferent(centerCrop, transformation);
+    keyTester
+        .addEquivalenceGroup(
+            new CenterCrop(),
+            new CenterCrop())
+        .addEquivalenceGroup(
+            transformation)
+        .addRegressionTest(
+            new CenterCrop(), "68bd5819c42b37efbe7124bb851443a6388ee3e2e9034213da6eaa15381d3457")
+        .test();
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java
similarity index 85%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java
index ebb4129a8..ba0f059f1 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java
@@ -19,12 +19,13 @@
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
-import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.KeyTester;
 import com.bumptech.glide.tests.Util;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
@@ -39,9 +40,10 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = { CenterInsideTest.DrawNothingCanvas.class })
 public class CenterInsideTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
 
-  @Mock Resource<Bitmap> resource;
-  @Mock Transformation<Bitmap> transformation;
+  @Mock private Resource<Bitmap> resource;
+  @Mock private Transformation<Bitmap> transformation;
   private CenterInside centerInside;
   private int bitmapWidth;
   private int bitmapHeight;
@@ -57,7 +59,7 @@ public void setUp() {
 
     context = RuntimeEnvironment.application;
     BitmapPool pool = new BitmapPoolAdapter();
-    Glide.init(new GlideBuilder().setBitmapPool(pool).build(context));
+    Glide.init(context, new GlideBuilder().setBitmapPool(pool));
 
     centerInside = new CenterInside();
   }
@@ -108,11 +110,18 @@ public void testDoesNotRecycleGivenResource() {
 
   @Test
   public void testEquals() throws NoSuchAlgorithmException {
-    KeyAssertions.assertSame(centerInside, new CenterInside());
-
     doAnswer(new Util.WriteDigest("other")).when(transformation)
         .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertDifferent(centerInside, transformation);
+
+    keyTester
+        .addEquivalenceGroup(
+            new CenterInside(),
+            new CenterInside(),
+            centerInside)
+        .addEquivalenceGroup(transformation)
+        .addRegressionTest(
+            new CenterInside(), "acf83850a2e8e9e809c8bfb999e2aede9e932cb897a15367fac9856b96f3ba33")
+    .test();
   }
 
   @Implements(Canvas.class)
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java
similarity index 86%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java
index 740472103..d93bc231c 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java
@@ -3,6 +3,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
+import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
 import android.content.Context;
@@ -13,10 +14,13 @@
 import android.graphics.Rect;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.GlideBuilder;
+import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.tests.KeyTester;
 import com.bumptech.glide.tests.Util;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
@@ -28,6 +32,7 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE)
 public class CircleCropTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
   @Mock private BitmapPool bitmapPool;
 
   private CircleCrop circleCrop;
@@ -38,7 +43,7 @@ public void setup() {
     when(bitmapPool.get(anyInt(), anyInt(), any(Bitmap.Config.class)))
         .thenAnswer(new Util.CreateBitmap());
     Context context = RuntimeEnvironment.application;
-    Glide.init(new GlideBuilder().setBitmapPool(bitmapPool).build(context));
+    Glide.init(context, new GlideBuilder().setBitmapPool(bitmapPool));
     circleCrop = new CircleCrop();
   }
 
@@ -85,6 +90,16 @@ public void testTransform_withNarrowRectangle() {
     assertSamePixels(expected, result);
   }
 
+  @Test
+  public void testEquals() {
+    keyTester
+        .addEquivalenceGroup(circleCrop, new CircleCrop())
+        .addEquivalenceGroup(mock(Transformation.class))
+        .addRegressionTest(
+            new CircleCrop(), "1442365bcc658f89310e39844ef4be58f4b16e52c283254e5a458020f56acb90")
+        .test();
+  }
+
   private void assertSamePixels(Bitmap expected, Bitmap actual) {
     assertEquals(expected.getWidth(), actual.getWidth());
     assertEquals(expected.getHeight(), actual.getHeight());
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java
similarity index 98%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java
index 40b9bfb7a..4b39cf880 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java
@@ -3,6 +3,7 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.ImageHeaderParser.ImageType;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
@@ -351,7 +352,7 @@ private static void runTest(byte[] data, ParserTestCase test) throws IOException
   private static class SometimesZeroSkipInputStream extends FilterInputStream {
     boolean returnZeroFlag = true;
 
-    protected SometimesZeroSkipInputStream(InputStream in) {
+    SometimesZeroSkipInputStream(InputStream in) {
         super(in);
     }
 
@@ -370,7 +371,7 @@ public long skip(long byteCount) throws IOException {
 
   private static class PartialSkipInputStream extends FilterInputStream {
 
-    protected PartialSkipInputStream(InputStream in) {
+    PartialSkipInputStream(InputStream in) {
         super(in);
     }
 
@@ -386,12 +387,12 @@ public long skip(long byteCount) throws IOException {
 
   private static class PartialReadInputStream extends FilterInputStream {
 
-    protected PartialReadInputStream(InputStream in) {
+    PartialReadInputStream(InputStream in) {
         super(in);
     }
 
     @Override
-    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
+    public int read(@NonNull byte[] buffer, int byteOffset, int byteCount) throws IOException {
         int toActuallyRead = byteCount / 2;
         if (byteCount == 1) {
             toActuallyRead = 1;
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategyTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategyTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategyTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategyTest.java
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformationTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformationTest.java
new file mode 100644
index 000000000..b95fee2ba
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformationTest.java
@@ -0,0 +1,183 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.isA;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Color;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.ColorDrawable;
+import android.graphics.drawable.Drawable;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
+import com.bumptech.glide.load.resource.SimpleResource;
+import com.bumptech.glide.tests.KeyTester;
+import com.bumptech.glide.tests.Util;
+import java.security.MessageDigest;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class DrawableTransformationTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
+  @Mock private Transformation<Bitmap> bitmapTransformation;
+  private BitmapPool bitmapPool;
+  private DrawableTransformation transformation;
+  private Context context;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    transformation = new DrawableTransformation(bitmapTransformation, /*isRequired=*/ true);
+    context = RuntimeEnvironment.application;
+    bitmapPool = new BitmapPoolAdapter();
+    Glide.init(context, new GlideBuilder().setBitmapPool(bitmapPool));
+  }
+
+  @After
+  public void tearDown() {
+    Glide.tearDown();
+  }
+
+  @Test
+  public void transform_withBitmapDrawable_andUnitBitmapTransformation_doesNotRecycle() {
+    when(
+        bitmapTransformation
+            .transform(
+                any(Context.class), anyBitmapResource(), anyInt(), anyInt()))
+        .thenAnswer(new ReturnGivenResource());
+
+    Bitmap bitmap = Bitmap.createBitmap(100, 200, Bitmap.Config.ARGB_8888);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+    @SuppressWarnings("unchecked")
+    Resource<Drawable> input =
+        (Resource<Drawable>) (Resource<?>) new BitmapDrawableResource(drawable, bitmapPool);
+    transformation.transform(context, input, /*outWidth=*/ 100, /*outHeight=*/ 200);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void transform_withBitmapDrawable_andFunctionalBitmapTransformation_doesNotRecycle() {
+    when(bitmapTransformation.transform(
+        any(Context.class), anyBitmapResource(), anyInt(), anyInt()))
+        .thenAnswer(new Answer<Resource<Bitmap>>() {
+          @Override
+          public Resource<Bitmap> answer(InvocationOnMock invocationOnMock) throws Throwable {
+            return BitmapResource.obtain(
+                Bitmap.createBitmap(200, 200, Bitmap.Config.ARGB_8888), bitmapPool);
+          }
+        });
+    Bitmap bitmap = Bitmap.createBitmap(100, 200, Bitmap.Config.ARGB_8888);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+    @SuppressWarnings("unchecked")
+    Resource<Drawable> input =
+        (Resource<Drawable>) (Resource<?>) new BitmapDrawableResource(drawable, bitmapPool);
+    transformation.transform(context, input, /*outWidth=*/ 100, /*outHeight=*/ 200);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void transform_withColorDrawable_andUnitBitmapTransformation_recycles() {
+    bitmapPool = mock(BitmapPool.class);
+    Glide.tearDown();
+    Glide.init(context, new GlideBuilder().setBitmapPool(bitmapPool));
+    when(
+        bitmapTransformation
+            .transform(
+                any(Context.class), anyBitmapResource(), anyInt(), anyInt()))
+        .thenAnswer(new ReturnGivenResource());
+
+    ColorDrawable colorDrawable = new ColorDrawable(Color.RED);
+    final Resource<Drawable> input = new SimpleResource<Drawable>(colorDrawable);
+
+    doAnswer(new Answer<Void>() {
+      @Override
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
+        Bitmap bitmap = (Bitmap) invocationOnMock.getArguments()[0];
+        assertThat(bitmap.getWidth()).isEqualTo(100);
+        assertThat(bitmap.getHeight()).isEqualTo(200);
+        return null;
+      }
+    }).when(bitmapPool).put(any(Bitmap.class));
+    when(bitmapPool.get(anyInt(), anyInt(), any(Bitmap.Config.class)))
+        .thenAnswer(new Answer<Bitmap>() {
+          @Override
+          public Bitmap answer(InvocationOnMock invocationOnMock) throws Throwable {
+            int width = (Integer) invocationOnMock.getArguments()[0];
+            int height = (Integer) invocationOnMock.getArguments()[1];
+            Bitmap.Config config = (Bitmap.Config) invocationOnMock.getArguments()[2];
+            return Bitmap.createBitmap(width, height, config);
+          }
+        });
+
+    transformation.transform(context, input, /*outWidth=*/ 100, /*outHeight=*/ 200);
+
+    verify(bitmapPool).put(isA(Bitmap.class));
+  }
+
+  @Test
+  public void testEquals() {
+    BitmapTransformation otherBitmapTransformation = mock(BitmapTransformation.class);
+    doAnswer(new Util.WriteDigest("bitmapTransformation"))
+        .when(bitmapTransformation).updateDiskCacheKey(any(MessageDigest.class));
+    doAnswer(new Util.WriteDigest("otherBitmapTransformation"))
+        .when(otherBitmapTransformation).updateDiskCacheKey(any(MessageDigest.class));
+
+    keyTester
+        .addEquivalenceGroup(
+            transformation,
+            new DrawableTransformation(bitmapTransformation, /*isRequired=*/ true),
+            new DrawableTransformation(bitmapTransformation, /*isRequired=*/ false))
+        .addEquivalenceGroup(bitmapTransformation)
+        .addEquivalenceGroup(otherBitmapTransformation)
+        .addEquivalenceGroup(
+            new DrawableTransformation(otherBitmapTransformation, /*isRequired=*/ true),
+            new DrawableTransformation(otherBitmapTransformation, /*isRequired=*/ false))
+        .addRegressionTest(
+            new DrawableTransformation(bitmapTransformation, /*isRequired=*/ true),
+            "eddf60c557a6315a489b8a3a19b12439a90381256289fbe9a503afa726230bd9")
+        .addRegressionTest(
+            new DrawableTransformation(otherBitmapTransformation, /*isRequired=*/ false),
+            "40931536ed0ec97c39d4be10c44f5b69a86030ec575317f5a0f17e15a0ea9be8")
+        .test();
+  }
+
+  @SuppressWarnings("unchecked")
+  private static Resource<Bitmap> anyBitmapResource() {
+    return any(Resource.class);
+  }
+
+  private static final class ReturnGivenResource implements Answer<Resource<Bitmap>> {
+
+    @Override
+    public Resource<Bitmap> answer(InvocationOnMock invocationOnMock) throws Throwable {
+      @SuppressWarnings("unchecked")
+      Resource<Bitmap> input = (Resource<Bitmap>) invocationOnMock.getArguments()[1];
+      return input;
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
similarity index 84%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
index 65b073205..39a7bce42 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
@@ -18,12 +18,13 @@
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
-import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.KeyTester;
 import com.bumptech.glide.tests.Util;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
@@ -38,9 +39,10 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = { FitCenterTest.DrawNothingCanvas.class })
 public class FitCenterTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
 
-  @Mock Resource<Bitmap> resource;
-  @Mock Transformation<Bitmap> transformation;
+  @Mock private Resource<Bitmap> resource;
+  @Mock private Transformation<Bitmap> transformation;
   private FitCenter fitCenter;
   private int bitmapWidth;
   private int bitmapHeight;
@@ -56,7 +58,7 @@ public void setUp() {
 
     BitmapPool pool = new BitmapPoolAdapter();
     context = RuntimeEnvironment.application;
-    Glide.init(new GlideBuilder().setBitmapPool(pool).build(context));
+    Glide.init(context, new GlideBuilder().setBitmapPool(pool));
 
 
     fitCenter = new FitCenter();
@@ -91,11 +93,14 @@ public void testDoesNotRecycleGivenResource() {
 
   @Test
   public void testEquals() throws NoSuchAlgorithmException {
-    KeyAssertions.assertSame(fitCenter, new FitCenter());
-
     doAnswer(new Util.WriteDigest("other")).when(transformation)
         .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertDifferent(fitCenter, transformation);
+    keyTester
+        .addEquivalenceGroup(fitCenter, new FitCenter(), new FitCenter())
+        .addEquivalenceGroup(transformation)
+        .addRegressionTest(
+            new FitCenter(), "eda03bc6969032145110add4bfe399915897406f4ca3a1a7512d07750e60f90d")
+        .test();
   }
 
   @Implements(Canvas.class)
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResourceTest.java
new file mode 100644
index 000000000..1ad62cac2
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResourceTest.java
@@ -0,0 +1,90 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import com.bumptech.glide.load.engine.Initializable;
+import com.bumptech.glide.load.engine.Resource;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class LazyBitmapDrawableResourceTest {
+  @Mock private Resource<Bitmap> bitmapResource;
+  private LazyBitmapDrawableResource resource;
+  private Resources resources;
+  private Bitmap bitmap;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
+    bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    when(bitmapResource.get()).thenReturn(bitmap);
+
+    resources = RuntimeEnvironment.application.getResources();
+    resource =
+        (LazyBitmapDrawableResource) LazyBitmapDrawableResource.obtain(resources, bitmapResource);
+  }
+
+  @Test
+  public void obtain_withNullBitmapResource_returnsNull() {
+    assertThat(LazyBitmapDrawableResource.obtain(resources, null)).isNull();
+  }
+
+  @Test
+  public void getSize_returnsSizeOfWrappedResource() {
+    when(bitmapResource.getSize()).thenReturn(100);
+    assertThat(resource.getSize()).isEqualTo(100);
+  }
+
+  @Test
+  public void recycle_callsRecycleOnWrappedResource() {
+    resource.recycle();
+    verify(bitmapResource).recycle();
+  }
+
+  @Test
+  public void recycle_doesNotRecycleWrappedBitmap() {
+    resource.recycle();
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void get_returnsDrawableContainingWrappedBitmap() {
+    BitmapDrawable drawable = resource.get();
+    assertThat(drawable.getBitmap()).isSameAs(bitmap);
+  }
+
+  @Test
+  public void initialize_withNonInitializableResource_doesNothing() {
+    resource.initialize();
+  }
+
+  @Test
+  public void initialize_withWrappedInitializableResource_callsInitializeOnWrapped() {
+    InitializableBitmapResource bitmapResource = mock(InitializableBitmapResource.class);
+    resource =
+        (LazyBitmapDrawableResource) LazyBitmapDrawableResource.obtain(resources, bitmapResource);
+    resource.initialize();
+
+    verify(bitmapResource).initialize();
+  }
+
+  private interface InitializableBitmapResource extends Initializable,
+      Resource<Bitmap> {
+    // Intentionally empty.
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java
similarity index 99%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java
index 3260f51ae..f3dfea93a 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java
@@ -19,6 +19,8 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
+// Not required in tests.
+@SuppressWarnings("ResultOfMethodCallIgnored")
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class RecyclableBufferedInputStreamTest {
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
similarity index 99%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
index ae6264663..effaae7bf 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
@@ -36,7 +36,7 @@
     TransformationUtilsTest.AlphaShadowBitmap.class })
 public class TransformationUtilsTest {
 
-  @Mock BitmapPool bitmapPool;
+  @Mock private BitmapPool bitmapPool;
 
   @Before
   public void setUp() {
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoDecoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoDecoderTest.java
new file mode 100644
index 000000000..ab3ebc56a
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoDecoderTest.java
@@ -0,0 +1,151 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.anyLong;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.graphics.Bitmap;
+import android.media.MediaMetadataRetriever;
+import android.os.Build;
+import android.os.ParcelFileDescriptor;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.tests.Util;
+import com.bumptech.glide.util.Preconditions;
+import java.io.IOException;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 27)
+public class VideoDecoderTest {
+  @Mock private ParcelFileDescriptor resource;
+  @Mock private VideoDecoder.MediaMetadataRetrieverFactory factory;
+  @Mock private VideoDecoder.MediaMetadataRetrieverInitializer<ParcelFileDescriptor> initializer;
+  @Mock private MediaMetadataRetriever retriever;
+  @Mock private BitmapPool bitmapPool;
+  private VideoDecoder<ParcelFileDescriptor> decoder;
+  private Options options;
+  private int initialSdkVersion;
+
+  @Before
+  public void setup() {
+    MockitoAnnotations.initMocks(this);
+    when(factory.build()).thenReturn(retriever);
+    decoder = new VideoDecoder<>(bitmapPool, initializer, factory);
+    options = new Options();
+
+    initialSdkVersion = Build.VERSION.SDK_INT;
+  }
+
+  @After
+  public void tearDown() {
+    Util.setSdkVersionInt(initialSdkVersion);
+  }
+
+  @Test
+  public void testReturnsRetrievedFrameForResource() throws IOException {
+    Util.setSdkVersionInt(19);
+    Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    when(retriever.getFrameAtTime(VideoDecoder.DEFAULT_FRAME, VideoDecoder.DEFAULT_FRAME_OPTION))
+        .thenReturn(expected);
+
+    Resource<Bitmap> result =
+        Preconditions.checkNotNull(decoder.decode(resource, 100, 100, options));
+
+    verify(initializer).initialize(retriever, resource);
+    assertEquals(expected, result.get());
+  }
+
+  @Test
+  public void testReleasesMediaMetadataRetriever() throws IOException {
+    Util.setSdkVersionInt(19);
+    decoder.decode(resource, 1, 2, options);
+
+    verify(retriever).release();
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testThrowsExceptionIfCalledWithInvalidFrame() throws IOException {
+    Util.setSdkVersionInt(19);
+    options.set(VideoDecoder.TARGET_FRAME, -5L);
+    new VideoDecoder<>(bitmapPool, initializer, factory).decode(resource, 100, 100, options);
+  }
+
+  @Test
+  public void testSpecifiesThumbnailFrameIfICalledWithFrameNumber() throws IOException {
+    Util.setSdkVersionInt(19);
+    long frame = 5;
+    options.set(VideoDecoder.TARGET_FRAME, frame);
+    decoder = new VideoDecoder<>(bitmapPool, initializer, factory);
+
+    decoder.decode(resource, 100, 100, options);
+
+    verify(retriever).getFrameAtTime(frame, VideoDecoder.DEFAULT_FRAME_OPTION);
+  }
+
+  @Test
+  public void testDoesNotSpecifyThumbnailFrameIfCalledWithoutFrameNumber() throws IOException {
+    Util.setSdkVersionInt(19);
+    decoder = new VideoDecoder<>(bitmapPool, initializer, factory);
+    decoder.decode(resource, 100, 100, options);
+
+    verify(retriever).getFrameAtTime(VideoDecoder.DEFAULT_FRAME, VideoDecoder.DEFAULT_FRAME_OPTION);
+  }
+
+  @Test
+  public void getScaledFrameAtTime() throws IOException {
+    Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    when(retriever.getScaledFrameAtTime(-1, MediaMetadataRetriever.OPTION_CLOSEST_SYNC, 100, 100))
+        .thenReturn(expected);
+
+    assertThat(decoder.decode(resource, 100, 100, options).get()).isSameAs(expected);
+  }
+
+  @Test
+  public void decodeFrame_withTargetSizeOriginal_onApi27_doesNotThrow() throws IOException {
+    Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    when(retriever.getFrameAtTime(-1, MediaMetadataRetriever.OPTION_CLOSEST_SYNC))
+        .thenReturn(expected);
+
+    verify(retriever, never()).getScaledFrameAtTime(anyLong(), anyInt(), anyInt(), anyInt());
+    assertThat(decoder.decode(resource, Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL, options).get())
+        .isSameAs(expected);
+  }
+
+  @Test
+  public void decodeFrame_withTargetSizeOriginalWidthOnly_onApi27_doesNotThrow()
+      throws IOException {
+    Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    when(retriever.getFrameAtTime(-1, MediaMetadataRetriever.OPTION_CLOSEST_SYNC))
+        .thenReturn(expected);
+
+    verify(retriever, never()).getScaledFrameAtTime(anyLong(), anyInt(), anyInt(), anyInt());
+    assertThat(decoder.decode(resource, Target.SIZE_ORIGINAL, 100, options).get())
+        .isSameAs(expected);
+  }
+
+  @Test
+  public void decodeFrame_withTargetSizeOriginalHeightOnly_onApi27_doesNotThrow()
+      throws IOException {
+    Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    when(retriever.getFrameAtTime(-1, MediaMetadataRetriever.OPTION_CLOSEST_SYNC))
+        .thenReturn(expected);
+
+    verify(retriever, never()).getScaledFrameAtTime(anyLong(), anyInt(), anyInt(), anyInt());
+    assertThat(decoder.decode(resource, 100, Target.SIZE_ORIGINAL, options).get())
+        .isSameAs(expected);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bytes/BytesResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bytes/BytesResourceTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/load/resource/bytes/BytesResourceTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bytes/BytesResourceTest.java
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java
similarity index 85%
rename from library/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java
index 6537c6d43..50af60a7a 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java
@@ -1,6 +1,6 @@
 package com.bumptech.glide.load.resource.drawable;
 
-import static org.junit.Assert.assertEquals;
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertNotEquals;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
@@ -9,6 +9,7 @@
 import android.graphics.Canvas;
 import android.graphics.ColorFilter;
 import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 import org.junit.Before;
 import org.junit.Test;
@@ -26,6 +27,7 @@
   public void setUp() {
     drawable = mock(TestDrawable.class);
     resource = new DrawableResource<TestDrawable>(drawable) {
+      @NonNull
       @Override
       public Class<TestDrawable> getResourceClass() {
         return TestDrawable.class;
@@ -55,15 +57,23 @@ public void testReturnsNewDrawableOnGet() {
     when(constantState.newDrawable()).thenReturn(expected);
     when(drawable.getConstantState()).thenReturn(constantState);
 
-    assertEquals(expected, resource.get());
+    assertThat(resource.get()).isEqualTo(expected);
 
     verify(drawable).getConstantState();
     verify(constantState).newDrawable();
   }
 
+  @Test
+  public void get_withNullState_returnsOriginalDrawable() {
+    when(drawable.getConstantState()).thenReturn(null);
+
+    assertThat(resource.get()).isEqualTo(drawable);
+  }
+
   @Test(expected = NullPointerException.class)
   public void testThrowsIfDrawableIsNull() {
     new DrawableResource<TestDrawable>(null) {
+      @NonNull
       @Override
       public Class<TestDrawable> getResourceClass() {
         return TestDrawable.class;
@@ -86,7 +96,7 @@ public void recycle() {
    */
   private static class TestDrawable extends Drawable {
     @Override
-    public void draw(Canvas canvas) {
+    public void draw(@NonNull Canvas canvas) {
 
     }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java
similarity index 83%
rename from library/src/test/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java
index b1b5f3130..5e2c76048 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java
@@ -4,6 +4,7 @@
 
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.util.Preconditions;
 import java.io.File;
 import java.io.IOException;
 import org.junit.Before;
@@ -26,7 +27,7 @@ public void setUp() {
   @Test
   public void testReturnsGivenFileAsResource() throws IOException {
     File expected = new File("testFile");
-    Resource<File> decoded = decoder.decode(expected, 1, 1, options);
+    Resource<File> decoded = Preconditions.checkNotNull(decoder.decode(expected, 1, 1, options));
 
     assertEquals(expected, decoded.get());
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/file/FileResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/file/FileResourceTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/load/resource/file/FileResourceTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/file/FileResourceTest.java
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
similarity index 90%
rename from library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
index 8c78f1de1..d440630cd 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
@@ -36,17 +36,17 @@
 @Config(manifest = Config.NONE, sdk = 18, shadows = GlideShadowLooper.class)
 public class ByteBufferGifDecoderTest {
   private static final byte[] GIF_HEADER = new byte[] { 0x47, 0x49, 0x46 };
-  static final int ARRAY_POOL_SIZE_BYTES = 4 * 1024 * 1024;
+  private static final int ARRAY_POOL_SIZE_BYTES = 4 * 1024 * 1024;
 
   private ByteBufferGifDecoder decoder;
   private GifHeader gifHeader;
   private Options options;
 
-  @Mock BitmapPool bitmapPool;
-  @Mock GifHeaderParser parser;
-  @Mock GifDecoder gifDecoder;
-  @Mock ByteBufferGifDecoder.GifHeaderParserPool parserPool;
-  @Mock ByteBufferGifDecoder.GifDecoderFactory decoderFactory;
+  @Mock private BitmapPool bitmapPool;
+  @Mock private GifHeaderParser parser;
+  @Mock private GifDecoder gifDecoder;
+  @Mock private ByteBufferGifDecoder.GifHeaderParserPool parserPool;
+  @Mock private ByteBufferGifDecoder.GifDecoderFactory decoderFactory;
 
   @Before
   public void setUp() {
@@ -60,7 +60,7 @@ public void setUp() {
         eq(gifHeader), isA(ByteBuffer.class), anyInt()))
         .thenReturn(gifDecoder);
 
-    List<ImageHeaderParser> parsers = new ArrayList<ImageHeaderParser>();
+    List<ImageHeaderParser> parsers = new ArrayList<>();
     parsers.add(new DefaultImageHeaderParser());
 
     options = new Options();
@@ -86,13 +86,13 @@ public void testHandlesStreamIfContainsGifHeaderAndDisabledIsNotSet() throws IOE
 
   @Test
   public void testHandlesStreamIfContainsGifHeaderAndDisabledIsFalse() throws IOException {
-    options.set(ByteBufferGifDecoder.DISABLE_ANIMATION, false);
+    options.set(GifOptions.DISABLE_ANIMATION, false);
     assertThat(decoder.handles(ByteBuffer.wrap(GIF_HEADER), options)).isTrue();
   }
 
   @Test
   public void testDoesNotHandleStreamIfDisabled() throws IOException {
-    options.set(ByteBufferGifDecoder.DISABLE_ANIMATION, true);
+    options.set(GifOptions.DISABLE_ANIMATION, true);
     assertThat(decoder.handles(ByteBuffer.wrap(GIF_HEADER), options)).isFalse();
   }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
similarity index 90%
rename from library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
index f947b4cc0..1a2187ed6 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
@@ -14,6 +14,7 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.app.Application;
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.Color;
@@ -24,17 +25,21 @@
 import android.graphics.PorterDuffColorFilter;
 import android.graphics.Rect;
 import android.graphics.drawable.Drawable;
+import android.graphics.drawable.TransitionDrawable;
 import android.os.Build;
+import android.view.View;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.gif.GifDrawableTest.BitmapTrackingShadowCanvas;
 import com.bumptech.glide.tests.GlideShadowLooper;
+import com.bumptech.glide.tests.TearDownGlide;
 import com.bumptech.glide.tests.Util;
+import com.bumptech.glide.util.Preconditions;
 import java.util.HashSet;
 import java.util.Set;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
@@ -51,6 +56,8 @@
 @Config(manifest = Config.NONE, sdk = 18,
     shadows = { GlideShadowLooper.class, BitmapTrackingShadowCanvas.class })
 public class GifDrawableTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+
   private GifDrawable drawable;
   private int frameHeight;
   private int frameWidth;
@@ -58,10 +65,10 @@
   private int initialSdkVersion;
 
   @Mock private Drawable.Callback cb;
-  @Mock private BitmapPool bitmapPool;
   @Mock private GifFrameLoader frameLoader;
   @Mock private Paint paint;
   @Mock private Transformation<Bitmap> transformation;
+  private Application context;
 
   private static Paint isAPaint() {
     return isA(Paint.class);
@@ -74,10 +81,11 @@ private static Rect isARect() {
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
+    context = RuntimeEnvironment.application;
     frameWidth = 120;
     frameHeight = 450;
     firstFrame = Bitmap.createBitmap(frameWidth, frameHeight, Bitmap.Config.RGB_565);
-    drawable = new GifDrawable(frameLoader, bitmapPool, paint);
+    drawable = new GifDrawable(frameLoader, paint);
     when(frameLoader.getWidth()).thenReturn(frameWidth);
     when(frameLoader.getHeight()).thenReturn(frameHeight);
     when(frameLoader.getCurrentFrame()).thenReturn(firstFrame);
@@ -91,13 +99,14 @@ public void tearDown() {
     Util.setSdkVersionInt(initialSdkVersion);
   }
 
+  // containsExactly doesn't need its return value checked.
+  @SuppressWarnings("ResultOfMethodCallIgnored")
   @Test
   public void testShouldDrawFirstFrameBeforeAnyFrameRead() {
     Canvas canvas = new Canvas();
     drawable.draw(canvas);
 
-    BitmapTrackingShadowCanvas shadowCanvas =
-        (BitmapTrackingShadowCanvas) Shadow.extract(canvas);
+    BitmapTrackingShadowCanvas shadowCanvas = Shadow.extract(canvas);
     assertThat(shadowCanvas.getDrawnBitmaps()).containsExactly(firstFrame);
   }
 
@@ -335,10 +344,15 @@ public void testReturnsSizeFromFrameLoader() {
   public void testReturnsNewDrawableFromConstantState() {
     Bitmap firstFrame = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
     drawable =
-        new GifDrawable(RuntimeEnvironment.application, mock(GifDecoder.class), bitmapPool,
-            transformation, 100, 100, firstFrame);
-
-    assertNotNull(drawable.getConstantState().newDrawable());
+        new GifDrawable(
+            RuntimeEnvironment.application,
+            mock(GifDecoder.class),
+            transformation,
+            100,
+            100,
+            firstFrame);
+
+    assertNotNull(Preconditions.checkNotNull(drawable.getConstantState()).newDrawable());
     assertNotNull(
         drawable.getConstantState().newDrawable(RuntimeEnvironment.application.getResources()));
   }
@@ -523,8 +537,8 @@ public void testSetsFrameTransformationOnFrameManager() {
 
   @Test(expected = NullPointerException.class)
   public void testThrowsIfConstructedWithNullFirstFrame() {
-    new GifDrawable(RuntimeEnvironment.application, mock(GifDecoder.class), bitmapPool,
-        transformation, 100, 100, null);
+    new GifDrawable(
+        RuntimeEnvironment.application, mock(GifDecoder.class), transformation, 100, 100, null);
   }
 
   @Test
@@ -567,6 +581,30 @@ public void testThrowsIfCreatedWithNullState() {
     new GifDrawable(null);
   }
 
+  @Test
+  public void onFrameReady_whenAttachedToDrawableCallbackButNotViewCallback_stops() {
+    TransitionDrawable topLevel = new TransitionDrawable(new Drawable[] { drawable });
+    drawable.setCallback(topLevel);
+    topLevel.setCallback(null);
+
+    drawable.start();
+    drawable.onFrameReady();
+
+    assertThat(drawable.isRunning()).isFalse();
+  }
+
+  @Test
+  public void onFrameReady_whenAttachedtoDrawableCallbackWithViewCallbackParent_doesNotStop() {
+      TransitionDrawable topLevel = new TransitionDrawable(new Drawable[] { drawable });
+    drawable.setCallback(topLevel);
+    topLevel.setCallback(new View(context));
+
+    drawable.start();
+    drawable.onFrameReady();
+
+    assertThat(drawable.isRunning()).isTrue();
+  }
+
   private void verifyRanLoops(int loopCount, int frameCount) {
     // 1 for invalidate in start().
     verify(cb, times(1 + loopCount * frameCount)).invalidateDrawable(eq(drawable));
@@ -587,15 +625,16 @@ private void runLoops(int loopCount, int frameCount) {
    * Keeps track of the set of Bitmaps drawn to the canvas.
    */
   @Implements(Canvas.class)
-  public static class BitmapTrackingShadowCanvas extends ShadowCanvas {
+  public static final class BitmapTrackingShadowCanvas extends ShadowCanvas {
     private final Set<Bitmap> drawnBitmaps = new HashSet<>();
 
     @Implementation
+    @Override
     public void drawBitmap(Bitmap bitmap, Rect src, Rect dst, Paint paint) {
       drawnBitmaps.add(bitmap);
     }
 
-    public Iterable<Bitmap> getDrawnBitmaps() {
+    private Iterable<Bitmap> getDrawnBitmaps() {
       return drawnBitmaps;
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
similarity index 81%
rename from library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
index f73dc91a5..f31857b81 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
@@ -18,12 +18,13 @@
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.UnitTransformation;
-import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.KeyTester;
 import com.bumptech.glide.tests.Util;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
@@ -35,8 +36,9 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class GifDrawableTransformationTest {
-  @Mock Transformation<Bitmap> wrapped;
-  @Mock BitmapPool bitmapPool;
+  @Rule public final KeyTester keyTester = new KeyTester();
+  @Mock private Transformation<Bitmap> wrapped;
+  @Mock private BitmapPool bitmapPool;
 
   private GifDrawableTransformation transformation;
   private Context context;
@@ -46,7 +48,7 @@ public void setUp() {
     MockitoAnnotations.initMocks(this);
     context = RuntimeEnvironment.application;
 
-    Glide.init(new GlideBuilder().setBitmapPool(bitmapPool).build(context));
+    Glide.init(context, new GlideBuilder().setBitmapPool(bitmapPool));
     transformation = new GifDrawableTransformation(wrapped);
   }
 
@@ -86,11 +88,19 @@ public void testSetsTransformationAsFrameTransformation() {
   public void testEquals() throws NoSuchAlgorithmException {
     doAnswer(new Util.WriteDigest("first")).when(wrapped)
         .updateDiskCacheKey(isA(MessageDigest.class));
-    KeyAssertions.assertSame(transformation, new GifDrawableTransformation(wrapped));
-
     @SuppressWarnings("unchecked") Transformation<Bitmap> other = mock(Transformation.class);
     doAnswer(new Util.WriteDigest("other")).when(other)
         .updateDiskCacheKey(isA(MessageDigest.class));
-    KeyAssertions.assertDifferent(transformation, new GifDrawableTransformation(other));
+    keyTester
+        .addEquivalenceGroup(
+            transformation,
+            new GifDrawableTransformation(wrapped),
+            new GifDrawableTransformation(wrapped))
+        .addEquivalenceGroup(wrapped)
+        .addEquivalenceGroup(new GifDrawableTransformation(other))
+        .addRegressionTest(
+            new GifDrawableTransformation(wrapped),
+            "a7937b64b8caa58f03721bb6bacf5c78cb235febe0e70b1b84cd99541461a08e")
+        .test();
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
similarity index 68%
rename from library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
index d6db3458b..c7a77bcfd 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
@@ -27,11 +27,12 @@
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.tests.TearDownGlide;
 import com.bumptech.glide.tests.Util.ReturnsSelfAnswer;
 import com.bumptech.glide.util.Util;
 import java.nio.ByteBuffer;
-import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.InOrder;
@@ -44,12 +45,13 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class GifFrameLoaderTest {
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
 
-  @Mock GifFrameLoader.FrameCallback callback;
-  @Mock GifDecoder gifDecoder;
-  @Mock Handler handler;
-  @Mock Transformation<Bitmap> transformation;
-  @Mock RequestManager requestManager;
+  @Mock private GifFrameLoader.FrameCallback callback;
+  @Mock private GifDecoder gifDecoder;
+  @Mock private Handler handler;
+  @Mock private Transformation<Bitmap> transformation;
+  @Mock private RequestManager requestManager;
   private GifFrameLoader loader;
   private RequestBuilder<Bitmap> requestBuilder;
   private Bitmap firstFrame;
@@ -70,15 +72,10 @@ public void setUp() {
     loader = createGifFrameLoader(handler);
   }
 
-  @After
-  public void tearDown() {
-    Glide.tearDown();
-  }
-
   @NonNull
   private GifFrameLoader createGifFrameLoader(Handler handler) {
     Glide glide = getGlideSingleton();
-    return new GifFrameLoader(
+    GifFrameLoader result = new GifFrameLoader(
         glide.getBitmapPool(),
         requestManager,
         gifDecoder,
@@ -86,6 +83,8 @@ private GifFrameLoader createGifFrameLoader(Handler handler) {
         requestBuilder,
         transformation,
         firstFrame);
+    result.subscribe(callback);
+    return result;
   }
 
   private static Glide getGlideSingleton() {
@@ -95,10 +94,11 @@ private static Glide getGlideSingleton() {
   @SuppressWarnings("unchecked")
   @Test
   public void testSetFrameTransformationSetsTransformationOnRequestBuilder() {
+    verify(requestBuilder, times(2)).apply(isA(RequestOptions.class));
     Transformation<Bitmap> transformation = mock(Transformation.class);
     loader.setFrameTransformation(transformation, firstFrame);
 
-    verify(requestBuilder, times(2)).apply(isA(RequestOptions.class));
+    verify(requestBuilder, times(3)).apply(isA(RequestOptions.class));
   }
 
   @Test(expected = NullPointerException.class)
@@ -115,15 +115,11 @@ public void testReturnsSizeFromGifDecoderAndCurrentFrame() {
 
   @Test
   public void testStartGetsNextFrameIfNotStartedAndWithNoLoadPending() {
-    loader.subscribe(callback);
-
     verify(requestBuilder).into(aTarget());
   }
 
   @Test
   public void testGetNextFrameIncrementsSignatureAndAdvancesDecoderBeforeStartingLoad() {
-    loader.subscribe(callback);
-
     InOrder order = inOrder(gifDecoder, requestBuilder);
     order.verify(gifDecoder).advance();
     order.verify(requestBuilder).apply(isA(RequestOptions.class));
@@ -147,7 +143,6 @@ public void testGetCurrentFrameReturnsCurrentBitmapAfterLoadHasCompleted() {
 
   @Test
   public void testStartDoesNotStartIfAlreadyRunning() {
-    loader.subscribe(callback);
     loader.subscribe(mock(FrameCallback.class));
 
     verify(requestBuilder, times(1)).into(aTarget());
@@ -155,14 +150,15 @@ public void testStartDoesNotStartIfAlreadyRunning() {
 
   @Test
   public void testGetNextFrameDoesNotStartLoadIfLoaderIsNotRunning() {
+    verify(requestBuilder, times(1)).into(aTarget());
+    loader.unsubscribe(callback);
     loader.onFrameReady(mock(DelayTarget.class));
 
-    verify(requestBuilder, never()).into(aTarget());
+    verify(requestBuilder, times(1)).into(aTarget());
   }
 
   @Test
   public void testGetNextFrameDoesNotStartLoadIfLoadIsInProgress() {
-    loader.subscribe(callback);
     loader.unsubscribe(callback);
     loader.subscribe(callback);
 
@@ -171,7 +167,6 @@ public void testGetNextFrameDoesNotStartLoadIfLoadIsInProgress() {
 
   @Test
   public void testGetNextFrameDoesStartLoadIfRestartedAndNoLoadIsInProgress() {
-    loader.subscribe(callback);
     loader.unsubscribe(callback);
 
     loader.onFrameReady(mock(DelayTarget.class));
@@ -182,7 +177,6 @@ public void testGetNextFrameDoesStartLoadIfRestartedAndNoLoadIsInProgress() {
 
   @Test
   public void testGetNextFrameDoesStartLoadAfterLoadCompletesIfStarted() {
-    loader.subscribe(callback);
     loader.onFrameReady(mock(DelayTarget.class));
 
     verify(requestBuilder, times(2)).into(aTarget());
@@ -269,6 +263,97 @@ public void testClearsCompletedLoadOnFrameReadyIfCleared() {
     assertNull(loader.getCurrentFrame());
   }
 
+  @Test
+  public void onFrameReady_whenNotRunning_doesNotClearPreviouslyLoadedImage() {
+    loader = createGifFrameLoader(/*handler=*/ null);
+    DelayTarget loaded = mock(DelayTarget.class);
+    when(loaded.getResource()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    loader.onFrameReady(loaded);
+    loader.unsubscribe(callback);
+
+    DelayTarget nextFrame = mock(DelayTarget.class);
+    when(nextFrame.getResource())
+        .thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    loader.onFrameReady(nextFrame);
+    verify(requestManager, never()).clear(loaded);
+  }
+
+  @Test
+  public void onFrameReady_whenNotRunning_clearsPendingFrameOnClear() {
+    loader = createGifFrameLoader(/*handler=*/ null);
+    DelayTarget loaded = mock(DelayTarget.class);
+    when(loaded.getResource()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    loader.onFrameReady(loaded);
+    loader.unsubscribe(callback);
+
+    DelayTarget nextFrame = mock(DelayTarget.class);
+    when(nextFrame.getResource())
+        .thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    loader.onFrameReady(nextFrame);
+
+    loader.clear();
+    verify(requestManager).clear(loaded);
+    verify(requestManager).clear(nextFrame);
+  }
+
+  @Test
+  public void onFrameReady_whenNotRunning_clearsOldFrameOnStart() {
+    loader = createGifFrameLoader(/*handler=*/ null);
+    DelayTarget loaded = mock(DelayTarget.class);
+    when(loaded.getResource()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    loader.onFrameReady(loaded);
+    loader.unsubscribe(callback);
+
+    DelayTarget nextFrame = mock(DelayTarget.class);
+    when(nextFrame.getResource())
+        .thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    loader.onFrameReady(nextFrame);
+
+    loader.subscribe(callback);
+    verify(requestManager).clear(loaded);
+  }
+
+  @Test
+  public void onFrameReady_whenNotRunning_callsFrameReadyWithNewFrameOnStart() {
+    loader = createGifFrameLoader(/*handler=*/ null);
+    DelayTarget loaded = mock(DelayTarget.class);
+    when(loaded.getResource()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    loader.onFrameReady(loaded);
+    loader.unsubscribe(callback);
+
+    DelayTarget nextFrame = mock(DelayTarget.class);
+    Bitmap expected = Bitmap.createBitmap(200, 200, Bitmap.Config.ARGB_8888);
+    when(nextFrame.getResource())
+        .thenReturn(expected);
+    loader.onFrameReady(nextFrame);
+
+    verify(callback, times(1)).onFrameReady();
+    loader.subscribe(callback);
+    verify(callback, times(2)).onFrameReady();
+    assertThat(loader.getCurrentFrame()).isEqualTo(expected);
+  }
+
+  @Test
+  public void startFromFirstFrame_withPendingFrame_clearsPendingFrame() {
+    loader = createGifFrameLoader(/*handler=*/ null);
+    DelayTarget loaded = mock(DelayTarget.class);
+    when(loaded.getResource()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    loader.onFrameReady(loaded);
+    loader.unsubscribe(callback);
+
+    DelayTarget nextFrame = mock(DelayTarget.class);
+    Bitmap expected = Bitmap.createBitmap(200, 200, Bitmap.Config.ARGB_8888);
+    when(nextFrame.getResource())
+        .thenReturn(expected);
+    loader.onFrameReady(nextFrame);
+
+    loader.setNextStartFromFirstFrame();
+    verify(requestManager).clear(nextFrame);
+
+    loader.subscribe(callback);
+    verify(callback, times(1)).onFrameReady();
+  }
+
   @SuppressWarnings("unchecked")
   private static Target<Bitmap> aTarget() {
     return isA(Target.class);
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java
similarity index 88%
rename from library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java
index 18c379433..59d3cfb09 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java
@@ -9,6 +9,7 @@
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.util.Preconditions;
 import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
@@ -35,7 +36,9 @@ public void testReturnsFrameFromGifDecoder() throws IOException {
     Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
     when(gifDecoder.getNextFrame()).thenReturn(expected);
 
-    assertEquals(expected, resourceDecoder.decode(gifDecoder, 100, 100, options).get());
+    assertEquals(
+        expected,
+        Preconditions.checkNotNull(resourceDecoder.decode(gifDecoder, 100, 100, options)).get());
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
similarity index 88%
rename from library/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
index f6d4eba4c..f50eaf075 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
@@ -25,8 +25,7 @@
 public class StreamGifDecoderTest {
   private static final byte[] GIF_HEADER = new byte[] { 0x47, 0x49, 0x46 };
 
-  @Mock
-  ResourceDecoder<ByteBuffer, GifDrawable> byteBufferDecoder;
+  @Mock private ResourceDecoder<ByteBuffer, GifDrawable> byteBufferDecoder;
   private StreamGifDecoder decoder;
   private Options options;
 
@@ -34,7 +33,7 @@
   public void setUp() {
     MockitoAnnotations.initMocks(this);
 
-    List<ImageHeaderParser> parsers = new ArrayList<ImageHeaderParser>();
+    List<ImageHeaderParser> parsers = new ArrayList<>();
     parsers.add(new DefaultImageHeaderParser());
 
     decoder = new StreamGifDecoder(parsers, byteBufferDecoder, new LruArrayPool());
@@ -53,13 +52,13 @@ public void testHandlesStreamIfContainsGifHeaderAndDisabledIsNotSet() throws IOE
 
   @Test
   public void testHandlesStreamIfContainsGifHeaderAndDisabledIsFalse() throws IOException {
-    options.set(StreamGifDecoder.DISABLE_ANIMATION, false);
+    options.set(GifOptions.DISABLE_ANIMATION, false);
     assertThat(decoder.handles(new ByteArrayInputStream(GIF_HEADER), options)).isTrue();
   }
 
   @Test
   public void testDoesNotHandleStreamIfDisabled() throws IOException {
-    options.set(StreamGifDecoder.DISABLE_ANIMATION, true);
+    options.set(GifOptions.DISABLE_ANIMATION, true);
     assertThat(decoder.handles(new ByteArrayInputStream(GIF_HEADER), options)).isFalse();
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
similarity index 85%
rename from library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
index b4379c750..866b3ff70 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
@@ -8,6 +8,7 @@
 import android.graphics.Bitmap;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
+import java.nio.charset.Charset;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -58,20 +59,20 @@ public void testBitmapResourceIsRecycled() {
     Bitmap.CompressFormat compressFormat = Bitmap.CompressFormat.JPEG;
     int quality = 100;
     final String description = "TestDescription";
-    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ALPHA_8);
-    Resource<Bitmap> bitmapResource = mockResource();
-    Options options = new Options();
+    final Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ALPHA_8);
+    final Resource<Bitmap> bitmapResource = mockResource();
+    final Options options = new Options();
 
-    public BitmapBytesTranscoderHarness() {
+    BitmapBytesTranscoderHarness() {
       when(bitmapResource.get()).thenReturn(bitmap);
       Shadows.shadowOf(bitmap).setDescription(description);
     }
 
-    public String getTranscodedDescription() {
+    String getTranscodedDescription() {
       BitmapBytesTranscoder transcoder = new BitmapBytesTranscoder(compressFormat, quality);
       Resource<byte[]> bytesResource = transcoder.transcode(bitmapResource, options);
 
-      return new String(bytesResource.get());
+      return new String(bytesResource.get(), Charset.defaultCharset());
     }
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java
similarity index 88%
rename from library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java
index 0707a342a..b3c195657 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java
@@ -2,14 +2,12 @@
 
 import static com.bumptech.glide.tests.Util.mockResource;
 import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -24,8 +22,7 @@
 
   @Before
   public void setUp() {
-    transcoder = new BitmapDrawableTranscoder(RuntimeEnvironment.application.getResources(),
-        mock(BitmapPool.class));
+    transcoder = new BitmapDrawableTranscoder(RuntimeEnvironment.application.getResources());
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
similarity index 91%
rename from library/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
index d1cd38b01..fc1c7777c 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
@@ -9,6 +9,7 @@
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 import java.nio.ByteBuffer;
+import java.nio.charset.Charset;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -31,7 +32,7 @@ public void setUp() {
   @Test
   public void testReturnsBytesOfGivenGifDrawable() {
     for (String fakeData : new String[] { "test", "1235asfklaw3", "@$@#" }) {
-      ByteBuffer expected = ByteBuffer.wrap(fakeData.getBytes());
+      ByteBuffer expected = ByteBuffer.wrap(fakeData.getBytes(Charset.defaultCharset()));
       when(gifDrawable.getBuffer()).thenReturn(expected);
 
       Resource<byte[]> transcoded = transcoder.transcode(resource, new Options());
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java
diff --git a/library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactoryTest.java b/library/test/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactoryTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactoryTest.java
rename to library/test/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactoryTest.java
diff --git a/library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java b/library/test/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
similarity index 61%
rename from library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
rename to library/test/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
index 32fa7111b..930a9f34e 100644
--- a/library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
@@ -3,7 +3,6 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.mockito.Matchers.anyBoolean;
 import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 
@@ -12,28 +11,36 @@
 import android.content.Intent;
 import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
+import com.bumptech.glide.manager.DefaultConnectivityMonitorTest.PermissionConnectivityManager;
 import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
-import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowApplication;
 import org.robolectric.shadows.ShadowConnectivityManager;
 import org.robolectric.shadows.ShadowNetworkInfo;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(manifest = Config.NONE, sdk = 18, shadows = PermissionConnectivityManager.class)
 public class DefaultConnectivityMonitorTest {
-  private ConnectivityMonitor.ConnectivityListener listener;
+  @Mock private ConnectivityMonitor.ConnectivityListener listener;
   private DefaultConnectivityMonitor monitor;
+  private ConnectivityHarness harness;
+
 
   @Before
   public void setUp() {
-    listener = mock(ConnectivityMonitor.ConnectivityListener.class);
+    MockitoAnnotations.initMocks(this);
     monitor = new DefaultConnectivityMonitor(RuntimeEnvironment.application, listener);
+    harness = new ConnectivityHarness();
   }
 
   @Test
@@ -69,7 +76,6 @@ public void testHandlesUnregisteringTwiceInARow() {
 
   @Test
   public void testDoesNotNotifyListenerIfConnectedAndBecomesConnected() {
-    ConnectivityHarness harness = new ConnectivityHarness();
     harness.connect();
 
     monitor.onStart();
@@ -80,7 +86,6 @@ public void testDoesNotNotifyListenerIfConnectedAndBecomesConnected() {
 
   @Test
   public void testNotifiesListenerIfConnectedAndBecomesDisconnected() {
-    ConnectivityHarness harness = new ConnectivityHarness();
     harness.connect();
 
     monitor.onStart();
@@ -92,7 +97,6 @@ public void testNotifiesListenerIfConnectedAndBecomesDisconnected() {
 
   @Test
   public void testNotifiesListenerIfDisconnectedAndBecomesConnected() {
-    ConnectivityHarness harness = new ConnectivityHarness();
     harness.disconnect();
 
     monitor.onStart();
@@ -104,7 +108,6 @@ public void testNotifiesListenerIfDisconnectedAndBecomesConnected() {
 
   @Test
   public void testDoesNotNotifyListenerWhenNotRegistered() {
-    ConnectivityHarness harness = new ConnectivityHarness();
     harness.disconnect();
 
     monitor.onStart();
@@ -115,33 +118,81 @@ public void testDoesNotNotifyListenerWhenNotRegistered() {
     verify(listener, never()).onConnectivityChanged(anyBoolean());
   }
 
+  @Test
+  public void register_withMissingPermission_doesNotThrow() {
+    harness.shadowConnectivityManager.isNetworkPermissionGranted = false;
+
+    monitor.onStart();
+  }
+
+  @Test
+  public void onReceive_withMissingPermission_doesNotThrow() {
+    monitor.onStart();
+    harness.shadowConnectivityManager.isNetworkPermissionGranted = false;
+    harness.broadcast();
+  }
+
+  @Test
+  public void onReceive_withMissingPermission_previouslyDisconnected_notifiesListenersConnected() {
+    harness.disconnect();
+    monitor.onStart();
+    harness.shadowConnectivityManager.isNetworkPermissionGranted = false;
+    harness.broadcast();
+
+    verify(listener).onConnectivityChanged(true);
+  }
+
+  @Test
+  public void onReceive_withMissingPermission_previouslyConnected_doesNotNotifyListeners() {
+    harness.connect();
+    monitor.onStart();
+    harness.shadowConnectivityManager.isNetworkPermissionGranted = false;
+    harness.broadcast();
+
+    verify(listener, never()).onConnectivityChanged(anyBoolean());
+  }
+
   private List<BroadcastReceiver> getConnectivityReceivers() {
     Intent connectivity = new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
     return ShadowApplication.getInstance().getReceiversForIntent(connectivity);
   }
 
   private static class ConnectivityHarness {
-    private final ShadowConnectivityManager shadowConnectivityManager;
+    private final PermissionConnectivityManager shadowConnectivityManager;
 
     public ConnectivityHarness() {
       ConnectivityManager connectivityManager = (ConnectivityManager) RuntimeEnvironment.application
           .getSystemService(Context.CONNECTIVITY_SERVICE);
-      shadowConnectivityManager = Shadows.shadowOf(connectivityManager);
+      shadowConnectivityManager = Shadow.extract(connectivityManager);
     }
 
-    public void disconnect() {
+    void disconnect() {
       shadowConnectivityManager.setActiveNetworkInfo(null);
     }
 
-    public void connect() {
+    void connect() {
       NetworkInfo networkInfo =
           ShadowNetworkInfo.newInstance(NetworkInfo.DetailedState.CONNECTED, 0, 0, true, true);
       shadowConnectivityManager.setActiveNetworkInfo(networkInfo);
     }
 
-    public void broadcast() {
+    void broadcast() {
       Intent connected = new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
       ShadowApplication.getInstance().sendBroadcast(connected);
     }
   }
+
+  @Implements(ConnectivityManager.class)
+  public static final class PermissionConnectivityManager extends ShadowConnectivityManager {
+    private boolean isNetworkPermissionGranted = true;
+
+    @Implementation
+    @Override
+    public NetworkInfo getActiveNetworkInfo() {
+      if (!isNetworkPermissionGranted) {
+        throw new SecurityException();
+      }
+      return super.getActiveNetworkInfo();
+    }
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/manager/Issue117Activity.java b/library/test/src/test/java/com/bumptech/glide/manager/Issue117Activity.java
similarity index 85%
rename from library/src/test/java/com/bumptech/glide/manager/Issue117Activity.java
rename to library/test/src/test/java/com/bumptech/glide/manager/Issue117Activity.java
index 570026f5d..60c59027d 100644
--- a/library/src/test/java/com/bumptech/glide/manager/Issue117Activity.java
+++ b/library/test/src/test/java/com/bumptech/glide/manager/Issue117Activity.java
@@ -2,10 +2,11 @@
 
 import static android.view.ViewGroup.LayoutParams.MATCH_PARENT;
 
-import android.annotation.TargetApi;
 import android.content.Context;
 import android.os.Build;
 import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.RequiresApi;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
 import android.support.v4.app.FragmentManager;
@@ -20,7 +21,7 @@
 /**
  * A test activity to reproduce Issue #117: https://github.com/bumptech/glide/issues/117.
  */
-@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+@RequiresApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
 class Issue117Activity extends FragmentActivity {
   @Override
   protected void onCreate(Bundle savedInstanceState) {
@@ -33,7 +34,7 @@ protected void onCreate(Bundle savedInstanceState) {
 
   private static class Issue117Adapter extends FragmentPagerAdapter {
 
-    public Issue117Adapter(FragmentManager fm) {
+    Issue117Adapter(FragmentManager fm) {
       super(fm);
     }
 
@@ -50,8 +51,8 @@ public int getCount() {
 
   public static class Issue117Fragment extends Fragment {
     @Override
-    public View onCreateView(LayoutInflater inflater, ViewGroup container,
-        Bundle savedInstanceState) {
+    public View onCreateView(
+        @NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
       return new Issue117ImageView(getActivity());
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/manager/LifecycleTest.java b/library/test/src/test/java/com/bumptech/glide/manager/LifecycleTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/manager/LifecycleTest.java
rename to library/test/src/test/java/com/bumptech/glide/manager/LifecycleTest.java
diff --git a/library/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java b/library/test/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
similarity index 98%
rename from library/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
rename to library/test/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
index 709573fed..65b63694e 100644
--- a/library/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
@@ -129,7 +129,7 @@ private void runTest(TestCase testCase) {
   }
 
   private interface TestCase {
-    public void runTest(Harness harness);
+    void runTest(Harness harness);
   }
 
   private interface Harness {
@@ -145,7 +145,7 @@ private void runTest(TestCase testCase) {
 
     void onLowMemory();
 
-    void onTrimMemory(int level);
+    void onTrimMemory(@SuppressWarnings("SameParameterValue") int level);
   }
 
   private static class RequestManagerHarness implements Harness {
diff --git a/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java b/library/test/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
similarity index 96%
rename from library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
rename to library/test/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
index 97884942a..79c5bd9f8 100644
--- a/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
@@ -9,20 +9,22 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
-import android.annotation.TargetApi;
 import android.app.Activity;
 import android.content.Context;
 import android.content.ContextWrapper;
 import android.os.Build;
 import android.os.Looper;
+import android.support.annotation.RequiresApi;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
 import com.bumptech.glide.RequestManager;
-import com.bumptech.glide.tests.BackgroundUtil;
+import com.bumptech.glide.tests.BackgroundUtil.BackgroundTester;
 import com.bumptech.glide.tests.GlideShadowLooper;
+import com.bumptech.glide.tests.TearDownGlide;
 import com.bumptech.glide.tests.Util;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mockito;
@@ -36,6 +38,8 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = GlideShadowLooper.class)
 public class RequestManagerRetrieverTest {
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+
   private static final String PARENT_TAG = "parent";
   private RetrieverHarness[] harnesses;
   private RequestManagerRetriever retriever;
@@ -284,9 +288,9 @@ public void testApplicationRequestManagerIsNotReResumedAfterFirstRetrieval() {
   @Test
   public void testDoesNotThrowWhenGetWithContextCalledFromBackgroundThread()
       throws InterruptedException {
-    testInBackground(new BackgroundUtil.BackgroundTester() {
+    testInBackground(new BackgroundTester() {
       @Override
-      public void runTest() throws Exception {
+      public void runTest() {
         retriever.get(RuntimeEnvironment.application);
       }
     });
@@ -305,7 +309,7 @@ public void testCanCallGetInOnAttachToWindowInFragmentInViewPager() {
   }
 
   @Test
-  @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+  @RequiresApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
   public void testDoesNotThrowIfAskedToGetManagerForActivityPreJellYBeanMr1() {
     Util.setSdkVersionInt(Build.VERSION_CODES.JELLY_BEAN);
     Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
@@ -316,7 +320,7 @@ public void testDoesNotThrowIfAskedToGetManagerForActivityPreJellYBeanMr1() {
   }
 
   @Test
-  @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+  @RequiresApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
   public void testDoesNotThrowIfAskedToGetManagerForFragmentPreJellyBeanMr1() {
     Util.setSdkVersionInt(Build.VERSION_CODES.JELLY_BEAN);
     Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
@@ -339,12 +343,12 @@ public void testDoesNotThrowIfAskedToGetManagerForFragmentPreJellyBeanMr1() {
     void addFragmentWithTag(String tag, RequestManager manager);
   }
 
-  public class DefaultRetrieverHarness implements RetrieverHarness {
+  final class DefaultRetrieverHarness implements RetrieverHarness {
     private final ActivityController<Activity> controller =
         Robolectric.buildActivity(Activity.class);
     private final android.app.Fragment parent;
 
-    public DefaultRetrieverHarness() {
+    DefaultRetrieverHarness() {
       this.parent = new android.app.Fragment();
 
       controller.create();
diff --git a/library/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java b/library/test/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
similarity index 84%
rename from library/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
rename to library/test/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
index 889cd2ba2..afff35212 100644
--- a/library/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
@@ -15,6 +15,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
+import org.mockito.MockitoAnnotations;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 
@@ -24,27 +25,40 @@
 
   @Before
   public void setUp() {
+    MockitoAnnotations.initMocks(this);
     tracker = new RequestTracker();
   }
 
   @Test
-  public void testClearsAddedRequestsOnDestroy() {
+  public void clearRequests_doesNotRecycleRequests() {
     Request request = mock(Request.class);
     tracker.addRequest(request);
 
     tracker.clearRequests();
 
     verify(request).clear();
-    verify(request).recycle();
+    verify(request, never()).recycle();
   }
 
   @Test
-  public void testClearRemoveAndRecycle_withNullRequest_doesNothingAndReturnsFalse() {
-    assertThat(tracker.clearRemoveAndRecycle(null)).isFalse();
+  public void clearRemoveAndRecycle_withRequestPreviouslyClearedInClearRequests_doesNothing() {
+    Request request = mock(Request.class);
+    tracker.addRequest(request);
+
+    tracker.clearRequests();
+    tracker.clearRemoveAndRecycle(request);
+
+    verify(request).clear();
+    verify(request, never()).recycle();
   }
 
   @Test
-  public void testClearRemoveAndRecycle_withUnTrackedRequest_doesNothingAndReturnsFalse() {
+  public void clearRemoveAndRecycle_withNullRequest_doesNothingAndReturnsTrue() {
+    assertThat(tracker.clearRemoveAndRecycle(null)).isTrue();
+  }
+
+  @Test
+  public void clearRemoveAndRecycle_withUnTrackedRequest_doesNothingAndReturnsFalse() {
     Request request = mock(Request.class);
 
     assertThat(tracker.clearRemoveAndRecycle(request)).isFalse();
@@ -54,7 +68,7 @@ public void testClearRemoveAndRecycle_withUnTrackedRequest_doesNothingAndReturns
   }
 
   @Test
-  public void testClearRemoveAndRecycle_withTrackedRequest_clearsRecyclesAndReturnsTrue() {
+  public void clearRemoveAndRecycle_withTrackedRequest_clearsRecyclesAndReturnsTrue() {
     Request request = mock(Request.class);
     tracker.addRequest(request);
 
@@ -64,7 +78,7 @@ public void testClearRemoveAndRecycle_withTrackedRequest_clearsRecyclesAndReturn
   }
 
   @Test
-  public void testClearRemoveAndRecycle_withAlreadyRemovedRequest_doesNothingAndReturnsFalse() {
+  public void clearRemoveAndRecycle_withAlreadyRemovedRequest_doesNothingAndReturnsFalse() {
     Request request = mock(Request.class);
     tracker.addRequest(request);
     tracker.clearRemoveAndRecycle(request);
@@ -340,11 +354,31 @@ public void testReturnsFalseFromIsPausedWhenResumed() {
     assertFalse(tracker.isPaused());
   }
 
+  @Test
+  public void testPauseAllRequests_returnsTrueFromIsPaused() {
+    tracker.pauseAllRequests();
+    assertTrue(tracker.isPaused());
+  }
+
+  @Test
+  public void testPauseAllRequests_whenRequestComplete_pausesRequest() {
+    Request request = mock(Request.class);
+    when(request.isFailed()).thenReturn(false);
+    when(request.isComplete()).thenReturn(true);
+    tracker.addRequest(request);
+    tracker.pauseAllRequests();
+    verify(request).pause();
+
+    when(request.isComplete()).thenReturn(false);
+    tracker.resumeRequests();
+    verify(request).begin();
+  }
+
   private class ClearAndRemoveRequest implements Answer<Void> {
 
-    private Request toRemove;
+    private final Request toRemove;
 
-    public ClearAndRemoveRequest(Request toRemove) {
+    ClearAndRemoveRequest(Request toRemove) {
       this.toRemove = toRemove;
     }
 
diff --git a/library/src/test/java/com/bumptech/glide/module/ManifestParserTest.java b/library/test/src/test/java/com/bumptech/glide/module/ManifestParserTest.java
similarity index 93%
rename from library/src/test/java/com/bumptech/glide/module/ManifestParserTest.java
rename to library/test/src/test/java/com/bumptech/glide/module/ManifestParserTest.java
index 8725e85b7..698425e22 100644
--- a/library/src/test/java/com/bumptech/glide/module/ManifestParserTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/module/ManifestParserTest.java
@@ -9,6 +9,7 @@
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
 import android.os.Bundle;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
@@ -27,8 +28,7 @@
 public class ManifestParserTest {
   private static final String MODULE_VALUE = "GlideModule";
 
-  @Mock
-  Context context;
+  @Mock private Context context;
   private ManifestParser parser;
   private ApplicationInfo applicationInfo;
 
@@ -111,12 +111,11 @@ private void addToManifest(String key) {
     applicationInfo.metaData.putString(key, MODULE_VALUE);
   }
 
-  public static class InvalidClass {
-  }
+  private static class InvalidClass { }
 
   public static class TestModule1 implements GlideModule {
     @Override
-    public void applyOptions(Context context, GlideBuilder builder) {
+    public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
     }
 
     @Override
@@ -137,7 +136,7 @@ public int hashCode() {
   public static class TestModule2 implements GlideModule {
 
     @Override
-    public void applyOptions(Context context, GlideBuilder builder) {
+    public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
     }
 
     @Override
diff --git a/library/test/src/test/java/com/bumptech/glide/request/ErrorRequestCoordinatorTest.java b/library/test/src/test/java/com/bumptech/glide/request/ErrorRequestCoordinatorTest.java
new file mode 100644
index 000000000..931579037
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/request/ErrorRequestCoordinatorTest.java
@@ -0,0 +1,629 @@
+package com.bumptech.glide.request;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(JUnit4.class)
+public class ErrorRequestCoordinatorTest {
+
+  @Mock private Request primary;
+  @Mock private Request error;
+  @Mock private RequestCoordinator parent;
+  private ErrorRequestCoordinator coordinator;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    coordinator = new ErrorRequestCoordinator(/*parent=*/ null);
+    coordinator.setRequests(primary, error);
+  }
+
+  @Test
+  public void begin_startsPrimary() {
+    coordinator.begin();
+    verify(primary).begin();
+  }
+
+  @Test
+  public void begin_whenPrimaryIsAlreadyRunning_doesNotStartPrimaryAgain() {
+    when(primary.isRunning()).thenReturn(true);
+    coordinator.begin();
+    verify(primary, never()).begin();
+  }
+
+  @Test
+  public void pause_whenPrimaryHasNotFailed_pausesPrimary() {
+    coordinator.pause();
+    verify(primary).pause();
+  }
+
+  @Test
+  public void pause_whenPrimaryHasFailed_doesNotPausePrimary() {
+    when(primary.isFailed()).thenReturn(true);
+    coordinator.pause();
+    verify(primary, never()).pause();
+  }
+
+  @Test
+  public void pause_whenErrorIsRunning_pausesError() {
+    when(error.isRunning()).thenReturn(true);
+    coordinator.pause();
+    verify(error).pause();
+  }
+
+  @Test
+  public void pause_whenErrorIsNotRunning_doesNotPauseError() {
+    coordinator.pause();
+    verify(error, never()).pause();
+  }
+
+  @Test
+  public void clear_whenPrimaryHasNotFailed_clearsPrimary() {
+    coordinator.clear();
+    verify(primary).clear();
+  }
+
+  @Test
+  public void clear_whenPrimaryHasNotFailed_doesNotClearError() {
+    coordinator.clear();
+    verify(error, never()).clear();
+  }
+
+  @Test
+  public void clear_whenPrimaryHasFailed_errorIsRunning_clearsError() {
+    when(primary.isFailed()).thenReturn(true);
+    when(error.isRunning()).thenReturn(true);
+    coordinator.clear();
+    verify(error).clear();
+  }
+
+  @Test
+  public void clear_whenPrimaryHasFailed_clearsPrimary() {
+    when(primary.isFailed()).thenReturn(true);
+    coordinator.clear();
+    verify(primary).clear();
+  }
+
+  @Test
+  public void clear_whenErrorIsRunning_clearsError() {
+    when(error.isRunning()).thenReturn(true);
+    coordinator.clear();
+
+    verify(error).clear();
+  }
+
+  @Test
+  public void isPaused_primaryNotFailed_primaryNotPaused_returnsFalse() {
+    assertThat(coordinator.isPaused()).isFalse();
+  }
+
+  @Test
+  public void isPaused_primaryNotFailed_primaryPaused_returnsTrue() {
+    when(primary.isPaused()).thenReturn(true);
+    assertThat(coordinator.isPaused()).isTrue();
+  }
+
+  @Test
+  public void isPaused_primaryFailed_errorNotPaused_returnsFalse() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.isPaused()).isFalse();
+  }
+
+  @Test
+  public void isPaused_primaryFailed_errorPaused_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    when(error.isPaused()).thenReturn(true);
+    assertThat(coordinator.isPaused()).isTrue();
+  }
+
+  @Test
+  public void isRunning_primaryNotFailed_primaryNotRunning_returnsFalse() {
+    assertThat(coordinator.isRunning()).isFalse();
+  }
+
+  @Test
+  public void isRunning_primaryNotFailed_primaryRunning_returnsTrue() {
+    when(primary.isRunning()).thenReturn(true);
+    assertThat(coordinator.isRunning()).isTrue();
+  }
+
+  @Test
+  public void isRunning_primaryFailed_errorNotRunning_returnsFalse() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.isRunning()).isFalse();
+  }
+
+  @Test
+  public void isRunning_primaryFailed_errorRunning_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    when(error.isRunning()).thenReturn(true);
+    assertThat(coordinator.isRunning()).isTrue();
+  }
+
+  @Test
+  public void isComplete_primaryNotFailed_primaryNotComplete_returnsFalse() {
+    assertThat(coordinator.isComplete()).isFalse();
+  }
+
+  @Test
+  public void isComplete_primaryNotFailed_primaryComplete_returnsTrue() {
+    when(primary.isComplete()).thenReturn(true);
+    assertThat(coordinator.isComplete()).isTrue();
+  }
+
+  @Test
+  public void isComplete_primaryFailed_errorNotComplete_returnsFalse() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.isComplete()).isFalse();
+  }
+
+  @Test
+  public void isComplete_primaryFailed_errorComplete_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    when(error.isComplete()).thenReturn(true);
+    assertThat(coordinator.isComplete()).isTrue();
+  }
+
+  @Test
+  public void isResourceSet_primaryNotFailed_primaryNotResourceSet_returnsFalse() {
+    assertThat(coordinator.isResourceSet()).isFalse();
+  }
+
+  @Test
+  public void isResourceSet_primaryNotFailed_primaryResourceSet_returnsTrue() {
+    when(primary.isResourceSet()).thenReturn(true);
+    assertThat(coordinator.isResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isResourceSet_primaryFailed_errorNotResourceSet_returnsFalse() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.isResourceSet()).isFalse();
+  }
+
+  @Test
+  public void isResourceSet_primaryFailed_errorResourceSet_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    when(error.isResourceSet()).thenReturn(true);
+    assertThat(coordinator.isResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isCancelled_primaryNotFailed_primaryNotCancelled_returnsFalse() {
+    assertThat(coordinator.isCancelled()).isFalse();
+  }
+
+  @Test
+  public void isCancelled_primaryNotFailed_primaryCancelled_returnsTrue() {
+    when(primary.isCancelled()).thenReturn(true);
+    assertThat(coordinator.isCancelled()).isTrue();
+  }
+
+  @Test
+  public void isCancelled_primaryFailed_errorNotCancelled_returnsFalse() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.isCancelled()).isFalse();
+  }
+
+  @Test
+  public void isCancelled_primaryFailed_errorCancelled_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    when(error.isCancelled()).thenReturn(true);
+    assertThat(coordinator.isCancelled()).isTrue();
+  }
+
+  @Test
+  public void isFailed_primaryNotFailed_errorNotFailed_returnsFalse() {
+    assertThat(coordinator.isFailed()).isFalse();
+  }
+
+  @Test
+  public void isFailed_primaryFailed_errorNotFailed_returnsFalse() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.isFailed()).isFalse();
+  }
+
+  @Test
+  public void isFailed_primaryNotFailed_errorFailed_returnsFalse() {
+    when(error.isFailed()).thenReturn(true);
+    assertThat(coordinator.isFailed()).isFalse();
+  }
+
+  @Test
+  public void isFailed_primaryFailed_andErrorFailed_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    when(error.isFailed()).thenReturn(true);
+    assertThat(coordinator.isFailed()).isTrue();
+  }
+
+  @Test
+  public void recycle_recyclesPrimaryAndError() {
+    coordinator.recycle();
+    verify(primary).recycle();
+    verify(error).recycle();
+  }
+
+  @Test
+  public void isEquivalentTo() {
+    assertThat(coordinator.isEquivalentTo(primary)).isFalse();
+
+    ErrorRequestCoordinator other = new ErrorRequestCoordinator(/*parent=*/ null);
+    assertThat(coordinator.isEquivalentTo(other)).isFalse();
+
+    other.setRequests(primary, primary);
+    assertThat(coordinator.isEquivalentTo(other)).isFalse();
+
+    other.setRequests(error, error);
+    assertThat(coordinator.isEquivalentTo(other)).isFalse();
+
+    when(primary.isEquivalentTo(primary)).thenReturn(true);
+    when(error.isEquivalentTo(error)).thenReturn(true);
+    other.setRequests(primary, error);
+    assertThat(coordinator.isEquivalentTo(other)).isTrue();
+
+    other = new ErrorRequestCoordinator(parent);
+    other.setRequests(primary, error);
+    assertThat(coordinator.isEquivalentTo(other)).isTrue();
+
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    other = new ErrorRequestCoordinator(parent);
+    other.setRequests(primary, error);
+    assertThat(coordinator.isEquivalentTo(other)).isTrue();
+  }
+
+  @Test
+  public void canSetImage_withNotFailedPrimary_andNullParent_returnsTrue() {
+    assertThat(coordinator.canSetImage(primary)).isTrue();
+  }
+
+  @Test
+  public void canSetImage_withError_andNullParent_andNotFailedPrimary_returnsFalse() {
+    assertThat(coordinator.canSetImage(error)).isFalse();
+  }
+
+  @Test
+  public void canSetImage_withNotFailedPrimary_parentCanSetImage_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.canSetImage(coordinator)).thenReturn(true);
+
+    assertThat(coordinator.canSetImage(primary)).isTrue();
+  }
+
+  @Test
+  public void canSetImage_withNotFailedPrimary_parentCanNotSetImage_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+
+    assertThat(coordinator.canSetImage(primary)).isFalse();
+  }
+
+  @Test
+  public void canSetImage_withError_andFailedPrimary_nullParent_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.canSetImage(error)).isTrue();
+  }
+
+  @Test
+  public void canSetImage_withError_andFailedPrimary_nonNullParentCanSetImage_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.canSetImage(coordinator)).thenReturn(true);
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canSetImage(error)).isTrue();
+  }
+
+  @Test
+  public void canSetImage_withError_andFailedPrimary_nonNullParentCanNotSetImage_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canSetImage(error)).isFalse();
+  }
+
+  @Test
+  public void canNotifyStatusChanged_withNotFailedPrimary_nullParent_returnsTrue() {
+    assertThat(coordinator.canNotifyStatusChanged(primary)).isTrue();
+  }
+
+  @Test
+  public void canNotifyStatusChanged_withNotFailedPrimary_nonNullParentCantNotify_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+
+    assertThat(coordinator.canNotifyStatusChanged(primary)).isFalse();
+  }
+
+  @Test
+  public void canNotifyStatusChanged_withNotFailedPrimary_nonNullParentCanNotify_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.canNotifyStatusChanged(coordinator)).thenReturn(true);
+
+    assertThat(coordinator.canNotifyStatusChanged(primary)).isTrue();
+  }
+
+  @Test
+  public void canNotifyStatusChanged_withError_notFailedPrimary_nullParent_returnsFalse() {
+    assertThat(coordinator.canNotifyStatusChanged(error)).isFalse();
+  }
+
+  @Test
+  public void canNotifyStatusChanged_withError_failedPrimary_nullParent_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canNotifyStatusChanged(error)).isTrue();
+  }
+
+  @Test
+  public void canNotifyStatusChanged_withError_failedPrimary_nonNullParentCantNotify_false() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canNotifyStatusChanged(error)).isFalse();
+  }
+
+  @Test
+  public void canNotifyStatusChanged_withError_failedPrimary_nonNullParentCanNotify_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(primary.isFailed()).thenReturn(true);
+    when(parent.canNotifyStatusChanged(coordinator)).thenReturn(true);
+
+    assertThat(coordinator.canNotifyStatusChanged(primary)).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_primaryNotSet_nullParent_returnsFalse() {
+    assertThat(coordinator.isAnyResourceSet()).isFalse();
+  }
+
+  @Test
+  public void isAnyResourceSet_primarySet_nullParent_returnsTrue() {
+    when(primary.isResourceSet()).thenReturn(true);
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_primarySet_parentResourceNotSet_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(primary.isResourceSet()).thenReturn(true);
+
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_primarySet_parentSet_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(primary.isResourceSet()).thenReturn(true);
+    when(parent.isAnyResourceSet()).thenReturn(true);
+
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_parentSet_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.isAnyResourceSet()).thenReturn(true);
+
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_errorSet_notFailedPrimary_nullParent_returnsFalse() {
+    when(error.isResourceSet()).thenReturn(true);
+    assertThat(coordinator.isAnyResourceSet()).isFalse();
+  }
+
+  @Test
+  public void isAnyResourceSet_errorSet_failedPrimary_nullParent_returnsTrue() {
+    when(error.isResourceSet()).thenReturn(true);
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_errorSet_notFailedPrimary_nonNullParentNotSet_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(error.isResourceSet()).thenReturn(true);
+
+    assertThat(coordinator.isAnyResourceSet()).isFalse();
+  }
+
+  @Test
+  public void isAnyResourceSet_errorSet_failedPrimary_nonNullParentNotSet_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(primary.isFailed()).thenReturn(true);
+    when(error.isResourceSet()).thenReturn(true);
+
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_errorSet_nonNullParentSet_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.isAnyResourceSet()).thenReturn(true);
+    when(error.isResourceSet()).thenReturn(true);
+
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_primaryNotSet_errorNotSet_nonNullParentNotSet_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+
+    assertThat(coordinator.isAnyResourceSet()).isFalse();
+  }
+
+  @Test
+  public void isAnyResourceSet_primaryNotSet_errorNotSet_nonNullParentSet_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+
+    when(parent.isAnyResourceSet()).thenReturn(true);
+
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void onRequestSuccess_nullParent_doesNotThrow() {
+    coordinator.onRequestSuccess(primary);
+  }
+
+  @Test
+  public void onRequestSuccess_nonNullParent_callsParent() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.onRequestSuccess(primary);
+    verify(parent).onRequestSuccess(coordinator);
+  }
+
+  @Test
+  public void onRequestFailed_primaryRequest_notRunningError_beingsError() {
+    coordinator.onRequestFailed(primary);
+    verify(error).begin();
+  }
+
+  @Test
+  public void onRequestFailed_primaryRequest_runningError_doesNotBeginError() {
+    when(error.isRunning()).thenReturn(true);
+    coordinator.onRequestFailed(primary);
+
+    verify(error, never()).begin();
+  }
+
+  @Test
+  public void onRequestFailed_errorRequest_doesNotBeginError() {
+    coordinator.onRequestFailed(error);
+    verify(error, never()).begin();
+  }
+
+  @Test
+  public void onRequestFailed_primaryRequest_notRunningError_nonNullParent_doesNotNotifyParent() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+
+    coordinator.onRequestFailed(primary);
+    verify(parent, never()).onRequestFailed(any(Request.class));
+  }
+
+  @Test
+  public void onRequestFailed_errorRequest_nonNullParent_notifiesParent() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+
+    coordinator.onRequestFailed(error);
+
+    verify(parent).onRequestFailed(coordinator);
+  }
+
+  @Test
+  public void onRequestFailed_primaryRequest_runningError_nonNullParent_doesNotNotifyParent() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(error.isRunning()).thenReturn(true);
+
+    coordinator.onRequestFailed(primary);
+
+    verify(parent, never()).onRequestFailed(any(Request.class));
+  }
+
+  @Test
+  public void canNotifyCleared_primaryRequest_nullParent_returnsTrue() {
+    assertThat(coordinator.canNotifyCleared(primary)).isTrue();
+  }
+
+  @Test
+  public void canNotifyCleared_primaryRequest_parentCanNotNotify_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+
+    assertThat(coordinator.canNotifyCleared(primary)).isFalse();
+  }
+
+  @Test
+  public void canNotifyCleared_primaryRequest_parentCanNotify_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.canNotifyCleared(coordinator)).thenReturn(true);
+
+    assertThat(coordinator.canNotifyCleared(primary)).isTrue();
+  }
+
+  @Test
+  public void canNotifyCleared_primaryRequestFailed_parentCanNotify_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.canNotifyCleared(coordinator)).thenReturn(true);
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canNotifyCleared(primary)).isTrue();
+  }
+
+  @Test
+  public void canNotifyCleared_primaryRequestFailed_parentCanNotNotify_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(primary.isFailed()).thenReturn(false);
+
+    assertThat(coordinator.canNotifyCleared(primary)).isFalse();
+  }
+
+  @Test
+  public void canNotifyCleared_primaryRequestFailed_nullParent_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canNotifyCleared(primary)).isTrue();
+  }
+
+  @Test
+  public void canNotifyCleared_errorRequest_nullParent_returnsFalse() {
+    assertThat(coordinator.canNotifyCleared(error)).isFalse();
+  }
+
+  @Test
+  public void canNotifyCleared_errorRequest_primaryFailed_nullParent_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.canNotifyCleared(error)).isTrue();
+  }
+
+  @Test
+  public void canNotifyCleared_errorRequest_primaryFailed_nonNullParentCanNotNotify_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.canNotifyCleared(coordinator)).thenReturn(false);
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canNotifyCleared(error)).isFalse();
+  }
+
+  @Test
+  public void canNotifyCleared_errorRequest_primaryFailed_nonNullParentCanNotify_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.canNotifyCleared(coordinator)).thenReturn(true);
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canNotifyCleared(error)).isTrue();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
similarity index 78%
rename from library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
index cc3c11cd0..c7b48a83d 100644
--- a/library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
@@ -6,6 +6,7 @@
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyLong;
 import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.atLeastOnce;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
@@ -13,6 +14,7 @@
 import static org.mockito.Mockito.verify;
 
 import android.os.Handler;
+import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.request.target.SizeReadyCallback;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.ExecutionException;
@@ -61,7 +63,12 @@ public void testReturnsFalseForDoneBeforeDone() {
 
   @Test
   public void testReturnsTrueFromIsDoneIfDone() {
-    future.onResourceReady(new Object(), null);
+    future.onResourceReady(
+        /*resource=*/ new Object(),
+        /*model=*/ null,
+        /*target=*/future,
+        DataSource.DATA_DISK_CACHE,
+        true /*isFirstResource*/);
     assertTrue(future.isDone());
   }
 
@@ -106,7 +113,12 @@ public void testClearsRequestOnRun() {
 
   @Test
   public void testDoesNotClearRequestIfCancelledAfterDone() {
-    future.onResourceReady(new Object(), null);
+    future.onResourceReady(
+        /*resource=*/ new Object(),
+        /*model=*/ null,
+        /*target=*/future,
+        DataSource.DATA_DISK_CACHE,
+        true /*isFirstResource*/);
     future.cancel(true);
 
     verify(request, never()).clear();
@@ -120,7 +132,12 @@ public void testReturnsTrueFromDoneIfCancelled() {
 
   @Test
   public void testReturnsFalseFromIsCancelledIfCancelledAfterDone() {
-    future.onResourceReady(new Object(), null);
+    future.onResourceReady(
+        /*resource=*/ new Object(),
+        /*model=*/ null,
+        /*target=*/future,
+        DataSource.DATA_DISK_CACHE,
+        true /*isFirstResource*/);
     future.cancel(true);
 
     assertFalse(future.isCancelled());
@@ -134,7 +151,12 @@ public void testReturnsTrueFromCancelIfCancelled() {
 
   @Test
   public void testReturnsFalseFromCancelIfDone() {
-    future.onResourceReady(new Object(), null);
+    future.onResourceReady(
+        /*resource=*/ new Object(),
+        /*model=*/ null,
+        /*target=*/future,
+        DataSource.DATA_DISK_CACHE,
+        true /*isFirstResource*/);
     assertFalse(future.cancel(true));
   }
 
@@ -142,7 +164,12 @@ public void testReturnsFalseFromCancelIfDone() {
   public void testReturnsResourceOnGetIfAlreadyDone()
       throws ExecutionException, InterruptedException {
     Object expected = new Object();
-    future.onResourceReady(expected, null);
+    future.onResourceReady(
+        /*resource=*/ expected,
+        /*model=*/ null,
+        /*target=*/future,
+        DataSource.DATA_DISK_CACHE,
+        true /*isFirstResource*/);
 
     assertEquals(expected, future.get());
   }
@@ -151,9 +178,14 @@ public void testReturnsResourceOnGetIfAlreadyDone()
   public void testReturnsResourceOnGetWithTimeoutIfAlreadyDone()
       throws InterruptedException, ExecutionException, TimeoutException {
     Object expected = new Object();
-    future.onResourceReady(expected, null);
+    future.onResourceReady(
+        /*resource=*/ expected,
+        /*model=*/ null,
+        /*target=*/future,
+        DataSource.DATA_DISK_CACHE,
+        true /*isFirstResource*/);
 
-    assertEquals(expected, future.get(100, TimeUnit.MILLISECONDS));
+    assertEquals(expected, future.get(1, TimeUnit.MILLISECONDS));
   }
 
   @Test(expected = CancellationException.class)
@@ -173,21 +205,21 @@ public void testThrowsCancellationExceptionIfCancelledBeforeGetWithTimeout()
   @Test(expected = ExecutionException.class)
   public void testThrowsExecutionExceptionOnGetIfExceptionBeforeGet()
       throws ExecutionException, InterruptedException {
-    future.onLoadFailed(null);
+    future.onLoadFailed(/*e=*/ null, /*model=*/ null, future, /*isFirstResource=*/ true);
     future.get();
   }
 
   @Test(expected = ExecutionException.class)
   public void testThrowsExecutionExceptionOnGetIfExceptionWithNullValueBeforeGet()
       throws ExecutionException, InterruptedException, TimeoutException {
-    future.onLoadFailed(null);
+    future.onLoadFailed(/*e=*/ null, /*model=*/ null, future, /*isFirstResource=*/ true);
     future.get(100, TimeUnit.MILLISECONDS);
   }
 
   @Test(expected = ExecutionException.class)
   public void testThrowsExecutionExceptionOnGetIfExceptionBeforeGetWithTimeout()
       throws ExecutionException, InterruptedException, TimeoutException {
-    future.onLoadFailed(null);
+    future.onLoadFailed(/*e=*/ null, /*model=*/ null, future, /*isFirstResource=*/ true);
     future.get(100, TimeUnit.MILLISECONDS);
   }
 
@@ -208,7 +240,12 @@ public void testThrowsExceptionIfGetCalledOnMainThread()
   public void testGetSucceedsOnMainThreadIfDone()
       throws ExecutionException, InterruptedException {
     future = new RequestFutureTarget<>(handler, width, height, true, waiter);
-    future.onResourceReady(new Object(), null);
+    future.onResourceReady(
+        /*resource=*/ new Object(),
+        /*model=*/ null,
+        /*target=*/future,
+        DataSource.DATA_DISK_CACHE,
+        true /*isFirstResource*/);
     future.get();
   }
 
@@ -232,7 +269,7 @@ public void testThrowsExecutionExceptionIfLoadFailsWhileWaiting()
     doAnswer(new Answer<Void>() {
       @Override
       public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        future.onLoadFailed(null);
+        future.onLoadFailed(/*e=*/ null, /*model=*/ null, future, /*isFirstResource=*/ true);
         return null;
       }
     }).when(waiter).waitForTimeout(eq(future), anyLong());
@@ -266,13 +303,18 @@ public void testThrowsAssertionErrorIfFinishesWaitingWithoutTimeoutAndDoesNotRec
 
   @Test
   public void testNotifiesAllWhenLoadFails() {
-    future.onLoadFailed(null);
+    future.onLoadFailed(/*e=*/ null, /*model=*/ null, future, /*isFirstResource=*/ true);
     verify(waiter).notifyAll(eq(future));
   }
 
   @Test
   public void testNotifiesAllWhenResourceReady() {
-    future.onResourceReady(null, null);
+    future.onResourceReady(
+        /*resource=*/ new Object(),
+        /*model=*/ null,
+        /*target=*/future,
+        DataSource.DATA_DISK_CACHE,
+        true /*isFirstResource*/);
     verify(waiter).notifyAll(eq(future));
   }
 
@@ -297,7 +339,12 @@ public void testReturnsResourceIfReceivedWhileWaiting()
     doAnswer(new Answer<Void>() {
       @Override
       public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        future.onResourceReady(expected, null);
+        future.onResourceReady(
+            /*resource=*/ expected,
+            /*model=*/ null,
+            /*target=*/future,
+            DataSource.DATA_DISK_CACHE,
+            true /*isFirstResource*/);
         return null;
       }
     }).when(waiter).waitForTimeout(eq(future), anyLong());
@@ -318,30 +365,31 @@ public void testWaitsForeverIfNoTimeoutSet() throws InterruptedException {
 
   @Test
   public void testWaitsForGivenTimeoutMillisIfTimeoutSet() throws InterruptedException {
-    long timeout = 1234;
+    long timeout = 2;
     try {
-      future.get(1234, TimeUnit.MILLISECONDS);
+      future.get(timeout, TimeUnit.MILLISECONDS);
     } catch (InterruptedException | ExecutionException e) {
       throw new RuntimeException(e);
     } catch (TimeoutException e) {
       // Expected.
     }
 
-    verify(waiter).waitForTimeout(eq(future), eq(timeout));
+    verify(waiter, atLeastOnce()).waitForTimeout(eq(future), eq(timeout));
   }
 
   @Test
   public void testConvertsOtherTimeUnitsToMillisForWaiter() throws InterruptedException {
-    long timeoutSeconds = 10;
+    long timeoutMicros = 1000;
     try {
-      future.get(timeoutSeconds, TimeUnit.SECONDS);
+      future.get(timeoutMicros, TimeUnit.MICROSECONDS);
     } catch (InterruptedException | ExecutionException e) {
       throw new RuntimeException(e);
     } catch (TimeoutException e) {
       // Expected.
     }
 
-    verify(waiter).waitForTimeout(eq(future), eq(TimeUnit.SECONDS.toMillis(timeoutSeconds)));
+    verify(waiter, atLeastOnce())
+        .waitForTimeout(eq(future), eq(TimeUnit.MICROSECONDS.toMillis(timeoutMicros)));
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java b/library/test/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java
similarity index 91%
rename from library/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java
index b8940197b..aa61bc883 100644
--- a/library/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java
@@ -262,6 +262,38 @@ public void testApplyMultiTransform() {
       .isInstanceOf(MultiTransformation.class);
   }
 
+  @Test
+  public void isSkipMemoryCacheSet_withoutSkipMemoryCache_isFalse() {
+    assertThat(options.isSkipMemoryCacheSet()).isFalse();
+  }
+
+  @Test
+  public void isSkipMemoryCacheSet_withSkipMemoryCacheTrue_isTrue() {
+    assertThat(options.skipMemoryCache(true).isSkipMemoryCacheSet()).isTrue();
+  }
+
+  @Test
+  public void isSkipMemoryCacheSet_withSkipMemoryCacheFalse_isTrue() {
+    assertThat(options.skipMemoryCache(false).isSkipMemoryCacheSet()).isTrue();
+  }
+
+  @Test
+  public void isDiskCacheStrategySet_withoutDiskCacheStrategy_isFalse() {
+    assertThat(options.isDiskCacheStrategySet()).isFalse();
+  }
+
+  @Test
+  public void isDiskCacheStrategySet_withDiskCacheStrategyDefault_isTrue() {
+    assertThat(options.diskCacheStrategy(DiskCacheStrategy.AUTOMATIC).isDiskCacheStrategySet())
+        .isTrue();
+  }
+
+  @Test
+  public void isDiskCacheStrategySet_withDiskCacheStrategyNonDefault_isTrue() {
+    assertThat(options.diskCacheStrategy(DiskCacheStrategy.ALL).isDiskCacheStrategySet())
+        .isTrue();
+  }
+
   @Test
   public void testEqualsHashCode() {
     Drawable first = new ColorDrawable(Color.RED);
@@ -336,12 +368,12 @@ public void testEqualsHashCode() {
         .addEqualityGroup(
             new RequestOptions().priority(Priority.LOW))
         .addEqualityGroup(
-            new RequestOptions().set(Option.<Boolean>memory("test"), true),
-            new RequestOptions().set(Option.<Boolean>memory("test"), true))
+            new RequestOptions().set(Option.memory("test"), true),
+            new RequestOptions().set(Option.memory("test"), true))
         .addEqualityGroup(
-            new RequestOptions().set(Option.<Boolean>memory("test"), false))
+            new RequestOptions().set(Option.memory("test"), false))
         .addEqualityGroup(
-            new RequestOptions().set(Option.<Boolean>memory("test2"), true))
+            new RequestOptions().set(Option.memory("test2"), true))
         .addEqualityGroup(
             new RequestOptions().decode(Integer.class),
             new RequestOptions().decode(Integer.class))
diff --git a/library/test/src/test/java/com/bumptech/glide/request/SingleRequestTest.java b/library/test/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
new file mode 100644
index 000000000..b41596250
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
@@ -0,0 +1,1150 @@
+package com.bumptech.glide.request;
+
+import static com.bumptech.glide.tests.Util.isADataSource;
+import static com.bumptech.glide.tests.Util.mockResource;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyBoolean;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Matchers.isA;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.graphics.Color;
+import android.graphics.drawable.ColorDrawable;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.GlideContext;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.engine.Engine;
+import com.bumptech.glide.load.engine.GlideException;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.request.target.SizeReadyCallback;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.request.transition.TransitionFactory;
+import com.bumptech.glide.signature.ObjectKey;
+import com.google.common.base.Equivalence;
+import com.google.common.testing.EquivalenceTester;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+@SuppressWarnings("rawtypes")
+public class SingleRequestTest {
+
+  private SingleRequestBuilder builder;
+
+  @Before
+  public void setUp() {
+    builder = new SingleRequestBuilder();
+  }
+
+  @Test
+  public void testIsNotCompleteBeforeReceivingResource() {
+    SingleRequest<List> request = builder.build();
+
+    assertFalse(request.isComplete());
+  }
+
+  @Test
+  public void testCanHandleNullResources() {
+    SingleRequest<List> request = builder.build();
+
+    request.onResourceReady(null, DataSource.LOCAL);
+
+    assertTrue(request.isFailed());
+    verify(builder.requestListener).onLoadFailed(isAGlideException(), isA(Number.class),
+        eq(builder.target), anyBoolean());
+  }
+
+  @Test
+  public void testCanHandleEmptyResources() {
+    SingleRequest<List> request = builder.build();
+    when(builder.resource.get()).thenReturn(null);
+
+    request.onResourceReady(builder.resource, DataSource.REMOTE);
+
+    assertTrue(request.isFailed());
+    verify(builder.engine).release(eq(builder.resource));
+    verify(builder.requestListener).onLoadFailed(isAGlideException(), any(Number.class),
+        eq(builder.target), anyBoolean());
+  }
+
+  @Test
+  public void testCanHandleNonConformingResources() {
+    SingleRequest<List> request = builder.build();
+    when(((Resource) (builder.resource)).get())
+        .thenReturn("Invalid mocked String, this should be a List");
+
+    request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
+
+    assertTrue(request.isFailed());
+    verify(builder.engine).release(eq(builder.resource));
+    verify(builder.requestListener).onLoadFailed(isAGlideException(), any(Number.class),
+        eq(builder.target), anyBoolean());
+  }
+
+  @Test
+  public void testIsNotFailedAfterClear() {
+    SingleRequest<List> request = builder.build();
+
+    request.onResourceReady(null, DataSource.DATA_DISK_CACHE);
+    request.clear();
+
+    assertFalse(request.isFailed());
+  }
+
+  @Test
+  public void testIsPausedAfterPause() {
+    SingleRequest<List> request = builder.build();
+    request.pause();
+
+    assertTrue(request.isPaused());
+  }
+
+  @Test
+  public void testIsNotCancelledAfterPause() {
+    SingleRequest<List> request = builder.build();
+    request.pause();
+
+    assertFalse(request.isCancelled());
+  }
+
+  @Test
+  public void testIsNotPausedAfterBeginningWhilePaused() {
+    SingleRequest<List> request = builder.build();
+    request.pause();
+    request.begin();
+
+    assertFalse(request.isPaused());
+    assertTrue(request.isRunning());
+  }
+
+  @Test
+  public void testIsNotFailedAfterBegin() {
+    SingleRequest<List> request = builder.build();
+
+    request.onResourceReady(null, DataSource.DATA_DISK_CACHE);
+    request.begin();
+
+    assertFalse(request.isFailed());
+  }
+
+  @Test
+  public void testIsCompleteAfterReceivingResource() {
+    SingleRequest<List> request = builder.build();
+
+    request.onResourceReady(builder.resource, DataSource.LOCAL);
+
+    assertTrue(request.isComplete());
+  }
+
+  @Test
+  public void testIsNotCompleteAfterClear() {
+    SingleRequest<List> request = builder.build();
+    request.onResourceReady(builder.resource, DataSource.REMOTE);
+    request.clear();
+
+    assertFalse(request.isComplete());
+  }
+
+  @Test
+  public void testIsCancelledAfterClear() {
+    SingleRequest<List> request = builder.build();
+    request.clear();
+
+    assertTrue(request.isCancelled());
+  }
+
+  @Test
+  public void clear_notifiesTarget() {
+    SingleRequest<List> request = builder.build();
+    request.clear();
+
+    verify(builder.target).onLoadCleared(any(Drawable.class));
+  }
+
+  @Test
+  public void testDoesNotNotifyTargetTwiceIfClearedTwiceInARow() {
+    SingleRequest<List> request = builder.build();
+    request.clear();
+    request.clear();
+
+    verify(builder.target, times(1)).onLoadCleared(any(Drawable.class));
+  }
+
+  @Test
+  public void clear_doesNotNotifyTarget_ifRequestCoordinatorReturnsFalseForCanClear() {
+    when(builder.requestCoordinator.canNotifyCleared(any(Request.class))).thenReturn(false);
+    SingleRequest<List> request = builder.build();
+    request.clear();
+
+    verify(builder.target, never()).onLoadCleared(any(Drawable.class));
+  }
+
+  @Test
+  public void testResourceIsNotCompleteWhenAskingCoordinatorIfCanSetImage() {
+    RequestCoordinator requestCoordinator = mock(RequestCoordinator.class);
+    doAnswer(new Answer() {
+      @Override
+      public Object answer(InvocationOnMock invocation) {
+        Request request = (Request) invocation.getArguments()[0];
+        assertFalse(request.isComplete());
+        return true;
+      }
+    }).when(requestCoordinator).canSetImage(any(Request.class));
+
+    SingleRequest<List> request = builder
+        .setRequestCoordinator(requestCoordinator)
+        .build();
+
+    request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
+
+    verify(requestCoordinator).canSetImage(eq(request));
+  }
+
+  @Test
+  public void testIsNotFailedWithoutException() {
+    SingleRequest<List> request = builder.build();
+
+    assertFalse(request.isFailed());
+  }
+
+  @Test
+  public void testIsFailedAfterException() {
+    SingleRequest<List> request = builder.build();
+
+    request.onLoadFailed(new GlideException("test"));
+    assertTrue(request.isFailed());
+  }
+
+  @Test
+  public void testIgnoresOnSizeReadyIfNotWaitingForSize() {
+    SingleRequest<List> request = builder.build();
+    request.begin();
+    request.onSizeReady(100, 100);
+    request.onSizeReady(100, 100);
+
+    verify(builder.engine, times(1))
+        .load(
+            eq(builder.glideContext),
+            eq(builder.model),
+            eq(builder.signature),
+            eq(100),
+            eq(100),
+            eq(Object.class),
+            eq(List.class),
+            any(Priority.class),
+            any(DiskCacheStrategy.class),
+            eq(builder.transformations),
+            anyBoolean(),
+            anyBoolean(),
+            any(Options.class),
+            anyBoolean(),
+            anyBoolean(),
+            /*useAnimationPool=*/ anyBoolean(),
+            anyBoolean(),
+            any(ResourceCallback.class));
+  }
+
+  @Test
+  public void testIsFailedAfterNoResultAndNullException() {
+    SingleRequest<List> request = builder.build();
+
+    request.onLoadFailed(new GlideException("test"));
+    assertTrue(request.isFailed());
+  }
+
+  @Test
+  public void testEngineLoadCancelledOnCancel() {
+    Engine.LoadStatus loadStatus = mock(Engine.LoadStatus.class);
+
+    when(builder.engine
+        .load(
+            eq(builder.glideContext),
+            eq(builder.model),
+            eq(builder.signature),
+            anyInt(),
+            anyInt(),
+            eq(Object.class),
+            eq(List.class),
+            any(Priority.class),
+            any(DiskCacheStrategy.class),
+            eq(builder.transformations),
+            anyBoolean(),
+            anyBoolean(),
+            any(Options.class),
+            anyBoolean(),
+            anyBoolean(),
+            anyBoolean(),
+            anyBoolean(),
+            any(ResourceCallback.class)))
+        .thenReturn(loadStatus);
+
+    SingleRequest<List> request = builder.build();
+    request.begin();
+
+    request.onSizeReady(100, 100);
+    request.cancel();
+
+    verify(loadStatus).cancel();
+  }
+
+  @Test
+  public void testResourceIsRecycledOnClear() {
+    SingleRequest<List> request = builder.build();
+
+    request.onResourceReady(builder.resource, DataSource.REMOTE);
+    request.clear();
+
+    verify(builder.engine).release(eq(builder.resource));
+  }
+
+  @Test
+  public void testPlaceholderDrawableIsSet() {
+    Drawable expected = new ColorDrawable(Color.RED);
+
+    MockTarget target = new MockTarget();
+
+    SingleRequest<List> request = builder
+        .setPlaceholderDrawable(expected)
+        .setTarget(target)
+        .build();
+    request.begin();
+
+    assertThat(target.currentPlaceholder).isEqualTo(expected);
+  }
+
+  @Test
+  public void testErrorDrawableIsSetOnLoadFailed() {
+    Drawable expected = new ColorDrawable(Color.RED);
+
+    MockTarget target = new MockTarget();
+
+    SingleRequest<List> request = builder
+        .setErrorDrawable(expected)
+        .setTarget(target)
+        .build();
+
+    request.onLoadFailed(new GlideException("test"));
+
+    assertThat(target.currentPlaceholder).isEqualTo(expected);
+  }
+
+  @Test
+  public void testPlaceholderDrawableSetOnNullModelWithNoErrorDrawable() {
+    Drawable placeholder = new ColorDrawable(Color.RED);
+
+    MockTarget target = new MockTarget();
+
+    SingleRequest<List> request = builder
+        .setErrorDrawable(placeholder)
+        .setTarget(target)
+        .setModel(null)
+        .build();
+
+    request.begin();
+
+    assertThat(target.currentPlaceholder).isEqualTo(placeholder);
+  }
+
+  @Test
+  public void testErrorDrawableSetOnNullModelWithErrorDrawable() {
+    Drawable placeholder = new ColorDrawable(Color.RED);
+    Drawable errorPlaceholder = new ColorDrawable(Color.GREEN);
+
+    MockTarget target = new MockTarget();
+
+    SingleRequest<List> request = builder
+        .setPlaceholderDrawable(placeholder)
+        .setErrorDrawable(errorPlaceholder)
+        .setTarget(target)
+        .setModel(null)
+        .build();
+
+    request.begin();
+
+    assertThat(target.currentPlaceholder).isEqualTo(errorPlaceholder);
+  }
+
+
+  @Test
+  public void testFallbackDrawableSetOnNullModelWithErrorAndFallbackDrawables() {
+    Drawable placeholder = new ColorDrawable(Color.RED);
+    Drawable errorPlaceholder = new ColorDrawable(Color.GREEN);
+    Drawable fallback = new ColorDrawable(Color.BLUE);
+
+    MockTarget target = new MockTarget();
+    SingleRequest<List> request = builder
+        .setPlaceholderDrawable(placeholder)
+        .setErrorDrawable(errorPlaceholder)
+        .setFallbackDrawable(fallback)
+        .setTarget(target)
+        .setModel(null)
+        .build();
+    request.begin();
+
+    assertThat(target.currentPlaceholder).isEqualTo(fallback);
+  }
+
+
+  @Test
+  public void testIsNotRunningBeforeRunCalled() {
+    assertFalse(builder.build().isRunning());
+  }
+
+  @Test
+  public void testIsRunningAfterRunCalled() {
+    Request request = builder.build();
+    request.begin();
+    assertTrue(request.isRunning());
+  }
+
+  @Test
+  public void testIsNotRunningAfterComplete() {
+    SingleRequest<List> request = builder.build();
+    request.begin();
+    request.onResourceReady(builder.resource, DataSource.REMOTE);
+
+    assertFalse(request.isRunning());
+  }
+
+  @Test
+  public void testIsNotRunningAfterFailing() {
+    SingleRequest<List> request = builder.build();
+    request.begin();
+    request.onLoadFailed(new GlideException("test"));
+
+    assertFalse(request.isRunning());
+  }
+
+  @Test
+  public void testIsNotRunningAfterClear() {
+    SingleRequest<List> request = builder.build();
+    request.begin();
+    request.clear();
+
+    assertFalse(request.isRunning());
+  }
+
+  @Test
+  public void testCallsTargetOnResourceReadyIfNoRequestListener() {
+    SingleRequest<List> request = builder
+        .setRequestListener(null)
+        .build();
+    request.onResourceReady(builder.resource, DataSource.LOCAL);
+
+    verify(builder.target).onResourceReady(eq(builder.result), anyTransition());
+  }
+
+  @Test
+  public void testCallsTargetOnResourceReadyIfRequestListenerReturnsFalse() {
+    SingleRequest<List> request = builder.build();
+    when(builder.requestListener
+        .onResourceReady(any(List.class), any(Number.class), eq(builder.target), isADataSource(),
+            anyBoolean())).thenReturn(false);
+    request.onResourceReady(builder.resource, DataSource.LOCAL);
+
+    verify(builder.target).onResourceReady(eq(builder.result), anyTransition());
+  }
+
+  @Test
+  public void testDoesNotCallTargetOnResourceReadyIfRequestListenerReturnsTrue() {
+    SingleRequest<List> request = builder.build();
+    when(builder.requestListener
+        .onResourceReady(any(List.class), any(Number.class), eq(builder.target), isADataSource(),
+            anyBoolean())).thenReturn(true);
+    request.onResourceReady(builder.resource, DataSource.REMOTE);
+
+    verify(builder.target, never()).onResourceReady(any(List.class), anyTransition());
+  }
+
+  @Test
+  public void testCallsTargetOnExceptionIfNoRequestListener() {
+    SingleRequest<List> request = builder
+        .setRequestListener(null)
+        .build();
+    request.onLoadFailed(new GlideException("test"));
+
+    verify(builder.target).onLoadFailed(eq(builder.errorDrawable));
+  }
+
+  @Test
+  public void testCallsTargetOnExceptionIfRequestListenerReturnsFalse() {
+    SingleRequest<List> request = builder.build();
+    when(builder.requestListener.onLoadFailed(isAGlideException(), any(Number.class),
+        eq(builder.target), anyBoolean()))
+        .thenReturn(false);
+    request.onLoadFailed(new GlideException("test"));
+
+    verify(builder.target).onLoadFailed(eq(builder.errorDrawable));
+  }
+
+  @Test
+  public void testDoesNotCallTargetOnExceptionIfRequestListenerReturnsTrue() {
+    SingleRequest<List> request = builder.build();
+    when(builder.requestListener.onLoadFailed(isAGlideException(), any(Number.class),
+        eq(builder.target), anyBoolean()))
+        .thenReturn(true);
+
+    request.onLoadFailed(new GlideException("test"));
+
+    verify(builder.target, never()).onLoadFailed(any(Drawable.class));
+  }
+
+  @Test
+  public void testRequestListenerIsCalledWithResourceResult() {
+    SingleRequest<List> request = builder.build();
+    request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
+
+    verify(builder.requestListener)
+        .onResourceReady(eq(builder.result), any(Number.class), isAListTarget(), isADataSource(),
+            anyBoolean());
+  }
+
+  @Test
+  public void testRequestListenerIsCalledWithModel() {
+    SingleRequest<List> request = builder.build();
+    request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
+
+    verify(builder.requestListener)
+        .onResourceReady(any(List.class), eq(builder.model), isAListTarget(), isADataSource(),
+            anyBoolean());
+  }
+
+  @Test
+  public void testRequestListenerIsCalledWithTarget() {
+    SingleRequest<List> request = builder.build();
+    request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
+
+    verify(builder.requestListener)
+        .onResourceReady(any(List.class), any(Number.class), eq(builder.target), isADataSource(),
+            anyBoolean());
+  }
+
+  @Test
+  public void testRequestListenerIsCalledWithLoadedFromMemoryIfLoadCompletesSynchronously() {
+    final SingleRequest<List> request = builder.build();
+
+    when(builder.engine
+        .load(
+            eq(builder.glideContext),
+            eq(builder.model),
+            eq(builder.signature),
+            anyInt(),
+            anyInt(),
+            eq(Object.class),
+            eq(List.class),
+            any(Priority.class),
+            any(DiskCacheStrategy.class),
+            eq(builder.transformations),
+            anyBoolean(),
+            anyBoolean(),
+            any(Options.class),
+            anyBoolean(),
+            anyBoolean(),
+            /*useAnimationPool=*/ anyBoolean(),
+            anyBoolean(),
+            any(ResourceCallback.class)))
+        .thenAnswer(new Answer<Object>() {
+          @Override
+          public Object answer(InvocationOnMock invocation) {
+            request.onResourceReady(builder.resource, DataSource.MEMORY_CACHE);
+            return null;
+          }
+        });
+
+    request.begin();
+    request.onSizeReady(100, 100);
+    verify(builder.requestListener)
+        .onResourceReady(eq(builder.result), any(Number.class), isAListTarget(),
+            eq(DataSource.MEMORY_CACHE), anyBoolean());
+  }
+
+  @Test
+  public void
+  testRequestListenerIsCalledWithNotLoadedFromMemoryCacheIfLoadCompletesAsynchronously() {
+    SingleRequest<List> request = builder.build();
+    request.onSizeReady(100, 100);
+    request.onResourceReady(builder.resource, DataSource.LOCAL);
+
+    verify(builder.requestListener)
+        .onResourceReady(eq(builder.result), any(Number.class), isAListTarget(),
+            eq(DataSource.LOCAL), anyBoolean());
+  }
+
+  @Test
+  public void testRequestListenerIsCalledWithIsFirstResourceIfNoRequestCoordinator() {
+    SingleRequest<List> request = builder
+        .setRequestCoordinator(null)
+        .build();
+    request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
+
+    verify(builder.requestListener)
+        .onResourceReady(eq(builder.result), any(Number.class), isAListTarget(), isADataSource(),
+            eq(true));
+  }
+
+  @Test
+  public void testRequestListenerIsCalledWithFirstImageIfRequestCoordinatorReturnsNoResourceSet() {
+    SingleRequest<List> request = builder.build();
+    when(builder.requestCoordinator.isAnyResourceSet()).thenReturn(false);
+    request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
+
+    verify(builder.requestListener)
+        .onResourceReady(eq(builder.result), any(Number.class), isAListTarget(), isADataSource(),
+            eq(true));
+  }
+
+  @Test
+  public void
+  testRequestListenerIsCalledWithNotIsFirstRequestIfRequestCoordinatorReturnsResourceSet() {
+    SingleRequest<List> request = builder.build();
+    when(builder.requestCoordinator.isAnyResourceSet()).thenReturn(true);
+    request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
+
+    verify(builder.requestListener)
+        .onResourceReady(eq(builder.result), any(Number.class), isAListTarget(),
+            isADataSource(), eq(false));
+  }
+
+  @Test
+  public void testTargetIsCalledWithAnimationFromFactory() {
+    SingleRequest<List> request = builder.build();
+    Transition<List> transition = mockTransition();
+    when(builder.transitionFactory.build(any(DataSource.class), anyBoolean()))
+        .thenReturn(transition);
+    request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
+
+    verify(builder.target).onResourceReady(eq(builder.result), eq(transition));
+  }
+
+  @Test
+  public void testCallsGetSizeIfOverrideWidthIsLessThanZero() {
+    SingleRequest<List> request = builder
+        .setOverrideWidth(-1)
+        .setOverrideHeight(100)
+        .build();
+    request.begin();
+
+    verify(builder.target).getSize(any(SizeReadyCallback.class));
+  }
+
+  @Test
+  public void testCallsGetSizeIfOverrideHeightIsLessThanZero() {
+    SingleRequest<List> request = builder
+        .setOverrideWidth(100)
+        .setOverrideHeight(-1)
+        .build();
+    request.begin();
+
+    verify(builder.target).getSize(any(SizeReadyCallback.class));
+  }
+
+  @Test
+  public void testDoesNotCallGetSizeIfOverrideWidthAndHeightAreSet() {
+    SingleRequest<List> request = builder
+        .setOverrideWidth(100)
+        .setOverrideHeight(100)
+        .build();
+    request.begin();
+
+    verify(builder.target, never()).getSize(any(SizeReadyCallback.class));
+  }
+
+  @Test
+  public void testCallsEngineWithOverrideWidthAndHeightIfSet() {
+    SingleRequest<List> request = builder
+        .setOverrideWidth(1)
+        .setOverrideHeight(2)
+        .build();
+    request.begin();
+
+    verify(builder.engine)
+        .load(
+            eq(builder.glideContext),
+            eq(builder.model),
+            eq(builder.signature),
+            anyInt(),
+            anyInt(),
+            eq(Object.class),
+            eq(List.class),
+            any(Priority.class),
+            any(DiskCacheStrategy.class),
+            eq(builder.transformations),
+            anyBoolean(),
+            anyBoolean(),
+            any(Options.class),
+            anyBoolean(),
+            anyBoolean(),
+            /*useAnimationPool=*/ anyBoolean(),
+            anyBoolean(),
+            any(ResourceCallback.class));
+  }
+
+  @Test
+  public void testDoesNotSetErrorDrawableIfRequestCoordinatorDoesntAllowIt() {
+    SingleRequest<List> request = builder
+        .setErrorDrawable(new ColorDrawable(Color.RED))
+        .build();
+    when(builder.requestCoordinator.canNotifyStatusChanged(any(Request.class))).thenReturn(false);
+    request.onLoadFailed(new GlideException("test"));
+
+    verify(builder.target, never()).onLoadFailed(any(Drawable.class));
+  }
+
+  @Test
+  public void testCanReRunCancelledRequests() {
+    doAnswer(new CallSizeReady(100, 100)).when(builder.target)
+        .getSize(any(SizeReadyCallback.class));
+
+    when(builder.engine
+        .load(
+            eq(builder.glideContext),
+            eq(builder.model),
+            eq(builder.signature),
+            eq(100),
+            eq(100),
+            eq(Object.class),
+            eq(List.class),
+            any(Priority.class),
+            any(DiskCacheStrategy.class),
+            eq(builder.transformations),
+            anyBoolean(),
+            anyBoolean(),
+            any(Options.class),
+            anyBoolean(),
+            anyBoolean(),
+            /*useAnimationPool=*/ anyBoolean(),
+            anyBoolean(),
+            any(ResourceCallback.class)))
+        .thenAnswer(new CallResourceCallback(builder.resource));
+    SingleRequest<List> request = builder.build();
+
+    request.begin();
+    request.cancel();
+    request.begin();
+
+    verify(builder.target, times(2)).onResourceReady(eq(builder.result), anyTransition());
+  }
+
+  @Test
+  public void testResourceOnlyReceivesOneGetOnResourceReady() {
+    SingleRequest<List> request = builder.build();
+    request.onResourceReady(builder.resource, DataSource.LOCAL);
+
+    verify(builder.resource, times(1)).get();
+  }
+
+  @Test
+  public void testDoesNotStartALoadIfOnSizeReadyIsCalledAfterCancel() {
+    SingleRequest<List> request = builder.build();
+    request.cancel();
+    request.onSizeReady(100, 100);
+
+    verify(builder.engine, never())
+        .load(
+            eq(builder.glideContext),
+            eq(builder.model),
+            eq(builder.signature),
+            anyInt(),
+            anyInt(),
+            eq(Object.class),
+            eq(List.class),
+            any(Priority.class),
+            any(DiskCacheStrategy.class),
+            eq(builder.transformations),
+            anyBoolean(),
+            anyBoolean(),
+            any(Options.class),
+            anyBoolean(),
+            anyBoolean(),
+            /*useAnimationPool=*/ anyBoolean(),
+            anyBoolean(),
+            any(ResourceCallback.class));
+  }
+
+
+  @Test
+  public void testCallsSourceUnlimitedExecutorEngineIfOptionsIsSet() {
+    doAnswer(new CallSizeReady(100, 100)).when(builder.target)
+        .getSize(any(SizeReadyCallback.class));
+
+    SingleRequest<List> request = builder
+        .setUseUnlimitedSourceGeneratorsPool(true)
+        .build();
+    request.begin();
+
+    verify(builder.engine)
+        .load(
+            eq(builder.glideContext),
+            eq(builder.model),
+            eq(builder.signature),
+            anyInt(),
+            anyInt(),
+            eq(Object.class),
+            eq(List.class),
+            any(Priority.class),
+            any(DiskCacheStrategy.class),
+            eq(builder.transformations),
+            anyBoolean(),
+            anyBoolean(),
+            any(Options.class),
+            anyBoolean(),
+            eq(true),
+            /*useAnimationPool=*/ anyBoolean(),
+            anyBoolean(),
+            any(ResourceCallback.class));
+  }
+
+  @Test
+  public void testCallsSourceExecutorEngineIfOptionsIsSet() {
+    doAnswer(new CallSizeReady(100, 100)).when(builder.target)
+        .getSize(any(SizeReadyCallback.class));
+
+    SingleRequest<List> request = builder
+        .setUseUnlimitedSourceGeneratorsPool(false)
+        .build();
+    request.begin();
+
+    verify(builder.engine)
+        .load(
+            eq(builder.glideContext),
+            eq(builder.model),
+            eq(builder.signature),
+            anyInt(),
+            anyInt(),
+            eq(Object.class),
+            eq(List.class),
+            any(Priority.class),
+            any(DiskCacheStrategy.class),
+            eq(builder.transformations),
+            anyBoolean(),
+            anyBoolean(),
+            any(Options.class),
+            anyBoolean(),
+            eq(false),
+            /*useAnimationPool=*/ anyBoolean(),
+            anyBoolean(),
+            any(ResourceCallback.class));
+  }
+
+  @Test
+  // Varargs
+  @SuppressWarnings("unchecked")
+  public void testIsEquivalentTo() {
+    EquivalenceTester<SingleRequestBuilder> tester = EquivalenceTester
+        .of(new Equivalence<SingleRequestBuilder>() {
+          @Override
+          protected boolean doEquivalent(
+              @NonNull SingleRequestBuilder a, @NonNull SingleRequestBuilder b) {
+            return a.build().isEquivalentTo(b.build()) && b.build().isEquivalentTo(a.build());
+          }
+
+          @Override
+          protected int doHash(@NonNull SingleRequestBuilder listSingleRequest) {
+            return 0;
+          }
+        });
+    tester
+        .addEquivalenceGroup(
+            new SingleRequestBuilder(),
+            new SingleRequestBuilder(),
+            // Non-null request listeners are treated as equivalent, even if they're not equal.
+            new SingleRequestBuilder().setRequestListener(mock(RequestListener.class)))
+        .addEquivalenceGroup(
+            new SingleRequestBuilder().setRequestListener(null),
+            new SingleRequestBuilder().setRequestListener(null))
+        .addEquivalenceGroup(
+            new SingleRequestBuilder().setOverrideHeight(500),
+            new SingleRequestBuilder().setOverrideHeight(500))
+        .addEquivalenceGroup(
+            new SingleRequestBuilder().setOverrideWidth(500),
+            new SingleRequestBuilder().setOverrideWidth(500))
+        .addEquivalenceGroup(
+            new SingleRequestBuilder().setModel(12345),
+            new SingleRequestBuilder().setModel(12345))
+        .addEquivalenceGroup(
+            new SingleRequestBuilder().setModel(null),
+            new SingleRequestBuilder().setModel(null))
+        .addEquivalenceGroup(
+            new SingleRequestBuilder().setErrorDrawable(new ColorDrawable(Color.GRAY)),
+            new SingleRequestBuilder().setErrorDrawable(new ColorDrawable(Color.GRAY)))
+        .addEquivalenceGroup(
+            new SingleRequestBuilder().setPriority(Priority.LOW),
+            new SingleRequestBuilder().setPriority(Priority.LOW))
+        .test();
+  }
+
+  static final class SingleRequestBuilder {
+    private Engine engine = mock(Engine.class);
+    private Number model = 123456;
+    @SuppressWarnings("unchecked")
+    private Target<List> target = mock(Target.class);
+    private Resource<List> resource = mockResource();
+    private RequestCoordinator requestCoordinator = mock(RequestCoordinator.class);
+    private Drawable placeholderDrawable = null;
+    private Drawable errorDrawable = null;
+    private Drawable fallbackDrawable = null;
+    @SuppressWarnings("unchecked")
+    private RequestListener<List> requestListener = mock(RequestListener.class);
+    @SuppressWarnings("unchecked")
+    private final TransitionFactory<List> transitionFactory = mock(TransitionFactory.class);
+    private int overrideWidth = -1;
+    private int overrideHeight = -1;
+    private List<?> result = new ArrayList<>();
+    private final GlideContext glideContext = mock(GlideContext.class);
+    private final Key signature = new ObjectKey(12345);
+    private Priority priority = Priority.HIGH;
+    private boolean useUnlimitedSourceGeneratorsPool = false;
+    private final Class<List> transcodeClass = List.class;
+    private final Map<Class<?>, Transformation<?>> transformations = new HashMap<>();
+
+    SingleRequestBuilder() {
+      when(requestCoordinator.canSetImage(any(Request.class))).thenReturn(true);
+      when(requestCoordinator.canNotifyCleared(any(Request.class))).thenReturn(true);
+      when(requestCoordinator.canNotifyStatusChanged(any(Request.class))).thenReturn(true);
+      when(resource.get()).thenReturn(result);
+    }
+
+    SingleRequestBuilder setEngine(Engine engine) {
+      this.engine = engine;
+      return this;
+    }
+
+    SingleRequestBuilder setModel(Number model) {
+      this.model = model;
+      return this;
+    }
+
+    SingleRequestBuilder setTarget(Target<List> target) {
+      this.target = target;
+      return this;
+    }
+
+    SingleRequestBuilder setResource(Resource<List> resource) {
+      this.resource = resource;
+      return this;
+    }
+
+    SingleRequestBuilder setRequestCoordinator(RequestCoordinator requestCoordinator) {
+      this.requestCoordinator = requestCoordinator;
+      return this;
+    }
+
+    SingleRequestBuilder setPlaceholderDrawable(Drawable placeholderDrawable) {
+      this.placeholderDrawable = placeholderDrawable;
+      return this;
+    }
+
+    SingleRequestBuilder setErrorDrawable(Drawable errorDrawable) {
+      this.errorDrawable = errorDrawable;
+      return this;
+    }
+
+    SingleRequestBuilder setFallbackDrawable(Drawable fallbackDrawable) {
+      this.fallbackDrawable = fallbackDrawable;
+      return this;
+    }
+
+    SingleRequestBuilder setRequestListener(RequestListener<List> requestListener) {
+      this.requestListener = requestListener;
+      return this;
+    }
+
+    SingleRequestBuilder setOverrideWidth(int overrideWidth) {
+      this.overrideWidth = overrideWidth;
+      return this;
+    }
+
+    SingleRequestBuilder setOverrideHeight(int overrideHeight) {
+      this.overrideHeight = overrideHeight;
+      return this;
+    }
+
+    SingleRequestBuilder setResult(List<?> result) {
+      this.result = result;
+      return this;
+    }
+
+    SingleRequestBuilder setPriority(Priority priority) {
+      this.priority = priority;
+      return this;
+    }
+
+    SingleRequestBuilder setUseUnlimitedSourceGeneratorsPool(
+        boolean useUnlimitedSourceGeneratorsPool) {
+      this.useUnlimitedSourceGeneratorsPool = useUnlimitedSourceGeneratorsPool;
+      return this;
+    }
+
+    SingleRequest<List> build() {
+      RequestOptions requestOptions = new RequestOptions()
+          .error(errorDrawable)
+          .placeholder(placeholderDrawable)
+          .fallback(fallbackDrawable)
+          .override(overrideWidth, overrideHeight)
+          .priority(priority)
+          .signature(signature)
+          .useUnlimitedSourceGeneratorsPool(useUnlimitedSourceGeneratorsPool);
+      return SingleRequest.obtain(
+          /*context=*/glideContext,
+          /*glideContext=*/glideContext,
+          model,
+          transcodeClass,
+          requestOptions,
+          overrideWidth,
+          overrideHeight,
+          priority,
+          target,
+          /*targetListener=*/ null,
+          requestListener,
+          requestCoordinator,
+          engine,
+          transitionFactory);
+    }
+  }
+
+  // TODO do we want to move these to Util?
+  @SuppressWarnings("unchecked")
+  private static <T> Transition<T> mockTransition() {
+    return mock(Transition.class);
+  }
+
+  @SuppressWarnings("unchecked")
+  private static Target<List> isAListTarget() {
+    return isA(Target.class);
+  }
+
+  private static GlideException isAGlideException() {
+    return isA(GlideException.class);
+  }
+
+  @SuppressWarnings("unchecked")
+  private static <T> Transition<T> anyTransition() {
+    return any(Transition.class);
+  }
+
+  private static class CallResourceCallback implements Answer {
+
+    private final Resource resource;
+
+    CallResourceCallback(Resource resource) {
+      this.resource = resource;
+    }
+
+    @Override
+    public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      ResourceCallback cb =
+          (ResourceCallback) invocationOnMock.getArguments()[
+              invocationOnMock.getArguments().length
+                  - 1];
+      cb.onResourceReady(resource, DataSource.REMOTE);
+      return null;
+    }
+  }
+
+  private static class CallSizeReady implements Answer {
+
+    private final int width;
+    private final int height;
+
+    CallSizeReady(int width, int height) {
+      this.width = width;
+      this.height = height;
+    }
+
+    @Override
+    public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      SizeReadyCallback cb = (SizeReadyCallback) invocationOnMock.getArguments()[0];
+      cb.onSizeReady(width, height);
+      return null;
+    }
+  }
+
+  private static class MockTarget implements Target<List> {
+
+    private Drawable currentPlaceholder;
+
+    @Override
+    public void onLoadCleared(@Nullable Drawable placeholder) {
+      currentPlaceholder = placeholder;
+    }
+
+    @Override
+    public void onLoadStarted(@Nullable Drawable placeholder) {
+      currentPlaceholder = placeholder;
+
+    }
+
+    @Override
+    public void onLoadFailed(@Nullable Drawable errorDrawable) {
+      currentPlaceholder = errorDrawable;
+
+    }
+
+    @Override
+    public void onResourceReady(@NonNull List resource,
+        @Nullable Transition<? super List> transition) {
+      currentPlaceholder = null;
+    }
+
+
+    @Override
+    public void getSize(@NonNull SizeReadyCallback cb) {
+    }
+
+    @Override
+    public void removeCallback(@NonNull SizeReadyCallback cb) {
+      // Do nothing.
+    }
+
+    @Override
+    public void setRequest(@Nullable Request request) {
+    }
+
+    @Nullable
+    @Override
+    public Request getRequest() {
+      return null;
+    }
+
+    @Override
+    public void onStart() {
+    }
+
+    @Override
+    public void onStop() {
+
+    }
+
+    @Override
+    public void onDestroy() {
+
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java b/library/test/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
similarity index 84%
rename from library/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
index cf2087c8c..4850a2d01 100644
--- a/library/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
@@ -1,12 +1,12 @@
 package com.bumptech.glide.request;
 
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
@@ -16,21 +16,21 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 
 @RunWith(JUnit4.class)
 public class ThumbnailRequestCoordinatorTest {
-  private Request full;
-  private Request thumb;
+  @Mock private Request full;
+  @Mock private Request thumb;
+  @Mock private RequestCoordinator parent;
   private ThumbnailRequestCoordinator coordinator;
-  private RequestCoordinator parent;
 
   @Before
   public void setUp() {
-    full = mock(Request.class);
-    thumb = mock(Request.class);
-    parent = mock(RequestCoordinator.class);
+    MockitoAnnotations.initMocks(this);
     coordinator = new ThumbnailRequestCoordinator();
     coordinator.setRequests(full, thumb);
   }
@@ -85,6 +85,33 @@ public void testDoesNotStartThumbOnRunIfRunning() {
     verify(thumb, never()).begin();
   }
 
+  @Test
+  public void begin_whenFullIsComplete_startsFull() {
+    when(full.isComplete()).thenReturn(true);
+
+    coordinator.begin();
+
+    verify(full).begin();
+  }
+
+  @Test
+  public void begin_whenFullIsComplete_doesNotBeginThumb() {
+    when(full.isComplete()).thenReturn(true);
+
+    coordinator.begin();
+
+    verify(thumb, never()).begin();
+  }
+
+  @Test
+  public void begin_whenFullIsComplete_doesNotSetRunning() {
+    when(full.isComplete()).thenReturn(true);
+
+    coordinator.begin();
+
+    assertThat(coordinator.isRunning()).isFalse();
+  }
+
   @Test
   public void testDoesNotStartFullIfClearedByThumb() {
     doAnswer(new Answer<Void>() {
@@ -317,9 +344,9 @@ public void testDoesNotClearThumbOnThumbRequestComplete() {
 
   @Test
   public void testDoesNotClearThumbOnFullComplete_whenThumbIsComplete() {
-      when(thumb.isComplete()).thenReturn(true);
-      coordinator.onRequestSuccess(full);
-      verify(thumb, never()).clear();
+    when(thumb.isComplete()).thenReturn(true);
+    coordinator.onRequestSuccess(full);
+    verify(thumb, never()).clear();
   }
 
   @Test
@@ -331,6 +358,32 @@ public void testDoesNotNotifyParentOnThumbRequestComplete() {
     verify(parent, never()).onRequestSuccess(any(Request.class));
   }
 
+  @Test
+  public void canNotifyCleared_withThumbRequest_returnsFalse() {
+    assertThat(coordinator.canNotifyCleared(thumb)).isFalse();
+  }
+
+  @Test
+  public void canNotifyCleared_withFullRequest_andNullParent_returnsTrue() {
+    assertThat(coordinator.canNotifyCleared(full)).isTrue();
+  }
+
+  @Test
+  public void canNotifyCleared_withFullRequest_nonNullParent_parentCanClear_returnsTrue() {
+    coordinator = new ThumbnailRequestCoordinator(parent);
+    coordinator.setRequests(full, thumb);
+    when(parent.canNotifyCleared(coordinator)).thenReturn(true);
+    assertThat(coordinator.canNotifyCleared(full)).isTrue();
+  }
+
+  @Test
+  public void canNotifyCleared_withFullRequest_nonNullParent_parentCanNotClear_returnsFalse() {
+    coordinator = new ThumbnailRequestCoordinator(parent);
+    coordinator.setRequests(full, thumb);
+    when(parent.canNotifyCleared(coordinator)).thenReturn(false);
+    assertThat(coordinator.canNotifyCleared(full)).isFalse();
+  }
+
   @Test
   public void testIsEquivalentTo() {
     ThumbnailRequestCoordinator first = new ThumbnailRequestCoordinator();
diff --git a/library/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
similarity index 95%
rename from library/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
index 4ec3ed752..a9a8ffe6e 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
@@ -31,8 +31,7 @@
 
   @Before
   public void setUp() {
-    shadowManager = (UpdateShadowAppWidgetManager) Shadow
-        .extract(AppWidgetManager.getInstance(RuntimeEnvironment.application));
+    shadowManager = Shadow.extract(AppWidgetManager.getInstance(RuntimeEnvironment.application));
     viewId = 1234;
     views = mock(RemoteViews.class);
   }
@@ -126,11 +125,12 @@ public void testThrowsWhenGivenNullComponentName() {
 
   @Implements(AppWidgetManager.class)
   public static class UpdateShadowAppWidgetManager extends ShadowAppWidgetManager {
-    public int[] updatedWidgetIds;
-    public RemoteViews updatedRemoteViews;
-    public ComponentName updatedComponentName;
+    int[] updatedWidgetIds;
+    RemoteViews updatedRemoteViews;
+    ComponentName updatedComponentName;
 
     @Implementation
+    @Override
     public void updateAppWidget(int[] appWidgetIds, RemoteViews views) {
       updatedWidgetIds = appWidgetIds;
       updatedRemoteViews = views;
diff --git a/library/src/test/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java
diff --git a/library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java
diff --git a/library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
similarity index 70%
rename from library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
index eeb0b1fcf..336a0ee29 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
@@ -4,11 +4,14 @@
 import static org.junit.Assert.assertNull;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.inOrder;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import android.graphics.Color;
+import android.graphics.drawable.Animatable;
 import android.graphics.drawable.ColorDrawable;
 import android.graphics.drawable.Drawable;
 import android.widget.ImageView;
@@ -16,6 +19,9 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
@@ -24,12 +30,15 @@
 @Config(manifest = Config.NONE, sdk = 18)
 public class ImageViewTargetTest {
 
+  @Mock private AnimatedDrawable animatedDrawable;
   private ImageView view;
   private TestTarget target;
   private ColorDrawable drawable;
 
   @Before
   public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
     view = new ImageView(RuntimeEnvironment.application);
     target = new TestTarget(view);
     drawable = new ColorDrawable(Color.RED);
@@ -102,16 +111,44 @@ public void testProvidesCurrentPlaceholderToAnimationIfPresent() {
     verify(animation).transition(eq(placeholder), eq(target));
   }
 
-  private static class TestTarget extends ImageViewTarget<Drawable> {
+  @Test
+  public void onResourceReady_withAnimatableResource_startsAnimatableAfterSetResource() {
+    AnimatedDrawable drawable = mock(AnimatedDrawable.class);
+    ImageView view = mock(ImageView.class);
+    target = new TestTarget(view);
+    target.onResourceReady(drawable, /*transition=*/ null);
+
+    InOrder order = inOrder(view, drawable);
+    order.verify(view).setImageDrawable(drawable);
+    order.verify(drawable).start();
+  }
+
+  @Test
+  public void onLoadCleared_withAnimatableDrawable_stopsDrawable() {
+    target.onResourceReady(animatedDrawable, /*transition=*/ null);
+    verify(animatedDrawable).start();
+    verify(animatedDrawable, never()).stop();
+
+    target.onLoadCleared(/*placeholder=*/ null);
+
+    verify(animatedDrawable).stop();
+  }
+
+  private abstract static class AnimatedDrawable extends Drawable implements Animatable {
+    // Intentionally empty.
+  }
+
+  private static final class TestTarget extends ImageViewTarget<Drawable> {
     public Drawable resource;
 
-    public TestTarget(ImageView view) {
+    TestTarget(ImageView view) {
       super(view);
     }
 
     @Override
     protected void setResource(Drawable resource) {
       this.resource = resource;
+      view.setImageDrawable(resource);
     }
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
similarity index 93%
rename from library/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
index eae33c7e4..d1c51da32 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
@@ -35,9 +35,10 @@
 
   @Before
   public void setUp() {
-    NotificationManager notificationManager = (NotificationManager) RuntimeEnvironment.application
-        .getSystemService(Context.NOTIFICATION_SERVICE);
-    shadowManager = (UpdateShadowNotificationManager) Shadow.extract(notificationManager);
+    NotificationManager notificationManager =
+        (NotificationManager)
+            RuntimeEnvironment.application.getSystemService(Context.NOTIFICATION_SERVICE);
+    shadowManager = Shadow.extract(notificationManager);
 
     remoteViews = mock(RemoteViews.class);
     viewId = 123;
@@ -97,6 +98,7 @@ public void testThrowsIfRemoteViewsIsNull() {
     Notification updatedNotification;
 
     @Implementation
+    @Override
     public void notify(String notificationTag, int notificationId, Notification notification) {
       updatedNotificationTag = notificationTag;
       updatedNotificationId = notificationId;
diff --git a/library/src/test/java/com/bumptech/glide/request/target/PreloadTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/PreloadTargetTest.java
similarity index 96%
rename from library/src/test/java/com/bumptech/glide/request/target/PreloadTargetTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/target/PreloadTargetTest.java
index e5e397f41..c3435319f 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/PreloadTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/target/PreloadTargetTest.java
@@ -18,7 +18,7 @@
 @Config(manifest = Config.NONE, sdk = 18)
 public class PreloadTargetTest {
 
-  @Mock RequestManager requestManager;
+  @Mock private RequestManager requestManager;
 
   @Before
   public void setUp() {
diff --git a/library/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java
similarity index 81%
rename from library/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java
index 14e1362f7..3093df1fb 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java
@@ -2,6 +2,8 @@
 
 import static org.mockito.Mockito.mock;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.request.transition.Transition;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -32,7 +34,13 @@ public void testThrowsOnGetSizeIfGivenHeightIsEqualToZero() {
 
   @Test
   public void testCanBeConstructedWithoutDimensions() {
-    getTarget();
+    new SimpleTarget<Object>() {
+      @Override
+      public void onResourceReady(@NonNull Object resource,
+          @Nullable Transition<? super Object> transition) {
+        // Do nothing.
+      }
+    };
   }
 
   @Test
@@ -45,19 +53,11 @@ public void testGetSizeDoesNotThrowWithSizeOriginal() {
     getTarget(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL).getSize(mock(SizeReadyCallback.class));
   }
 
-  private SimpleTarget<Object> getTarget() {
-    return new SimpleTarget<Object>() {
-      @Override
-      public void onResourceReady(Object resource, Transition<? super Object> transition) {
-        // Do nothing.
-      }
-    };
-  }
-
   private SimpleTarget<Object> getTarget(int width, int height) {
     return new SimpleTarget<Object>(width, height) {
       @Override
-      public void onResourceReady(Object resource, Transition<? super Object> transition) {
+      public void onResourceReady(@NonNull Object resource,
+          @Nullable Transition<? super Object> transition) {
         // Do nothing.
       }
     };
diff --git a/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
similarity index 65%
rename from library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
index e8a603d36..69b694138 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
@@ -12,17 +12,24 @@
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
 
 import android.content.Context;
 import android.graphics.drawable.Drawable;
 import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
+import android.view.View.OnAttachStateChangeListener;
 import android.view.ViewTreeObserver;
 import android.view.WindowManager;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.tests.Util;
+import com.bumptech.glide.util.Preconditions;
+import java.util.HashSet;
 import java.util.List;
+import java.util.Set;
 import java.util.concurrent.CopyOnWriteArrayList;
 import org.junit.After;
 import org.junit.Before;
@@ -37,6 +44,7 @@
 import org.robolectric.annotation.Config;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.RealObject;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowDisplay;
 import org.robolectric.shadows.ShadowView;
@@ -52,6 +60,7 @@
   @Mock private SizeReadyCallback cb;
   @Mock private Request request;
   private int sdkVersion;
+  private AttachStateTarget attachStateTarget;
 
   @Before
   public void setUp() {
@@ -59,6 +68,7 @@ public void setUp() {
     MockitoAnnotations.initMocks(this);
     view = new View(RuntimeEnvironment.application);
     target = new TestViewTarget(view);
+    attachStateTarget = new AttachStateTarget(view);
 
     shadowView = Shadow.extract(view);
     shadowObserver = Shadow.extract(view.getViewTreeObserver());
@@ -460,7 +470,8 @@ public void getSize_withWidthAndHeightEqualToPadding_doesNotCallSizeReady() {
   private void setDisplayDimens(Integer width, Integer height) {
     WindowManager windowManager =
         (WindowManager) RuntimeEnvironment.application.getSystemService(Context.WINDOW_SERVICE);
-    ShadowDisplay shadowDisplay = Shadows.shadowOf(windowManager.getDefaultDisplay());
+    ShadowDisplay shadowDisplay =
+        Shadows.shadowOf(Preconditions.checkNotNull(windowManager).getDefaultDisplay());
     if (width != null) {
       shadowDisplay.setWidth(width);
     }
@@ -470,9 +481,169 @@ private void setDisplayDimens(Integer width, Integer height) {
     }
   }
 
+  @Test
+  public void clearOnDetach_onDetach_withNullRequest_doesNothing() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(null);
+    shadowView.callOnAttachedToWindow();
+  }
+
+  @Test
+  public void clearOnDetach_onDetach_withCancelledRequest_doesNotPauseRequest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isCancelled()).thenReturn(true);
+    shadowView.callOnDetachedFromWindow();
+
+    verify(request, never()).pause();
+    verify(request, never()).clear();
+  }
+
+  @Test
+  public void clearOnDetach_onDetach_withPausedRequest_doesNotPauseRequest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isPaused()).thenReturn(true);
+    shadowView.callOnDetachedFromWindow();
+
+    verify(request, never()).pause();
+    verify(request, never()).clear();
+  }
+
+  @Test
+  public void clearOnDetach_onDetach_withRunningRequest_pausesRequestOnce() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    shadowView.callOnDetachedFromWindow();
+
+    verify(request).pause();
+  }
+
+  @Test
+  public void clearOnDetach_onDetach_afterOnLoadCleared_removesListener() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.onLoadCleared(/*placeholder=*/ null);
+    attachStateTarget.setRequest(request);
+    shadowView.callOnDetachedFromWindow();
+
+    verify(request, never()).pause();
+    verify(request, never()).clear();
+  }
+
+  @Test
+  public void clearOnDetach_moreThanOnce_registersObserverOnce() {
+    attachStateTarget
+        .clearOnDetach()
+        .clearOnDetach();
+
+    assertThat(shadowView.attachStateListeners).hasSize(1);
+  }
+
+  @Test
+  public void clearOnDetach_onDetach_afterMultipleClearOnDetaches_removesListener() {
+    attachStateTarget
+        .clearOnDetach()
+        .clearOnDetach()
+        .clearOnDetach();
+    attachStateTarget.onLoadCleared(/*placeholder=*/ null);
+    attachStateTarget.setRequest(request);
+    shadowView.callOnDetachedFromWindow();
+
+    verify(request, never()).pause();
+    verify(request, never()).clear();
+  }
+
+  @Test
+  public void clearOnDetach_onDetach_afterLoadCleared_doesNotPauseRequest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    attachStateTarget.onLoadCleared(/*placeholder=*/ null);
+    shadowView.callOnDetachedFromWindow();
+
+    verify(request, never()).pause();
+  }
+
+  @Test
+  public void clearOnDetach_onAttach_withNullRequest_doesNothing() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(null);
+    shadowView.callOnAttachedToWindow();
+  }
+
+  @Test
+  public void clearOnDetach_onAttach_withRunningRequest_doesNotBeginRequest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isPaused()).thenReturn(false);
+    shadowView.callOnAttachedToWindow();
+
+    verify(request, never()).begin();
+  }
+
+  @Test
+  public void clearOnDetach_onAttach_withPausedRequest_beginsRequest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isPaused()).thenReturn(true);
+    shadowView.callOnAttachedToWindow();
+
+    verify(request).begin();
+  }
+
+  @Test
+  public void clearOnDetach_afterLoadClearedAndRestarted_onAttach_beingsREquest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isPaused()).thenReturn(true);
+    attachStateTarget.onLoadCleared(/*placeholder=*/ null);
+    attachStateTarget.onLoadStarted(/*placeholder=*/ null);
+    shadowView.callOnAttachedToWindow();
+
+    verify(request).begin();
+  }
+
+  @Test
+  public void clearOnDetach_onAttach_afterLoadCleared_doesNotBeingRequest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isPaused()).thenReturn(true);
+    attachStateTarget.onLoadCleared(/*placeholder=*/ null);
+    shadowView.callOnAttachedToWindow();
+
+    verify(request, never()).begin();
+  }
+
+  @Test
+  public void onLoadStarted_withoutClearOnDetach_doesNotAddListener() {
+    attachStateTarget.onLoadStarted(/*placeholder=*/ null);
+
+    assertThat(shadowView.attachStateListeners).isEmpty();
+  }
+
+  // containsExactly does not need its result checked.
+  @SuppressWarnings("ResultOfMethodCallIgnored")
+  @Test
+  public void onLoadCleared_withoutClearOnDetach_doesNotRemoveListeners() {
+    OnAttachStateChangeListener expected = new OnAttachStateChangeListener() {
+      @Override
+      public void onViewAttachedToWindow(View v) {
+      }
+
+      @Override
+      public void onViewDetachedFromWindow(View v) {
+      }
+    };
+    shadowView.addOnAttachStateChangeListener(expected);
+
+    attachStateTarget.onLoadCleared(/*placeholder=*/ null);
+
+    assertThat(shadowView.attachStateListeners).containsExactly(expected);
+  }
+
   @Implements(ViewTreeObserver.class)
-  public static class PreDrawShadowViewTreeObserver {
-    private CopyOnWriteArrayList<OnPreDrawListener> preDrawListeners = new CopyOnWriteArrayList<>();
+  public static final class PreDrawShadowViewTreeObserver {
+    private final CopyOnWriteArrayList<OnPreDrawListener> preDrawListeners =
+        new CopyOnWriteArrayList<>();
     private boolean isAlive = true;
 
     @SuppressWarnings("unused")
@@ -490,6 +661,7 @@ public void removeOnPreDrawListener(OnPreDrawListener listener) {
     }
 
     @Implementation
+    @SuppressWarnings("WeakerAccess")
     public boolean isAlive() {
       return isAlive;
     }
@@ -500,28 +672,32 @@ private void checkIsAlive() {
       }
     }
 
-    public void setIsAlive(boolean isAlive) {
+    void setIsAlive(@SuppressWarnings("SameParameterValue") boolean isAlive) {
       this.isAlive = isAlive;
     }
 
-    public void fireOnPreDrawListeners() {
+    void fireOnPreDrawListeners() {
       for (OnPreDrawListener listener : preDrawListeners) {
         listener.onPreDraw();
       }
     }
 
-    public List<OnPreDrawListener> getPreDrawListeners() {
+    List<OnPreDrawListener> getPreDrawListeners() {
       return preDrawListeners;
     }
   }
 
+  // Shadows require stronger access and unused values.
+  @SuppressWarnings({"UnusedReturnValue", "WeakerAccess", "unused"})
   @Implements(View.class)
-  public static class SizedShadowView extends ShadowView {
+  public static final class SizedShadowView extends ShadowView {
+    @RealObject private View view;
     private int width;
     private int height;
     private LayoutParams layoutParams;
     private boolean isLaidOut;
     private boolean isLayoutRequested;
+    private final Set<OnAttachStateChangeListener> attachStateListeners = new HashSet<>();
 
     public SizedShadowView setWidth(int width) {
       this.width = width;
@@ -533,17 +709,54 @@ public SizedShadowView setHeight(int height) {
       return this;
     }
 
+    @Implementation
+    public void addOnAttachStateChangeListener(OnAttachStateChangeListener listener) {
+      attachStateListeners.add(listener);
+    }
+
+    @Implementation
+    public void removeOnAttachStateChangeListener(OnAttachStateChangeListener listener) {
+      attachStateListeners.remove(listener);
+    }
+
+    @Implementation
+    public void onAttachedToWindow() {
+      for (OnAttachStateChangeListener listener : attachStateListeners) {
+        listener.onViewAttachedToWindow(view);
+      }
+    }
+
+    @Implementation
+    public void onDetachedFromWindow() {
+      for (OnAttachStateChangeListener listener : attachStateListeners) {
+        listener.onViewDetachedFromWindow(view);
+      }
+    }
+
+    @Override
+    public void callOnAttachedToWindow() {
+      super.callOnAttachedToWindow();
+    }
+
+    @Override
+    public void callOnDetachedFromWindow() {
+      super.callOnDetachedFromWindow();
+    }
+
+    @Implementation
     public SizedShadowView setLayoutParams(LayoutParams layoutParams) {
       this.layoutParams = layoutParams;
       return this;
     }
 
+    @Implementation
     public SizedShadowView setIsLaidOut(boolean isLaidOut) {
       this.isLaidOut = isLaidOut;
       return this;
     }
 
     @Implementation
+    @Override
     public void requestLayout() {
       isLayoutRequested = true;
     }
@@ -574,30 +787,49 @@ public LayoutParams getLayoutParams() {
     }
   }
 
-  private static class TestViewTarget extends ViewTarget<View, Object> {
-
-    public TestViewTarget(View view) {
+  private static final class AttachStateTarget extends ViewTarget<View, Object> {
+    AttachStateTarget(View view) {
       super(view);
     }
 
     @Override
-    public void onLoadStarted(Drawable placeholder) {
+    public void onResourceReady(@NonNull Object resource,
+        @Nullable Transition<? super Object> transition) { }
+  }
+
+  private static final class TestViewTarget extends ViewTarget<View, Object> {
 
+    TestViewTarget(View view) {
+      super(view);
     }
 
+    // We're intentionally avoiding the super call.
+    @SuppressWarnings("MissingSuperCall")
     @Override
-    public void onLoadFailed(Drawable errorDrawable) {
-
+    public void onResourceReady(@NonNull Object resource,
+        @Nullable Transition<? super Object> transition) {
+      // Avoid calling super.
     }
 
+    // We're intentionally avoiding the super call.
+    @SuppressWarnings("MissingSuperCall")
     @Override
-    public void onResourceReady(Object resource, Transition<? super Object> transition) {
-
+    public void onLoadCleared(@Nullable Drawable placeholder) {
+      // Avoid calling super.
     }
 
+    // We're intentionally avoiding the super call.
+    @SuppressWarnings("MissingSuperCall")
     @Override
-    public void onLoadCleared(Drawable placeholder) {
+    public void onLoadStarted(@Nullable Drawable placeholder) {
+      // Avoid calling super.
+    }
 
+    // We're intentionally avoiding the super call.
+    @SuppressWarnings("MissingSuperCall")
+    @Override
+    public void onLoadFailed(@Nullable Drawable errorDrawable) {
+      // Avoid calling super.
     }
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java b/library/test/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java b/library/test/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
similarity index 92%
rename from library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
index 022277447..e89b6f8bc 100644
--- a/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
@@ -63,10 +63,10 @@ public void transition_withCurrentDrawable_returnsTrue() {
 
   @SuppressWarnings("unchecked")
   private static class CrossFadeHarness {
-    Drawable current = new ColorDrawable(Color.GRAY);
-    ViewAdapter adapter = mock(ViewAdapter.class);
-    int duration = 200;
-    DrawableCrossFadeTransition animation =
+    final Drawable current = new ColorDrawable(Color.GRAY);
+    final ViewAdapter adapter = mock(ViewAdapter.class);
+    final int duration = 200;
+    final DrawableCrossFadeTransition animation =
         new DrawableCrossFadeTransition(duration, true /*isCrossFadeEnabled*/);
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/ViewAnimationTest.java b/library/test/src/test/java/com/bumptech/glide/request/transition/ViewAnimationTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/request/transition/ViewAnimationTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/transition/ViewAnimationTest.java
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyAnimationTest.java b/library/test/src/test/java/com/bumptech/glide/request/transition/ViewPropertyAnimationTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyAnimationTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/transition/ViewPropertyAnimationTest.java
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyViewTransitionAnimationFactoryTest.java b/library/test/src/test/java/com/bumptech/glide/request/transition/ViewPropertyViewTransitionAnimationFactoryTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyViewTransitionAnimationFactoryTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/transition/ViewPropertyViewTransitionAnimationFactoryTest.java
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/ViewTransitionAnimationFactoryTest.java b/library/test/src/test/java/com/bumptech/glide/request/transition/ViewTransitionAnimationFactoryTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/request/transition/ViewTransitionAnimationFactoryTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/transition/ViewTransitionAnimationFactoryTest.java
diff --git a/library/src/test/java/com/bumptech/glide/resize/load/ExifTest.java b/library/test/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
similarity index 95%
rename from library/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
rename to library/test/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
index 95eaca505..1efd9b736 100644
--- a/library/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
@@ -21,7 +21,7 @@
 
   private ArrayPool byteArrayPool;
 
-  private InputStream open(String imageName) throws IOException {
+  private InputStream open(String imageName) {
     return TestResourceUtil.openResource(getClass(), "exif-orientation-examples/" + imageName);
   }
 
@@ -72,11 +72,11 @@ public void testPortrait() throws IOException {
   @Test
   public void testHandlesInexactSizesInByteArrayPools() {
     for (int i = 1; i <= 8; i++) {
-      byteArrayPool.put(new byte[ArrayPool.STANDARD_BUFFER_SIZE_BYTES], byte[].class);
+      byteArrayPool.put(new byte[ArrayPool.STANDARD_BUFFER_SIZE_BYTES]);
       assertOrientation("Portrait", i);
     }
     for (int i = 1; i <= 8; i++) {
-      byteArrayPool.put(new byte[ArrayPool.STANDARD_BUFFER_SIZE_BYTES], byte[].class);
+      byteArrayPool.put(new byte[ArrayPool.STANDARD_BUFFER_SIZE_BYTES]);
       assertOrientation("Landscape", i);
     }
   }
diff --git a/library/test/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java b/library/test/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java
new file mode 100644
index 000000000..0d2c90bb8
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java
@@ -0,0 +1,83 @@
+package com.bumptech.glide.signature;
+
+import static org.junit.Assert.assertNotNull;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import android.content.Context;
+import android.content.pm.PackageManager.NameNotFoundException;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.tests.KeyTester;
+import java.io.UnsupportedEncodingException;
+import java.security.NoSuchAlgorithmException;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Answers;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class ApplicationVersionSignatureTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
+  private Context context;
+
+  @Before
+  public void setUp() {
+    context = RuntimeEnvironment.application;
+  }
+
+  @After
+  public void tearDown() {
+    ApplicationVersionSignature.reset();
+  }
+
+  @Test
+  public void testCanGetKeyForSignature() {
+    Key key = ApplicationVersionSignature.obtain(context);
+    assertNotNull(key);
+  }
+
+  @Test
+  public void testKeyForSignatureIsTheSameAcrossCallsInTheSamePackage()
+      throws NoSuchAlgorithmException, UnsupportedEncodingException {
+    keyTester
+        .addEquivalenceGroup(
+            ApplicationVersionSignature.obtain(context),
+            ApplicationVersionSignature.obtain(context))
+        .addEquivalenceGroup(new ObjectKey("test"))
+        .addRegressionTest(
+            ApplicationVersionSignature.obtain(context),
+            "5feceb66ffc86f38d952786c6d696c79c2dbc239dd4e91b46729d73a27fb57e9")
+        .test();
+  }
+
+  @Test
+  public void testUnresolvablePackageInfo() throws NameNotFoundException {
+    Context context = mock(Context.class, Answers.RETURNS_DEEP_STUBS.get());
+    String packageName = "my.package";
+    when(context.getPackageName()).thenReturn(packageName);
+    when(context.getPackageManager().getPackageInfo(packageName, 0))
+        .thenThrow(new NameNotFoundException("test"));
+
+    Key key = ApplicationVersionSignature.obtain(context);
+
+    assertNotNull(key);
+  }
+
+  @Test
+  public void testMissingPackageInfo() throws NameNotFoundException {
+    Context context = mock(Context.class, Answers.RETURNS_DEEP_STUBS.get());
+    String packageName = "my.package";
+    when(context.getPackageName()).thenReturn(packageName);
+    when(context.getPackageManager().getPackageInfo(packageName, 0)).thenReturn(null);
+
+    Key key = ApplicationVersionSignature.obtain(context);
+
+    assertNotNull(key);
+  }
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/signature/EmptySignatureTest.java b/library/test/src/test/java/com/bumptech/glide/signature/EmptySignatureTest.java
new file mode 100644
index 000000000..a10b26cd7
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/signature/EmptySignatureTest.java
@@ -0,0 +1,27 @@
+package com.bumptech.glide.signature;
+
+
+import static org.mockito.Mockito.mock;
+
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.tests.KeyTester;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class EmptySignatureTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
+
+  @Test
+  public void testEquals() {
+    keyTester
+        .addEquivalenceGroup(
+            EmptySignature.obtain(),
+            EmptySignature.obtain())
+        .addEquivalenceGroup(mock(Key.class))
+        .addEmptyDigestRegressionTest(EmptySignature.obtain())
+        .test();
+  }
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java b/library/test/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java
new file mode 100644
index 000000000..e972c3e2e
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java
@@ -0,0 +1,27 @@
+package com.bumptech.glide.signature;
+
+import com.bumptech.glide.tests.KeyTester;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class MediaStoreSignatureTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
+
+  @Test
+  public void equalsHashCodeAndDigest() {
+    keyTester
+        .addEquivalenceGroup(
+            new MediaStoreSignature("first", 100, 1),
+            new MediaStoreSignature("first", 100, 1))
+        .addEquivalenceGroup(new MediaStoreSignature("second", 100, 1))
+        .addEquivalenceGroup(new MediaStoreSignature("first", 200, 1))
+        .addEquivalenceGroup(new MediaStoreSignature("first", 100, 2))
+        .addRegressionTest(
+            new MediaStoreSignature("first", 100, 1),
+            "04959925006b21081000fd10835cc376343c0e922df0bd7346897ede6f958adf")
+        .test();
+  }
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/signature/ObjectKeyTest.java b/library/test/src/test/java/com/bumptech/glide/signature/ObjectKeyTest.java
new file mode 100644
index 000000000..f5656d4a0
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/signature/ObjectKeyTest.java
@@ -0,0 +1,26 @@
+package com.bumptech.glide.signature;
+
+import com.bumptech.glide.tests.KeyTester;
+import java.security.NoSuchAlgorithmException;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class ObjectKeyTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
+
+  @Test
+  public void testEqualsHashCodeAndDigest() throws NoSuchAlgorithmException {
+    Object object = new Object();
+    keyTester
+        .addEquivalenceGroup(new ObjectKey(object), new ObjectKey(object))
+        .addEquivalenceGroup(new ObjectKey(new Object()))
+        .addEquivalenceGroup(new ObjectKey("test"), new ObjectKey("test"))
+        .addRegressionTest(
+            new ObjectKey("test"),
+            "9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08")
+        .test();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/tests/BackgroundUtil.java b/library/test/src/test/java/com/bumptech/glide/tests/BackgroundUtil.java
similarity index 69%
rename from library/src/test/java/com/bumptech/glide/tests/BackgroundUtil.java
rename to library/test/src/test/java/com/bumptech/glide/tests/BackgroundUtil.java
index 796a09240..3800e8b77 100644
--- a/library/src/test/java/com/bumptech/glide/tests/BackgroundUtil.java
+++ b/library/test/src/test/java/com/bumptech/glide/tests/BackgroundUtil.java
@@ -1,8 +1,9 @@
 package com.bumptech.glide.tests;
 
-public class BackgroundUtil {
-  public interface BackgroundTester {
-    public void runTest() throws Exception;
+public final class BackgroundUtil {
+
+  private BackgroundUtil() {
+    // Utility class.
   }
 
   public static void testInBackground(BackgroundTester test) throws InterruptedException {
@@ -14,11 +15,11 @@ public static void testInBackground(BackgroundTester test) throws InterruptedExc
     }
   }
 
-  private static class TestThread extends Thread {
+  private static final class TestThread extends Thread {
+    private final BackgroundTester test;
     private Exception exception;
-    private BackgroundTester test;
 
-    public TestThread(BackgroundTester test) {
+    private TestThread(BackgroundTester test) {
       this.test = test;
     }
 
@@ -32,4 +33,8 @@ public void run() {
       }
     }
   }
+
+  public interface BackgroundTester {
+    void runTest();
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/tests/ContentResolverShadow.java b/library/test/src/test/java/com/bumptech/glide/tests/ContentResolverShadow.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/tests/ContentResolverShadow.java
rename to library/test/src/test/java/com/bumptech/glide/tests/ContentResolverShadow.java
diff --git a/library/src/test/java/com/bumptech/glide/tests/GlideShadowLog.java b/library/test/src/test/java/com/bumptech/glide/tests/GlideShadowLog.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/tests/GlideShadowLog.java
rename to library/test/src/test/java/com/bumptech/glide/tests/GlideShadowLog.java
diff --git a/library/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java b/library/test/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java
similarity index 66%
rename from library/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java
rename to library/test/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java
index 7b94a888c..fede54a45 100644
--- a/library/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java
+++ b/library/test/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java
@@ -6,13 +6,21 @@
 import android.os.MessageQueue;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
 import org.robolectric.shadows.ShadowLooper;
 
 @Implements(Looper.class)
 public class GlideShadowLooper extends ShadowLooper {
+  public static MessageQueue queue = mock(MessageQueue.class);
 
   @Implementation
   public static MessageQueue myQueue() {
-    return mock(MessageQueue.class);
+    return queue;
+  }
+
+  @Resetter
+  @Override
+  public void reset() {
+    queue = mock(MessageQueue.class);
   }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/tests/KeyTester.java b/library/test/src/test/java/com/bumptech/glide/tests/KeyTester.java
new file mode 100644
index 000000000..8a064db54
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/tests/KeyTester.java
@@ -0,0 +1,153 @@
+package com.bumptech.glide.tests;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assert_;
+import static org.junit.Assert.fail;
+
+import android.support.annotation.CheckResult;
+import android.support.annotation.NonNull;
+import com.bumptech.glide.load.Key;
+import com.google.common.base.Equivalence;
+import com.google.common.testing.EquivalenceTester;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.Arrays;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Map.Entry;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+public final class KeyTester implements TestRule {
+  private static final String EMPTY_DIGEST_STRING =
+      "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
+  // Use LinkedHashMap to keep iteration based on insertion order.
+  private final Map<Key, String> regressionTests = new LinkedHashMap<>();
+  private final Sha256 sha256 = new Sha256();
+  private final EquivalenceTester<Key> tester = EquivalenceTester.of(new KeyEquivalence(sha256));
+  private boolean isUsedWithoutCallingTest;
+  private boolean isUsedAsRule;
+
+  @Override
+  public Statement apply(final Statement base, Description description) {
+    return new Statement() {
+
+      @Override
+      public void evaluate() throws Throwable {
+          isUsedAsRule = true;
+          base.evaluate();
+          if (isUsedWithoutCallingTest) {
+            fail("You used KeyTester but failed to call test()!");
+          }
+      }
+    };
+  }
+
+  private void assertUsedAsRule() {
+    if (!isUsedAsRule) {
+      fail("You must use KeyTester as an @Rule");
+    }
+  }
+
+  @CheckResult
+  public KeyTester addEquivalenceGroup(Key first, Key... rest) {
+    assertUsedAsRule();
+    isUsedWithoutCallingTest = true;
+    tester.addEquivalenceGroup(first, rest);
+    return this;
+  }
+
+  @CheckResult
+  public KeyTester addRegressionTest(Key key, String expectedDigest) {
+    assertUsedAsRule();
+    if (EMPTY_DIGEST_STRING.equals(expectedDigest)) {
+      throw new IllegalArgumentException("Expected digest is empty, if this is intended use "
+          + "addEmptyDigestRegressionTest instead");
+    }
+    return addRegressionTestInternal(key, expectedDigest);
+  }
+
+  @CheckResult
+  public KeyTester addEmptyDigestRegressionTest(Key key) {
+    assertUsedAsRule();
+    return addRegressionTestInternal(key, EMPTY_DIGEST_STRING);
+  }
+
+  private KeyTester addRegressionTestInternal(Key key, String expectedDigest) {
+    isUsedWithoutCallingTest = true;
+    String oldValue = regressionTests.put(key, expectedDigest);
+    if (oldValue != null) {
+      throw new IllegalArgumentException(
+          "Given multiple values for: " + key + " old: " + oldValue + " new: " + expectedDigest);
+    }
+    return this;
+  }
+
+  public void test() {
+    assertUsedAsRule();
+    isUsedWithoutCallingTest = false;
+    tester.test();
+
+    assertThat(regressionTests).isNotEmpty();
+    int i = 1;
+    for (Entry<Key, String> entry : regressionTests.entrySet()) {
+      assert_()
+          .withMessage(
+              "Unexpected digest for regression test [" + i + "]: with key: " + entry.getKey())
+          .that(sha256.getStringDigest(entry.getKey())).isEqualTo(entry.getValue());
+      i++;
+    }
+  }
+
+  private static final class Sha256 {
+
+    private final MessageDigest digest;
+
+    Sha256() {
+      try {
+        digest = MessageDigest.getInstance("SHA-256");
+      } catch (NoSuchAlgorithmException e) {
+        throw new RuntimeException(e);
+      }
+    }
+
+    private byte[] getDigest(Key key) {
+      try {
+        key.updateDiskCacheKey(digest);
+        return digest.digest();
+      } finally {
+        digest.reset();
+      }
+    }
+
+
+    String getStringDigest(Key key) {
+      return com.bumptech.glide.util.Util.sha256BytesToHex(getDigest(key));
+    }
+  }
+
+  /**
+   * Tests equals, hashcode and digest methods of {@link Key}s.
+   */
+  private static final class KeyEquivalence extends Equivalence<Key> {
+
+    private final Sha256 sha256;
+
+    KeyEquivalence(Sha256 sha256) {
+      this.sha256 = sha256;
+    }
+
+    @Override
+    protected boolean doEquivalent(@NonNull Key a, @NonNull Key b) {
+      byte[] aDigest = sha256.getDigest(a);
+      byte[] bDigest = sha256.getDigest(b);
+      return a.equals(b) && Arrays.equals(aDigest, bDigest);
+    }
+
+    @Override
+    protected int doHash(@NonNull Key key) {
+      return key.hashCode();
+    }
+  }
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/tests/TearDownGlide.java b/library/test/src/test/java/com/bumptech/glide/tests/TearDownGlide.java
new file mode 100644
index 000000000..d1814f48f
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/tests/TearDownGlide.java
@@ -0,0 +1,26 @@
+package com.bumptech.glide.tests;
+
+import com.bumptech.glide.Glide;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+/**
+ * Clears out Glide's disk cache and the Glide singleton after every test method.
+ */
+public final class TearDownGlide implements TestRule {
+  @Override
+  public Statement apply(final Statement base, Description description) {
+    return new Statement() {
+      @Override
+      public void evaluate() throws Throwable {
+        try {
+          base.evaluate();
+        } finally {
+          Glide.tearDown();
+
+        }
+      }
+    };
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/tests/Util.java b/library/test/src/test/java/com/bumptech/glide/tests/Util.java
similarity index 89%
rename from library/src/test/java/com/bumptech/glide/tests/Util.java
rename to library/test/src/test/java/com/bumptech/glide/tests/Util.java
index e80796ba2..bcd5d34f4 100644
--- a/library/src/test/java/com/bumptech/glide/tests/Util.java
+++ b/library/test/src/test/java/com/bumptech/glide/tests/Util.java
@@ -27,10 +27,6 @@
 // FIXME move to testutil module
 public class Util {
 
-  public static String getExpectedClassId(Class<?> clazz) {
-    return clazz.getSimpleName() + "." + clazz.getPackage().getName();
-  }
-
   /**
    * Gives the proper generic type to the {@link ArgumentCaptor}.
    * Only useful when the captor's {@code T} is also a generic type.
@@ -46,7 +42,7 @@ public static DataSource isADataSource() {
   }
 
   public static Context anyContext() {
-    return any(Context.class);
+    return any();
   }
 
   /**
@@ -106,8 +102,8 @@ public static void setSdkVersionInt(int version) {
     ReflectionHelpers.setStaticField(Build.VERSION.class, "SDK_INT", version);
   }
 
-  public static class WriteDigest implements Answer<Void> {
-    private String toWrite;
+  public static final class WriteDigest implements Answer<Void> {
+    private final String toWrite;
 
     public WriteDigest(String toWrite) {
       this.toWrite = toWrite;
@@ -116,13 +112,14 @@ public WriteDigest(String toWrite) {
     @Override
     public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
       MessageDigest md = (MessageDigest) invocationOnMock.getArguments()[0];
-      md.update(toWrite.getBytes());
+      md.update(toWrite.getBytes("UTF-8"));
       return null;
     }
   }
 
-  public static class ReturnsSelfAnswer implements Answer<Object> {
+  public static final class ReturnsSelfAnswer implements Answer<Object> {
 
+    @Override
     public Object answer(InvocationOnMock invocation) throws Throwable {
       Object mock = invocation.getMock();
       if (invocation.getMethod().getReturnType().isInstance(mock)) {
@@ -133,9 +130,9 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
     }
   }
 
-  public static class CallDataReady<T> implements Answer<Void> {
+  public static final class CallDataReady<T> implements Answer<Void> {
 
-    private T data;
+    private final T data;
 
     public CallDataReady(T data) {
       this.data = data;
@@ -151,7 +148,7 @@ public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
     }
   }
 
-  public static class CreateBitmap implements Answer<Bitmap> {
+  public static final class CreateBitmap implements Answer<Bitmap> {
 
     @Override
     public Bitmap answer(InvocationOnMock invocation) throws Throwable {
diff --git a/library/src/test/java/com/bumptech/glide/util/ByteBufferUtilTest.java b/library/test/src/test/java/com/bumptech/glide/util/ByteBufferUtilTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/util/ByteBufferUtilTest.java
rename to library/test/src/test/java/com/bumptech/glide/util/ByteBufferUtilTest.java
diff --git a/library/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java b/library/test/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java
similarity index 95%
rename from library/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java
rename to library/test/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java
index 848321fe1..a9a912613 100644
--- a/library/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java
@@ -20,7 +20,7 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class ContentLengthInputStreamTest {
-  @Mock InputStream wrapped;
+  @Mock private InputStream wrapped;
 
   @Before
   public void setUp() {
@@ -95,6 +95,7 @@ public void testRead_whenReturnsLessThanZeroWithoutReadingAllContent_throwsIOExc
     when(wrapped.read()).thenReturn(-1);
 
     try {
+      //noinspection ResultOfMethodCallIgnored
       is.read();
       fail("Failed to throw expected exception");
     } catch (IOException e) {
@@ -110,6 +111,7 @@ public void testReadBytes_whenReturnsLessThanZeroWithoutReadingAllContent_throws
     when(wrapped.read(any(byte[].class), anyInt(), anyInt())).thenReturn(-1);
 
     try {
+      //noinspection ResultOfMethodCallIgnored
       is.read(new byte[10], 0, 0);
       fail("Failed to throw expected exception");
     } catch (IOException e) {
@@ -121,6 +123,7 @@ public void testReadBytes_whenReturnsLessThanZeroWithoutReadingAllContent_throws
   public void testRead_whenReturnsLessThanZeroWithInvalidLength_doesNotThrow() throws IOException {
     InputStream is = ContentLengthInputStream.obtain(wrapped, "invalid_length");
     when(wrapped.read()).thenReturn(-1);
+    //noinspection ResultOfMethodCallIgnored
     is.read();
   }
 
@@ -129,6 +132,7 @@ public void testReadBytes_whenReturnsLessThanZeroWithInvalidLength_doesNotThrow(
       throws IOException {
     InputStream is = ContentLengthInputStream.obtain(wrapped, "invalid_length");
     when(wrapped.read(any(byte[].class), anyInt(), anyInt())).thenReturn(-1);
+    //noinspection ResultOfMethodCallIgnored
     is.read(new byte[10], 0, 0);
   }
 
diff --git a/library/src/test/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java b/library/test/src/test/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java
rename to library/test/src/test/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java
diff --git a/library/src/test/java/com/bumptech/glide/util/FixedPreloadSizeProviderTest.java b/library/test/src/test/java/com/bumptech/glide/util/FixedPreloadSizeProviderTest.java
similarity index 86%
rename from library/src/test/java/com/bumptech/glide/util/FixedPreloadSizeProviderTest.java
rename to library/test/src/test/java/com/bumptech/glide/util/FixedPreloadSizeProviderTest.java
index 89cab6985..8418cc85d 100644
--- a/library/src/test/java/com/bumptech/glide/util/FixedPreloadSizeProviderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/util/FixedPreloadSizeProviderTest.java
@@ -11,6 +11,8 @@
 @Config(manifest = Config.NONE, sdk = 18)
 public class FixedPreloadSizeProviderTest {
 
+  // containsExactly doesn't need a return value check.
+  @SuppressWarnings("ResultOfMethodCallIgnored")
   @Test
   public void testReturnsGivenSize() {
     int width = 500;
diff --git a/library/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java b/library/test/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java
similarity index 99%
rename from library/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java
rename to library/test/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java
index 1e18b4203..5684e3c13 100644
--- a/library/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java
@@ -135,7 +135,7 @@ public void testReturnsEndOfStream_whenSkipping_withZeroBytesRemainingInMarkLimi
     is.mark(MARK_LIMIT);
 
     assertEquals(MARK_LIMIT, is.skip(DATA_SIZE));
-    assertEquals(-1, is.skip(1));
+    assertEquals(0, is.skip(1));
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/util/UtilTest.java b/library/test/src/test/java/com/bumptech/glide/util/UtilTest.java
similarity index 85%
rename from library/src/test/java/com/bumptech/glide/util/UtilTest.java
rename to library/test/src/test/java/com/bumptech/glide/util/UtilTest.java
index 92d16e95b..416095784 100644
--- a/library/src/test/java/com/bumptech/glide/util/UtilTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/util/UtilTest.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.util;
 
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 
 import android.graphics.Bitmap;
@@ -9,7 +10,7 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(manifest = Config.NONE, sdk = 27)
 public class UtilTest {
 
   @Test
@@ -70,4 +71,12 @@ public void testReturnsLargestSizeForNullConfig() {
     int size = Util.getBitmapByteSize(width, height, null);
     assertEquals(width * height * 4, size);
   }
+
+  @Test
+  public void getBitmapByteSize_withRGBA_F16_returnsCorrectSize() {
+    int width = 100;
+    int height = 200;
+    assertThat(Util.getBitmapByteSize(width, height, Bitmap.Config.RGBA_F16))
+        .isEqualTo(width * height * 8);
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java b/library/test/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java
similarity index 96%
rename from library/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java
rename to library/test/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java
index 014cdaa19..5cc8f12ff 100644
--- a/library/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java
@@ -12,6 +12,8 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
+// containsExactly does not need its return value checked.
+@SuppressWarnings("ResultOfMethodCallIgnored")
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class ViewPreloadSizeProviderTest {
diff --git a/library/src/test/java/javax/microedition/khronos/opengles/GL.java b/library/test/src/test/java/opengles/GL.java
similarity index 100%
rename from library/src/test/java/javax/microedition/khronos/opengles/GL.java
rename to library/test/src/test/java/opengles/GL.java
diff --git a/library/test/src/test/resources/exif-orientation-examples b/library/test/src/test/resources/exif-orientation-examples
new file mode 160000
index 000000000..9c4ccfaea
--- /dev/null
+++ b/library/test/src/test/resources/exif-orientation-examples
@@ -0,0 +1 @@
+Subproject commit 9c4ccfaea6bfd434ac1c4bb0750ac6fc5848a5f4
diff --git a/library/src/test/resources/issue387_rotated_jpeg.jpg b/library/test/src/test/resources/issue387_rotated_jpeg.jpg
similarity index 100%
rename from library/src/test/resources/issue387_rotated_jpeg.jpg
rename to library/test/src/test/resources/issue387_rotated_jpeg.jpg
diff --git a/library/src/test/resources/org.robolectric.Config.properties b/library/test/src/test/resources/org.robolectric.Config.properties
similarity index 100%
rename from library/src/test/resources/org.robolectric.Config.properties
rename to library/test/src/test/resources/org.robolectric.Config.properties
diff --git a/library/src/test/resources/short_exif_sample.jpg b/library/test/src/test/resources/short_exif_sample.jpg
similarity index 100%
rename from library/src/test/resources/short_exif_sample.jpg
rename to library/test/src/test/resources/short_exif_sample.jpg
diff --git a/library/src/test/resources/test.gif b/library/test/src/test/resources/test.gif
similarity index 100%
rename from library/src/test/resources/test.gif
rename to library/test/src/test/resources/test.gif
diff --git a/samples/contacturi/build.gradle b/samples/contacturi/build.gradle
index e8753dd15..d1f2480ea 100644
--- a/samples/contacturi/build.gradle
+++ b/samples/contacturi/build.gradle
@@ -1,14 +1,13 @@
 apply plugin: 'com.android.application'
 
 dependencies {
-    compile project(':library')
-    compile "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}"
+    implementation project(':library')
+    implementation "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}"
     annotationProcessor project(':annotation:compiler')
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         applicationId 'com.bumptech.glide.samples.contacturi'
diff --git a/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java
index c928f9fd5..c072483df 100644
--- a/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java
+++ b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java
@@ -1,10 +1,6 @@
 package com.bumptech.glide.samples.contacturi;
 
-import static android.os.Build.VERSION;
-import static android.os.Build.VERSION_CODES;
-
 import android.Manifest;
-import android.annotation.TargetApi;
 import android.app.Activity;
 import android.content.ContentUris;
 import android.content.Intent;
@@ -21,6 +17,7 @@
 import android.widget.ImageView;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.util.Preconditions;
 
 /**
  * An activity that demonstrates loading photos using
@@ -44,11 +41,11 @@ protected void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
     setContentView(R.layout.activity_main);
 
-    imageViewContact = (ImageView) findViewById(R.id.image_contact);
-    imageViewLookup = (ImageView) findViewById(R.id.image_lookup);
-    imageViewPhoto = (ImageView) findViewById(R.id.image_photo);
-    imageViewDisplayPhoto = (ImageView) findViewById(R.id.image_display_photo);
-    numberEntry = (EditText) findViewById(R.id.number_entry);
+    imageViewContact = findViewById(R.id.image_contact);
+    imageViewLookup = findViewById(R.id.image_lookup);
+    imageViewPhoto = findViewById(R.id.image_photo);
+    imageViewDisplayPhoto = findViewById(R.id.image_display_photo);
+    numberEntry = findViewById(R.id.number_entry);
     // Make sure that user gives application required permissions
     if (ContextCompat.checkSelfPermission(
         getApplication(),
@@ -83,7 +80,8 @@ public void onClick(View v) {
   @Override
   protected void onActivityResult(int requestCode, int resultCode, Intent data) {
     if (requestCode == REQUEST_CONTACT && resultCode == RESULT_OK) {
-      final Cursor cursor = getContentResolver().query(data.getData(), null, null, null, null);
+      Uri uri = Preconditions.checkNotNull(data.getData());
+      final Cursor cursor = getContentResolver().query(uri, null, null, null, null);
       try {
         if (cursor != null && cursor.moveToFirst()) {
           final long contactId = cursor.getLong(cursor.getColumnIndex(Contacts._ID));
@@ -99,7 +97,6 @@ protected void onActivityResult(int requestCode, int resultCode, Intent data) {
     super.onActivityResult(requestCode, resultCode, data);
   }
 
-  @TargetApi(VERSION_CODES.ICE_CREAM_SANDWICH)
   private void showContact(long id) {
     GlideRequests glideRequests = GlideApp.with(this);
     RequestOptions originalSize = new RequestOptions().override(Target.SIZE_ORIGINAL);
@@ -113,9 +110,7 @@ private void showContact(long id) {
     Uri photoUri = Uri.withAppendedPath(contactUri, Contacts.Photo.CONTENT_DIRECTORY);
     glideRequests.load(photoUri).apply(originalSize).into(imageViewPhoto);
 
-    if (VERSION.SDK_INT >= VERSION_CODES.ICE_CREAM_SANDWICH) {
-      Uri displayPhotoUri = Uri.withAppendedPath(contactUri, Contacts.Photo.DISPLAY_PHOTO);
-      glideRequests.load(displayPhotoUri).apply(originalSize).into(imageViewDisplayPhoto);
-    }
+    Uri displayPhotoUri = Uri.withAppendedPath(contactUri, Contacts.Photo.DISPLAY_PHOTO);
+    glideRequests.load(displayPhotoUri).apply(originalSize).into(imageViewDisplayPhoto);
   }
 }
diff --git a/samples/flickr/build.gradle b/samples/flickr/build.gradle
index 73b2b4e01..37ec1e3b8 100644
--- a/samples/flickr/build.gradle
+++ b/samples/flickr/build.gradle
@@ -1,20 +1,19 @@
 apply plugin: 'com.android.application'
 
 dependencies {
-    compile project(':library')
-    compile(project(':integration:recyclerview')) {
+    implementation project(':library')
+    implementation(project(':integration:recyclerview')) {
         transitive = false
     }
     annotationProcessor project(':annotation:compiler')
 
-    compile "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}"
-    compile "com.android.volley:volley:${VOLLEY_VERSION}"
-    compile "com.android.support:recyclerview-v7:${ANDROID_SUPPORT_VERSION}"
+    implementation "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}"
+    implementation "com.android.volley:volley:${VOLLEY_VERSION}"
+    implementation "com.android.support:recyclerview-v7:${ANDROID_SUPPORT_VERSION}"
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         applicationId 'com.bumptech.glide.samples.flickr'
diff --git a/samples/flickr/src/main/AndroidManifest.xml b/samples/flickr/src/main/AndroidManifest.xml
index 9be7824f6..191c38149 100644
--- a/samples/flickr/src/main/AndroidManifest.xml
+++ b/samples/flickr/src/main/AndroidManifest.xml
@@ -3,8 +3,11 @@
           package="com.bumptech.glide.samples.flickr">
 
     <uses-permission android:name="android.permission.INTERNET"/>
+    <!--
+    Allows Glide to monitor connectivity status and restart failed requests if users go from a
+    a disconnected to a connected network state.
+    -->
     <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
-    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
 
     <application
         android:label="@string/app_name"
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideExtension.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideExtension.java
new file mode 100644
index 000000000..1a5346d09
--- /dev/null
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideExtension.java
@@ -0,0 +1,32 @@
+package com.bumptech.glide.samples.flickr;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.RequestOptions;
+import com.bumptech.glide.samples.flickr.api.Api;
+
+/**
+ * Extension methods for the Flickr sample's generated API.
+ */
+// Required by Glide's annotation processor.
+@SuppressWarnings({"WeakerAccess", "unused"})
+@GlideExtension
+public final class FlickrGlideExtension {
+
+  private FlickrGlideExtension() {
+    // Utility class.
+  }
+
+  @NonNull
+  @GlideOption
+  public static RequestOptions squareThumb(RequestOptions requestOptions) {
+    return requestOptions.centerCrop();
+  }
+
+  @NonNull
+  @GlideOption
+  public static RequestOptions squareMiniThumb(RequestOptions requestOptions) {
+    return requestOptions.centerCrop().override(Api.SQUARE_THUMB_SIZE);
+  }
+}
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java
index 9a9be21e1..c0a1bce18 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java
@@ -1,10 +1,14 @@
 package com.bumptech.glide.samples.flickr;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
 import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.module.AppGlideModule;
+import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.samples.flickr.api.Photo;
 import java.io.InputStream;
 
@@ -13,8 +17,16 @@
  */
 @GlideModule
 public class FlickrGlideModule extends AppGlideModule {
+
+  @Override
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
+    super.applyOptions(context, builder);
+    builder.setDefaultRequestOptions(new RequestOptions().format(DecodeFormat.PREFER_ARGB_8888));
+  }
+
   @Override
-  public void registerComponents(Context context, Glide glide, Registry registry) {
+  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry) {
     registry.append(Photo.class, InputStream.class, new FlickrModelLoader.Factory());
   }
 
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java
index cf7ea32c0..a2b3d2f6e 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.samples.flickr;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelCache;
@@ -17,18 +18,19 @@
  * ExecutorService backing the Engine to download the image and resize it in memory before saving
  * the resized version directly to the disk cache.
  */
-public class FlickrModelLoader extends BaseGlideUrlLoader<Photo> {
+public final class FlickrModelLoader extends BaseGlideUrlLoader<Photo> {
 
   /**
    * The default factory for {@link com.bumptech.glide.samples.flickr.FlickrModelLoader}s.
    */
   public static class Factory implements ModelLoaderFactory<Photo, InputStream> {
-    private final ModelCache<Photo, GlideUrl> modelCache = new ModelCache<Photo, GlideUrl>(500);
+    private final ModelCache<Photo, GlideUrl> modelCache = new ModelCache<>(500);
 
+    @NonNull
     @Override
     public ModelLoader<Photo, InputStream> build(MultiModelLoaderFactory multiFactory) {
-      return new FlickrModelLoader(multiFactory.build(GlideUrl.class, InputStream.class),
-          modelCache);
+      return new FlickrModelLoader(
+          multiFactory.build(GlideUrl.class, InputStream.class), modelCache);
     }
 
     @Override
@@ -36,13 +38,13 @@ public void teardown() {
     }
   }
 
-  public FlickrModelLoader(ModelLoader<GlideUrl, InputStream> urlLoader,
-      ModelCache<Photo, GlideUrl> modelCache) {
+  private FlickrModelLoader(
+      ModelLoader<GlideUrl, InputStream> urlLoader, ModelCache<Photo, GlideUrl> modelCache) {
     super(urlLoader, modelCache);
   }
 
   @Override
-  public boolean handles(Photo model) {
+  public boolean handles(@NonNull Photo model) {
     return true;
   }
 
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
index 9539d0006..65bc1ceab 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
@@ -5,6 +5,7 @@
 import android.graphics.drawable.Drawable;
 import android.os.Bundle;
 import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.support.v4.app.Fragment;
 import android.support.v7.widget.GridLayoutManager;
 import android.support.v7.widget.RecyclerView;
@@ -20,6 +21,7 @@
 import com.bumptech.glide.samples.flickr.api.Api;
 import com.bumptech.glide.samples.flickr.api.Photo;
 import com.bumptech.glide.util.FixedPreloadSizeProvider;
+import com.bumptech.glide.util.Preconditions;
 import java.util.Collections;
 import java.util.List;
 
@@ -55,9 +57,9 @@ public static FlickrPhotoGrid newInstance(int size, int preloadCount, boolean th
   }
 
   @Override
-  public View onCreateView(LayoutInflater inflater, ViewGroup container,
-      Bundle savedInstanceState) {
-    Bundle args = getArguments();
+  public View onCreateView(
+      @NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+    Bundle args = Preconditions.checkNotNull(getArguments());
     photoSize = args.getInt(IMAGE_SIZE_KEY);
     thumbnail = args.getBoolean(THUMBNAIL_KEY);
 
@@ -77,7 +79,7 @@ public View onCreateView(LayoutInflater inflater, ViewGroup container,
 
     final int gridMargin = getResources().getDimensionPixelOffset(R.dimen.grid_margin);
     int spanCount = getResources().getDisplayMetrics().widthPixels / (photoSize + (2 * gridMargin));
-    grid = (RecyclerView) result.findViewById(R.id.flickr_photo_grid);
+    grid = result.findViewById(R.id.flickr_photo_grid);
     layoutManager = new GridLayoutManager(getActivity(), spanCount);
     grid.setLayoutManager(layoutManager);
 
@@ -121,7 +123,7 @@ public void onViewRecycled(RecyclerView.ViewHolder holder) {
   }
 
   @Override
-  public void onSaveInstanceState(Bundle outState) {
+  public void onSaveInstanceState(@NonNull Bundle outState) {
     super.onSaveInstanceState(outState);
     if (grid != null) {
       int index = layoutManager.findFirstVisibleItemPosition();
@@ -142,11 +144,11 @@ public void onPhotosUpdated(List<Photo> photos) {
     private final LayoutInflater inflater;
     private List<Photo> photos = Collections.emptyList();
 
-    public PhotoAdapter() {
+    PhotoAdapter() {
       this.inflater = LayoutInflater.from(getActivity());
     }
 
-    public void setPhotos(List<Photo> photos) {
+    void setPhotos(List<Photo> photos) {
       this.photos = photos;
       notifyDataSetChanged();
     }
@@ -198,17 +200,17 @@ public int getItemCount() {
       return photos.subList(position, position + 1);
     }
 
-    @NonNull
+    @Nullable
     @Override
-    public RequestBuilder<Drawable> getPreloadRequestBuilder(Photo item) {
+    public RequestBuilder<Drawable> getPreloadRequestBuilder(@NonNull Photo item) {
       return preloadRequest.load(item);
     }
   }
 
-  private static class PhotoViewHolder extends RecyclerView.ViewHolder {
+  private static final class PhotoViewHolder extends RecyclerView.ViewHolder {
     private final ImageView imageView;
 
-    public PhotoViewHolder(View itemView) {
+    PhotoViewHolder(View itemView) {
       super(itemView);
       imageView = (ImageView) itemView;
     }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java
index e54856c2a..a9423c091 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java
@@ -8,6 +8,7 @@
 import android.graphics.drawable.Drawable;
 import android.os.Bundle;
 import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.support.v4.app.Fragment;
 import android.support.v7.widget.LinearLayoutManager;
 import android.support.v7.widget.RecyclerView;
@@ -54,11 +55,11 @@ public void onPhotosUpdated(List<Photo> photos) {
   }
 
   @Override
-  public View onCreateView(LayoutInflater inflater, ViewGroup container,
-      Bundle savedInstanceState) {
+  public View onCreateView(
+      @NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
     final View result = inflater.inflate(R.layout.flickr_photo_list, container, false);
 
-    list = (RecyclerView) result.findViewById(R.id.flickr_photo_list);
+    list = result.findViewById(R.id.flickr_photo_list);
     layoutManager = new LinearLayoutManager(getActivity());
     list.setLayoutManager(layoutManager);
     adapter = new FlickrPhotoListAdapter();
@@ -105,7 +106,7 @@ public void onViewRecycled(RecyclerView.ViewHolder holder) {
   }
 
   @Override
-  public void onSaveInstanceState(Bundle outState) {
+  public void onSaveInstanceState(@NonNull Bundle outState) {
     super.onSaveInstanceState(outState);
     if (list != null) {
       int index = layoutManager.findFirstVisibleItemPosition();
@@ -116,16 +117,16 @@ public void onSaveInstanceState(Bundle outState) {
     }
   }
 
-  private class FlickrPhotoListAdapter extends RecyclerView.Adapter<PhotoTitleViewHolder>
+  private final class FlickrPhotoListAdapter extends RecyclerView.Adapter<PhotoTitleViewHolder>
       implements ListPreloader.PreloadModelProvider<Photo> {
     private final LayoutInflater inflater;
     private List<Photo> photos = Collections.emptyList();
 
-    public FlickrPhotoListAdapter() {
+    FlickrPhotoListAdapter() {
       this.inflater = LayoutInflater.from(getActivity());
     }
 
-    public void setPhotos(List<Photo> photos) {
+    void setPhotos(List<Photo> photos) {
       this.photos = photos;
       notifyDataSetChanged();
     }
@@ -172,21 +173,21 @@ public int getItemCount() {
       return photos.subList(position, position + 1);
     }
 
-    @NonNull
+    @Nullable
     @Override
-    public RequestBuilder<Drawable> getPreloadRequestBuilder(Photo item) {
+    public RequestBuilder<Drawable> getPreloadRequestBuilder(@NonNull Photo item) {
       return fullRequest.thumbnail(thumbRequest.load(item)).load(item);
     }
   }
 
-  private static class PhotoTitleViewHolder extends RecyclerView.ViewHolder {
+  private static final class PhotoTitleViewHolder extends RecyclerView.ViewHolder {
     private final TextView titleView;
     private final ImageView imageView;
 
-    public PhotoTitleViewHolder(View itemView) {
+    PhotoTitleViewHolder(View itemView) {
       super(itemView);
-      imageView = (ImageView) itemView.findViewById(R.id.photo_view);
-      titleView = (TextView) itemView.findViewById(R.id.title_view);
+      imageView = itemView.findViewById(R.id.photo_view);
+      titleView = itemView.findViewById(R.id.title_view);
     }
   }
 }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
index cedac252f..d1b57740e 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
@@ -47,10 +47,11 @@
   private static final Query DEFAULT_QUERY = new SearchQuery("kitten");
 
   private final QueryListener queryListener = new QueryListener();
+  private final Set<PhotoViewer> photoViewers = new HashSet<>();
+
+  private List<Photo> currentPhotos = new ArrayList<>();
   private View searching;
   private TextView searchTerm;
-  private Set<PhotoViewer> photoViewers = new HashSet<>();
-  private List<Photo> currentPhotos = new ArrayList<>();
   private View searchLoading;
   private BackgroundThumbnailFetcher backgroundThumbnailFetcher;
   private HandlerThread backgroundThread;
@@ -64,13 +65,14 @@
     LIST
   }
 
-  private static final Map<Page, Integer> PAGE_TO_TITLE = new HashMap<Page, Integer>() {
-    {
-      put(Page.SMALL, R.string.small);
-      put(Page.MEDIUM, R.string.medium);
-      put(Page.LIST, R.string.list);
-    }
-  };
+  private static final Map<Page, Integer> PAGE_TO_TITLE;
+  static {
+    Map<Page, Integer> temp = new HashMap<>();
+    temp.put(Page.SMALL, R.string.small);
+    temp.put(Page.MEDIUM, R.string.medium);
+    temp.put(Page.LIST, R.string.list);
+    PAGE_TO_TITLE = Collections.unmodifiableMap(temp);
+  }
 
   @Override
   public void onAttachFragment(Fragment fragment) {
@@ -248,12 +250,12 @@ public void onSearchFailed(Query query, Exception e) {
     }
   }
 
-  private class FlickrPagerAdapter extends FragmentPagerAdapter {
+  private final class FlickrPagerAdapter extends FragmentPagerAdapter {
 
     private int mLastPosition = -1;
     private Fragment mLastFragment;
 
-    public FlickrPagerAdapter(FragmentManager fm) {
+    FlickrPagerAdapter(FragmentManager fm) {
       super(fm);
     }
 
@@ -311,16 +313,17 @@ private int getPageSize(int id) {
   }
 
   private static class BackgroundThumbnailFetcher implements Runnable {
+    private final Context context;
+    private final List<Photo> photos;
+
     private boolean isCancelled;
-    private Context context;
-    private List<Photo> photos;
 
-    public BackgroundThumbnailFetcher(Context context, List<Photo> photos) {
+    BackgroundThumbnailFetcher(Context context, List<Photo> photos) {
       this.context = context;
       this.photos = photos;
     }
 
-    public void cancel() {
+    void cancel() {
       isCancelled = true;
     }
 
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/PhotoViewer.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/PhotoViewer.java
index 19776b359..28e88ecb5 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/PhotoViewer.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/PhotoViewer.java
@@ -7,11 +7,11 @@
  * An interface for an object that displays {@link com.bumptech.glide.samples.flickr.api.Photo}
  * objects.
  */
-public interface PhotoViewer {
+interface PhotoViewer {
   /**
    * Called whenever new {@link com.bumptech.glide.samples.flickr.api.Photo}s are loaded.
    *
    * @param photos The loaded photos.
    */
-  public void onPhotosUpdated(List<Photo> photos);
+  void onPhotosUpdated(List<Photo> photos);
 }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/SquareImageView.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/SquareImageView.java
index 5988e6bf8..e6cce5ec7 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/SquareImageView.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/SquareImageView.java
@@ -22,6 +22,8 @@ public SquareImageView(Context context, AttributeSet attrs, int defStyleAttr) {
     super(context, attrs, defStyleAttr);
   }
 
+  // We want a square view.
+  @SuppressWarnings("SuspiciousNameCombination")
   @Override
   protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
     super.onMeasure(widthMeasureSpec, widthMeasureSpec);
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Api.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Api.java
index 4ef7f0bde..6fa99de2c 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Api.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Api.java
@@ -17,9 +17,8 @@
 /**
  * A class for interfacing with Flickr's http API.
  */
-public class Api {
+public final class Api {
   private static Api api;
-  private static final String TAG = "FlickrApi";
   private static final String API_KEY = "f0e6fbb5fdf1f3842294a1d21f84e8a6";
   private static final String SIGNED_API_URL =
       "https://api.flickr.com/services/rest/?method=%s&format=json&api_key=" + API_KEY;
@@ -73,7 +72,9 @@ private static String getSizeKey(int width, int height) {
 
     boolean isFirstLargest = true;
     List<String> result = new ArrayList<>();
-    for (int edge : SORTED_SIZE_KEYS) {
+    int size = result.size();
+    for (int i = 0; i < size; i++) {
+      int edge = SORTED_SIZE_KEYS.get(i);
       if (largestEdge <= edge) {
         if (isFirstLargest) {
           isFirstLargest = false;
@@ -86,7 +87,7 @@ private static String getSizeKey(int width, int height) {
 
   }
 
-  public static String getCacheableUrl(Photo photo) {
+  static String getCacheableUrl(Photo photo) {
     return String.format(CACHEABLE_PHOTO_URL, photo.getFarm(), photo.getServer(), photo.getId(),
         photo.getSecret());
   }
@@ -154,10 +155,10 @@ public static Api get(Context context) {
   }
 
   private final RequestQueue requestQueue;
-  private final Set<QueryListener> queryListeners = new HashSet<QueryListener>();
+  private final Set<QueryListener> queryListeners = new HashSet<>();
   private QueryResult lastQueryResult;
 
-  protected Api(Context context) {
+  private Api(Context context) {
     this.requestQueue = Volley.newRequestQueue(context.getApplicationContext());
     QueryListener queryListener = new QueryListener() {
       @Override
@@ -202,7 +203,7 @@ public void query(Query query) {
     private final Query query;
     private final List<Photo> results;
 
-    public QueryResult(Query query, List<Photo> results) {
+    QueryResult(Query query, List<Photo> results) {
       this.query = query;
       this.results = results;
     }
diff --git a/samples/gallery/build.gradle b/samples/gallery/build.gradle
index bc2e3fde3..7b40050cb 100644
--- a/samples/gallery/build.gradle
+++ b/samples/gallery/build.gradle
@@ -1,18 +1,17 @@
 apply plugin: 'com.android.application'
 
 dependencies {
-    compile project(':library')
-    compile(project(':integration:recyclerview')) {
+    implementation project(':library')
+    implementation(project(':integration:recyclerview')) {
         transitive = false
     }
-    compile "com.android.support:recyclerview-v7:${ANDROID_SUPPORT_VERSION}"
-    compile "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
+    implementation "com.android.support:recyclerview-v7:${ANDROID_SUPPORT_VERSION}"
+    implementation "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
     annotationProcessor project(':annotation:compiler')
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         applicationId 'com.bumptech.glide.samples.gallery'
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java
index 30933931c..46ac3d232 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.samples.gallery;
 
 import android.os.Bundle;
+import android.support.annotation.NonNull;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.LoaderManager;
 import android.support.v4.content.Loader;
@@ -27,8 +28,8 @@ public void onCreate(Bundle savedInstanceState) {
   }
 
   @Override
-  public View onCreateView(LayoutInflater inflater, ViewGroup container,
-      Bundle savedInstanceState) {
+  public View onCreateView(
+      @NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
     View result = inflater.inflate(R.layout.recycler_view, container, false);
     recyclerView = (RecyclerView) result.findViewById(R.id.recycler_view);
     GridLayoutManager layoutManager = new GridLayoutManager(getActivity(), 1);
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java
index cf315b106..1206230ff 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java
@@ -1,11 +1,11 @@
 package com.bumptech.glide.samples.gallery;
 
 import android.Manifest.permission;
-import android.annotation.TargetApi;
 import android.content.pm.PackageManager;
 import android.os.Build;
 import android.os.Bundle;
 import android.support.annotation.NonNull;
+import android.support.annotation.RequiresApi;
 import android.support.v4.app.ActivityCompat;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
@@ -16,6 +16,7 @@
 /**
  * Displays a {@link HorizontalGalleryFragment}.
  */
+@RequiresApi(Build.VERSION_CODES.JELLY_BEAN)
 public class MainActivity extends FragmentActivity {
 
   private static final int REQUEST_READ_STORAGE = 0;
@@ -34,7 +35,6 @@ protected void onCreate(Bundle savedInstanceState) {
     }
   }
 
-  @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
   private void requestStoragePermission() {
      ActivityCompat.requestPermissions(this,
         new String[]{permission.READ_EXTERNAL_STORAGE},
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreData.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreData.java
index 8663eafdd..c0c924e15 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreData.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreData.java
@@ -25,15 +25,15 @@ public int describeContents() {
     return 0;
   }
 
-  public final long rowId;
-  public final Uri uri;
-  public final String mimeType;
-  public final long dateModified;
-  public final int orientation;
-  public final Type type;
-  public final long dateTaken;
+  final long rowId;
+  final Uri uri;
+  final String mimeType;
+  final long dateModified;
+  final int orientation;
+  private final Type type;
+  final long dateTaken;
 
-  public MediaStoreData(long rowId, Uri uri, String mimeType, long dateTaken, long dateModified,
+  MediaStoreData(long rowId, Uri uri, String mimeType, long dateTaken, long dateModified,
       int orientation, Type type) {
     this.rowId = rowId;
     this.uri = uri;
@@ -44,7 +44,7 @@ public MediaStoreData(long rowId, Uri uri, String mimeType, long dateTaken, long
     this.dateTaken = dateTaken;
   }
 
-  MediaStoreData(Parcel in) {
+  private MediaStoreData(Parcel in) {
     rowId = in.readLong();
     uri = Uri.parse(in.readString());
     mimeType = in.readString();
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreDataLoader.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreDataLoader.java
index efe2366d5..372e9dbe8 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreDataLoader.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreDataLoader.java
@@ -37,7 +37,7 @@
   private boolean observerRegistered = false;
   private final ForceLoadContentObserver forceLoadContentObserver = new ForceLoadContentObserver();
 
-  public MediaStoreDataLoader(Context context) {
+  MediaStoreDataLoader(Context context) {
     super(context);
   }
 
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java
index 96897779d..665cccffe 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java
@@ -4,6 +4,7 @@
 import android.graphics.Point;
 import android.graphics.drawable.Drawable;
 import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.support.v7.widget.RecyclerView;
 import android.view.Display;
 import android.view.LayoutInflater;
@@ -16,6 +17,7 @@
 import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.signature.MediaStoreSignature;
+import com.bumptech.glide.util.Preconditions;
 import java.util.Collections;
 import java.util.List;
 
@@ -98,9 +100,9 @@ public int getItemViewType(int position) {
     return Collections.singletonList(data.get(position));
   }
 
-  @NonNull
+  @Nullable
   @Override
-  public RequestBuilder<Drawable> getPreloadRequestBuilder(MediaStoreData item) {
+  public RequestBuilder<Drawable> getPreloadRequestBuilder(@NonNull MediaStoreData item) {
     MediaStoreSignature signature =
         new MediaStoreSignature(item.mimeType, item.dateModified, item.orientation);
     return requestBuilder
@@ -109,8 +111,10 @@ public int getItemViewType(int position) {
         .load(item.uri);
   }
 
+  @Nullable
   @Override
-  public int[] getPreloadSize(MediaStoreData item, int adapterPosition, int perItemPosition) {
+  public int[] getPreloadSize(@NonNull MediaStoreData item, int adapterPosition,
+      int perItemPosition) {
     return actualDimensions;
   }
 
@@ -118,7 +122,7 @@ public int getItemViewType(int position) {
   @SuppressWarnings("deprecation")
   private static int getScreenWidth(Context context) {
     WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
-    Display display = wm.getDefaultDisplay();
+    Display display = Preconditions.checkNotNull(wm).getDefaultDisplay();
     Point size = new Point();
     display.getSize(size);
     return size.x;
@@ -128,13 +132,13 @@ private static int getScreenWidth(Context context) {
    * ViewHolder containing views to display individual {@link
    * com.bumptech.glide.samples.gallery.MediaStoreData}.
    */
-  public static final class ListViewHolder extends RecyclerView.ViewHolder {
+  static final class ListViewHolder extends RecyclerView.ViewHolder {
 
     private final ImageView image;
 
-    public ListViewHolder(View itemView) {
+    ListViewHolder(View itemView) {
       super(itemView);
-      image = (ImageView) itemView.findViewById(R.id.image);
+      image = itemView.findViewById(R.id.image);
     }
   }
 }
diff --git a/samples/gallery/src/main/res/layout/main_activity.xml b/samples/gallery/src/main/res/layout/main_activity.xml
index 8a31cf241..26fd8b6a8 100644
--- a/samples/gallery/src/main/res/layout/main_activity.xml
+++ b/samples/gallery/src/main/res/layout/main_activity.xml
@@ -1,7 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
 <FrameLayout
   xmlns:android="http://schemas.android.com/apk/res/android"
+  xmlns:tools="http://schemas.android.com/tools"
+  tools:ignore="MergeRootFrame"
   android:id="@+id/fragment_container"
   android:layout_width="match_parent"
-  android:layout_height="match_parent">
-</FrameLayout>
+  android:layout_height="match_parent" />
diff --git a/samples/giphy/build.gradle b/samples/giphy/build.gradle
index 9512035e5..f224a53a9 100644
--- a/samples/giphy/build.gradle
+++ b/samples/giphy/build.gradle
@@ -1,19 +1,18 @@
 apply plugin: 'com.android.application'
 
 dependencies {
-    compile project(':library')
-    compile(project(':integration:recyclerview')) {
+    implementation project(':library')
+    implementation(project(':integration:recyclerview')) {
         transitive = false
     }
-    compile 'com.google.code.gson:gson:2.8.0'
-    compile "com.android.support:recyclerview-v7:${ANDROID_SUPPORT_VERSION}"
-    compile "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
+    implementation 'com.google.code.gson:gson:2.8.2'
+    implementation "com.android.support:recyclerview-v7:${ANDROID_SUPPORT_VERSION}"
+    implementation "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
     annotationProcessor project(':annotation:compiler')
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         applicationId 'com.bumptech.glide.samples.giphy'
diff --git a/samples/giphy/src/main/AndroidManifest.xml b/samples/giphy/src/main/AndroidManifest.xml
index cff2771de..469e1295a 100644
--- a/samples/giphy/src/main/AndroidManifest.xml
+++ b/samples/giphy/src/main/AndroidManifest.xml
@@ -3,6 +3,11 @@
           package="com.bumptech.glide.samples.giphy">
 
     <uses-permission android:name="android.permission.INTERNET"/>
+    <!--
+    Allows Glide to monitor connectivity status and restart failed requests if users go from a
+    a disconnected to a connected network state.
+    -->
+    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
 
     <application
         android:allowBackup="false"
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java
index 921dc0db6..e58c5bd0d 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java
@@ -20,8 +20,9 @@
   private static volatile Api api = null;
   private static final String BETA_KEY = "dc6zaTOxFJmzC";
   private static final String BASE_URL = "https://api.giphy.com/";
-  private static final String SEARCH_PATH = "v1/gifs/search";
   private static final String TRENDING_PATH = "v1/gifs/trending";
+  private static final int LIMIT = 100;
+  private static final int OFFSET = 0;
   private final Handler bgHandler;
   private final Handler mainHandler;
   private final HashSet<Monitor> monitors = new HashSet<>();
@@ -30,13 +31,8 @@ private static String signUrl(String url) {
     return url + "&api_key=" + BETA_KEY;
   }
 
-  private static String getSearchUrl(String query, int limit, int offset) {
-    return signUrl(
-        BASE_URL + SEARCH_PATH + "?q=" + query + "&limit=" + limit + "&offset=" + offset);
-  }
-
-  private static String getTrendingUrl(int limit, int offset) {
-    return signUrl(BASE_URL + TRENDING_PATH + "?limit=" + limit + "&offset=" + offset);
+  private static String getTrendingUrl() {
+    return signUrl(BASE_URL + TRENDING_PATH + "?limit=" + LIMIT + "&offset=" + OFFSET);
   }
 
   /**
@@ -51,7 +47,7 @@ private static String getTrendingUrl(int limit, int offset) {
     void onSearchComplete(SearchResult result);
   }
 
-  public static Api get() {
+  static Api get() {
     if (api == null) {
       synchronized (Api.class) {
         if (api == null) {
@@ -70,21 +66,16 @@ private Api() {
     // Do nothing.
   }
 
-  public void addMonitor(Monitor monitor) {
+  void addMonitor(Monitor monitor) {
     monitors.add(monitor);
   }
 
-  public void removeMonitor(Monitor monitor) {
+  void removeMonitor(Monitor monitor) {
     monitors.remove(monitor);
   }
 
-  public void search(String searchTerm) {
-    String searchUrl = getSearchUrl(searchTerm, 100, 0);
-    query(searchUrl);
-  }
-
-  public void getTrending() {
-    String trendingUrl = getTrendingUrl(100, 0);
+  void getTrending() {
+    String trendingUrl = getTrendingUrl();
     query(trendingUrl);
   }
 
@@ -138,7 +129,7 @@ public void run() {
   /**
    * A POJO mirroring the top level result JSON object returned from Giphy's api.
    */
-  public static class SearchResult {
+  public static final class SearchResult {
     public GifResult[] data;
 
     @Override
@@ -150,15 +141,13 @@ public String toString() {
   /**
    * A POJO mirroring an individual GIF image returned from Giphy's api.
    */
-  public static class GifResult {
+  public static final class GifResult {
     public String id;
-    // Page url not GIF url
-    public String url;
-    public GifUrlSet images;
+    GifUrlSet images;
 
     @Override
     public String toString() {
-      return "GifResult{" + "id='" + id + '\'' + ", url='" + url + '\'' + ", images=" + images
+      return "GifResult{" + "id='" + id + '\'' + ", images=" + images
           + '}';
     }
   }
@@ -167,10 +156,10 @@ public String toString() {
    * A POJO mirroring a JSON object with a put of urls of different sizes and dimensions returned
    * for a single image from Giphy's api.
    */
-  public static class GifUrlSet {
-    public GifImage original;
-    public GifImage fixed_width;
-    public GifImage fixed_height;
+  public static final class GifUrlSet {
+    GifImage original;
+    GifImage fixed_width;
+    GifImage fixed_height;
 
     @Override
     public String toString() {
@@ -184,17 +173,14 @@ public String toString() {
    * A POJO mirroring a JSON object for an image with one particular url, size and dimension
    * returned from Giphy's api.
    */
-  public static class GifImage {
-    public String url;
-    public int width;
-    public int height;
-    public int frames;
-    public int size;
+  public static final class GifImage {
+    String url;
+    int width;
+    int height;
 
     @Override
     public String toString() {
-      return "GifImage{" + "url='" + url + '\'' + ", width=" + width + ", height=" + height
-          + ", frames=" + frames + ", size=" + size + '}';
+      return "GifImage{" + "url='" + url + '\'' + ", width=" + width + ", height=" + height + '}';
     }
   }
 }
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java
index 5381e1f22..6fbca3826 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.samples.giphy;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.Registry;
 import com.bumptech.glide.annotation.GlideModule;
@@ -13,7 +14,8 @@
 @GlideModule
 public class GiphyGlideModule extends AppGlideModule {
   @Override
-  public void registerComponents(Context context, Glide glide, Registry registry) {
+  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry) {
     registry.append(Api.GifResult.class, InputStream.class, new GiphyModelLoader.Factory());
   }
 
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java
index 184e976ea..a0163074e 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.samples.giphy;
 
+import android.support.annotation.NonNull;
 import android.text.TextUtils;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
@@ -7,6 +8,7 @@
 import com.bumptech.glide.load.model.ModelLoaderFactory;
 import com.bumptech.glide.load.model.MultiModelLoaderFactory;
 import com.bumptech.glide.load.model.stream.BaseGlideUrlLoader;
+import com.bumptech.glide.samples.giphy.Api.GifResult;
 import java.io.InputStream;
 
 /**
@@ -14,31 +16,14 @@
  * Giphy's api into an {@link java.io.InputStream} that can be decoded into an
  * {@link android.graphics.drawable.Drawable}.
  */
-public class GiphyModelLoader extends BaseGlideUrlLoader<Api.GifResult> {
+public final class GiphyModelLoader extends BaseGlideUrlLoader<Api.GifResult> {
 
   @Override
-  public boolean handles(Api.GifResult model) {
+  public boolean handles(@NonNull Api.GifResult model) {
     return true;
   }
 
-  /**
-   * The default factory for {@link com.bumptech.glide.samples.giphy.GiphyModelLoader}s.
-   */
-  public static class Factory implements ModelLoaderFactory<Api.GifResult, InputStream> {
-
-
-    @Override
-    public ModelLoader<Api.GifResult, InputStream> build(MultiModelLoaderFactory multiFactory) {
-      return new GiphyModelLoader(multiFactory.build(GlideUrl.class, InputStream.class));
-    }
-
-    @Override
-    public void teardown() {
-      // Do nothing.
-    }
-  }
-
-  public GiphyModelLoader(ModelLoader<GlideUrl, InputStream> urlLoader) {
+  private GiphyModelLoader(ModelLoader<GlideUrl, InputStream> urlLoader) {
     super(urlLoader);
   }
 
@@ -62,4 +47,20 @@ protected String getUrl(Api.GifResult model, int width, int height, Options opti
   private static int getDifference(Api.GifImage gifImage, int width, int height) {
     return Math.abs(width - gifImage.width) + Math.abs(height - gifImage.height);
   }
+
+  /**
+   * The default factory for {@link com.bumptech.glide.samples.giphy.GiphyModelLoader}s.
+   */
+  public static final class Factory implements ModelLoaderFactory<GifResult, InputStream> {
+    @NonNull
+    @Override
+    public ModelLoader<Api.GifResult, InputStream> build(MultiModelLoaderFactory multiFactory) {
+      return new GiphyModelLoader(multiFactory.build(GlideUrl.class, InputStream.class));
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+  }
 }
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java
index 5ae74d704..947518cca 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java
@@ -8,14 +8,18 @@
 import android.graphics.drawable.Drawable;
 import android.os.Bundle;
 import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.support.v7.widget.LinearLayoutManager;
 import android.support.v7.widget.RecyclerView;
+import android.support.v7.widget.RecyclerView.RecyclerListener;
+import android.support.v7.widget.RecyclerView.ViewHolder;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.ImageView;
 import com.bumptech.glide.ListPreloader;
 import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.integration.recyclerview.RecyclerViewPreloader;
+import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.ViewPreloadSizeProvider;
 import java.util.Collections;
 import java.util.List;
@@ -32,13 +36,13 @@ protected void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
     setContentView(R.layout.activity_main);
 
-    ImageView giphyLogoView = (ImageView) findViewById(R.id.giphy_logo_view);
+    ImageView giphyLogoView = findViewById(R.id.giphy_logo_view);
 
     GlideApp.with(this)
         .load(R.raw.large_giphy_logo)
         .into(giphyLogoView);
 
-    RecyclerView gifList = (RecyclerView) findViewById(R.id.gif_list);
+    RecyclerView gifList = findViewById(R.id.gif_list);
     LinearLayoutManager layoutManager = new LinearLayoutManager(this);
     gifList.setLayoutManager(layoutManager);
 
@@ -52,6 +56,15 @@ protected void onCreate(Bundle savedInstanceState) {
     RecyclerViewPreloader<Api.GifResult> preloader =
         new RecyclerViewPreloader<>(GlideApp.with(this), adapter, preloadSizeProvider, 4);
     gifList.addOnScrollListener(preloader);
+    gifList.setRecyclerListener(new RecyclerListener() {
+      @Override
+      public void onViewRecycled(ViewHolder holder) {
+        // This is an optimization to reduce the memory usage of RecyclerView's recycled view pool
+        // and good practice when using Glide with RecyclerView.
+        GifViewHolder gifViewHolder = (GifViewHolder) holder;
+        GlideApp.with(MainActivity.this).clear(gifViewHolder.gifView);
+      }
+    });
   }
 
   @Override
@@ -79,8 +92,8 @@ public void onSearchComplete(Api.SearchResult result) {
     private static final Api.GifResult[] EMPTY_RESULTS = new Api.GifResult[0];
 
     private final Activity activity;
-    private RequestBuilder<Drawable> requestBuilder;
-    private ViewPreloadSizeProvider<Api.GifResult> preloadSizeProvider;
+    private final RequestBuilder<Drawable> requestBuilder;
+    private final ViewPreloadSizeProvider<Api.GifResult> preloadSizeProvider;
 
     private Api.GifResult[] results = EMPTY_RESULTS;
 
@@ -116,14 +129,16 @@ public void onClick(View view) {
               (ClipboardManager) activity.getSystemService(Context.CLIPBOARD_SERVICE);
           ClipData clip =
               ClipData.newPlainText("giphy_url", result.images.fixed_height.url);
-          clipboard.setPrimaryClip(clip);
+          Preconditions.checkNotNull(clipboard).setPrimaryClip(clip);
 
           Intent fullscreenIntent = FullscreenActivity.getIntent(activity, result);
           activity.startActivity(fullscreenIntent);
         }
       });
 
-      requestBuilder.load(result).into(holder.gifView);
+      // clearOnDetach let's us stop animating GifDrawables that RecyclerView hasn't yet recycled
+      // but that are currently off screen.
+      requestBuilder.load(result).into(holder.gifView).clearOnDetach();
 
       preloadSizeProvider.setView(holder.gifView);
     }
@@ -144,9 +159,9 @@ public int getItemCount() {
       return Collections.singletonList(results[position]);
     }
 
-    @NonNull
+    @Nullable
     @Override
-    public RequestBuilder<Drawable> getPreloadRequestBuilder(Api.GifResult item) {
+    public RequestBuilder<Drawable> getPreloadRequestBuilder(@NonNull Api.GifResult item) {
       return requestBuilder.load(item);
     }
   }
@@ -156,7 +171,7 @@ public int getItemCount() {
 
     GifViewHolder(View itemView) {
       super(itemView);
-      gifView = (ImageView) itemView.findViewById(R.id.gif_view);
+      gifView = itemView.findViewById(R.id.gif_view);
     }
   }
 }
diff --git a/samples/imgur/build.gradle b/samples/imgur/build.gradle
index df3acd658..215392a94 100644
--- a/samples/imgur/build.gradle
+++ b/samples/imgur/build.gradle
@@ -2,7 +2,6 @@ apply plugin: 'com.android.application'
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION
 
     defaultConfig {
         applicationId "com.bumptech.glide.samples.imgur"
@@ -21,32 +20,37 @@ android {
     buildTypes {
         release {
             minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
         }
     }
 }
 
 dependencies {
-    compile project(':library')
+    implementation project(':library')
     annotationProcessor project(':annotation:compiler')
 
-    compile "com.google.dagger:dagger:${DAGGER_VERSION}"
+    implementation "com.google.dagger:dagger:${DAGGER_VERSION}"
     annotationProcessor "com.google.dagger:dagger-compiler:${DAGGER_VERSION}"
-    compile "com.google.dagger:dagger-android:${DAGGER_VERSION}"
-    compile "com.google.dagger:dagger-android-support:${DAGGER_VERSION}"
+    implementation "com.google.dagger:dagger-android:${DAGGER_VERSION}"
+    implementation ("com.google.dagger:dagger-android-support:${DAGGER_VERSION}") {
+        exclude group: "com.android.support"
+    }
     annotationProcessor "com.google.dagger:dagger-android-processor:${DAGGER_VERSION}"
 
-    compile "com.squareup.okhttp3:okhttp:${OK_HTTP_VERSION}"
-    compile 'com.squareup.retrofit2:retrofit:2.2.0'
-    compile 'com.squareup.retrofit2:converter-gson:2.2.0'
-    compile 'com.squareup.retrofit2:adapter-rxjava:2.2.0'
+    implementation "com.squareup.okhttp3:okhttp:${OK_HTTP_VERSION}"
+    implementation 'com.squareup.retrofit2:retrofit:2.3.0'
+    implementation 'com.squareup.retrofit2:converter-gson:2.3.0'
+    implementation 'com.squareup.retrofit2:adapter-rxjava:2.3.0'
+
+    implementation 'io.reactivex:rxandroid:1.2.1'
+    implementation 'io.reactivex:rxjava:1.3.4'
 
-    compile 'io.reactivex:rxandroid:1.2.1'
-    compile 'io.reactivex:rxjava:1.2.9'
+    implementation "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}"
+    implementation "com.android.support:cardview-v7:${ANDROID_SUPPORT_VERSION}"
+    implementation "com.android.support:recyclerview-v7:${ANDROID_SUPPORT_VERSION}"
 
-    compile "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}"
-    compile "com.android.support:cardview-v7:${ANDROID_SUPPORT_VERSION}"
-    compile "com.android.support:recyclerview-v7:${ANDROID_SUPPORT_VERSION}"
+    // Fixes a compilation warning related to dagger, see
+    // https://github.com/google/guava/issues/2721.
+    compileOnly "com.google.errorprone:error_prone_annotations:2.1.3"
 }
 
 task run(type: Exec, dependsOn: 'installDebug') {
diff --git a/samples/imgur/proguard-rules.pro b/samples/imgur/proguard-rules.pro
deleted file mode 100644
index 896f865d9..000000000
--- a/samples/imgur/proguard-rules.pro
+++ /dev/null
@@ -1,25 +0,0 @@
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in /Users/judds/Library/Android/sdk/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the proguardFiles
-# directive in build.gradle.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
-
-# Uncomment this to preserve the line number information for
-# debugging stack traces.
-#-keepattributes SourceFile,LineNumberTable
-
-# If you keep the line number information, uncomment this to
-# hide the original source file name.
-#-renamesourcefileattribute SourceFile
diff --git a/samples/imgur/src/main/AndroidManifest.xml b/samples/imgur/src/main/AndroidManifest.xml
index 23f5ec718..854c9930f 100644
--- a/samples/imgur/src/main/AndroidManifest.xml
+++ b/samples/imgur/src/main/AndroidManifest.xml
@@ -2,6 +2,11 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
   package="com.bumptech.glide.samples.imgur">
   <uses-permission android:name="android.permission.INTERNET" />
+  <!--
+  Allows Glide to monitor connectivity status and restart failed requests if users go from a
+  a disconnected to a connected network state.
+  -->
+  <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
   <application
     android:allowBackup="false"
     android:icon="@mipmap/ic_launcher"
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ApplicationModule.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ApplicationModule.java
index d40c24c8c..f64d72143 100644
--- a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ApplicationModule.java
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ApplicationModule.java
@@ -8,7 +8,7 @@
  * The Application Dagger module for the Imgur sample.
  */
 @Module
-public class ApplicationModule {
+class ApplicationModule {
   @Provides
   OkHttpClient okHttpClient() {
     return new OkHttpClient();
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplicationComponent.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplicationComponent.java
index cdfc96e91..7b9d639aa 100644
--- a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplicationComponent.java
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplicationComponent.java
@@ -4,7 +4,6 @@
 import dagger.Component;
 import dagger.android.AndroidInjector;
 import dagger.android.support.AndroidSupportInjectionModule;
-
 import javax.inject.Singleton;
 
 /**
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ApiModule.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ApiModule.java
index 85b056916..7a70c6dc3 100644
--- a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ApiModule.java
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ApiModule.java
@@ -14,10 +14,7 @@
 import retrofit2.converter.gson.GsonConverterFactory;
 import rx.Observable;
 
-/**
- * Provides classes related to the Imgur API via Dagger.
- */
-@Singleton
+/** Provides classes related to the Imgur API via Dagger. */
 @Module
 public final class ApiModule {
 
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Gallery.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Gallery.java
index 6466b1527..199752239 100644
--- a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Gallery.java
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Gallery.java
@@ -7,7 +7,7 @@
  *
  * <p>Populated automatically by GSON.
  */
-public final class Gallery {
+final class Gallery {
   public List<Image> data;
 
   @Override
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Image.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Image.java
index 3f0008234..af157f8cd 100644
--- a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Image.java
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Image.java
@@ -6,11 +6,11 @@
  * <p>Populated automatically by GSON
  */
 public final class Image {
-  public String id;
+  private String id;
   public String title;
   public String description;
   public String link;
-  public boolean is_album;
+  boolean is_album;
 
   @Override
   public String toString() {
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurObservables.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurObservables.java
index 26d5f034a..478465160 100644
--- a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurObservables.java
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurObservables.java
@@ -10,7 +10,7 @@
 /**
  * Observables for retrieving metadata from Imgur's API.
  */
-public final class ImgurObservables {
+final class ImgurObservables {
 
   private final ImgurService imgurService;
 
@@ -18,7 +18,7 @@
     this.imgurService = imgurService;
   }
 
-  public Observable<List<Image>> getHotViralImages(int maxPages) {
+  Observable<List<Image>> getHotViralImages(@SuppressWarnings("SameParameterValue") int maxPages) {
     return Observable.range(0, maxPages)
         .flatMap(new Func1<Integer, Observable<List<Image>>>() {
           @Override
diff --git a/samples/svg/build.gradle b/samples/svg/build.gradle
index 433c9c4d5..e6a204650 100644
--- a/samples/svg/build.gradle
+++ b/samples/svg/build.gradle
@@ -1,15 +1,14 @@
 apply plugin: 'com.android.application'
 
 dependencies {
-    compile project(':library')
+    implementation project(':library')
     annotationProcessor project(':annotation:compiler')
-    compile 'com.caverock:androidsvg:1.2.1'
-    compile "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
+    implementation 'com.caverock:androidsvg:1.2.1'
+    implementation "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         applicationId 'com.bumptech.glide.samples.svg'
diff --git a/samples/svg/proguard-rules.pro b/samples/svg/proguard-rules.pro
deleted file mode 100644
index 95c847b91..000000000
--- a/samples/svg/proguard-rules.pro
+++ /dev/null
@@ -1,17 +0,0 @@
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in /Users/judds/dev/adt-bundle-mac-x86_64-20131030/sdk/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the proguardFiles
-# directive in build.gradle.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/MainActivity.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/MainActivity.java
index f60b46461..d91a9f665 100644
--- a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/MainActivity.java
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/MainActivity.java
@@ -13,6 +13,7 @@
 import android.widget.TextView;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.util.Preconditions;
 import java.io.File;
 
 /**
@@ -53,7 +54,7 @@ public void clearCache(View v) {
     glideRequests.clear(imageViewRes);
     glideRequests.clear(imageViewNet);
     GlideApp.get(this).clearMemory();
-    File cacheDir = Glide.getPhotoCacheDir(this);
+    File cacheDir = Preconditions.checkNotNull(Glide.getPhotoCacheDir(this));
     if (cacheDir.isDirectory()) {
       for (File child : cacheDir.listFiles()) {
         if (!child.delete()) {
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDecoder.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDecoder.java
index 3fdd91ad5..ad2212227 100644
--- a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDecoder.java
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDecoder.java
@@ -1,12 +1,12 @@
 package com.bumptech.glide.samples.svg;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.SimpleResource;
 import com.caverock.androidsvg.SVG;
 import com.caverock.androidsvg.SVGParseException;
-
 import java.io.IOException;
 import java.io.InputStream;
 
@@ -16,16 +16,17 @@
 public class SvgDecoder implements ResourceDecoder<InputStream, SVG> {
 
   @Override
-  public boolean handles(InputStream source, Options options) throws IOException {
+  public boolean handles(@NonNull InputStream source, @NonNull Options options) {
     // TODO: Can we tell?
     return true;
   }
 
-  public Resource<SVG> decode(InputStream source, int width, int height, Options options)
+  public Resource<SVG> decode(@NonNull InputStream source, int width, int height,
+      @NonNull Options options)
       throws IOException {
     try {
       SVG svg = SVG.getFromInputStream(source);
-      return new SimpleResource<SVG>(svg);
+      return new SimpleResource<>(svg);
     } catch (SVGParseException ex) {
       throw new IOException("Cannot load SVG from stream", ex);
     }
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDrawableTranscoder.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDrawableTranscoder.java
index 4f600fdc1..a3fd80abf 100644
--- a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDrawableTranscoder.java
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDrawableTranscoder.java
@@ -2,6 +2,8 @@
 
 import android.graphics.Picture;
 import android.graphics.drawable.PictureDrawable;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.SimpleResource;
@@ -13,12 +15,13 @@
  * ({@link Picture}).
  */
 public class SvgDrawableTranscoder implements ResourceTranscoder<SVG, PictureDrawable> {
+  @Nullable
   @Override
-  public Resource<PictureDrawable> transcode(Resource<SVG> toTranscode, Options options) {
+  public Resource<PictureDrawable> transcode(@NonNull Resource<SVG> toTranscode,
+      @NonNull Options options) {
     SVG svg = toTranscode.get();
     Picture picture = svg.renderToPicture();
     PictureDrawable drawable = new PictureDrawable(picture);
-    return new SimpleResource<PictureDrawable>(drawable);
+    return new SimpleResource<>(drawable);
   }
 }
-
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java
index 798d0f07f..fdd14df98 100644
--- a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java
@@ -2,6 +2,7 @@
 
 import android.content.Context;
 import android.graphics.drawable.PictureDrawable;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.Registry;
 import com.bumptech.glide.annotation.GlideModule;
@@ -15,7 +16,8 @@
 @GlideModule
 public class SvgModule extends AppGlideModule {
   @Override
-  public void registerComponents(Context context, Glide glide, Registry registry) {
+  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry) {
     registry.register(SVG.class, PictureDrawable.class, new SvgDrawableTranscoder())
         .append(InputStream.class, SVG.class, new SvgDecoder());
   }
diff --git a/samples/svg/src/main/res/layout/activity_main.xml b/samples/svg/src/main/res/layout/activity_main.xml
index 704faa1f9..bff58690a 100644
--- a/samples/svg/src/main/res/layout/activity_main.xml
+++ b/samples/svg/src/main/res/layout/activity_main.xml
@@ -16,7 +16,7 @@
         android:onClick="clearCache"
         android:clickable="true"
         android:text="@string/hello_world"
-        />
+        android:focusable="true"/>
 
     <Button
         android:id="@+id/button"
diff --git a/scripts/android-wait-for-emulator.sh b/scripts/android-wait-for-emulator.sh
new file mode 100755
index 000000000..aa6345d8b
--- /dev/null
+++ b/scripts/android-wait-for-emulator.sh
@@ -0,0 +1,25 @@
+#!/bin/bash
+
+# Originally written by Ralf Kistner <ralf@embarkmobile.com>, but placed in the public domain
+
+set +e
+
+bootanim=""
+failcounter=0
+timeout_in_sec=360
+
+until [[ "$bootanim" =~ "stopped" ]]; do
+  bootanim=`adb -e shell getprop init.svc.bootanim 2>&1 &`
+  if [[ "$bootanim" =~ "device not found" || "$bootanim" =~ "device offline"
+    || "$bootanim" =~ "running" ]]; then
+    let "failcounter += 1"
+    echo "Waiting for emulator to start"
+    if [[ $failcounter -gt timeout_in_sec ]]; then
+      echo "Timeout ($timeout_in_sec seconds) reached; failed to start emulator"
+      exit 1
+    fi
+  fi
+  sleep 1
+done
+
+echo "Emulator is ready"
diff --git a/scripts/install_firebase.sh b/scripts/install_firebase.sh
new file mode 100755
index 000000000..594d16e87
--- /dev/null
+++ b/scripts/install_firebase.sh
@@ -0,0 +1,10 @@
+#!/usr/bin/env bash
+
+set -e
+
+openssl aes-256-cbc -K $encrypted_ad2664a1c4dd_key -iv $encrypted_ad2664a1c4dd_iv -in $GCLOUD_FILE -out gcloud.json -d
+
+wget https://dl.google.com/dl/cloudsdk/channels/rapid/downloads/google-cloud-sdk-176.0.0-linux-x86_64.tar.gz
+tar xf google-cloud-sdk-176.0.0-linux-x86_64.tar.gz
+echo "y" | ./google-cloud-sdk/bin/gcloud components update beta
+./google-cloud-sdk/bin/gcloud auth activate-service-account --key-file gcloud.json
diff --git a/scripts/regenerate_resources.sh b/scripts/regenerate_resources.sh
new file mode 100755
index 000000000..4536c8da9
--- /dev/null
+++ b/scripts/regenerate_resources.sh
@@ -0,0 +1,76 @@
+#!/usr/bin/env bash
+#
+# Generates or regenerates canonical resources for Glide's emulator tests with the cooperation
+# of the BitmapRegressionTester class.
+#
+# Usage:
+# ./scripts/regenerate_resources.sh <com.bumptech.glide.instrumentation.class_name>
+#
+# The class name is optional. If not specified all tests will be run (including those that
+# do not generate resources).
+
+# The signal file that tells BitmapRegressionTester to generate the resource files.
+REGENERATE_FILE_NAME="regenerate"
+# The name of the subfolder on the sdcard where resources are stored on the device/emulator.
+DIRECTORY_NAME="test_files"
+# The full path to a place where the app is able to write resources and we're able to read them.
+DIRECTORY="/sdcard/DCIM/${DIRECTORY_NAME}"
+
+set -e
+
+if [ "$#" -eq 1 ]; then
+  test_restriction="-Pandroid.testInstrumentationRunnerArguments.class=${1}"
+fi
+
+exec 3>&1
+exec 4>&2
+if !(($VERBOSE)); then
+  exec 1>/dev/null
+  exec 2>/dev/null
+fi
+
+echo "Setting up environment..."  1>&3 2>&4
+adb devices | grep -v "List of devices" | grep device \
+  || echo "No devices found, try starting an emulator" 1>&3 2>&4
+
+adb root || true 
+# In case there are any old artifacts from an old or failed test, clean them up.
+adb shell rm -r $DIRECTORY || true
+# Create the signal file.
+# On some emulators touch fails if the directory isn't created first.
+adb shell mkdir /sdcard/DCIM || true
+adb shell mkdir $DIRECTORY || true
+# This actually has to work, previous steps may fail if the directories already exist.
+adb shell touch "${DIRECTORY}/${REGENERATE_FILE_NAME}"
+
+# On APIs > 22 we need to grant the appropriate runtime permissions so our test APK can write
+# resource files to the public sdcard. Cache and internal cache directories aren't consistently
+# available across all versions of Android. So far this is the best cross SDK solution I've 
+# found
+sdk_version=`adb shell getprop ro.build.version.sdk`
+sdk_version=`echo $sdk_version | tr -d '\r'`
+if [[ $sdk_version -gt 22 ]]; then
+  echo "Installing apks and granting runtime permissions..." 1>&3 2>&4
+  ./gradlew :instrumentation:installDebug :instrumentation:installDebugAndroidTest 
+  adb shell pm grant com.bumptech.glide.instrumentation android.permission.WRITE_EXTERNAL_STORAGE
+  adb shell pm grant com.bumptech.glide.instrumentation android.permission.READ_EXTERNAL_STORAGE
+  adb shell pm grant com.bumptech.glide.instrumentation.test android.permission.WRITE_EXTERNAL_STORAGE
+  adb shell pm grant com.bumptech.glide.instrumentation.test android.permission.READ_EXTERNAL_STORAGE
+fi
+
+echo "Generating updated resource files..." 1>&3 2>&4
+./gradlew :instrumentation:connectedDebugAndroidTest $test_restriction --parallel || true 
+
+echo "Copying updated resource files to res directory..." 1>&3 2>&4
+adb pull $DIRECTORY
+rm "${DIRECTORY_NAME}/${REGENERATE_FILE_NAME}" 
+cp $DIRECTORY_NAME/raw/* instrumentation/src/main/res/raw 
+rm -rf $DIRECTORY_NAME
+adb shell rm -r $DIRECTORY
+ 
+echo "Verifying all tests pass..." 1>&3 2>&4
+
+./gradlew :instrumentation:clean
+./gradlew :instrumentation:connectedDebugAndroidTest $test_restriction --parallel
+
+echo "Complete!" 1>&3 2>&4
diff --git a/scripts/release_checks.sh b/scripts/release_checks.sh
new file mode 100755
index 000000000..e25412f51
--- /dev/null
+++ b/scripts/release_checks.sh
@@ -0,0 +1,87 @@
+#!/usr/bin/env bash
+
+set -e
+
+if [ "$#" -ne 1 ]; then
+  echo "Usage: ./release_checks.sh <major.minor.patch[-SNAPSHOT]>"
+  exit 1
+fi
+
+if [[ $(git status -uno --porcelain) ]]; then
+  echo "One or more changes, commit or revert first."
+  git status -uno --porcelain
+  exit 1
+fi
+if [[ $(git rev-list master...bump/master --count) -ne 0 ]]; then
+  echo "Bump and master are not up to date"
+  git rev-list master...bump/master --pretty
+  exit 1
+fi
+if [[ $(git rev-list master...origin/master --count) -ne 0 ]]; then
+  echo "Origin and master are not up to date"
+  git rev-list master...origin/master --pretty
+  exit 1
+fi
+if [[ $(git ls-files --exclude-standard --others) ]]; then
+  echo "Untracked files, aborting"
+  exit 1
+fi
+
+version=$1
+echo "Setting version to $version"
+echo -n "Is this a correct? (y/n)? "
+read answer
+if echo "$answer" | grep -iq "^y" ; then
+  echo "Updating gradle.properties..."
+else
+  echo "Cancelling"
+  exit 1
+fi
+
+sed -i '' "s/VERSION_NAME=.*/VERSION_NAME=${version}/g" gradle.properties
+sed -i '' "s/VERSION_MAJOR=.*/VERSION_MAJOR=$(echo $version | cut -d '.' -f 1)/" gradle.properties
+sed -i '' "s/VERSION_MINOR=.*/VERSION_MINOR=$(echo $version | cut -d '.' -f 2)/" gradle.properties
+sed -i '' "s/VERSION_PATCH=.*/VERSION_PATCH=$(echo $version | cut -d '.' -f 3 | sed 's/-.*//')/" gradle.properties
+
+git diff
+
+echo "Updated gradle.properties, is this correct? (y/n)?"
+read answer
+if echo "$answer" | grep -iq "^y" ; then
+  echo "Committing..."
+else
+  echo "Cancelling"
+  exit 1
+fi
+
+version_tag="v${version}"
+git add gradle.properties
+git commit -m "Bump version to ${version}"
+if [[ $version != *"SNAPSHOT"* ]]; then
+  echo "Found release version, adding tag, building and uploading"
+  git tag $version_tag
+
+  echo "Building... and uploading"
+  ./gradlew clean build --parallel
+  ./gradlew uploadArchives 
+
+  echo "Upload complete, please verify the output and upload the jars to the GitHub release."
+fi
+
+echo -n "Ready to push, continue? (y/n)? "
+read answer
+if echo "$answer" | grep -iq "^y" ; then
+  echo "Pushing commits"
+else
+  echo "Cancelling"
+  exit 1
+fi
+
+git push origin master
+git push bump master
+if [[ $version != *"SNAPSHOT"* ]]; then
+  echo "Found release version, pushing tags"
+  git push origin $version_tag
+  git push bump $version_tag
+fi
+
diff --git a/scripts/run_instrumentation_tests.sh b/scripts/run_instrumentation_tests.sh
new file mode 100755
index 000000000..412690a8a
--- /dev/null
+++ b/scripts/run_instrumentation_tests.sh
@@ -0,0 +1,20 @@
+#!/usr/bin/env bash
+# Runs instrumentation tests on firebase. Must be run locally, not on travis.
+#
+# Usage: 
+# ./scripts/run_instrumentation_test.sh
+
+./gradlew :instrumentation:assembleDebug :instrumentation:assembleDebugAndroidTest --parallel
+
+apk_dir=instrumentation/build/outputs/apk
+gcloud firebase test android run \
+  --type instrumentation \
+  --app $apk_dir/instrumentation-debug.apk \
+  --test $apk_dir/instrumentation-debug-androidTest.apk \
+  --device model=Nexus6P,version=26,locale=en,orientation=portrait  \
+  --device model=Nexus6P,version=25,locale=en,orientation=portrait \
+  --device model=Nexus6P,version=23,locale=en,orientation=portrait \
+  --device model=Nexus6,version=22,locale=en,orientation=portrait \
+  --device model=Nexus5,version=19,locale=en,orientation=portrait \
+  --project android-glide \
+  --no-auto-google-login \
diff --git a/scripts/run_sample_robo_tests.sh b/scripts/run_sample_robo_tests.sh
new file mode 100755
index 000000000..d7c9cc23d
--- /dev/null
+++ b/scripts/run_sample_robo_tests.sh
@@ -0,0 +1,44 @@
+#!/usr/bin/env bash
+# Runs Firebases' robo tests (monkeyrunner) on Glide's sample apps
+#
+# Usage: 
+# ./scripts/run_sample_robo_tests.sh
+
+set -e
+
+./gradlew :samples:flickr:build \
+  :samples:giphy:build \
+  :samples:contacturi:build \
+  :samples:gallery:build \
+  :samples:imgur:build \
+  :samples:svg:build \
+  --parallel
+
+declare -a samples=("flickr" 
+                "giphy" 
+                "contacturi"
+                "gallery"
+                "imgur"
+                "svg")
+pids=()
+
+for sample in "${samples[@]}"
+do
+  sample_dir="samples/${sample}/build/outputs/apk/"
+  sample_apk="${sample_dir}/${sample}-debug.apk"
+  gcloud firebase test android run \
+    --type robo \
+    --app $sample_apk \
+    --device model=Nexus6P,version=26,locale=en,orientation=portrait  \
+    --project android-glide \
+    --no-auto-google-login &
+  pids+=("$!")
+done
+
+for current in "${pids[@]}"
+do
+  wait $current
+done
+       
+
+
diff --git a/scripts/split_by_sdk.sh b/scripts/split_by_sdk.sh
new file mode 100755
index 000000000..8e700ba8a
--- /dev/null
+++ b/scripts/split_by_sdk.sh
@@ -0,0 +1,169 @@
+#!/usr/bin/env bash
+#
+# Loops through all Android API levels that Glide supports (and that 
+# functioning emulators exist for) and runs a particular emulator test file
+# to generate canonical assets. If assets start to fail on a particular sdk
+# level, the test file is updated with the new API level to split on and 
+# assets for that particular api level are added to the test resources 
+# directory.
+#
+# Usage:
+#   ./scripts/split_by_sdk.sh [--abis x86,armeabi-v7a] [--apis 16,17] \
+#      [-v/--verbose] [--tests com.bumptech.glide.TestName1,com.bumptech.glide.TestName2]
+#
+# apis: The Android SDK version(s) you want to run against.
+# abis: The Android CPU types you want to run against
+# v/verbose: Enable verbose logging.
+
+POSITIONAL=()
+while [[ $# -gt 0 ]]
+do
+key="$1"
+
+case $key in
+    --tests)
+    test_classes_string="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    --apis)
+    apis_string="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    --abis)
+    abis_string="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    -v|--verbose)
+    verbose="1"
+    shift # past argument
+    ;;
+    *)    # unknown option
+    POSITIONAL+=("$1") # save it in an array for later
+    shift # past argument
+    ;;
+esac
+done
+set -- "${POSITIONAL[@]}" # restore positional parameters
+
+if [ -z "$test_classes_string" ]; then
+  test_classes_string=`grep -rwl instrumentation/src/androidTest -e RegressionTest \
+    | grep -v "/test/" \
+    | grep -v ".bak" \
+    | tr '\n' ',' \
+    | sed 's/instrumentation\/src\/androidTest\/java\///g' \
+    | sed 's/\//\./g' \
+    | sed 's/\.java//g' \
+    | sed 's/,*$//g'` 
+fi
+
+if [ -z "$apis_string" ]; then
+  declare -a apis=(
+                  "16" 
+                  #"17" API 17 emulator seems to have trouble starting and I haven't yet found a case where behaviors changed at that API level.
+                  "18"
+                  "19"
+                  # "20" Android Wear, missing x86 emulators.
+                  "21"
+                  "22"
+                  "23"
+                  "24"
+                  "25"
+                  "26")
+else 
+  IFS=',' read -ra apis <<< "$apis_string"
+fi
+
+if [ -z "$abis_string" ]; then
+  declare -a abis=(
+  "x86"
+  "armeabi-v7a"
+  )
+else 
+  IFS=',' read -ra abis <<< "$abis_string"
+fi
+
+IFS=',' read -ra test_classes <<< "$test_classes_string"
+for test_class in "${test_classes[@]}"
+do
+  test_path=`echo $test_class | sed 's/\./\//g' | sed -e 's/^/instrumentation\/src\/androidTest\/java\//' | sed -e 's/$/\.java/'`
+  if [ ! -f "${test_path}" ]; then
+    echo "Missing test $test_class at expected path: $test_path"
+    exit 1
+  fi
+done
+
+if (($verbose)); then
+  printf "tests: "
+  printf '%s,' "${test_classes[@]}"
+  printf "\nabis:"
+  printf '%s,' "${abis[@]}"
+  printf "\napis:"
+  printf '%s,' "${apis[@]}"
+  printf "\n"
+fi
+
+adb devices | grep -v "List of devices" | grep device > /dev/null 2>&1 \
+  && \
+  { \
+    echo "Emulators are already running, kill them before running this script: "; \
+    echo "e.g.: adb -s emulator-5554 emu kill"; \
+    adb devices; \
+    exit 1; \
+  }
+
+exec 3>&1
+exec 4>&2
+if !(($verbose)); then
+  exec 1>/dev/null
+  exec 2>/dev/null
+fi
+
+for abi in "${abis[@]}"
+do
+  if [ "${abi}" == "armeabi-v7a" ]; then
+    emulator_type="default"
+    emulator_script=$ANDROID_HOME/emulator/emulator
+  else 
+    emulator_type="google_apis"
+    emulator_script=$ANDROID_HOME/tools/emulator
+  fi
+
+  for api in "${apis[@]}"
+  do
+    if [ "${abi}" == "armeabi-v7a" ] && [ "${api}" -gt 22 ]; then
+      echo "armeabi-v7a emulators beyond API 22 are unreliable, ignoring ${api}"
+      continue
+    fi
+
+    echo "Checking on API ${api} and ${abi}" 1>&3 2>&4
+    target="system-images;android-${api};${emulator_type};${abi}"
+    sdkmanager --install $target
+    avdmanager create avd --force -n test -k $target --device "Nexus 5X" -c 2000M 
+    QEMU_AUDIO_DRV=none $emulator_script -avd test -no-window &
+    pid=$!
+    ./scripts/android-wait-for-emulator.sh
+    for test_class in "${test_classes[@]}"
+    do
+      test_path=`echo $test_class | sed 's/\./\//g' | sed -e 's/^/instrumentation\/src\/androidTest\/java\//' | sed -e 's/$/\.java/'`
+      ./gradlew :instrumentation:connectedCheck \
+        -Pandroid.testInstrumentationRunnerArguments.class=$test_class
+      if [ $? -ne 0 ]; then
+        echo "Tests for API ${api} failed, updating SplitBySdk and generating resources..." 1>&3 2>&4
+        if [ -z $(grep "@SplitBySdk" $test_path | grep "${api}") ]; then
+          sed -i.bak s/@SplitBySdk\(\{/@SplitBySdk\(\{$api,/ $test_path
+          rm "${test_path}.bak"
+        fi
+        ./scripts/regenerate_resources.sh $test_class #|| { echo "Tests still fail with new resources, aborting";  exit 1; }
+      fi
+    done
+    adb -s emulator-5554 emu kill
+    sleep 1
+    kill -9 $pid
+    pkill emulator64-crash-service
+    pkill emulator-crash-service
+    echo "Finished API ${api}" 1>&3 2>&4
+  done
+done
diff --git a/scripts/travis_after_success.sh b/scripts/travis_after_success.sh
new file mode 100755
index 000000000..d9c2a3042
--- /dev/null
+++ b/scripts/travis_after_success.sh
@@ -0,0 +1,7 @@
+#!/usr/bin/env bash
+
+set -e
+
+if [ "$COMPONENT" == "unit" ]; then
+  ./scripts/travis_sonatype_publish.sh
+fi
diff --git a/scripts/travis_before_script.sh b/scripts/travis_before_script.sh
new file mode 100755
index 000000000..e45e901af
--- /dev/null
+++ b/scripts/travis_before_script.sh
@@ -0,0 +1,7 @@
+#!/usr/bin/env bash
+# Copies our debug.keystore file to its expected location to avoid a bug
+# where the Android build system seems to occasionally fail to generate it.
+
+set -e
+
+cp debug.keystore ~/.android/debug.keystore
diff --git a/scripts/travis_create_emulator.sh b/scripts/travis_create_emulator.sh
new file mode 100755
index 000000000..997ffcdcc
--- /dev/null
+++ b/scripts/travis_create_emulator.sh
@@ -0,0 +1,11 @@
+#!/usr/bin/env bash
+
+set -e
+
+target="system-images;android-${ANDROID_TARGET};default;armeabi-v7a"
+echo y | sdkmanager --update
+echo y | sdkmanager --install $target
+avdmanager create avd --force -n test -k $target --device "Nexus 4" -c 2048M
+QEMU_AUDIO_DRV=none $ANDROID_HOME/emulator/emulator -avd test -no-window -memory 2048 &
+
+exit 0
diff --git a/scripts/travis_firebase.sh b/scripts/travis_firebase.sh
new file mode 100755
index 000000000..e405462a5
--- /dev/null
+++ b/scripts/travis_firebase.sh
@@ -0,0 +1,32 @@
+#!/usr/bin/env bash
+
+set -e
+
+if [ ! "$firebase_enabled" == "true" ]; then
+  echo "Unable to run Firebase tests for pull requests, exiting"
+  exit 0
+fi
+
+./gradlew :instrumentation:assembleDebug \
+  :instrumentation:assembleDebugAndroidTest \
+  --parallel \
+  -PDISABLE_ERROR_PRONE &
+pid=$!
+./scripts/install_firebase.sh
+wait $pid
+
+apk_dir=instrumentation/build/outputs/apk
+./google-cloud-sdk/bin/gcloud firebase test android run \
+  --type instrumentation \
+  --app $apk_dir/debug/instrumentation-debug.apk \
+  --test $apk_dir/androidTest/debug/instrumentation-debug-androidTest.apk \
+  --device model=Nexus6P,version=27,locale=en,orientation=portrait \
+  --device model=Nexus6P,version=26,locale=en,orientation=portrait \
+  --device model=Nexus6P,version=25,locale=en,orientation=portrait \
+  --device model=Nexus6P,version=24,locale=en,orientation=portrait \
+  --device model=Nexus6P,version=23,locale=en,orientation=portrait \
+  --device model=Nexus6,version=22,locale=en,orientation=portrait \
+  --device model=Nexus5,version=21,locale=en,orientation=portrait \
+  --device model=Nexus5,version=19,locale=en,orientation=portrait \
+  --project android-glide \
+  --no-auto-google-login \
diff --git a/scripts/travis_instrumentation.sh b/scripts/travis_instrumentation.sh
new file mode 100755
index 000000000..d365034bf
--- /dev/null
+++ b/scripts/travis_instrumentation.sh
@@ -0,0 +1,17 @@
+#!/usr/bin/env bash
+
+set -e
+
+echo "Starting emulator for $COMPONENT tests"
+./scripts/travis_create_emulator.sh &
+
+./gradlew :instrumentation:assembleDebug \
+  :instrumentation:assembleDebugAndroidTest \
+  --parallel \
+  -PDISABLE_ERROR_PRONE
+
+echo "Waiting for emulator..."
+android-wait-for-emulator
+
+for i in {1..3}; do ./gradlew :instrumentation:connectedDebugAndroidTest && break; done
+
diff --git a/scripts/travis_samples.sh b/scripts/travis_samples.sh
new file mode 100755
index 000000000..45fe59827
--- /dev/null
+++ b/scripts/travis_samples.sh
@@ -0,0 +1,53 @@
+#!/usr/bin/env bash
+
+set -e
+
+./gradlew :samples:flickr:build \
+  :samples:giphy:build \
+  :samples:contacturi:build \
+  :samples:gallery:build \
+  :samples:imgur:build \
+  :samples:svg:build \
+  --parallel \
+  -PERROR_PRONE="false" &
+pid=$!
+
+if [ ! "$firebase_enabled" == "true" ]; then
+  wait $pid
+  echo "Unable to run Firebase tests for pull requests, exiting"
+  exit 0
+else
+  ./scripts/install_firebase.sh
+  wait $pid
+fi
+
+
+declare -a samples=("flickr"
+                "giphy"
+                "contacturi"
+                "gallery"
+                "imgur"
+                "svg")
+pids=()
+
+for sample in "${samples[@]}"
+do
+  sample_dir="samples/${sample}/build/outputs/apk/debug"
+  sample_apk="${sample_dir}/${sample}-debug.apk"
+  ./google-cloud-sdk/bin/gcloud firebase test android run \
+    --type robo \
+    --app $sample_apk \
+    --device model=Nexus6P,version=26,locale=en,orientation=portrait  \
+    --project android-glide \
+    --no-auto-google-login \
+    --timeout 5m \
+    &
+  pids+=("$!")
+done
+
+for current in "${pids[@]}"
+do
+  wait $current
+done
+
+
diff --git a/scripts/travis_script.sh b/scripts/travis_script.sh
new file mode 100755
index 000000000..ab103e875
--- /dev/null
+++ b/scripts/travis_script.sh
@@ -0,0 +1,23 @@
+#!/usr/bin/env bash
+
+set -e
+
+if [ -z ${encrypted_ad2664a1c4dd_key+x} ] || [ -z ${encrypted_ad2664a1c4dd_iv+x} ] || [ -z ${GCLOUD_FILE} ]; then
+  export firebase_enabled="false"
+else
+  export firebase_enabled="true"
+fi
+
+
+if [ "$COMPONENT" == "unit" ]; then
+  ./scripts/travis_unit.sh
+elif [ "$COMPONENT" == "instrumentation" ]; then
+  ./scripts/travis_instrumentation.sh
+elif [ "$COMPONENT" == "samples" ]; then
+  ./scripts/travis_samples.sh
+elif [ "$COMPONENT" == "firebase" ]; then
+  ./scripts/travis_firebase.sh
+else
+  echo "Unrecognized component: $COMPONENT"
+  exit 1
+fi
diff --git a/scripts/travis-sonatype-publish.sh b/scripts/travis_sonatype_publish.sh
similarity index 100%
rename from scripts/travis-sonatype-publish.sh
rename to scripts/travis_sonatype_publish.sh
diff --git a/scripts/travis_unit.sh b/scripts/travis_unit.sh
new file mode 100755
index 000000000..ec19192f6
--- /dev/null
+++ b/scripts/travis_unit.sh
@@ -0,0 +1,12 @@
+#!/usr/bin/env bash
+
+set -e
+
+./gradlew build \
+  -x :samples:flickr:build \
+  -x :samples:giphy:build \
+  -x :samples:contacturi:build \
+  -x :samples:gallery:build \
+  -x :samples:imgur:build \
+  -x :samples:svg:build \
+  --parallel
diff --git a/scripts/update_javadocs.sh b/scripts/update_javadocs.sh
index a8646613b..95238183c 100755
--- a/scripts/update_javadocs.sh
+++ b/scripts/update_javadocs.sh
@@ -1,54 +1,61 @@
 #!/bin/bash
+#
+# Usage: ./scripts/update_javadocs.sh
+#
+# The version name is pulled automatically from gradle.properties.
 set -e
 set -o pipefail
 
 TEMP_DIR="/tmp/tmp_glide_javadoc"
 JAVADOC_GH_PAGES_DIR="javadocs"
 
-if [[ -z "$1" ]]; 
-then
-  echo "You must supply a target version"
-  echo "Usage ./scripts/update_javadocs.sh <400>"
-  exit 1
-fi
+major_version=$(fgrep VERSION_MAJOR gradle.properties | cut -d '=' -f 2)
+minor_version=$(fgrep VERSION_MINOR gradle.properties | cut -d '=' -f 2)
+version="${major_version}${minor_version}0"
+
+echo "Updating javadocs for ${version}"
 
 if [[ $(git status -uno --porcelain) ]];
-then 
+then
   echo "One or more changes, commit or revert first."
   git status -uno --porcelain
   exit 1
 fi
 
 if [ -e "$JAVADOC_GH_PAGES_DIR" ];
-then 
+then
   echo "javadocs directory exists locally, remove first."
   exit 1
 fi
 
-if [[ $(git rev-list master...origin/master --count) -ne 0 ]]; 
-then 
+if [[ $(git rev-list master...origin/master --count) -ne 0 ]];
+then
   echo "Origin and master are not up to date"
   git rev-list master...origin/master --pretty
   exit 1
 fi
-if [[ $(git rev-list gh-pages...origin/gh-pages --count) -ne 0 ]]; 
-then 
+if [[ $(git rev-list gh-pages...origin/gh-pages --count) -ne 0 ]];
+then
   echo "Origin and gh-pages are not up to date"
   git rev-list gh-pages...origin/gh-pages --pretty
   exit 1
 fi
 
 git checkout master
-GIT_COMMIT_SHA="$(git rev-parse HEAD)"   
-./gradlew clean releaseJavadocJar javadoc
+GIT_COMMIT_SHA="$(git rev-parse HEAD)"
+./gradlew clean debugJavadocJar javadoc
 rm -rf $TEMP_DIR
 cp -r glide/build/docs/javadoc $TEMP_DIR
+
+# Add the favicon to the javadocs pages.
+find $TEMP_DIR -name '*.html' -exec sed -i '' -e 's#<head>#<head><link rel="apple-touch-icon" sizes="180x180" href="/glide/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/glide/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/glide/favicon-16x16.png"><link rel="manifest" href="/glide/manifest.json">#' {} \;
+
 git checkout gh-pages
-rm -rf "${JAVADOC_GH_PAGES_DIR}/${1}"
-cp -r $TEMP_DIR $JAVADOC_GH_PAGES_DIR/$1
+rm -rf "${JAVADOC_GH_PAGES_DIR}/${version}"
+cp -r $TEMP_DIR $JAVADOC_GH_PAGES_DIR/$version
 rm -rf $TEMP_DIR
-git add "${JAVADOC_GH_PAGES_DIR}/$1" 
-git commit -m "Update javadocs for version $1" -m "Generated from commit on master branch: ${GIT_COMMIT_SHA}"
-echo "Copied javadoc into ${JAVADOC_GH_PAGES_DIR}/${1} and committed"
+git add "${JAVADOC_GH_PAGES_DIR}/$version"
+git commit -m "Update javadocs for version $version" -m "Generated from commit on master branch: ${GIT_COMMIT_SHA}"
+echo "Copied javadoc into ${JAVADOC_GH_PAGES_DIR}/${version} and committed"
 git log -1 --pretty=%B
 echo "Ready to push"
diff --git a/scripts/upload.gradle b/scripts/upload.gradle
index 4b38c3961..8f8d18b7b 100644
--- a/scripts/upload.gradle
+++ b/scripts/upload.gradle
@@ -15,10 +15,12 @@
  *
  *
  * Based on: https://github.com/mcxiaoke/gradle-mvn-push/blob/master/gradle-mvn-push.gradle.
- * Local test with (..._REPOSITORY_URL properties must be full paths):
- * gradlew clean buildArchives uploadArchives --stacktrace --info -PSNAPSHOT_REPOSITORY_URL=file://p:\projects\contrib\github-glide\repo-snapshot -PRELEASE_REPOSITORY_URL=file://p:\projects\contrib\github-glide\repo-release
- * For faster runs add: -x check
- * 
+ *
+ * To install in a local maven repo:
+ * 1. In the project you want to test (not Glide), add mavenLocal() to the repositories list.
+ * 2. In Glide, run: ./gradlew uploadArchives -PLOCAL
+ *
+ * For faster runs add: -x check when building Glide.
  */
 
 apply plugin: 'maven'
@@ -27,17 +29,24 @@ apply plugin: 'signing'
 version = VERSION_NAME
 group = GROUP
 
+static def localMavenRepo() {
+    'file://' + new File(System.getProperty('user.home'), '.m2/repository').absolutePath
+}
+
+@SuppressWarnings("GrMethodMayBeStatic")
 def isReleaseBuild() {
-    return VERSION_NAME.contains("SNAPSHOT") == false
+    return !VERSION_NAME.contains("SNAPSHOT")
 }
 
 def getReleaseRepositoryUrl() {
-    return hasProperty('RELEASE_REPOSITORY_URL') ? RELEASE_REPOSITORY_URL
+    return hasProperty('LOCAL') ? localMavenRepo()
+            : hasProperty('RELEASE_REPOSITORY_URL') ? RELEASE_REPOSITORY_URL
             : 'https://oss.sonatype.org/service/local/staging/deploy/maven2/'
 }
 
 def getSnapshotRepositoryUrl() {
-    return hasProperty('SNAPSHOT_REPOSITORY_URL') ? SNAPSHOT_REPOSITORY_URL
+    return hasProperty('LOCAL') ? localMavenRepo()
+            : hasProperty('SNAPSHOT_REPOSITORY_URL') ? SNAPSHOT_REPOSITORY_URL
             : 'https://oss.sonatype.org/content/repositories/snapshots/'
 }
 
@@ -50,6 +59,7 @@ def getRepositoryPassword() {
 }
 
 afterEvaluate { project ->
+    def isAndroidProject = project.plugins.hasPlugin('com.android.application') || project.plugins.hasPlugin('com.android.library')
     // To avoid uploading the default empty jar artifact in the project root directory, we use a custom
     // configuration to specify which artifacts we want to upload.
     uploadArchives {
@@ -73,9 +83,40 @@ afterEvaluate { project ->
                     authentication(userName: getRepositoryUsername(), password: getRepositoryPassword())
                 }
 
+                pom.whenConfigured { pom ->
+                    pom.packaging = POM_PACKAGING
+                }
+
+                // Dependencies are only automatically included by the release plugin if the release
+                // variant is built. Since we've disabled the release variant to improve build
+                // times, we need to add the dependencies to the pom file explicitly.
+                if (isAndroidProject) {
+                    pom.withXml {
+                        def dependenciesNode = asNode().appendNode('dependencies')
+
+                        project.configurations.implementation.allDependencies.each {
+                            def groupId = it.group
+                            def artifactId = it.name
+                            // If we specify an artifact id that differs from the project name, it won't
+                            // match. To avoid that, we look up the artifact id (and group) by property
+                            // for any project dependencies.
+                            // TODO: there must be a neater way to do this.
+                            if (it instanceof ProjectDependency) {
+                                def properties = it.getDependencyProject().getProperties()
+                                groupId = properties.get("GROUP")
+                                artifactId = properties.get("POM_ARTIFACT_ID")
+                            }
+                            def dependencyNode = dependenciesNode.appendNode('dependency')
+                            dependencyNode.appendNode('groupId', groupId)
+                            dependencyNode.appendNode('artifactId', artifactId)
+                            dependencyNode.appendNode('version', it.version)
+                            dependencyNode.appendNode('scope', 'compile')
+                        }
+                    }
+                }
+
                 pom.project {
                     name = POM_NAME
-                    packaging = POM_PACKAGING
                     description = POM_DESCRIPTION
                     url = POM_URL
 
@@ -115,32 +156,29 @@ afterEvaluate { project ->
         sign configurations.archives
     }
 
-    def isAndroidProject = project.plugins.hasPlugin('com.android.application') || project.plugins.hasPlugin('com.android.library')
 
     if (isAndroidProject) {
-        def releaseVariants = project.android.libraryVariants.findAll {
-            it.buildType.name.equalsIgnoreCase('release')
+        def variants = project.android.libraryVariants.findAll {
+            it.buildType.name.equalsIgnoreCase('debug')
         }
 
-        def getAndroidCompileSdkVersion = project.android.compileSdkVersion
-
         def getAndroidSdkDirectory = project.android.sdkDirectory
 
-        def getAndroidJar = "${getAndroidSdkDirectory}/platforms/${getAndroidCompileSdkVersion}/android.jar"
-
-        def getSupportJar = "${getAndroidSdkDirectory}/extras/android/support/v4/android-support-v4.jar"
-
-        task androidJavadocs(type: Javadoc, dependsOn: assembleRelease) {
-            source = releaseVariants.collect { it.javaCompile.source }
-            classpath = files(releaseVariants.collect {
-                files(it.javaCompile.classpath.files, getAndroidJar, getSupportJar)
-            })
-            classpath += files("${project.projectDir}/build/intermediates/classes/release")
+        def getAndroidJar = "${getAndroidSdkDirectory}/platforms/${project.android.compileSdkVersion}/android.jar"
 
+        task androidJavadocs(type: Javadoc, dependsOn: assembleDebug) {
+            source = variants.collect { it.javaCompile.source }
+            classpath = files(
+                    getAndroidJar,
+                    project.file("build/intermediates/classes/debug")
+            )
+            doFirst {
+                classpath += files(variants.collect { it.javaCompile.classpath.files })
+            }
             options {
                 links("http://docs.oracle.com/javase/7/docs/api/")
                 linksOffline("http://d.android.com/reference",
-                    "${getAndroidSdkDirectory}/docs/reference")
+                        "${getAndroidSdkDirectory}/docs/reference")
             }
 
             exclude '**/BuildConfig.java'
@@ -164,8 +202,8 @@ afterEvaluate { project ->
             baseName "${JAR_PREFIX}${project.name}${JAR_POSTFIX}"
         }
 
-        task androidLibraryJar(type: Jar, dependsOn: compileReleaseJavaWithJavac /* == variant.javaCompile */) {
-            from compileReleaseJavaWithJavac.destinationDir
+        task androidLibraryJar(type: Jar, dependsOn: compileDebugJavaWithJavac /* == variant.javaCompile */) {
+            from compileDebugJavaWithJavac.destinationDir
             exclude '**/R.class'
             exclude '**/BuildConfig.class'
             exclude '**/R$*.class'
@@ -176,6 +214,11 @@ afterEvaluate { project ->
             archives androidLibraryJar
             archives androidSourcesJar
             archives androidJavadocsJar
+            // This is unnecessary with a release variant because by default the release variant
+            // includes the release aar in archives. Since we've disabled our release variants and
+            // want to include an aar, we need to manually specify the task that produces the aar
+            // here.
+            archives project.tasks.bundleDebug
         }
     } else if (project.plugins.hasPlugin('java')) {
         task sourcesJar(type: Jar, dependsOn: classes) {
@@ -194,5 +237,5 @@ afterEvaluate { project ->
         }
     }
     logger.info("Published artifacts in ${configurations.archives}:")
-    configurations.archives.artifacts.files.files.each { logger.info("\t$it"); }
+    configurations.archives.artifacts.files.files.each { logger.info("\t$it") }
 }
diff --git a/settings.gradle b/settings.gradle
index 20c2b4430..464936b4e 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -2,8 +2,13 @@ exec {
     commandLine "git", "submodule", "update", "--init", "--recursive"
 }
 include ':library'
+include ':library:pmd'
+include ':library:findbugs'
+include ':library:test'
+include ':instrumentation'
 include ':annotation'
 include ':annotation:compiler'
+include ':annotation:compiler:test'
 include ':glide'
 include ':third_party:gif_decoder'
 include ':third_party:disklrucache'
diff --git a/testutil/src/main/java/com/bumptech/glide/testutil/TestUtil.java b/testutil/src/main/java/com/bumptech/glide/testutil/TestUtil.java
index 9c93de9e5..f39342c94 100644
--- a/testutil/src/main/java/com/bumptech/glide/testutil/TestUtil.java
+++ b/testutil/src/main/java/com/bumptech/glide/testutil/TestUtil.java
@@ -9,6 +9,8 @@
 /**
  * Shared utility classes for tests.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public final class TestUtil {
   private TestUtil() {
     // Utility class.
diff --git a/third_party/gif_decoder/build.gradle b/third_party/gif_decoder/build.gradle
index a19bcda5f..301fd7c7e 100644
--- a/third_party/gif_decoder/build.gradle
+++ b/third_party/gif_decoder/build.gradle
@@ -1,19 +1,18 @@
 apply plugin: 'com.android.library'
 
 dependencies {
-    compile "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}"
+    implementation "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}"
 
-    testCompile project(':testutil')
-    testCompile "com.android.support:support-v4:${ANDROID_SUPPORT_VERSION}"
-    testCompile "com.google.truth:truth:${TRUTH_VERSION}"
-    testCompile "junit:junit:${JUNIT_VERSION}"
-    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}"
-    testCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
+    testImplementation project(':testutil')
+    testImplementation "com.android.support:support-v4:${ANDROID_SUPPORT_VERSION}"
+    testImplementation "com.google.truth:truth:${TRUTH_VERSION}"
+    testImplementation "junit:junit:${JUNIT_VERSION}"
+    testImplementation "org.mockito:mockito-core:${MOCKITO_VERSION}"
+    testImplementation "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         minSdkVersion MIN_SDK_VERSION as int
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
index 257cd98f0..8aeaa634d 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
@@ -3,6 +3,7 @@
 import android.graphics.Bitmap;
 import android.support.annotation.IntDef;
 import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import java.io.InputStream;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -12,6 +13,7 @@
  * Shared interface for GIF decoders.
  */
 public interface GifDecoder {
+
   /** File read status: No errors. */
   int STATUS_OK = 0;
   /** File read status: Error decoding file (may be partially decoded). */
@@ -33,7 +35,7 @@
    * An interface that can be used to provide reused {@link android.graphics.Bitmap}s to avoid GCs
    * from constantly allocating {@link android.graphics.Bitmap}s for every frame.
    */
-  public interface BitmapProvider {
+  interface BitmapProvider {
     /**
      * Returns an {@link Bitmap} with exactly the given dimensions and config.
      *
@@ -43,40 +45,43 @@
      *               android.graphics.Bitmap}.
      */
     @NonNull
-    Bitmap obtain(int width, int height, Bitmap.Config config);
+    Bitmap obtain(int width, int height, @NonNull Bitmap.Config config);
 
     /**
      * Releases the given Bitmap back to the pool.
      */
-    void release(Bitmap bitmap);
+    void release(@NonNull Bitmap bitmap);
 
     /**
      * Returns a byte array used for decoding and generating the frame bitmap.
      *
      * @param size the size of the byte array to obtain
      */
+    @NonNull
     byte[] obtainByteArray(int size);
 
     /**
      * Releases the given byte array back to the pool.
      */
-    void release(byte[] bytes);
+    void release(@NonNull byte[] bytes);
 
     /**
      * Returns an int array used for decoding/generating the frame bitmaps.
      */
+    @NonNull
     int[] obtainIntArray(int size);
 
     /**
      * Release the given array back to the pool.
      */
-    void release(int[] array);
+    void release(@NonNull int[] array);
   }
 
   int getWidth();
 
   int getHeight();
 
+  @NonNull
   ByteBuffer getData();
 
   /**
@@ -188,6 +193,7 @@
    *
    * @return Bitmap representation of frame.
    */
+  @Nullable
   Bitmap getNextFrame();
 
   /**
@@ -197,15 +203,15 @@
    * @return read status code (0 = no errors).
    */
   @GifDecodeStatus
-  int read(InputStream is, int contentLength);
+  int read(@Nullable InputStream is, int contentLength);
 
   void clear();
 
-  void setData(GifHeader header, byte[] data);
+  void setData(@NonNull GifHeader header, @NonNull byte[] data);
 
-  void setData(GifHeader header, ByteBuffer buffer);
+  void setData(@NonNull GifHeader header, @NonNull ByteBuffer buffer);
 
-  void setData(GifHeader header, ByteBuffer buffer, int sampleSize);
+  void setData(@NonNull GifHeader header, @NonNull ByteBuffer buffer, int sampleSize);
 
   /**
    * Reads GIF image from byte array.
@@ -214,6 +220,23 @@
    * @return read status code (0 = no errors).
    */
   @GifDecodeStatus
-  int read(byte[] data);
+  int read(@Nullable byte[] data);
 
+
+  /**
+   * Sets the default {@link android.graphics.Bitmap.Config} to use when decoding frames of a GIF.
+   *
+   * <p>Valid options are {@link android.graphics.Bitmap.Config#ARGB_8888} and
+   * {@link android.graphics.Bitmap.Config#RGB_565}.
+   * {@link android.graphics.Bitmap.Config#ARGB_8888} will produce higher quality frames, but will
+   * also use 2x the memory of {@link android.graphics.Bitmap.Config#RGB_565}.
+   *
+   * <p>Defaults to {@link android.graphics.Bitmap.Config#ARGB_8888}
+   *
+   * <p>This value is not a guarantee. For example if set to
+   * {@link android.graphics.Bitmap.Config#RGB_565} and the GIF contains transparent pixels,
+   * {@link android.graphics.Bitmap.Config#ARGB_8888} will be used anyway to support the
+   * transparency.
+   */
+  void setDefaultBitmapConfig(@NonNull Bitmap.Config format);
 }
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifFrame.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifFrame.java
index 0a26cb756..a4d980d3e 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifFrame.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifFrame.java
@@ -16,26 +16,26 @@
    * <p><b>GIF89a</b>: <i>No disposal specified.
    * The decoder is not required to take any action.</i></p>
    */
-  public static final int DISPOSAL_UNSPECIFIED = 0;
+  static final int DISPOSAL_UNSPECIFIED = 0;
   /**
    * GIF Disposal Method meaning leave canvas from previous frame.
    * <p><b>GIF89a</b>: <i>Do not dispose.
    * The graphic is to be left in place.</i></p>
    */
-  public static final int DISPOSAL_NONE = 1;
+  static final int DISPOSAL_NONE = 1;
   /**
    * GIF Disposal Method meaning clear canvas to background color.
    * <p><b>GIF89a</b>: <i>Restore to background color.
    * The area used by the graphic must be restored to the background color.</i></p>
    */
-  public static final int DISPOSAL_BACKGROUND = 2;
+  static final int DISPOSAL_BACKGROUND = 2;
   /**
    * GIF Disposal Method meaning clear canvas to frame before last.
    * <p><b>GIF89a</b>: <i>Restore to previous.
    * The decoder is required to restore the area overwritten by the graphic
    * with what was there prior to rendering the graphic.</i></p>
    */
-  public static final int DISPOSAL_PREVIOUS = 3;
+  static final int DISPOSAL_PREVIOUS = 3;
 
   /**
    * <p><b>GIF89a</b>:
@@ -49,7 +49,7 @@
    */
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(value = {DISPOSAL_UNSPECIFIED, DISPOSAL_NONE, DISPOSAL_BACKGROUND, DISPOSAL_PREVIOUS})
-  @interface GifDisposalMethod {
+  private @interface GifDisposalMethod {
   }
 
   int ix, iy, iw, ih;
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java
index d43f7cca7..7a60b5f46 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java
@@ -26,7 +26,7 @@
   int frameCount = 0;
 
   GifFrame currentFrame;
-  List<GifFrame> frames = new ArrayList<>();
+  final List<GifFrame> frames = new ArrayList<>();
   /** Logical screen size: Full image width. */
   int width;
   /** Logical screen size: Full image height. */
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java
index 05662c04e..47f6e25df 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java
@@ -4,6 +4,8 @@
 import static com.bumptech.glide.gifdecoder.GifFrame.DISPOSAL_NONE;
 import static com.bumptech.glide.gifdecoder.GifFrame.DISPOSAL_UNSPECIFIED;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.util.Log;
 import java.nio.BufferUnderflowException;
 import java.nio.ByteBuffer;
@@ -17,7 +19,7 @@
  * @see <a href="https://www.w3.org/Graphics/GIF/spec-gif89a.txt">GIF 89a Specification</a>
  */
 public class GifHeaderParser {
-  public static final String TAG = "GifHeaderParser";
+  private static final String TAG = "GifHeaderParser";
 
   private static final int MASK_INT_LOWEST_BYTE = 0x000000FF;
 
@@ -35,7 +37,6 @@
 
   // Graphic Control Extension packed field masks
 
-  private static final int GCE_MASK_RESERVED_BITS = 0b11100000;
   /**
    * Mask (bits 4-2) to extract Disposal Method of the current frame.
    *
@@ -46,7 +47,6 @@
    * Shift so the Disposal Method extracted from the packed value is on the least significant bit.
    */
   private static final int GCE_DISPOSAL_METHOD_SHIFT = 2;
-  private static final int GCE_MASK_USER_INPUT_FLAG = 0b00000010;
   /**
    * Mask (bit 0) to extract Transparent Color Flag of the current frame.
    * <p><b>GIF89a</b>: <i>Indicates whether a transparency index is given
@@ -76,8 +76,6 @@
    * </ul>
    */
   private static final int DESCRIPTOR_MASK_INTERLACE_FLAG = 0b01000000;
-  private static final int DESCRIPTOR_MASK_SORT_FLAG = 0b00100000;
-  private static final int DESCRIPTOR_MASK_RESERVED = 0b00011000;
   /**
    * Mask (bits 2-0) to extract Size of the Local Color Table of the current image.
    * <p><b>GIF89a</b>: <i>If the Local Color Table Flag is set to 1, the value in this
@@ -100,8 +98,6 @@
    * </ul>
    */
   private static final int LSD_MASK_GCT_FLAG = 0b10000000;
-  private static final int LSD_MASK_COLOR_RESOLUTION = 0b01110000;
-  private static final int LSD_MASK_SORT_FLAG = 0b00001000;
   /**
    * Mask (bits 2-0) to extract Size of the Global Color Table of the current image.
    * <p><b>GIF89a</b>: <i>If the Global Color Table Flag is set to 1, the value in this
@@ -128,7 +124,7 @@
   private GifHeader header;
   private int blockSize = 0;
 
-  public GifHeaderParser setData(ByteBuffer data) {
+  public GifHeaderParser setData(@NonNull ByteBuffer data) {
     reset();
     rawData = data.asReadOnlyBuffer();
     rawData.position(0);
@@ -136,7 +132,7 @@ public GifHeaderParser setData(ByteBuffer data) {
     return this;
   }
 
-  public GifHeaderParser setData(byte[] data) {
+  public GifHeaderParser setData(@Nullable byte[] data) {
     if (data != null) {
       setData(ByteBuffer.wrap(data));
     } else {
@@ -158,6 +154,7 @@ private void reset() {
     blockSize = 0;
   }
 
+  @NonNull
   public GifHeader parseHeader() {
     if (rawData == null) {
       throw new IllegalStateException("You must call setData() before parseHeader()");
@@ -225,11 +222,11 @@ private void readContents(int maxFrames) {
               break;
             case LABEL_APPLICATION_EXTENSION:
               readBlock();
-              String app = "";
+              StringBuilder app = new StringBuilder();
               for (int i = 0; i < 11; i++) {
-                app += (char) block[i];
+                app.append((char) block[i]);
               }
-              if (app.equals("NETSCAPE2.0")) {
+              if (app.toString().equals("NETSCAPE2.0")) {
                 readNetscapeExt();
               } else {
                 // Don't care.
@@ -366,11 +363,11 @@ private void readNetscapeExt() {
    * Reads GIF file header information.
    */
   private void readHeader() {
-    String id = "";
+    StringBuilder id = new StringBuilder();
     for (int i = 0; i < 6; i++) {
-      id += (char) read();
+      id.append((char) read());
     }
-    if (!id.startsWith("GIF")) {
+    if (!id.toString().startsWith("GIF")) {
       header.status = STATUS_FORMAT_ERROR;
       return;
     }
@@ -414,6 +411,7 @@ private void readLSD() {
    * @param nColors int number of colors to read.
    * @return int array containing 256 colors (packed ARGB with full alpha).
    */
+  @Nullable
   private int[] readColorTable(int nColors) {
     int nBytes = 3 * nColors;
     int[] tab = null;
@@ -467,10 +465,8 @@ private void skip() {
 
   /**
    * Reads next variable length block from input.
-   *
-   * @return number of bytes stored in "buffer"
    */
-  private int readBlock() {
+  private void readBlock() {
     blockSize = read();
     int n = 0;
     if (blockSize > 0) {
@@ -490,7 +486,6 @@ private int readBlock() {
         header.status = STATUS_FORMAT_ERROR;
       }
     }
-    return n;
   }
 
   /**
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java
index f0d374ff6..4ce8a73c3 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java
@@ -29,7 +29,9 @@
 import static com.bumptech.glide.gifdecoder.GifFrame.DISPOSAL_UNSPECIFIED;
 
 import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
 import android.support.annotation.ColorInt;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.util.Log;
 import java.io.ByteArrayOutputStream;
@@ -85,21 +87,14 @@
   @ColorInt
   private final int[] pct = new int[256];
 
+  private final GifDecoder.BitmapProvider bitmapProvider;
+
   /** Raw GIF data from input source. */
   private ByteBuffer rawData;
 
   /** Raw data read working array. */
   private byte[] block;
 
-  private static final int WORK_BUFFER_SIZE = 16 * 1024;
-  /**
-   * Temporary buffer for block reading.
-   * Reads 16k chunks from the native buffer for processing, to greatly reduce JNI overhead.
-   */
-  @Nullable private byte[] workBuffer;
-  private int workBufferSize = 0;
-  private int workBufferPosition = 0;
-
   private GifHeaderParser parser;
 
   // LZW decoder working arrays.
@@ -112,7 +107,6 @@
 
   private int framePointer;
   private GifHeader header;
-  private GifDecoder.BitmapProvider bitmapProvider;
   private Bitmap previousImage;
   private boolean savePrevious;
   @GifDecodeStatus
@@ -120,22 +114,27 @@
   private int sampleSize;
   private int downsampledHeight;
   private int downsampledWidth;
-  private boolean isFirstFrameTransparent;
+  @Nullable
+  private Boolean isFirstFrameTransparent;
+  @NonNull
+  private Bitmap.Config bitmapConfig = Config.ARGB_8888;
 
+  // Public API.
+  @SuppressWarnings("unused")
   public StandardGifDecoder(
-      GifDecoder.BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData) {
+      @NonNull GifDecoder.BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData) {
     this(provider, gifHeader, rawData, 1 /*sampleSize*/);
   }
 
   public StandardGifDecoder(
-      GifDecoder.BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData,
+      @NonNull GifDecoder.BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData,
       int sampleSize) {
     this(provider);
     setData(gifHeader, rawData, sampleSize);
   }
 
   public StandardGifDecoder(
-      GifDecoder.BitmapProvider provider) {
+      @NonNull GifDecoder.BitmapProvider provider) {
     this.bitmapProvider = provider;
     header = new GifHeader();
   }
@@ -150,6 +149,7 @@ public int getHeight() {
     return header.height;
   }
 
+  @NonNull
   @Override
   public ByteBuffer getData() {
     return rawData;
@@ -228,6 +228,7 @@ public int getByteSize() {
     return rawData.limit() + mainPixels.length + (mainScratch.length * BYTES_PER_INTEGER);
   }
 
+  @Nullable
   @Override
   public synchronized Bitmap getNextFrame() {
     if (header.frameCount <= 0 || framePointer < 0) {
@@ -247,6 +248,10 @@ public synchronized Bitmap getNextFrame() {
     }
     status = STATUS_OK;
 
+    if (block == null) {
+      block = bitmapProvider.obtainByteArray(255);
+    }
+
     GifFrame currentFrame = header.frames.get(framePointer);
     GifFrame previousFrame = null;
     int previousIndex = framePointer - 1;
@@ -280,7 +285,7 @@ public synchronized Bitmap getNextFrame() {
   }
 
   @Override
-  public int read(InputStream is, int contentLength) {
+  public int read(@Nullable InputStream is, int contentLength) {
     if (is != null) {
       try {
         int capacity = (contentLength > 0) ? (contentLength + 4 * 1024) : 16 * 1024;
@@ -325,27 +330,25 @@ public void clear() {
     }
     previousImage = null;
     rawData = null;
-    isFirstFrameTransparent = false;
+    isFirstFrameTransparent = null;
     if (block != null) {
       bitmapProvider.release(block);
     }
-    if (workBuffer != null) {
-      bitmapProvider.release(workBuffer);
-    }
   }
 
   @Override
-  public synchronized void setData(GifHeader header, byte[] data) {
+  public synchronized void setData(@NonNull GifHeader header, @NonNull byte[] data) {
     setData(header, ByteBuffer.wrap(data));
   }
 
   @Override
-  public synchronized void setData(GifHeader header, ByteBuffer buffer) {
+  public synchronized void setData(@NonNull GifHeader header, @NonNull ByteBuffer buffer) {
     setData(header, buffer, 1);
   }
 
   @Override
-  public synchronized void setData(GifHeader header, ByteBuffer buffer, int sampleSize) {
+  public synchronized void setData(@NonNull GifHeader header, @NonNull ByteBuffer buffer,
+      int sampleSize) {
     if (sampleSize <= 0) {
       throw new IllegalArgumentException("Sample size must be >=0, not: " + sampleSize);
     }
@@ -353,7 +356,6 @@ public synchronized void setData(GifHeader header, ByteBuffer buffer, int sample
     sampleSize = Integer.highestOneBit(sampleSize);
     this.status = STATUS_OK;
     this.header = header;
-    isFirstFrameTransparent = false;
     framePointer = INITIAL_FRAME_POINTER;
     // Initialize the raw data buffer.
     rawData = buffer.asReadOnlyBuffer();
@@ -378,6 +380,7 @@ public synchronized void setData(GifHeader header, ByteBuffer buffer, int sample
     mainScratch = bitmapProvider.obtainIntArray(downsampledWidth * downsampledHeight);
   }
 
+  @NonNull
   private GifHeaderParser getHeaderParser() {
     if (parser == null) {
       parser = new GifHeaderParser();
@@ -387,7 +390,7 @@ private GifHeaderParser getHeaderParser() {
 
   @Override
   @GifDecodeStatus
-  public synchronized int read(byte[] data) {
+  public synchronized int read(@Nullable byte[] data) {
     this.header = getHeaderParser().setData(data).parseHeader();
     if (data != null) {
       setData(header, data);
@@ -396,6 +399,16 @@ public synchronized int read(byte[] data) {
     return status;
   }
 
+  @Override
+  public void setDefaultBitmapConfig(@NonNull Bitmap.Config config) {
+    if (config != Bitmap.Config.ARGB_8888 && config != Bitmap.Config.RGB_565) {
+      throw new IllegalArgumentException("Unsupported format: " + config
+          + ", must be one of " + Bitmap.Config.ARGB_8888 + " or " + Bitmap.Config.RGB_565);
+    }
+
+    bitmapConfig = config;
+  }
+
   /**
    * Creates new frame image from current data (and previous frames as specified by their
    * disposition codes).
@@ -404,8 +417,20 @@ private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {
     // Final location of blended pixels.
     final int[] dest = mainScratch;
 
-    // clear all pixels when meet first frame
+    // clear all pixels when meet first frame and drop prev image from last loop
     if (previousFrame == null) {
+      if (previousImage != null) {
+        bitmapProvider.release(previousImage);
+      }
+      previousImage = null;
+      Arrays.fill(dest, COLOR_TRANSPARENT_BLACK);
+    }
+
+    // clear all pixels when dispose is 3 but previousImage is null.
+    // When DISPOSAL_PREVIOUS and previousImage didn't be set, new frame should draw on
+    // a empty image
+    if (previousFrame != null && previousFrame.dispose == DISPOSAL_PREVIOUS
+            && previousImage == null) {
       Arrays.fill(dest, COLOR_TRANSPARENT_BLACK);
     }
 
@@ -450,6 +475,76 @@ private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {
     // Decode pixels for this frame into the global pixels[] scratch.
     decodeBitmapData(currentFrame);
 
+    if (currentFrame.interlace || sampleSize != 1) {
+      copyCopyIntoScratchRobust(currentFrame);
+    } else {
+      copyIntoScratchFast(currentFrame);
+    }
+
+    // Copy pixels into previous image
+    if (savePrevious && (currentFrame.dispose == DISPOSAL_UNSPECIFIED
+        || currentFrame.dispose == DISPOSAL_NONE)) {
+      if (previousImage == null) {
+        previousImage = getNextBitmap();
+      }
+      previousImage.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth,
+          downsampledHeight);
+    }
+
+    // Set pixels for current image.
+    Bitmap result = getNextBitmap();
+    result.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth, downsampledHeight);
+    return result;
+  }
+
+  private void copyIntoScratchFast(GifFrame currentFrame) {
+    int[] dest = mainScratch;
+    int downsampledIH = currentFrame.ih;
+    int downsampledIY = currentFrame.iy;
+    int downsampledIW = currentFrame.iw;
+    int downsampledIX = currentFrame.ix;
+    // Copy each source line to the appropriate place in the destination.
+    boolean isFirstFrame = framePointer == 0;
+    int width = this.downsampledWidth;
+    byte[] mainPixels = this.mainPixels;
+    int[] act = this.act;
+    byte transparentColorIndex = -1;
+    for (int i = 0; i < downsampledIH; i++) {
+      int line = i + downsampledIY;
+      int k = line * width;
+      // Start of line in dest.
+      int dx = k + downsampledIX;
+      // End of dest line.
+      int dlim = dx + downsampledIW;
+      if (k + width < dlim) {
+        // Past dest edge.
+        dlim = k + width;
+      }
+      // Start of line in source.
+      int sx = i * currentFrame.iw;
+
+      while (dx < dlim) {
+        byte byteCurrentColorIndex = mainPixels[sx];
+        int currentColorIndex = ((int) byteCurrentColorIndex) & MASK_INT_LOWEST_BYTE;
+        if (currentColorIndex != transparentColorIndex) {
+          int color = act[currentColorIndex];
+          if (color != COLOR_TRANSPARENT_BLACK) {
+            dest[dx] = color;
+          } else {
+            transparentColorIndex = byteCurrentColorIndex;
+          }
+        }
+        ++sx;
+        ++dx;
+      }
+    }
+
+    isFirstFrameTransparent =
+        isFirstFrameTransparent == null && isFirstFrame && transparentColorIndex != -1;
+  }
+
+  private void copyCopyIntoScratchRobust(GifFrame currentFrame) {
+    int[] dest = mainScratch;
     int downsampledIH = currentFrame.ih / sampleSize;
     int downsampledIY = currentFrame.iy / sampleSize;
     int downsampledIW = currentFrame.iw / sampleSize;
@@ -459,6 +554,13 @@ private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {
     int inc = 8;
     int iline = 0;
     boolean isFirstFrame = framePointer == 0;
+    int sampleSize = this.sampleSize;
+    int downsampledWidth = this.downsampledWidth;
+    int downsampledHeight = this.downsampledHeight;
+    byte[] mainPixels = this.mainPixels;
+    int[] act = this.act;
+    @Nullable
+    Boolean isFirstFrameTransparent = this.isFirstFrameTransparent;
     for (int i = 0; i < downsampledIH; i++) {
       int line = i;
       if (currentFrame.interlace) {
@@ -484,6 +586,7 @@ private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {
         iline += inc;
       }
       line += downsampledIY;
+      boolean isNotDownsampling = sampleSize == 1;
       if (line < downsampledHeight) {
         int k = line * downsampledWidth;
         // Start of line in dest.
@@ -496,43 +599,43 @@ private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {
         }
         // Start of line in source.
         int sx = i * sampleSize * currentFrame.iw;
-        int maxPositionInSource = sx + ((dlim - dx) * sampleSize);
-        while (dx < dlim) {
-          // Map color and insert in destination.
-          @ColorInt int averageColor;
-          if (sampleSize == 1) {
+        if (isNotDownsampling) {
+          int averageColor;
+          while (dx < dlim) {
             int currentColorIndex = ((int) mainPixels[sx]) & MASK_INT_LOWEST_BYTE;
             averageColor = act[currentColorIndex];
-          } else {
+            if (averageColor != COLOR_TRANSPARENT_BLACK) {
+              dest[dx] = averageColor;
+            } else if (isFirstFrame && isFirstFrameTransparent == null) {
+              isFirstFrameTransparent = true;
+            }
+            sx += sampleSize;
+            dx++;
+          }
+        } else {
+          int averageColor;
+          int maxPositionInSource = sx + ((dlim - dx) * sampleSize);
+          while (dx < dlim) {
+            // Map color and insert in destination.
             // TODO: This is substantially slower (up to 50ms per frame) than just grabbing the
             // current color index above, even with a sample size of 1.
             averageColor = averageColorsNear(sx, maxPositionInSource, currentFrame.iw);
+            if (averageColor != COLOR_TRANSPARENT_BLACK) {
+              dest[dx] = averageColor;
+            } else if (isFirstFrame && isFirstFrameTransparent == null) {
+              isFirstFrameTransparent = true;
+            }
+            sx += sampleSize;
+            dx++;
           }
-          if (averageColor != COLOR_TRANSPARENT_BLACK) {
-            dest[dx] = averageColor;
-          } else if (!isFirstFrameTransparent && isFirstFrame) {
-            isFirstFrameTransparent = true;
-          }
-          sx += sampleSize;
-          dx++;
         }
       }
     }
 
-    // Copy pixels into previous image
-    if (savePrevious && (currentFrame.dispose == DISPOSAL_UNSPECIFIED
-        || currentFrame.dispose == DISPOSAL_NONE)) {
-      if (previousImage == null) {
-        previousImage = getNextBitmap();
-      }
-      previousImage.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth,
-          downsampledHeight);
+    if (this.isFirstFrameTransparent == null) {
+      this.isFirstFrameTransparent = isFirstFrameTransparent == null
+          ? false : isFirstFrameTransparent;
     }
-
-    // Set pixels for current image.
-    Bitmap result = getNextBitmap();
-    result.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth, downsampledHeight);
-    return result;
   }
 
   @ColorInt
@@ -586,8 +689,6 @@ private int averageColorsNear(int positionInMainPixels, int maxPositionInMainPix
    * Decodes LZW image data into pixel array. Adapted from John Cristy's BitmapMagick.
    */
   private void decodeBitmapData(GifFrame frame) {
-    workBufferSize = 0;
-    workBufferPosition = 0;
     if (frame != null) {
       // Jump to the frame start position.
       rawData.position(frame.bufferFrameStart);
@@ -601,15 +702,19 @@ private void decodeBitmapData(GifFrame frame) {
       // Allocate new pixel array.
       mainPixels = bitmapProvider.obtainByteArray(npix);
     }
+    byte[] mainPixels = this.mainPixels;
     if (prefix == null) {
       prefix = new short[MAX_STACK_SIZE];
     }
+    short[] prefix = this.prefix;
     if (suffix == null) {
       suffix = new byte[MAX_STACK_SIZE];
     }
+    byte[] suffix = this.suffix;
     if (pixelStack == null) {
       pixelStack = new byte[MAX_STACK_SIZE + 1];
     }
+    byte[] pixelStack = this.pixelStack;
 
     // Initialize GIF data stream decoder.
     dataSize = readByte();
@@ -619,18 +724,18 @@ private void decodeBitmapData(GifFrame frame) {
     oldCode = NULL_CODE;
     codeSize = dataSize + 1;
     codeMask = (1 << codeSize) - 1;
+
     for (code = 0; code < clear; code++) {
       // XXX ArrayIndexOutOfBoundsException.
       prefix[code] = 0;
       suffix[code] = (byte) code;
     }
-
+    byte[] block = this.block;
     // Decode GIF pixel stream.
-    datum = bits = count = first = top = pi = bi = 0;
-    for (i = 0; i < npix; ) {
-      // Load bytes until there are enough bits for a code.
+    i = datum = bits = count = first = top = pi = bi = 0;
+    while (i < npix) {
+      // Read a new data block.
       if (count == 0) {
-        // Read a new data block.
         count = readBlock();
         if (count <= 0) {
           status = STATUS_PARTIAL_DECODE;
@@ -641,8 +746,8 @@ private void decodeBitmapData(GifFrame frame) {
 
       datum += (((int) block[bi]) & MASK_INT_LOWEST_BYTE) << bits;
       bits += 8;
-      bi++;
-      count--;
+      ++bi;
+      --count;
 
       while (bits >= codeSize) {
         // Get the next code.
@@ -658,87 +763,64 @@ private void decodeBitmapData(GifFrame frame) {
           available = clear + 2;
           oldCode = NULL_CODE;
           continue;
-        }
-
-        if (code > available) {
-          status = STATUS_PARTIAL_DECODE;
+        } else if (code == endOfInformation) {
           break;
-        }
-
-        if (code == endOfInformation) {
-          break;
-        }
-
-        if (oldCode == NULL_CODE) {
-          pixelStack[top++] = suffix[code];
+        } else if (oldCode == NULL_CODE) {
+          pixelStack[top] = suffix[code];
+          ++top;
           oldCode = code;
           first = code;
           continue;
         }
+
         inCode = code;
         if (code >= available) {
-          pixelStack[top++] = (byte) first;
+          pixelStack[top] = (byte) first;
+          ++top;
           code = oldCode;
         }
+
         while (code >= clear) {
-          pixelStack[top++] = suffix[code];
+          pixelStack[top] = suffix[code];
+          ++top;
           code = prefix[code];
         }
         first = ((int) suffix[code]) & MASK_INT_LOWEST_BYTE;
-        pixelStack[top++] = (byte) first;
+
+        mainPixels[pi] = (byte) first;
+        ++pi;
+        ++i;
+
+        while (top > 0) {
+          // Pop a pixel off the pixel stack.
+          mainPixels[pi] = pixelStack[--top];
+          ++pi;
+          ++i;
+        }
 
         // Add a new string to the string table.
         if (available < MAX_STACK_SIZE) {
           prefix[available] = (short) oldCode;
           suffix[available] = (byte) first;
-          available++;
+          ++available;
           if (((available & codeMask) == 0) && (available < MAX_STACK_SIZE)) {
-            codeSize++;
+            ++codeSize;
             codeMask += available;
           }
         }
         oldCode = inCode;
-
-        while (top > 0) {
-          // Pop a pixel off the pixel stack.
-          mainPixels[pi++] = pixelStack[--top];
-          i++;
-        }
       }
     }
 
     // Clear missing pixels.
-    for (i = pi; i < npix; i++) {
-      mainPixels[i] = COLOR_TRANSPARENT_BLACK;
-    }
-  }
-
-  /**
-   * Reads the next chunk for the intermediate work buffer.
-   */
-  private void readChunkIfNeeded() {
-    if (workBufferSize > workBufferPosition) {
-      return;
-    }
-    if (workBuffer == null) {
-      workBuffer = bitmapProvider.obtainByteArray(WORK_BUFFER_SIZE);
-    }
-    workBufferPosition = 0;
-    workBufferSize = Math.min(rawData.remaining(), WORK_BUFFER_SIZE);
-    rawData.get(workBuffer, 0, workBufferSize);
+    Arrays.fill(mainPixels, pi, npix, (byte) COLOR_TRANSPARENT_BLACK);
   }
 
   /**
    * Reads a single byte from the input stream.
    */
   private int readByte() {
-    try {
-      readChunkIfNeeded();
-      return workBuffer[workBufferPosition++] & MASK_INT_LOWEST_BYTE;
-    } catch (Exception e) {
-      status = STATUS_FORMAT_ERROR;
-      return 0;
-    }
+    return rawData.get() & MASK_INT_LOWEST_BYTE;
   }
 
   /**
@@ -748,38 +830,16 @@ private int readByte() {
    */
   private int readBlock() {
     int blockSize = readByte();
-    if (blockSize > 0) {
-      try {
-        if (block == null) {
-          block = bitmapProvider.obtainByteArray(255);
-        }
-        final int remaining = workBufferSize - workBufferPosition;
-        if (remaining >= blockSize) {
-          // Block can be read from the current work buffer.
-          System.arraycopy(workBuffer, workBufferPosition, block, 0, blockSize);
-          workBufferPosition += blockSize;
-        } else if (rawData.remaining() + remaining >= blockSize) {
-          // Block can be read in two passes.
-          System.arraycopy(workBuffer, workBufferPosition, block, 0, remaining);
-          workBufferPosition = workBufferSize;
-          readChunkIfNeeded();
-          final int secondHalfRemaining = blockSize - remaining;
-          System.arraycopy(workBuffer, 0, block, remaining, secondHalfRemaining);
-          workBufferPosition += secondHalfRemaining;
-        } else {
-          status = STATUS_FORMAT_ERROR;
-        }
-      } catch (Exception e) {
-        Log.w(TAG, "Error Reading Block", e);
-        status = STATUS_FORMAT_ERROR;
-      }
+    if (blockSize <= 0) {
+      return blockSize;
     }
+    rawData.get(block, 0, Math.min(blockSize, rawData.remaining()));
     return blockSize;
   }
 
   private Bitmap getNextBitmap() {
-    Bitmap.Config config = isFirstFrameTransparent
-        ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
+    Bitmap.Config config = isFirstFrameTransparent == null || isFirstFrameTransparent
+        ? Bitmap.Config.ARGB_8888 : bitmapConfig;
     Bitmap result = bitmapProvider.obtain(downsampledWidth, downsampledHeight, config);
     result.setHasAlpha(true);
     return result;
diff --git a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
index 13a581303..cc25027e0 100644
--- a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
+++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
@@ -197,27 +197,29 @@ public Bitmap obtain(int width, int height, Bitmap.Config config) {
     }
 
     @Override
-    public void release(Bitmap bitmap) {
+    public void release(@NonNull Bitmap bitmap) {
       // Do nothing.
     }
 
+    @NonNull
     @Override
     public byte[] obtainByteArray(int size) {
       return new byte[size];
     }
 
     @Override
-    public void release(byte[] bytes) {
+    public void release(@NonNull byte[] bytes) {
       // Do nothing.
     }
 
+    @NonNull
     @Override
     public int[] obtainIntArray(int size) {
       return new int[size];
     }
 
     @Override
-    public void release(int[] array) {
+    public void release(@NonNull int[] array) {
       // Do Nothing
     }
 
diff --git a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
index 55dfa41a4..8fc2efa9e 100644
--- a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
+++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
@@ -122,7 +122,7 @@ public void testCanReadImageDescriptorWithoutGraphicalExtension() {
     final int lzwMinCodeSize = 2;
     ByteBuffer buffer = ByteBuffer.allocate(
         GifBytesTestUtil.HEADER_LENGTH + GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH + GifBytesTestUtil
-            .getImageDataSize(lzwMinCodeSize)).order(ByteOrder.LITTLE_ENDIAN);
+            .getImageDataSize()).order(ByteOrder.LITTLE_ENDIAN);
     GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
     GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0);
     GifBytesTestUtil.writeFakeImageData(buffer, lzwMinCodeSize);
@@ -140,7 +140,7 @@ private static ByteBuffer writeHeaderWithGceAndFrameDelay(short frameDelay) {
     ByteBuffer buffer = ByteBuffer.allocate(
         GifBytesTestUtil.HEADER_LENGTH + GifBytesTestUtil.GRAPHICS_CONTROL_EXTENSION_LENGTH
             + GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH + GifBytesTestUtil
-            .getImageDataSize(lzwMinCodeSize)).order(ByteOrder.LITTLE_ENDIAN);
+            .getImageDataSize()).order(ByteOrder.LITTLE_ENDIAN);
     GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
     GifBytesTestUtil.writeGraphicsControlExtension(buffer, frameDelay);
     GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0);
@@ -204,7 +204,7 @@ public void testSetsFrameLocalColorTableToNullIfNoColorTable() {
     final int lzwMinCodeSize = 2;
     ByteBuffer buffer = ByteBuffer.allocate(
         GifBytesTestUtil.HEADER_LENGTH + GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH + GifBytesTestUtil
-            .getImageDataSize(lzwMinCodeSize)).order(ByteOrder.LITTLE_ENDIAN);
+            .getImageDataSize()).order(ByteOrder.LITTLE_ENDIAN);
     GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
     GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0);
     GifBytesTestUtil.writeFakeImageData(buffer, lzwMinCodeSize);
@@ -224,7 +224,7 @@ public void testSetsFrameLocalColorTableIfHasColorTable() {
     final int numColors = 4;
     ByteBuffer buffer = ByteBuffer.allocate(
         GifBytesTestUtil.HEADER_LENGTH + GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH + GifBytesTestUtil
-            .getImageDataSize(lzwMinCodeSize) + GifBytesTestUtil.getColorTableLength(numColors))
+            .getImageDataSize() + GifBytesTestUtil.getColorTableLength(numColors))
         .order(ByteOrder.LITTLE_ENDIAN);
     GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
     GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, true /*hasLct*/, numColors);
@@ -248,7 +248,7 @@ public void testCanParseMultipleFrames() {
     final int expectedFrames = 3;
 
     final int frameSize = GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH + GifBytesTestUtil
-        .getImageDataSize(lzwMinCodeSize);
+        .getImageDataSize();
     ByteBuffer buffer =
         ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH + expectedFrames * frameSize)
             .order(ByteOrder.LITTLE_ENDIAN);
@@ -272,7 +272,7 @@ public void testIsAnimatedMultipleFrames() {
 
     final int frameSize =
         GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH
-            + GifBytesTestUtil.getImageDataSize(lzwMinCodeSize);
+            + GifBytesTestUtil.getImageDataSize();
     ByteBuffer buffer =
         ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH + numFrames * frameSize)
             .order(ByteOrder.LITTLE_ENDIAN);
@@ -293,7 +293,7 @@ public void testIsNotAnimatedOneFrame() {
 
     final int frameSize =
         GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH
-            + GifBytesTestUtil.getImageDataSize(lzwMinCodeSize);
+            + GifBytesTestUtil.getImageDataSize();
 
     ByteBuffer buffer =
         ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH + frameSize)
diff --git a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtil.java b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtil.java
index 7a32733a6..4752afc3c 100644
--- a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtil.java
+++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtil.java
@@ -17,7 +17,7 @@ public static int getColorTableLength(int numColors) {
     return 3 * numColors;
   }
 
-  public static int getImageDataSize(int lzwMinCodeSize) {
+  public static int getImageDataSize() {
     // TODO: fill this out.
     return 4;
   }
@@ -78,7 +78,7 @@ public static void writeHeaderAndLsd(ByteBuffer out, int width, int height, bool
     // Version - 89a.
     out.put((byte) 0x38).put((byte) 0x39).put((byte) 0x61);
 
-    /** LSD (Logical Screen Descriptor) **/
+    /* LSD (Logical Screen Descriptor) **/
     // Width.
     out.putShort((short) width);
     // Height.
@@ -89,7 +89,7 @@ public static void writeHeaderAndLsd(ByteBuffer out, int width, int height, bool
     // Color resolution - next three bits.
     byte colorResolution = 1 << 5;
     // Sort flag - next bit;
-    byte sortFlag = 0 << 4;
+    byte sortFlag = 0;
     // exponent of size of color table, size = 2^(1 + exponent) - least significant 3 bits.
     byte size = (byte) gctSize;
 
diff --git a/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java b/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java
index 7bb25acab..f05bd08b8 100644
--- a/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java
+++ b/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java
@@ -4,6 +4,8 @@
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.Color;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.util.Log;
 import java.io.BufferedOutputStream;
 import java.io.FileOutputStream;
@@ -152,7 +154,7 @@ public void setTransparent(int color) {
      *          BufferedImage containing frame to write.
      * @return true if successful.
      */
-    public boolean addFrame(Bitmap im) {
+    public boolean addFrame(@Nullable Bitmap im) {
         return addFrame(im, 0, 0);
     }
 
@@ -175,7 +177,7 @@ public boolean addFrame(Bitmap im) {
      *          the Logical Screen.
      * @return true if successful.
      */
-    public boolean addFrame(Bitmap im, int x, int y) {
+    public boolean addFrame(@Nullable Bitmap im, int x, int y) {
         if ((im == null) || !started) {
             return false;
         }
@@ -318,7 +320,7 @@ private void setFrameSize(int w, int h) {
      *          OutputStream on which GIF images are written.
      * @return false if initial write failed.
      */
-    public boolean start(OutputStream os) {
+    public boolean start(@Nullable OutputStream os) {
         if (os == null)
             return false;
         boolean ok = true;
@@ -339,8 +341,8 @@ public boolean start(OutputStream os) {
      *          String containing output file name.
      * @return false if open or initial write failed.
      */
-    public boolean start(String file) {
-        boolean ok = true;
+    public boolean start(@NonNull String file) {
+        boolean ok;
         try {
             out = new BufferedOutputStream(new FileOutputStream(file));
             ok = start(out);
