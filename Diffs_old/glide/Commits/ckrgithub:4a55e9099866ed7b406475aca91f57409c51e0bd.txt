diff --git a/README.md b/README.md
index c1319c58d..cd89ab5a7 100644
--- a/README.md
+++ b/README.md
@@ -271,7 +271,12 @@ Manifest解析
     }
   }
 ```
-GlideExecutor
+### GlideExecutor
+* 磁盘缓存线程池：默认构建一个核心线程数和一个最大线程数
+* 原数据线程池：默认构建最优核心线程数和最优最大线程数
+* 无限制原数据线程池：默认构建0个核心线程数和Integer.MAX_VALUE个最大线程数
+* 动画线程池：默认构建0个核心线程数和2个/1个最大线程数
+
 ```java
   public final class GlideExecutor implements ExecutorService{
     private static final String DEFAULT_SOURCE_EXECUTOR_NAME="source";
@@ -449,9 +454,114 @@ GlideExecutor
     }
   }
 ```
-
-
-
+RuntimeCompat：可用进程数
+```java
+  final class RuntimeCompat{
+    private static final String TAG="GlideRuntimeCompat";
+    private static final String CPU_NAME_REGEX="cpu[0-9]+";
+    private static final String CPU_LOCATION="/sys/devices/system/cpu/";
+    private RuntimeCompat(){
+      
+    }
+    static int availableProcessors(){
+      int cpus=Runtime.getRuntime().availableProcessors();
+      if(Build.VERSION.SDK_INT <17){
+        cpus=Math.max(getCoreCountPre17(),cpus);
+      }
+      return cpus;
+    }
+    private static int getCoreCountPre17(){
+      File[] cpus=null;
+      //重写线程策略，允许磁盘读操作
+      //https://github.com/bumptech/glide/issues/1170
+      ThreadPolicy originalPolicy = StrictMode.allowThreadDiskReads();
+      try{
+        File cpuInfo=new File(CPU_LOCATION);
+        final Pattern cpuNamePattern = Pattern.compile(CPU_NAME_REGEX);
+        cups=cupInfo.listFiles(new FilenameFilter(){
+          @Override
+          public boolean accept(File file,String s){
+            return cpuNamePattern.match(s).matches();
+          }
+        });
+      }catch(Throwable t){
+        
+      }finally{
+        StrictMode.setThreadPolicy(originalPolicy);
+      }
+      return Math.max(1,cups!=null?cups.length:0);
+    }
+  }
+```
+### MemorySizeCalcultor
+内存大小计算器
+```java
+  public final class MemorySizeCalculator{
+    private static final String TAG="MemorySizeCalculator";
+    static final int BYTES_PER_ARGB_8888_PIXEL=4;
+    private static final int LOW_MEMORY_BYTE_ARRAY_POOL_DIVISOR=2;
+    private final int bitmapPoolSize;
+    private final int memoryCacheSize;
+    private final Context context;
+    private final int arrayPoolSize;
+    interface ScreenDimensions{
+      int getWidthPixels();
+      int getHeightPixels();
+    }
+    MemorySizeCalculator(MemorySizeCalculator.Builder builder){
+      this.context=builder.context;
+      //低端设备，数组池内存分配等于高端设备一半
+      arrayPoolSize=isLowMemoryDevice(builder.activityManager)?builder.arrayPoolSizeBytes/LOW_MEMORY_BYTE_ARRAY_POOL_DIVISOR:builder.arrayPoolSizeBytes;
+      int maxSize=getMaxSize(builder.activityManager,builder.maxSizeMultiplier,builder.lowMemoryMaxSizeMultiplier);
+      int widthPixels=builder.screenDimensions.getWidthPixels();
+      int heightPixels=builder.screenDimensions.getHeightPixels();
+      int screenSize=widthPixels*heightPixels*BYTES_PER_ARGB_8888_PIXEL;
+      int targetBitmapPoolSize=Math.round(screenSize*builder.bitmapPoolScreens);
+      int targetMemoryCacheSize=Math.round(screenSize*builder.memoryCacheScreens);
+      int availableSize=maxSize-arrayPoolSize;
+      if(targetMemoryCacheSize+targetBitmapPoolSize<=availableSize){
+        memoryCacheSize=targetMemoryCahceSize;
+        bitmapPoolSize=targetBitmapPoolSize;
+      }else{
+        float part=avialableSize/(builder.bitmapPoolScreens+builder.memoryCacheScreens);
+        memoryCachSize=Math.round(part*builder.memoryCacheScreens);
+        bitmapPoolSize=Math.round(part*builder.bitmapPoolScreens);
+      }
+    }
+    @TargetApi(Builder.VERSION_CODES.KITKAT)
+    static boolean isLowMemoryDevice(ActivityManager activityManager){
+      if(Build.VERSION.SDK_INT>=Build.VERSION_CODES.KITKAT){
+        return activityManager.isLowRamDevice();
+      }else{
+        return true;
+      }
+    }
+    private static int getMaxSize(ActivityManager activityManager,float maxSizeMultiplier,float lowMemoryMaxSizeMultiplier){
+      final int memroyClassBytes=activityManager.getMemoryClass()*1024*1024;
+      final boolean isLowMemoryDevice=isLowMemoryDevice(activityManager);
+      return Math.round(memoryClassBytes*(isLowMemoryDevice?lowMemoryMaxSizeMultiplier:maxSizeMultiplier));
+    }
+    public int getMemoryCacheSize(){
+      return memoryCacheSize;
+    }
+    public int getBitmapPoolSize(){
+      return bitmapPoolSize;
+    }
+    public int getArrayPoolSizeInBytes(){
+      return arrayPoolSize;
+    }
+    privte String toMb(int bytes){
+      return Formatter.formatFileSize(context,bytes);
+    }
+    
+    public static final class Builder{
+      static final int MEMORY_CACHE_TARGET_SCREENS=2;
+      /**
+      * On Android O+,we use {@link android.graphics.Bitmap.Config#HEADWARE} for all reasonably sized 
+      */
+    }
+  }
+```
 
 
 
