diff --git a/instrumentation/src/androidTest/AndroidManifest.xml b/instrumentation/src/androidTest/AndroidManifest.xml
index f9088f24f..f12090f37 100644
--- a/instrumentation/src/androidTest/AndroidManifest.xml
+++ b/instrumentation/src/androidTest/AndroidManifest.xml
@@ -1,6 +1,11 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
   package="com.bumptech.glide.instrumentation.test">
   <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
-  <application>
+  <application android:label="GlideTest">
+    <uses-library android:name="android.test.runner" />
   </application>
+
+  <instrumentation android:targetPackage="com.bumptech.glide.instrumentation"
+                   android:name="com.google.android.apps.common.testing.testrunner.Google3InstrumentationTestRunner"
+                   android:label="Glide Emulator Tests" />
 </manifest>
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java
new file mode 100644
index 000000000..6c8f76234
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java
@@ -0,0 +1,192 @@
+package com.bumptech.glide;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyBoolean;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.verify;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.os.Handler;
+import android.os.Looper;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.engine.cache.LruResourceCache;
+import com.bumptech.glide.request.FutureTarget;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.test.BitmapSubject;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+/**
+ * Tests various aspects of memory and disk caching to verify resources can be retrieved as we
+ * expect.
+ */
+@RunWith(AndroidJUnit4.class)
+public class CachingTest {
+  private static final int IMAGE_SIZE_PIXELS = 500;
+  private static final long TIMEOUT_MS = 5000;
+  private static final TimeUnit TIMEOUT_UNIT = TimeUnit.MILLISECONDS;
+  // Store at least 10 500x500 pixel Bitmaps with the ARGB_8888 config to be safe.
+  private static final long CACHE_SIZE_BYTES =
+      IMAGE_SIZE_PIXELS * IMAGE_SIZE_PIXELS * 4 * 10;
+
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+  @Mock private RequestListener<Drawable> requestListener;
+
+  private Context context;
+
+  @Before
+  public void setUp() throws InterruptedException {
+    MockitoAnnotations.initMocks(this);
+    context = InstrumentationRegistry.getTargetContext();
+
+    Glide.init(
+        context, new GlideBuilder().setMemoryCache(new LruResourceCache(CACHE_SIZE_BYTES)));
+  }
+
+  @Test
+  public void submit_withPreviousRequestClearedFromMemory_completesFromDataDiskCache()
+      throws InterruptedException, ExecutionException, TimeoutException {
+    FutureTarget<Drawable> future = GlideApp.with(context)
+        .load(ResourceIds.raw.canonical)
+        .diskCacheStrategy(DiskCacheStrategy.DATA)
+        .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS);
+    future.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
+    GlideApp.with(context).clear(future);
+
+    clearMemoryCacheOnMainThread();
+
+    GlideApp.with(context)
+        .load(ResourceIds.raw.canonical)
+        .diskCacheStrategy(DiskCacheStrategy.DATA)
+        .listener(requestListener)
+        .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS)
+        .get(TIMEOUT_MS, TIMEOUT_UNIT);
+
+    verify(requestListener)
+        .onResourceReady(
+            any(Drawable.class),
+            any(),
+            anyTarget(),
+            eq(DataSource.DATA_DISK_CACHE),
+            anyBoolean());
+  }
+
+  @Test
+  public void submit_withPreviousButNoLongerReferencedIdenticalRequest_completesFromMemoryCache()
+      throws InterruptedException, TimeoutException, ExecutionException {
+    // We can't allow any mocks (RequestListner, Target etc) to reference this request or the test
+    // will fail due to the transient strong reference to the request.
+    GlideApp.with(context)
+        .load(ResourceIds.raw.canonical)
+        .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+        .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS)
+        .get(TIMEOUT_MS, TIMEOUT_UNIT);
+    // Force the collection of weak references now that the listener/request in the first load is no
+    // longer referenced.
+    Runtime.getRuntime().gc();
+    GlideApp.with(context)
+        .load(ResourceIds.raw.canonical)
+        .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+        .listener(requestListener)
+        .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS)
+        .get(TIMEOUT_MS, TIMEOUT_UNIT);
+
+    verify(requestListener).onResourceReady(
+        any(Drawable.class), any(), anyTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
+  }
+
+  @Test
+  public void submit_withPreviousButNoLongerReferencedIdenticalRequest_doesNotRecycleBitmap()
+      throws InterruptedException, TimeoutException, ExecutionException {
+    // We can't allow any mocks (RequestListener, Target etc) to reference this request or the test
+    // will fail due to the transient strong reference to the request.
+    Bitmap bitmap = GlideApp.with(context)
+        .asBitmap()
+        .load(ResourceIds.raw.canonical)
+        .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+        .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS)
+        .get(TIMEOUT_MS, TIMEOUT_UNIT);
+    // Force the collection of weak references now that the listener/request in the first load is no
+    // longer referenced.
+    Runtime.getRuntime().gc();
+
+    FutureTarget<Bitmap> future = GlideApp.with(context)
+        .asBitmap()
+        .load(ResourceIds.raw.canonical)
+        .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+        .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS);
+    future.get(TIMEOUT_MS, TIMEOUT_UNIT);
+    Glide.with(context).clear(future);
+
+    clearMemoryCacheOnMainThread();
+
+    BitmapSubject.assertThat(bitmap).isNotRecycled();
+  }
+
+  @Test
+  public void clearDiskCache_doesNotPreventFutureLoads()
+      throws ExecutionException, InterruptedException, TimeoutException {
+    FutureTarget<Drawable> future = GlideApp.with(context)
+        .load(ResourceIds.raw.canonical)
+        .diskCacheStrategy(DiskCacheStrategy.DATA)
+        .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS);
+    future.get(TIMEOUT_MS, TIMEOUT_UNIT);
+    GlideApp.with(context).clear(future);
+
+    clearMemoryCacheOnMainThread();
+    GlideApp.get(context).clearDiskCache();
+
+    future = GlideApp.with(context)
+        .load(ResourceIds.raw.canonical)
+        .diskCacheStrategy(DiskCacheStrategy.DATA)
+        .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS);
+    future.get(TIMEOUT_MS, TIMEOUT_UNIT);
+
+    GlideApp.with(context).clear(future);
+    clearMemoryCacheOnMainThread();
+
+    GlideApp.with(context)
+        .load(ResourceIds.raw.canonical)
+        .listener(requestListener)
+        .diskCacheStrategy(DiskCacheStrategy.DATA)
+        .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS)
+        .get(TIMEOUT_MS, TIMEOUT_UNIT);
+
+    verify(requestListener).onResourceReady(
+        any(Drawable.class), any(), anyTarget(), eq(DataSource.DATA_DISK_CACHE), anyBoolean());
+  }
+
+  @SuppressWarnings("unchecked")
+  private static Target<Drawable> anyTarget() {
+    return (Target<Drawable>) any(Target.class);
+  }
+
+  private void clearMemoryCacheOnMainThread() throws InterruptedException {
+    final CountDownLatch countDownLatch = new CountDownLatch(1);
+    new Handler(Looper.getMainLooper()).post(new Runnable() {
+      @Override
+      public void run() {
+        Glide.get(context).clearMemory();
+        countDownLatch.countDown();
+      }
+    });
+    countDownLatch.await(TIMEOUT_MS, TIMEOUT_UNIT);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java b/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java
new file mode 100644
index 000000000..0cbde46d1
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java
@@ -0,0 +1,97 @@
+package com.bumptech.glide.load.engine;
+
+import android.os.Looper;
+import android.os.MessageQueue;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.engine.EngineResource.ResourceListener;
+import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Synthetic;
+import java.lang.ref.ReferenceQueue;
+import java.lang.ref.WeakReference;
+import java.util.HashMap;
+import java.util.Map;
+
+final class ActiveResources {
+  private final Map<Key, ResourceWeakReference> activeEngineResources = new HashMap<>();
+  // Lazily instantiate to avoid exceptions if Glide is initialized on a background thread. See
+  // #295.
+  @Nullable
+  private ReferenceQueue<EngineResource<?>> resourceReferenceQueue;
+  private ResourceListener listener;
+
+  void setListener(ResourceListener listener) {
+    this.listener = listener;
+  }
+
+  void activate(Key key, EngineResource<?> resource) {
+    activeEngineResources.put(key, new ResourceWeakReference(key, resource, getReferenceQueue()));
+  }
+
+  void deactivate(Key key) {
+    activeEngineResources.remove(key);
+  }
+
+  @Nullable
+  EngineResource<?> get(Key key) {
+    ResourceWeakReference activeRef = activeEngineResources.get(key);
+    if (activeRef == null) {
+      return null;
+    }
+
+    EngineResource<?> active = activeRef.get();
+    if (active == null) {
+      cleanupActiveReference(activeRef);
+    }
+    return active;
+  }
+
+  private void cleanupActiveReference(@NonNull ResourceWeakReference ref) {
+    activeEngineResources.remove(ref.key);
+
+    if (!ref.isCacheable) {
+      return;
+    }
+    EngineResource<?> newResource =
+        new EngineResource<>(ref.resource, /*isCacheable=*/ true, /*isRecyclable=*/ false);
+    newResource.setResourceListener(ref.key, listener);
+    listener.onResourceReleased(ref.key, newResource);
+  }
+
+  private ReferenceQueue<EngineResource<?>> getReferenceQueue() {
+    if (resourceReferenceQueue == null) {
+      resourceReferenceQueue = new ReferenceQueue<>();
+      MessageQueue queue = Looper.myQueue();
+      queue.addIdleHandler(new RefQueueIdleHandler());
+    }
+    return resourceReferenceQueue;
+  }
+
+  // Responsible for cleaning up the active resource map by remove weak references that have been
+  // cleared.
+  private class RefQueueIdleHandler implements MessageQueue.IdleHandler {
+    @Override
+    public boolean queueIdle() {
+      ResourceWeakReference ref;
+      while ((ref = (ResourceWeakReference) getReferenceQueue().poll()) != null) {
+        cleanupActiveReference(ref);
+      }
+      return true;
+    }
+  }
+
+  private static class ResourceWeakReference extends WeakReference<EngineResource<?>> {
+    @Synthetic final Key key;
+    @Synthetic final EngineResource<?> resource;
+    @Synthetic final boolean isCacheable;
+
+    ResourceWeakReference(
+        Key key, EngineResource<?> r, ReferenceQueue<? super EngineResource<?>> q) {
+      super(r, q);
+      this.key = Preconditions.checkNotNull(key);
+      this.resource = Preconditions.checkNotNull(r);
+      isCacheable = r.isCacheable();
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
index 0f1aed67a..16e7eed64 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.engine;
 
-import android.os.Looper;
-import android.os.MessageQueue;
+import android.support.annotation.Nullable;
 import android.support.annotation.VisibleForTesting;
 import android.support.v4.util.Pools;
 import android.util.Log;
@@ -20,8 +19,6 @@
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
 import com.bumptech.glide.util.pool.FactoryPools;
-import java.lang.ref.ReferenceQueue;
-import java.lang.ref.WeakReference;
 import java.util.HashMap;
 import java.util.Map;
 
@@ -37,31 +34,10 @@
   private final EngineKeyFactory keyFactory;
   private final MemoryCache cache;
   private final EngineJobFactory engineJobFactory;
-  private final Map<Key, WeakReference<EngineResource<?>>> activeResources;
   private final ResourceRecycler resourceRecycler;
   private final LazyDiskCacheProvider diskCacheProvider;
   private final DecodeJobFactory decodeJobFactory;
-
-  // Lazily instantiate to avoid exceptions if Glide is initialized on a background thread. See
-  // #295.
-  private ReferenceQueue<EngineResource<?>> resourceReferenceQueue;
-
-  /**
-   * Allows a request to indicate it no longer is interested in a given load.
-   */
-  public static class LoadStatus {
-    private final EngineJob<?> engineJob;
-    private final ResourceCallback cb;
-
-    public LoadStatus(ResourceCallback cb, EngineJob<?> engineJob) {
-      this.cb = cb;
-      this.engineJob = engineJob;
-    }
-
-    public void cancel() {
-      engineJob.removeCallback(cb);
-    }
-  }
+  private final ActiveResources activeResources;
 
   public Engine(MemoryCache memoryCache,
       DiskCache.Factory diskCacheFactory,
@@ -78,7 +54,7 @@ public Engine(MemoryCache memoryCache,
         animationExecutor,
         /*jobs=*/ null,
         /*keyFactory=*/ null,
-        /*activeResources=*/ null,
+        /*activeEngineResources=*/ null,
         /*engineJobFactory=*/ null,
         /*decodeJobFactory=*/ null,
         /*resourceRecycler=*/ null);
@@ -93,7 +69,7 @@ public Engine(MemoryCache memoryCache,
       GlideExecutor animationExecutor,
       Map<Key, EngineJob<?>> jobs,
       EngineKeyFactory keyFactory,
-      Map<Key, WeakReference<EngineResource<?>>> activeResources,
+      ActiveResources activeResources,
       EngineJobFactory engineJobFactory,
       DecodeJobFactory decodeJobFactory,
       ResourceRecycler resourceRecycler) {
@@ -101,9 +77,10 @@ public Engine(MemoryCache memoryCache,
     this.diskCacheProvider = new LazyDiskCacheProvider(diskCacheFactory);
 
     if (activeResources == null) {
-      activeResources = new HashMap<>();
+      activeResources = new ActiveResources();
     }
     this.activeResources = activeResources;
+    activeResources.setListener(this);
 
     if (keyFactory == null) {
       keyFactory = new EngineKeyFactory();
@@ -179,20 +156,20 @@ public Engine(MemoryCache memoryCache,
     EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,
         resourceClass, transcodeClass, options);
 
-    EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);
-    if (cached != null) {
-      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);
+    EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);
+    if (active != null) {
+      cb.onResourceReady(active, DataSource.MEMORY_CACHE);
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
-        logWithTimeAndKey("Loaded resource from cache", startTime, key);
+        logWithTimeAndKey("Loaded resource from active resources", startTime, key);
       }
       return null;
     }
 
-    EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);
-    if (active != null) {
-      cb.onResourceReady(active, DataSource.MEMORY_CACHE);
+    EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);
+    if (cached != null) {
+      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
-        logWithTimeAndKey("Loaded resource from active resources", startTime, key);
+        logWithTimeAndKey("Loaded resource from cache", startTime, key);
       }
       return null;
     }
@@ -239,25 +216,20 @@ private static void logWithTimeAndKey(String log, long startTime, Key key) {
     Log.v(TAG, log + " in " + LogTime.getElapsedMillis(startTime) + "ms, key: " + key);
   }
 
+  @Nullable
   private EngineResource<?> loadFromActiveResources(Key key, boolean isMemoryCacheable) {
     if (!isMemoryCacheable) {
       return null;
     }
-
-    EngineResource<?> active = null;
-    WeakReference<EngineResource<?>> activeRef = activeResources.get(key);
-    if (activeRef != null) {
-      active = activeRef.get();
-      if (active != null) {
-        active.acquire();
-      } else {
-        activeResources.remove(key);
-      }
+    EngineResource<?> active = activeResources.get(key);
+    if (active != null) {
+      active.acquire();
     }
 
     return active;
   }
 
+
   private EngineResource<?> loadFromCache(Key key, boolean isMemoryCacheable) {
     if (!isMemoryCacheable) {
       return null;
@@ -266,7 +238,7 @@ private static void logWithTimeAndKey(String log, long startTime, Key key) {
     EngineResource<?> cached = getEngineResourceFromCache(key);
     if (cached != null) {
       cached.acquire();
-      activeResources.put(key, new ResourceWeakReference(key, cached, getReferenceQueue()));
+      activeResources.activate(key, cached);
     }
     return cached;
   }
@@ -282,7 +254,7 @@ private static void logWithTimeAndKey(String log, long startTime, Key key) {
       // Save an object allocation if we've cached an EngineResource (the typical case).
       result = (EngineResource<?>) cached;
     } else {
-      result = new EngineResource<>(cached, true /*isMemoryCacheable*/);
+      result = new EngineResource<>(cached, true /*isMemoryCacheable*/, true /*isRecyclable*/);
     }
     return result;
   }
@@ -305,7 +277,7 @@ public void onEngineJobComplete(Key key, EngineResource<?> resource) {
       resource.setResourceListener(key, this);
 
       if (resource.isCacheable()) {
-        activeResources.put(key, new ResourceWeakReference(key, resource, getReferenceQueue()));
+        activeResources.activate(key, resource);
       }
     }
     // TODO: should this check that the engine job is still current?
@@ -328,9 +300,9 @@ public void onResourceRemoved(final Resource<?> resource) {
   }
 
   @Override
-  public void onResourceReleased(Key cacheKey, EngineResource resource) {
+  public void onResourceReleased(Key cacheKey, EngineResource<?> resource) {
     Util.assertMainThread();
-    activeResources.remove(cacheKey);
+    activeResources.deactivate(cacheKey);
     if (resource.isCacheable()) {
       cache.put(cacheKey, resource);
     } else {
@@ -347,13 +319,21 @@ public void tearDown() {
     engineJobFactory.tearDown();
   }
 
-  private ReferenceQueue<EngineResource<?>> getReferenceQueue() {
-    if (resourceReferenceQueue == null) {
-      resourceReferenceQueue = new ReferenceQueue<>();
-      MessageQueue queue = Looper.myQueue();
-      queue.addIdleHandler(new RefQueueIdleHandler(activeResources, resourceReferenceQueue));
+  /**
+   * Allows a request to indicate it no longer is interested in a given load.
+   */
+  public static class LoadStatus {
+    private final EngineJob<?> engineJob;
+    private final ResourceCallback cb;
+
+    LoadStatus(ResourceCallback cb, EngineJob<?> engineJob) {
+      this.cb = cb;
+      this.engineJob = engineJob;
+    }
+
+    public void cancel() {
+      engineJob.removeCallback(cb);
     }
-    return resourceReferenceQueue;
   }
 
   private static class LazyDiskCacheProvider implements DecodeJob.DiskCacheProvider {
@@ -361,7 +341,7 @@ public void tearDown() {
     private final DiskCache.Factory factory;
     private volatile DiskCache diskCache;
 
-    public LazyDiskCacheProvider(DiskCache.Factory factory) {
+    LazyDiskCacheProvider(DiskCache.Factory factory) {
       this.factory = factory;
     }
 
@@ -381,40 +361,7 @@ public DiskCache getDiskCache() {
     }
   }
 
-  private static class ResourceWeakReference extends WeakReference<EngineResource<?>> {
-    @Synthetic final Key key;
-
-    public ResourceWeakReference(Key key, EngineResource<?> r,
-        ReferenceQueue<? super EngineResource<?>> q) {
-      super(r, q);
-      this.key = key;
-    }
-  }
-
-  // Responsible for cleaning up the active resource map by remove weak references that have been
-  // cleared.
-  private static class RefQueueIdleHandler implements MessageQueue.IdleHandler {
-    private final Map<Key, WeakReference<EngineResource<?>>> activeResources;
-    private final ReferenceQueue<EngineResource<?>> queue;
-
-    public RefQueueIdleHandler(Map<Key, WeakReference<EngineResource<?>>> activeResources,
-        ReferenceQueue<EngineResource<?>> queue) {
-      this.activeResources = activeResources;
-      this.queue = queue;
-    }
-
-    @Override
-    public boolean queueIdle() {
-      ResourceWeakReference ref = (ResourceWeakReference) queue.poll();
-      if (ref != null) {
-        activeResources.remove(ref.key);
-      }
-
-      return true;
-    }
-  }
-
-  // Visible for testing.
+  @VisibleForTesting
   static class DecodeJobFactory {
     @Synthetic final DecodeJob.DiskCacheProvider diskCacheProvider;
     @Synthetic final Pools.Pool<DecodeJob<?>> pool = FactoryPools.simple(JOB_POOL_SIZE,
@@ -469,7 +416,7 @@ public boolean queueIdle() {
     }
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class EngineJobFactory {
     @Synthetic final GlideExecutor diskCacheExecutor;
     @Synthetic final GlideExecutor sourceExecutor;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
index 87c714a6a..9079801c3 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
@@ -294,7 +294,7 @@ public StateVerifier getVerifier() {
   // Visible for testing.
   static class EngineResourceFactory {
     public <R> EngineResource<R> build(Resource<R> resource, boolean isMemoryCacheable) {
-      return new EngineResource<>(resource, isMemoryCacheable);
+      return new EngineResource<>(resource, isMemoryCacheable, /*isRecyclable=*/ true);
     }
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
index c03168f69..7aacd9126 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
@@ -12,6 +12,7 @@
  */
 class EngineResource<Z> implements Resource<Z> {
   private final boolean isCacheable;
+  private final boolean isRecyclable;
   private ResourceListener listener;
   private Key key;
   private int acquired;
@@ -22,9 +23,10 @@
     void onResourceReleased(Key key, EngineResource<?> resource);
   }
 
-  EngineResource(Resource<Z> toWrap, boolean isCacheable) {
+  EngineResource(Resource<Z> toWrap, boolean isCacheable, boolean isRecyclable) {
     resource = Preconditions.checkNotNull(toWrap);
     this.isCacheable = isCacheable;
+    this.isRecyclable = isRecyclable;
   }
 
   void setResourceListener(Key key, ResourceListener listener) {
@@ -32,6 +34,10 @@ void setResourceListener(Key key, ResourceListener listener) {
     this.listener = listener;
   }
 
+  Resource<Z> getResource() {
+    return resource;
+  }
+
   boolean isCacheable() {
     return isCacheable;
   }
@@ -60,7 +66,9 @@ public void recycle() {
       throw new IllegalStateException("Cannot recycle a resource that has already been recycled");
     }
     isRecycled = true;
-    resource.recycle();
+    if (isRecyclable) {
+      resource.recycle();
+    }
   }
 
   /**
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheFactory.java
index 9cb71e441..ae02f4c58 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheFactory.java
@@ -63,6 +63,6 @@ public DiskCache build() {
       return null;
     }
 
-    return DiskLruCacheWrapper.get(cacheDir, diskCacheSize);
+    return DiskLruCacheWrapper.create(cacheDir, diskCacheSize);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
index a8f58be31..3c3a6d01e 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
@@ -38,7 +38,10 @@
    * @param directory The directory for the disk cache
    * @param maxSize   The max size for the disk cache
    * @return The new disk cache with the given arguments, or the current cache if one already exists
+   *
+   * @deprecated Use {@link #create(File, long)} to create a new cache with the specified arguments.
    */
+  @Deprecated
   public static synchronized DiskCache get(File directory, long maxSize) {
     // TODO calling twice with different arguments makes it return the cache for the same
     // directory, it's public!
@@ -48,6 +51,17 @@ public static synchronized DiskCache get(File directory, long maxSize) {
     return wrapper;
   }
 
+  /**
+   * Create a new DiskCache in the given directory with a specified max size.
+   *
+   * @param directory The directory for the disk cache
+   * @param maxSize   The max size for the disk cache
+   * @return The new disk cache with the given arguments
+   */
+  public static DiskCache create(File directory, long maxSize) {
+    return new DiskLruCacheWrapper(directory, maxSize);
+  }
+
   protected DiskLruCacheWrapper(File directory, long maxSize) {
     this.directory = directory;
     this.maxSize = maxSize;
diff --git a/library/src/main/java/com/bumptech/glide/util/LruCache.java b/library/src/main/java/com/bumptech/glide/util/LruCache.java
index dfb420e41..d09ee9923 100644
--- a/library/src/main/java/com/bumptech/glide/util/LruCache.java
+++ b/library/src/main/java/com/bumptech/glide/util/LruCache.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.util;
 
 import android.support.annotation.Nullable;
-
 import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.Map;
diff --git a/library/src/test/java/com/bumptech/glide/GlideTest.java b/library/src/test/java/com/bumptech/glide/GlideTest.java
index 830fc2b5b..77eb57a78 100644
--- a/library/src/test/java/com/bumptech/glide/GlideTest.java
+++ b/library/src/test/java/com/bumptech/glide/GlideTest.java
@@ -16,11 +16,9 @@
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
-import static org.robolectric.Shadows.shadowOf;
 
 import android.content.ContentResolver;
 import android.content.Context;
-import android.content.pm.ApplicationInfo;
 import android.content.res.AssetFileDescriptor;
 import android.graphics.Bitmap;
 import android.graphics.Color;
@@ -29,7 +27,6 @@
 import android.graphics.drawable.Drawable;
 import android.media.MediaMetadataRetriever;
 import android.net.Uri;
-import android.os.Bundle;
 import android.os.Handler;
 import android.os.ParcelFileDescriptor;
 import android.view.ViewGroup;
@@ -74,6 +71,8 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.RobolectricTestRunner;
@@ -85,7 +84,6 @@
 import org.robolectric.annotation.Resetter;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowBitmap;
-import org.robolectric.shadows.ShadowPackageManager;
 
 /**
  * Tests for the {@link Glide} interface and singleton.
@@ -95,31 +93,53 @@
     GlideTest.ShadowFileDescriptorContentResolver.class,
     GlideTest.ShadowMediaMetadataRetriever.class, GlideShadowLooper.class,
     GlideTest.MutableShadowBitmap.class })
-@SuppressWarnings({"unchecked", "deprecation"})
+@SuppressWarnings("unchecked")
 public class GlideTest {
+
   @SuppressWarnings("rawtypes")
-  private Target target = null;
+  @Mock private Target target;
+  @Mock private DiskCache.Factory diskCacheFactory;
+  @Mock private DiskCache diskCache;
+  @Mock private MemoryCache memoryCache;
+  @Mock private Handler bgHandler;
+  @Mock private Lifecycle lifecycle;
+  @Mock private RequestManagerTreeNode treeNode;
+  @Mock private BitmapPool bitmapPool;
+
   private ImageView imageView;
   private RequestManager requestManager;
+  private Context context;
 
   @Before
   public void setUp() throws Exception {
-    Glide.tearDown();
-
-    ShadowPackageManager pm = shadowOf(RuntimeEnvironment.application.getPackageManager());
-    ApplicationInfo info =
-        pm.getApplicationInfo(RuntimeEnvironment.application.getPackageName(), 0);
-    info.metaData = new Bundle();
-    info.metaData.putString(SetupModule.class.getName(), "GlideModule");
+    MockitoAnnotations.initMocks(this);
+    context = RuntimeEnvironment.application;
+
+     // Run all tasks on the main thread so they complete synchronously.
+    GlideExecutor executor = MockGlideExecutor.newMainThreadExecutor();
+    when(diskCacheFactory.build()).thenReturn(diskCache);
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setMemoryCache(memoryCache)
+            .setDiskCache(diskCacheFactory)
+            .setResizeExecutor(executor)
+            .setDiskCacheExecutor(executor));
+    Registry registry = Glide.get(context).getRegistry();
+    registerMockModelLoader(
+        GlideUrl.class, InputStream.class, new ByteArrayInputStream(new byte[0]), registry);
+    registerMockModelLoader(
+        File.class, InputStream.class, new ByteArrayInputStream(new byte[0]), registry);
+    registerMockModelLoader(
+        File.class, ParcelFileDescriptor.class, mock(ParcelFileDescriptor.class), registry);
+    registerMockModelLoader(File.class, ByteBuffer.class, ByteBuffer.allocate(10), registry);
 
     // Ensure that target's size ready callback will be called synchronously.
-    target = mock(Target.class);
-    imageView = new ImageView(RuntimeEnvironment.application);
+    imageView = new ImageView(context);
     imageView.setLayoutParams(new ViewGroup.LayoutParams(100, 100));
     imageView.layout(0, 0, 100, 100);
     doAnswer(new CallSizeReady()).when(target).getSize(isA(SizeReadyCallback.class));
 
-    Handler bgHandler = mock(Handler.class);
     when(bgHandler.post(isA(Runnable.class))).thenAnswer(new Answer<Boolean>() {
       @Override
       public Boolean answer(InvocationOnMock invocation) throws Throwable {
@@ -129,9 +149,7 @@ public Boolean answer(InvocationOnMock invocation) throws Throwable {
       }
     });
 
-    Lifecycle lifecycle = mock(Lifecycle.class);
-    RequestManagerTreeNode treeNode = mock(RequestManagerTreeNode.class);
-    requestManager = new RequestManager(Glide.get(getContext()), lifecycle, treeNode, getContext());
+    requestManager = new RequestManager(Glide.get(context), lifecycle, treeNode, context);
     requestManager.resumeRequests();
   }
 
@@ -142,13 +160,12 @@ public void tearDown() {
 
   @Test
   public void testCanSetMemoryCategory() {
-    MemoryCache memoryCache = mock(MemoryCache.class);
-    BitmapPool bitmapPool = mock(BitmapPool.class);
-
     MemoryCategory memoryCategory = MemoryCategory.NORMAL;
     Glide glide =
-        new GlideBuilder().setBitmapPool(bitmapPool).setMemoryCache(memoryCache)
-            .build(getContext());
+        new GlideBuilder()
+            .setBitmapPool(bitmapPool)
+            .setMemoryCache(memoryCache)
+            .build(context);
     glide.setMemoryCategory(memoryCategory);
 
     verify(memoryCache).setSizeMultiplier(eq(memoryCategory.getMultiplier()));
@@ -157,13 +174,12 @@ public void testCanSetMemoryCategory() {
 
   @Test
   public void testCanIncreaseMemoryCategory() {
-    MemoryCache memoryCache = mock(MemoryCache.class);
-    BitmapPool bitmapPool = mock(BitmapPool.class);
-
     MemoryCategory memoryCategory = MemoryCategory.NORMAL;
     Glide glide =
-        new GlideBuilder().setBitmapPool(bitmapPool).setMemoryCache(memoryCache)
-            .build(getContext());
+        new GlideBuilder()
+            .setBitmapPool(bitmapPool)
+            .setMemoryCache(memoryCache)
+            .build(context);
     glide.setMemoryCategory(memoryCategory);
 
     verify(memoryCache).setSizeMultiplier(eq(memoryCategory.getMultiplier()));
@@ -180,13 +196,12 @@ public void testCanIncreaseMemoryCategory() {
 
   @Test
   public void testCanDecreaseMemoryCategory() {
-    MemoryCache memoryCache = mock(MemoryCache.class);
-    BitmapPool bitmapPool = mock(BitmapPool.class);
-
     MemoryCategory memoryCategory = MemoryCategory.NORMAL;
     Glide glide =
-        new GlideBuilder().setBitmapPool(bitmapPool).setMemoryCache(memoryCache)
-            .build(getContext());
+        new GlideBuilder()
+            .setBitmapPool(bitmapPool)
+            .setMemoryCache(memoryCache)
+            .build(context);
     glide.setMemoryCategory(memoryCategory);
 
     verify(memoryCache).setSizeMultiplier(eq(memoryCategory.getMultiplier()));
@@ -203,12 +218,11 @@ public void testCanDecreaseMemoryCategory() {
 
   @Test
   public void testClearMemory() {
-    BitmapPool bitmapPool = mock(BitmapPool.class);
-    MemoryCache memoryCache = mock(MemoryCache.class);
-
     Glide glide =
-        new GlideBuilder().setBitmapPool(bitmapPool).setMemoryCache(memoryCache)
-            .build(getContext());
+        new GlideBuilder()
+            .setBitmapPool(bitmapPool)
+            .setMemoryCache(memoryCache)
+            .build(context);
 
     glide.clearMemory();
 
@@ -218,12 +232,11 @@ public void testClearMemory() {
 
   @Test
   public void testTrimMemory() {
-    BitmapPool bitmapPool = mock(BitmapPool.class);
-    MemoryCache memoryCache = mock(MemoryCache.class);
-
     Glide glide =
-        new GlideBuilder().setBitmapPool(bitmapPool).setMemoryCache(memoryCache)
-            .build(getContext());
+        new GlideBuilder()
+            .setBitmapPool(bitmapPool)
+            .setMemoryCache(memoryCache)
+            .build(context);
 
     final int level = 123;
 
@@ -499,7 +512,7 @@ public void testNonDefaultModelWithRegisteredFactoryDoesNotThrow() {
   @Test
   public void testReceivesGif() throws IOException {
     String fakeUri = "content://fake";
-    InputStream testGifData = openResource("test.gif");
+    InputStream testGifData = openGif();
     mockUri(Uri.parse(fakeUri), testGifData);
 
     requestManager.asGif().load(fakeUri).into(target);
@@ -510,7 +523,7 @@ public void testReceivesGif() throws IOException {
   @Test
   public void testReceivesGifBytes() throws IOException {
     String fakeUri = "content://fake";
-    InputStream testGifData = openResource("test.gif");
+    InputStream testGifData = openGif();
     mockUri(Uri.parse(fakeUri), testGifData);
 
     requestManager.as(byte[].class).apply(decodeTypeOf(GifDrawable.class)).load(fakeUri)
@@ -700,24 +713,23 @@ public void testClone() throws IOException {
     ModelLoaderFactory<T, Z> failFactory = mock(ModelLoaderFactory.class);
     when(failFactory.build(isA(MultiModelLoaderFactory.class))).thenReturn(failLoader);
 
-    Glide.get(getContext()).getRegistry().prepend(failModel, failResource, failFactory);
+    Glide.get(context).getRegistry().prepend(failModel, failResource, failFactory);
   }
 
   private String mockUri(String uriString) {
     return mockUri(Uri.parse(uriString), null);
   }
 
-  private String mockUri(Uri uri) {
-    return mockUri(uri, null);
+  private void mockUri(Uri uri) {
+    mockUri(uri, null);
   }
 
   private String mockUri(Uri uri, InputStream is) {
     if (is == null) {
       is = new ByteArrayInputStream(new byte[0]);
     }
-    ContentResolver contentResolver = RuntimeEnvironment.application.getContentResolver();
-    ShadowFileDescriptorContentResolver shadowContentResolver =
-        (ShadowFileDescriptorContentResolver) Shadow.extract(contentResolver);
+    ContentResolver contentResolver = context.getContentResolver();
+    ShadowFileDescriptorContentResolver shadowContentResolver = Shadow.extract(contentResolver);
     shadowContentResolver.registerInputStream(uri, is);
 
     AssetFileDescriptor assetFileDescriptor = mock(AssetFileDescriptor.class);
@@ -728,17 +740,13 @@ private String mockUri(Uri uri, InputStream is) {
     return uri.toString();
   }
 
-  private Context getContext() {
-    return RuntimeEnvironment.application;
-  }
-
   @SuppressWarnings("unchecked")
   private <T> void registerMockStreamModelLoader(final Class<T> modelClass) {
     ModelLoader<T, InputStream> modelLoader = mockStreamModelLoader(modelClass);
     ModelLoaderFactory<T, InputStream> modelLoaderFactory = mock(ModelLoaderFactory.class);
     when(modelLoaderFactory.build(isA(MultiModelLoaderFactory.class))).thenReturn(modelLoader);
 
-    Glide.get(RuntimeEnvironment.application).getRegistry()
+    Glide.get(context).getRegistry()
         .prepend(modelClass, InputStream.class, modelLoaderFactory);
   }
 
@@ -760,19 +768,19 @@ private Context getContext() {
     return modelLoader;
   }
 
-  private InputStream openResource(String imageName) throws IOException {
-    return TestResourceUtil.openResource(getClass(), imageName);
+  private InputStream openGif() throws IOException {
+    return TestResourceUtil.openResource(getClass(), "test.gif");
   }
 
   private static class CallSizeReady implements Answer<Void> {
     private int width;
     private int height;
 
-    public CallSizeReady() {
+    CallSizeReady() {
       this(100, 100);
     }
 
-    public CallSizeReady(int width, int height) {
+    CallSizeReady(int width, int height) {
       this.width = width;
       this.height = height;
     }
@@ -785,53 +793,26 @@ public Void answer(InvocationOnMock invocation) throws Throwable {
     }
   }
 
-  public static class SetupModule implements com.bumptech.glide.module.GlideModule {
-
-    @Override
-    public void applyOptions(Context context, GlideBuilder builder) {
-      // Run all tasks on the main thread so they complete synchronously.
-      GlideExecutor executor = MockGlideExecutor.newMainThreadExecutor();
-
-      DiskCache.Factory diskCacheFactory = mock(DiskCache.Factory.class);
-      when(diskCacheFactory.build()).thenReturn(mock(DiskCache.class));
-
-      builder.setMemoryCache(mock(MemoryCache.class)).setDiskCache(diskCacheFactory)
-          .setResizeExecutor(executor).setDiskCacheExecutor(executor);
-    }
-
-    @Override
-    public void registerComponents(Context context, Glide glide, Registry registry) {
-      registerMockModelLoader(GlideUrl.class, InputStream.class,
-          new ByteArrayInputStream(new byte[0]), registry);
-      registerMockModelLoader(File.class, InputStream.class,
-          new ByteArrayInputStream(new byte[0]), registry);
-      registerMockModelLoader(File.class, ParcelFileDescriptor.class,
-          mock(ParcelFileDescriptor.class), registry);
-      registerMockModelLoader(File.class, ByteBuffer.class,
-          ByteBuffer.allocate(10), registry);
+  private static <X, Y> void registerMockModelLoader(Class<X> modelClass, Class<Y> dataClass,
+        Y loadedData, Registry registry) {
+    DataFetcher<Y> mockStreamFetcher = mock(DataFetcher.class);
+    when(mockStreamFetcher.getDataClass()).thenReturn(dataClass);
+    try {
+      doAnswer(new Util.CallDataReady<>(loadedData))
+          .when(mockStreamFetcher)
+          .loadData(isA(Priority.class), isA(DataFetcher.DataCallback.class));
+    } catch (Exception e) {
+      throw new RuntimeException(e);
     }
+    ModelLoader<X, Y> mockUrlLoader = mock(ModelLoader.class);
+    when(mockUrlLoader.buildLoadData(isA(modelClass), anyInt(), anyInt(), isA(Options.class)))
+        .thenReturn(new ModelLoader.LoadData<>(mock(Key.class), mockStreamFetcher));
+    when(mockUrlLoader.handles(isA(modelClass))).thenReturn(true);
+    ModelLoaderFactory<X, Y> mockUrlLoaderFactory = mock(ModelLoaderFactory.class);
+    when(mockUrlLoaderFactory.build(isA(MultiModelLoaderFactory.class)))
+        .thenReturn(mockUrlLoader);
 
-    private static <X, Y> void registerMockModelLoader(Class<X> modelClass, Class<Y> dataClass,
-          Y loadedData, Registry registry) {
-      DataFetcher<Y> mockStreamFetcher = mock(DataFetcher.class);
-      when(mockStreamFetcher.getDataClass()).thenReturn(dataClass);
-      try {
-        doAnswer(new Util.CallDataReady<>(loadedData))
-            .when(mockStreamFetcher)
-            .loadData(isA(Priority.class), isA(DataFetcher.DataCallback.class));
-      } catch (Exception e) {
-        throw new RuntimeException(e);
-      }
-      ModelLoader<X, Y> mockUrlLoader = mock(ModelLoader.class);
-      when(mockUrlLoader.buildLoadData(isA(modelClass), anyInt(), anyInt(), isA(Options.class)))
-          .thenReturn(new ModelLoader.LoadData<>(mock(Key.class), mockStreamFetcher));
-      when(mockUrlLoader.handles(isA(modelClass))).thenReturn(true);
-      ModelLoaderFactory<X, Y> mockUrlLoaderFactory = mock(ModelLoaderFactory.class);
-      when(mockUrlLoaderFactory.build(isA(MultiModelLoaderFactory.class)))
-          .thenReturn(mockUrlLoader);
-
-      registry.replace(modelClass, dataClass, mockUrlLoaderFactory);
-    }
+    registry.replace(modelClass, dataClass, mockUrlLoaderFactory);
   }
 
   // TODO: Extending ShadowContentResolver results in exceptions because of some state issues
@@ -850,11 +831,11 @@ public static void reset() {
       URI_TO_FILE_DESCRIPTOR.clear();
     }
 
-    public void registerInputStream(Uri uri, InputStream inputStream) {
+    void registerInputStream(Uri uri, InputStream inputStream) {
       URI_TO_INPUT_STREAMS.put(uri, inputStream);
     }
 
-    public void registerAssetFileDescriptor(Uri uri, AssetFileDescriptor assetFileDescriptor) {
+    void registerAssetFileDescriptor(Uri uri, AssetFileDescriptor assetFileDescriptor) {
       URI_TO_FILE_DESCRIPTOR.put(uri, assetFileDescriptor);
     }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java b/library/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java
index c4a05be94..e2ab082fa 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java
@@ -5,8 +5,10 @@
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
@@ -23,12 +25,13 @@
   private EngineResource<Object> engineResource;
   private EngineResource.ResourceListener listener;
   private Key cacheKey = mock(Key.class);
-  private Resource<Object> resource;
+  private Resource<Object> resource = mockResource();
 
   @Before
   public void setUp() {
     resource = mockResource();
-    engineResource = new EngineResource<>(resource, true /*isMemoryCacheable*/);
+    engineResource =
+        new EngineResource<>(resource, /*isMemoryCacheable=*/ true, /*isRecyclable=*/ true);
     listener = mock(EngineResource.ResourceListener.class);
     engineResource.setResourceListener(cacheKey, listener);
   }
@@ -140,14 +143,27 @@ public void testThrowsIfReleasedMoreThanAcquired() {
 
   @Test(expected = NullPointerException.class)
   public void testThrowsIfWrappedResourceIsNull() {
-    new EngineResource<>(null, false);
+    new EngineResource<>(/*toWrap=*/ null, /*isCacheable=*/ false, /*isRecyclable=*/ true);
   }
 
   @Test
   public void testCanSetAndGetIsCacheable() {
-    engineResource = new EngineResource<>(mockResource(), true);
+    engineResource =
+        new EngineResource<>(mockResource(), /*isCacheable=*/ true, /*isRecyclable=*/ true);
     assertTrue(engineResource.isCacheable());
-    engineResource = new EngineResource<>(mockResource(), false);
+    engineResource =
+        new EngineResource<>(mockResource(), /*isCacheable=*/ false, /*isRecyclable=*/ true);
     assertFalse(engineResource.isCacheable());
   }
+
+  @Test
+  public void release_whenNotRecycleable_doesNotRecycleResource() {
+    resource = mockResource();
+    engineResource = new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ false);
+    engineResource.setResourceListener(cacheKey, listener);
+    engineResource.recycle();
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+    verify(resource, never()).recycle();
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java b/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
index 9f17c6768..af474fa76 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
@@ -11,7 +11,6 @@
 import static org.mockito.Matchers.anyBoolean;
 import static org.mockito.Matchers.anyInt;
 import static org.mockito.Matchers.eq;
-import static org.mockito.Matchers.isNull;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
@@ -19,6 +18,7 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.os.MessageQueue.IdleHandler;
 import com.bumptech.glide.GlideContext;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
@@ -26,18 +26,19 @@
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.cache.DiskCache;
+import com.bumptech.glide.load.engine.cache.LruResourceCache;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
 import com.bumptech.glide.load.engine.executor.MockGlideExecutor;
 import com.bumptech.glide.request.ResourceCallback;
 import com.bumptech.glide.tests.BackgroundUtil;
 import com.bumptech.glide.tests.GlideShadowLooper;
-import java.lang.ref.WeakReference;
 import java.util.HashMap;
 import java.util.Map;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.RobolectricTestRunner;
@@ -117,36 +118,16 @@ public void testLoadStatusIsReturnedForExistingJob() {
 
   @Test
   public void testResourceIsReturnedFromActiveResourcesIfPresent() {
-    harness.activeResources
-        .put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
+    harness.activeResources.activate(harness.cacheKey, harness.resource);
 
     harness.doLoad();
 
     verify(harness.cb).onResourceReady(eq(harness.resource), eq(DataSource.MEMORY_CACHE));
   }
 
-  @Test
-  public void testResourceIsNotReturnedFromActiveResourcesIfRefIsCleared() {
-    harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(null));
-
-    harness.doLoad();
-
-    verify(harness.cb, never()).onResourceReady(isNull(Resource.class), isADataSource());
-  }
-
-  @Test
-  public void testKeyIsRemovedFromActiveResourcesIfRefIsCleared() {
-    harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(null));
-
-    harness.doLoad();
-
-    assertThat(harness.activeResources).doesNotContainKey(harness.cacheKey);
-  }
-
   @Test
   public void testResourceIsAcquiredIfReturnedFromActiveResources() {
-    harness.activeResources
-        .put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
+    harness.activeResources.activate(harness.cacheKey, harness.resource);
 
     harness.doLoad();
 
@@ -155,8 +136,7 @@ public void testResourceIsAcquiredIfReturnedFromActiveResources() {
 
   @Test
   public void testNewLoadIsNotStartedIfResourceIsActive() {
-    harness.activeResources
-        .put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
+    harness.activeResources.activate(harness.cacheKey, harness.resource);
 
     harness.doLoad();
 
@@ -165,28 +145,24 @@ public void testNewLoadIsNotStartedIfResourceIsActive() {
 
   @Test
   public void testNullLoadStatusIsReturnedIfResourceIsActive() {
-    harness.activeResources
-        .put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
+    harness.activeResources.activate(harness.cacheKey, harness.resource);
 
     assertNull(harness.doLoad());
   }
 
   @Test
-  public void testActiveResourcesIsNotCheckedIfReturnedFromCache() {
-    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
-    EngineResource<?> other = mock(EngineResource.class);
-    harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(other));
+  public void load_withResourceInActiveResources_doesNotCheckMemoryCache() {
+    harness.activeResources.activate(harness.cacheKey, harness.resource);
 
     harness.doLoad();
 
     verify(harness.cb).onResourceReady(eq(harness.resource), eq(DataSource.MEMORY_CACHE));
-    verify(harness.cb, never()).onResourceReady(eq(other), isADataSource());
+    verify(harness.cache, never()).remove(any(Key.class));
   }
 
   @Test
   public void testActiveResourcesIsNotCheckedIfNotMemoryCacheable() {
-    harness.activeResources
-        .put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
+    harness.activeResources.activate(harness.cacheKey, harness.resource);
 
     harness.isMemoryCacheable = false;
     harness.doLoad();
@@ -249,8 +225,8 @@ public void testResourceIsAddedToActiveResourceIfReturnedFromCache() {
     when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
 
     harness.doLoad();
-
-    assertEquals(harness.resource, harness.activeResources.get(harness.cacheKey).get());
+    EngineResource<?> activeResource = harness.activeResources.get(harness.cacheKey);
+    assertThat(activeResource).isEqualTo(harness.resource);
   }
 
   @Test
@@ -264,7 +240,7 @@ public void testResourceIsAcquiredIfReturnedFromCache() {
 
   @Test
   public void testNewLoadIsNotStartedIfResourceIsCached() {
-    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(mock(EngineResource.class));
+    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
 
     harness.doLoad();
 
@@ -273,7 +249,7 @@ public void testNewLoadIsNotStartedIfResourceIsCached() {
 
   @Test
   public void testNullLoadStatusIsReturnedForCachedResource() {
-    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(mock(EngineResource.class));
+    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
 
     Engine.LoadStatus loadStatus = harness.doLoad();
     assertNull(loadStatus);
@@ -283,7 +259,7 @@ public void testNullLoadStatusIsReturnedForCachedResource() {
   public void testRunnerIsRemovedFromRunnersOnEngineNotifiedJobComplete() {
     harness.doLoad();
 
-    harness.engine.onEngineJobComplete(harness.cacheKey, harness.resource);
+    harness.getEngine().onEngineJobComplete(harness.cacheKey, harness.resource);
 
     assertThat(harness.jobs).doesNotContainKey(harness.cacheKey);
   }
@@ -292,45 +268,45 @@ public void testRunnerIsRemovedFromRunnersOnEngineNotifiedJobComplete() {
   public void testEngineIsSetAsResourceListenerOnJobComplete() {
     harness.doLoad();
 
-    harness.engine.onEngineJobComplete(harness.cacheKey, harness.resource);
+    harness.getEngine().onEngineJobComplete(harness.cacheKey, harness.resource);
 
-    verify(harness.resource).setResourceListener(eq(harness.cacheKey), eq(harness.engine));
+    verify(harness.resource).setResourceListener(eq(harness.cacheKey), eq(harness.getEngine()));
   }
 
   @Test
   public void testEngineIsNotSetAsResourceListenerIfResourceIsNullOnJobComplete() {
     harness.doLoad();
 
-    harness.engine.onEngineJobComplete(harness.cacheKey, null);
+    harness.getEngine().onEngineJobComplete(harness.cacheKey, null);
   }
 
   @Test
   public void testResourceIsAddedToActiveResourcesOnEngineComplete() {
     when(harness.resource.isCacheable()).thenReturn(true);
-    harness.engine.onEngineJobComplete(harness.cacheKey, harness.resource);
+    harness.getEngine().onEngineJobComplete(harness.cacheKey, harness.resource);
 
-    WeakReference<EngineResource<?>> resourceRef = harness.activeResources.get(harness.cacheKey);
-    assertThat(harness.resource).isEqualTo(resourceRef.get());
+    EngineResource<?> resource = harness.activeResources.get(harness.cacheKey);
+    assertThat(harness.resource).isEqualTo(resource);
   }
 
   @Test
   public void testDoesNotPutNullResourceInActiveResourcesOnEngineComplete() {
-    harness.engine.onEngineJobComplete(harness.cacheKey, null);
-    assertThat(harness.activeResources).doesNotContainKey(harness.cacheKey);
+    harness.getEngine().onEngineJobComplete(harness.cacheKey, null);
+    assertThat(harness.activeResources.get(harness.cacheKey)).isNull();
   }
 
   @Test
   public void testDoesNotPutResourceThatIsNotCacheableInActiveResourcesOnEngineComplete() {
     when(harness.resource.isCacheable()).thenReturn(false);
-    harness.engine.onEngineJobComplete(harness.cacheKey, harness.resource);
-    assertThat(harness.activeResources).doesNotContainKey(harness.cacheKey);
+    harness.getEngine().onEngineJobComplete(harness.cacheKey, harness.resource);
+    assertThat(harness.activeResources.get(harness.cacheKey)).isNull();
   }
 
   @Test
   public void testRunnerIsRemovedFromRunnersOnEngineNotifiedJobCancel() {
     harness.doLoad();
 
-    harness.engine.onEngineJobCancelled(harness.job, harness.cacheKey);
+    harness.getEngine().onEngineJobCancelled(harness.job, harness.cacheKey);
 
     assertThat(harness.jobs).doesNotContainKey(harness.cacheKey);
   }
@@ -339,7 +315,7 @@ public void testRunnerIsRemovedFromRunnersOnEngineNotifiedJobCancel() {
   public void testJobIsNotRemovedFromJobsIfOldJobIsCancelled() {
     harness.doLoad();
 
-    harness.engine.onEngineJobCancelled(mock(EngineJob.class), harness.cacheKey);
+    harness.getEngine().onEngineJobCancelled(mock(EngineJob.class), harness.cacheKey);
 
     assertEquals(harness.job, harness.jobs.get(harness.cacheKey));
   }
@@ -358,7 +334,7 @@ public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
       }
     }).when(harness.cache).put(eq(harness.cacheKey), anyResource());
 
-    harness.engine.onResourceReleased(harness.cacheKey, harness.resource);
+    harness.getEngine().onResourceReleased(harness.cacheKey, harness.resource);
 
     verify(harness.cache).put(eq(harness.cacheKey), anyResource());
   }
@@ -366,7 +342,7 @@ public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
   @Test
   public void testResourceIsNotAddedToCacheOnReleasedIfNotCacheable() {
     when(harness.resource.isCacheable()).thenReturn(false);
-    harness.engine.onResourceReleased(harness.cacheKey, harness.resource);
+    harness.getEngine().onResourceReleased(harness.cacheKey, harness.resource);
 
     verify(harness.cache, never()).put(eq(harness.cacheKey), eq(harness.resource));
   }
@@ -374,28 +350,28 @@ public void testResourceIsNotAddedToCacheOnReleasedIfNotCacheable() {
   @Test
   public void testResourceIsRecycledIfNotCacheableWhenReleased() {
     when(harness.resource.isCacheable()).thenReturn(false);
-    harness.engine.onResourceReleased(harness.cacheKey, harness.resource);
+    harness.getEngine().onResourceReleased(harness.cacheKey, harness.resource);
     verify(harness.resourceRecycler).recycle(eq(harness.resource));
   }
 
   @Test
   public void testResourceIsRemovedFromActiveResourcesWhenReleased() {
-    harness.activeResources
-        .put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
+    harness.activeResources.activate(harness.cacheKey, harness.resource);
 
-    harness.engine.onResourceReleased(harness.cacheKey, harness.resource);
+    harness.getEngine().onResourceReleased(harness.cacheKey, harness.resource);
 
-    assertThat(harness.activeResources).doesNotContainKey(harness.cacheKey);
+    assertThat(harness.activeResources.get(harness.cacheKey)).isNull();
   }
 
   @Test
   public void testEngineAddedAsListenerToMemoryCache() {
-    verify(harness.cache).setResourceRemovedListener(eq(harness.engine));
+    harness.getEngine();
+    verify(harness.cache).setResourceRemovedListener(eq(harness.getEngine()));
   }
 
   @Test
   public void testResourceIsRecycledWhenRemovedFromCache() {
-    harness.engine.onResourceRemoved(harness.resource);
+    harness.getEngine().onResourceRemoved(harness.resource);
     verify(harness.resourceRecycler).recycle(eq(harness.resource));
   }
 
@@ -441,13 +417,13 @@ public void testFactoryIsGivenNecessaryArgumentsWithUnlimitedPool() {
   @Test
   public void testReleaseReleasesEngineResource() {
     EngineResource<Object> engineResource = mock(EngineResource.class);
-    harness.engine.release(engineResource);
+    harness.getEngine().release(engineResource);
     verify(engineResource).release();
   }
 
   @Test(expected = IllegalArgumentException.class)
   public void testThrowsIfAskedToReleaseNonEngineResource() {
-    harness.engine.release(mockResource());
+    harness.getEngine().release(mockResource());
   }
 
   @Test(expected = RuntimeException.class)
@@ -460,6 +436,59 @@ public void runTest() throws Exception {
     });
   }
 
+  @Test
+  public void load_afterResourceIsLoadedInActiveResources_returnsFromMemoryCache() {
+    when(harness.resource.isCacheable()).thenReturn(true);
+    doAnswer(new Answer() {
+      @Override
+      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+        harness.getEngine().onEngineJobComplete(harness.cacheKey, harness.resource);
+        return null;
+      }
+    }).when(harness.job).start(any(DecodeJob.class));
+    harness.doLoad();
+    harness.doLoad();
+    verify(harness.cb).onResourceReady(any(Resource.class), eq(DataSource.MEMORY_CACHE));
+  }
+
+  @Test
+  public void load_afterResourceIsLoadedAndReleased_returnsFromMemoryCache() {
+    harness.cache = new LruResourceCache(100);
+    when(harness.resource.isCacheable()).thenReturn(true);
+    doAnswer(new Answer() {
+      @Override
+      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+        harness.getEngine().onEngineJobComplete(harness.cacheKey, harness.resource);
+        return null;
+      }
+    }).when(harness.job).start(any(DecodeJob.class));
+    harness.doLoad();
+    harness.getEngine().onResourceReleased(harness.cacheKey, harness.resource);
+    harness.doLoad();
+    verify(harness.cb).onResourceReady(any(Resource.class), eq(DataSource.MEMORY_CACHE));
+  }
+
+  @Test
+  public void load_afterResourceIsGcedFromActive_returnsFromMemoryCache() {
+    when(harness.resource.getResource()).thenReturn(mock(Resource.class));
+    when(harness.resource.isCacheable()).thenReturn(true);
+    harness.cache = new LruResourceCache(100);
+    doAnswer(new Answer() {
+      @Override
+      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+        harness.getEngine().onEngineJobComplete(harness.cacheKey, harness.resource);
+        return null;
+      }
+    }).when(harness.job).start(any(DecodeJob.class));
+    harness.doLoad();
+//    harness.activeResources.get(harness.cacheKey).enqueue();
+    ArgumentCaptor<IdleHandler> captor = ArgumentCaptor.forClass(IdleHandler.class);
+    verify(GlideShadowLooper.queue).addIdleHandler(captor.capture());
+    captor.getValue().queueIdle();
+    harness.doLoad();
+    verify(harness.cb).onResourceReady(any(Resource.class), eq(DataSource.MEMORY_CACHE));
+  }
+
   private static class EngineTestHarness {
     EngineKey cacheKey = mock(EngineKey.class);
     EngineKeyFactory keyFactory = mock(EngineKeyFactory.class);
@@ -467,7 +496,7 @@ public void runTest() throws Exception {
     @SuppressWarnings("rawtypes")
     EngineResource resource = mock(EngineResource.class);
     Map<Key, EngineJob<?>> jobs = new HashMap<>();
-    Map<Key, WeakReference<EngineResource<?>>> activeResources = new HashMap<>();
+    ActiveResources activeResources = new ActiveResources();
 
     int width = 100;
     int height = 100;
@@ -475,7 +504,7 @@ public void runTest() throws Exception {
     Object model = new Object();
     MemoryCache cache = mock(MemoryCache.class);
     EngineJob<?> job;
-    Engine engine;
+    private Engine engine;
     Engine.EngineJobFactory engineJobFactory = mock(Engine.EngineJobFactory.class);
     Engine.DecodeJobFactory decodeJobFactory = mock(Engine.DecodeJobFactory.class);
     ResourceRecycler resourceRecycler = mock(ResourceRecycler.class);
@@ -491,29 +520,16 @@ public void runTest() throws Exception {
     public EngineTestHarness() {
       when(keyFactory.buildKey(eq(model), eq(signature), anyInt(), anyInt(), eq(transformations),
           eq(Object.class), eq(Object.class), eq(options))).thenReturn(cacheKey);
+      when(resource.getResource()).thenReturn(mock(Resource.class));
 
       job = mock(EngineJob.class);
 
-      engine =
-          new Engine(
-              cache,
-              mock(DiskCache.Factory.class),
-              GlideExecutor.newDiskCacheExecutor(),
-              MockGlideExecutor.newMainThreadExecutor(),
-              MockGlideExecutor.newMainThreadUnlimitedExecutor(),
-              MockGlideExecutor.newMainThreadUnlimitedExecutor(),
-              jobs,
-              keyFactory,
-              activeResources,
-              engineJobFactory,
-              decodeJobFactory,
-              resourceRecycler);
     }
 
     public Engine.LoadStatus doLoad() {
       when(engineJobFactory.build(eq(cacheKey), anyBoolean(), anyBoolean(), anyBoolean()))
           .thenReturn((EngineJob<Object>) job);
-      return engine.load(glideContext,
+      return getEngine().load(glideContext,
           model,
           signature,
           width,
@@ -532,5 +548,26 @@ public EngineTestHarness() {
           onlyRetrieveFromCache,
           cb);
     }
+
+    Engine getEngine() {
+      if (engine == null) {
+        engine =
+            new Engine(
+                cache,
+                mock(DiskCache.Factory.class),
+                GlideExecutor.newDiskCacheExecutor(),
+                MockGlideExecutor.newMainThreadExecutor(),
+                MockGlideExecutor.newMainThreadUnlimitedExecutor(),
+                MockGlideExecutor.newMainThreadUnlimitedExecutor(),
+                jobs,
+                keyFactory,
+                activeResources,
+                engineJobFactory,
+                decodeJobFactory,
+                resourceRecycler);
+      }
+      return engine;
+    }
   }
+
 }
diff --git a/library/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java b/library/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java
index 7b94a888c..96513fec5 100644
--- a/library/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java
+++ b/library/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java
@@ -6,13 +6,20 @@
 import android.os.MessageQueue;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
 import org.robolectric.shadows.ShadowLooper;
 
 @Implements(Looper.class)
 public class GlideShadowLooper extends ShadowLooper {
+  public static MessageQueue queue = mock(MessageQueue.class);
 
   @Implementation
   public static MessageQueue myQueue() {
-    return mock(MessageQueue.class);
+    return queue;
+  }
+
+  @Resetter
+  public void reset() {
+    queue = mock(MessageQueue.class);
   }
 }
