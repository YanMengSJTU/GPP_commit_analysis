diff --git a/library/src/main/java/com/bumptech/glide/RequestManager.java b/library/src/main/java/com/bumptech/glide/RequestManager.java
index 51f3a3ff4..14e2c828b 100644
--- a/library/src/main/java/com/bumptech/glide/RequestManager.java
+++ b/library/src/main/java/com/bumptech/glide/RequestManager.java
@@ -414,7 +414,7 @@ public void onDestroy() {
   }
 
   /**
-   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(URL).
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(URL)}.
    *
    * @return A new request builder for loading a {@link Drawable} using the given model.
    */
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java b/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java
index dbc67df5b..fc91f7d37 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java
@@ -4,6 +4,7 @@
 import android.os.MessageQueue;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.EngineResource.ResourceListener;
 import com.bumptech.glide.util.Preconditions;
@@ -14,7 +15,8 @@
 import java.util.Map;
 
 final class ActiveResources {
-  private final Map<Key, ResourceWeakReference> activeEngineResources = new HashMap<>();
+  @VisibleForTesting
+  final Map<Key, ResourceWeakReference> activeEngineResources = new HashMap<>();
   // Lazily instantiate to avoid exceptions if Glide is initialized on a background thread. See
   // #295.
   @Nullable
@@ -26,11 +28,19 @@ void setListener(ResourceListener listener) {
   }
 
   void activate(Key key, EngineResource<?> resource) {
-    activeEngineResources.put(key, new ResourceWeakReference(key, resource, getReferenceQueue()));
+    ResourceWeakReference removed =
+        activeEngineResources.put(
+            key, new ResourceWeakReference(key, resource, getReferenceQueue()));
+    if (removed != null) {
+      removed.reset();
+    }
   }
 
   void deactivate(Key key) {
-    activeEngineResources.remove(key);
+    ResourceWeakReference removed = activeEngineResources.remove(key);
+    if (removed != null) {
+      removed.reset();
+    }
   }
 
   @Nullable
@@ -50,7 +60,7 @@ void deactivate(Key key) {
   private void cleanupActiveReference(@NonNull ResourceWeakReference ref) {
     activeEngineResources.remove(ref.key);
 
-    if (!ref.isCacheable) {
+    if (!ref.isCacheable || ref.resource == null) {
       return;
     }
     EngineResource<?> newResource =
@@ -81,19 +91,29 @@ public boolean queueIdle() {
     }
   }
 
-  private static class ResourceWeakReference extends WeakReference<EngineResource<?>> {
+  @VisibleForTesting
+  static final class ResourceWeakReference extends WeakReference<EngineResource<?>> {
     @SuppressWarnings("WeakerAccess") @Synthetic final Key key;
-    @SuppressWarnings("WeakerAccess") @Synthetic final Resource<?> resource;
     @SuppressWarnings("WeakerAccess") @Synthetic final boolean isCacheable;
 
+    @Nullable @SuppressWarnings("WeakerAccess") @Synthetic Resource<?> resource;
+
     @Synthetic
     @SuppressWarnings("WeakerAccess")
     ResourceWeakReference(
-        Key key, EngineResource<?> r, ReferenceQueue<? super EngineResource<?>> q) {
-      super(r, q);
+        @NonNull Key key,
+        @NonNull EngineResource<?> referent,
+        @NonNull ReferenceQueue<? super EngineResource<?>> queue) {
+      super(referent, queue);
       this.key = Preconditions.checkNotNull(key);
-      this.resource = Preconditions.checkNotNull(r.getResource());
-      isCacheable = r.isCacheable();
+      this.resource =
+          referent.isCacheable() ? Preconditions.checkNotNull(referent.getResource()) : null;
+      isCacheable = referent.isCacheable();
+    }
+
+    void reset() {
+      resource = null;
+      clear();
     }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
index 30e623530..171548a81 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
@@ -116,19 +116,26 @@ public Engine(MemoryCache memoryCache,
   }
 
   /**
-   * Starts a load for the given arguments. Must be called on the main thread.
+   * Starts a load for the given arguments.
    *
-   * <p> The flow for any request is as follows: <ul> <li>Check the memory cache and provide the
-   * cached resource if present</li> <li>Check the current put of actively used resources and return
-   * the active resource if present</li> <li>Check the current put of in progress loads and add the
-   * cb to the in progress load if present</li> <li>Start a new load</li> </ul> </p>
+   * <p>Must be called on the main thread.
    *
-   * <p> Active resources are those that have been provided to at least one request and have not yet
+   * <p>The flow for any request is as follows:
+   * <ul>
+   *   <li>Check the current set of actively used resources, return the active resource if
+   *   present, and move any newly inactive resources into the memory cache.</li>
+   *   <li>Check the memory cache and provide the cached resource if present.</li>
+   *   <li>Check the current set of in progress loads and add the cb to the in progress load if
+   *   one is present.</li>
+   *   <li>Start a new load.</li>
+   * </ul>
+   *
+   * <p>Active resources are those that have been provided to at least one request and have not yet
    * been released. Once all consumers of a resource have released that resource, the resource then
    * goes to cache. If the resource is ever returned to a new consumer from cache, it is re-added to
    * the active resources. If the resource is evicted from the cache, its resources are recycled and
    * re-used if possible and the resource is discarded. There is no strict requirement that
-   * consumers release their resources so active resources are held weakly. </p>
+   * consumers release their resources so active resources are held weakly.
    *
    * @param width  The target width in pixels of the desired resource.
    * @param height The target height in pixels of the desired resource.
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java
index e9831b4e8..922c01afd 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java
@@ -29,7 +29,8 @@
  * limit, we assume a GC has occurred, stop the current allocations, and try again after a delay.
  */
 final class BitmapPreFillRunner implements Runnable {
-  private static final String TAG = "PreFillRunner";
+  @VisibleForTesting
+  static final String TAG = "PreFillRunner";
   private static final Clock DEFAULT_CLOCK = new Clock();
 
   /**
@@ -65,15 +66,23 @@
 
   // Public API.
   @SuppressWarnings("WeakerAccess")
-  public BitmapPreFillRunner(BitmapPool bitmapPool, MemoryCache memoryCache,
-      PreFillQueue allocationOrder) {
-    this(bitmapPool, memoryCache, allocationOrder, DEFAULT_CLOCK,
+  public BitmapPreFillRunner(
+      BitmapPool bitmapPool, MemoryCache memoryCache, PreFillQueue allocationOrder) {
+    this(
+        bitmapPool,
+        memoryCache,
+        allocationOrder,
+        DEFAULT_CLOCK,
         new Handler(Looper.getMainLooper()));
   }
 
   @VisibleForTesting
-  BitmapPreFillRunner(BitmapPool bitmapPool, MemoryCache memoryCache, PreFillQueue allocationOrder,
-      Clock clock, Handler handler) {
+  BitmapPreFillRunner(
+      BitmapPool bitmapPool,
+      MemoryCache memoryCache,
+      PreFillQueue allocationOrder,
+      Clock clock,
+      Handler handler) {
     this.bitmapPool = bitmapPool;
     this.memoryCache = memoryCache;
     this.toPrefill = allocationOrder;
@@ -89,24 +98,30 @@ public void cancel() {
    * Attempts to allocate {@link android.graphics.Bitmap}s and returns {@code true} if there are
    * more {@link android.graphics.Bitmap}s to allocate and {@code false} otherwise.
    */
-  private boolean allocate() {
+  @VisibleForTesting
+  boolean allocate() {
     long start = clock.now();
     while (!toPrefill.isEmpty() && !isGcDetected(start)) {
       PreFillType toAllocate = toPrefill.remove();
       final Bitmap bitmap;
       if (!seenTypes.contains(toAllocate)) {
         seenTypes.add(toAllocate);
-        bitmap = bitmapPool.getDirty(toAllocate.getWidth(), toAllocate.getHeight(),
-            toAllocate.getConfig());
+        bitmap =
+            bitmapPool.getDirty(
+                toAllocate.getWidth(), toAllocate.getHeight(), toAllocate.getConfig());
       } else {
-        bitmap = Bitmap.createBitmap(toAllocate.getWidth(), toAllocate.getHeight(),
-            toAllocate.getConfig());
+        bitmap =
+            Bitmap.createBitmap(
+                toAllocate.getWidth(), toAllocate.getHeight(), toAllocate.getConfig());
       }
 
+      // Order matters here! If the Bitmap is too large or the BitmapPool is too full, it may be
+      // recycled after the call to bitmapPool#put below.
+      int bitmapSize = Util.getBitmapByteSize(bitmap);
+
       // Don't over fill the memory cache to avoid evicting useful resources, but make sure it's
-      // not empty so
-      // we use all available space.
-      if (getFreeMemoryCacheBytes() >= Util.getBitmapByteSize(bitmap)) {
+      // not empty so that we use all available space.
+      if (getFreeMemoryCacheBytes() >= bitmapSize) {
         memoryCache.put(new UniqueKey(), BitmapResource.obtain(bitmap, bitmapPool));
       } else {
         bitmapPool.put(bitmap);
@@ -114,8 +129,8 @@ private boolean allocate() {
 
       if (Log.isLoggable(TAG, Log.DEBUG)) {
         Log.d(TAG,
-            "allocated [" + toAllocate.getWidth() + "x" + toAllocate.getHeight() + "] " + toAllocate
-                .getConfig() + " size: " + Util.getBitmapByteSize(bitmap));
+            "allocated [" + toAllocate.getWidth() + "x" + toAllocate.getHeight() + "] "
+                + toAllocate.getConfig() + " size: " + bitmapSize);
       }
     }
 
@@ -143,7 +158,7 @@ private long getNextDelay() {
     return result;
   }
 
-  private static class UniqueKey implements Key {
+  private static final class UniqueKey implements Key {
 
     @Synthetic
     @SuppressWarnings("WeakerAccess")
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/ActiveResourcesTest.java b/library/src/test/java/com/bumptech/glide/load/engine/ActiveResourcesTest.java
new file mode 100644
index 000000000..136c9f779
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/engine/ActiveResourcesTest.java
@@ -0,0 +1,326 @@
+package com.bumptech.glide.load.engine;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
+import android.os.MessageQueue.IdleHandler;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.engine.ActiveResources.ResourceWeakReference;
+import com.bumptech.glide.load.engine.EngineResource.ResourceListener;
+import com.bumptech.glide.tests.GlideShadowLooper;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(shadows = GlideShadowLooper.class)
+public class ActiveResourcesTest {
+
+  @Mock private ResourceListener listener;
+  @Mock private Key key;
+  @Mock private Resource<Object> resource;
+
+  private ActiveResources resources;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    resources = new ActiveResources();
+    resources.setListener(listener);
+  }
+
+  @Test
+  public void get_withMissingKey_returnsNull() {
+    assertThat(resources.get(key)).isNull();
+  }
+
+  @Test
+  public void get_withActiveKey_returnsResource() {
+    EngineResource<Object> expected =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, expected);
+    assertThat(resources.get(key)).isEqualTo(expected);
+  }
+
+  @Test
+  public void get_withDeactivatedKey_returnsNull() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+    resources.deactivate(key);
+    assertThat(resources.get(key)).isNull();
+  }
+
+  @Test
+  public void deactivate_withNotActiveKey_doesNotThrow() {
+    resources.deactivate(key);
+  }
+
+  @Test
+  public void get_withActiveAndClearedKey_returnsNull() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+    resources.activeEngineResources.get(key).clear();
+    assertThat(resources.get(key)).isNull();
+  }
+
+  @Test
+  public void get_withActiveAndClearedKey_andCacheableResource_callsListenerWithWrappedResource() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+    resources.activeEngineResources.get(key).clear();
+    resources.get(key);
+
+    ArgumentCaptor<EngineResource<?>> captor = getEngineResourceCaptor();
+
+    verify(listener).onResourceReleased(eq(key), captor.capture());
+
+    assertThat(captor.getValue().getResource()).isEqualTo(resource);
+  }
+
+  @Test
+  public void get_withActiveAndClearedKey_andCacheableResource_callsListenerWithNotRecycleable() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+    resources.activeEngineResources.get(key).clear();
+    resources.get(key);
+
+    ArgumentCaptor<EngineResource<?>> captor = getEngineResourceCaptor();
+
+    verify(listener).onResourceReleased(eq(key), captor.capture());
+
+    captor.getValue().recycle();
+    verify(resource, never()).recycle();
+  }
+
+  @Test
+  public void get_withActiveAndClearedKey_andCacheableResource_callsListenerWithCacheable() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+    resources.activeEngineResources.get(key).clear();
+    resources.get(key);
+
+    ArgumentCaptor<EngineResource<?>> captor = getEngineResourceCaptor();
+
+    verify(listener).onResourceReleased(eq(key), captor.capture());
+
+    assertThat(captor.getValue().isCacheable()).isTrue();
+  }
+
+  @Test
+  public void get_withActiveAndClearedKey_andNotCacheableResource_doesNotCallListener() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ false, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+    resources.activeEngineResources.get(key).clear();
+    resources.get(key);
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  @Test
+  public void queueIdle_afterResourceRemovedFromActive_doesNotCallListener() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    resources.deactivate(key);
+
+    weakRef.enqueue();
+
+    triggerQueueIdle();
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  @Test
+  public void queueIdle_withCacheableResourceInActive_callListener() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    weakRef.enqueue();
+
+    triggerQueueIdle();
+
+    ArgumentCaptor<EngineResource<?>> captor = getEngineResourceCaptor();
+
+    verify(listener).onResourceReleased(eq(key), captor.capture());
+
+    EngineResource<?> released = captor.getValue();
+    assertThat(released.getResource()).isEqualTo(resource);
+    assertThat(released.isCacheable()).isTrue();
+
+    released.recycle();
+    verify(resource, never()).recycle();
+  }
+
+  @Test
+  public void queueIdle_withNotCacheableResourceInActive_callListener() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ false, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    weakRef.enqueue();
+
+    triggerQueueIdle();
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  @Test
+  public void queueIdle_withCacheableResourceInActive_removesResourceFromActive() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    weakRef.enqueue();
+
+    triggerQueueIdle();
+
+    assertThat(resources.get(key)).isNull();
+  }
+
+  @Test
+  public void queueIdle_withNotCacheableResourceInActive_removesResourceFromActive() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ false, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    weakRef.enqueue();
+
+    triggerQueueIdle();
+
+    assertThat(resources.get(key)).isNull();
+  }
+
+  @Test
+  public void get_withQueuedReference_returnsResource() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    weakRef.enqueue();
+
+    assertThat(resources.get(key)).isEqualTo(engineResource);
+  }
+
+  @Test
+  public void get_withQueuedReference_doesNotNotifyListener() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    weakRef.enqueue();
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  @Test
+  public void queueIdle_withQueuedReferenceRetrievedFromGet_notifiesListener() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    weakRef.enqueue();
+
+    resources.get(key);
+
+    triggerQueueIdle();
+
+    ArgumentCaptor<EngineResource<?>> captor = getEngineResourceCaptor();
+    verify(listener).onResourceReleased(eq(key), captor.capture());
+    assertThat(captor.getValue().getResource()).isEqualTo(resource);
+  }
+
+  @Test
+  public void queueIdle_withQueuedReferenceRetrievedFromGetAndNotCacheable_doesNotNotifyListener() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ false, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    weakRef.enqueue();
+
+    resources.get(key);
+
+    triggerQueueIdle();
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  @Test
+  public void queueIdle_withQueuedReferenceDeactivated_doesNotNotifyListener() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    weakRef.enqueue();
+
+    resources.deactivate(key);
+
+    triggerQueueIdle();
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  @Test
+  public void queueIdle_afterReferenceQueuedThenReactived_doesNotNotifyListner() {
+    EngineResource<Object> first =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, first);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    weakRef.enqueue();
+
+    EngineResource<Object> second =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, second);
+
+    triggerQueueIdle();
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  @Test
+  public void activate_withNonCacheableResource_doesNotSaveResource() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ false, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    assertThat(resources.activeEngineResources.get(key).resource).isNull();
+  }
+
+  private void triggerQueueIdle() {
+    ArgumentCaptor<IdleHandler> captor = ArgumentCaptor.forClass(IdleHandler.class);
+    verify(GlideShadowLooper.queue).addIdleHandler(captor.capture());
+    captor.getValue().queueIdle();
+  }
+
+  @SuppressWarnings("unchecked")
+  private static ArgumentCaptor<EngineResource<?>> getEngineResourceCaptor() {
+    return (ArgumentCaptor<EngineResource<?>>) (ArgumentCaptor<?>)
+        ArgumentCaptor.forClass(EngineResource.class);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java b/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
index 3ccd97521..7680c43a7 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
@@ -16,10 +16,13 @@
 
 import android.graphics.Bitmap;
 import android.os.Handler;
+import android.util.Log;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruBitmapPool;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
+import com.bumptech.glide.load.engine.cache.MemoryCacheAdapter;
 import com.bumptech.glide.load.resource.bitmap.BitmapResource;
 import com.bumptech.glide.tests.Util.CreateBitmap;
 import com.bumptech.glide.util.Util;
@@ -37,6 +40,7 @@
 import org.mockito.stubbing.Answer;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLog;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
@@ -300,6 +304,24 @@ public void testDoesNotGetMoreThanOncePerSize() {
     // order.verify(pool, times(numBitmaps)).put(eq(bitmap));
   }
 
+  @Test
+  public void allocate_whenBitmapPoolIsAtCapacity_doesNotLogWithRecycledBitmap() {
+    ShadowLog.setLoggable(BitmapPreFillRunner.TAG, Log.VERBOSE);
+
+    int dimensions = 10;
+    Bitmap.Config config = Bitmap.Config.ARGB_8888;
+    int bitmapByteSize = Util.getBitmapByteSize(dimensions, dimensions, config);
+    PreFillType preFillType = new PreFillType.Builder(dimensions).setConfig(config).build();
+    Map<PreFillType, Integer> allocationOrder = new HashMap<>();
+    allocationOrder.put(preFillType, 1);
+    PreFillQueue queue = new PreFillQueue(allocationOrder);
+    BitmapPreFillRunner runner =
+        new BitmapPreFillRunner(
+            new LruBitmapPool(bitmapByteSize - 1), new MemoryCacheAdapter(), queue);
+
+    runner.allocate();
+  }
+
   private static final class AddBitmapPoolAnswer implements Answer<Void> {
     private final List<Bitmap> bitmaps;
 
diff --git a/library/src/test/java/com/bumptech/glide/request/ErrorRequestCoordinatorTest.java b/library/src/test/java/com/bumptech/glide/request/ErrorRequestCoordinatorTest.java
index 16d794915..0bce9056d 100644
--- a/library/src/test/java/com/bumptech/glide/request/ErrorRequestCoordinatorTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/ErrorRequestCoordinatorTest.java
@@ -24,7 +24,7 @@
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
-    coordinator = new ErrorRequestCoordinator(/*coordinator=*/ null);
+    coordinator = new ErrorRequestCoordinator(/*parent=*/ null);
     coordinator.setRequests(primary, error);
   }
 
@@ -248,7 +248,7 @@ public void recycle_recyclesPrimaryAndError() {
   public void isEquivalentTo() {
     assertThat(coordinator.isEquivalentTo(primary)).isFalse();
 
-    ErrorRequestCoordinator other = new ErrorRequestCoordinator(/*coordinator=*/ null);
+    ErrorRequestCoordinator other = new ErrorRequestCoordinator(/*parent=*/ null);
     assertThat(coordinator.isEquivalentTo(other)).isFalse();
 
     other.setRequests(primary, primary);
