diff --git a/.gitmodules b/.gitmodules
index 5ddbae6d6..89321173c 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,3 +1,6 @@
 [submodule "third_party/disklrucache"]
 	path = third_party/disklrucache
 	url = https://github.com/sjudd/DiskLruCache.git
+[submodule "library/test/src/test/resources/exif-orientation-examples"]
+	path = library/test/src/test/resources/exif-orientation-examples
+	url = https://github.com/recurser/exif-orientation-examples.git
\ No newline at end of file
diff --git a/annotation/compiler/build.gradle b/annotation/compiler/build.gradle
index 4be6596a0..b5c1ab4a4 100644
--- a/annotation/compiler/build.gradle
+++ b/annotation/compiler/build.gradle
@@ -17,8 +17,9 @@ dependencies {
     compileOnly "com.google.auto.service:auto-service:${AUTO_SERVICE_VERSION}"
     compileOnly "com.google.code.findbugs:jsr305:${JSR_305_VERSION}"
     compile project(':annotation')
+
     // This is to support com.sun.tools.javac.util.List, currently used in RootModuleGenerator.
-    compile files(Jvm.current().getToolsJar())
+    //compile files(Jvm.current().getToolsJar())
 }
 
 // Make sure running `gradlew :annotation:compiler:check` actually does full quality control.
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
index 0ee6cece8..c1c9d1179 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
@@ -90,8 +90,6 @@
   public static final Option<Boolean> ALLOW_HARDWARE_CONFIG =
       Option.memory("com.bumtpech.glide.load.resource.bitmap.Downsampler.AllowHardwareDecode");
 
-  public static boolean ignoreEXIF = true;
-
   private static final String WBMP_MIME_TYPE = "image/vnd.wap.wbmp";
   private static final String ICO_MIME_TYPE = "image/x-ico";
   private static final Set<String> NO_DOWNSAMPLE_PRE_N_MIME_TYPES =
@@ -238,7 +236,7 @@ private Bitmap decodeFromWrappedStreams(InputStream is,
     }
 
     int orientation = ImageHeaderParserUtils.getOrientation(parsers, is, byteArrayPool);
-    int degreesToRotate = ignoreEXIF ? 0 : TransformationUtils.getExifOrientationDegrees(orientation);
+    int degreesToRotate = TransformationUtils.getExifOrientationDegrees(orientation);
     boolean isExifOrientationRequired = TransformationUtils.isExifOrientationRequired(orientation);
 
     int targetWidth = requestedWidth == Target.SIZE_ORIGINAL ? sourceWidth : requestedWidth;
@@ -345,7 +343,7 @@ private static void calculateScaling(
     }
 
     final float exactScaleFactor;
-    if ((degreesToRotate == 90 || degreesToRotate == 270) && !ignoreEXIF) {
+    if ((degreesToRotate == 90 || degreesToRotate == 270)) {
       // If we're rotating the image +-90 degrees, we need to downsample accordingly so the image
       // width is decreased to near our target's height and the image height is decreased to near
       // our target width.
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
index 1c4d4812c..75d517d86 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
@@ -41,6 +41,8 @@
   private static final Paint CIRCLE_CROP_SHAPE_PAINT = new Paint(CIRCLE_CROP_PAINT_FLAGS);
   private static final Paint CIRCLE_CROP_BITMAP_PAINT;
 
+  public static boolean ignoreEXIF = true;
+
   // See #738.
   private static final Set<String> MODELS_REQUIRING_BITMAP_LOCK =
       new HashSet<>(
@@ -110,7 +112,7 @@ public static Lock getBitmapDrawableLock() {
    * Bitmap with the given dimensions is passed in as well.
    *
    * @param pool     The BitmapPool to obtain a bitmap from.
-   * @param inBitmap   The Bitmap to resize.
+   * @param inBitmap The Bitmap to resize.
    * @param width    The width in pixels of the final Bitmap.
    * @param height   The height in pixels of the final Bitmap.
    * @return The resized Bitmap (will be recycled if recycled is not null).
@@ -150,10 +152,10 @@ public static Bitmap centerCrop(@NonNull BitmapPool pool, @NonNull Bitmap inBitm
    * An expensive operation to resize the given Bitmap down so that it fits within the given
    * dimensions maintain the original proportions.
    *
-   * @param pool   The BitmapPool obtain a bitmap from.
-   * @param inBitmap  The Bitmap to shrink.
-   * @param width  The width in pixels the final image will fit within.
-   * @param height The height in pixels the final image will fit within.
+   * @param pool     The BitmapPool obtain a bitmap from.
+   * @param inBitmap The Bitmap to shrink.
+   * @param width    The width in pixels the final image will fit within.
+   * @param height   The height in pixels the final image will fit within.
    * @return A new Bitmap shrunk to fit within the given dimensions, or toFit if toFit's width or
    * height matches the given dimensions and toFit fits within the given dimensions
    */
@@ -211,10 +213,10 @@ public static Bitmap fitCenter(@NonNull BitmapPool pool, @NonNull Bitmap inBitma
    * If the Bitmap is smaller or equal to the Target it returns the original size, if not then
    * {@link #fitCenter(BitmapPool, Bitmap, int, int)} is called instead.
    *
-   * @param pool   The BitmapPool obtain a bitmap from.
-   * @param inBitmap  The Bitmap to center.
-   * @param width  The width in pixels of the target.
-   * @param height The height in pixels of the target.
+   * @param pool     The BitmapPool obtain a bitmap from.
+   * @param inBitmap The Bitmap to center.
+   * @param width    The width in pixels of the target.
+   * @param height   The height in pixels of the target.
    * @return returns input Bitmap if smaller or equal to target, or toFit if the Bitmap's width or
    * height is larger than the given dimensions
    */
@@ -238,9 +240,9 @@ public static Bitmap centerInside(@NonNull BitmapPool pool, @NonNull Bitmap inBi
    * transform. This keeps {@link android.graphics.Bitmap#hasAlpha()}} consistent before and after
    * the transformation for transformations that don't add or remove transparent pixels.
    *
-   * @param inBitmap The {@link android.graphics.Bitmap} that will be transformed.
-   * @param outBitmap   The {@link android.graphics.Bitmap} that will be returned from the
-   *                    transformation.
+   * @param inBitmap  The {@link android.graphics.Bitmap} that will be transformed.
+   * @param outBitmap The {@link android.graphics.Bitmap} that will be returned from the
+   *                  transformation.
    */
   public static void setAlpha(Bitmap inBitmap, Bitmap outBitmap) {
     outBitmap.setHasAlpha(inBitmap.hasAlpha());
@@ -279,23 +281,25 @@ public static Bitmap rotateImage(@NonNull Bitmap imageToOrient, int degreesToRot
    * @return the number of degrees to rotate
    */
   public static int getExifOrientationDegrees(int exifOrientation) {
-    final int degreesToRotate;
-    switch (exifOrientation) {
-      case ExifInterface.ORIENTATION_TRANSPOSE:
-      case ExifInterface.ORIENTATION_ROTATE_90:
-        degreesToRotate = 90;
-        break;
-      case ExifInterface.ORIENTATION_ROTATE_180:
-      case ExifInterface.ORIENTATION_FLIP_VERTICAL:
-        degreesToRotate = 180;
-        break;
-      case ExifInterface.ORIENTATION_TRANSVERSE:
-      case ExifInterface.ORIENTATION_ROTATE_270:
-        degreesToRotate = 270;
-        break;
-      default:
-        degreesToRotate = 0;
-        break;
+    int degreesToRotate = 0;
+    if (!ignoreEXIF) {
+      switch (exifOrientation) {
+        case ExifInterface.ORIENTATION_TRANSPOSE:
+        case ExifInterface.ORIENTATION_ROTATE_90:
+          degreesToRotate = 90;
+          break;
+        case ExifInterface.ORIENTATION_ROTATE_180:
+        case ExifInterface.ORIENTATION_FLIP_VERTICAL:
+          degreesToRotate = 180;
+          break;
+        case ExifInterface.ORIENTATION_TRANSVERSE:
+        case ExifInterface.ORIENTATION_ROTATE_270:
+          degreesToRotate = 270;
+          break;
+        default:
+          degreesToRotate = 0;
+          break;
+      }
     }
     return degreesToRotate;
   }
@@ -311,27 +315,27 @@ public static int getExifOrientationDegrees(int exifOrientation) {
    */
   public static Bitmap rotateImageExif(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap,
       int exifOrientation) {
-    if (!isExifOrientationRequired(exifOrientation)) {
-      return inBitmap;
-    }
-
-    final Matrix matrix = new Matrix();
-    initializeMatrixForRotation(exifOrientation, matrix);
-
-    // From Bitmap.createBitmap.
-    final RectF newRect = new RectF(0, 0, inBitmap.getWidth(), inBitmap.getHeight());
-    matrix.mapRect(newRect);
-
-    final int newWidth = Math.round(newRect.width());
-    final int newHeight = Math.round(newRect.height());
-
-    Bitmap.Config config = getNonNullConfig(inBitmap);
-    Bitmap result = pool.get(newWidth, newHeight, config);
-
-    matrix.postTranslate(-newRect.left, -newRect.top);
-
-    applyMatrix(inBitmap, result, matrix);
-    return result;
+    //if (!isExifOrientationRequired(exifOrientation)) {
+    return inBitmap;
+    //}
+
+//    final Matrix matrix = new Matrix();
+//    initializeMatrixForRotation(exifOrientation, matrix);
+//
+//    // From Bitmap.createBitmap.
+//    final RectF newRect = new RectF(0, 0, inBitmap.getWidth(), inBitmap.getHeight());
+//    matrix.mapRect(newRect);
+//
+//    final int newWidth = Math.round(newRect.width());
+//    final int newHeight = Math.round(newRect.height());
+//
+//    Bitmap.Config config = getNonNullConfig(inBitmap);
+//    Bitmap result = pool.get(newWidth, newHeight, config);
+//
+//    matrix.postTranslate(-newRect.left, -newRect.top);
+//
+//    applyMatrix(inBitmap, result, matrix);
+//    return result;
   }
 
   /**
@@ -357,10 +361,10 @@ public static boolean isExifOrientationRequired(int exifOrientation) {
    * Crop the image to a circle and resize to the specified width/height.  The circle crop will
    * have the same width and height equal to the min-edge of the result image.
    *
-   * @param pool   The BitmapPool obtain a bitmap from.
+   * @param pool       The BitmapPool obtain a bitmap from.
    * @param inBitmap   The Bitmap to resize.
-   * @param destWidth    The width in pixels of the final Bitmap.
-   * @param destHeight   The height in pixels of the final Bitmap.
+   * @param destWidth  The width in pixels of the final Bitmap.
+   * @param destHeight The height in pixels of the final Bitmap.
    * @return The resized Bitmap (will be recycled if recycled is not null).
    */
   public static Bitmap circleCrop(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap,
@@ -439,15 +443,14 @@ private static Config getAlphaSafeConfig(@NonNull Bitmap inBitmap) {
   /**
    * Creates a bitmap from a source bitmap and rounds the corners.
    *
-   * @param inBitmap the source bitmap to use as a basis for the created bitmap.
-   * @param width the width of the generated bitmap.
-   * @param height the height of the generated bitmap.
+   * @param inBitmap       the source bitmap to use as a basis for the created bitmap.
+   * @param width          the width of the generated bitmap.
+   * @param height         the height of the generated bitmap.
    * @param roundingRadius the corner radius to be applied (in device-specific pixels).
    * @return a {@link Bitmap} similar to inBitmap but with rounded corners.
    * @throws IllegalArgumentException if roundingRadius, width or height is 0 or less.
-   *
-   * @deprecated Width and height are unused and ignored. Use
-   * {@link #roundedCorners(BitmapPool, Bitmap, int)} instead.
+   * @deprecated Width and height are unused and ignored. Use {@link #roundedCorners(BitmapPool,
+   * Bitmap, int)} instead.
    */
   @Deprecated
   public static Bitmap roundedCorners(
@@ -467,7 +470,7 @@ public static Bitmap roundedCorners(
    * {@link com.bumptech.glide.request.RequestOptions#transforms(Transformation[])} and/or
    * {@link com.bumptech.glide.load.MultiTransformation}.
    *
-   * @param inBitmap the source bitmap to use as a basis for the created bitmap.
+   * @param inBitmap       the source bitmap to use as a basis for the created bitmap.
    * @param roundingRadius the corner radius to be applied (in device-specific pixels).
    * @return a {@link Bitmap} similar to inBitmap but with rounded corners.
    * @throws IllegalArgumentException if roundingRadius, width or height is 0 or less.
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java
index ba3095dc2..3d3b13ef4 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java
@@ -28,6 +28,6 @@ protected void onCreate(Bundle savedInstanceState) {
     ImageView fullscreenView = (ImageView) findViewById(R.id.fullscreen_view);
     Photo photo = getIntent().getParcelableExtra(ARG_PHOTO);
 
-    GlideApp.with(this).load(photo).apply(fitCenterTransform()).into(fullscreenView);
+    GlideApp.with(this).load("https://expertbudowy.pl/xellacompass-srv/api/v1/profile-image/46/public_file?hash=bf972930486979a57ab23c4ccbbdac61").apply(fitCenterTransform()).into(fullscreenView);
   }
 }
