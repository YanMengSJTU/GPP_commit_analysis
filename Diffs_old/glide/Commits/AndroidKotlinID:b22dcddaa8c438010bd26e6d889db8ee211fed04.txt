diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java
index 0406a1a30..f93063b6d 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java
@@ -157,7 +157,7 @@ public void run() {
 
   /** Tests #2555. */
   @Test
-  public void onStop_withRequestWithOnlyFullInProgress_nullsOutDrawableInView() {
+  public void clear_withRequestWithOnlyFullInProgress_nullsOutDrawableInView() {
     final WaitModel<Integer> mainModel = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);
     concurrency.loadUntilFirstFinish(
         GlideApp.with(context)
@@ -174,7 +174,7 @@ public void onStop_withRequestWithOnlyFullInProgress_nullsOutDrawableInView() {
         new Runnable() {
           @Override
           public void run() {
-            GlideApp.with(context).onStop();
+            GlideApp.with(context).clear(imageView);
           }
         });
 
@@ -196,6 +196,46 @@ public void run() {
     mainModel.countDown();
   }
 
+  @Test
+  public void clear_withRequestWithOnlyFullInProgress_doesNotNullOutDrawableInView() {
+    final WaitModel<Integer> mainModel = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);
+    concurrency.loadUntilFirstFinish(
+        GlideApp.with(context)
+            .load(mainModel)
+            .listener(requestListener)
+            .thumbnail(
+                GlideApp.with(context)
+                    .load(ResourceIds.raw.canonical)
+                    .listener(requestListener)
+                    .override(100, 100)),
+        imageView);
+
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.with(context).onStop();
+          }
+        });
+
+    verify(requestListener, never())
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.DATA_DISK_CACHE),
+            anyBoolean());
+    verify(requestListener, never())
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.RESOURCE_DISK_CACHE),
+            anyBoolean());
+    assertThat(imageView.getDrawable()).isNotNull();
+    mainModel.countDown();
+  }
+
   @Test
   public void onStop_withRequestWithOnlyThumbnailInProgress_doesNotNullOutDrawableInView() {
     final WaitModel<Integer> thumbModel = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);
diff --git a/library/src/main/java/com/bumptech/glide/Glide.java b/library/src/main/java/com/bumptech/glide/Glide.java
index 252edddaa..4ef954d7e 100644
--- a/library/src/main/java/com/bumptech/glide/Glide.java
+++ b/library/src/main/java/com/bumptech/glide/Glide.java
@@ -360,7 +360,8 @@ private static void throwIncorrectGlideModule(Exception e) {
       @NonNull List<RequestListener<Object>> defaultRequestListeners,
       boolean isLoggingRequestOriginsEnabled,
       boolean isImageDecoderEnabledForBitmaps,
-      int hardwareBitmapFdLimit) {
+      int hardwareBitmapFdLimit,
+      int minHardwareDimension) {
     this.engine = engine;
     this.bitmapPool = bitmapPool;
     this.arrayPool = arrayPool;
diff --git a/library/src/main/java/com/bumptech/glide/GlideBuilder.java b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
index 1162e7a6e..0e1c15e0b 100644
--- a/library/src/main/java/com/bumptech/glide/GlideBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
@@ -68,6 +68,7 @@ public RequestOptions build() {
   private boolean isImageDecoderEnabledForBitmaps;
 
   private int hardwareBitmapFdLimit = HardwareConfigState.DEFAULT_MAXIMUM_FDS_FOR_HARDWARE_CONFIGS;
+  private int minHardwareDimension = HardwareConfigState.DEFAULT_MIN_HARDWARE_DIMENSION;
 
   /**
    * Sets the {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} implementation to use
@@ -578,6 +579,7 @@ Glide build(@NonNull Context context) {
         defaultRequestListeners,
         isLoggingRequestOriginsEnabled,
         isImageDecoderEnabledForBitmaps,
-        hardwareBitmapFdLimit);
+        hardwareBitmapFdLimit,
+        minHardwareDimension);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/RequestManager.java b/library/src/main/java/com/bumptech/glide/RequestManager.java
index 0a205d266..a33e2b9ec 100644
--- a/library/src/main/java/com/bumptech/glide/RequestManager.java
+++ b/library/src/main/java/com/bumptech/glide/RequestManager.java
@@ -590,7 +590,7 @@ public void clear(@NonNull View view) {
    *
    * @param target The Target to cancel loads for.
    */
-  public synchronized void clear(@Nullable final Target<?> target) {
+  public void clear(@Nullable final Target<?> target) {
     if (target == null) {
       return;
     }
@@ -617,8 +617,8 @@ private void untrackOrDelegate(@NonNull Target<?> target) {
     // the corresponding Activity or Fragment is destroyed because retaining any reference to the
     // RequestManager leaks memory. It's possible that there's some brief period of time during or
     // immediately after onDestroy where this is reasonable, but I can't think of why.
-    if (!isOwnedByUs && !glide.removeFromManagers(target) && target.getRequest() != null) {
-      Request request = target.getRequest();
+    Request request = target.getRequest();
+    if (!isOwnedByUs && !glide.removeFromManagers(target) && request != null) {
       target.setRequest(null);
       request.clear();
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java b/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java
index bdfc03615..6e883402c 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java
@@ -106,25 +106,18 @@ synchronized void deactivate(Key key) {
   @SuppressWarnings({"WeakerAccess", "SynchronizeOnNonFinalField"})
   @Synthetic
   void cleanupActiveReference(@NonNull ResourceWeakReference ref) {
-    // Fixes a deadlock where we normally acquire the Engine lock and then the ActiveResources lock
-    // but reverse that order in this one particular test. This is definitely a bit of a hack...
-    synchronized (listener) {
-      synchronized (this) {
-        activeEngineResources.remove(ref.key);
+    synchronized (this) {
+      activeEngineResources.remove(ref.key);
 
-        if (!ref.isCacheable || ref.resource == null) {
-          return;
-        }
-        EngineResource<?> newResource =
-            new EngineResource<>(
-                ref.resource,
-                /*isMemoryCacheable=*/ true,
-                /*isRecyclable=*/ false,
-                ref.key,
-                listener);
-        listener.onResourceReleased(ref.key, newResource);
+      if (!ref.isCacheable || ref.resource == null) {
+        return;
       }
     }
+
+    EngineResource<?> newResource =
+        new EngineResource<>(
+            ref.resource, /*isMemoryCacheable=*/ true, /*isRecyclable=*/ false, ref.key, listener);
+    listener.onResourceReleased(ref.key, newResource);
   }
 
   @SuppressWarnings("WeakerAccess")
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
index 5872340cc..21bb80f34 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
@@ -388,7 +388,7 @@ public void onResourceRemoved(@NonNull final Resource<?> resource) {
   }
 
   @Override
-  public synchronized void onResourceReleased(Key cacheKey, EngineResource<?> resource) {
+  public void onResourceReleased(Key cacheKey, EngineResource<?> resource) {
     activeResources.deactivate(cacheKey);
     if (resource.isMemoryCacheable()) {
       cache.put(cacheKey, resource);
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
index bd34729c8..e99f55dc8 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
@@ -274,17 +274,22 @@ synchronized void incrementPendingCallbacks(int count) {
 
   @SuppressWarnings("WeakerAccess")
   @Synthetic
-  synchronized void decrementPendingCallbacks() {
-    stateVerifier.throwIfRecycled();
-    Preconditions.checkArgument(isDone(), "Not yet complete!");
-    int decremented = pendingCallbacks.decrementAndGet();
-    Preconditions.checkArgument(decremented >= 0, "Can't decrement below 0");
-    if (decremented == 0) {
-      if (engineResource != null) {
-        engineResource.release();
+  void decrementPendingCallbacks() {
+    EngineResource<?> toRelease = null;
+    synchronized (this) {
+      stateVerifier.throwIfRecycled();
+      Preconditions.checkArgument(isDone(), "Not yet complete!");
+      int decremented = pendingCallbacks.decrementAndGet();
+      Preconditions.checkArgument(decremented >= 0, "Can't decrement below 0");
+      if (decremented == 0) {
+        toRelease = engineResource;
+
+        release();
       }
+    }
 
-      release();
+    if (toRelease != null) {
+      toRelease.release();
     }
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
index 0b097e995..1bbc821a4 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
@@ -103,18 +103,17 @@ synchronized void acquire() {
   // listener is effectively final.
   @SuppressWarnings("SynchronizeOnNonFinalField")
   void release() {
-    // To avoid deadlock, always acquire the listener lock before our lock so that the locking
-    // scheme is consistent (Engine -> EngineResource). Violating this order leads to deadlock
-    // (b/123646037).
-    synchronized (listener) {
-      synchronized (this) {
-        if (acquired <= 0) {
-          throw new IllegalStateException("Cannot release a recycled or not yet acquired resource");
-        }
-        if (--acquired == 0) {
-          listener.onResourceReleased(key, this);
-        }
+    boolean release = false;
+    synchronized (this) {
+      if (acquired <= 0) {
+        throw new IllegalStateException("Cannot release a recycled or not yet acquired resource");
       }
+      if (--acquired == 0) {
+        release = true;
+      }
+    }
+    if (release) {
+      listener.onResourceReleased(key, this);
     }
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/ImageDecoderResourceDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/ImageDecoderResourceDecoder.java
index 11c8da20f..69be85536 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/ImageDecoderResourceDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/ImageDecoderResourceDecoder.java
@@ -1,12 +1,14 @@
 package com.bumptech.glide.load.resource;
 
 import android.annotation.SuppressLint;
+import android.graphics.ColorSpace;
 import android.graphics.ImageDecoder;
 import android.graphics.ImageDecoder.DecodeException;
 import android.graphics.ImageDecoder.ImageInfo;
 import android.graphics.ImageDecoder.OnHeaderDecodedListener;
 import android.graphics.ImageDecoder.OnPartialImageListener;
 import android.graphics.ImageDecoder.Source;
+import android.os.Build;
 import android.util.Log;
 import android.util.Size;
 import androidx.annotation.NonNull;
@@ -14,6 +16,7 @@
 import androidx.annotation.RequiresApi;
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.PreferredColorSpace;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
@@ -58,6 +61,7 @@ public final boolean handles(@NonNull Source source, @NonNull Options options) {
     final boolean isHardwareConfigAllowed =
         options.get(Downsampler.ALLOW_HARDWARE_CONFIG) != null
             && options.get(Downsampler.ALLOW_HARDWARE_CONFIG);
+    final PreferredColorSpace preferredColorSpace = options.get(Downsampler.PREFERRED_COLOR_SPACE);
 
     return decode(
         source,
@@ -125,6 +129,18 @@ public boolean onPartialImage(@NonNull DecodeException e) {
             }
 
             decoder.setTargetSize(resizeWidth, resizeHeight);
+
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
+              boolean isP3Eligible =
+                  preferredColorSpace == PreferredColorSpace.DISPLAY_P3
+                      && info.getColorSpace() != null
+                      && info.getColorSpace().isWideGamut();
+              decoder.setTargetColorSpace(
+                  ColorSpace.get(
+                      isP3Eligible ? ColorSpace.Named.DISPLAY_P3 : ColorSpace.Named.SRGB));
+            } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+              decoder.setTargetColorSpace(ColorSpace.get(ColorSpace.Named.SRGB));
+            }
           }
         });
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java
index 46bd42043..f6335d1d6 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java
@@ -23,7 +23,7 @@
    *
    * @see #FD_SIZE_LIST
    */
-  @VisibleForTesting static final int MIN_HARDWARE_DIMENSION = 128;
+  public static final int DEFAULT_MIN_HARDWARE_DIMENSION = 128;
 
   /**
    * Allows us to check to make sure we're not exceeding the FD limit for a process with hardware
@@ -58,6 +58,7 @@
   public static final int DEFAULT_MAXIMUM_FDS_FOR_HARDWARE_CONFIGS = 700;
 
   private static volatile int fdSizeLimit = DEFAULT_MAXIMUM_FDS_FOR_HARDWARE_CONFIGS;
+  private static volatile int minHardwareDimension = DEFAULT_MIN_HARDWARE_DIMENSION;
 
   private static volatile HardwareConfigState instance;
 
@@ -98,8 +99,8 @@ public boolean isHardwareConfigAllowed(
       return false;
     }
 
-    return targetWidth >= MIN_HARDWARE_DIMENSION
-        && targetHeight >= MIN_HARDWARE_DIMENSION
+    return targetWidth >= minHardwareDimension
+        && targetHeight >= minHardwareDimension
         // Make sure to call isFdSizeBelowHardwareLimit last because it has side affects.
         && isFdSizeBelowHardwareLimit();
   }
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
index ff39b7583..4c80874a0 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
@@ -93,7 +93,10 @@ public void pauseRequests() {
     isPaused = true;
     for (Request request : Util.getSnapshot(requests)) {
       if (request.isRunning()) {
-        request.clear();
+        // Avoid clearing parts of requests that may have completed (thumbnails) to avoid blinking
+        // in the UI, while still making sure that any in progress parts of requests are immediately
+        // stopped.
+        request.pause();
         pendingRequests.add(request);
       }
     }
diff --git a/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java b/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java
index 648c2efc3..5cf58ef94 100644
--- a/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java
+++ b/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java
@@ -38,6 +38,12 @@ public void clear() {
     }
   }
 
+  @Override
+  public void pause() {
+    primary.pause();
+    error.pause();
+  }
+
   @Override
   public boolean isRunning() {
     return primary.isFailed() ? error.isRunning() : primary.isRunning();
diff --git a/library/src/main/java/com/bumptech/glide/request/Request.java b/library/src/main/java/com/bumptech/glide/request/Request.java
index ac08ed719..77dcb888e 100644
--- a/library/src/main/java/com/bumptech/glide/request/Request.java
+++ b/library/src/main/java/com/bumptech/glide/request/Request.java
@@ -2,7 +2,6 @@
 
 /** A request that loads a resource for an {@link com.bumptech.glide.request.target.Target}. */
 public interface Request {
-
   /** Starts an asynchronous load. */
   void begin();
 
@@ -13,6 +12,17 @@
    */
   void clear();
 
+  /**
+   * Similar to {@link #clear} for in progress requests (or portions of a request), but does nothing
+   * if the request is already complete.
+   *
+   * <p>Unlike {@link #clear()}, this method allows implementations to act differently on subparts
+   * of a request. For example if a Request has both a thumbnail and a primary request and the
+   * thumbnail portion of the request is complete, this method allows only the primary portion of
+   * the request to be paused without clearing the previously completed thumbnail portion.
+   */
+  void pause();
+
   /** Returns true if this request is running and has not completed or failed. */
   boolean isRunning();
 
diff --git a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
index 9f02dffb9..44b6b8397 100644
--- a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
@@ -307,27 +307,37 @@ private void assertNotCallingCallbacks() {
    * @see #cancel()
    */
   @Override
-  public synchronized void clear() {
-    assertNotCallingCallbacks();
-    stateVerifier.throwIfRecycled();
-    if (status == Status.CLEARED) {
-      return;
-    }
-    cancel();
-    // Resource must be released before canNotifyStatusChanged is called.
-    if (resource != null) {
-      releaseResource(resource);
-    }
-    if (canNotifyCleared()) {
-      target.onLoadCleared(getPlaceholderDrawable());
+  public void clear() {
+    Resource<R> toRelease = null;
+    synchronized (this) {
+      assertNotCallingCallbacks();
+      stateVerifier.throwIfRecycled();
+      if (status == Status.CLEARED) {
+        return;
+      }
+      cancel();
+      // Resource must be released before canNotifyStatusChanged is called.
+      if (resource != null) {
+        toRelease = resource;
+        resource = null;
+      }
+      if (canNotifyCleared()) {
+        target.onLoadCleared(getPlaceholderDrawable());
+      }
+
+      status = Status.CLEARED;
     }
 
-    status = Status.CLEARED;
+    if (toRelease != null) {
+      engine.release(toRelease);
+    }
   }
 
-  private void releaseResource(Resource<?> resource) {
-    engine.release(resource);
-    this.resource = null;
+  @Override
+  public synchronized void pause() {
+    if (isRunning()) {
+      clear();
+    }
   }
 
   @Override
@@ -499,53 +509,64 @@ private void notifyLoadFailed() {
   @SuppressWarnings("unchecked")
   @Override
   public synchronized void onResourceReady(Resource<?> resource, DataSource dataSource) {
-    stateVerifier.throwIfRecycled();
-    loadStatus = null;
-    if (resource == null) {
-      GlideException exception =
-          new GlideException(
-              "Expected to receive a Resource<R> with an "
-                  + "object of "
-                  + transcodeClass
-                  + " inside, but instead got null.");
-      onLoadFailed(exception);
-      return;
-    }
+    Resource<?> toRelease = null;
+    try {
+      synchronized (this) {
+        stateVerifier.throwIfRecycled();
+        loadStatus = null;
+        if (resource == null) {
+          GlideException exception =
+              new GlideException(
+                  "Expected to receive a Resource<R> with an "
+                      + "object of "
+                      + transcodeClass
+                      + " inside, but instead got null.");
+          onLoadFailed(exception);
+          return;
+        }
 
-    Object received = resource.get();
-    if (received == null || !transcodeClass.isAssignableFrom(received.getClass())) {
-      releaseResource(resource);
-      GlideException exception =
-          new GlideException(
-              "Expected to receive an object of "
-                  + transcodeClass
-                  + " but instead"
-                  + " got "
-                  + (received != null ? received.getClass() : "")
-                  + "{"
-                  + received
-                  + "} inside"
-                  + " "
-                  + "Resource{"
-                  + resource
-                  + "}."
-                  + (received != null
-                      ? ""
-                      : " "
-                          + "To indicate failure return a null Resource "
-                          + "object, rather than a Resource object containing null data."));
-      onLoadFailed(exception);
-      return;
-    }
+        Object received = resource.get();
+        if (received == null || !transcodeClass.isAssignableFrom(received.getClass())) {
+          toRelease = resource;
+          this.resource = null;
+          GlideException exception =
+              new GlideException(
+                  "Expected to receive an object of "
+                      + transcodeClass
+                      + " but instead"
+                      + " got "
+                      + (received != null ? received.getClass() : "")
+                      + "{"
+                      + received
+                      + "} inside"
+                      + " "
+                      + "Resource{"
+                      + resource
+                      + "}."
+                      + (received != null
+                          ? ""
+                          : " "
+                              + "To indicate failure return a null Resource "
+                              + "object, rather than a Resource object containing null data."));
+          onLoadFailed(exception);
+          return;
+        }
 
-    if (!canSetResource()) {
-      releaseResource(resource);
-      // We can't put the status to complete before asking canSetResource().
-      status = Status.COMPLETE;
-      return;
-    }
+        if (!canSetResource()) {
+          toRelease = resource;
+          this.resource = null;
+          // We can't put the status to complete before asking canSetResource().
+          status = Status.COMPLETE;
+          return;
+        }
 
-    onResourceReady((Resource<R>) resource, (R) received, dataSource);
+        onResourceReady((Resource<R>) resource, (R) received, dataSource);
+      }
+    } finally {
+      if (toRelease != null) {
+        engine.release(toRelease);
+      }
+    }
   }
 
   /**
diff --git a/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
index 90726a656..a7e374738 100644
--- a/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
+++ b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
@@ -13,6 +13,7 @@
   private Request full;
   private Request thumb;
   private boolean isRunning;
+  private boolean isPaused;
 
   @VisibleForTesting
   ThumbnailRequestCoordinator() {
@@ -56,7 +57,7 @@ public boolean canNotifyStatusChanged(Request request) {
 
   @Override
   public boolean canNotifyCleared(Request request) {
-    return parentCanNotifyCleared() && request.equals(full);
+    return parentCanNotifyCleared() && request.equals(full) && !isPaused;
   }
 
   private boolean parentCanNotifyCleared() {
@@ -106,6 +107,7 @@ private boolean parentIsAnyResourceSet() {
   /** Starts first the thumb request and then the full request. */
   @Override
   public void begin() {
+    isPaused = false;
     isRunning = true;
     // If the request has completed previously, there's no need to restart both the full and the
     // thumb, we can just restart the full.
@@ -119,11 +121,20 @@ public void begin() {
 
   @Override
   public void clear() {
+    isPaused = false;
     isRunning = false;
     thumb.clear();
     full.clear();
   }
 
+  @Override
+  public void pause() {
+    isPaused = true;
+    isRunning = false;
+    thumb.pause();
+    full.pause();
+  }
+
   /** Returns true if the full request is still running. */
   @Override
   public boolean isRunning() {
@@ -133,7 +144,7 @@ public boolean isRunning() {
   /** Returns true if the full request is complete. */
   @Override
   public boolean isComplete() {
-    return full.isComplete() || thumb.isComplete();
+    return full.isComplete();
   }
 
   @Override
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigStateTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigStateTest.java
index 115993e90..2564d02a4 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigStateTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigStateTest.java
@@ -24,8 +24,8 @@
     BitmapFactory.Options options = new BitmapFactory.Options();
     boolean result =
         state.setHardwareConfigIfAllowed(
-            /*targetWidth=*/ HardwareConfigState.MIN_HARDWARE_DIMENSION,
-            /*targetHeight=*/ HardwareConfigState.MIN_HARDWARE_DIMENSION,
+            /*targetWidth=*/ HardwareConfigState.DEFAULT_MIN_HARDWARE_DIMENSION,
+            /*targetHeight=*/ HardwareConfigState.DEFAULT_MIN_HARDWARE_DIMENSION,
             options,
             /*isHardwareConfigAllowed=*/ true,
             /*isExifOrientationRequired=*/ false);
@@ -45,8 +45,8 @@ public void setHardwareConfigIfAllowed_withSmallerThanMinWidth_returnsFalse_does
 
     boolean result =
         state.setHardwareConfigIfAllowed(
-            /*targetWidth=*/ HardwareConfigState.MIN_HARDWARE_DIMENSION - 1,
-            /*targetHeight=*/ HardwareConfigState.MIN_HARDWARE_DIMENSION,
+            /*targetWidth=*/ HardwareConfigState.DEFAULT_MIN_HARDWARE_DIMENSION - 1,
+            /*targetHeight=*/ HardwareConfigState.DEFAULT_MIN_HARDWARE_DIMENSION,
             options,
             /*isHardwareConfigAllowed=*/ true,
             /*isExifOrientationRequired=*/ false);
@@ -66,8 +66,8 @@ public void setHardwareConfigIfAllowed_withSmallerThanMinHeight_returnsFalse_doe
 
     boolean result =
         state.setHardwareConfigIfAllowed(
-            /*targetWidth=*/ HardwareConfigState.MIN_HARDWARE_DIMENSION,
-            /*targetHeight=*/ HardwareConfigState.MIN_HARDWARE_DIMENSION - 1,
+            /*targetWidth=*/ HardwareConfigState.DEFAULT_MIN_HARDWARE_DIMENSION,
+            /*targetHeight=*/ HardwareConfigState.DEFAULT_MIN_HARDWARE_DIMENSION - 1,
             options,
             /*isHardwareConfigAllowed=*/ true,
             /*isExifOrientationRequired=*/ false);
@@ -88,8 +88,8 @@ public void setHardwareConfigIfAllowed_withSmallerThanMinHeight_returnsFalse_doe
 
     boolean result =
         state.setHardwareConfigIfAllowed(
-            /*targetWidth=*/ HardwareConfigState.MIN_HARDWARE_DIMENSION,
-            /*targetHeight=*/ HardwareConfigState.MIN_HARDWARE_DIMENSION,
+            /*targetWidth=*/ HardwareConfigState.DEFAULT_MIN_HARDWARE_DIMENSION,
+            /*targetHeight=*/ HardwareConfigState.DEFAULT_MIN_HARDWARE_DIMENSION,
             options,
             /*isHardwareConfigAllowed=*/ false,
             /*isExifOrientationRequired=*/ false);
@@ -110,8 +110,8 @@ public void setHardwareConfigIfAllowed_withSmallerThanMinHeight_returnsFalse_doe
 
     boolean result =
         state.setHardwareConfigIfAllowed(
-            /*targetWidth=*/ HardwareConfigState.MIN_HARDWARE_DIMENSION,
-            /*targetHeight=*/ HardwareConfigState.MIN_HARDWARE_DIMENSION,
+            /*targetWidth=*/ HardwareConfigState.DEFAULT_MIN_HARDWARE_DIMENSION,
+            /*targetHeight=*/ HardwareConfigState.DEFAULT_MIN_HARDWARE_DIMENSION,
             options,
             /*isHardwareConfigAllowed=*/ true,
             /*isExifOrientationRequired=*/ true);
@@ -131,8 +131,8 @@ public void setHardwareConfigIfAllowed_withOsLessThanO_returnsFalse_doesNotSetVa
 
     boolean result =
         state.setHardwareConfigIfAllowed(
-            /*targetWidth=*/ HardwareConfigState.MIN_HARDWARE_DIMENSION,
-            /*targetHeight=*/ HardwareConfigState.MIN_HARDWARE_DIMENSION,
+            /*targetWidth=*/ HardwareConfigState.DEFAULT_MIN_HARDWARE_DIMENSION,
+            /*targetHeight=*/ HardwareConfigState.DEFAULT_MIN_HARDWARE_DIMENSION,
             options,
             /*isHardwareConfigAllowed=*/ true,
             /*isExifOrientationRequired=*/ false);
@@ -158,8 +158,8 @@ public void setHardwareConfigIfAllowed_withOsLessThanO_returnsFalse_doesNotSetVa
 
       boolean result =
           state.setHardwareConfigIfAllowed(
-              /*targetWidth=*/ HardwareConfigState.MIN_HARDWARE_DIMENSION,
-              /*targetHeight=*/ HardwareConfigState.MIN_HARDWARE_DIMENSION,
+              /*targetWidth=*/ HardwareConfigState.DEFAULT_MIN_HARDWARE_DIMENSION,
+              /*targetHeight=*/ HardwareConfigState.DEFAULT_MIN_HARDWARE_DIMENSION,
               options,
               /*isHardwareConfigAllowed=*/ true,
               /*isExifOrientationRequired=*/ false);
@@ -185,8 +185,8 @@ public void setHardwareConfigIfAllowed_withDisallowedSamsungDevices_OMR1_returns
 
       boolean result =
           state.setHardwareConfigIfAllowed(
-              /*targetWidth=*/ HardwareConfigState.MIN_HARDWARE_DIMENSION,
-              /*targetHeight=*/ HardwareConfigState.MIN_HARDWARE_DIMENSION,
+              /*targetWidth=*/ HardwareConfigState.DEFAULT_MIN_HARDWARE_DIMENSION,
+              /*targetHeight=*/ HardwareConfigState.DEFAULT_MIN_HARDWARE_DIMENSION,
               options,
               /*isHardwareConfigAllowed=*/ true,
               /*isExifOrientationRequired=*/ false);
@@ -212,8 +212,8 @@ public void setHardwareConfigIfAllowed_withShortEmptyOrNullModelNames_returnsTru
 
       boolean result =
           state.setHardwareConfigIfAllowed(
-              /*targetWidth=*/ HardwareConfigState.MIN_HARDWARE_DIMENSION,
-              /*targetHeight=*/ HardwareConfigState.MIN_HARDWARE_DIMENSION,
+              /*targetWidth=*/ HardwareConfigState.DEFAULT_MIN_HARDWARE_DIMENSION,
+              /*targetHeight=*/ HardwareConfigState.DEFAULT_MIN_HARDWARE_DIMENSION,
               options,
               /*isHardwareConfigAllowed=*/ true,
               /*isExifOrientationRequired=*/ false);
diff --git a/library/test/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java b/library/test/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
index dbf11323e..c1868420c 100644
--- a/library/test/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
@@ -117,18 +117,40 @@ public void pauseRequest_withRunningRequest_pausesRequest() {
 
     tracker.pauseRequests();
 
-    assertThat(request.isCleared()).isTrue();
+    assertThat(request.isPaused()).isTrue();
   }
 
   @Test
-  public void pauseRequests_withCompletedRequest_doesNotClearRequest() {
+  public void pauseRequests_withCompletedRequest_doesNotPauseRequest() {
     FakeRequest request = new FakeRequest();
     tracker.addRequest(request);
 
     request.setIsComplete();
     tracker.pauseRequests();
 
-    assertThat(request.isCleared()).isFalse();
+    assertThat(request.isPaused()).isFalse();
+  }
+
+  @Test
+  public void pauseRequests_withFailedRequest_doesNotPauseRequest() {
+    FakeRequest request = new FakeRequest();
+    tracker.addRequest(request);
+
+    request.setIsFailed();
+    tracker.pauseRequests();
+
+    assertThat(request.isPaused()).isFalse();
+  }
+
+  @Test
+  public void pauseRequests_withClearedRequest_doesNotPauseRequest() {
+    FakeRequest request = new FakeRequest();
+    tracker.addRequest(request);
+
+    request.clear();
+    tracker.pauseRequests();
+
+    assertThat(request.isPaused()).isFalse();
   }
 
   @Test
@@ -351,6 +373,27 @@ public void testReturnsTrueFromIsPausedWhenPaused() {
     assertTrue(tracker.isPaused());
   }
 
+  @Test
+  public void pauseRequests_pausesRunningRequest() {
+    FakeRequest request = new FakeRequest();
+    request.setIsRunning();
+    tracker.addRequest(request);
+    tracker.pauseRequests();
+
+    assertThat(request.isCleared()).isTrue();
+  }
+
+  @Test
+  public void pauseRequest_doesNotPauseCompletedRequest() {
+    FakeRequest request = new FakeRequest();
+    request.setIsComplete();
+    tracker.addRequest(request);
+    tracker.pauseRequests();
+
+    assertThat(request.isComplete()).isTrue();
+    assertThat(request.isCleared()).isFalse();
+  }
+
   @Test
   public void testReturnsFalseFromIsPausedWhenResumed() {
     tracker.resumeRequests();
@@ -381,6 +424,17 @@ public void resumeRequests_afterRequestIsPausedViaPauseAllRequests_resumesReques
   }
 
   private static final class FakeRequest implements Request {
+
+    private boolean isPaused;
+
+    @Override
+    public void pause() {
+      isPaused = true;
+      if (isRunning) {
+        clear();
+      }
+    }
+
     private boolean isRunning;
     private boolean isFailed;
     private boolean isCleared;
@@ -407,6 +461,10 @@ boolean isRecycled() {
       return isRecycled;
     }
 
+    boolean isPaused() {
+      return isPaused;
+    }
+
     @Override
     public void begin() {
       if (isRunning) {
diff --git a/library/test/src/test/java/com/bumptech/glide/request/ErrorRequestCoordinatorTest.java b/library/test/src/test/java/com/bumptech/glide/request/ErrorRequestCoordinatorTest.java
index dfae194c2..8587d1b55 100644
--- a/library/test/src/test/java/com/bumptech/glide/request/ErrorRequestCoordinatorTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/ErrorRequestCoordinatorTest.java
@@ -76,6 +76,72 @@ public void clear_whenErrorIsRunning_clearsError() {
     verify(error).clear();
   }
 
+  @Test
+  public void pause_whenPrimaryIsRunning_pausesPrimary() {
+    when(primary.isRunning()).thenReturn(true);
+    coordinator.pause();
+
+    verify(primary).pause();
+  }
+
+  // Rely on the underlying implementation to ignore the pause call. It's somewhat more efficient
+  // because we don't need an additional lock.
+  @Test
+  public void pause_whenPrimaryIsComplete_doesNotPausePrimary() {
+    when(primary.isComplete()).thenReturn(true);
+    coordinator.pause();
+
+    verify(primary).pause();
+  }
+
+  // Rely on the underlying implementation to ignore the pause call. It's somewhat more efficient
+  // because we don't need an additional lock.
+  @Test
+  public void pause_whenPrimaryIsFailed_pausesPrimary() {
+    when(primary.isFailed()).thenReturn(true);
+    coordinator.pause();
+
+    verify(primary).pause();
+  }
+
+  // Rely on the underlying implementation to ignore the pause call. It's somewhat more efficient
+  // because we don't need an additional lock.
+  @Test
+  public void pause_whenErrorIsNotRunning_pausesError() {
+    when(error.isRunning()).thenReturn(false);
+    coordinator.pause();
+
+    verify(error).pause();
+  }
+
+  // Rely on the underlying implementation to ignore the pause call. It's somewhat more efficient
+  // because we don't need an additional lock.
+  @Test
+  public void pause_whenErrorIsComplete_pausesError() {
+    when(error.isComplete()).thenReturn(true);
+    coordinator.pause();
+
+    verify(error).pause();
+  }
+
+  // Rely on the underlying implementation to ignore the pause call. It's somewhat more efficient
+  // because we don't need an additional lock.
+  @Test
+  public void pause_whenErrorIsFailed_pausesError() {
+    when(error.isFailed()).thenReturn(true);
+    coordinator.pause();
+
+    verify(error).pause();
+  }
+
+  @Test
+  public void pause_whenErrorIsRunning_pausesError() {
+    when(error.isRunning()).thenReturn(true);
+    coordinator.pause();
+
+    verify(error).pause();
+  }
+
   @Test
   public void isRunning_primaryNotFailed_primaryNotRunning_returnsFalse() {
     assertThat(coordinator.isRunning()).isFalse();
diff --git a/library/test/src/test/java/com/bumptech/glide/request/SingleRequestTest.java b/library/test/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
index f0bc66ff1..f35559a1d 100644
--- a/library/test/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
@@ -224,6 +224,55 @@ public void testIsFailedAfterException() {
     assertTrue(request.isFailed());
   }
 
+  @Test
+  public void pause_whenRequestIsWaitingForASize_clearsRequest() {
+    SingleRequest<List> request = builder.build();
+
+    request.begin();
+    request.pause();
+    assertThat(request.isRunning()).isFalse();
+    assertThat(request.isCleared()).isTrue();
+  }
+
+  @Test
+  public void pause_whenRequestIsWaitingForAResource_clearsRequest() {
+    SingleRequest<List> request = builder.build();
+
+    request.begin();
+    request.onSizeReady(100, 100);
+    request.pause();
+    assertThat(request.isRunning()).isFalse();
+    assertThat(request.isCleared()).isTrue();
+  }
+
+  @Test
+  public void pause_whenComplete_doesNotClearRequest() {
+    SingleRequest<List> request = builder.build();
+
+    request.onResourceReady(builder.resource, DataSource.REMOTE);
+    request.pause();
+    assertThat(request.isComplete()).isTrue();
+  }
+
+  @Test
+  public void pause_whenFailed_doesNotClearRequest() {
+    SingleRequest<List> request = builder.build();
+
+    request.onLoadFailed(new GlideException("test"));
+    request.pause();
+    assertThat(request.isFailed()).isTrue();
+  }
+
+  @Test
+  public void pause_whenCleared_doesNotClearRequest() {
+    SingleRequest<List> request = builder.build();
+
+    request.clear();
+    request.pause();
+
+    verify(builder.target, times(1)).onLoadCleared(anyDrawableOrNull());
+  }
+
   @Test
   public void testIgnoresOnSizeReadyIfNotWaitingForSize() {
     SingleRequest<List> request = builder.build();
diff --git a/library/test/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java b/library/test/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
index ec3948c86..18b9ac449 100644
--- a/library/test/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
@@ -139,6 +139,14 @@ public void testCallsClearOnRequestsWhenCleared() {
     order.verify(full).clear();
   }
 
+  @Test
+  public void pause_pausesThumbAndFullInOrder() {
+    coordinator.pause();
+    InOrder order = inOrder(thumb, full);
+    order.verify(thumb).pause();
+    order.verify(full).pause();
+  }
+
   @Test
   public void testRecyclesRequestsWhenRecycled() {
     coordinator.recycle();
@@ -282,9 +290,9 @@ public void testIsCompleteIfFullIsComplete() {
   }
 
   @Test
-  public void testIsCompleteIfThumbIsComplete() {
+  public void isComplete_withOnlyThumbComplete_returnsFalse() {
     when(thumb.isComplete()).thenReturn(true);
-    assertTrue(coordinator.isComplete());
+    assertThat(coordinator.isComplete()).isFalse();
   }
 
   @Test
@@ -374,6 +382,26 @@ public void canNotifyCleared_withFullRequest_nonNullParent_parentCanNotClear_ret
     assertThat(coordinator.canNotifyCleared(full)).isFalse();
   }
 
+  @Test
+  public void canNotifyCleared_withFullRequest_afterPause_returnsFalse() {
+    coordinator.pause();
+    assertThat(coordinator.canNotifyCleared(full)).isFalse();
+  }
+
+  @Test
+  public void canNotifyCleared_withFullRequest_afterPauseAndResume_returnsTrue() {
+    coordinator.pause();
+    coordinator.begin();
+    assertThat(coordinator.canNotifyCleared(full)).isTrue();
+  }
+
+  @Test
+  public void canNotifyCleared_withFullRequest_afterPauseAndClear_returnsTrue() {
+    coordinator.pause();
+    coordinator.clear();
+    assertThat(coordinator.canNotifyCleared(full)).isTrue();
+  }
+
   @Test
   public void testIsEquivalentTo() {
     ThumbnailRequestCoordinator first = new ThumbnailRequestCoordinator();
