diff --git a/library/src/main/java/com/bumptech/glide/Glide.java b/library/src/main/java/com/bumptech/glide/Glide.java
index 6a2c652d1..cd5ed1372 100644
--- a/library/src/main/java/com/bumptech/glide/Glide.java
+++ b/library/src/main/java/com/bumptech/glide/Glide.java
@@ -306,7 +306,7 @@ private static void initializeGlide(
   }
 
   @Nullable
-  @SuppressWarnings({"unchecked", "TryWithIdenticalCatches"})
+  @SuppressWarnings({"unchecked", "TryWithIdenticalCatches", "PMD.UnusedFormalParameter"})
   private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules(Context context) {
     GeneratedAppGlideModule result = null;
     try {
@@ -345,6 +345,7 @@ private static void throwIncorrectGlideModule(Exception e) {
         e);
   }
 
+  @SuppressWarnings("PMD.UnusedFormalParameter")
   Glide(
       @NonNull Context context,
       @NonNull Engine engine,
@@ -358,7 +359,8 @@ private static void throwIncorrectGlideModule(Exception e) {
       @NonNull Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions,
       @NonNull List<RequestListener<Object>> defaultRequestListeners,
       boolean isLoggingRequestOriginsEnabled,
-      boolean isImageDecoderEnabledForBitmaps) {
+      boolean isImageDecoderEnabledForBitmaps,
+      int hardwareBitmapFdLimit) {
     this.engine = engine;
     this.bitmapPool = bitmapPool;
     this.arrayPool = arrayPool;
diff --git a/library/src/main/java/com/bumptech/glide/GlideBuilder.java b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
index 1f9bb52c8..1162e7a6e 100644
--- a/library/src/main/java/com/bumptech/glide/GlideBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
@@ -6,6 +6,7 @@
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import androidx.collection.ArrayMap;
+import androidx.core.os.BuildCompat;
 import com.bumptech.glide.Glide.RequestOptionsFactory;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.engine.Engine;
@@ -21,6 +22,7 @@
 import com.bumptech.glide.load.engine.cache.MemoryCache;
 import com.bumptech.glide.load.engine.cache.MemorySizeCalculator;
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.load.resource.bitmap.HardwareConfigState;
 import com.bumptech.glide.manager.ConnectivityMonitorFactory;
 import com.bumptech.glide.manager.DefaultConnectivityMonitorFactory;
 import com.bumptech.glide.manager.RequestManagerRetriever;
@@ -36,6 +38,7 @@
 import java.util.Map;
 
 /** A builder class for setting default structural classes for Glide to use. */
+@SuppressWarnings("PMD.ImmutableField")
 public final class GlideBuilder {
   private final Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions = new ArrayMap<>();
   private Engine engine;
@@ -61,8 +64,11 @@ public RequestOptions build() {
   private boolean isActiveResourceRetentionAllowed;
   @Nullable private List<RequestListener<Object>> defaultRequestListeners;
   private boolean isLoggingRequestOriginsEnabled;
+
   private boolean isImageDecoderEnabledForBitmaps;
 
+  private int hardwareBitmapFdLimit = HardwareConfigState.DEFAULT_MAXIMUM_FDS_FOR_HARDWARE_CONFIGS;
+
   /**
    * Sets the {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} implementation to use
    * to store and retrieve reused {@link android.graphics.Bitmap}s.
@@ -454,6 +460,10 @@ public GlideBuilder setLogRequestOrigins(boolean isEnabled) {
    * Set to {@code true} to make Glide use {@link android.graphics.ImageDecoder} when decoding
    * {@link Bitmap}s on Android P and higher.
    *
+   * <p>Calls to this method on versions of Android less than Q are ignored. Although ImageDecoder
+   * was added in Android O a bug prevents it from scaling images with exif orientations until Q.
+   * See b/136096254.
+   *
    * <p>Specifically {@link android.graphics.ImageDecoder} will be used in place of {@link
    * com.bumptech.glide.load.resource.bitmap.Downsampler} and {@link android.graphics.BitmapFactory}
    * to decode {@link Bitmap}s. GIFs, resources, and all other types of {@link
@@ -473,6 +483,9 @@ public GlideBuilder setLogRequestOrigins(boolean isEnabled) {
    * which may not agree.
    */
   public GlideBuilder setImageDecoderEnabledForBitmaps(boolean isEnabled) {
+    if (!BuildCompat.isAtLeastQ()) {
+      return this;
+    }
     isImageDecoderEnabledForBitmaps = isEnabled;
     return this;
   }
@@ -564,6 +577,7 @@ Glide build(@NonNull Context context) {
         defaultTransitionOptions,
         defaultRequestListeners,
         isLoggingRequestOriginsEnabled,
-        isImageDecoderEnabledForBitmaps);
+        isImageDecoderEnabledForBitmaps,
+        hardwareBitmapFdLimit);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java
index a1c4990de..46bd42043 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java
@@ -49,8 +49,15 @@
   /**
    * 700 with an error of 50 Bitmaps in between at two FDs each lets us use up to 800 FDs for
    * hardware Bitmaps.
+   *
+   * <p>Prior to P, the limit per process was 1024 FDs. In P, the limit was updated to 32k FDs per
+   * process.
+   *
+   * <p>Access to this variable will be removed in a future version without deprecation.
    */
-  private static final int MAXIMUM_FDS_FOR_HARDWARE_CONFIGS = 700;
+  public static final int DEFAULT_MAXIMUM_FDS_FOR_HARDWARE_CONFIGS = 700;
+
+  private static volatile int fdSizeLimit = DEFAULT_MAXIMUM_FDS_FOR_HARDWARE_CONFIGS;
 
   private static volatile HardwareConfigState instance;
 
@@ -143,7 +150,7 @@ private synchronized boolean isFdSizeBelowHardwareLimit() {
     if (++decodesSinceLastFdCheck >= MINIMUM_DECODES_BETWEEN_FD_CHECKS) {
       decodesSinceLastFdCheck = 0;
       int currentFds = FD_SIZE_LIST.list().length;
-      isFdSizeBelowHardwareLimit = currentFds < MAXIMUM_FDS_FOR_HARDWARE_CONFIGS;
+      isFdSizeBelowHardwareLimit = currentFds < fdSizeLimit;
 
       if (!isFdSizeBelowHardwareLimit && Log.isLoggable(Downsampler.TAG, Log.WARN)) {
         Log.w(
@@ -152,7 +159,7 @@ private synchronized boolean isFdSizeBelowHardwareLimit() {
                 + ", file descriptors "
                 + currentFds
                 + ", limit "
-                + MAXIMUM_FDS_FOR_HARDWARE_CONFIGS);
+                + fdSizeLimit);
       }
     }
 
