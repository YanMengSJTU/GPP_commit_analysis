diff --git a/.idea/inspectionProfiles/Project_Default.xml b/.idea/inspectionProfiles/Project_Default.xml
deleted file mode 100644
index 6560a9898..000000000
--- a/.idea/inspectionProfiles/Project_Default.xml
+++ /dev/null
@@ -1,36 +0,0 @@
-<component name="InspectionProjectProfileManager">
-  <profile version="1.0">
-    <option name="myName" value="Project Default" />
-    <inspection_tool class="JavaDoc" enabled="true" level="WARNING" enabled_by_default="true">
-      <option name="TOP_LEVEL_CLASS_OPTIONS">
-        <value>
-          <option name="ACCESS_JAVADOC_REQUIRED_FOR" value="none" />
-          <option name="REQUIRED_TAGS" value="" />
-        </value>
-      </option>
-      <option name="INNER_CLASS_OPTIONS">
-        <value>
-          <option name="ACCESS_JAVADOC_REQUIRED_FOR" value="none" />
-          <option name="REQUIRED_TAGS" value="" />
-        </value>
-      </option>
-      <option name="METHOD_OPTIONS">
-        <value>
-          <option name="ACCESS_JAVADOC_REQUIRED_FOR" value="none" />
-          <option name="REQUIRED_TAGS" value="@return@param@throws or @exception" />
-        </value>
-      </option>
-      <option name="FIELD_OPTIONS">
-        <value>
-          <option name="ACCESS_JAVADOC_REQUIRED_FOR" value="none" />
-          <option name="REQUIRED_TAGS" value="" />
-        </value>
-      </option>
-      <option name="IGNORE_DEPRECATED" value="false" />
-      <option name="IGNORE_JAVADOC_PERIOD" value="true" />
-      <option name="IGNORE_DUPLICATED_THROWS" value="false" />
-      <option name="IGNORE_POINT_TO_ITSELF" value="false" />
-      <option name="myAdditionalJavadocTags" value="date" />
-    </inspection_tool>
-  </profile>
-</component>
\ No newline at end of file
diff --git a/gradletest/src/main/java/com/xuge/gradletest/MainActivity.java b/gradletest/src/main/java/com/xuge/gradletest/MainActivity.java
index 0756bdc3a..b955e895f 100644
--- a/gradletest/src/main/java/com/xuge/gradletest/MainActivity.java
+++ b/gradletest/src/main/java/com/xuge/gradletest/MainActivity.java
@@ -1,11 +1,17 @@
 package com.xuge.gradletest;
 
 import android.content.Context;
+import android.graphics.drawable.Drawable;
 import android.os.Bundle;
+import android.support.annotation.Nullable;
 import android.support.v7.app.AppCompatActivity;
 import android.widget.ImageView;
 
 import com.bumptech.glide.Glide;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.GlideException;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.target.Target;
 
 public class MainActivity extends AppCompatActivity {
 
@@ -15,6 +21,7 @@ protected void onCreate(Bundle savedInstanceState) {
         setContentView(R.layout.activity_main);
 
         normalUse(this);
+
     }
 
     private void normalUse(Context context) {
@@ -23,10 +30,32 @@ private void normalUse(Context context) {
         Glide.with(context)
                 .load(url)
                 .override(300, 300)
-//                .centerCrop()
                 .fitCenter()
                 .centerInside()
+                .listener(new RequestListener<Drawable>() {
+                    @Override
+                    public boolean onLoadFailed(@Nullable GlideException e, Object model, Target<Drawable> target, boolean isFirstResource) {
+                        return false;
+                    }
+
+                    @Override
+                    public boolean onResourceReady(Drawable resource, Object model, Target<Drawable> target, DataSource dataSource, boolean isFirstResource) {
+                        return false;
+                    }
+                })
                 .into(imageView);
+
+
+
+
+
+
+
+
+
+
+
+
     }
 
     private void normalUseWithPlace(Context context) {
diff --git a/library/src/main/java/com/bumptech/glide/GlideContext.java b/library/src/main/java/com/bumptech/glide/GlideContext.java
index a587b19bd..3d6590b1d 100644
--- a/library/src/main/java/com/bumptech/glide/GlideContext.java
+++ b/library/src/main/java/com/bumptech/glide/GlideContext.java
@@ -7,12 +7,14 @@
 import android.support.annotation.NonNull;
 import android.support.annotation.VisibleForTesting;
 import android.widget.ImageView;
+
 import com.bumptech.glide.load.engine.Engine;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.request.RequestListener;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.ImageViewTargetFactory;
 import com.bumptech.glide.request.target.ViewTarget;
+
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
@@ -22,94 +24,94 @@
  * required to load resources.
  */
 public class GlideContext extends ContextWrapper {
-  @VisibleForTesting
-  static final TransitionOptions<?, ?> DEFAULT_TRANSITION_OPTIONS =
-      new GenericTransitionOptions<>();
-  private final Handler mainHandler;
-  private final ArrayPool arrayPool;
-  private final Registry registry;
-  private final ImageViewTargetFactory imageViewTargetFactory;
-  private final RequestOptions defaultRequestOptions;
-  private final List<RequestListener<Object>> defaultRequestListeners;
-  private final Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions;
-  private final Engine engine;
-  private final int logLevel;
+    @VisibleForTesting
+    static final TransitionOptions<?, ?> DEFAULT_TRANSITION_OPTIONS =
+            new GenericTransitionOptions<>();
+    private final Handler mainHandler;
+    private final ArrayPool arrayPool;
+    private final Registry registry;
+    private final ImageViewTargetFactory imageViewTargetFactory;
+    private final RequestOptions defaultRequestOptions;
+    private final List<RequestListener<Object>> defaultRequestListeners;
+    private final Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions;
+    private final Engine engine;
+    private final int logLevel;
 
-  public GlideContext(
-      @NonNull Context context,
-      @NonNull ArrayPool arrayPool,
-      @NonNull Registry registry,
-      @NonNull ImageViewTargetFactory imageViewTargetFactory,
-      @NonNull RequestOptions defaultRequestOptions,
-      @NonNull Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions,
-      @NonNull List<RequestListener<Object>> defaultRequestListeners,
-      @NonNull Engine engine,
-      int logLevel) {
-    super(context.getApplicationContext());
-    this.arrayPool = arrayPool;
-    this.registry = registry;
-    this.imageViewTargetFactory = imageViewTargetFactory;
-    this.defaultRequestOptions = defaultRequestOptions;
-    this.defaultRequestListeners = defaultRequestListeners;
-    this.defaultTransitionOptions = defaultTransitionOptions;
-    this.engine = engine;
-    this.logLevel = logLevel;
+    public GlideContext(
+            @NonNull Context context,
+            @NonNull ArrayPool arrayPool,
+            @NonNull Registry registry,
+            @NonNull ImageViewTargetFactory imageViewTargetFactory,
+            @NonNull RequestOptions defaultRequestOptions,
+            @NonNull Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions,
+            @NonNull List<RequestListener<Object>> defaultRequestListeners,
+            @NonNull Engine engine,
+            int logLevel) {
+        super(context.getApplicationContext());
+        this.arrayPool = arrayPool;
+        this.registry = registry;
+        this.imageViewTargetFactory = imageViewTargetFactory;
+        this.defaultRequestOptions = defaultRequestOptions;
+        this.defaultRequestListeners = defaultRequestListeners;
+        this.defaultTransitionOptions = defaultTransitionOptions;
+        this.engine = engine;
+        this.logLevel = logLevel;
 
-    mainHandler = new Handler(Looper.getMainLooper());
-  }
+        mainHandler = new Handler(Looper.getMainLooper());
+    }
 
-  public List<RequestListener<Object>> getDefaultRequestListeners() {
-    return defaultRequestListeners;
-  }
+    public List<RequestListener<Object>> getDefaultRequestListeners() {
+        return defaultRequestListeners;
+    }
 
-  public RequestOptions getDefaultRequestOptions() {
-    return defaultRequestOptions;
-  }
+    public RequestOptions getDefaultRequestOptions() {
+        return defaultRequestOptions;
+    }
 
-  @SuppressWarnings("unchecked")
-  @NonNull
-  public <T> TransitionOptions<?, T> getDefaultTransitionOptions(@NonNull Class<T> transcodeClass) {
-    TransitionOptions<?, ?> result = defaultTransitionOptions.get(transcodeClass);
-    if (result == null) {
-      for (Entry<Class<?>, TransitionOptions<?, ?>> value : defaultTransitionOptions.entrySet()) {
-        if (value.getKey().isAssignableFrom(transcodeClass)) {
-          result = value.getValue();
+    @SuppressWarnings("unchecked")
+    @NonNull
+    public <T> TransitionOptions<?, T> getDefaultTransitionOptions(@NonNull Class<T> transcodeClass) {
+        TransitionOptions<?, ?> result = defaultTransitionOptions.get(transcodeClass);
+        if (result == null) {
+            for (Entry<Class<?>, TransitionOptions<?, ?>> value : defaultTransitionOptions.entrySet()) {
+                if (value.getKey().isAssignableFrom(transcodeClass)) {
+                    result = value.getValue();
+                }
+            }
         }
-      }
-    }
-    if (result == null) {
-      result = DEFAULT_TRANSITION_OPTIONS;
+        if (result == null) {
+            result = DEFAULT_TRANSITION_OPTIONS;
+        }
+        return (TransitionOptions<?, T>) result;
     }
-    return (TransitionOptions<?, T>) result;
-  }
 
-  @NonNull
-  public <X> ViewTarget<ImageView, X> buildImageViewTarget(
-      @NonNull ImageView imageView, @NonNull Class<X> transcodeClass) {
-    return imageViewTargetFactory.buildTarget(imageView, transcodeClass);
-  }
+    @NonNull
+    public <X> ViewTarget<ImageView, X> buildImageViewTarget(
+            @NonNull ImageView imageView, @NonNull Class<X> transcodeClass) {
+        return imageViewTargetFactory.buildTarget(imageView, transcodeClass);
+    }
 
-  @NonNull
-  public Handler getMainHandler() {
-    return mainHandler;
-  }
+    @NonNull
+    public Handler getMainHandler() {
+        return mainHandler;
+    }
 
-  @NonNull
-  public Engine getEngine() {
-    return engine;
-  }
+    @NonNull
+    public Engine getEngine() {
+        return engine;
+    }
 
-  @NonNull
-  public Registry getRegistry() {
-    return registry;
-  }
+    @NonNull
+    public Registry getRegistry() {
+        return registry;
+    }
 
-  public int getLogLevel() {
-    return logLevel;
-  }
+    public int getLogLevel() {
+        return logLevel;
+    }
 
-  @NonNull
-  public ArrayPool getArrayPool() {
-    return arrayPool;
-  }
+    @NonNull
+    public ArrayPool getArrayPool() {
+        return arrayPool;
+    }
 }
diff --git a/library/src/main/java/com/bumptech/glide/RequestBuilder.java b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
index a01d45500..1c9f52783 100644
--- a/library/src/main/java/com/bumptech/glide/RequestBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
@@ -15,6 +15,7 @@
 import android.support.annotation.Nullable;
 import android.support.annotation.RawRes;
 import android.widget.ImageView;
+
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
 import com.bumptech.glide.request.BaseRequestOptions;
@@ -34,6 +35,7 @@
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
+
 import java.io.File;
 import java.net.URL;
 import java.util.ArrayList;
@@ -43,1035 +45,1047 @@
  * A generic class that can handle setting options and staring loads for generic resource types.
  *
  * @param <TranscodeType> The type of resource that will be delivered to the
- * {@link com.bumptech.glide.request.target.Target}.
+ *                        {@link com.bumptech.glide.request.target.Target}.
  */
 // Public API.
 @SuppressWarnings({"unused", "WeakerAccess"})
 public class RequestBuilder<TranscodeType> extends BaseRequestOptions<RequestBuilder<TranscodeType>>
-    implements Cloneable,
-    ModelTypes<RequestBuilder<TranscodeType>> {
-  // Used in generated subclasses
-  protected static final RequestOptions DOWNLOAD_ONLY_OPTIONS =
-      new RequestOptions().diskCacheStrategy(DiskCacheStrategy.DATA).priority(Priority.LOW)
-          .skipMemoryCache(true);
-
-  private final Context context;
-  private final RequestManager requestManager;
-  private final Class<TranscodeType> transcodeClass;
-  private final Glide glide;
-  private final GlideContext glideContext;
-
-  @NonNull
-  @SuppressWarnings("unchecked")
-  private TransitionOptions<?, ? super TranscodeType> transitionOptions;
-
-  @Nullable private Object model;
-  // model may occasionally be null, so to enforce that load() was called, put a boolean rather
-  // than relying on model not to be null.
-  @Nullable private List<RequestListener<TranscodeType>> requestListeners;
-  @Nullable private RequestBuilder<TranscodeType> thumbnailBuilder;
-  @Nullable private RequestBuilder<TranscodeType> errorBuilder;
-  @Nullable private Float thumbSizeMultiplier;
-  private boolean isDefaultTransitionOptionsSet = true;
-  private boolean isModelSet;
-  private boolean isThumbnailBuilt;
-
-  // We only override the method to change the return type, not the functionality.
-  @SuppressLint("CheckResult")
-  @SuppressWarnings("PMD.ConstructorCallsOverridableMethod")
-  protected RequestBuilder(
-      @NonNull Glide glide,
-      RequestManager requestManager,
-      Class<TranscodeType> transcodeClass,
-      Context context) {
-    this.glide = glide;
-    this.requestManager = requestManager;
-    this.transcodeClass = transcodeClass;
-    this.context = context;
-    this.transitionOptions = requestManager.getDefaultTransitionOptions(transcodeClass);
-    this.glideContext = glide.getGlideContext();
-
-    initRequestListeners(requestManager.getDefaultRequestListeners());
-    apply(requestManager.getDefaultRequestOptions());
-  }
-
-  @SuppressWarnings("PMD.ConstructorCallsOverridableMethod")
-  protected RequestBuilder(Class<TranscodeType> transcodeClass, RequestBuilder<?> other) {
-    this(other.glide, other.requestManager, transcodeClass, other.context);
-    model = other.model;
-    isModelSet = other.isModelSet;
-
-    apply(other);
-  }
-
-  // Casting from Object to a specific type is always safe.
-  @SuppressWarnings("unchecked")
-  // addListener always returns the same instance.
-  @SuppressLint("CheckResult")
-  private void initRequestListeners(List<RequestListener<Object>> requestListeners) {
-    for (RequestListener<Object> listener : requestListeners) {
-      addListener((RequestListener<TranscodeType>) listener);
+        implements Cloneable,
+        ModelTypes<RequestBuilder<TranscodeType>> {
+    // Used in generated subclasses
+    protected static final RequestOptions DOWNLOAD_ONLY_OPTIONS =
+            new RequestOptions().diskCacheStrategy(DiskCacheStrategy.DATA).priority(Priority.LOW)
+                    .skipMemoryCache(true);
+
+    private final Context context;
+    private final RequestManager requestManager;
+    private final Class<TranscodeType> transcodeClass;
+    private final Glide glide;
+    private final GlideContext glideContext;
+
+    @NonNull
+    @SuppressWarnings("unchecked")
+    private TransitionOptions<?, ? super TranscodeType> transitionOptions;
+
+    @Nullable
+    private Object model;
+    // model may occasionally be null, so to enforce that load() was called, put a boolean rather
+    // than relying on model not to be null.
+    @Nullable
+    private List<RequestListener<TranscodeType>> requestListeners;
+    @Nullable
+    private RequestBuilder<TranscodeType> thumbnailBuilder;
+    @Nullable
+    private RequestBuilder<TranscodeType> errorBuilder;
+    @Nullable
+    private Float thumbSizeMultiplier;
+    private boolean isDefaultTransitionOptionsSet = true;
+    private boolean isModelSet;
+    private boolean isThumbnailBuilt;
+
+    // We only override the method to change the return type, not the functionality.
+    @SuppressLint("CheckResult")
+    @SuppressWarnings("PMD.ConstructorCallsOverridableMethod")
+    protected RequestBuilder(
+            @NonNull Glide glide,
+            RequestManager requestManager,
+            Class<TranscodeType> transcodeClass,
+            Context context) {
+        this.glide = glide;
+        this.requestManager = requestManager;
+        this.transcodeClass = transcodeClass;
+        this.context = context;
+        this.transitionOptions = requestManager.getDefaultTransitionOptions(transcodeClass);
+        this.glideContext = glide.getGlideContext();
+
+        initRequestListeners(requestManager.getDefaultRequestListeners());
+        apply(requestManager.getDefaultRequestOptions());
+    }
+
+    @SuppressWarnings("PMD.ConstructorCallsOverridableMethod")
+    protected RequestBuilder(Class<TranscodeType> transcodeClass, RequestBuilder<?> other) {
+        this(other.glide, other.requestManager, transcodeClass, other.context);
+        model = other.model;
+        isModelSet = other.isModelSet;
+
+        apply(other);
+    }
+
+    // Casting from Object to a specific type is always safe.
+    @SuppressWarnings("unchecked")
+    // addListener always returns the same instance.
+    @SuppressLint("CheckResult")
+    private void initRequestListeners(List<RequestListener<Object>> requestListeners) {
+        for (RequestListener<Object> listener : requestListeners) {
+            addListener((RequestListener<TranscodeType>) listener);
+        }
+    }
+
+    /**
+     * Applies the given options to the request.
+     * <p>
+     * <p>As with {@link RequestOptions#apply(BaseRequestOptions)}, {@code #apply} only replaces those
+     * values that are explicitly set in the given {@link RequestOptions} object. If you need to
+     * completely reset all previously set options, create a new {@code RequestBuilder} instead of
+     * using this method.
+     *
+     * @return This request builder.
+     * @see RequestOptions#apply(BaseRequestOptions)
+     */
+    @NonNull
+    @CheckResult
+    @Override
+    public RequestBuilder<TranscodeType> apply(@NonNull BaseRequestOptions<?> requestOptions) {
+        Preconditions.checkNotNull(requestOptions);
+        return super.apply(requestOptions);
+    }
+
+    /**
+     * Sets the {@link TransitionOptions} to use to transition from the placeholder or thumbnail when
+     * this load completes.
+     * <p>
+     * <p>The given {@link TransitionOptions} will replace any {@link TransitionOptions} set
+     * previously.
+     *
+     * @return This request builder.
+     */
+    @NonNull
+    @CheckResult
+    public RequestBuilder<TranscodeType> transition(
+            @NonNull TransitionOptions<?, ? super TranscodeType> transitionOptions) {
+        this.transitionOptions = Preconditions.checkNotNull(transitionOptions);
+        isDefaultTransitionOptionsSet = false;
+        return this;
+    }
+
+    /**
+     * Sets a {@link RequestListener} to monitor the resource load. It's best to create a single
+     * instance of an exception handler per type of request (usually activity/fragment) rather than
+     * pass one in per request to avoid some redundant object allocation.
+     * <p>
+     * <p>Subsequent calls to this method will replace previously set listeners. To set multiple
+     * listeners, use {@link #addListener} instead.
+     *
+     * @param requestListener The request listener to use.
+     * @return This request builder.
+     */
+    @NonNull
+    @CheckResult
+    @SuppressWarnings("unchecked")
+    public RequestBuilder<TranscodeType> listener(
+            @Nullable RequestListener<TranscodeType> requestListener) {
+        this.requestListeners = null;
+        return addListener(requestListener);
+    }
+
+    /**
+     * Adds a {@link RequestListener}. If called multiple times, all passed
+     * {@link RequestListener listeners} will be called in order.
+     *
+     * @param requestListener The request listener to use. If {@code null}, this method is a noop.
+     * @return This request builder.
+     */
+    @NonNull
+    @CheckResult
+    public RequestBuilder<TranscodeType> addListener(
+            @Nullable RequestListener<TranscodeType> requestListener) {
+        if (requestListener != null) {
+            if (this.requestListeners == null) {
+                this.requestListeners = new ArrayList<>();
+            }
+            this.requestListeners.add(requestListener);
+        }
+        return this;
+    }
+
+    /**
+     * Sets a {@link RequestBuilder} that is built and run if the load started by this
+     * {@link RequestBuilder} fails.
+     * <p>
+     * <p>If this {@link RequestBuilder} uses a thumbnail that succeeds the given error
+     * {@link RequestBuilder} will be started anyway if the non-thumbnail request fails.
+     * <p>
+     * <p>Recursive calls to this method as well as calls to {@link #thumbnail(float)} and
+     * {@link #thumbnail(RequestBuilder)} are supported for the given error {@link RequestBuilder}.
+     * <p>
+     * <p>Unlike {@link #thumbnail(RequestBuilder)} and {@link #thumbnail(float)}, no options from
+     * this primary {@link RequestBuilder} are propagated to the given error {@link RequestBuilder}.
+     * Options like priority, override widths and heights and transitions must be applied
+     * independently to the error builder.
+     * <p>
+     * <p>The given {@link RequestBuilder} will start and potentially override a fallback drawable
+     * if it's set on this {@link RequestBuilder} via
+     * {@link RequestOptions#fallback(android.graphics.drawable.Drawable)} or
+     * {@link RequestOptions#fallback(int)}.
+     *
+     * @return This {@link RequestBuilder}.
+     */
+    @NonNull
+    public RequestBuilder<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> errorBuilder) {
+        this.errorBuilder = errorBuilder;
+        return this;
+    }
+
+    /**
+     * Loads and displays the resource retrieved by the given thumbnail request if it finishes before
+     * this request. Best used for loading thumbnail resources that are smaller and will be loaded
+     * more quickly than the full size resource. There are no guarantees about the order in which the
+     * requests will actually finish. However, if the thumb request completes after the full request,
+     * the thumb resource will never replace the full resource.
+     * <p>
+     * <p>Recursive calls to thumbnail are supported.
+     * <p>
+     * <p>Overrides any previous calls to this method, {@link #thumbnail(float)} and
+     * {@link #thumbnail(RequestBuilder[])}.
+     *
+     * @param thumbnailRequest The request to use to load the thumbnail.
+     * @return This request builder.
+     * @see #thumbnail(float)
+     * @see #thumbnail(RequestBuilder[])
+     */
+    @NonNull
+    @CheckResult
+    @SuppressWarnings("unchecked")
+    public RequestBuilder<TranscodeType> thumbnail(
+            @Nullable RequestBuilder<TranscodeType> thumbnailRequest) {
+        this.thumbnailBuilder = thumbnailRequest;
+
+        return this;
+    }
+
+    /**
+     * Recursively applies {@link #thumbnail(RequestBuilder)} so that the {@link RequestBuilder}s are
+     * loaded as thumbnails in the given priority order.
+     * <p>
+     * <p>{@link #thumbnail(RequestBuilder)} is applied in the order given so that the
+     * {@link RequestBuilder} at position 0 has the {@link RequestBuilder} at position 1 applied
+     * as using its thumbnail method, the {@link RequestBuilder} at position 1 has the
+     * {@link RequestBuilder} at position 2 applied using its thumbnail method and so on.
+     * <p>
+     * <p>Calling this method with an {@code null} array of {@link RequestBuilder} thumbnails or
+     * an empty array of {@link RequestBuilder} thumbnails is equivalent to calling
+     * {@link #thumbnail(RequestBuilder)} with {@code null}.
+     * <p>
+     * <p>Any individual {@link RequestBuilder} in the array of thumbnails provided here may be
+     * {@code null}. {@code null} {@link RequestBuilder}s are ignored and excluded from the recursive
+     * chain.
+     * <p>
+     * <p>The {@link RequestBuilder} objects provided here may be mutated and have any previous
+     * calls to this method or {@link #thumbnail(RequestBuilder)} methods overridden.
+     * <p>
+     * <p>Overrides any previous calls to {@link #thumbnail(RequestBuilder)},
+     * {@link #thumbnail(float)} and this method.
+     *
+     * @return This request builder.
+     * @see #thumbnail(float)
+     * @see #thumbnail(RequestBuilder)
+     */
+    @SuppressWarnings({"CheckResult", "unchecked"})
+    @NonNull
+    @CheckResult
+    public RequestBuilder<TranscodeType> thumbnail(
+            @Nullable RequestBuilder<TranscodeType>... thumbnails) {
+        if (thumbnails == null || thumbnails.length == 0) {
+            return thumbnail((RequestBuilder<TranscodeType>) null);
+        }
+
+        RequestBuilder<TranscodeType> previous = null;
+
+        // Start with the lowest priority thumbnail so that we can safely handle mutations if
+        // autoClone() is enabled by assigning the result of calling thumbnail() during the iteration.
+        // Starting with the highest priority thumbnail would prevent us from assigning the result of
+        // thumbnail because the mutated request wouldn't be used in the next iteration.
+        for (int i = thumbnails.length - 1; i >= 0; i--) {
+            RequestBuilder<TranscodeType> current = thumbnails[i];
+            // Ignore null thumbnails.
+            if (current == null) {
+                continue;
+            }
+
+            if (previous == null) {
+                // If we don't yet have our first non-null request, set it and continue.
+                previous = current;
+            } else {
+                // Otherwise make our next lowest priority request the thumbnail of our current request.
+                previous = current.thumbnail(previous);
+            }
+        }
+        return thumbnail(previous);
+    }
+
+    /**
+     * Loads a resource in an identical manner to this request except with the dimensions of the
+     * target multiplied by the given size multiplier. If the thumbnail load completes before the full
+     * size load, the thumbnail will be shown. If the thumbnail load completes after the full size
+     * load, the thumbnail will not be shown.
+     * <p>
+     * <p>Note - The thumbnail resource will be smaller than the size requested so the target (or
+     * {@link ImageView}) must be able to scale the thumbnail appropriately. See
+     * {@link android.widget.ImageView.ScaleType}.
+     * <p>
+     * <p>Almost all options will be copied from the original load, including the {@link
+     * com.bumptech.glide.load.model.ModelLoader}, {@link com.bumptech.glide.load.ResourceDecoder},
+     * and {@link com.bumptech.glide.load.Transformation}s. However,
+     * {@link com.bumptech.glide.request.RequestOptions#placeholder(int)} and
+     * {@link com.bumptech.glide.request.RequestOptions#error(int)}, and
+     * {@link #listener(RequestListener)} will only be used on the full size load and will not be
+     * copied for the thumbnail load.
+     * <p>
+     * <p>Recursive calls to thumbnail are supported.
+     * <p>
+     * <p>Overrides any previous calls to this method, {@link #thumbnail(RequestBuilder[])},
+     * and {@link #thumbnail(RequestBuilder)}.
+     *
+     * @param sizeMultiplier The multiplier to apply to the {@link Target}'s dimensions when loading
+     *                       the thumbnail.
+     * @return This request builder.
+     * @see #thumbnail(RequestBuilder)
+     * @see #thumbnail(RequestBuilder[])
+     */
+    @NonNull
+    @CheckResult
+    @SuppressWarnings("unchecked")
+    public RequestBuilder<TranscodeType> thumbnail(float sizeMultiplier) {
+        if (sizeMultiplier < 0f || sizeMultiplier > 1f) {
+            throw new IllegalArgumentException("sizeMultiplier must be between 0 and 1");
+        }
+        this.thumbSizeMultiplier = sizeMultiplier;
+
+        return this;
+    }
+
+    /**
+     * Sets the specific model to load data for.
+     *
+     * @param model The model to load data for, or null.
+     * @return This request builder.
+     */
+    @NonNull
+    @CheckResult
+    @SuppressWarnings("unchecked")
+    @Override
+    public RequestBuilder<TranscodeType> load(@Nullable Object model) {
+        return loadGeneric(model);
+    }
+
+    @NonNull
+    private RequestBuilder<TranscodeType> loadGeneric(@Nullable Object model) {
+        this.model = model;
+        isModelSet = true;
+        return this;
+    }
+
+    /**
+     * Returns an object to load the given {@link Bitmap}.
+     * <p>
+     * <p>It's almost always better to allow Glide to load {@link Bitmap}s than
+     * pass {@link Bitmap}s into Glide. If you have a custom way to obtain {@link Bitmap}s that is
+     * not supported by Glide by default, consider registering a custom
+     * {@link com.bumptech.glide.load.model.ModelLoader} or
+     * {@link com.bumptech.glide.load.ResourceDecoder} instead of using this method.
+     * <p>
+     * <p>The {@link DiskCacheStrategy} is set to {@link DiskCacheStrategy#NONE}. Previous calls to
+     * {@link #apply(BaseRequestOptions)} or previously applied {@link DiskCacheStrategy}s will be
+     * overridden by this method. Applying an {@link DiskCacheStrategy} other than
+     * {@link DiskCacheStrategy#NONE} after calling this method may result in undefined behavior.
+     * <p>
+     * <p>In memory caching relies on Object equality. The contents of the {@link Bitmap}s are not
+     * compared.
+     *
+     * @see #load(Object)
+     */
+    @NonNull
+    @CheckResult
+    @Override
+    public RequestBuilder<TranscodeType> load(@Nullable Bitmap bitmap) {
+        return loadGeneric(bitmap)
+                .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
+    }
+
+    /**
+     * Returns a request builder to load the given {@link Drawable}.
+     * <p>
+     * <p>It's almost always better to allow Glide to load {@link Bitmap}s than to pass
+     * {@link Bitmap}s into Glide using this method . If you have a custom way to obtain
+     * {@link Bitmap}s that is not supported by Glide by default, consider registering a custom
+     * {@link com.bumptech.glide.load.model.ModelLoader} or
+     * {@link com.bumptech.glide.load.ResourceDecoder} instead of using this method.
+     * <p>
+     * <p>The {@link DiskCacheStrategy} is set to {@link DiskCacheStrategy#NONE}. Previous calls to
+     * {@link #apply(BaseRequestOptions)} or previously applied {@link DiskCacheStrategy}s will be
+     * overridden by this method. Applying an {@link DiskCacheStrategy} other than
+     * {@link DiskCacheStrategy#NONE} after calling this method may result in undefined behavior.
+     * <p>
+     * <p>In memory caching relies on Object equality. The contents of the {@link Drawable}s are not
+     * compared.
+     *
+     * @see #load(Object)
+     */
+    @NonNull
+    @CheckResult
+    @Override
+    public RequestBuilder<TranscodeType> load(@Nullable Drawable drawable) {
+        return loadGeneric(drawable)
+                .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
+    }
+
+    /**
+     * Returns a request builder to load the given {@link java.lang.String}.
+     * <p>
+     * <p> Note - this method caches data using only the given String as the cache key. If the data is
+     * a Uri outside of your control, or you otherwise expect the data represented by the given String
+     * to change without the String identifier changing, Consider using
+     * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)} to
+     * mixin a signature you create that identifies the data currently at the given String that will
+     * invalidate the cache if that data changes. Alternatively, using
+     * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
+     * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
+     * appropriate.
+     * </p>
+     *
+     * @param string A file path, or a uri or url handled by
+     *               {@link com.bumptech.glide.load.model.UriLoader}.
+     * @see #load(Object)
+     */
+    @NonNull
+    @Override
+    @CheckResult
+    public RequestBuilder<TranscodeType> load(@Nullable String string) {
+        return loadGeneric(string);
+    }
+
+    /**
+     * Returns a request builder to load the given {@link Uri}.
+     * <p>
+     * <p> Note - this method caches data at Uris using only the Uri itself as the cache key. The data
+     * represented by Uris from some content providers may change without the Uri changing, which
+     * means using this method can lead to displaying stale data. Consider using
+     * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)} to
+     * mixin a signature you create based on the data at the given Uri that will invalidate the cache
+     * if that data changes. Alternatively, using
+     * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
+     * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
+     * appropriate. </p>
+     *
+     * @param uri The Uri representing the image. Must be of a type handled by
+     *            {@link com.bumptech.glide.load.model.UriLoader}.
+     * @see #load(Object)
+     */
+    @NonNull
+    @CheckResult
+    @Override
+    public RequestBuilder<TranscodeType> load(@Nullable Uri uri) {
+        return loadGeneric(uri);
     }
-  }
-
-  /**
-   * Applies the given options to the request.
-   *
-   * <p>As with {@link RequestOptions#apply(BaseRequestOptions)}, {@code #apply} only replaces those
-   * values that are explicitly set in the given {@link RequestOptions} object. If you need to
-   * completely reset all previously set options, create a new {@code RequestBuilder} instead of
-   * using this method.
-   *
-   * @see RequestOptions#apply(BaseRequestOptions)
-   * @return This request builder.
-   */
-  @NonNull
-  @CheckResult
-  @Override
-  public RequestBuilder<TranscodeType> apply(@NonNull BaseRequestOptions<?> requestOptions) {
-    Preconditions.checkNotNull(requestOptions);
-    return super.apply(requestOptions);
-  }
-
-  /**
-   * Sets the {@link TransitionOptions} to use to transition from the placeholder or thumbnail when
-   * this load completes.
-   *
-   * <p>The given {@link TransitionOptions} will replace any {@link TransitionOptions} set
-   * previously.
-   *
-   * @return This request builder.
-   */
-  @NonNull
-  @CheckResult
-  public RequestBuilder<TranscodeType> transition(
-      @NonNull TransitionOptions<?, ? super TranscodeType> transitionOptions) {
-    this.transitionOptions = Preconditions.checkNotNull(transitionOptions);
-    isDefaultTransitionOptionsSet = false;
-    return this;
-  }
-
-  /**
-   * Sets a {@link RequestListener} to monitor the resource load. It's best to create a single
-   * instance of an exception handler per type of request (usually activity/fragment) rather than
-   * pass one in per request to avoid some redundant object allocation.
-   *
-   * <p>Subsequent calls to this method will replace previously set listeners. To set multiple
-   * listeners, use {@link #addListener} instead.
-   *
-   * @param requestListener The request listener to use.
-   * @return This request builder.
-   */
-  @NonNull
-  @CheckResult
-  @SuppressWarnings("unchecked")
-  public RequestBuilder<TranscodeType> listener(
-      @Nullable RequestListener<TranscodeType> requestListener) {
-    this.requestListeners = null;
-    return addListener(requestListener);
-  }
-
-  /**
-   * Adds a {@link RequestListener}. If called multiple times, all passed
-   * {@link RequestListener listeners} will be called in order.
-   *
-   * @param requestListener The request listener to use. If {@code null}, this method is a noop.
-   * @return This request builder.
-   */
-  @NonNull
-  @CheckResult
-  public RequestBuilder<TranscodeType> addListener(
-      @Nullable RequestListener<TranscodeType> requestListener) {
-    if (requestListener != null) {
-      if (this.requestListeners == null) {
-        this.requestListeners = new ArrayList<>();
-      }
-      this.requestListeners.add(requestListener);
+
+    /**
+     * Returns a request builder to load the given {@link File}.
+     * <p>
+     * <p>Note - this method caches data for Files using only the file path itself as the cache key.
+     * The data in the File can change so using this method can lead to displaying stale data. If you
+     * expect the data in the File to change, Consider using
+     * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)}
+     * to mixin a signature you create that identifies the data currently in the File that will
+     * invalidate the cache if that data changes. Alternatively, using
+     * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
+     * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
+     * appropriate.
+     *
+     * @param file The File containing the image
+     * @see #load(Object)
+     */
+    @NonNull
+    @CheckResult
+    @Override
+    public RequestBuilder<TranscodeType> load(@Nullable File file) {
+        return loadGeneric(file);
     }
-    return this;
-  }
-
-  /**
-   * Sets a {@link RequestBuilder} that is built and run if the load started by this
-   * {@link RequestBuilder} fails.
-   *
-   * <p>If this {@link RequestBuilder} uses a thumbnail that succeeds the given error
-   * {@link RequestBuilder} will be started anyway if the non-thumbnail request fails.
-   *
-   * <p>Recursive calls to this method as well as calls to {@link #thumbnail(float)} and
-   * {@link #thumbnail(RequestBuilder)} are supported for the given error {@link RequestBuilder}.
-   *
-   * <p>Unlike {@link #thumbnail(RequestBuilder)} and {@link #thumbnail(float)}, no options from
-   * this primary {@link RequestBuilder} are propagated to the given error {@link RequestBuilder}.
-   * Options like priority, override widths and heights and transitions must be applied
-   * independently to the error builder.
-   *
-   * <p>The given {@link RequestBuilder} will start and potentially override a fallback drawable
-   * if it's set on this {@link RequestBuilder} via
-   * {@link RequestOptions#fallback(android.graphics.drawable.Drawable)} or
-   * {@link RequestOptions#fallback(int)}.
-   *
-   * @return This {@link RequestBuilder}.
-   */
-  @NonNull
-  public RequestBuilder<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> errorBuilder) {
-    this.errorBuilder = errorBuilder;
-    return this;
-  }
-
-  /**
-   * Loads and displays the resource retrieved by the given thumbnail request if it finishes before
-   * this request. Best used for loading thumbnail resources that are smaller and will be loaded
-   * more quickly than the full size resource. There are no guarantees about the order in which the
-   * requests will actually finish. However, if the thumb request completes after the full request,
-   * the thumb resource will never replace the full resource.
-   *
-   * <p>Recursive calls to thumbnail are supported.
-   *
-   * <p>Overrides any previous calls to this method, {@link #thumbnail(float)} and
-   * {@link #thumbnail(RequestBuilder[])}.
-   *
-   * @see #thumbnail(float)
-   * @see #thumbnail(RequestBuilder[])
-   *
-   * @param thumbnailRequest The request to use to load the thumbnail.
-   * @return This request builder.
-   */
-  @NonNull
-  @CheckResult
-  @SuppressWarnings("unchecked")
-  public RequestBuilder<TranscodeType> thumbnail(
-      @Nullable RequestBuilder<TranscodeType> thumbnailRequest) {
-    this.thumbnailBuilder = thumbnailRequest;
-
-    return this;
-  }
-
-  /**
-   * Recursively applies {@link #thumbnail(RequestBuilder)} so that the {@link RequestBuilder}s are
-   * loaded as thumbnails in the given priority order.
-   *
-   * <p>{@link #thumbnail(RequestBuilder)} is applied in the order given so that the
-   * {@link RequestBuilder} at position 0 has the {@link RequestBuilder} at position 1 applied
-   * as using its thumbnail method, the {@link RequestBuilder} at position 1 has the
-   * {@link RequestBuilder} at position 2 applied using its thumbnail method and so on.
-   *
-   * <p>Calling this method with an {@code null} array of {@link RequestBuilder} thumbnails or
-   * an empty array of {@link RequestBuilder} thumbnails is equivalent to calling
-   * {@link #thumbnail(RequestBuilder)} with {@code null}.
-   *
-   * <p>Any individual {@link RequestBuilder} in the array of thumbnails provided here may be
-   * {@code null}. {@code null} {@link RequestBuilder}s are ignored and excluded from the recursive
-   * chain.
-   *
-   * <p>The {@link RequestBuilder} objects provided here may be mutated and have any previous
-   * calls to this method or {@link #thumbnail(RequestBuilder)} methods overridden.
-   *
-   * <p>Overrides any previous calls to {@link #thumbnail(RequestBuilder)},
-   * {@link #thumbnail(float)} and this method.
-   *
-   * @see #thumbnail(float)
-   * @see #thumbnail(RequestBuilder)
-   *
-   * @return This request builder.
-   */
-  @SuppressWarnings({"CheckResult", "unchecked"})
-  @NonNull
-  @CheckResult
-  public RequestBuilder<TranscodeType> thumbnail(
-      @Nullable RequestBuilder<TranscodeType>... thumbnails) {
-    if (thumbnails == null || thumbnails.length == 0) {
-      return thumbnail((RequestBuilder<TranscodeType>) null);
+
+    /**
+     * Returns a request builder that uses the
+     * {@link com.bumptech.glide.load.model.ModelLoaderFactory} currently registered or
+     * {@link Integer} to load the image represented by the given {@link Integer} resource id.
+     * Defaults to {@link com.bumptech.glide.load.model.ResourceLoader} to load resource id models.
+     * <p>
+     * <p>By default this method adds a version code based signature to the cache key used to cache
+     * this resource in Glide. This signature is sufficient to guarantee that end users will see the
+     * most up to date versions of your Drawables, but during development if you do not increment your
+     * version code before each install and you replace a Drawable with different data without
+     * changing the Drawable name, you may see inconsistent cached data. To get around this, consider
+     * using {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} via
+     * {@link RequestOptions#diskCacheStrategy(com.bumptech.glide.load.engine.DiskCacheStrategy)}
+     * during development, and re-enabling the default
+     * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESOURCE} for release builds.
+     * <p>
+     * <p>This method will load non-{@link android.graphics.Bitmap} resources like
+     * {@link android.graphics.drawable.VectorDrawable}s. Although Glide makes a best effort to apply
+     * {@link com.bumptech.glide.load.Transformation}s to these {@link Drawable}s by either extracting
+     * the underlying {@link Bitmap} or by converting the {@link Drawable} to a {@link Bitmap}, Glide
+     * is still not able to transform all types of resources. Animated {@link Drawable}s cannot be
+     * transformed (other than {@link com.bumptech.glide.load.resource.gif.GifDrawable}). To avoid
+     * load failures if a {@link Drawable} can't be transformed, use the optional transformation
+     * methods like {@link RequestOptions#optionalTransform(Class, Transformation)}.
+     * <p>
+     * <p>In some cases converting {@link Drawable}s to {@link Bitmap}s may be inefficient. Use this
+     * method, especially in conjunction with {@link com.bumptech.glide.load.Transformation}s with
+     * caution for non-{@link Bitmap} {@link Drawable}s.
+     *
+     * @see #load(Integer)
+     * @see com.bumptech.glide.signature.ApplicationVersionSignature
+     */
+    @NonNull
+    @CheckResult
+    @Override
+    public RequestBuilder<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer resourceId) {
+        return loadGeneric(resourceId).apply(signatureOf(ApplicationVersionSignature.obtain(context)));
     }
 
-    RequestBuilder<TranscodeType> previous = null;
-
-    // Start with the lowest priority thumbnail so that we can safely handle mutations if
-    // autoClone() is enabled by assigning the result of calling thumbnail() during the iteration.
-    // Starting with the highest priority thumbnail would prevent us from assigning the result of
-    // thumbnail because the mutated request wouldn't be used in the next iteration.
-    for (int i = thumbnails.length - 1; i >= 0; i--) {
-      RequestBuilder<TranscodeType> current = thumbnails[i];
-      // Ignore null thumbnails.
-      if (current == null) {
-        continue;
-      }
-
-      if (previous == null) {
-        // If we don't yet have our first non-null request, set it and continue.
-        previous = current;
-      } else {
-        // Otherwise make our next lowest priority request the thumbnail of our current request.
-        previous = current.thumbnail(previous);
-      }
+    /**
+     * Returns a request builder to load the given {@link URL}.
+     *
+     * @param url The URL representing the image.
+     * @see #load(Object)
+     * @deprecated The {@link java.net.URL} class has
+     * <a href="http://goo.gl/c4hHNu">a number of performance problems</a> and should generally be
+     * avoided when possible. Prefer {@link #load(android.net.Uri)} or {@link #load(String)}.
+     */
+    @Deprecated
+    @CheckResult
+    @Override
+    public RequestBuilder<TranscodeType> load(@Nullable URL url) {
+        return loadGeneric(url);
     }
-    return thumbnail(previous);
-  }
-
-  /**
-   * Loads a resource in an identical manner to this request except with the dimensions of the
-   * target multiplied by the given size multiplier. If the thumbnail load completes before the full
-   * size load, the thumbnail will be shown. If the thumbnail load completes after the full size
-   * load, the thumbnail will not be shown.
-   *
-   * <p>Note - The thumbnail resource will be smaller than the size requested so the target (or
-   * {@link ImageView}) must be able to scale the thumbnail appropriately. See
-   * {@link android.widget.ImageView.ScaleType}.
-   *
-   * <p>Almost all options will be copied from the original load, including the {@link
-   * com.bumptech.glide.load.model.ModelLoader}, {@link com.bumptech.glide.load.ResourceDecoder},
-   * and {@link com.bumptech.glide.load.Transformation}s. However,
-   * {@link com.bumptech.glide.request.RequestOptions#placeholder(int)} and
-   * {@link com.bumptech.glide.request.RequestOptions#error(int)}, and
-   * {@link #listener(RequestListener)} will only be used on the full size load and will not be
-   * copied for the thumbnail load.
-   *
-   * <p>Recursive calls to thumbnail are supported.
-   *
-   * <p>Overrides any previous calls to this method, {@link #thumbnail(RequestBuilder[])},
-   *  and {@link #thumbnail(RequestBuilder)}.
-   *
-   * @see #thumbnail(RequestBuilder)
-   * @see #thumbnail(RequestBuilder[])
-   *
-   * @param sizeMultiplier The multiplier to apply to the {@link Target}'s dimensions when loading
-   *                       the thumbnail.
-   * @return This request builder.
-   */
-  @NonNull
-  @CheckResult
-  @SuppressWarnings("unchecked")
-  public RequestBuilder<TranscodeType> thumbnail(float sizeMultiplier) {
-    if (sizeMultiplier < 0f || sizeMultiplier > 1f) {
-      throw new IllegalArgumentException("sizeMultiplier must be between 0 and 1");
+
+    /**
+     * Returns a request to load the given byte array.
+     * <p>
+     * <p>Note - by default loads for bytes are not cached in either the memory or the disk cache.
+     *
+     * @param model the data to load.
+     * @see #load(Object)
+     */
+    @NonNull
+    @CheckResult
+    @Override
+    public RequestBuilder<TranscodeType> load(@Nullable byte[] model) {
+        RequestBuilder<TranscodeType> result = loadGeneric(model);
+        if (!result.isDiskCacheStrategySet()) {
+            result = result.apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
+        }
+        if (!result.isSkipMemoryCacheSet()) {
+            result = result.apply(skipMemoryCacheOf(true /*skipMemoryCache*/));
+        }
+        return result;
     }
-    this.thumbSizeMultiplier = sizeMultiplier;
-
-    return this;
-  }
-
-  /**
-   * Sets the specific model to load data for.
-   *
-   * @param model The model to load data for, or null.
-   * @return This request builder.
-   */
-  @NonNull
-  @CheckResult
-  @SuppressWarnings("unchecked")
-  @Override
-  public RequestBuilder<TranscodeType> load(@Nullable Object model) {
-    return loadGeneric(model);
-  }
-
-  @NonNull
-  private RequestBuilder<TranscodeType> loadGeneric(@Nullable Object model) {
-    this.model = model;
-    isModelSet = true;
-    return this;
-  }
-  /**
-   * Returns an object to load the given {@link Bitmap}.
-   *
-   * <p>It's almost always better to allow Glide to load {@link Bitmap}s than
-   * pass {@link Bitmap}s into Glide. If you have a custom way to obtain {@link Bitmap}s that is
-   * not supported by Glide by default, consider registering a custom
-   * {@link com.bumptech.glide.load.model.ModelLoader} or
-   * {@link com.bumptech.glide.load.ResourceDecoder} instead of using this method.
-   *
-   * <p>The {@link DiskCacheStrategy} is set to {@link DiskCacheStrategy#NONE}. Previous calls to
-   * {@link #apply(BaseRequestOptions)} or previously applied {@link DiskCacheStrategy}s will be
-   * overridden by this method. Applying an {@link DiskCacheStrategy} other than
-   * {@link DiskCacheStrategy#NONE} after calling this method may result in undefined behavior.
-   *
-   * <p>In memory caching relies on Object equality. The contents of the {@link Bitmap}s are not
-   * compared.
-   *
-   * @see #load(Object)
-   */
-  @NonNull
-  @CheckResult
-  @Override
-  public RequestBuilder<TranscodeType> load(@Nullable Bitmap bitmap) {
-    return loadGeneric(bitmap)
-        .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
-  }
-
-  /**
-   * Returns a request builder to load the given {@link Drawable}.
-   *
-   * <p>It's almost always better to allow Glide to load {@link Bitmap}s than to pass
-   * {@link Bitmap}s into Glide using this method . If you have a custom way to obtain
-   * {@link Bitmap}s that is not supported by Glide by default, consider registering a custom
-   * {@link com.bumptech.glide.load.model.ModelLoader} or
-   * {@link com.bumptech.glide.load.ResourceDecoder} instead of using this method.
-   *
-   * <p>The {@link DiskCacheStrategy} is set to {@link DiskCacheStrategy#NONE}. Previous calls to
-   * {@link #apply(BaseRequestOptions)} or previously applied {@link DiskCacheStrategy}s will be
-   * overridden by this method. Applying an {@link DiskCacheStrategy} other than
-   * {@link DiskCacheStrategy#NONE} after calling this method may result in undefined behavior.
-   *
-   * <p>In memory caching relies on Object equality. The contents of the {@link Drawable}s are not
-   * compared.
-   *
-   * @see #load(Object)
-   */
-  @NonNull
-  @CheckResult
-  @Override
-  public RequestBuilder<TranscodeType> load(@Nullable Drawable drawable) {
-    return loadGeneric(drawable)
-        .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
-  }
-
-  /**
-   * Returns a request builder to load the given {@link java.lang.String}.
-   *
-   * <p> Note - this method caches data using only the given String as the cache key. If the data is
-   * a Uri outside of your control, or you otherwise expect the data represented by the given String
-   * to change without the String identifier changing, Consider using
-   * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)} to
-   * mixin a signature you create that identifies the data currently at the given String that will
-   * invalidate the cache if that data changes. Alternatively, using
-   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
-   * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
-   * appropriate.
-   * </p>
-   *
-   * @see #load(Object)
-   *
-   * @param string A file path, or a uri or url handled by
-   * {@link com.bumptech.glide.load.model.UriLoader}.
-   */
-  @NonNull
-  @Override
-  @CheckResult
-  public RequestBuilder<TranscodeType> load(@Nullable String string) {
-    return loadGeneric(string);
-  }
-
-  /**
-   * Returns a request builder to load the given {@link Uri}.
-   *
-   * <p> Note - this method caches data at Uris using only the Uri itself as the cache key. The data
-   * represented by Uris from some content providers may change without the Uri changing, which
-   * means using this method can lead to displaying stale data. Consider using
-   * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)} to
-   * mixin a signature you create based on the data at the given Uri that will invalidate the cache
-   * if that data changes. Alternatively, using
-   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
-   * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
-   * appropriate. </p>
-   *
-   * @see #load(Object)
-   *
-   * @param uri The Uri representing the image. Must be of a type handled by
-   * {@link com.bumptech.glide.load.model.UriLoader}.
-   */
-  @NonNull
-  @CheckResult
-  @Override
-  public RequestBuilder<TranscodeType> load(@Nullable Uri uri) {
-    return loadGeneric(uri);
-  }
-
-  /**
-   * Returns a request builder to load the given {@link File}.
-   *
-   * <p>Note - this method caches data for Files using only the file path itself as the cache key.
-   * The data in the File can change so using this method can lead to displaying stale data. If you
-   * expect the data in the File to change, Consider using
-   * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)}
-   * to mixin a signature you create that identifies the data currently in the File that will
-   * invalidate the cache if that data changes. Alternatively, using
-   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
-   * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
-   * appropriate.
-   *
-   * @see #load(Object)
-   *
-   * @param file The File containing the image
-   */
-  @NonNull
-  @CheckResult
-  @Override
-  public RequestBuilder<TranscodeType> load(@Nullable File file) {
-    return loadGeneric(file);
-  }
-
-  /**
-   * Returns a request builder that uses the
-   * {@link com.bumptech.glide.load.model.ModelLoaderFactory} currently registered or
-   * {@link Integer} to load the image represented by the given {@link Integer} resource id.
-   * Defaults to {@link com.bumptech.glide.load.model.ResourceLoader} to load resource id models.
-   *
-   * <p>By default this method adds a version code based signature to the cache key used to cache
-   * this resource in Glide. This signature is sufficient to guarantee that end users will see the
-   * most up to date versions of your Drawables, but during development if you do not increment your
-   * version code before each install and you replace a Drawable with different data without
-   * changing the Drawable name, you may see inconsistent cached data. To get around this, consider
-   * using {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} via
-   * {@link RequestOptions#diskCacheStrategy(com.bumptech.glide.load.engine.DiskCacheStrategy)}
-   * during development, and re-enabling the default
-   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESOURCE} for release builds.
-   *
-   * <p>This method will load non-{@link android.graphics.Bitmap} resources like
-   * {@link android.graphics.drawable.VectorDrawable}s. Although Glide makes a best effort to apply
-   * {@link com.bumptech.glide.load.Transformation}s to these {@link Drawable}s by either extracting
-   * the underlying {@link Bitmap} or by converting the {@link Drawable} to a {@link Bitmap}, Glide
-   * is still not able to transform all types of resources. Animated {@link Drawable}s cannot be
-   * transformed (other than {@link com.bumptech.glide.load.resource.gif.GifDrawable}). To avoid
-   * load failures if a {@link Drawable} can't be transformed, use the optional transformation
-   * methods like {@link RequestOptions#optionalTransform(Class, Transformation)}.
-   *
-   * <p>In some cases converting {@link Drawable}s to {@link Bitmap}s may be inefficient. Use this
-   * method, especially in conjunction with {@link com.bumptech.glide.load.Transformation}s with
-   * caution for non-{@link Bitmap} {@link Drawable}s.
-   *
-   * @see #load(Integer)
-   * @see com.bumptech.glide.signature.ApplicationVersionSignature
-   */
-  @NonNull
-  @CheckResult
-  @Override
-  public RequestBuilder<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer resourceId) {
-    return loadGeneric(resourceId).apply(signatureOf(ApplicationVersionSignature.obtain(context)));
-  }
-
-  /**
-   * Returns a request builder to load the given {@link URL}.
-   *
-   * @param url The URL representing the image.
-   * @see #load(Object)
-   * @deprecated The {@link java.net.URL} class has
-   * <a href="http://goo.gl/c4hHNu">a number of performance problems</a> and should generally be
-   * avoided when possible. Prefer {@link #load(android.net.Uri)} or {@link #load(String)}.
-   */
-  @Deprecated
-  @CheckResult
-  @Override
-  public RequestBuilder<TranscodeType> load(@Nullable URL url) {
-    return loadGeneric(url);
-  }
-
-  /**
-   * Returns a request to load the given byte array.
-   *
-   * <p>Note - by default loads for bytes are not cached in either the memory or the disk cache.
-   *
-   * @param model the data to load.
-   * @see #load(Object)
-   */
-  @NonNull
-  @CheckResult
-  @Override
-  public RequestBuilder<TranscodeType> load(@Nullable byte[] model) {
-    RequestBuilder<TranscodeType> result = loadGeneric(model);
-    if (!result.isDiskCacheStrategySet()) {
-        result = result.apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
+
+    /**
+     * Returns a copy of this request builder with all of the options put so far on this builder.
+     * <p>
+     * <p> This method returns a "deep" copy in that all non-immutable arguments are copied such that
+     * changes to one builder will not affect the other builder. However, in addition to immutable
+     * arguments, the current model is not copied copied so changes to the model will affect both
+     * builders. </p>
+     */
+    @SuppressWarnings({
+            "unchecked",
+            // we don't want to throw to be user friendly
+            "PMD.CloneThrowsCloneNotSupportedException"
+    })
+    @CheckResult
+    @Override
+    public RequestBuilder<TranscodeType> clone() {
+        RequestBuilder<TranscodeType> result = super.clone();
+        result.transitionOptions = result.transitionOptions.clone();
+        return result;
     }
-    if (!result.isSkipMemoryCacheSet()) {
-      result = result.apply(skipMemoryCacheOf(true /*skipMemoryCache*/));
+
+    /**
+     * Set the target the resource will be loaded into.
+     *
+     * @param target The target to load the resource into.
+     * @return The given target.
+     * @see RequestManager#clear(Target)
+     */
+    @NonNull
+    public <Y extends Target<TranscodeType>> Y into(@NonNull Y target) {
+        return into(target, /*targetListener=*/ null);
+    }
+
+    @NonNull
+    @Synthetic
+    <Y extends Target<TranscodeType>> Y into(
+            @NonNull Y target,
+            @Nullable RequestListener<TranscodeType> targetListener) {
+        return into(target, targetListener, /*options=*/ this);
     }
-    return result;
-  }
-
-  /**
-   * Returns a copy of this request builder with all of the options put so far on this builder.
-   *
-   * <p> This method returns a "deep" copy in that all non-immutable arguments are copied such that
-   * changes to one builder will not affect the other builder. However, in addition to immutable
-   * arguments, the current model is not copied copied so changes to the model will affect both
-   * builders. </p>
-   */
-  @SuppressWarnings({
-      "unchecked",
-      // we don't want to throw to be user friendly
-      "PMD.CloneThrowsCloneNotSupportedException"
-  })
-  @CheckResult
-  @Override
-  public RequestBuilder<TranscodeType> clone() {
-    RequestBuilder<TranscodeType> result = super.clone();
-    result.transitionOptions = result.transitionOptions.clone();
-    return result;
-  }
-
-  /**
-   * Set the target the resource will be loaded into.
-   *
-   * @param target The target to load the resource into.
-   * @return The given target.
-   * @see RequestManager#clear(Target)
-   */
-  @NonNull
-  public <Y extends Target<TranscodeType>> Y into(@NonNull Y target) {
-    return into(target, /*targetListener=*/ null);
-  }
-
-  @NonNull
-  @Synthetic <Y extends Target<TranscodeType>> Y into(
-      @NonNull Y target,
-      @Nullable RequestListener<TranscodeType> targetListener) {
-    return into(target, targetListener, /*options=*/ this);
-  }
-
-  private <Y extends Target<TranscodeType>> Y into(
-      @NonNull Y target,
-      @Nullable RequestListener<TranscodeType> targetListener,
-      BaseRequestOptions<?> options) {
-    Util.assertMainThread();
-    Preconditions.checkNotNull(target);
-    if (!isModelSet) {
-      throw new IllegalArgumentException("You must call #load() before calling #into()");
+
+    private <Y extends Target<TranscodeType>> Y into(
+            @NonNull Y target,
+            @Nullable RequestListener<TranscodeType> targetListener,
+            BaseRequestOptions<?> options) {
+        // 1、进行必要的check
+        Util.assertMainThread();
+        Preconditions.checkNotNull(target);
+        if (!isModelSet) {
+            throw new IllegalArgumentException("You must call #load() before calling #into()");
+        }
+
+        // 2、构建Request
+        Request request = buildRequest(target, targetListener, options);
+
+        // 3、获取原有的Request
+        Request previous = target.getRequest();
+        if (request.isEquivalentTo(previous)
+                && !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) {
+            request.recycle();
+            // If the request is completed, beginning again will ensure the result is re-delivered,
+            // triggering RequestListeners and Targets. If the request is failed, beginning again will
+            // restart the request, giving it another chance to complete. If the request is already
+            // running, we can let it continue running without interruption.
+            if (!Preconditions.checkNotNull(previous).isRunning()) {
+                // Use the previous request rather than the new one to allow for optimizations like skipping
+                // setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions
+                // that are done in the individual Request.
+                // 复用 原有的Request
+                previous.begin();
+            }
+            return target;
+        }
+
+        // 4、如果target上有正在执行的请求，则将其取消
+        requestManager.clear(target);
+        // 5、将Tartget(ImageView)与Request绑定
+        target.setRequest(request);
+
+        // 6、通过track完成网络请求
+        requestManager.track(target, request);
+
+        return target;
+    }
+
+    // If the caller is using skipMemoryCache and the previous request is finished, calling begin on
+    // the previous request will complete from memory because it will just use the resource that had
+    // already been loaded. If the previous request isn't complete, we can wait for it to finish
+    // because the previous request must also be using skipMemoryCache for the requests to be
+    // equivalent. See #2663 for additional context.
+    private boolean isSkipMemoryCacheWithCompletePreviousRequest(
+            BaseRequestOptions<?> options, Request previous) {
+        return !options.isMemoryCacheable() && previous.isComplete();
+    }
+
+    /**
+     * Sets the {@link ImageView} the resource will be loaded into, cancels any existing loads into
+     * the view, and frees any resources Glide may have previously loaded into the view so they may be
+     * reused.
+     *
+     * @param view The view to cancel previous loads for and load the new resource into.
+     * @return The
+     * {@link com.bumptech.glide.request.target.Target} used to wrap the given {@link ImageView}.
+     * @see RequestManager#clear(Target)
+     */
+    @NonNull
+    public ViewTarget<ImageView, TranscodeType> into(@NonNull ImageView view) {
+        // 1、是否是主线程，如果不是主线程则会抛出异常
+        Util.assertMainThread();
+
+        // 2、View不能为空
+        Preconditions.checkNotNull(view);
+
+        // 3、构造BaseRequestOptions
+        BaseRequestOptions<?> requestOptions = this;
+        if (!requestOptions.isTransformationSet()
+                && requestOptions.isTransformationAllowed()
+                && view.getScaleType() != null) {
+            // Clone in this method so that if we use this RequestBuilder to load into a View and then
+            // into a different target, we don't retain the transformation applied based on the previous
+            // View's scale type.
+            switch (view.getScaleType()) {
+                case CENTER_CROP:
+                    requestOptions = requestOptions.clone().optionalCenterCrop();
+                    break;
+                case CENTER_INSIDE:
+                    requestOptions = requestOptions.clone().optionalCenterInside();
+                    break;
+                case FIT_CENTER:
+                case FIT_START:
+                case FIT_END:
+                    requestOptions = requestOptions.clone().optionalFitCenter();
+                    break;
+                case FIT_XY:
+                    requestOptions = requestOptions.clone().optionalCenterInside();
+                    break;
+                case CENTER:
+                case MATRIX:
+                default:
+                    // Do nothing.
+            }
+        }
+
+        // 4、 构建Target，并调用into方法完成实际的请求
+        return into(
+                glideContext.buildImageViewTarget(view, transcodeClass),
+                /*targetListener=*/ null,
+                requestOptions);
     }
 
-    Request request = buildRequest(target, targetListener, options);
-
-    Request previous = target.getRequest();
-    if (request.isEquivalentTo(previous)
-        && !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) {
-      request.recycle();
-      // If the request is completed, beginning again will ensure the result is re-delivered,
-      // triggering RequestListeners and Targets. If the request is failed, beginning again will
-      // restart the request, giving it another chance to complete. If the request is already
-      // running, we can let it continue running without interruption.
-      if (!Preconditions.checkNotNull(previous).isRunning()) {
-        // Use the previous request rather than the new one to allow for optimizations like skipping
-        // setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions
-        // that are done in the individual Request.
-        previous.begin();
-      }
-      return target;
+    /**
+     * Returns a future that can be used to do a blocking get on a background thread.
+     *
+     * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
+     *               overridden by
+     *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
+     *               previously called.
+     * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
+     *               overridden by
+     *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
+     *               previously called).
+     * @see RequestManager#clear(Target)
+     * @deprecated Use {@link #submit(int, int)} instead.
+     */
+    @Deprecated
+    public FutureTarget<TranscodeType> into(int width, int height) {
+        return submit(width, height);
     }
 
-    requestManager.clear(target);
-    target.setRequest(request);
-    requestManager.track(target, request);
-
-    return target;
-  }
-
-  // If the caller is using skipMemoryCache and the previous request is finished, calling begin on
-  // the previous request will complete from memory because it will just use the resource that had
-  // already been loaded. If the previous request isn't complete, we can wait for it to finish
-  // because the previous request must also be using skipMemoryCache for the requests to be
-  // equivalent. See #2663 for additional context.
-  private boolean isSkipMemoryCacheWithCompletePreviousRequest(
-      BaseRequestOptions<?> options, Request previous) {
-    return !options.isMemoryCacheable() && previous.isComplete();
-  }
-
-  /**
-   * Sets the {@link ImageView} the resource will be loaded into, cancels any existing loads into
-   * the view, and frees any resources Glide may have previously loaded into the view so they may be
-   * reused.
-   *
-   * @see RequestManager#clear(Target)
-   *
-   * @param view The view to cancel previous loads for and load the new resource into.
-   * @return The
-   * {@link com.bumptech.glide.request.target.Target} used to wrap the given {@link ImageView}.
-   */
-  @NonNull
-  public ViewTarget<ImageView, TranscodeType> into(@NonNull ImageView view) {
-    Util.assertMainThread();
-    Preconditions.checkNotNull(view);
-
-    BaseRequestOptions<?> requestOptions = this;
-    if (!requestOptions.isTransformationSet()
-        && requestOptions.isTransformationAllowed()
-        && view.getScaleType() != null) {
-      // Clone in this method so that if we use this RequestBuilder to load into a View and then
-      // into a different target, we don't retain the transformation applied based on the previous
-      // View's scale type.
-      switch (view.getScaleType()) {
-        case CENTER_CROP:
-          requestOptions = requestOptions.clone().optionalCenterCrop();
-          break;
-        case CENTER_INSIDE:
-          requestOptions = requestOptions.clone().optionalCenterInside();
-          break;
-        case FIT_CENTER:
-        case FIT_START:
-        case FIT_END:
-          requestOptions = requestOptions.clone().optionalFitCenter();
-          break;
-        case FIT_XY:
-          requestOptions = requestOptions.clone().optionalCenterInside();
-          break;
-        case CENTER:
-        case MATRIX:
-        default:
-          // Do nothing.
-      }
+    /**
+     * Returns a future that can be used to do a blocking get on a background thread.
+     * <p>
+     * <p>This method defaults to {@link Target#SIZE_ORIGINAL} for the width and the height. However,
+     * since the width and height will be overridden by values passed to {@link
+     * RequestOptions#override(int, int)}, this method can be used whenever {@link RequestOptions}
+     * with override values are applied, or whenever you want to retrieve the image in its original
+     * size.
+     *
+     * @see #submit(int, int)
+     * @see #into(Target)
+     */
+    @NonNull
+    public FutureTarget<TranscodeType> submit() {
+        return submit(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
     }
 
-    return into(
-        glideContext.buildImageViewTarget(view, transcodeClass),
-        /*targetListener=*/ null,
-        requestOptions);
-  }
-
-  /**
-   * Returns a future that can be used to do a blocking get on a background thread.
-   *
-   * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
-   *               overridden by
-   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
-   *               previously called.
-   * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
-   *               overridden by
-   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
-   *               previously called).
-   * @see RequestManager#clear(Target)
-   *
-   * @deprecated Use {@link #submit(int, int)} instead.
-   */
-  @Deprecated
-  public FutureTarget<TranscodeType> into(int width, int height) {
-    return submit(width, height);
-  }
-
-  /**
-   * Returns a future that can be used to do a blocking get on a background thread.
-   *
-   * <p>This method defaults to {@link Target#SIZE_ORIGINAL} for the width and the height. However,
-   * since the width and height will be overridden by values passed to {@link
-   * RequestOptions#override(int, int)}, this method can be used whenever {@link RequestOptions}
-   * with override values are applied, or whenever you want to retrieve the image in its original
-   * size.
-   *
-   * @see #submit(int, int)
-   * @see #into(Target)
-   */
-  @NonNull
-  public FutureTarget<TranscodeType> submit() {
-    return submit(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
-  }
-
-  /**
-   * Returns a future that can be used to do a blocking get on a background thread.
-   *
-   * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
-   *               overridden by
-   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
-   *               previously called.
-   * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
-   *               overridden by
-   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
-   *               previously called).
-   */
-  @NonNull
-  public FutureTarget<TranscodeType> submit(int width, int height) {
-    final RequestFutureTarget<TranscodeType> target =
-        new RequestFutureTarget<>(glideContext.getMainHandler(), width, height);
-
-    if (Util.isOnBackgroundThread()) {
-      glideContext.getMainHandler().post(new Runnable() {
-        @Override
-        public void run() {
-          if (!target.isCancelled()) {
+    /**
+     * Returns a future that can be used to do a blocking get on a background thread.
+     *
+     * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
+     *               overridden by
+     *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
+     *               previously called.
+     * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
+     *               overridden by
+     *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
+     *               previously called).
+     */
+    @NonNull
+    public FutureTarget<TranscodeType> submit(int width, int height) {
+        final RequestFutureTarget<TranscodeType> target =
+                new RequestFutureTarget<>(glideContext.getMainHandler(), width, height);
+
+        if (Util.isOnBackgroundThread()) {
+            glideContext.getMainHandler().post(new Runnable() {
+                @Override
+                public void run() {
+                    if (!target.isCancelled()) {
+                        into(target, target);
+                    }
+                }
+            });
+        } else {
             into(target, target);
-          }
         }
-      });
-    } else {
-      into(target, target);
+
+        return target;
+    }
+
+    /**
+     * Preloads the resource into the cache using the given width and height.
+     * <p>
+     * <p> Pre-loading is useful for making sure that resources you are going to to want in the near
+     * future are available quickly. </p>
+     *
+     * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
+     *               overridden by
+     *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
+     *               previously called.
+     * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
+     *               overridden by
+     *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
+     *               previously called).
+     * @return A {@link Target} that can be used to cancel the load via
+     * {@link RequestManager#clear(Target)}.
+     * @see com.bumptech.glide.ListPreloader
+     */
+    @NonNull
+    public Target<TranscodeType> preload(int width, int height) {
+        final PreloadTarget<TranscodeType> target = PreloadTarget.obtain(requestManager, width, height);
+        return into(target);
     }
 
-    return target;
-  }
-
-  /**
-   * Preloads the resource into the cache using the given width and height.
-   *
-   * <p> Pre-loading is useful for making sure that resources you are going to to want in the near
-   * future are available quickly. </p>
-   *
-   * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
-   *               overridden by
-   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
-   *               previously called.
-   * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
-   *               overridden by
-   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
-   *               previously called).
-   * @return A {@link Target} that can be used to cancel the load via
-   * {@link RequestManager#clear(Target)}.
-   * @see com.bumptech.glide.ListPreloader
-   */
-  @NonNull
-  public Target<TranscodeType> preload(int width, int height) {
-    final PreloadTarget<TranscodeType> target = PreloadTarget.obtain(requestManager, width, height);
-    return into(target);
-  }
-
-  /**
-   * Preloads the resource into the cache using {@link Target#SIZE_ORIGINAL} as the target width and
-   * height. Equivalent to calling {@link #preload(int, int)} with {@link Target#SIZE_ORIGINAL} as
-   * the width and height.
-   *
-   * @return A {@link Target} that can be used to cancel the load via
-   * {@link RequestManager#clear(Target)}
-   * @see #preload(int, int)
-   */
-  @NonNull
-  public Target<TranscodeType> preload() {
-    return preload(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
-  }
-
-  /**
-   * Loads the original unmodified data into the cache and calls the given Target with the cache
-   * File.
-   *
-   * @param target The Target that will receive the cache File when the load completes
-   * @param <Y>    The type of Target.
-   * @return The given Target.
-   *
-   * @deprecated Use {@link RequestManager#downloadOnly()} and {@link #into(Target)}.
-   */
-  @Deprecated
-  @CheckResult
-  public <Y extends Target<File>> Y downloadOnly(@NonNull Y target) {
-    return getDownloadOnlyRequest().into(target);
-  }
-
-  /**
-   * Loads the original unmodified data into the cache and returns a
-   * {@link java.util.concurrent.Future} that can be used to retrieve the cache File containing the
-   * data.
-   *
-   * @param width  The width in pixels to use to fetch the data.
-   * @param height The height in pixels to use to fetch the data.
-   * @return A {@link java.util.concurrent.Future} that can be used to retrieve the cache File
-   * containing the data.
-   *
-   * @deprecated Use {@link RequestManager#downloadOnly()} and {@link #submit(int, int)}.
-   */
-  @Deprecated
-  @CheckResult
-  public FutureTarget<File> downloadOnly(int width, int height) {
-    return getDownloadOnlyRequest().submit(width, height);
-  }
-
-  @NonNull
-  @CheckResult
-  protected RequestBuilder<File> getDownloadOnlyRequest() {
-    return new RequestBuilder<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
-  }
-
-  @NonNull
-  private Priority getThumbnailPriority(@NonNull Priority current) {
-    switch (current) {
-      case LOW:
-        return Priority.NORMAL;
-      case NORMAL:
-        return Priority.HIGH;
-      case HIGH:
-      case IMMEDIATE:
-        return Priority.IMMEDIATE;
-      default:
-        throw new IllegalArgumentException("unknown priority: " + getPriority());
+    /**
+     * Preloads the resource into the cache using {@link Target#SIZE_ORIGINAL} as the target width and
+     * height. Equivalent to calling {@link #preload(int, int)} with {@link Target#SIZE_ORIGINAL} as
+     * the width and height.
+     *
+     * @return A {@link Target} that can be used to cancel the load via
+     * {@link RequestManager#clear(Target)}
+     * @see #preload(int, int)
+     */
+    @NonNull
+    public Target<TranscodeType> preload() {
+        return preload(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
     }
-  }
-
-  private Request buildRequest(
-      Target<TranscodeType> target,
-      @Nullable RequestListener<TranscodeType> targetListener,
-      BaseRequestOptions<?> requestOptions) {
-    return buildRequestRecursive(
-        target,
-        targetListener,
-        /*parentCoordinator=*/ null,
-        transitionOptions,
-        requestOptions.getPriority(),
-        requestOptions.getOverrideWidth(),
-        requestOptions.getOverrideHeight(),
-        requestOptions);
-  }
-
-  private Request buildRequestRecursive(
-      Target<TranscodeType> target,
-      @Nullable RequestListener<TranscodeType> targetListener,
-      @Nullable RequestCoordinator parentCoordinator,
-      TransitionOptions<?, ? super TranscodeType> transitionOptions,
-      Priority priority,
-      int overrideWidth,
-      int overrideHeight,
-      BaseRequestOptions<?> requestOptions) {
-
-    // Build the ErrorRequestCoordinator first if necessary so we can update parentCoordinator.
-    ErrorRequestCoordinator errorRequestCoordinator = null;
-    if (errorBuilder != null) {
-      errorRequestCoordinator = new ErrorRequestCoordinator(parentCoordinator);
-      parentCoordinator = errorRequestCoordinator;
+
+    /**
+     * Loads the original unmodified data into the cache and calls the given Target with the cache
+     * File.
+     *
+     * @param target The Target that will receive the cache File when the load completes
+     * @param <Y>    The type of Target.
+     * @return The given Target.
+     * @deprecated Use {@link RequestManager#downloadOnly()} and {@link #into(Target)}.
+     */
+    @Deprecated
+    @CheckResult
+    public <Y extends Target<File>> Y downloadOnly(@NonNull Y target) {
+        return getDownloadOnlyRequest().into(target);
     }
 
-    Request mainRequest =
-        buildThumbnailRequestRecursive(
-            target,
-            targetListener,
-            parentCoordinator,
-            transitionOptions,
-            priority,
-            overrideWidth,
-            overrideHeight,
-            requestOptions);
-
-    if (errorRequestCoordinator == null) {
-      return mainRequest;
+    /**
+     * Loads the original unmodified data into the cache and returns a
+     * {@link java.util.concurrent.Future} that can be used to retrieve the cache File containing the
+     * data.
+     *
+     * @param width  The width in pixels to use to fetch the data.
+     * @param height The height in pixels to use to fetch the data.
+     * @return A {@link java.util.concurrent.Future} that can be used to retrieve the cache File
+     * containing the data.
+     * @deprecated Use {@link RequestManager#downloadOnly()} and {@link #submit(int, int)}.
+     */
+    @Deprecated
+    @CheckResult
+    public FutureTarget<File> downloadOnly(int width, int height) {
+        return getDownloadOnlyRequest().submit(width, height);
     }
 
-    int errorOverrideWidth = errorBuilder.getOverrideWidth();
-    int errorOverrideHeight = errorBuilder.getOverrideHeight();
-    if (Util.isValidDimensions(overrideWidth, overrideHeight)
-        && !errorBuilder.isValidOverride()) {
-      errorOverrideWidth = requestOptions.getOverrideWidth();
-      errorOverrideHeight = requestOptions.getOverrideHeight();
+    @NonNull
+    @CheckResult
+    protected RequestBuilder<File> getDownloadOnlyRequest() {
+        return new RequestBuilder<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+    }
+
+    @NonNull
+    private Priority getThumbnailPriority(@NonNull Priority current) {
+        switch (current) {
+            case LOW:
+                return Priority.NORMAL;
+            case NORMAL:
+                return Priority.HIGH;
+            case HIGH:
+            case IMMEDIATE:
+                return Priority.IMMEDIATE;
+            default:
+                throw new IllegalArgumentException("unknown priority: " + getPriority());
+        }
+    }
+
+    private Request buildRequest(
+            Target<TranscodeType> target,
+            @Nullable RequestListener<TranscodeType> targetListener,
+            BaseRequestOptions<?> requestOptions) {
+        return buildRequestRecursive(
+                target,
+                targetListener,
+                /*parentCoordinator=*/ null,
+                transitionOptions,
+                requestOptions.getPriority(),
+                requestOptions.getOverrideWidth(),
+                requestOptions.getOverrideHeight(),
+                requestOptions);
+    }
+
+    private Request buildRequestRecursive(
+            Target<TranscodeType> target,
+            @Nullable RequestListener<TranscodeType> targetListener,
+            @Nullable RequestCoordinator parentCoordinator,
+            TransitionOptions<?, ? super TranscodeType> transitionOptions,
+            Priority priority,
+            int overrideWidth,
+            int overrideHeight,
+            BaseRequestOptions<?> requestOptions) {
+
+        // Build the ErrorRequestCoordinator first if necessary so we can update parentCoordinator.
+        ErrorRequestCoordinator errorRequestCoordinator = null;
+        if (errorBuilder != null) {
+            errorRequestCoordinator = new ErrorRequestCoordinator(parentCoordinator);
+            parentCoordinator = errorRequestCoordinator;
+        }
+
+        Request mainRequest =
+                buildThumbnailRequestRecursive(
+                        target,
+                        targetListener,
+                        parentCoordinator,
+                        transitionOptions,
+                        priority,
+                        overrideWidth,
+                        overrideHeight,
+                        requestOptions);
+
+        if (errorRequestCoordinator == null) {
+            return mainRequest;
+        }
+
+        int errorOverrideWidth = errorBuilder.getOverrideWidth();
+        int errorOverrideHeight = errorBuilder.getOverrideHeight();
+        if (Util.isValidDimensions(overrideWidth, overrideHeight)
+                && !errorBuilder.isValidOverride()) {
+            errorOverrideWidth = requestOptions.getOverrideWidth();
+            errorOverrideHeight = requestOptions.getOverrideHeight();
+        }
+
+        Request errorRequest = errorBuilder.buildRequestRecursive(
+                target,
+                targetListener,
+                errorRequestCoordinator,
+                errorBuilder.transitionOptions,
+                errorBuilder.getPriority(),
+                errorOverrideWidth,
+                errorOverrideHeight,
+                errorBuilder);
+        errorRequestCoordinator.setRequests(mainRequest, errorRequest);
+        return errorRequestCoordinator;
+    }
+
+    private Request buildThumbnailRequestRecursive(
+            Target<TranscodeType> target,
+            RequestListener<TranscodeType> targetListener,
+            @Nullable RequestCoordinator parentCoordinator,
+            TransitionOptions<?, ? super TranscodeType> transitionOptions,
+            Priority priority,
+            int overrideWidth,
+            int overrideHeight,
+            BaseRequestOptions<?> requestOptions) {
+        if (thumbnailBuilder != null) {
+            // Recursive case: contains a potentially recursive thumbnail request builder.
+            if (isThumbnailBuilt) {
+                throw new IllegalStateException("You cannot use a request as both the main request and a "
+                        + "thumbnail, consider using clone() on the request(s) passed to thumbnail()");
+            }
+
+            TransitionOptions<?, ? super TranscodeType> thumbTransitionOptions =
+                    thumbnailBuilder.transitionOptions;
+
+            // Apply our transition by default to thumbnail requests but avoid overriding custom options
+            // that may have been applied on the thumbnail request explicitly.
+            if (thumbnailBuilder.isDefaultTransitionOptionsSet) {
+                thumbTransitionOptions = transitionOptions;
+            }
+
+            Priority thumbPriority = thumbnailBuilder.isPrioritySet()
+                    ? thumbnailBuilder.getPriority() : getThumbnailPriority(priority);
+
+            int thumbOverrideWidth = thumbnailBuilder.getOverrideWidth();
+            int thumbOverrideHeight = thumbnailBuilder.getOverrideHeight();
+            if (Util.isValidDimensions(overrideWidth, overrideHeight)
+                    && !thumbnailBuilder.isValidOverride()) {
+                thumbOverrideWidth = requestOptions.getOverrideWidth();
+                thumbOverrideHeight = requestOptions.getOverrideHeight();
+            }
+
+            ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
+            Request fullRequest =
+                    obtainRequest(
+                            target,
+                            targetListener,
+                            requestOptions,
+                            coordinator,
+                            transitionOptions,
+                            priority,
+                            overrideWidth,
+                            overrideHeight);
+            isThumbnailBuilt = true;
+            // Recursively generate thumbnail requests.
+            Request thumbRequest =
+                    thumbnailBuilder.buildRequestRecursive(
+                            target,
+                            targetListener,
+                            coordinator,
+                            thumbTransitionOptions,
+                            thumbPriority,
+                            thumbOverrideWidth,
+                            thumbOverrideHeight,
+                            thumbnailBuilder);
+            isThumbnailBuilt = false;
+            coordinator.setRequests(fullRequest, thumbRequest);
+            return coordinator;
+        } else if (thumbSizeMultiplier != null) {
+            // Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse.
+            ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
+            Request fullRequest =
+                    obtainRequest(
+                            target,
+                            targetListener,
+                            requestOptions,
+                            coordinator,
+                            transitionOptions,
+                            priority,
+                            overrideWidth,
+                            overrideHeight);
+            BaseRequestOptions<?> thumbnailOptions =
+                    requestOptions.clone().sizeMultiplier(thumbSizeMultiplier);
+
+            Request thumbnailRequest =
+                    obtainRequest(
+                            target,
+                            targetListener,
+                            thumbnailOptions,
+                            coordinator,
+                            transitionOptions,
+                            getThumbnailPriority(priority),
+                            overrideWidth,
+                            overrideHeight);
+
+            coordinator.setRequests(fullRequest, thumbnailRequest);
+            return coordinator;
+        } else {
+            // 没有缩略图
+            // Base case: no thumbnail.
+            return obtainRequest(
+                    target,
+                    targetListener,
+                    requestOptions,
+                    parentCoordinator,
+                    transitionOptions,
+                    priority,
+                    overrideWidth,
+                    overrideHeight);
+        }
     }
 
-    Request errorRequest = errorBuilder.buildRequestRecursive(
-        target,
-        targetListener,
-        errorRequestCoordinator,
-        errorBuilder.transitionOptions,
-        errorBuilder.getPriority(),
-        errorOverrideWidth,
-        errorOverrideHeight,
-        errorBuilder);
-    errorRequestCoordinator.setRequests(mainRequest, errorRequest);
-    return errorRequestCoordinator;
-  }
-
-  private Request buildThumbnailRequestRecursive(
-      Target<TranscodeType> target,
-      RequestListener<TranscodeType> targetListener,
-      @Nullable RequestCoordinator parentCoordinator,
-      TransitionOptions<?, ? super TranscodeType> transitionOptions,
-      Priority priority,
-      int overrideWidth,
-      int overrideHeight,
-      BaseRequestOptions<?> requestOptions) {
-    if (thumbnailBuilder != null) {
-      // Recursive case: contains a potentially recursive thumbnail request builder.
-      if (isThumbnailBuilt) {
-        throw new IllegalStateException("You cannot use a request as both the main request and a "
-            + "thumbnail, consider using clone() on the request(s) passed to thumbnail()");
-      }
-
-      TransitionOptions<?, ? super TranscodeType> thumbTransitionOptions =
-          thumbnailBuilder.transitionOptions;
-
-      // Apply our transition by default to thumbnail requests but avoid overriding custom options
-      // that may have been applied on the thumbnail request explicitly.
-      if (thumbnailBuilder.isDefaultTransitionOptionsSet) {
-        thumbTransitionOptions = transitionOptions;
-      }
-
-      Priority thumbPriority = thumbnailBuilder.isPrioritySet()
-          ? thumbnailBuilder.getPriority() : getThumbnailPriority(priority);
-
-      int thumbOverrideWidth = thumbnailBuilder.getOverrideWidth();
-      int thumbOverrideHeight = thumbnailBuilder.getOverrideHeight();
-      if (Util.isValidDimensions(overrideWidth, overrideHeight)
-          && !thumbnailBuilder.isValidOverride()) {
-        thumbOverrideWidth = requestOptions.getOverrideWidth();
-        thumbOverrideHeight = requestOptions.getOverrideHeight();
-      }
-
-      ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
-      Request fullRequest =
-          obtainRequest(
-              target,
-              targetListener,
-              requestOptions,
-              coordinator,
-              transitionOptions,
-              priority,
-              overrideWidth,
-              overrideHeight);
-      isThumbnailBuilt = true;
-      // Recursively generate thumbnail requests.
-      Request thumbRequest =
-          thumbnailBuilder.buildRequestRecursive(
-              target,
-              targetListener,
-              coordinator,
-              thumbTransitionOptions,
-              thumbPriority,
-              thumbOverrideWidth,
-              thumbOverrideHeight,
-              thumbnailBuilder);
-      isThumbnailBuilt = false;
-      coordinator.setRequests(fullRequest, thumbRequest);
-      return coordinator;
-    } else if (thumbSizeMultiplier != null) {
-      // Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse.
-      ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
-      Request fullRequest =
-          obtainRequest(
-              target,
-              targetListener,
-              requestOptions,
-              coordinator,
-              transitionOptions,
-              priority,
-              overrideWidth,
-              overrideHeight);
-      BaseRequestOptions<?> thumbnailOptions =
-          requestOptions.clone().sizeMultiplier(thumbSizeMultiplier);
-
-      Request thumbnailRequest =
-          obtainRequest(
-              target,
-              targetListener,
-              thumbnailOptions,
-              coordinator,
-              transitionOptions,
-              getThumbnailPriority(priority),
-              overrideWidth,
-              overrideHeight);
-
-      coordinator.setRequests(fullRequest, thumbnailRequest);
-      return coordinator;
-    } else {
-      // Base case: no thumbnail.
-      return obtainRequest(
-          target,
-          targetListener,
-          requestOptions,
-          parentCoordinator,
-          transitionOptions,
-          priority,
-          overrideWidth,
-          overrideHeight);
+    private Request obtainRequest(
+            Target<TranscodeType> target,
+            RequestListener<TranscodeType> targetListener,
+            BaseRequestOptions<?> requestOptions,
+            RequestCoordinator requestCoordinator,
+            TransitionOptions<?, ? super TranscodeType> transitionOptions,
+            Priority priority,
+            int overrideWidth,
+            int overrideHeight) {
+
+        return SingleRequest.obtain(
+                context,
+                glideContext,
+                model,
+                transcodeClass,
+                requestOptions,
+                overrideWidth,
+                overrideHeight,
+                priority,
+                target,
+                targetListener,
+                requestListeners,
+                requestCoordinator,
+                glideContext.getEngine(),
+                transitionOptions.getTransitionFactory());
     }
-  }
-
-  private Request obtainRequest(
-      Target<TranscodeType> target,
-      RequestListener<TranscodeType> targetListener,
-      BaseRequestOptions<?> requestOptions,
-      RequestCoordinator requestCoordinator,
-      TransitionOptions<?, ? super TranscodeType> transitionOptions,
-      Priority priority,
-      int overrideWidth,
-      int overrideHeight) {
-    return SingleRequest.obtain(
-        context,
-        glideContext,
-        model,
-        transcodeClass,
-        requestOptions,
-        overrideWidth,
-        overrideHeight,
-        priority,
-        target,
-        targetListener,
-        requestListeners,
-        requestCoordinator,
-        glideContext.getEngine(),
-        transitionOptions.getTransitionFactory());
-  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/RequestManager.java b/library/src/main/java/com/bumptech/glide/RequestManager.java
index 9e0cdb6c3..847526668 100644
--- a/library/src/main/java/com/bumptech/glide/RequestManager.java
+++ b/library/src/main/java/com/bumptech/glide/RequestManager.java
@@ -16,6 +16,7 @@
 import android.support.annotation.Nullable;
 import android.support.annotation.RawRes;
 import android.view.View;
+
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
 import com.bumptech.glide.load.engine.GlideException;
@@ -35,6 +36,7 @@
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
+
 import java.io.File;
 import java.net.URL;
 import java.util.List;
@@ -53,645 +55,658 @@
  * @see Glide#with(Context)
  */
 public class RequestManager implements LifecycleListener,
-    ModelTypes<RequestBuilder<Drawable>> {
-  private static final RequestOptions DECODE_TYPE_BITMAP = decodeTypeOf(Bitmap.class).lock();
-  private static final RequestOptions DECODE_TYPE_GIF = decodeTypeOf(GifDrawable.class).lock();
-  private static final RequestOptions DOWNLOAD_ONLY_OPTIONS =
-      diskCacheStrategyOf(DiskCacheStrategy.DATA).priority(Priority.LOW)
-          .skipMemoryCache(true);
-
-  protected final Glide glide;
-  protected final Context context;
-  @Synthetic final Lifecycle lifecycle;
-  private final RequestTracker requestTracker;
-  private final RequestManagerTreeNode treeNode;
-  private final TargetTracker targetTracker = new TargetTracker();
-  private final Runnable addSelfToLifecycle = new Runnable() {
-    @Override
-    public void run() {
-      lifecycle.addListener(RequestManager.this);
-    }
-  };
-  private final Handler mainHandler = new Handler(Looper.getMainLooper());
-  private final ConnectivityMonitor connectivityMonitor;
-  // Adding default listeners should be much less common than starting new requests. We want
-  // some way of making sure that requests don't mutate our listeners without creating a new copy of
-  // the list each time a request is started.
-  private final CopyOnWriteArrayList<RequestListener<Object>> defaultRequestListeners;
-
-  private RequestOptions requestOptions;
-
-  public RequestManager(
-      @NonNull Glide glide, @NonNull Lifecycle lifecycle,
-      @NonNull RequestManagerTreeNode treeNode, @NonNull Context context) {
-    this(
-        glide,
-        lifecycle,
-        treeNode,
-        new RequestTracker(),
-        glide.getConnectivityMonitorFactory(),
-        context);
-  }
-
-  // Our usage is safe here.
-  @SuppressWarnings("PMD.ConstructorCallsOverridableMethod")
-  RequestManager(
-      Glide glide,
-      Lifecycle lifecycle,
-      RequestManagerTreeNode treeNode,
-      RequestTracker requestTracker,
-      ConnectivityMonitorFactory factory,
-      Context context) {
-    this.glide = glide;
-    this.lifecycle = lifecycle;
-    this.treeNode = treeNode;
-    this.requestTracker = requestTracker;
-    this.context = context;
-
-    connectivityMonitor =
-        factory.build(
-            context.getApplicationContext(),
-            new RequestManagerConnectivityListener(requestTracker));
-
-    // If we're the application level request manager, we may be created on a background thread.
-    // In that case we cannot risk synchronously pausing or resuming requests, so we hack around the
-    // issue by delaying adding ourselves as a lifecycle listener by posting to the main thread.
-    // This should be entirely safe.
-    if (Util.isOnBackgroundThread()) {
-      mainHandler.post(addSelfToLifecycle);
-    } else {
-      lifecycle.addListener(this);
-    }
-    lifecycle.addListener(connectivityMonitor);
-
-    defaultRequestListeners =
-        new CopyOnWriteArrayList<>(glide.getGlideContext().getDefaultRequestListeners());
-    setRequestOptions(glide.getGlideContext().getDefaultRequestOptions());
-
-    glide.registerRequestManager(this);
-  }
-
-  protected void setRequestOptions(@NonNull RequestOptions toSet) {
-    requestOptions = toSet.clone().autoClone();
-  }
-
-  private void updateRequestOptions(@NonNull RequestOptions toUpdate) {
-    requestOptions = requestOptions.apply(toUpdate);
-  }
-
-  /**
-   * Updates the default {@link RequestOptions} for all loads started with this request manager
-   * with the given {@link RequestOptions}.
-   *
-   * <p>The {@link RequestOptions} provided here are applied on top of those provided via {@link
-   * GlideBuilder#setDefaultRequestOptions(RequestOptions)}. If there are conflicts, the options
-   * applied here will win. Note that this method does not mutate options provided to
-   * {@link GlideBuilder#setDefaultRequestOptions(RequestOptions)}.
-   *
-   * <p>Multiple sets of options can be applied. If there are conflicts the last {@link
-   * RequestOptions} applied will win.
-   *
-   * <p>The modified options will only be applied to loads started after this method is called.
-   *
-   * @see RequestBuilder#apply(RequestOptions)
-   *
-   * @return This request manager.
-   */
-  @NonNull
-  public RequestManager applyDefaultRequestOptions(@NonNull RequestOptions requestOptions) {
-    updateRequestOptions(requestOptions);
-    return this;
-  }
-
-  /**
-   * Replaces the default {@link RequestOptions} for all loads started with this request manager
-   * with the given {@link RequestOptions}.
-   *
-   * <p>The {@link RequestOptions} provided here replace those that have been previously provided
-   * via this method, {@link GlideBuilder#setDefaultRequestOptions(RequestOptions)}, and
-   * {@link #applyDefaultRequestOptions(RequestOptions)}.
-   *
-   * <p>Subsequent calls to {@link #applyDefaultRequestOptions(RequestOptions)} will not mutate
-   * the {@link RequestOptions} provided here. Instead the manager will create a clone of these
-   * options and mutate the clone.
-   *
-   * @see #applyDefaultRequestOptions(RequestOptions)
-   *
-   * @return This request manager.
-   */
-  @NonNull
-  public RequestManager setDefaultRequestOptions(@NonNull RequestOptions requestOptions) {
-    setRequestOptions(requestOptions);
-    return this;
-  }
-
-  /**
-   * Adds a default {@link RequestListener} that will be added to every request started with this
-   * {@link RequestManager}.
-   *
-   * <p>Multiple {@link RequestListener}s can be added here, in {@link RequestManager} scopes or
-   * to individual {@link RequestBuilder}s. {@link RequestListener}s are called in the order they're
-   * added. Even if an earlier {@link RequestListener} returns {@code true} from
-   * {@link RequestListener#onLoadFailed(GlideException, Object, Target, boolean)} or
-   * {@link RequestListener#onResourceReady(Object, Object, Target, DataSource, boolean)}, it will
-   * not prevent subsequent {@link RequestListener}s from being called.
-   *
-   * <p>Because Glide requests can be started for any number of individual resource types, any
-   * listener added here has to accept any generic resource type in
-   * {@link RequestListener#onResourceReady(Object, Object, Target, DataSource, boolean)}. If you
-   * must base the behavior of the listener on the resource type, you will need to use
-   * {@code instanceof} to do so. It's not safe to cast resource types without first checking
-   * with {@code instanceof}.
-   */
-  public RequestManager addDefaultRequestListener(RequestListener<Object> requestListener) {
-    defaultRequestListeners.add(requestListener);
-    return this;
-  }
-
-  /**
-   * Returns true if loads for this {@link RequestManager} are currently paused.
-   *
-   * @see #pauseRequests()
-   * @see #resumeRequests()
-   */
-  public boolean isPaused() {
-    Util.assertMainThread();
-    return requestTracker.isPaused();
-  }
-
-  /**
-   * Cancels any in progress loads, but does not clear resources of completed loads.
-   *
-   * <p>Note #{@link #resumeRequests()} must be called for any requests made before or while the
-   * manager is paused to complete. RequestManagers attached to Fragments and Activities
-   * automatically resume onStart().
-   *
-   * @see #isPaused()
-   * @see #resumeRequests()
-   */
-  public void pauseRequests() {
-    Util.assertMainThread();
-    requestTracker.pauseRequests();
-  }
-
-  /**
-   * Cancels any in progress loads and clears resources of completed loads.
-   *
-   * <p>Note #{@link #resumeRequests()} must be called for any requests made before or while the
-   * manager is paused to complete. RequestManagers attached to Fragments and Activities
-   * automatically resume onStart().
-   *
-   * <p>This will release the memory used by completed bitmaps but leaves them in any configured
-   * caches. When an #{@link android.app.Activity} receives #{@link
-   * android.app.Activity#onTrimMemory(int)} at a level of #{@link
-   * android.content.ComponentCallbacks2#TRIM_MEMORY_BACKGROUND} this is desirable in order to keep
-   * your process alive longer.
-   *
-   * @see #isPaused()
-   * @see #resumeRequests()
-   */
-  public void pauseAllRequests() {
-    Util.assertMainThread();
-    requestTracker.pauseAllRequests();
-  }
-
-  /**
-   * Performs {@link #pauseRequests()} recursively for all managers that are contextually
-   * descendant to this manager based on the Activity/Fragment hierarchy:
-   *
-   * <ul>
-   *   <li>When pausing on an Activity all attached fragments will also get paused.
-   *   <li>When pausing on an attached Fragment all descendant fragments will also get paused.
-   *   <li>When pausing on a detached Fragment or the application context only the current
-   *   RequestManager is paused.
-   * </ul>
-   *
-   * <p>Note, on pre-Jelly Bean MR1 calling pause on a Fragment will not cause child fragments to
-   * pause, in this case either call pause on the Activity or use a support Fragment.
-   */
-  // Public API.
-  @SuppressWarnings({"WeakerAccess", "unused"})
-  public void pauseRequestsRecursive() {
-    Util.assertMainThread();
-    pauseRequests();
-    for (RequestManager requestManager : treeNode.getDescendants()) {
-      requestManager.pauseRequests();
-    }
-  }
-
-  /**
-   * Restarts any loads that have not yet completed.
-   *
-   * @see #isPaused()
-   * @see #pauseRequests()
-   */
-  public void resumeRequests() {
-    Util.assertMainThread();
-    requestTracker.resumeRequests();
-  }
-
-  /**
-   * Performs {@link #resumeRequests()} recursively for all managers that are contextually
-   * descendant to this manager based on the Activity/Fragment hierarchy. The hierarchical semantics
-   * are identical as for {@link #pauseRequestsRecursive()}.
-   */
-  // Public API.
-  @SuppressWarnings("unused")
-  public void resumeRequestsRecursive() {
-    Util.assertMainThread();
-    resumeRequests();
-    for (RequestManager requestManager : treeNode.getDescendants()) {
-      requestManager.resumeRequests();
-    }
-  }
-
-  /**
-   * Lifecycle callback that registers for connectivity events (if the
-   * android.permission.ACCESS_NETWORK_STATE permission is present) and restarts failed or paused
-   * requests.
-   */
-  @Override
-  public void onStart() {
-    resumeRequests();
-    targetTracker.onStart();
-  }
-
-  /**
-   * Lifecycle callback that unregisters for connectivity events (if the
-   * android.permission.ACCESS_NETWORK_STATE permission is present) and pauses in progress loads.
-   */
-  @Override
-  public void onStop() {
-    pauseRequests();
-    targetTracker.onStop();
-  }
-
-  /**
-   * Lifecycle callback that cancels all in progress requests and clears and recycles resources for
-   * all completed requests.
-   */
-  @Override
-  public void onDestroy() {
-    targetTracker.onDestroy();
-    for (Target<?> target : targetTracker.getAll()) {
-      clear(target);
-    }
-    targetTracker.clear();
-    requestTracker.clearRequests();
-    lifecycle.removeListener(this);
-    lifecycle.removeListener(connectivityMonitor);
-    mainHandler.removeCallbacks(addSelfToLifecycle);
-    glide.unregisterRequestManager(this);
-  }
-
-  /**
-   * Attempts to always load the resource as a {@link android.graphics.Bitmap}, even if it could
-   * actually be animated.
-   *
-   * @return A new request builder for loading a {@link android.graphics.Bitmap}
-   */
-  @NonNull
-  @CheckResult
-  public RequestBuilder<Bitmap> asBitmap() {
-    return as(Bitmap.class).apply(DECODE_TYPE_BITMAP);
-  }
-
-  /**
-   * Attempts to always load the resource as a
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
-   *
-   * <p> If the underlying data is not a GIF, this will fail. As a result, this should only be used
-   * if the model represents an animated GIF and the caller wants to interact with the GifDrawable
-   * directly. Normally using just {@link #asDrawable()} is sufficient because it will determine
-   * whether or not the given data represents an animated GIF and return the appropriate {@link
-   * Drawable}, animated or not, automatically. </p>
-   *
-   * @return A new request builder for loading a
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
-   */
-  @NonNull
-  @CheckResult
-  public RequestBuilder<GifDrawable> asGif() {
-    return as(GifDrawable.class).apply(DECODE_TYPE_GIF);
-  }
-
-  /**
-   * Attempts to always load the resource using any registered {@link
-   * com.bumptech.glide.load.ResourceDecoder}s that can decode any subclass of {@link Drawable}.
-   *
-   * <p> By default, may return either a {@link android.graphics.drawable.BitmapDrawable} or {@link
-   * GifDrawable}, but if additional decoders are registered for other {@link Drawable} subclasses,
-   * any of those subclasses may also be returned. </p>
-   *
-   * @return A new request builder for loading a {@link Drawable}.
-   */
-  @NonNull
-  @CheckResult
-  public RequestBuilder<Drawable> asDrawable() {
-    return as(Drawable.class);
-  }
-
-  /**
-   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(Bitmap)}.
-   *
-   * @return A new request builder for loading a {@link Drawable} using the given model.
-   */
-  @NonNull
-  @CheckResult
-  @Override
-  public RequestBuilder<Drawable> load(@Nullable Bitmap bitmap) {
-    return asDrawable().load(bitmap);
-  }
-
-  /**
-   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(Drawable)}.
-   *
-   * @return A new request builder for loading a {@link Drawable} using the given model.
-   */
-  @NonNull
-  @CheckResult
-  @Override
-  public RequestBuilder<Drawable> load(@Nullable Drawable drawable) {
-    return asDrawable().load(drawable);
-  }
-
-  /**
-   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(String)}.
-   *
-   * @return A new request builder for loading a {@link Drawable} using the given model.
-   */
-  @NonNull
-  @CheckResult
-  @Override
-  public RequestBuilder<Drawable> load(@Nullable String string) {
-    return asDrawable().load(string);
-  }
-
-  /**
-   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(Uri)}.
-   *
-   * @return A new request builder for loading a {@link Drawable} using the given model.
-   */
-  @NonNull
-  @CheckResult
-  @Override
-  public RequestBuilder<Drawable> load(@Nullable Uri uri) {
-    return asDrawable().load(uri);
-  }
-
-  /**
-   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(File)}.
-   *
-   * @return A new request builder for loading a {@link Drawable} using the given model.
-   */
-  @NonNull
-  @CheckResult
-  @Override
-  public RequestBuilder<Drawable> load(@Nullable File file) {
-    return asDrawable().load(file);
-  }
-
-  /**
-   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(Integer)}.
-   *
-   * @return A new request builder for loading a {@link Drawable} using the given model.
-   */
-  @SuppressWarnings("deprecation")
-  @NonNull
-  @CheckResult
-  @Override
-  public RequestBuilder<Drawable> load(@RawRes @DrawableRes @Nullable Integer resourceId) {
-    return asDrawable().load(resourceId);
-  }
-
-  /**
-   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(URL)}.
-   *
-   * @return A new request builder for loading a {@link Drawable} using the given model.
-   */
-  @SuppressWarnings("deprecation")
-  @CheckResult
-  @Override
-  @Deprecated
-  public RequestBuilder<Drawable> load(@Nullable URL url) {
-    return asDrawable().load(url);
-  }
-
-
-  /**
-   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(byte[])}.
-   *
-   * @return A new request builder for loading a {@link Drawable} using the given model.
-   */
-  @NonNull
-  @CheckResult
-  @Override
-  public RequestBuilder<Drawable> load(@Nullable byte[] model) {
-    return asDrawable().load(model);
-  }
-
-  /**
-   * A helper method equivalent to calling {@link #asDrawable()} and then {@link
-   * RequestBuilder#load(Object)} with the given model.
-   *
-   * @return A new request builder for loading a {@link Drawable} using the given model.
-   */
-  @NonNull
-  @CheckResult
-  @Override
-  public RequestBuilder<Drawable> load(@Nullable Object model) {
-    return asDrawable().load(model);
-  }
-
-  /**
-   * Attempts always load the resource into the cache and return the {@link File} containing the
-   * cached source data.
-   *
-   * <p>This method is designed to work for remote data that is or will be cached using {@link
-   * com.bumptech.glide.load.engine.DiskCacheStrategy#DATA}. As a result, specifying a
-   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy} on this request is generally not
-   * recommended.
-   *
-   * @return A new request builder for downloading content to cache and returning the cache File.
-   */
-  @NonNull
-  @CheckResult
-  public RequestBuilder<File> downloadOnly() {
-    return as(File.class).apply(DOWNLOAD_ONLY_OPTIONS);
-  }
-
-  /**
-   * A helper method equivalent to calling {@link #downloadOnly()} ()} and then {@link
-   * RequestBuilder#load(Object)} with the given model.
-   *
-   * @return A new request builder for loading a {@link Drawable} using the given model.
-   */
-  @NonNull
-  @CheckResult
-  public RequestBuilder<File> download(@Nullable Object model) {
-    return downloadOnly().load(model);
-  }
-
-  /**
-   * Attempts to always load a {@link File} containing the resource, either using a file path
-   * obtained from the media store (for local images/videos), or using Glide's disk cache
-   * (for remote images/videos).
-   *
-   * <p>For remote content, prefer {@link #downloadOnly()}.
-   *
-   * @return A new request builder for obtaining File paths to content.
-   */
-  @NonNull
-  @CheckResult
-  public RequestBuilder<File> asFile() {
-    return as(File.class).apply(skipMemoryCacheOf(true));
-  }
-
-  /**
-   * Attempts to load the resource using any registered
-   * {@link com.bumptech.glide.load.ResourceDecoder}s
-   * that can decode the given resource class or any subclass of the given resource class.
-   *
-   * @param resourceClass The resource to decode.
-   * @return A new request builder for loading the given resource class.
-   */
-  @NonNull
-  @CheckResult
-  public <ResourceType> RequestBuilder<ResourceType> as(
-      @NonNull Class<ResourceType> resourceClass) {
-    return new RequestBuilder<>(glide, this, resourceClass, context);
-  }
-
-  /**
-   * Cancel any pending loads Glide may have for the view and free any resources that may have been
-   * loaded for the view.
-   *
-   * <p> Note that this will only work if {@link View#setTag(Object)} is not called on this view
-   * outside of Glide. </p>
-   *
-   * @param view The view to cancel loads and free resources for.
-   * @throws IllegalArgumentException if an object other than Glide's metadata is put as the view's
-   *                                  tag.
-   * @see #clear(Target)
-   */
-  public void clear(@NonNull View view) {
-    clear(new ClearTarget(view));
-  }
-
-  /**
-   * Cancel any pending loads Glide may have for the target and free any resources (such as
-   * {@link Bitmap}s) that may have been loaded for the target so they may be reused.
-   *
-   * @param target The Target to cancel loads for.
-   */
-  public void clear(@Nullable final Target<?> target) {
-    if (target == null) {
-      return;
-    }
-
-    if (Util.isOnMainThread()) {
-      untrackOrDelegate(target);
-    } else {
-      mainHandler.post(new Runnable() {
+        ModelTypes<RequestBuilder<Drawable>> {
+    private static final RequestOptions DECODE_TYPE_BITMAP = decodeTypeOf(Bitmap.class).lock();
+    private static final RequestOptions DECODE_TYPE_GIF = decodeTypeOf(GifDrawable.class).lock();
+    private static final RequestOptions DOWNLOAD_ONLY_OPTIONS =
+            diskCacheStrategyOf(DiskCacheStrategy.DATA).priority(Priority.LOW)
+                    .skipMemoryCache(true);
+
+    protected final Glide glide;
+    protected final Context context;
+    @Synthetic
+    final Lifecycle lifecycle;
+    private final RequestTracker requestTracker;
+    private final RequestManagerTreeNode treeNode;
+    private final TargetTracker targetTracker = new TargetTracker();
+    private final Runnable addSelfToLifecycle = new Runnable() {
         @Override
         public void run() {
-          clear(target);
+            lifecycle.addListener(RequestManager.this);
         }
-      });
-    }
-  }
-
-  private void untrackOrDelegate(@NonNull Target<?> target) {
-    boolean isOwnedByUs = untrack(target);
-    // We'll end up here if the Target was cleared after the RequestManager that started the request
-    // is destroyed. That can happen for at least two reasons:
-    // 1. We call clear() on a background thread using something other than Application Context
-    // RequestManager.
-    // 2. The caller retains a reference to the RequestManager after the corresponding Activity or
-    // Fragment is destroyed, starts a load with it, and then clears that load with a different
-    // RequestManager. Callers seem especially likely to do this in retained Fragments (#2262).
-    //
-    // #1 is always an error. At best the caller is leaking memory briefly in something like an
-    // AsyncTask. At worst the caller is leaking an Activity or Fragment for a sustained period of
-    // time if they do something like reference the Activity RequestManager in a long lived
-    // background thread or task.
-    //
-    // #2 is always an error. Callers shouldn't be starting new loads using RequestManagers after
-    // the corresponding Activity or Fragment is destroyed because retaining any reference to the
-    // RequestManager leaks memory. It's possible that there's some brief period of time during or
-    // immediately after onDestroy where this is reasonable, but I can't think of why.
-    if (!isOwnedByUs && !glide.removeFromManagers(target) && target.getRequest() != null) {
-      Request request = target.getRequest();
-      target.setRequest(null);
-      request.clear();
-    }
-  }
-
-  boolean untrack(@NonNull Target<?> target) {
-    Request request = target.getRequest();
-    // If the Target doesn't have a request, it's already been cleared.
-    if (request == null) {
-      return true;
-    }
-
-    if (requestTracker.clearRemoveAndRecycle(request)) {
-      targetTracker.untrack(target);
-      target.setRequest(null);
-      return true;
-    } else {
-      return false;
-    }
-  }
-
-  void track(@NonNull Target<?> target, @NonNull Request request) {
-    targetTracker.track(target);
-    requestTracker.runRequest(request);
-  }
-
-  List<RequestListener<Object>> getDefaultRequestListeners() {
-    return defaultRequestListeners;
-  }
-
-  RequestOptions getDefaultRequestOptions() {
-    return requestOptions;
-  }
-
-  @NonNull
-  <T> TransitionOptions<?, T> getDefaultTransitionOptions(Class<T> transcodeClass) {
-    return glide.getGlideContext().getDefaultTransitionOptions(transcodeClass);
-  }
-
-  @Override
-  public String toString() {
-    return super.toString() + "{tracker=" + requestTracker + ", treeNode=" + treeNode + "}";
-  }
-
-  private static class RequestManagerConnectivityListener implements ConnectivityMonitor
-      .ConnectivityListener {
-    private final RequestTracker requestTracker;
+    };
+    private final Handler mainHandler = new Handler(Looper.getMainLooper());
+    private final ConnectivityMonitor connectivityMonitor;
+    // Adding default listeners should be much less common than starting new requests. We want
+    // some way of making sure that requests don't mutate our listeners without creating a new copy of
+    // the list each time a request is started.
+    private final CopyOnWriteArrayList<RequestListener<Object>> defaultRequestListeners;
+
+    private RequestOptions requestOptions;
+
+    public RequestManager(
+            @NonNull Glide glide, @NonNull Lifecycle lifecycle,
+            @NonNull RequestManagerTreeNode treeNode, @NonNull Context context) {
+        this(
+                glide,
+                lifecycle,
+                treeNode,
+                new RequestTracker(),
+                glide.getConnectivityMonitorFactory(),
+                context);
+    }
+
+    // Our usage is safe here.
+    @SuppressWarnings("PMD.ConstructorCallsOverridableMethod")
+    RequestManager(
+            Glide glide,
+            Lifecycle lifecycle,
+            RequestManagerTreeNode treeNode,
+            RequestTracker requestTracker,
+            ConnectivityMonitorFactory factory,
+            Context context) {
+        this.glide = glide;
+        this.lifecycle = lifecycle;
+        this.treeNode = treeNode;
+        this.requestTracker = requestTracker;
+        this.context = context;
+
+        connectivityMonitor =
+                factory.build(
+                        context.getApplicationContext(),
+                        new RequestManagerConnectivityListener(requestTracker));
+
+        // If we're the application level request manager, we may be created on a background thread.
+        // In that case we cannot risk synchronously pausing or resuming requests, so we hack around the
+        // issue by delaying adding ourselves as a lifecycle listener by posting to the main thread.
+        // This should be entirely safe.
+        if (Util.isOnBackgroundThread()) {
+            mainHandler.post(addSelfToLifecycle);
+        } else {
+            lifecycle.addListener(this);
+        }
+        lifecycle.addListener(connectivityMonitor);
+
+        defaultRequestListeners =
+                new CopyOnWriteArrayList<>(glide.getGlideContext().getDefaultRequestListeners());
+        setRequestOptions(glide.getGlideContext().getDefaultRequestOptions());
+
+        glide.registerRequestManager(this);
+    }
+
+    protected void setRequestOptions(@NonNull RequestOptions toSet) {
+        requestOptions = toSet.clone().autoClone();
+    }
+
+    private void updateRequestOptions(@NonNull RequestOptions toUpdate) {
+        requestOptions = requestOptions.apply(toUpdate);
+    }
+
+    /**
+     * Updates the default {@link RequestOptions} for all loads started with this request manager
+     * with the given {@link RequestOptions}.
+     * <p>
+     * <p>The {@link RequestOptions} provided here are applied on top of those provided via {@link
+     * GlideBuilder#setDefaultRequestOptions(RequestOptions)}. If there are conflicts, the options
+     * applied here will win. Note that this method does not mutate options provided to
+     * {@link GlideBuilder#setDefaultRequestOptions(RequestOptions)}.
+     * <p>
+     * <p>Multiple sets of options can be applied. If there are conflicts the last {@link
+     * RequestOptions} applied will win.
+     * <p>
+     * <p>The modified options will only be applied to loads started after this method is called.
+     *
+     * @return This request manager.
+     * @see RequestBuilder#apply(RequestOptions)
+     */
+    @NonNull
+    public RequestManager applyDefaultRequestOptions(@NonNull RequestOptions requestOptions) {
+        updateRequestOptions(requestOptions);
+        return this;
+    }
+
+    /**
+     * Replaces the default {@link RequestOptions} for all loads started with this request manager
+     * with the given {@link RequestOptions}.
+     * <p>
+     * <p>The {@link RequestOptions} provided here replace those that have been previously provided
+     * via this method, {@link GlideBuilder#setDefaultRequestOptions(RequestOptions)}, and
+     * {@link #applyDefaultRequestOptions(RequestOptions)}.
+     * <p>
+     * <p>Subsequent calls to {@link #applyDefaultRequestOptions(RequestOptions)} will not mutate
+     * the {@link RequestOptions} provided here. Instead the manager will create a clone of these
+     * options and mutate the clone.
+     *
+     * @return This request manager.
+     * @see #applyDefaultRequestOptions(RequestOptions)
+     */
+    @NonNull
+    public RequestManager setDefaultRequestOptions(@NonNull RequestOptions requestOptions) {
+        setRequestOptions(requestOptions);
+        return this;
+    }
+
+    /**
+     * Adds a default {@link RequestListener} that will be added to every request started with this
+     * {@link RequestManager}.
+     * <p>
+     * <p>Multiple {@link RequestListener}s can be added here, in {@link RequestManager} scopes or
+     * to individual {@link RequestBuilder}s. {@link RequestListener}s are called in the order they're
+     * added. Even if an earlier {@link RequestListener} returns {@code true} from
+     * {@link RequestListener#onLoadFailed(GlideException, Object, Target, boolean)} or
+     * {@link RequestListener#onResourceReady(Object, Object, Target, DataSource, boolean)}, it will
+     * not prevent subsequent {@link RequestListener}s from being called.
+     * <p>
+     * <p>Because Glide requests can be started for any number of individual resource types, any
+     * listener added here has to accept any generic resource type in
+     * {@link RequestListener#onResourceReady(Object, Object, Target, DataSource, boolean)}. If you
+     * must base the behavior of the listener on the resource type, you will need to use
+     * {@code instanceof} to do so. It's not safe to cast resource types without first checking
+     * with {@code instanceof}.
+     */
+    public RequestManager addDefaultRequestListener(RequestListener<Object> requestListener) {
+        defaultRequestListeners.add(requestListener);
+        return this;
+    }
+
+    /**
+     * Returns true if loads for this {@link RequestManager} are currently paused.
+     *
+     * @see #pauseRequests()
+     * @see #resumeRequests()
+     */
+    public boolean isPaused() {
+        Util.assertMainThread();
+        return requestTracker.isPaused();
+    }
+
+    /**
+     * Cancels any in progress loads, but does not clear resources of completed loads.
+     * <p>
+     * <p>Note #{@link #resumeRequests()} must be called for any requests made before or while the
+     * manager is paused to complete. RequestManagers attached to Fragments and Activities
+     * automatically resume onStart().
+     *
+     * @see #isPaused()
+     * @see #resumeRequests()
+     */
+    public void pauseRequests() {
+        Util.assertMainThread();
+        requestTracker.pauseRequests();
+    }
+
+    /**
+     * Cancels any in progress loads and clears resources of completed loads.
+     * <p>
+     * <p>Note #{@link #resumeRequests()} must be called for any requests made before or while the
+     * manager is paused to complete. RequestManagers attached to Fragments and Activities
+     * automatically resume onStart().
+     * <p>
+     * <p>This will release the memory used by completed bitmaps but leaves them in any configured
+     * caches. When an #{@link android.app.Activity} receives #{@link
+     * android.app.Activity#onTrimMemory(int)} at a level of #{@link
+     * android.content.ComponentCallbacks2#TRIM_MEMORY_BACKGROUND} this is desirable in order to keep
+     * your process alive longer.
+     *
+     * @see #isPaused()
+     * @see #resumeRequests()
+     */
+    public void pauseAllRequests() {
+        Util.assertMainThread();
+        requestTracker.pauseAllRequests();
+    }
+
+    /**
+     * Performs {@link #pauseRequests()} recursively for all managers that are contextually
+     * descendant to this manager based on the Activity/Fragment hierarchy:
+     * <p>
+     * <ul>
+     * <li>When pausing on an Activity all attached fragments will also get paused.
+     * <li>When pausing on an attached Fragment all descendant fragments will also get paused.
+     * <li>When pausing on a detached Fragment or the application context only the current
+     * RequestManager is paused.
+     * </ul>
+     * <p>
+     * <p>Note, on pre-Jelly Bean MR1 calling pause on a Fragment will not cause child fragments to
+     * pause, in this case either call pause on the Activity or use a support Fragment.
+     */
+    // Public API.
+    @SuppressWarnings({"WeakerAccess", "unused"})
+    public void pauseRequestsRecursive() {
+        Util.assertMainThread();
+        pauseRequests();
+        for (RequestManager requestManager : treeNode.getDescendants()) {
+            requestManager.pauseRequests();
+        }
+    }
 
-    RequestManagerConnectivityListener(@NonNull RequestTracker requestTracker) {
-      this.requestTracker = requestTracker;
+    /**
+     * Restarts any loads that have not yet completed.
+     *
+     * @see #isPaused()
+     * @see #pauseRequests()
+     */
+    public void resumeRequests() {
+        Util.assertMainThread();
+        requestTracker.resumeRequests();
     }
 
+    /**
+     * Performs {@link #resumeRequests()} recursively for all managers that are contextually
+     * descendant to this manager based on the Activity/Fragment hierarchy. The hierarchical semantics
+     * are identical as for {@link #pauseRequestsRecursive()}.
+     */
+    // Public API.
+    @SuppressWarnings("unused")
+    public void resumeRequestsRecursive() {
+        Util.assertMainThread();
+        resumeRequests();
+        for (RequestManager requestManager : treeNode.getDescendants()) {
+            requestManager.resumeRequests();
+        }
+    }
+
+    /**
+     * Lifecycle callback that registers for connectivity events (if the
+     * android.permission.ACCESS_NETWORK_STATE permission is present) and restarts failed or paused
+     * requests.
+     */
     @Override
-    public void onConnectivityChanged(boolean isConnected) {
-      if (isConnected) {
-        requestTracker.restartRequests();
-      }
+    public void onStart() {
+        resumeRequests();
+        targetTracker.onStart();
     }
-  }
 
-  private static class ClearTarget extends ViewTarget<View, Object> {
+    /**
+     * Lifecycle callback that unregisters for connectivity events (if the
+     * android.permission.ACCESS_NETWORK_STATE permission is present) and pauses in progress loads.
+     */
+    @Override
+    public void onStop() {
+        pauseRequests();
+        targetTracker.onStop();
+    }
 
-    ClearTarget(@NonNull View view) {
-      super(view);
+    /**
+     * Lifecycle callback that cancels all in progress requests and clears and recycles resources for
+     * all completed requests.
+     */
+    @Override
+    public void onDestroy() {
+        targetTracker.onDestroy();
+        for (Target<?> target : targetTracker.getAll()) {
+            clear(target);
+        }
+        targetTracker.clear();
+        requestTracker.clearRequests();
+        lifecycle.removeListener(this);
+        lifecycle.removeListener(connectivityMonitor);
+        mainHandler.removeCallbacks(addSelfToLifecycle);
+        glide.unregisterRequestManager(this);
     }
 
+    /**
+     * Attempts to always load the resource as a {@link android.graphics.Bitmap}, even if it could
+     * actually be animated.
+     *
+     * @return A new request builder for loading a {@link android.graphics.Bitmap}
+     */
+    @NonNull
+    @CheckResult
+    public RequestBuilder<Bitmap> asBitmap() {
+        return as(Bitmap.class).apply(DECODE_TYPE_BITMAP);
+    }
+
+    /**
+     * Attempts to always load the resource as a
+     * {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
+     * <p>
+     * <p> If the underlying data is not a GIF, this will fail. As a result, this should only be used
+     * if the model represents an animated GIF and the caller wants to interact with the GifDrawable
+     * directly. Normally using just {@link #asDrawable()} is sufficient because it will determine
+     * whether or not the given data represents an animated GIF and return the appropriate {@link
+     * Drawable}, animated or not, automatically. </p>
+     *
+     * @return A new request builder for loading a
+     * {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
+     */
+    @NonNull
+    @CheckResult
+    public RequestBuilder<GifDrawable> asGif() {
+        return as(GifDrawable.class).apply(DECODE_TYPE_GIF);
+    }
+
+    /**
+     * Attempts to always load the resource using any registered {@link
+     * com.bumptech.glide.load.ResourceDecoder}s that can decode any subclass of {@link Drawable}.
+     * <p>
+     * <p> By default, may return either a {@link android.graphics.drawable.BitmapDrawable} or {@link
+     * GifDrawable}, but if additional decoders are registered for other {@link Drawable} subclasses,
+     * any of those subclasses may also be returned. </p>
+     *
+     * @return A new request builder for loading a {@link Drawable}.
+     */
+    @NonNull
+    @CheckResult
+    public RequestBuilder<Drawable> asDrawable() {
+        return as(Drawable.class);
+    }
+
+    /**
+     * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(Bitmap)}.
+     *
+     * @return A new request builder for loading a {@link Drawable} using the given model.
+     */
+    @NonNull
+    @CheckResult
     @Override
-    public void onResourceReady(@NonNull Object resource,
-        @Nullable Transition<? super Object> transition) {
-      // Do nothing.
+    public RequestBuilder<Drawable> load(@Nullable Bitmap bitmap) {
+        return asDrawable().load(bitmap);
+    }
+
+    /**
+     * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(Drawable)}.
+     *
+     * @return A new request builder for loading a {@link Drawable} using the given model.
+     */
+    @NonNull
+    @CheckResult
+    @Override
+    public RequestBuilder<Drawable> load(@Nullable Drawable drawable) {
+        return asDrawable().load(drawable);
+    }
+
+    /**
+     * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(String)}.
+     *
+     * @return A new request builder for loading a {@link Drawable} using the given model.
+     */
+    @NonNull
+    @CheckResult
+    @Override
+    public RequestBuilder<Drawable> load(@Nullable String string) {
+        return asDrawable().load(string);
+    }
+
+    /**
+     * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(Uri)}.
+     *
+     * @return A new request builder for loading a {@link Drawable} using the given model.
+     */
+    @NonNull
+    @CheckResult
+    @Override
+    public RequestBuilder<Drawable> load(@Nullable Uri uri) {
+        return asDrawable().load(uri);
+    }
+
+    /**
+     * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(File)}.
+     *
+     * @return A new request builder for loading a {@link Drawable} using the given model.
+     */
+    @NonNull
+    @CheckResult
+    @Override
+    public RequestBuilder<Drawable> load(@Nullable File file) {
+        return asDrawable().load(file);
+    }
+
+    /**
+     * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(Integer)}.
+     *
+     * @return A new request builder for loading a {@link Drawable} using the given model.
+     */
+    @SuppressWarnings("deprecation")
+    @NonNull
+    @CheckResult
+    @Override
+    public RequestBuilder<Drawable> load(@RawRes @DrawableRes @Nullable Integer resourceId) {
+        return asDrawable().load(resourceId);
+    }
+
+    /**
+     * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(URL)}.
+     *
+     * @return A new request builder for loading a {@link Drawable} using the given model.
+     */
+    @SuppressWarnings("deprecation")
+    @CheckResult
+    @Override
+    @Deprecated
+    public RequestBuilder<Drawable> load(@Nullable URL url) {
+        return asDrawable().load(url);
+    }
+
+
+    /**
+     * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(byte[])}.
+     *
+     * @return A new request builder for loading a {@link Drawable} using the given model.
+     */
+    @NonNull
+    @CheckResult
+    @Override
+    public RequestBuilder<Drawable> load(@Nullable byte[] model) {
+        return asDrawable().load(model);
+    }
+
+    /**
+     * A helper method equivalent to calling {@link #asDrawable()} and then {@link
+     * RequestBuilder#load(Object)} with the given model.
+     *
+     * @return A new request builder for loading a {@link Drawable} using the given model.
+     */
+    @NonNull
+    @CheckResult
+    @Override
+    public RequestBuilder<Drawable> load(@Nullable Object model) {
+        return asDrawable().load(model);
+    }
+
+    /**
+     * Attempts always load the resource into the cache and return the {@link File} containing the
+     * cached source data.
+     * <p>
+     * <p>This method is designed to work for remote data that is or will be cached using {@link
+     * com.bumptech.glide.load.engine.DiskCacheStrategy#DATA}. As a result, specifying a
+     * {@link com.bumptech.glide.load.engine.DiskCacheStrategy} on this request is generally not
+     * recommended.
+     *
+     * @return A new request builder for downloading content to cache and returning the cache File.
+     */
+    @NonNull
+    @CheckResult
+    public RequestBuilder<File> downloadOnly() {
+        return as(File.class).apply(DOWNLOAD_ONLY_OPTIONS);
+    }
+
+    /**
+     * A helper method equivalent to calling {@link #downloadOnly()} ()} and then {@link
+     * RequestBuilder#load(Object)} with the given model.
+     *
+     * @return A new request builder for loading a {@link Drawable} using the given model.
+     */
+    @NonNull
+    @CheckResult
+    public RequestBuilder<File> download(@Nullable Object model) {
+        return downloadOnly().load(model);
+    }
+
+    /**
+     * Attempts to always load a {@link File} containing the resource, either using a file path
+     * obtained from the media store (for local images/videos), or using Glide's disk cache
+     * (for remote images/videos).
+     * <p>
+     * <p>For remote content, prefer {@link #downloadOnly()}.
+     *
+     * @return A new request builder for obtaining File paths to content.
+     */
+    @NonNull
+    @CheckResult
+    public RequestBuilder<File> asFile() {
+        return as(File.class).apply(skipMemoryCacheOf(true));
+    }
+
+    /**
+     * Attempts to load the resource using any registered
+     * {@link com.bumptech.glide.load.ResourceDecoder}s
+     * that can decode the given resource class or any subclass of the given resource class.
+     *
+     * @param resourceClass The resource to decode.
+     * @return A new request builder for loading the given resource class.
+     */
+    @NonNull
+    @CheckResult
+    public <ResourceType> RequestBuilder<ResourceType> as(
+            @NonNull Class<ResourceType> resourceClass) {
+        return new RequestBuilder<>(glide, this, resourceClass, context);
+    }
+
+    /**
+     * Cancel any pending loads Glide may have for the view and free any resources that may have been
+     * loaded for the view.
+     * <p>
+     * <p> Note that this will only work if {@link View#setTag(Object)} is not called on this view
+     * outside of Glide. </p>
+     *
+     * @param view The view to cancel loads and free resources for.
+     * @throws IllegalArgumentException if an object other than Glide's metadata is put as the view's
+     *                                  tag.
+     * @see #clear(Target)
+     */
+    public void clear(@NonNull View view) {
+        clear(new ClearTarget(view));
+    }
+
+    /**
+     * Cancel any pending loads Glide may have for the target and free any resources (such as
+     * {@link Bitmap}s) that may have been loaded for the target so they may be reused.
+     *
+     * @param target The Target to cancel loads for.
+     */
+    public void clear(@Nullable final Target<?> target) {
+        if (target == null) {
+            return;
+        }
+
+        if (Util.isOnMainThread()) {
+            // 主线程，直接调用untrackOrDelegate
+            untrackOrDelegate(target);
+        } else {
+            // 子线程，通过Handler将事件发送到主线程
+            mainHandler.post(new Runnable() {
+                @Override
+                public void run() {
+                    // 在主线程继续调用clear方法
+                    clear(target);
+                }
+            });
+        }
+    }
+
+    private void untrackOrDelegate(@NonNull Target<?> target) {
+        // 尝试移除当前target上正在执行的请求
+        // isOwnedByUs = true：表示当前target上已经没有正在执行的请求
+        // false 表示现在target上有正在执行的请求
+        boolean isOwnedByUs = untrack(target);
+        // We'll end up here if the Target was cleared after the RequestManager that started the request
+        // is destroyed. That can happen for at least two reasons:
+        // 1. We call clear() on a background thread using something other than Application Context
+        // RequestManager.
+        // 2. The caller retains a reference to the RequestManager after the corresponding Activity or
+        // Fragment is destroyed, starts a load with it, and then clears that load with a different
+        // RequestManager. Callers seem especially likely to do this in retained Fragments (#2262).
+        //
+        // #1 is always an error. At best the caller is leaking memory briefly in something like an
+        // AsyncTask. At worst the caller is leaking an Activity or Fragment for a sustained period of
+        // time if they do something like reference the Activity RequestManager in a long lived
+        // background thread or task.
+        //
+        // #2 is always an error. Callers shouldn't be starting new loads using RequestManagers after
+        // the corresponding Activity or Fragment is destroyed because retaining any reference to the
+        // RequestManager leaks memory. It's possible that there's some brief period of time during or
+        // immediately after onDestroy where this is reasonable, but I can't think of why.
+        if (!isOwnedByUs && !glide.removeFromManagers(target) && target.getRequest() != null) {
+            Request request = target.getRequest();
+            target.setRequest(null);
+            request.clear();
+        }
+    }
+
+    boolean untrack(@NonNull Target<?> target) {
+        Request request = target.getRequest();
+        // If the Target doesn't have a request, it's already been cleared.
+        if (request == null) {
+            // 当前target上没有正在执行的请求
+            return true;
+        }
+
+        // 移除并回收 当前target上的请求
+        if (requestTracker.clearRemoveAndRecycle(request)) {
+            // 移除失败
+            // 该 target上有正在执行的请求，所以需要先将原有的请求取消
+            targetTracker.untrack(target);
+            target.setRequest(null);
+            return true;
+        } else {
+            // 移除失败
+            return false;
+        }
+    }
+
+    void track(@NonNull Target<?> target, @NonNull Request request) {
+        // 将target加入到targetTracker，以便统一管理
+        targetTracker.track(target);
+
+        // 将request加入到requestTracker的内部集合中，然后进行请求操作
+        requestTracker.runRequest(request);
+    }
+
+    List<RequestListener<Object>> getDefaultRequestListeners() {
+        return defaultRequestListeners;
+    }
+
+    RequestOptions getDefaultRequestOptions() {
+        return requestOptions;
+    }
+
+    @NonNull
+    <T> TransitionOptions<?, T> getDefaultTransitionOptions(Class<T> transcodeClass) {
+        return glide.getGlideContext().getDefaultTransitionOptions(transcodeClass);
+    }
+
+    @Override
+    public String toString() {
+        return super.toString() + "{tracker=" + requestTracker + ", treeNode=" + treeNode + "}";
+    }
+
+    private static class RequestManagerConnectivityListener implements ConnectivityMonitor
+            .ConnectivityListener {
+        private final RequestTracker requestTracker;
+
+        RequestManagerConnectivityListener(@NonNull RequestTracker requestTracker) {
+            this.requestTracker = requestTracker;
+        }
+
+        @Override
+        public void onConnectivityChanged(boolean isConnected) {
+            if (isConnected) {
+                requestTracker.restartRequests();
+            }
+        }
+    }
+
+    private static class ClearTarget extends ViewTarget<View, Object> {
+
+        ClearTarget(@NonNull View view) {
+            super(view);
+        }
+
+        @Override
+        public void onResourceReady(@NonNull Object resource,
+                                    @Nullable Transition<? super Object> transition) {
+            // Do nothing.
+        }
     }
-  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
index 14215377a..3f580b8dc 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
@@ -29,6 +29,7 @@
 @Deprecated
 public class RequestManagerFragment extends Fragment {
   private static final String TAG = "RMFragment";
+  //
   private final ActivityFragmentLifecycle lifecycle;
   private final RequestManagerTreeNode requestManagerTreeNode =
       new FragmentRequestManagerTreeNode();
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
index a8260fa81..dd9e5c889 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
@@ -21,10 +21,12 @@
 import android.support.v4.util.ArrayMap;
 import android.util.Log;
 import android.view.View;
+
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Util;
+
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Map;
@@ -34,461 +36,506 @@
  * retrieving existing ones from activities and fragment.
  */
 public class RequestManagerRetriever implements Handler.Callback {
-  @VisibleForTesting
-  static final String FRAGMENT_TAG = "com.bumptech.glide.manager";
-  private static final String TAG = "RMRetriever";
-
-  private static final int ID_REMOVE_FRAGMENT_MANAGER = 1;
-  private static final int ID_REMOVE_SUPPORT_FRAGMENT_MANAGER = 2;
-
-  // Hacks based on the implementation of FragmentManagerImpl in the non-support libraries that
-  // allow us to iterate over and retrieve all active Fragments in a FragmentManager.
-  private static final String FRAGMENT_INDEX_KEY = "key";
-
-  /**
-   * The top application level RequestManager.
-   */
-  private volatile RequestManager applicationManager;
-
-  /**
-   * Pending adds for RequestManagerFragments.
-   */
-  @SuppressWarnings("deprecation")
-  @VisibleForTesting
-  final Map<android.app.FragmentManager, RequestManagerFragment> pendingRequestManagerFragments =
-      new HashMap<>();
-
-  /**
-   * Pending adds for SupportRequestManagerFragments.
-   */
-  @VisibleForTesting
-  final Map<FragmentManager, SupportRequestManagerFragment> pendingSupportRequestManagerFragments =
-      new HashMap<>();
-
-  /**
-   * Main thread handler to handle cleaning up pending fragment maps.
-   */
-  private final Handler handler;
-  private final RequestManagerFactory factory;
-
-  // Objects used to find Fragments and Activities containing views.
-  private final ArrayMap<View, Fragment> tempViewToSupportFragment = new ArrayMap<>();
-  private final ArrayMap<View, android.app.Fragment> tempViewToFragment = new ArrayMap<>();
-  private final Bundle tempBundle = new Bundle();
-
-  public RequestManagerRetriever(@Nullable RequestManagerFactory factory) {
-    this.factory = factory != null ? factory : DEFAULT_FACTORY;
-    handler = new Handler(Looper.getMainLooper(), this /* Callback */);
-  }
-
-  @NonNull
-  private RequestManager getApplicationManager(@NonNull Context context) {
-    // Either an application context or we're on a background thread.
-    if (applicationManager == null) {
-      synchronized (this) {
+    @VisibleForTesting
+    static final String FRAGMENT_TAG = "com.bumptech.glide.manager";
+    private static final String TAG = "RMRetriever";
+
+    private static final int ID_REMOVE_FRAGMENT_MANAGER = 1;
+    private static final int ID_REMOVE_SUPPORT_FRAGMENT_MANAGER = 2;
+
+    // Hacks based on the implementation of FragmentManagerImpl in the non-support libraries that
+    // allow us to iterate over and retrieve all active Fragments in a FragmentManager.
+    private static final String FRAGMENT_INDEX_KEY = "key";
+
+    /**
+     * The top application level RequestManager.
+     */
+    private volatile RequestManager applicationManager;
+
+    /**
+     * Pending adds for RequestManagerFragments.
+     */
+    @SuppressWarnings("deprecation")
+    @VisibleForTesting
+    final Map<android.app.FragmentManager, RequestManagerFragment> pendingRequestManagerFragments =
+            new HashMap<>();
+
+    /**
+     * Pending adds for SupportRequestManagerFragments.
+     */
+    @VisibleForTesting
+    final Map<FragmentManager, SupportRequestManagerFragment> pendingSupportRequestManagerFragments =
+            new HashMap<>();
+
+    /**
+     * Main thread handler to handle cleaning up pending fragment maps.
+     */
+    private final Handler handler;
+    private final RequestManagerFactory factory;
+
+    // Objects used to find Fragments and Activities containing views.
+    private final ArrayMap<View, Fragment> tempViewToSupportFragment = new ArrayMap<>();
+    private final ArrayMap<View, android.app.Fragment> tempViewToFragment = new ArrayMap<>();
+    private final Bundle tempBundle = new Bundle();
+
+    public RequestManagerRetriever(@Nullable RequestManagerFactory factory) {
+        this.factory = factory != null ? factory : DEFAULT_FACTORY;
+        handler = new Handler(Looper.getMainLooper(), this /* Callback */);
+    }
+
+    /**
+     * 通过 double-check的方式获取全局唯一的 RequestManager实例对象applicationManager
+     */
+    @NonNull
+    private RequestManager getApplicationManager(@NonNull Context context) {
+        // Either an application context or we're on a background thread.
         if (applicationManager == null) {
-          // Normally pause/resume is taken care of by the fragment we add to the fragment or
-          // activity. However, in this case since the manager attached to the application will not
-          // receive lifecycle events, we must force the manager to start resumed using
-          // ApplicationLifecycle.
-
-          // TODO(b/27524013): Factor out this Glide.get() call.
-          Glide glide = Glide.get(context.getApplicationContext());
-          applicationManager =
-              factory.build(
-                  glide,
-                  new ApplicationLifecycle(),
-                  new EmptyRequestManagerTreeNode(),
-                  context.getApplicationContext());
+            synchronized (this) {
+                if (applicationManager == null) {
+                    // Normally pause/resume is taken care of by the fragment we add to the fragment or
+                    // activity. However, in this case since the manager attached to the application will not
+                    // receive lifecycle events, we must force the manager to start resumed using
+                    // ApplicationLifecycle.
+
+                    // TODO(b/27524013): Factor out this Glide.get() call.
+                    Glide glide = Glide.get(context.getApplicationContext());
+                    // 通过factory构造RequestManager实例
+                    applicationManager =
+                            factory.build(
+                                    glide,
+                                    new ApplicationLifecycle(),
+                                    new EmptyRequestManagerTreeNode(),
+                                    context.getApplicationContext());
+                }
+            }
         }
-      }
+        return applicationManager;
     }
 
-    return applicationManager;
-  }
-
-  @NonNull
-  public RequestManager get(@NonNull Context context) {
-    if (context == null) {
-      throw new IllegalArgumentException("You cannot start a load on a null Context");
-    } else if (Util.isOnMainThread() && !(context instanceof Application)) {
-      if (context instanceof FragmentActivity) {
-        return get((FragmentActivity) context);
-      } else if (context instanceof Activity) {
-        return get((Activity) context);
-      } else if (context instanceof ContextWrapper) {
-        return get(((ContextWrapper) context).getBaseContext());
-      }
-    }
+    @NonNull
+    public RequestManager get(@NonNull Context context) {
+        if (context == null) {
+            // context为null，抛出异常
+            throw new IllegalArgumentException("You cannot start a load on a null Context");
+        } else if (Util.isOnMainThread() && !(context instanceof Application)) {
+            // 如果当前是主线程 并且 Context不是Application
+            if (context instanceof FragmentActivity) {
+                // get(FragmentActivity activity)
+                return get((FragmentActivity) context);
+            } else if (context instanceof Activity) {
+                // get(Activity activity)
+                return get((Activity) context);
+            } else if (context instanceof ContextWrapper) {
+                //
+                return get(((ContextWrapper) context).getBaseContext());
+            }
+        }
 
-    return getApplicationManager(context);
-  }
-
-  @NonNull
-  public RequestManager get(@NonNull FragmentActivity activity) {
-    if (Util.isOnBackgroundThread()) {
-      return get(activity.getApplicationContext());
-    } else {
-      assertNotDestroyed(activity);
-      FragmentManager fm = activity.getSupportFragmentManager();
-      return supportFragmentGet(
-          activity, fm, /*parentHint=*/ null, isActivityVisible(activity));
-    }
-  }
-
-  @NonNull
-  public RequestManager get(@NonNull Fragment fragment) {
-    Preconditions.checkNotNull(fragment.getActivity(),
-          "You cannot start a load on a fragment before it is attached or after it is destroyed");
-    if (Util.isOnBackgroundThread()) {
-      return get(fragment.getActivity().getApplicationContext());
-    } else {
-      FragmentManager fm = fragment.getChildFragmentManager();
-      return supportFragmentGet(fragment.getActivity(), fm, fragment, fragment.isVisible());
+        // 非主线程，或 Context 是 Application，会调用getApplicationManager方法获取唯一的RequestManager实例
+        return getApplicationManager(context);
     }
-  }
-
-  @SuppressWarnings("deprecation")
-  @NonNull
-  public RequestManager get(@NonNull Activity activity) {
-    if (Util.isOnBackgroundThread()) {
-      return get(activity.getApplicationContext());
-    } else {
-      assertNotDestroyed(activity);
-      android.app.FragmentManager fm = activity.getFragmentManager();
-      return fragmentGet(
-          activity, fm, /*parentHint=*/ null, isActivityVisible(activity));
-    }
-  }
 
-  @SuppressWarnings("deprecation")
-  @NonNull
-  public RequestManager get(@NonNull View view) {
-    if (Util.isOnBackgroundThread()) {
-      return get(view.getContext().getApplicationContext());
+    @NonNull
+    public RequestManager get(@NonNull FragmentActivity activity) {
+        if (Util.isOnBackgroundThread()) {
+            return get(activity.getApplicationContext());
+        } else {
+            assertNotDestroyed(activity);
+            FragmentManager fm = activity.getSupportFragmentManager();
+            return supportFragmentGet(
+                    activity, fm, /*parentHint=*/ null, isActivityVisible(activity));
+        }
     }
 
-    Preconditions.checkNotNull(view);
-    Preconditions.checkNotNull(view.getContext(),
-        "Unable to obtain a request manager for a view without a Context");
-    Activity activity = findActivity(view.getContext());
-    // The view might be somewhere else, like a service.
-    if (activity == null) {
-      return get(view.getContext().getApplicationContext());
+    @NonNull
+    public RequestManager get(@NonNull Fragment fragment) {
+        Preconditions.checkNotNull(fragment.getActivity(),
+                "You cannot start a load on a fragment before it is attached or after it is destroyed");
+        if (Util.isOnBackgroundThread()) {
+            // 是后台线程，则将ApplicationContext作为参数传递给get(Context)方法
+            return get(fragment.getActivity().getApplicationContext());
+        } else {
+            // 是主线程，仍然获取一个FragmentManager对象并将其作为参数传递给supportFragmentGet
+            // FragmentManager对象的作用是将一个隐藏的Fragment添加到当前环境中，用来进行生命周期的检查
+            FragmentManager fm = fragment.getChildFragmentManager();
+            return supportFragmentGet(fragment.getActivity(), fm, fragment, fragment.isVisible());
+        }
     }
 
-    // Support Fragments.
-    // Although the user might have non-support Fragments attached to FragmentActivity, searching
-    // for non-support Fragments is so expensive pre O and that should be rare enough that we
-    // prefer to just fall back to the Activity directly.
-    if (activity instanceof FragmentActivity) {
-      Fragment fragment = findSupportFragment(view, (FragmentActivity) activity);
-      return fragment != null ? get(fragment) : get(activity);
+    @SuppressWarnings("deprecation")
+    @NonNull
+    public RequestManager get(@NonNull Activity activity) {
+        // 是否是后台线程
+        if (Util.isOnBackgroundThread()) {
+            // 是后台线程，则将ApplicationContext作为参数传递给get(Context)方法
+            return get(activity.getApplicationContext());
+        } else {
+            assertNotDestroyed(activity);
+            // 是主线程，则获取Activity的FragmentManager，并作为参数传递给fragmentGet方法
+            android.app.FragmentManager fm = activity.getFragmentManager();
+            return fragmentGet(
+                    activity, fm, /*parentHint=*/ null, isActivityVisible(activity));
+        }
     }
 
-    // Standard Fragments.
-    android.app.Fragment fragment = findFragment(view, activity);
-    if (fragment == null) {
-      return get(activity);
-    }
-    return get(fragment);
-  }
-
-  private static void findAllSupportFragmentsWithViews(
-      @Nullable Collection<Fragment> topLevelFragments,
-      @NonNull Map<View, Fragment> result) {
-    if (topLevelFragments == null) {
-      return;
-    }
-    for (Fragment fragment : topLevelFragments) {
-      // getFragment()s in the support FragmentManager may contain null values, see #1991.
-      if (fragment == null || fragment.getView() == null) {
-        continue;
-      }
-      result.put(fragment.getView(), fragment);
-      findAllSupportFragmentsWithViews(fragment.getChildFragmentManager().getFragments(), result);
-    }
-  }
-
-  @Nullable
-  private Fragment findSupportFragment(@NonNull View target, @NonNull FragmentActivity activity) {
-    tempViewToSupportFragment.clear();
-    findAllSupportFragmentsWithViews(
-        activity.getSupportFragmentManager().getFragments(), tempViewToSupportFragment);
-    Fragment result = null;
-    View activityRoot = activity.findViewById(android.R.id.content);
-    View current = target;
-    while (!current.equals(activityRoot)) {
-      result = tempViewToSupportFragment.get(current);
-      if (result != null) {
-        break;
-      }
-      if (current.getParent() instanceof View) {
-        current = (View) current.getParent();
-      } else {
-        break;
-      }
+    @SuppressWarnings("deprecation")
+    @NonNull
+    public RequestManager get(@NonNull View view) {
+        if (Util.isOnBackgroundThread()) {
+            // 是后台线程，则将ApplicationContext作为参数传递给get(Context)方法
+            return get(view.getContext().getApplicationContext());
+        }
+
+        // 对View和与其关联的Context进行非空检查
+        Preconditions.checkNotNull(view);
+        Preconditions.checkNotNull(view.getContext(),
+                "Unable to obtain a request manager for a view without a Context");
+        // 获取Activity对象，并进行非空判断
+        Activity activity = findActivity(view.getContext());
+        // The view might be somewhere else, like a service.
+        if (activity == null) {
+            return get(view.getContext().getApplicationContext());
+        }
+
+        // Support Fragments.
+        // Although the user might have non-support Fragments attached to FragmentActivity, searching
+        // for non-support Fragments is so expensive pre O and that should be rare enough that we
+        // prefer to just fall back to the Activity directly.
+        if (activity instanceof FragmentActivity) {
+            // 当前Activity是FragmentActivity
+            Fragment fragment = findSupportFragment(view, (FragmentActivity) activity);
+            // 如果能够获取到Fragment，并且不为null，则调用get(Fragment fragment)，否则调用get(Activity activity)
+            return fragment != null ? get(fragment) : get(activity);
+        }
+
+        // Standard Fragments.
+        android.app.Fragment fragment = findFragment(view, activity);
+        if (fragment == null) {
+            // get(Activity activity)
+            return get(activity);
+        }
+
+        // 调用get(android.app.Fragment fragment)
+        return get(fragment);
     }
 
-    tempViewToSupportFragment.clear();
-    return result;
-  }
-
-  @SuppressWarnings({"deprecation", "DeprecatedIsStillUsed"})
-  @Deprecated
-  @Nullable
-  private android.app.Fragment findFragment(@NonNull View target, @NonNull Activity activity) {
-    tempViewToFragment.clear();
-    findAllFragmentsWithViews(activity.getFragmentManager(), tempViewToFragment);
-
-    android.app.Fragment result = null;
-
-    View activityRoot = activity.findViewById(android.R.id.content);
-    View current = target;
-    while (!current.equals(activityRoot)) {
-      result = tempViewToFragment.get(current);
-      if (result != null) {
-        break;
-      }
-      if (current.getParent() instanceof View) {
-        current = (View) current.getParent();
-      } else {
-        break;
-      }
+    private static void findAllSupportFragmentsWithViews(
+            @Nullable Collection<Fragment> topLevelFragments,
+            @NonNull Map<View, Fragment> result) {
+        if (topLevelFragments == null) {
+            return;
+        }
+        for (Fragment fragment : topLevelFragments) {
+            // getFragment()s in the support FragmentManager may contain null values, see #1991.
+            if (fragment == null || fragment.getView() == null) {
+                continue;
+            }
+            result.put(fragment.getView(), fragment);
+            findAllSupportFragmentsWithViews(fragment.getChildFragmentManager().getFragments(), result);
+        }
     }
-    tempViewToFragment.clear();
-    return result;
-  }
-
-  // TODO: Consider using an accessor class in the support library package to more directly retrieve
-  // non-support Fragments.
-  @SuppressWarnings("deprecation")
-  @Deprecated
-  @TargetApi(Build.VERSION_CODES.O)
-  private void findAllFragmentsWithViews(
-      @NonNull android.app.FragmentManager fragmentManager,
-      @NonNull ArrayMap<View, android.app.Fragment> result) {
-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
-      for (android.app.Fragment fragment : fragmentManager.getFragments()) {
-        if (fragment.getView() != null) {
-          result.put(fragment.getView(), fragment);
-          findAllFragmentsWithViews(fragment.getChildFragmentManager(), result);
+
+    @Nullable
+    private Fragment findSupportFragment(@NonNull View target, @NonNull FragmentActivity activity) {
+        tempViewToSupportFragment.clear();
+        findAllSupportFragmentsWithViews(
+                activity.getSupportFragmentManager().getFragments(), tempViewToSupportFragment);
+        Fragment result = null;
+        View activityRoot = activity.findViewById(android.R.id.content);
+        View current = target;
+        while (!current.equals(activityRoot)) {
+            result = tempViewToSupportFragment.get(current);
+            if (result != null) {
+                break;
+            }
+            if (current.getParent() instanceof View) {
+                current = (View) current.getParent();
+            } else {
+                break;
+            }
         }
-      }
-    } else {
-      findAllFragmentsWithViewsPreO(fragmentManager, result);
+
+        tempViewToSupportFragment.clear();
+        return result;
     }
-  }
-
-  @SuppressWarnings("deprecation")
-  @Deprecated
-  private void findAllFragmentsWithViewsPreO(
-      @NonNull android.app.FragmentManager fragmentManager,
-      @NonNull ArrayMap<View, android.app.Fragment> result) {
-    int index = 0;
-    while (true) {
-      tempBundle.putInt(FRAGMENT_INDEX_KEY, index++);
-      android.app.Fragment fragment = null;
-      try {
-        fragment = fragmentManager.getFragment(tempBundle, FRAGMENT_INDEX_KEY);
-      } catch (Exception e) {
-        // This generates log spam from FragmentManager anyway.
-      }
-      if (fragment == null) {
-        break;
-      }
-      if (fragment.getView() != null) {
-        result.put(fragment.getView(), fragment);
-        if (VERSION.SDK_INT >= VERSION_CODES.JELLY_BEAN_MR1) {
-          findAllFragmentsWithViews(fragment.getChildFragmentManager(), result);
+
+    @SuppressWarnings({"deprecation", "DeprecatedIsStillUsed"})
+    @Deprecated
+    @Nullable
+    private android.app.Fragment findFragment(@NonNull View target, @NonNull Activity activity) {
+        tempViewToFragment.clear();
+        findAllFragmentsWithViews(activity.getFragmentManager(), tempViewToFragment);
+
+        android.app.Fragment result = null;
+
+        View activityRoot = activity.findViewById(android.R.id.content);
+        View current = target;
+        while (!current.equals(activityRoot)) {
+            result = tempViewToFragment.get(current);
+            if (result != null) {
+                break;
+            }
+            if (current.getParent() instanceof View) {
+                current = (View) current.getParent();
+            } else {
+                break;
+            }
         }
-      }
+        tempViewToFragment.clear();
+        return result;
     }
-  }
-
-  @Nullable
-  private Activity findActivity(@NonNull Context context) {
-    if (context instanceof Activity) {
-      return (Activity) context;
-    } else if (context instanceof ContextWrapper) {
-      return findActivity(((ContextWrapper) context).getBaseContext());
-    } else {
-      return null;
+
+    // TODO: Consider using an accessor class in the support library package to more directly retrieve
+    // non-support Fragments.
+    @SuppressWarnings("deprecation")
+    @Deprecated
+    @TargetApi(Build.VERSION_CODES.O)
+    private void findAllFragmentsWithViews(
+            @NonNull android.app.FragmentManager fragmentManager,
+            @NonNull ArrayMap<View, android.app.Fragment> result) {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+            for (android.app.Fragment fragment : fragmentManager.getFragments()) {
+                if (fragment.getView() != null) {
+                    result.put(fragment.getView(), fragment);
+                    findAllFragmentsWithViews(fragment.getChildFragmentManager(), result);
+                }
+            }
+        } else {
+            findAllFragmentsWithViewsPreO(fragmentManager, result);
+        }
     }
-  }
 
-  @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
-  private static void assertNotDestroyed(@NonNull Activity activity) {
-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1 && activity.isDestroyed()) {
-      throw new IllegalArgumentException("You cannot start a load for a destroyed activity");
+    @SuppressWarnings("deprecation")
+    @Deprecated
+    private void findAllFragmentsWithViewsPreO(
+            @NonNull android.app.FragmentManager fragmentManager,
+            @NonNull ArrayMap<View, android.app.Fragment> result) {
+        int index = 0;
+        while (true) {
+            tempBundle.putInt(FRAGMENT_INDEX_KEY, index++);
+            android.app.Fragment fragment = null;
+            try {
+                fragment = fragmentManager.getFragment(tempBundle, FRAGMENT_INDEX_KEY);
+            } catch (Exception e) {
+                // This generates log spam from FragmentManager anyway.
+            }
+            if (fragment == null) {
+                break;
+            }
+            if (fragment.getView() != null) {
+                result.put(fragment.getView(), fragment);
+                if (VERSION.SDK_INT >= VERSION_CODES.JELLY_BEAN_MR1) {
+                    findAllFragmentsWithViews(fragment.getChildFragmentManager(), result);
+                }
+            }
+        }
     }
-  }
-
-  @SuppressWarnings("deprecation")
-  @Deprecated
-  @NonNull
-  @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
-  public RequestManager get(@NonNull android.app.Fragment fragment) {
-    if (fragment.getActivity() == null) {
-      throw new IllegalArgumentException(
-          "You cannot start a load on a fragment before it is attached");
+
+    @Nullable
+    private Activity findActivity(@NonNull Context context) {
+        if (context instanceof Activity) {
+            return (Activity) context;
+        } else if (context instanceof ContextWrapper) {
+            return findActivity(((ContextWrapper) context).getBaseContext());
+        } else {
+            return null;
+        }
     }
-    if (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {
-      return get(fragment.getActivity().getApplicationContext());
-    } else {
-      android.app.FragmentManager fm = fragment.getChildFragmentManager();
-      return fragmentGet(fragment.getActivity(), fm, fragment, fragment.isVisible());
+
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+    private static void assertNotDestroyed(@NonNull Activity activity) {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1 && activity.isDestroyed()) {
+            throw new IllegalArgumentException("You cannot start a load for a destroyed activity");
+        }
     }
-  }
-
-  @SuppressWarnings("deprecation")
-  @Deprecated
-  @NonNull
-  RequestManagerFragment getRequestManagerFragment(Activity activity) {
-    return getRequestManagerFragment(
-        activity.getFragmentManager(), /*parentHint=*/ null, isActivityVisible(activity));
-  }
-
-  @SuppressWarnings("deprecation")
-  @NonNull
-  private RequestManagerFragment getRequestManagerFragment(
-      @NonNull final android.app.FragmentManager fm,
-      @Nullable android.app.Fragment parentHint,
-      boolean isParentVisible) {
-    RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);
-    if (current == null) {
-      current = pendingRequestManagerFragments.get(fm);
-      if (current == null) {
-        current = new RequestManagerFragment();
-        current.setParentFragmentHint(parentHint);
-        if (isParentVisible) {
-          current.getGlideLifecycle().onStart();
+
+    @SuppressWarnings("deprecation")
+    @Deprecated
+    @NonNull
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+    public RequestManager get(@NonNull android.app.Fragment fragment) {
+        if (fragment.getActivity() == null) {
+            throw new IllegalArgumentException(
+                    "You cannot start a load on a fragment before it is attached");
+        }
+        if (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {
+            // 后台线程，或当前的sdk版本小与17
+            // 则将ApplicationContext作为参数传递给get(Context)方法
+            return get(fragment.getActivity().getApplicationContext());
+        } else {
+            android.app.FragmentManager fm = fragment.getChildFragmentManager();
+            return fragmentGet(fragment.getActivity(), fm, fragment, fragment.isVisible());
         }
-        pendingRequestManagerFragments.put(fm, current);
-        fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();
-        handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();
-      }
     }
-    return current;
-  }
-
-  @SuppressWarnings({"deprecation", "DeprecatedIsStillUsed"})
-  @Deprecated
-  @NonNull
-  private RequestManager fragmentGet(@NonNull Context context,
-      @NonNull android.app.FragmentManager fm,
-      @Nullable android.app.Fragment parentHint,
-      boolean isParentVisible) {
-    RequestManagerFragment current = getRequestManagerFragment(fm, parentHint, isParentVisible);
-    RequestManager requestManager = current.getRequestManager();
-    if (requestManager == null) {
-      // TODO(b/27524013): Factor out this Glide.get() call.
-      Glide glide = Glide.get(context);
-      requestManager =
-          factory.build(
-              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);
-      current.setRequestManager(requestManager);
+
+    @SuppressWarnings("deprecation")
+    @Deprecated
+    @NonNull
+    RequestManagerFragment getRequestManagerFragment(Activity activity) {
+        return getRequestManagerFragment(
+                activity.getFragmentManager(), /*parentHint=*/ null, isActivityVisible(activity));
     }
-    return requestManager;
-  }
-
-  @NonNull
-  SupportRequestManagerFragment getSupportRequestManagerFragment(FragmentActivity activity) {
-    return getSupportRequestManagerFragment(
-        activity.getSupportFragmentManager(), /*parentHint=*/ null, isActivityVisible(activity));
-  }
-
-  private static boolean isActivityVisible(Activity activity) {
-    // This is a poor heuristic, but it's about all we have. We'd rather err on the side of visible
-    // and start requests than on the side of invisible and ignore valid requests.
-    return !activity.isFinishing();
-  }
-
-  @NonNull
-  private SupportRequestManagerFragment getSupportRequestManagerFragment(
-      @NonNull final FragmentManager fm, @Nullable Fragment parentHint, boolean isParentVisible) {
-    SupportRequestManagerFragment current =
-        (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);
-    if (current == null) {
-      current = pendingSupportRequestManagerFragments.get(fm);
-      if (current == null) {
-        current = new SupportRequestManagerFragment();
-        current.setParentFragmentHint(parentHint);
-        if (isParentVisible) {
-          current.getGlideLifecycle().onStart();
+
+    @SuppressWarnings("deprecation")
+    @NonNull
+    private RequestManagerFragment getRequestManagerFragment(
+            @NonNull final android.app.FragmentManager fm,
+            @Nullable android.app.Fragment parentHint,
+            boolean isParentVisible) {
+        // 根据tag在传入的FragmentManager中查找 RequestManagerFragment
+        RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);
+        if (current == null) {
+            // 没有找到，从pendingRequestManagerFragments中获取缓存的
+            current = pendingRequestManagerFragments.get(fm);
+            if (current == null) {
+                // 没有缓存的RequestManagerFragment，那么就通过构造方法构造一个
+                current = new RequestManagerFragment();
+                current.setParentFragmentHint(parentHint);
+                if (isParentVisible) {
+                    // 如果这个RequestManagerFragment需要加入的parent可见，则回调onStart
+                    current.getGlideLifecycle().onStart();
+                }
+                // 缓存RequestManagerFragment对象，key为FragmentManager，value为RequestManagerFragment对象
+                pendingRequestManagerFragments.put(fm, current);
+                fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();
+
+                // ？？？？
+                handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();
+            }
         }
-        pendingSupportRequestManagerFragments.put(fm, current);
-        fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();
-        handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();
-      }
+        return current;
     }
-    return current;
-  }
-
-  @NonNull
-  private RequestManager supportFragmentGet(
-      @NonNull Context context,
-      @NonNull FragmentManager fm,
-      @Nullable Fragment parentHint,
-      boolean isParentVisible) {
-    SupportRequestManagerFragment current =
-        getSupportRequestManagerFragment(fm, parentHint, isParentVisible);
-    RequestManager requestManager = current.getRequestManager();
-    if (requestManager == null) {
-      // TODO(b/27524013): Factor out this Glide.get() call.
-      Glide glide = Glide.get(context);
-      requestManager =
-          factory.build(
-              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);
-      current.setRequestManager(requestManager);
+
+    @SuppressWarnings({"deprecation", "DeprecatedIsStillUsed"})
+    @Deprecated
+    @NonNull
+    private RequestManager fragmentGet(@NonNull Context context,
+                                       @NonNull android.app.FragmentManager fm,
+                                       @Nullable android.app.Fragment parentHint,
+                                       boolean isParentVisible) {
+        // 1、通过getRequestManagerFragment获取一个可用的RequestManagerFragment对象
+        RequestManagerFragment current = getRequestManagerFragment(fm, parentHint, isParentVisible);
+
+        // 2、获取RequestManagerFragment中的成员变量RequestManager
+        RequestManager requestManager = current.getRequestManager();
+        if (requestManager == null) {
+            // TODO(b/27524013): Factor out this Glide.get() call.
+            // 获取失败，则通过factory构造出一个requestManager，并将其设置给current
+            Glide glide = Glide.get(context);
+            requestManager =
+                    factory.build(
+                            glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);
+            current.setRequestManager(requestManager);
+        }
+        return requestManager;
     }
-    return requestManager;
-  }
-
-  @Override
-  public boolean handleMessage(Message message) {
-    boolean handled = true;
-    Object removed = null;
-    Object key = null;
-    switch (message.what) {
-      case ID_REMOVE_FRAGMENT_MANAGER:
-        android.app.FragmentManager fm = (android.app.FragmentManager) message.obj;
-        key = fm;
-        removed = pendingRequestManagerFragments.remove(fm);
-        break;
-      case ID_REMOVE_SUPPORT_FRAGMENT_MANAGER:
-        FragmentManager supportFm = (FragmentManager) message.obj;
-        key = supportFm;
-        removed = pendingSupportRequestManagerFragments.remove(supportFm);
-        break;
-      default:
-        handled = false;
-        break;
+
+    @NonNull
+    SupportRequestManagerFragment getSupportRequestManagerFragment(FragmentActivity activity) {
+        return getSupportRequestManagerFragment(
+                activity.getSupportFragmentManager(), /*parentHint=*/ null, isActivityVisible(activity));
     }
-    if (handled && removed == null && Log.isLoggable(TAG, Log.WARN)) {
-      Log.w(TAG, "Failed to remove expected request manager fragment, manager: " + key);
+
+    private static boolean isActivityVisible(Activity activity) {
+        // This is a poor heuristic, but it's about all we have. We'd rather err on the side of visible
+        // and start requests than on the side of invisible and ignore valid requests.
+        return !activity.isFinishing();
     }
-    return handled;
-  }
 
-  /**
-   * Used internally to create {@link RequestManager}s.
-   */
-  public interface RequestManagerFactory {
     @NonNull
-    RequestManager build(
-        @NonNull Glide glide,
-        @NonNull Lifecycle lifecycle,
-        @NonNull RequestManagerTreeNode requestManagerTreeNode,
-        @NonNull Context context);
-  }
-
-  private static final RequestManagerFactory DEFAULT_FACTORY = new RequestManagerFactory() {
+    private SupportRequestManagerFragment getSupportRequestManagerFragment(
+            @NonNull final FragmentManager fm, @Nullable Fragment parentHint, boolean isParentVisible) {
+        // 根据tag在传入的FragmentManager中查找 SupportRequestManagerFragment
+        SupportRequestManagerFragment current =
+                (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);
+        if (current == null) {
+            // 没有找到，从 pendingSupportRequestManagerFragments 中获取缓存的
+            current = pendingSupportRequestManagerFragments.get(fm);
+            if (current == null) {
+                // 没有缓存的 SupportRequestManagerFragment，那么就通过构造方法构造一个
+                current = new SupportRequestManagerFragment();
+                current.setParentFragmentHint(parentHint);
+                if (isParentVisible) {
+                    // 如果这个 SupportRequestManagerFragment 需要加入的parent可见，则回调onStart
+                    current.getGlideLifecycle().onStart();
+                }
+                // 缓存SupportRequestManagerFragment对象，key为FragmentManager，value为SupportRequestManagerFragment对象
+                pendingSupportRequestManagerFragments.put(fm, current);
+                fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();
+                handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();
+            }
+        }
+        return current;
+    }
+
     @NonNull
+    private RequestManager supportFragmentGet(
+            @NonNull Context context,
+            @NonNull FragmentManager fm,
+            @Nullable Fragment parentHint,
+            boolean isParentVisible) {
+        // 1、获取SupportRequestManagerFragment对象
+        SupportRequestManagerFragment current =
+                getSupportRequestManagerFragment(fm, parentHint, isParentVisible);
+
+        // 2、获取SupportRequestManagerFragment中的成员变量RequestManager
+        RequestManager requestManager = current.getRequestManager();
+        if (requestManager == null) {
+            // TODO(b/27524013): Factor out this Glide.get() call.
+            // 获取失败，则通过factory构造出一个requestManager，并将其设置给current
+            Glide glide = Glide.get(context);
+            requestManager =
+                    factory.build(
+                            glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);
+            current.setRequestManager(requestManager);
+        }
+        return requestManager;
+    }
+
     @Override
-    public RequestManager build(@NonNull Glide glide, @NonNull Lifecycle lifecycle,
-        @NonNull RequestManagerTreeNode requestManagerTreeNode, @NonNull Context context) {
-      return new RequestManager(glide, lifecycle, requestManagerTreeNode, context);
+    public boolean handleMessage(Message message) {
+        boolean handled = true;
+        Object removed = null;
+        Object key = null;
+        switch (message.what) {
+            case ID_REMOVE_FRAGMENT_MANAGER:
+                android.app.FragmentManager fm = (android.app.FragmentManager) message.obj;
+                key = fm;
+                removed = pendingRequestManagerFragments.remove(fm);
+                break;
+            case ID_REMOVE_SUPPORT_FRAGMENT_MANAGER:
+                FragmentManager supportFm = (FragmentManager) message.obj;
+                key = supportFm;
+                removed = pendingSupportRequestManagerFragments.remove(supportFm);
+                break;
+            default:
+                handled = false;
+                break;
+        }
+        if (handled && removed == null && Log.isLoggable(TAG, Log.WARN)) {
+            Log.w(TAG, "Failed to remove expected request manager fragment, manager: " + key);
+        }
+        return handled;
     }
-  };
+
+    /**
+     * Used internally to create {@link RequestManager}s.
+     */
+    public interface RequestManagerFactory {
+        @NonNull
+        RequestManager build(
+                @NonNull Glide glide,
+                @NonNull Lifecycle lifecycle,
+                @NonNull RequestManagerTreeNode requestManagerTreeNode,
+                @NonNull Context context);
+    }
+
+    private static final RequestManagerFactory DEFAULT_FACTORY = new RequestManagerFactory() {
+        @NonNull
+        @Override
+        public RequestManager build(@NonNull Glide glide, @NonNull Lifecycle lifecycle,
+                                    @NonNull RequestManagerTreeNode requestManagerTreeNode, @NonNull Context context) {
+            return new RequestManager(glide, lifecycle, requestManagerTreeNode, context);
+        }
+    };
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
index 97567671b..d84997d14 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
@@ -16,6 +16,9 @@
  * A class for tracking, canceling, and restarting in progress, completed, and failed requests.
  *
  * <p>This class is not thread safe and must be accessed on the main thread.
+ *
+ * 管理 Request
+ *
  */
 public class RequestTracker {
   private static final String TAG = "RequestTracker";
@@ -39,14 +42,20 @@
    * Starts tracking the given request.
    */
   public void runRequest(@NonNull Request request) {
+    // 将请求加入到requests的set中
     requests.add(request);
+
+    // isPaused变量标识界面是否处于onStop状态
     if (!isPaused) {
+      // 可见则直接开始请求
       request.begin();
     } else {
+      // 不可见
       request.clear();
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
         Log.v(TAG, "Paused, delaying request");
       }
+      // 将请求加入到pendingRequests中
       pendingRequests.add(request);
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java b/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java
index 45ad1252a..75eecb811 100644
--- a/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java
+++ b/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java
@@ -11,6 +11,12 @@
 /**
  * Holds the set of {@link Target}s currently active for a
  * {@link com.bumptech.glide.RequestManager} and forwards on lifecycle events.
+ *
+ * 管理 target。
+ *
+ * 有一个Set保存 所管理的target，
+ * 其中保存了由当前RequestManager在处理的所有target的集合
+ *
  */
 public final class TargetTracker implements LifecycleListener {
   private final Set<Target<?>> targets =
diff --git a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
index 7207bc57e..f58e92b62 100644
--- a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
@@ -8,6 +8,7 @@
 import android.support.annotation.Nullable;
 import android.support.v4.util.Pools;
 import android.util.Log;
+
 import com.bumptech.glide.GlideContext;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
@@ -24,6 +25,7 @@
 import com.bumptech.glide.util.Util;
 import com.bumptech.glide.util.pool.FactoryPools;
 import com.bumptech.glide.util.pool.StateVerifier;
+
 import java.util.List;
 
 /**
@@ -33,617 +35,638 @@
  * @param <R> The type of the resource that will be transcoded from the loaded resource.
  */
 public final class SingleRequest<R> implements Request,
-    SizeReadyCallback,
-    ResourceCallback,
-    FactoryPools.Poolable {
-  /** Tag for logging internal events, not generally suitable for public use. */
-  private static final String TAG = "Request";
-  /** Tag for logging externally useful events (request completion, timing etc). */
-  private static final String GLIDE_TAG = "Glide";
-  private static final Pools.Pool<SingleRequest<?>> POOL = FactoryPools.simple(150,
-      new FactoryPools.Factory<SingleRequest<?>>() {
-        @Override
-        public SingleRequest<?> create() {
-          return new SingleRequest<Object>();
-        }
-      });
-  private boolean isCallingCallbacks;
-
-  private static final boolean IS_VERBOSE_LOGGABLE =
-      Log.isLoggable(TAG, Log.VERBOSE);
-
-  private enum Status {
+        SizeReadyCallback,
+        ResourceCallback,
+        FactoryPools.Poolable {
     /**
-     * Created but not yet running.
+     * Tag for logging internal events, not generally suitable for public use.
      */
-    PENDING,
+    private static final String TAG = "Request";
     /**
-     * In the process of fetching media.
+     * Tag for logging externally useful events (request completion, timing etc).
      */
-    RUNNING,
+    private static final String GLIDE_TAG = "Glide";
+    private static final Pools.Pool<SingleRequest<?>> POOL = FactoryPools.simple(150,
+            new FactoryPools.Factory<SingleRequest<?>>() {
+                @Override
+                public SingleRequest<?> create() {
+                    return new SingleRequest<Object>();
+                }
+            });
+    private boolean isCallingCallbacks;
+
+    private static final boolean IS_VERBOSE_LOGGABLE =
+            Log.isLoggable(TAG, Log.VERBOSE);
+
+    private enum Status {
+        /**
+         * Created but not yet running.
+         */
+        PENDING,
+        /**
+         * In the process of fetching media.
+         */
+        RUNNING,
+        /**
+         * Waiting for a callback given to the Target to be called to determine target dimensions.
+         */
+        WAITING_FOR_SIZE,
+        /**
+         * Finished loading media successfully.
+         */
+        COMPLETE,
+        /**
+         * Failed to load media, may be restarted.
+         */
+        FAILED,
+        /**
+         * Cleared by the user with a placeholder set, may be restarted.
+         */
+        CLEARED,
+    }
+
+    @Nullable
+    private final String tag = IS_VERBOSE_LOGGABLE ? String.valueOf(super.hashCode()) : null;
+    private final StateVerifier stateVerifier = StateVerifier.newInstance();
+
+    @Nullable
+    private RequestListener<R> targetListener;
+    private RequestCoordinator requestCoordinator;
+    private Context context;
+    private GlideContext glideContext;
+    @Nullable
+    private Object model;
+    private Class<R> transcodeClass;
+    private BaseRequestOptions<?> requestOptions;
+    private int overrideWidth;
+    private int overrideHeight;
+    private Priority priority;
+    private Target<R> target;
+    @Nullable
+    private List<RequestListener<R>> requestListeners;
+    private Engine engine;
+    private TransitionFactory<? super R> animationFactory;
+    private Resource<R> resource;
+    private Engine.LoadStatus loadStatus;
+    private long startTime;
+    private Status status;
+    private Drawable errorDrawable;
+    private Drawable placeholderDrawable;
+    private Drawable fallbackDrawable;
+    private int width;
+    private int height;
+
+    public static <R> SingleRequest<R> obtain(
+            Context context,
+            GlideContext glideContext,
+            Object model,
+            Class<R> transcodeClass,
+            BaseRequestOptions<?> requestOptions,
+            int overrideWidth,
+            int overrideHeight,
+            Priority priority,
+            Target<R> target,
+            RequestListener<R> targetListener,
+            @Nullable List<RequestListener<R>> requestListeners,
+            RequestCoordinator requestCoordinator,
+            Engine engine,
+            TransitionFactory<? super R> animationFactory) {
+        // 首先进行复用
+        @SuppressWarnings("unchecked") SingleRequest<R> request =
+                (SingleRequest<R>) POOL.acquire();
+        if (request == null) {
+            //  不能复用，则创建新的
+            request = new SingleRequest<>();
+        }
+        request.init(
+                context,
+                glideContext,
+                model,
+                transcodeClass,
+                requestOptions,
+                overrideWidth,
+                overrideHeight,
+                priority,
+                target,
+                targetListener,
+                requestListeners,
+                requestCoordinator,
+                engine,
+                animationFactory);
+        return request;
+    }
+
+    @SuppressWarnings("WeakerAccess")
+    @Synthetic
+    SingleRequest() {
+        // just create, instances are reused with recycle/init
+    }
+
+    private void init(
+            Context context,
+            GlideContext glideContext,
+            Object model,
+            Class<R> transcodeClass,
+            BaseRequestOptions<?> requestOptions,
+            int overrideWidth,
+            int overrideHeight,
+            Priority priority,
+            Target<R> target,
+            RequestListener<R> targetListener,
+            @Nullable List<RequestListener<R>> requestListeners,
+            RequestCoordinator requestCoordinator,
+            Engine engine,
+            TransitionFactory<? super R> animationFactory) {
+        this.context = context;
+        this.glideContext = glideContext;
+        this.model = model;
+        this.transcodeClass = transcodeClass;
+        this.requestOptions = requestOptions;
+        this.overrideWidth = overrideWidth;
+        this.overrideHeight = overrideHeight;
+        this.priority = priority;
+        this.target = target;
+        this.targetListener = targetListener;
+        this.requestListeners = requestListeners;
+        this.requestCoordinator = requestCoordinator;
+        this.engine = engine;
+        this.animationFactory = animationFactory;
+        status = Status.PENDING;
+    }
+
+    @NonNull
+    @Override
+    public StateVerifier getVerifier() {
+        return stateVerifier;
+    }
+
+    @Override
+    public void recycle() {
+        assertNotCallingCallbacks();
+        context = null;
+        glideContext = null;
+        model = null;
+        transcodeClass = null;
+        requestOptions = null;
+        overrideWidth = -1;
+        overrideHeight = -1;
+        target = null;
+        requestListeners = null;
+        targetListener = null;
+        requestCoordinator = null;
+        animationFactory = null;
+        loadStatus = null;
+        errorDrawable = null;
+        placeholderDrawable = null;
+        fallbackDrawable = null;
+        width = -1;
+        height = -1;
+        POOL.release(this);
+    }
+
+    @Override
+    public void begin() {
+        assertNotCallingCallbacks();
+        stateVerifier.throwIfRecycled();
+        startTime = LogTime.getLogTime();
+        // 1、对model进行检查
+        if (model == null) {
+            // model为null，直接回调onLoadFailed
+            if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
+                width = overrideWidth;
+                height = overrideHeight;
+            }
+            // Only log at more verbose log levels if the user has set a fallback drawable, because
+            // fallback Drawables indicate the user expects null models occasionally.
+            int logLevel = getFallbackDrawable() == null ? Log.WARN : Log.DEBUG;
+            onLoadFailed(new GlideException("Received null model"), logLevel);
+            return;
+        }
+
+        // 2、当前请求是否正在执行
+        if (status == Status.RUNNING) {
+            // 是，则直接抛出异常，一个请求不能执行两次
+            throw new IllegalArgumentException("Cannot restart a running request");
+        }
+
+        // If we're restarted after we're complete (usually via something like a notifyDataSetChanged
+        // that starts an identical request into the same Target or View), we can simply use the
+        // resource and size we retrieved the last time around and skip obtaining a new size, starting a
+        // new load etc. This does mean that users who want to restart a load because they expect that
+        // the view size has changed will need to explicitly clear the View or Target before starting
+        // the new load.
+        // 3、请求是否已经完成
+        if (status == Status.COMPLETE) {
+            // 完成，则直接回调 onResourceReady
+            onResourceReady(resource, DataSource.MEMORY_CACHE);
+            return;
+        }
+
+        // Restarts for requests that are neither complete nor running can be treated as new requests
+        // and can run again from the beginning.
+
+        status = Status.WAITING_FOR_SIZE;
+        // 4、是否通过override设置过图片尺寸
+        if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
+            // 是则 直接 调用 onSizeReady
+            onSizeReady(overrideWidth, overrideHeight);
+        } else {
+            // 计算size
+            target.getSize(this);
+        }
+
+        if ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)
+                && canNotifyStatusChanged()) {
+            // 5、回调 开始加载
+            target.onLoadStarted(getPlaceholderDrawable());
+        }
+        if (IS_VERBOSE_LOGGABLE) {
+            logV("finished run method in " + LogTime.getElapsedMillis(startTime));
+        }
+    }
+
     /**
-     * Waiting for a callback given to the Target to be called to determine target dimensions.
+     * Cancels the current load but does not release any resources held by the request and continues
+     * to display the loaded resource if the load completed before the call to cancel.
+     * <p>
+     * <p> Cancelled requests can be restarted with a subsequent call to {@link #begin()}. </p>
+     *
+     * @see #clear()
      */
-    WAITING_FOR_SIZE,
+    private void cancel() {
+        assertNotCallingCallbacks();
+        stateVerifier.throwIfRecycled();
+        target.removeCallback(this);
+        if (loadStatus != null) {
+            loadStatus.cancel();
+            loadStatus = null;
+        }
+    }
+
+    // Avoids difficult to understand errors like #2413.
+    private void assertNotCallingCallbacks() {
+        if (isCallingCallbacks) {
+            throw new IllegalStateException("You can't start or clear loads in RequestListener or"
+                    + " Target callbacks. If you're trying to start a fallback request when a load fails, use"
+                    + " RequestBuilder#error(RequestBuilder). Otherwise consider posting your into() or"
+                    + " clear() calls to the main thread using a Handler instead.");
+        }
+    }
+
     /**
-     * Finished loading media successfully.
+     * Cancels the current load if it is in progress, clears any resources held onto by the request
+     * and replaces the loaded resource if the load completed with the placeholder.
+     * <p>
+     * <p> Cleared requests can be restarted with a subsequent call to {@link #begin()} </p>
+     *
+     * @see #cancel()
      */
-    COMPLETE,
+    @Override
+    public void clear() {
+        Util.assertMainThread();
+        assertNotCallingCallbacks();
+        stateVerifier.throwIfRecycled();
+        if (status == Status.CLEARED) {
+            return;
+        }
+        cancel();
+        // Resource must be released before canNotifyStatusChanged is called.
+        if (resource != null) {
+            releaseResource(resource);
+        }
+        if (canNotifyCleared()) {
+            target.onLoadCleared(getPlaceholderDrawable());
+        }
+
+        status = Status.CLEARED;
+    }
+
+    private void releaseResource(Resource<?> resource) {
+        engine.release(resource);
+        this.resource = null;
+    }
+
+    @Override
+    public boolean isRunning() {
+        return status == Status.RUNNING || status == Status.WAITING_FOR_SIZE;
+    }
+
+    @Override
+    public boolean isComplete() {
+        return status == Status.COMPLETE;
+    }
+
+    @Override
+    public boolean isResourceSet() {
+        return isComplete();
+    }
+
+    @Override
+    public boolean isCleared() {
+        return status == Status.CLEARED;
+    }
+
+    @Override
+    public boolean isFailed() {
+        return status == Status.FAILED;
+    }
+
+    private Drawable getErrorDrawable() {
+        if (errorDrawable == null) {
+            errorDrawable = requestOptions.getErrorPlaceholder();
+            if (errorDrawable == null && requestOptions.getErrorId() > 0) {
+                errorDrawable = loadDrawable(requestOptions.getErrorId());
+            }
+        }
+        return errorDrawable;
+    }
+
+    private Drawable getPlaceholderDrawable() {
+        if (placeholderDrawable == null) {
+            placeholderDrawable = requestOptions.getPlaceholderDrawable();
+            if (placeholderDrawable == null && requestOptions.getPlaceholderId() > 0) {
+                placeholderDrawable = loadDrawable(requestOptions.getPlaceholderId());
+            }
+        }
+        return placeholderDrawable;
+    }
+
+    private Drawable getFallbackDrawable() {
+        if (fallbackDrawable == null) {
+            fallbackDrawable = requestOptions.getFallbackDrawable();
+            if (fallbackDrawable == null && requestOptions.getFallbackId() > 0) {
+                fallbackDrawable = loadDrawable(requestOptions.getFallbackId());
+            }
+        }
+        return fallbackDrawable;
+    }
+
+    private Drawable loadDrawable(@DrawableRes int resourceId) {
+        Theme theme = requestOptions.getTheme() != null
+                ? requestOptions.getTheme() : context.getTheme();
+        return DrawableDecoderCompat.getDrawable(glideContext, resourceId, theme);
+    }
+
+    private void setErrorPlaceholder() {
+        if (!canNotifyStatusChanged()) {
+            return;
+        }
+
+        Drawable error = null;
+        if (model == null) {
+            error = getFallbackDrawable();
+        }
+        // Either the model isn't null, or there was no fallback drawable set.
+        if (error == null) {
+            error = getErrorDrawable();
+        }
+        // The model isn't null, no fallback drawable was set or no error drawable was set.
+        if (error == null) {
+            error = getPlaceholderDrawable();
+        }
+        target.onLoadFailed(error);
+    }
+
     /**
-     * Failed to load media, may be restarted.
+     * A callback method that should never be invoked directly.
      */
-    FAILED,
+    @Override
+    public void onSizeReady(int width, int height) {
+        stateVerifier.throwIfRecycled();
+        if (IS_VERBOSE_LOGGABLE) {
+            logV("Got onSizeReady in " + LogTime.getElapsedMillis(startTime));
+        }
+        // 1、检查是不是等待 size
+        if (status != Status.WAITING_FOR_SIZE) {
+            // 不是，表明已经 计算好 size了
+            return;
+        }
+
+        // 将状态更新为RUNNING
+        status = Status.RUNNING;
+
+        float sizeMultiplier = requestOptions.getSizeMultiplier();
+        this.width = maybeApplySizeMultiplier(width, sizeMultiplier);
+        this.height = maybeApplySizeMultiplier(height, sizeMultiplier);
+
+        if (IS_VERBOSE_LOGGABLE) {
+            logV("finished setup for calling load in " + LogTime.getElapsedMillis(startTime));
+        }
+        loadStatus = engine.load(
+                glideContext,
+                model,
+                requestOptions.getSignature(),
+                this.width,
+                this.height,
+                requestOptions.getResourceClass(),
+                transcodeClass,
+                priority,
+                requestOptions.getDiskCacheStrategy(),
+                requestOptions.getTransformations(),
+                requestOptions.isTransformationRequired(),
+                requestOptions.isScaleOnlyOrNoTransform(),
+                requestOptions.getOptions(),
+                requestOptions.isMemoryCacheable(),
+                requestOptions.getUseUnlimitedSourceGeneratorsPool(),
+                requestOptions.getUseAnimationPool(),
+                requestOptions.getOnlyRetrieveFromCache(),
+                this);
+
+        // This is a hack that's only useful for testing right now where loads complete synchronously
+        // even though under any executor running on any thread but the main thread, the load would
+        // have completed asynchronously.
+        if (status != Status.RUNNING) {
+            loadStatus = null;
+        }
+        if (IS_VERBOSE_LOGGABLE) {
+            logV("finished onSizeReady in " + LogTime.getElapsedMillis(startTime));
+        }
+    }
+
+    private static int maybeApplySizeMultiplier(int size, float sizeMultiplier) {
+        return size == Target.SIZE_ORIGINAL ? size : Math.round(sizeMultiplier * size);
+    }
+
+    private boolean canSetResource() {
+        return requestCoordinator == null || requestCoordinator.canSetImage(this);
+    }
+
+    private boolean canNotifyCleared() {
+        return requestCoordinator == null || requestCoordinator.canNotifyCleared(this);
+    }
+
+    private boolean canNotifyStatusChanged() {
+        return requestCoordinator == null || requestCoordinator.canNotifyStatusChanged(this);
+    }
+
+    private boolean isFirstReadyResource() {
+        return requestCoordinator == null || !requestCoordinator.isAnyResourceSet();
+    }
+
+    private void notifyLoadSuccess() {
+        if (requestCoordinator != null) {
+            requestCoordinator.onRequestSuccess(this);
+        }
+    }
+
+    private void notifyLoadFailed() {
+        if (requestCoordinator != null) {
+            requestCoordinator.onRequestFailed(this);
+        }
+    }
+
     /**
-     * Cleared by the user with a placeholder set, may be restarted.
+     * A callback method that should never be invoked directly.
      */
-    CLEARED,
-  }
-
-  @Nullable
-  private final String tag = IS_VERBOSE_LOGGABLE ? String.valueOf(super.hashCode()) : null;
-  private final StateVerifier stateVerifier = StateVerifier.newInstance();
-
-  @Nullable
-  private RequestListener<R> targetListener;
-  private RequestCoordinator requestCoordinator;
-  private Context context;
-  private GlideContext glideContext;
-  @Nullable
-  private Object model;
-  private Class<R> transcodeClass;
-  private BaseRequestOptions<?> requestOptions;
-  private int overrideWidth;
-  private int overrideHeight;
-  private Priority priority;
-  private Target<R> target;
-  @Nullable private List<RequestListener<R>> requestListeners;
-  private Engine engine;
-  private TransitionFactory<? super R> animationFactory;
-  private Resource<R> resource;
-  private Engine.LoadStatus loadStatus;
-  private long startTime;
-  private Status status;
-  private Drawable errorDrawable;
-  private Drawable placeholderDrawable;
-  private Drawable fallbackDrawable;
-  private int width;
-  private int height;
-
-  public static <R> SingleRequest<R> obtain(
-      Context context,
-      GlideContext glideContext,
-      Object model,
-      Class<R> transcodeClass,
-      BaseRequestOptions<?> requestOptions,
-      int overrideWidth,
-      int overrideHeight,
-      Priority priority,
-      Target<R> target,
-      RequestListener<R> targetListener,
-      @Nullable List<RequestListener<R>> requestListeners,
-      RequestCoordinator requestCoordinator,
-      Engine engine,
-      TransitionFactory<? super R> animationFactory) {
-    @SuppressWarnings("unchecked") SingleRequest<R> request =
-        (SingleRequest<R>) POOL.acquire();
-    if (request == null) {
-      request = new SingleRequest<>();
-    }
-    request.init(
-        context,
-        glideContext,
-        model,
-        transcodeClass,
-        requestOptions,
-        overrideWidth,
-        overrideHeight,
-        priority,
-        target,
-        targetListener,
-        requestListeners,
-        requestCoordinator,
-        engine,
-        animationFactory);
-    return request;
-  }
-
-  @SuppressWarnings("WeakerAccess")
-  @Synthetic
-  SingleRequest() {
-    // just create, instances are reused with recycle/init
-  }
-
-  private void init(
-      Context context,
-      GlideContext glideContext,
-      Object model,
-      Class<R> transcodeClass,
-      BaseRequestOptions<?> requestOptions,
-      int overrideWidth,
-      int overrideHeight,
-      Priority priority,
-      Target<R> target,
-      RequestListener<R> targetListener,
-      @Nullable List<RequestListener<R>> requestListeners,
-      RequestCoordinator requestCoordinator,
-      Engine engine,
-      TransitionFactory<? super R> animationFactory) {
-    this.context = context;
-    this.glideContext = glideContext;
-    this.model = model;
-    this.transcodeClass = transcodeClass;
-    this.requestOptions = requestOptions;
-    this.overrideWidth = overrideWidth;
-    this.overrideHeight = overrideHeight;
-    this.priority = priority;
-    this.target = target;
-    this.targetListener = targetListener;
-    this.requestListeners = requestListeners;
-    this.requestCoordinator = requestCoordinator;
-    this.engine = engine;
-    this.animationFactory = animationFactory;
-    status = Status.PENDING;
-  }
-
-  @NonNull
-  @Override
-  public StateVerifier getVerifier() {
-    return stateVerifier;
-  }
-
-  @Override
-  public void recycle() {
-    assertNotCallingCallbacks();
-    context = null;
-    glideContext = null;
-    model = null;
-    transcodeClass = null;
-    requestOptions = null;
-    overrideWidth = -1;
-    overrideHeight = -1;
-    target = null;
-    requestListeners = null;
-    targetListener = null;
-    requestCoordinator = null;
-    animationFactory = null;
-    loadStatus = null;
-    errorDrawable = null;
-    placeholderDrawable = null;
-    fallbackDrawable = null;
-    width = -1;
-    height = -1;
-    POOL.release(this);
-  }
-
-  @Override
-  public void begin() {
-    assertNotCallingCallbacks();
-    stateVerifier.throwIfRecycled();
-    startTime = LogTime.getLogTime();
-    if (model == null) {
-      if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
-        width = overrideWidth;
-        height = overrideHeight;
-      }
-      // Only log at more verbose log levels if the user has set a fallback drawable, because
-      // fallback Drawables indicate the user expects null models occasionally.
-      int logLevel = getFallbackDrawable() == null ? Log.WARN : Log.DEBUG;
-      onLoadFailed(new GlideException("Received null model"), logLevel);
-      return;
-    }
-
-    if (status == Status.RUNNING) {
-      throw new IllegalArgumentException("Cannot restart a running request");
-    }
-
-    // If we're restarted after we're complete (usually via something like a notifyDataSetChanged
-    // that starts an identical request into the same Target or View), we can simply use the
-    // resource and size we retrieved the last time around and skip obtaining a new size, starting a
-    // new load etc. This does mean that users who want to restart a load because they expect that
-    // the view size has changed will need to explicitly clear the View or Target before starting
-    // the new load.
-    if (status == Status.COMPLETE) {
-      onResourceReady(resource, DataSource.MEMORY_CACHE);
-      return;
-    }
-
-    // Restarts for requests that are neither complete nor running can be treated as new requests
-    // and can run again from the beginning.
-
-    status = Status.WAITING_FOR_SIZE;
-    if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
-      onSizeReady(overrideWidth, overrideHeight);
-    } else {
-      target.getSize(this);
-    }
-
-    if ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)
-        && canNotifyStatusChanged()) {
-      target.onLoadStarted(getPlaceholderDrawable());
-    }
-    if (IS_VERBOSE_LOGGABLE) {
-      logV("finished run method in " + LogTime.getElapsedMillis(startTime));
-    }
-  }
-
-  /**
-   * Cancels the current load but does not release any resources held by the request and continues
-   * to display the loaded resource if the load completed before the call to cancel.
-   *
-   * <p> Cancelled requests can be restarted with a subsequent call to {@link #begin()}. </p>
-   *
-   * @see #clear()
-   */
-  private void cancel() {
-    assertNotCallingCallbacks();
-    stateVerifier.throwIfRecycled();
-    target.removeCallback(this);
-    if (loadStatus != null) {
-      loadStatus.cancel();
-      loadStatus = null;
-    }
-  }
-
-  // Avoids difficult to understand errors like #2413.
-  private void assertNotCallingCallbacks() {
-    if (isCallingCallbacks) {
-      throw new IllegalStateException("You can't start or clear loads in RequestListener or"
-          + " Target callbacks. If you're trying to start a fallback request when a load fails, use"
-          + " RequestBuilder#error(RequestBuilder). Otherwise consider posting your into() or"
-          + " clear() calls to the main thread using a Handler instead.");
-    }
-  }
-
-  /**
-   * Cancels the current load if it is in progress, clears any resources held onto by the request
-   * and replaces the loaded resource if the load completed with the placeholder.
-   *
-   * <p> Cleared requests can be restarted with a subsequent call to {@link #begin()} </p>
-   *
-   * @see #cancel()
-   */
-  @Override
-  public void clear() {
-    Util.assertMainThread();
-    assertNotCallingCallbacks();
-    stateVerifier.throwIfRecycled();
-    if (status == Status.CLEARED) {
-      return;
-    }
-    cancel();
-    // Resource must be released before canNotifyStatusChanged is called.
-    if (resource != null) {
-      releaseResource(resource);
-    }
-    if (canNotifyCleared()) {
-      target.onLoadCleared(getPlaceholderDrawable());
-    }
-
-    status = Status.CLEARED;
-  }
-
-  private void releaseResource(Resource<?> resource) {
-    engine.release(resource);
-    this.resource = null;
-  }
-
-  @Override
-  public boolean isRunning() {
-    return status == Status.RUNNING || status == Status.WAITING_FOR_SIZE;
-  }
-
-  @Override
-  public boolean isComplete() {
-    return status == Status.COMPLETE;
-  }
-
-  @Override
-  public boolean isResourceSet() {
-    return isComplete();
-  }
-
-  @Override
-  public boolean isCleared() {
-    return status == Status.CLEARED;
-  }
-
-  @Override
-  public boolean isFailed() {
-    return status == Status.FAILED;
-  }
-
-  private Drawable getErrorDrawable() {
-    if (errorDrawable == null) {
-      errorDrawable = requestOptions.getErrorPlaceholder();
-      if (errorDrawable == null && requestOptions.getErrorId() > 0) {
-        errorDrawable = loadDrawable(requestOptions.getErrorId());
-      }
-    }
-    return errorDrawable;
-  }
-
-  private Drawable getPlaceholderDrawable() {
-     if (placeholderDrawable == null) {
-      placeholderDrawable = requestOptions.getPlaceholderDrawable();
-      if (placeholderDrawable == null && requestOptions.getPlaceholderId() > 0) {
-        placeholderDrawable = loadDrawable(requestOptions.getPlaceholderId());
-      }
-    }
-    return placeholderDrawable;
-  }
-
-  private Drawable getFallbackDrawable() {
-    if (fallbackDrawable == null) {
-      fallbackDrawable = requestOptions.getFallbackDrawable();
-      if (fallbackDrawable == null && requestOptions.getFallbackId() > 0) {
-        fallbackDrawable = loadDrawable(requestOptions.getFallbackId());
-      }
-    }
-    return fallbackDrawable;
-  }
-
-  private Drawable loadDrawable(@DrawableRes int resourceId) {
-    Theme theme = requestOptions.getTheme() != null
-        ? requestOptions.getTheme() : context.getTheme();
-    return DrawableDecoderCompat.getDrawable(glideContext, resourceId, theme);
-  }
-
-  private void setErrorPlaceholder() {
-    if (!canNotifyStatusChanged()) {
-      return;
-    }
-
-    Drawable error = null;
-    if (model == null) {
-      error = getFallbackDrawable();
-    }
-    // Either the model isn't null, or there was no fallback drawable set.
-    if (error == null) {
-      error = getErrorDrawable();
-    }
-    // The model isn't null, no fallback drawable was set or no error drawable was set.
-    if (error == null) {
-      error = getPlaceholderDrawable();
-    }
-    target.onLoadFailed(error);
-  }
-
-  /**
-   * A callback method that should never be invoked directly.
-   */
-  @Override
-  public void onSizeReady(int width, int height) {
-    stateVerifier.throwIfRecycled();
-    if (IS_VERBOSE_LOGGABLE) {
-      logV("Got onSizeReady in " + LogTime.getElapsedMillis(startTime));
-    }
-    if (status != Status.WAITING_FOR_SIZE) {
-      return;
-    }
-    status = Status.RUNNING;
-
-    float sizeMultiplier = requestOptions.getSizeMultiplier();
-    this.width = maybeApplySizeMultiplier(width, sizeMultiplier);
-    this.height = maybeApplySizeMultiplier(height, sizeMultiplier);
-
-    if (IS_VERBOSE_LOGGABLE) {
-      logV("finished setup for calling load in " + LogTime.getElapsedMillis(startTime));
-    }
-    loadStatus = engine.load(
-        glideContext,
-        model,
-        requestOptions.getSignature(),
-        this.width,
-        this.height,
-        requestOptions.getResourceClass(),
-        transcodeClass,
-        priority,
-        requestOptions.getDiskCacheStrategy(),
-        requestOptions.getTransformations(),
-        requestOptions.isTransformationRequired(),
-        requestOptions.isScaleOnlyOrNoTransform(),
-        requestOptions.getOptions(),
-        requestOptions.isMemoryCacheable(),
-        requestOptions.getUseUnlimitedSourceGeneratorsPool(),
-        requestOptions.getUseAnimationPool(),
-        requestOptions.getOnlyRetrieveFromCache(),
-        this);
-
-    // This is a hack that's only useful for testing right now where loads complete synchronously
-    // even though under any executor running on any thread but the main thread, the load would
-    // have completed asynchronously.
-    if (status != Status.RUNNING) {
-      loadStatus = null;
-    }
-    if (IS_VERBOSE_LOGGABLE) {
-      logV("finished onSizeReady in " + LogTime.getElapsedMillis(startTime));
-    }
-  }
-
-  private static int maybeApplySizeMultiplier(int size, float sizeMultiplier) {
-    return size == Target.SIZE_ORIGINAL ? size : Math.round(sizeMultiplier * size);
-  }
-
-  private boolean canSetResource() {
-    return requestCoordinator == null || requestCoordinator.canSetImage(this);
-  }
-
-  private boolean canNotifyCleared() {
-    return requestCoordinator == null || requestCoordinator.canNotifyCleared(this);
-  }
-
-  private boolean canNotifyStatusChanged() {
-    return requestCoordinator == null || requestCoordinator.canNotifyStatusChanged(this);
-  }
-
-  private boolean isFirstReadyResource() {
-    return requestCoordinator == null || !requestCoordinator.isAnyResourceSet();
-  }
-
-  private void notifyLoadSuccess() {
-    if (requestCoordinator != null) {
-      requestCoordinator.onRequestSuccess(this);
-    }
-  }
-
-  private void notifyLoadFailed() {
-    if (requestCoordinator != null) {
-      requestCoordinator.onRequestFailed(this);
-    }
-  }
-
-  /**
-   * A callback method that should never be invoked directly.
-   */
-  @SuppressWarnings("unchecked")
-  @Override
-  public void onResourceReady(Resource<?> resource, DataSource dataSource) {
-    stateVerifier.throwIfRecycled();
-    loadStatus = null;
-    if (resource == null) {
-      GlideException exception = new GlideException("Expected to receive a Resource<R> with an "
-          + "object of " + transcodeClass + " inside, but instead got null.");
-      onLoadFailed(exception);
-      return;
-    }
-
-    Object received = resource.get();
-    if (received == null || !transcodeClass.isAssignableFrom(received.getClass())) {
-      releaseResource(resource);
-      GlideException exception = new GlideException("Expected to receive an object of "
-          + transcodeClass + " but instead" + " got "
-          + (received != null ? received.getClass() : "") + "{" + received + "} inside" + " "
-          + "Resource{" + resource + "}."
-          + (received != null ? "" : " " + "To indicate failure return a null Resource "
-          + "object, rather than a Resource object containing null data."));
-      onLoadFailed(exception);
-      return;
-    }
-
-    if (!canSetResource()) {
-      releaseResource(resource);
-      // We can't put the status to complete before asking canSetResource().
-      status = Status.COMPLETE;
-      return;
-    }
-
-    onResourceReady((Resource<R>) resource, (R) received, dataSource);
-  }
-
-  /**
-   * Internal {@link #onResourceReady(Resource, DataSource)} where arguments are known to be safe.
-   *
-   * @param resource original {@link Resource}, never <code>null</code>
-   * @param result   object returned by {@link Resource#get()}, checked for type and never
-   *                 <code>null</code>
-   */
-  private void onResourceReady(Resource<R> resource, R result, DataSource dataSource) {
-    // We must call isFirstReadyResource before setting status.
-    boolean isFirstResource = isFirstReadyResource();
-    status = Status.COMPLETE;
-    this.resource = resource;
-
-    if (glideContext.getLogLevel() <= Log.DEBUG) {
-      Log.d(GLIDE_TAG, "Finished loading " + result.getClass().getSimpleName() + " from "
-          + dataSource + " for " + model + " with size [" + width + "x" + height + "] in "
-          + LogTime.getElapsedMillis(startTime) + " ms");
-    }
-
-    isCallingCallbacks = true;
-    try {
-      boolean anyListenerHandledUpdatingTarget = false;
-      if (requestListeners != null) {
-        for (RequestListener<R> listener : requestListeners) {
-          anyListenerHandledUpdatingTarget |=
-              listener.onResourceReady(result, model, target, dataSource, isFirstResource);
-        }
-      }
-      anyListenerHandledUpdatingTarget |=
-          targetListener != null
-              && targetListener.onResourceReady(result, model, target, dataSource, isFirstResource);
-
-      if (!anyListenerHandledUpdatingTarget) {
-        Transition<? super R> animation =
-            animationFactory.build(dataSource, isFirstResource);
-        target.onResourceReady(result, animation);
-      }
-    } finally {
-      isCallingCallbacks = false;
-    }
-
-    notifyLoadSuccess();
-  }
-
-  /**
-   * A callback method that should never be invoked directly.
-   */
-  @Override
-  public void onLoadFailed(GlideException e) {
-    onLoadFailed(e, Log.WARN);
-  }
-
-  private void onLoadFailed(GlideException e, int maxLogLevel) {
-    stateVerifier.throwIfRecycled();
-    int logLevel = glideContext.getLogLevel();
-    if (logLevel <= maxLogLevel) {
-      Log.w(GLIDE_TAG, "Load failed for " + model + " with size [" + width + "x" + height + "]", e);
-      if (logLevel <= Log.INFO) {
-        e.logRootCauses(GLIDE_TAG);
-      }
-    }
-
-    loadStatus = null;
-    status = Status.FAILED;
-
-    isCallingCallbacks = true;
-    try {
-      //TODO: what if this is a thumbnail request?
-      boolean anyListenerHandledUpdatingTarget = false;
-      if (requestListeners != null) {
-        for (RequestListener<R> listener : requestListeners) {
-          anyListenerHandledUpdatingTarget |=
-              listener.onLoadFailed(e, model, target, isFirstReadyResource());
-        }
-      }
-      anyListenerHandledUpdatingTarget |=
-          targetListener != null
-              && targetListener.onLoadFailed(e, model, target, isFirstReadyResource());
-
-      if (!anyListenerHandledUpdatingTarget) {
-        setErrorPlaceholder();
-      }
-    } finally {
-      isCallingCallbacks = false;
-    }
-
-    notifyLoadFailed();
-  }
-
-  @Override
-  public boolean isEquivalentTo(Request o) {
-    if (o instanceof SingleRequest) {
-      SingleRequest<?> that = (SingleRequest<?>) o;
-      return overrideWidth == that.overrideWidth
-          && overrideHeight == that.overrideHeight
-          && Util.bothModelsNullEquivalentOrEquals(model, that.model)
-          && transcodeClass.equals(that.transcodeClass)
-          && requestOptions.equals(that.requestOptions)
-          && priority == that.priority
-          // We do not want to require that RequestListeners implement equals/hashcode, so we don't
-          // compare them using equals(). We can however, at least assert that the same amount of
-          // request listeners are present in both requests
-          && listenerCountEquals(this, that);
-    }
-    return false;
-  }
-
-  private static boolean listenerCountEquals(SingleRequest<?> first, SingleRequest<?> second) {
-    int firstListenerCount = first.requestListeners == null ? 0 : first.requestListeners.size();
-    int secondListenerCount = second.requestListeners == null ? 0 : second.requestListeners.size();
-    return firstListenerCount == secondListenerCount;
-  }
-
-  private void logV(String message) {
-    Log.v(TAG, message + " this: " + tag);
-  }
+    @SuppressWarnings("unchecked")
+    @Override
+    public void onResourceReady(Resource<?> resource, DataSource dataSource) {
+        stateVerifier.throwIfRecycled();
+        loadStatus = null;
+        if (resource == null) {
+            GlideException exception = new GlideException("Expected to receive a Resource<R> with an "
+                    + "object of " + transcodeClass + " inside, but instead got null.");
+            onLoadFailed(exception);
+            return;
+        }
+
+        Object received = resource.get();
+        if (received == null || !transcodeClass.isAssignableFrom(received.getClass())) {
+            releaseResource(resource);
+            GlideException exception = new GlideException("Expected to receive an object of "
+                    + transcodeClass + " but instead" + " got "
+                    + (received != null ? received.getClass() : "") + "{" + received + "} inside" + " "
+                    + "Resource{" + resource + "}."
+                    + (received != null ? "" : " " + "To indicate failure return a null Resource "
+                    + "object, rather than a Resource object containing null data."));
+            onLoadFailed(exception);
+            return;
+        }
+
+        if (!canSetResource()) {
+            releaseResource(resource);
+            // We can't put the status to complete before asking canSetResource().
+            status = Status.COMPLETE;
+            return;
+        }
+
+        onResourceReady((Resource<R>) resource, (R) received, dataSource);
+    }
+
+    /**
+     * Internal {@link #onResourceReady(Resource, DataSource)} where arguments are known to be safe.
+     *
+     * @param resource original {@link Resource}, never <code>null</code>
+     * @param result   object returned by {@link Resource#get()}, checked for type and never
+     *                 <code>null</code>
+     */
+    private void onResourceReady(Resource<R> resource, R result, DataSource dataSource) {
+        // We must call isFirstReadyResource before setting status.
+        boolean isFirstResource = isFirstReadyResource();
+        status = Status.COMPLETE;
+        this.resource = resource;
+
+        if (glideContext.getLogLevel() <= Log.DEBUG) {
+            Log.d(GLIDE_TAG, "Finished loading " + result.getClass().getSimpleName() + " from "
+                    + dataSource + " for " + model + " with size [" + width + "x" + height + "] in "
+                    + LogTime.getElapsedMillis(startTime) + " ms");
+        }
+
+        isCallingCallbacks = true;
+        try {
+            boolean anyListenerHandledUpdatingTarget = false;
+            if (requestListeners != null) {
+                for (RequestListener<R> listener : requestListeners) {
+                    anyListenerHandledUpdatingTarget |=
+                            listener.onResourceReady(result, model, target, dataSource, isFirstResource);
+                }
+            }
+            anyListenerHandledUpdatingTarget |=
+                    targetListener != null
+                            && targetListener.onResourceReady(result, model, target, dataSource, isFirstResource);
+
+            if (!anyListenerHandledUpdatingTarget) {
+                Transition<? super R> animation =
+                        animationFactory.build(dataSource, isFirstResource);
+                target.onResourceReady(result, animation);
+            }
+        } finally {
+            isCallingCallbacks = false;
+        }
+
+        notifyLoadSuccess();
+    }
+
+    /**
+     * A callback method that should never be invoked directly.
+     */
+    @Override
+    public void onLoadFailed(GlideException e) {
+        onLoadFailed(e, Log.WARN);
+    }
+
+    private void onLoadFailed(GlideException e, int maxLogLevel) {
+        stateVerifier.throwIfRecycled();
+        int logLevel = glideContext.getLogLevel();
+        if (logLevel <= maxLogLevel) {
+            Log.w(GLIDE_TAG, "Load failed for " + model + " with size [" + width + "x" + height + "]", e);
+            if (logLevel <= Log.INFO) {
+                e.logRootCauses(GLIDE_TAG);
+            }
+        }
+
+        loadStatus = null;
+        status = Status.FAILED;
+
+        isCallingCallbacks = true;
+        try {
+            //TODO: what if this is a thumbnail request?
+            boolean anyListenerHandledUpdatingTarget = false;
+            if (requestListeners != null) {
+                for (RequestListener<R> listener : requestListeners) {
+                    anyListenerHandledUpdatingTarget |=
+                            listener.onLoadFailed(e, model, target, isFirstReadyResource());
+                }
+            }
+            anyListenerHandledUpdatingTarget |=
+                    targetListener != null
+                            && targetListener.onLoadFailed(e, model, target, isFirstReadyResource());
+
+            if (!anyListenerHandledUpdatingTarget) {
+                setErrorPlaceholder();
+            }
+        } finally {
+            isCallingCallbacks = false;
+        }
+
+        notifyLoadFailed();
+    }
+
+    @Override
+    public boolean isEquivalentTo(Request o) {
+        if (o instanceof SingleRequest) {
+            SingleRequest<?> that = (SingleRequest<?>) o;
+            return overrideWidth == that.overrideWidth
+                    && overrideHeight == that.overrideHeight
+                    && Util.bothModelsNullEquivalentOrEquals(model, that.model)
+                    && transcodeClass.equals(that.transcodeClass)
+                    && requestOptions.equals(that.requestOptions)
+                    && priority == that.priority
+                    // We do not want to require that RequestListeners implement equals/hashcode, so we don't
+                    // compare them using equals(). We can however, at least assert that the same amount of
+                    // request listeners are present in both requests
+                    && listenerCountEquals(this, that);
+        }
+        return false;
+    }
+
+    private static boolean listenerCountEquals(SingleRequest<?> first, SingleRequest<?> second) {
+        int firstListenerCount = first.requestListeners == null ? 0 : first.requestListeners.size();
+        int secondListenerCount = second.requestListeners == null ? 0 : second.requestListeners.size();
+        return firstListenerCount == secondListenerCount;
+    }
+
+    private void logV(String message) {
+        Log.v(TAG, message + " this: " + tag);
+    }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java
index 6f270b9a6..fb004d8eb 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java
@@ -53,6 +53,7 @@ public Drawable getCurrentDrawable() {
    */
   @Override
   public void setDrawable(Drawable drawable) {
+    // 调用setImageDrawable设置占位图
     view.setImageDrawable(drawable);
   }
 
@@ -66,6 +67,7 @@ public void setDrawable(Drawable drawable) {
   public void onLoadStarted(@Nullable Drawable placeholder) {
     super.onLoadStarted(placeholder);
     setResourceInternal(null);
+    // 设置 占位图
     setDrawable(placeholder);
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java
index 2e91ac594..98e19162d 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java
@@ -10,17 +10,17 @@
  * {@link com.bumptech.glide.request.target.Target} for a given {@link android.view.View} subclass.
  */
 public class ImageViewTargetFactory {
-  @NonNull
-  @SuppressWarnings("unchecked")
-  public <Z> ViewTarget<ImageView, Z> buildTarget(@NonNull ImageView view,
-      @NonNull Class<Z> clazz) {
-    if (Bitmap.class.equals(clazz)) {
-      return (ViewTarget<ImageView, Z>) new BitmapImageViewTarget(view);
-    } else if (Drawable.class.isAssignableFrom(clazz)) {
-      return (ViewTarget<ImageView, Z>) new DrawableImageViewTarget(view);
-    } else {
-      throw new IllegalArgumentException(
-          "Unhandled class: " + clazz + ", try .as*(Class).transcode(ResourceTranscoder)");
+    @NonNull
+    @SuppressWarnings("unchecked")
+    public <Z> ViewTarget<ImageView, Z> buildTarget(@NonNull ImageView view,
+                                                    @NonNull Class<Z> clazz) {
+        if (Bitmap.class.equals(clazz)) {
+            return (ViewTarget<ImageView, Z>) new BitmapImageViewTarget(view);
+        } else if (Drawable.class.isAssignableFrom(clazz)) {
+            return (ViewTarget<ImageView, Z>) new DrawableImageViewTarget(view);
+        } else {
+            throw new IllegalArgumentException(
+                    "Unhandled class: " + clazz + ", try .as*(Class).transcode(ResourceTranscoder)");
+        }
     }
-  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
index 9bc6d8b2e..72a2ad5ca 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
@@ -398,6 +398,7 @@ void getSize(@NonNull SizeReadyCallback cb) {
       if (layoutListener == null) {
         ViewTreeObserver observer = view.getViewTreeObserver();
         layoutListener = new SizeDeterminerLayoutListener(this);
+
         observer.addOnPreDrawListener(layoutListener);
       }
     }
