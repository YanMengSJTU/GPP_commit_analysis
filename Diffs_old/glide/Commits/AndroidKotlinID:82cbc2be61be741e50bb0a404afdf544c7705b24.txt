diff --git a/README.md b/README.md
index 9905895d8..6e9981912 100644
--- a/README.md
+++ b/README.md
@@ -24,12 +24,12 @@ Or use Gradle:
 
 ```gradle
 repositories {
-  mavenCentral() // jcenter() works as well because it pulls from Maven Central
+  mavenCentral()
+  maven { url 'https://maven.google.com' }
 }
 
 dependencies {
   compile 'com.github.bumptech.glide:glide:4.1.1'
-  compile 'com.android.support:support-v4:25.3.1'
   annotationProcessor 'com.github.bumptech.glide:compiler:4.1.1'
 }
 ```
diff --git a/library/src/main/java/com/bumptech/glide/Registry.java b/library/src/main/java/com/bumptech/glide/Registry.java
index 91e4c5734..f5b7c0239 100644
--- a/library/src/main/java/com/bumptech/glide/Registry.java
+++ b/library/src/main/java/com/bumptech/glide/Registry.java
@@ -23,6 +23,7 @@
 import com.bumptech.glide.provider.ResourceDecoderRegistry;
 import com.bumptech.glide.provider.ResourceEncoderRegistry;
 import com.bumptech.glide.util.pool.FactoryPools;
+
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -65,11 +66,49 @@ public Registry() {
    * {@link java.io.FileInputStream} and any other subclass.
    *
    * <p>If multiple {@link Encoder}s are registered for the same type or super type, the
-   * {@link Encoder} that is registered first will be used. As a result, it's not currently possible
-   * to replace Glide's default {@link Encoder}s.
+   * {@link Encoder} that is registered first will be used.
+   *
+   * @deprecated Use the equivalent {@link #append(Class, Class, ModelLoaderFactory)} method
+   * instead.
    */
+  @Deprecated
   public <Data> Registry register(Class<Data> dataClass, Encoder<Data> encoder) {
-    encoderRegistry.add(dataClass, encoder);
+    return append(dataClass, encoder);
+  }
+
+  /**
+   * Appends the given {@link Encoder} onto the list of available {@link Encoder}s so that it is
+   * attempted after all earlier and default {@link Encoder}s for the given data class.
+   *
+   * <p>The {@link Encoder} will be used both for the exact data class and any subtypes. For
+   * example, registering an {@link Encoder} for {@link java.io.InputStream} will result in the
+   * {@link Encoder} being used for
+   * {@link android.content.res.AssetFileDescriptor.AutoCloseInputStream},
+   * {@link java.io.FileInputStream} and any other subclass.
+   *
+   * <p>If multiple {@link Encoder}s are registered for the same type or super type, the
+   * {@link Encoder} that is registered first will be used.
+   *
+   * @see #prepend(Class, Encoder)
+   */
+  public <Data> Registry append(Class<Data> dataClass, Encoder<Data> encoder) {
+    encoderRegistry.append(dataClass, encoder);
+    return this;
+  }
+
+  /**
+   * Prepends the given {@link Encoder} into the list of available {@link Encoder}s
+   * so that it is attempted before all later and default {@link Encoder}s for the given
+   * data class.
+   *
+   * <p>This method allows you to replace the default {@link Encoder} because it ensures
+   * the registered {@link Encoder} will run first. If multiple {@link Encoder}s are registered for
+   * the same type or super type, the {@link Encoder} that is registered first will be used.
+   *
+   * @see #append(Class, Encoder)
+   */
+  public <Data> Registry prepend(Class<Data> dataClass, Encoder<Data> encoder) {
+    encoderRegistry.prepend(dataClass, encoder);
     return this;
   }
 
@@ -128,9 +167,9 @@ public Registry() {
   }
 
   /**
-   * Registers the given {@link ResourceEncoder} for the given resource class
-   * ({@link android.graphics.Bitmap}, {@link com.bumptech.glide.load.resource.gif.GifDrawable}
-   * etc).
+   * Appends the given {@link ResourceEncoder} into the list of available {@link ResourceEncoder}s
+   * so that it is attempted after all earlier and default {@link ResourceEncoder}s for the given
+   * data type.
    *
    * <p>The {@link ResourceEncoder} will be used both for the exact resource class and any subtypes.
    * For example, registering an {@link ResourceEncoder} for
@@ -139,12 +178,53 @@ public Registry() {
    * {@link com.bumptech.glide.load.resource.gif.GifDrawable} and any other subclass.
    *
    * <p>If multiple {@link ResourceEncoder}s are registered for the same type or super type, the
-   * {@link ResourceEncoder} that is registered first will be used. As a result, it's not currently
-   * possible to replace Glide's default {@link ResourceEncoder}s.
+   * {@link ResourceEncoder} that is registered first will be used.
+   *
+   * @deprecated Use the equivalent {@link #append(Class, ResourceEncoder)} method instead.
+   */
+  @Deprecated
+  public <TResource> Registry register(
+      Class<TResource> resourceClass, ResourceEncoder<TResource> encoder) {
+    return append(resourceClass, encoder);
+  }
+
+  /**
+   * Appends the given {@link ResourceEncoder} into the list of available {@link ResourceEncoder}s
+   * so that it is attempted after all earlier and default {@link ResourceEncoder}s for the given
+   * data type.
+   *
+   * <p>The {@link ResourceEncoder} will be used both for the exact resource class and any subtypes.
+   * For example, registering an {@link ResourceEncoder} for
+   * {@link android.graphics.drawable.Drawable} (not recommended) will result in the
+   * {@link ResourceEncoder} being used for {@link android.graphics.drawable.BitmapDrawable} and
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} and any other subclass.
+   *
+   * <p>If multiple {@link ResourceEncoder}s are registered for the same type or super type, the
+   * {@link ResourceEncoder} that is registered first will be used.
+   *
+   * @see #prepend(Class, ResourceEncoder)
+   */
+  public <TResource> Registry append(
+      Class<TResource> resourceClass, ResourceEncoder<TResource> encoder) {
+    resourceEncoderRegistry.append(resourceClass, encoder);
+    return this;
+  }
+
+  /**
+   * Prepends the given {@link ResourceEncoder} into the list of available {@link ResourceEncoder}s
+   * so that it is attempted before all later and default {@link ResourceEncoder}s for the given
+   * data type.
+   *
+   * <p>This method allows you to replace the default {@link ResourceEncoder} because it ensures
+   * the registered {@link ResourceEncoder} will run first. If multiple {@link ResourceEncoder}s are
+   * registered for the same type or super type, the {@link ResourceEncoder} that is registered
+   * first will be used.
+   *
+   * @see #append(Class, ResourceEncoder)
    */
-  public <TResource> Registry register(Class<TResource> resourceClass,
-      ResourceEncoder<TResource> encoder) {
-    resourceEncoderRegistry.add(resourceClass, encoder);
+  public <TResource> Registry prepend(
+      Class<TResource> resourceClass, ResourceEncoder<TResource> encoder) {
+    resourceEncoderRegistry.prepend(resourceClass, encoder);
     return this;
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
index 91a464a37..6989129cc 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
@@ -100,6 +100,8 @@ private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,
 
     // Connect explicitly to avoid errors in decoders if connection fails.
     urlConnection.connect();
+    // Set the stream so that it's closed in cleanup to avoid resource leaks. See #2352.
+    stream = urlConnection.getInputStream();
     if (isCancelled) {
       return null;
     }
@@ -112,6 +114,9 @@ private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,
         throw new HttpException("Received empty or null redirect url");
       }
       URL redirectUrl = new URL(url, redirectUrlString);
+      // Closing the stream specifically is required to avoid leaking ResponseBodys in addition
+      // to disconnecting the url connection below. See #2352.
+      cleanup();
       return loadDataWithRedirects(redirectUrl, redirects + 1, url, headers);
     } else if (statusCode == -1) {
       throw new HttpException(statusCode);
@@ -146,6 +151,7 @@ public void cleanup() {
     if (urlConnection != null) {
       urlConnection.disconnect();
     }
+    urlConnection = null;
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java
index 13318a8fc..d11f0f02a 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.load.engine.cache;
 
-import com.bumptech.glide.load.Key;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayDeque;
@@ -19,16 +18,16 @@
  *  0, the lock can safely be removed from the map. </p>
  */
 final class DiskCacheWriteLocker {
-  private final Map<Key, WriteLock> locks = new HashMap<>();
+  private final Map<String, WriteLock> locks = new HashMap<>();
   private final WriteLockPool writeLockPool = new WriteLockPool();
 
-  void acquire(Key key) {
+  void acquire(String safeKey) {
     WriteLock writeLock;
     synchronized (this) {
-      writeLock = locks.get(key);
+      writeLock = locks.get(safeKey);
       if (writeLock == null) {
         writeLock = writeLockPool.obtain();
-        locks.put(key, writeLock);
+        locks.put(safeKey, writeLock);
       }
       writeLock.interestedThreads++;
     }
@@ -36,24 +35,24 @@ void acquire(Key key) {
     writeLock.lock.lock();
   }
 
-  void release(Key key) {
+  void release(String safeKey) {
     WriteLock writeLock;
     synchronized (this) {
-      writeLock = Preconditions.checkNotNull(locks.get(key));
+      writeLock = Preconditions.checkNotNull(locks.get(safeKey));
       if (writeLock.interestedThreads < 1) {
         throw new IllegalStateException("Cannot release a lock that is not held"
-            + ", key: " + key
+            + ", safeKey: " + safeKey
             + ", interestedThreads: " + writeLock.interestedThreads);
       }
 
       writeLock.interestedThreads--;
       if (writeLock.interestedThreads == 0) {
-        WriteLock removed = locks.remove(key);
+        WriteLock removed = locks.remove(safeKey);
         if (!removed.equals(writeLock)) {
           throw new IllegalStateException("Removed the wrong lock"
               + ", expected to remove: " + writeLock
               + ", but actually removed: " + removed
-              + ", key: " + key);
+              + ", safeKey: " + safeKey);
         }
         writeLockPool.offer(removed);
       }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
index c0e6f5269..8cd104d02 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
@@ -88,9 +88,9 @@ public File get(Key key) {
   public void put(Key key, Writer writer) {
     // We want to make sure that puts block so that data is available when put completes. We may
     // actually not write any data if we find that data is written by the time we acquire the lock.
-    writeLocker.acquire(key);
+    String safeKey = safeKeyGenerator.getSafeKey(key);
+    writeLocker.acquire(safeKey);
     try {
-      String safeKey = safeKeyGenerator.getSafeKey(key);
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
         Log.v(TAG, "Put: Obtained: " + safeKey + " for for Key: " + key);
       }
@@ -121,7 +121,7 @@ public void put(Key key, Writer writer) {
         }
       }
     } finally {
-      writeLocker.release(key);
+      writeLocker.release(safeKey);
     }
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java b/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java
index 29bd3af62..1cc3bba81 100644
--- a/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java
@@ -7,7 +7,7 @@
 import java.util.List;
 
 /**
- * Contains an unordered list of {@link Encoder}s capable of encoding arbitrary data types.
+ * Contains an ordered list of {@link Encoder}s capable of encoding arbitrary data types.
  */
 public class EncoderRegistry {
   // TODO: This registry should probably contain a put, rather than a list.
@@ -24,10 +24,14 @@
     return null;
   }
 
-  public synchronized <T> void add(Class<T> dataClass, Encoder<T> encoder) {
+  public synchronized <T> void append(Class<T> dataClass, Encoder<T> encoder) {
     encoders.add(new Entry<>(dataClass, encoder));
   }
 
+  public synchronized <T> void prepend(Class<T> dataClass, Encoder<T> encoder) {
+    encoders.add(0, new Entry<>(dataClass, encoder));
+  }
+
   private static final class Entry<T> {
     private final Class<T> dataClass;
     @Synthetic final Encoder<T> encoder;
diff --git a/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java b/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java
index e096cc759..fa58e81e8 100644
--- a/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java
@@ -1,23 +1,29 @@
 package com.bumptech.glide.provider;
 
 import android.support.annotation.Nullable;
+
 import com.bumptech.glide.load.ResourceEncoder;
 import com.bumptech.glide.util.Synthetic;
+
 import java.util.ArrayList;
 import java.util.List;
 
 /**
- * Contains an unordered list of {@link ResourceEncoder}s capable of encoding arbitrary resource
+ * Contains an ordered list of {@link ResourceEncoder}s capable of encoding arbitrary resource
  * types.
  */
 public class ResourceEncoderRegistry {
   // TODO: this should probably be a put.
   final List<Entry<?>> encoders = new ArrayList<>();
 
-  public synchronized <Z> void add(Class<Z> resourceClass, ResourceEncoder<Z> encoder) {
+  public synchronized <Z> void append(Class<Z> resourceClass, ResourceEncoder<Z> encoder) {
     encoders.add(new Entry<>(resourceClass, encoder));
   }
 
+  public synchronized <Z> void prepend(Class<Z> resourceClass, ResourceEncoder<Z> encoder) {
+    encoders.add(0, new Entry<>(resourceClass, encoder));
+  }
+
   @SuppressWarnings("unchecked")
   @Nullable
   public synchronized <Z> ResourceEncoder<Z> get(Class<Z> resourceClass) {
