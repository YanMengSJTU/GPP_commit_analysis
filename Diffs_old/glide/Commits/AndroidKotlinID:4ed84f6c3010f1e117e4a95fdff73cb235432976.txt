diff --git a/README.md b/README.md
index 88a009c76..889d794b9 100644
--- a/README.md
+++ b/README.md
@@ -200,7 +200,7 @@ This is not an official Google product.
 
 [1]: https://github.com/bumptech/glide/releases
 [2]: https://github.com/bumptech/glide/wiki
-[3]: http://bumptech.github.io/glide/ref/javadocs.html
+[3]: https://bumptech.github.io/glide/ref/javadocs.html
 [4]: https://www.jetbrains.com/idea/download/
 [5]: https://github.com/bumptech/glide/blob/master/CONTRIBUTING.md
 [6]: https://groups.google.com/forum/#!forum/glidelibrary
@@ -217,6 +217,6 @@ This is not an official Google product.
 [17]: https://github.com/bumptech/glide/wiki/Snapshots
 [18]: https://github.com/bumptech/glide/issues?q=is%3Aissue+CircleImageView+OR+CircularImageView+OR+RoundedImageView
 [19]: https://github.com/wasabeef/glide-transformations
-[20]: http://bumptech.github.io/glide/
-[21]: http://bumptech.github.io/glide/doc/generatedapi.html
+[20]: https://bumptech.github.io/glide/
+[21]: https://bumptech.github.io/glide/doc/generatedapi.html
 [22]: https://muyangmin.github.io/glide-docs-cn/
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java
index e13b211d8..069d45bfe 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java
@@ -2,6 +2,7 @@
 
 import static com.bumptech.glide.test.Matchers.anyDrawable;
 import static com.bumptech.glide.test.Matchers.anyTarget;
+import static com.google.common.truth.Truth.assertThat;
 import static org.mockito.AdditionalMatchers.not;
 import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.anyBoolean;
@@ -11,6 +12,8 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
+import android.os.Handler;
+import android.os.Looper;
 import android.support.test.InstrumentationRegistry;
 import android.support.test.runner.AndroidJUnit4;
 import com.bumptech.glide.load.DataSource;
@@ -25,7 +28,11 @@
 import com.bumptech.glide.test.ResourceIds;
 import com.bumptech.glide.test.ResourceIds.raw;
 import com.bumptech.glide.test.TearDownGlide;
+import com.bumptech.glide.test.WaitModelLoader;
+import com.bumptech.glide.test.WaitModelLoader.WaitModel;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 import org.junit.Before;
 import org.junit.Rule;
@@ -91,17 +98,22 @@ public void submit_withRequestClearedFromMemory_doesNotLoadFromMemory() {
     Glide.init(
         context, new GlideBuilder().setMemoryCache(new MemoryCacheAdapter()));
 
-    FutureTarget<Drawable> first =
-        GlideApp.with(context)
-            .load(raw.canonical)
-            .submit();
-    concurrency.get(first);
+    // Allow the request to be run and GCed without being cleared.
+    concurrency.loadOnOtherThread(new Runnable() {
+      @Override
+      public void run() {
+        FutureTarget<Drawable> first =
+            GlideApp.with(context)
+                .load(raw.canonical)
+                .submit();
+        concurrency.get(first);
+      }
+    });
 
-    // Allow first to be GCed and removed from active resources.
-    //noinspection UnusedAssignment
-    first = null;
+    // Wait for the weak reference to be cleared and the request to be removed from active
+    // resources.
     // De-flake by allowing multiple tries
-    for (int j = 0; j < 10; j++) {
+    for (int j = 0; j < 100; j++) {
       Runtime.getRuntime().gc();
       concurrency.pokeMainThread();
       try {
@@ -266,6 +278,63 @@ public void clearDiskCache_doesNotPreventFutureLoads()
             anyBoolean());
   }
 
+  // Tests #2428.
+  @Test
+  public void onlyRetrieveFromCache_withPreviousRequestLoadingFromSource_doesNotBlock() {
+    final WaitModel<Integer> waitModel = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);
+
+    GlideApp.with(context)
+        .load(waitModel)
+        .submit();
+
+    FutureTarget<Drawable> onlyFromCacheFuture = GlideApp.with(context)
+        .load(waitModel)
+        .onlyRetrieveFromCache(true)
+        .submit();
+    try {
+      onlyFromCacheFuture.get(1000, TimeUnit.MILLISECONDS);
+      throw new IllegalStateException();
+    } catch (InterruptedException | TimeoutException e) {
+      throw new RuntimeException(e);
+    } catch (ExecutionException e) {
+      // Expected.
+    }
+    waitModel.countDown();
+  }
+
+  // Tests #2428.
+  @Test
+  public void submit_withRequestLoadingWithOnlyRetrieveFromCache_andNotInCache_doesNotFail() {
+    // Block the main thread so that we know that both requests will be queued but not started at
+    // the same time.
+    final CountDownLatch blockMainThread = new CountDownLatch(1);
+    new Handler(Looper.getMainLooper()).post(new Runnable() {
+      @Override
+      public void run() {
+         try {
+          blockMainThread.await();
+        } catch (InterruptedException e) {
+          throw new RuntimeException(e);
+        }
+      }
+    });
+
+    // Queue the retrieve from cache request first.
+    GlideApp.with(context)
+        .load(ResourceIds.raw.canonical)
+        .onlyRetrieveFromCache(true)
+        .submit();
+
+    // Then queue the normal request.
+    FutureTarget<Drawable> expectedFuture =
+        GlideApp.with(context).load(ResourceIds.raw.canonical).submit();
+
+    // Run the requests.
+    blockMainThread.countDown();
+
+    // Verify that the request that didn't have retrieve from cache succeeds
+    assertThat(concurrency.get(expectedFuture)).isNotNull();
+  }
 
   private void clearMemoryCacheOnMainThread() throws InterruptedException {
     concurrency.runOnMainThread(new Runnable() {
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/Issue2638Test.java b/instrumentation/src/androidTest/java/com/bumptech/glide/Issue2638Test.java
new file mode 100644
index 000000000..2696fc73b
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/Issue2638Test.java
@@ -0,0 +1,80 @@
+package com.bumptech.glide;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.CompressFormat;
+import android.graphics.BitmapFactory;
+import android.graphics.Color;
+import android.graphics.drawable.BitmapDrawable;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import android.widget.AbsListView.LayoutParams;
+import android.widget.ImageView;
+import com.bumptech.glide.test.BitmapSubject;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import com.google.common.io.ByteStreams;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.concurrent.ExecutionException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+public class Issue2638Test {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private Context context;
+
+  @Before
+  public void setUp() {
+    context = InstrumentationRegistry.getTargetContext();
+  }
+
+  @Test
+  public void intoImageView_withDifferentByteArrays_loadsDifferentImages()
+      throws IOException, ExecutionException, InterruptedException {
+    final ImageView imageView = new ImageView(context);
+    imageView.setLayoutParams(new LayoutParams(/*w=*/ 100, /*h=*/ 100));
+
+    final byte[] canonicalBytes = getCanonicalBytes();
+    final byte[] modifiedBytes = getModifiedBytes();
+
+    Glide.with(context)
+        .load(canonicalBytes)
+        .submit()
+        .get();
+
+    concurrency.loadOnMainThread(Glide.with(context).load(canonicalBytes), imageView);
+    Bitmap firstBitmap = ((BitmapDrawable) imageView.getDrawable()).getBitmap();
+
+    concurrency.loadOnMainThread(Glide.with(context).load(modifiedBytes), imageView);
+    Bitmap secondBitmap = ((BitmapDrawable) imageView.getDrawable()).getBitmap();
+
+    BitmapSubject.assertThat(firstBitmap).isNotSameAs(secondBitmap);
+  }
+
+  private byte[] getModifiedBytes() throws IOException {
+    byte[] canonicalBytes = getCanonicalBytes();
+    BitmapFactory.Options options = new BitmapFactory.Options();
+    options.inMutable = true;
+    Bitmap bitmap =
+        BitmapFactory.decodeByteArray(canonicalBytes, 0, canonicalBytes.length, options);
+    bitmap.setPixel(0, 0, Color.TRANSPARENT);
+    ByteArrayOutputStream os = new ByteArrayOutputStream();
+    bitmap.compress(CompressFormat.PNG, /*quality=*/ 100, os);
+    return os.toByteArray();
+  }
+
+  private byte[] getCanonicalBytes() throws IOException {
+    int resourceId = ResourceIds.raw.canonical;
+    Resources resources = context.getResources();
+    InputStream is = resources.openRawResource(resourceId);
+    return ByteStreams.toByteArray(is);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapSubject.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapSubject.java
index e71ee33c4..fede0a765 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapSubject.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapSubject.java
@@ -94,4 +94,10 @@ public void sameAs(Bitmap other) {
       fail("is the same as " + getDisplayString(other));
     }
   }
+
+  public void isNotSameAs(Bitmap other) {
+    if (actual().sameAs(other)) {
+      fail("is not the same as " + getDisplayString(other));
+    }
+  }
 }
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java
index d7de5c40d..a44b59056 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java
@@ -20,6 +20,7 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
 
 /**
@@ -43,6 +44,26 @@
     return future;
   }
 
+  public void loadOnOtherThread(final Runnable runnable) {
+    final AtomicBoolean isDone = new AtomicBoolean();
+    Thread thread = new Thread(new Runnable() {
+      @Override
+      public void run() {
+        runnable.run();
+        isDone.set(true);
+      }
+    });
+    thread.start();
+    try {
+      thread.join(TIMEOUT_MS, /*nanos=*/0);
+    } catch (InterruptedException e) {
+      throw new RuntimeException(e);
+    }
+    if (!isDone.get()) {
+      throw new IllegalStateException("Failed to finish job in available time");
+    }
+  }
+
   public void loadOnMainThread(
       final RequestBuilder<Drawable> builder, ImageView imageView) {
     loadOnMainThread(builder, new DrawableImageViewTarget(imageView));
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
index 9b073f5ed..30e623530 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.support.annotation.VisibleForTesting;
 import android.support.v4.util.Pools;
@@ -20,7 +21,6 @@
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
 import com.bumptech.glide.util.pool.FactoryPools;
-import java.util.HashMap;
 import java.util.Map;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.TimeUnit;
@@ -33,7 +33,7 @@
     EngineResource.ResourceListener {
   private static final String TAG = "Engine";
   private static final int JOB_POOL_SIZE = 150;
-  private final Map<Key, EngineJob<?>> jobs;
+  private final Jobs jobs;
   private final EngineKeyFactory keyFactory;
   private final MemoryCache cache;
   private final EngineJobFactory engineJobFactory;
@@ -70,7 +70,7 @@ public Engine(MemoryCache memoryCache,
       GlideExecutor sourceExecutor,
       GlideExecutor sourceUnlimitedExecutor,
       GlideExecutor animationExecutor,
-      Map<Key, EngineJob<?>> jobs,
+      Jobs jobs,
       EngineKeyFactory keyFactory,
       ActiveResources activeResources,
       EngineJobFactory engineJobFactory,
@@ -91,7 +91,7 @@ public Engine(MemoryCache memoryCache,
     this.keyFactory = keyFactory;
 
     if (jobs == null) {
-      jobs = new HashMap<>();
+      jobs = new Jobs();
     }
     this.jobs = jobs;
 
@@ -177,7 +177,7 @@ public Engine(MemoryCache memoryCache,
       return null;
     }
 
-    EngineJob<?> current = jobs.get(key);
+    EngineJob<?> current = jobs.get(key, onlyRetrieveFromCache);
     if (current != null) {
       current.addCallback(cb);
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
@@ -186,26 +186,35 @@ public Engine(MemoryCache memoryCache,
       return new LoadStatus(cb, current);
     }
 
-    EngineJob<R> engineJob = engineJobFactory.build(key, isMemoryCacheable,
-        useUnlimitedSourceExecutorPool, useAnimationPool);
-    DecodeJob<R> decodeJob = decodeJobFactory.build(
-        glideContext,
-        model,
-        key,
-        signature,
-        width,
-        height,
-        resourceClass,
-        transcodeClass,
-        priority,
-        diskCacheStrategy,
-        transformations,
-        isTransformationRequired,
-        isScaleOnlyOrNoTransform,
-        onlyRetrieveFromCache,
-        options,
-        engineJob);
+    EngineJob<R> engineJob =
+        engineJobFactory.build(
+            key,
+            isMemoryCacheable,
+            useUnlimitedSourceExecutorPool,
+            useAnimationPool,
+            onlyRetrieveFromCache);
+
+    DecodeJob<R> decodeJob =
+        decodeJobFactory.build(
+            glideContext,
+            model,
+            key,
+            signature,
+            width,
+            height,
+            resourceClass,
+            transcodeClass,
+            priority,
+            diskCacheStrategy,
+            transformations,
+            isTransformationRequired,
+            isScaleOnlyOrNoTransform,
+            onlyRetrieveFromCache,
+            options,
+            engineJob);
+
     jobs.put(key, engineJob);
+
     engineJob.addCallback(cb);
     engineJob.start(decodeJob);
 
@@ -232,7 +241,6 @@ private static void logWithTimeAndKey(String log, long startTime, Key key) {
     return active;
   }
 
-
   private EngineResource<?> loadFromCache(Key key, boolean isMemoryCacheable) {
     if (!isMemoryCacheable) {
       return null;
@@ -273,7 +281,7 @@ public void release(Resource<?> resource) {
 
   @SuppressWarnings("unchecked")
   @Override
-  public void onEngineJobComplete(Key key, EngineResource<?> resource) {
+  public void onEngineJobComplete(EngineJob<?> engineJob, Key key, EngineResource<?> resource) {
     Util.assertMainThread();
     // A null resource indicates that the load failed, usually due to an exception.
     if (resource != null) {
@@ -283,21 +291,19 @@ public void onEngineJobComplete(Key key, EngineResource<?> resource) {
         activeResources.activate(key, resource);
       }
     }
-    // TODO: should this check that the engine job is still current?
-    jobs.remove(key);
+
+    jobs.removeIfCurrent(key, engineJob);
   }
 
   @Override
   public void onEngineJobCancelled(EngineJob<?> engineJob, Key key) {
     Util.assertMainThread();
-    EngineJob<?> current = jobs.get(key);
-    if (engineJob.equals(current)) {
-      jobs.remove(key);
-    }
+
+    jobs.removeIfCurrent(key, engineJob);
   }
 
   @Override
-  public void onResourceRemoved(final Resource<?> resource) {
+  public void onResourceRemoved(@NonNull final Resource<?> resource) {
     Util.assertMainThread();
     resourceRecycler.recycle(resource);
   }
@@ -471,10 +477,19 @@ void shutdown() {
     }
 
     @SuppressWarnings("unchecked")
-    <R> EngineJob<R> build(Key key, boolean isMemoryCacheable,
-        boolean useUnlimitedSourceGeneratorPool, boolean useAnimationPool) {
+    <R> EngineJob<R> build(
+        Key key,
+        boolean isMemoryCacheable,
+        boolean useUnlimitedSourceGeneratorPool,
+        boolean useAnimationPool,
+        boolean onlyRetrieveFromCache) {
       EngineJob<R> result = Preconditions.checkNotNull((EngineJob<R>) pool.acquire());
-      return result.init(key, isMemoryCacheable, useUnlimitedSourceGeneratorPool, useAnimationPool);
+      return result.init(
+          key,
+          isMemoryCacheable,
+          useUnlimitedSourceGeneratorPool,
+          useAnimationPool,
+          onlyRetrieveFromCache);
     }
 
     private static void shutdownAndAwaitTermination(ExecutorService pool) {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
index 4683403c4..a7f42dd04 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
@@ -46,6 +46,7 @@
   private boolean isCacheable;
   private boolean useUnlimitedSourceGeneratorPool;
   private boolean useAnimationPool;
+  private boolean onlyRetrieveFromCache;
   private Resource<?> resource;
   private DataSource dataSource;
   private boolean hasResource;
@@ -100,11 +101,13 @@
       Key key,
       boolean isCacheable,
       boolean useUnlimitedSourceGeneratorPool,
-      boolean useAnimationPool) {
+      boolean useAnimationPool,
+      boolean onlyRetrieveFromCache) {
     this.key = key;
     this.isCacheable = isCacheable;
     this.useUnlimitedSourceGeneratorPool = useUnlimitedSourceGeneratorPool;
     this.useAnimationPool = useAnimationPool;
+    this.onlyRetrieveFromCache = onlyRetrieveFromCache;
     return this;
   }
 
@@ -128,7 +131,7 @@ void addCallback(ResourceCallback cb) {
     }
   }
 
-  public void removeCallback(ResourceCallback cb) {
+  void removeCallback(ResourceCallback cb) {
     Util.assertMainThread();
     stateVerifier.throwIfRecycled();
     if (hasResource || hasLoadFailed) {
@@ -141,6 +144,10 @@ public void removeCallback(ResourceCallback cb) {
     }
   }
 
+  boolean onlyRetrieveFromCache() {
+    return onlyRetrieveFromCache;
+  }
+
   private GlideExecutor getActiveSourceExecutor() {
     return useUnlimitedSourceGeneratorPool
         ? sourceUnlimitedExecutor : (useAnimationPool ? animationExecutor : sourceExecutor);
@@ -200,7 +207,7 @@ void handleResultOnMainThread() {
     // Hold on to resource for duration of request so we don't recycle it in the middle of
     // notifying if it synchronously released by one of the callbacks.
     engineResource.acquire();
-    listener.onEngineJobComplete(key, engineResource);
+    listener.onEngineJobComplete(this, key, engineResource);
 
     int size = cbs.size();
     for (int i = 0; i < size; i++) {
@@ -278,7 +285,7 @@ void handleExceptionOnMainThread() {
     }
     hasLoadFailed = true;
 
-    listener.onEngineJobComplete(key, null);
+    listener.onEngineJobComplete(this, key, null);
 
     for (ResourceCallback cb : cbs) {
       if (!isInIgnoredCallbacks(cb)) {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineJobListener.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineJobListener.java
index df81284b3..4b068286f 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineJobListener.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJobListener.java
@@ -4,7 +4,7 @@
 
 interface EngineJobListener {
 
-  void onEngineJobComplete(Key key, EngineResource<?> resource);
+  void onEngineJobComplete(EngineJob<?> engineJob, Key key, EngineResource<?> resource);
 
   void onEngineJobCancelled(EngineJob<?> engineJob, Key key);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java
index 81b0e8c4c..d9cbc2879 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java
@@ -21,9 +21,15 @@
   private final Options options;
   private int hashCode;
 
-  EngineKey(Object model, Key signature, int width, int height,
-      Map<Class<?>, Transformation<?>> transformations, Class<?> resourceClass,
-      Class<?> transcodeClass, Options options) {
+  EngineKey(
+      Object model,
+      Key signature,
+      int width,
+      int height,
+      Map<Class<?>, Transformation<?>> transformations,
+      Class<?> resourceClass,
+      Class<?> transcodeClass,
+      Options options) {
     this.model = Preconditions.checkNotNull(model);
     this.signature = Preconditions.checkNotNull(signature, "Signature must not be null");
     this.width = width;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Jobs.java b/library/src/main/java/com/bumptech/glide/load/engine/Jobs.java
new file mode 100644
index 000000000..93b3106f7
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Jobs.java
@@ -0,0 +1,36 @@
+package com.bumptech.glide.load.engine;
+
+import android.support.annotation.VisibleForTesting;
+import com.bumptech.glide.load.Key;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
+final class Jobs {
+  private final Map<Key, EngineJob<?>> jobs = new HashMap<>();
+  private final Map<Key, EngineJob<?>> onlyCacheJobs = new HashMap<>();
+
+  @VisibleForTesting
+  Map<Key, EngineJob<?>> getAll() {
+    return Collections.unmodifiableMap(jobs);
+  }
+
+  EngineJob<?> get(Key key, boolean onlyRetrieveFromCache) {
+    return getJobMap(onlyRetrieveFromCache).get(key);
+  }
+
+  void put(Key key, EngineJob<?> job) {
+    getJobMap(job.onlyRetrieveFromCache()).put(key, job);
+  }
+
+  void removeIfCurrent(Key key, EngineJob<?> expected) {
+    Map<Key, EngineJob<?>> jobMap = getJobMap(expected.onlyRetrieveFromCache());
+    if (expected.equals(jobMap.get(key))) {
+      jobMap.remove(key);
+    }
+  }
+
+  private Map<Key, EngineJob<?>> getJobMap(boolean onlyRetrieveFromCache) {
+    return onlyRetrieveFromCache ? onlyCacheJobs : jobs;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalPreferredCacheDiskCacheFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalPreferredCacheDiskCacheFactory.java
index 024964713..4f2743b1e 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalPreferredCacheDiskCacheFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalPreferredCacheDiskCacheFactory.java
@@ -52,7 +52,7 @@ public File getCacheDirectory() {
         File cacheDirectory = context.getExternalCacheDir();
 
         // Shared storage is not available.
-        if (cacheDirectory == null) {
+        if ((cacheDirectory == null) || (!cacheDirectory.canWrite())) {
           return internalCacheDirectory;
         }
         if (diskCacheName != null) {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java
index 91c705a72..ff2ad2ff8 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java
@@ -1,6 +1,8 @@
 package com.bumptech.glide.load.engine.cache;
 
 import android.annotation.SuppressLint;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.util.LruCache;
@@ -26,8 +28,8 @@ public void setResourceRemovedListener(ResourceRemovedListener listener) {
   }
 
   @Override
-  protected void onItemEvicted(Key key, Resource<?> item) {
-    if (listener != null) {
+  protected void onItemEvicted(@NonNull Key key, @Nullable Resource<?> item) {
+    if (listener != null && item != null) {
       listener.onResourceRemoved(item);
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCache.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCache.java
index d5262d6fa..654d1686b 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCache.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.engine.cache;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.Resource;
@@ -12,7 +13,7 @@
    * An interface that will be called whenever a bitmap is removed from the cache.
    */
   interface ResourceRemovedListener {
-    void onResourceRemoved(Resource<?> removed);
+    void onResourceRemoved(@NonNull Resource<?> removed);
   }
 
   /**
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java b/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java
index 43718dc3c..c654de2fc 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.model;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.support.annotation.VisibleForTesting;
 import com.bumptech.glide.util.LruCache;
@@ -29,7 +30,7 @@ public ModelCache() {
   public ModelCache(long size) {
     cache = new LruCache<ModelKey<A>, B>(size) {
       @Override
-      protected void onItemEvicted(ModelKey<A> key, B item) {
+      protected void onItemEvicted(@NonNull ModelKey<A> key, @Nullable B item) {
         key.release();
       }
     };
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
index 99c05f1a5..e4e60f361 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
@@ -468,6 +468,7 @@ public RequestOptions useAnimationPool(boolean flag) {
   }
 
   /**
+   *
    * If set to true, will only load an item if found in the cache, and will not fetch from source.
    */
   @CheckResult
diff --git a/library/src/main/java/com/bumptech/glide/util/LruCache.java b/library/src/main/java/com/bumptech/glide/util/LruCache.java
index d09ee9923..e106e578f 100644
--- a/library/src/main/java/com/bumptech/glide/util/LruCache.java
+++ b/library/src/main/java/com/bumptech/glide/util/LruCache.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.util;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
@@ -69,7 +70,7 @@ protected synchronized int getCount() {
    * @param key  The key of the evicted item.
    * @param item The evicted item.
    */
-  protected void onItemEvicted(T key, Y item) {
+  protected void onItemEvicted(@NonNull T key, @Nullable Y item) {
     // optional override
   }
 
@@ -111,31 +112,34 @@ public synchronized Y get(T key) {
    * Adds the given item to the cache with the given key and returns any previous entry for the
    * given key that may have already been in the cache.
    *
-   * <p> If the size of the item is larger than the total cache size, the item will not be added to
+   * <p>If the size of the item is larger than the total cache size, the item will not be added to
    * the cache and instead {@link #onItemEvicted(Object, Object)} will be called synchronously with
-   * the given key and item. </p>
+   * the given key and item.
    *
    * @param key  The key to add the item at.
    * @param item The item to add.
    */
-  public synchronized Y put(T key, Y item) {
+  public synchronized Y put(T key, @Nullable Y item) {
     final int itemSize = getSize(item);
     if (itemSize >= maxSize) {
       onItemEvicted(key, item);
       return null;
     }
 
-    final Y result = cache.put(key, item);
+    @Nullable final Y old = cache.put(key, item);
     if (item != null) {
       currentSize += getSize(item);
     }
-    if (result != null) {
-      // TODO: should we call onItemEvicted here?
-      currentSize -= getSize(result);
+    if (old != null) {
+      currentSize -= getSize(old);
+
+      if (!old.equals(item)) {
+        onItemEvicted(key, old);
+      }
     }
     evict();
 
-    return result;
+    return old;
   }
 
   /**
diff --git a/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java b/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
index 5bd1cf613..044bf30e8 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
@@ -72,6 +72,7 @@ public void testReturnsInputStreamOnStatusOk() throws Exception {
     fetcher.loadData(Priority.HIGH, callback);
     verify(callback).onDataReady(streamCaptor.capture());
     TestUtil.assertStreamOf(expected, streamCaptor.getValue());
+    assertThat(mockWebServer.takeRequest().getMethod()).isEqualTo("GET");
   }
 
   @Test
@@ -83,6 +84,8 @@ public void testHandlesRedirect301s() throws Exception {
     getFetcher().loadData(Priority.LOW, callback);
     verify(callback).onDataReady(streamCaptor.capture());
     TestUtil.assertStreamOf(expected, streamCaptor.getValue());
+    assertThat(mockWebServer.takeRequest().getMethod()).isEqualTo("GET");
+    assertThat(mockWebServer.takeRequest().getMethod()).isEqualTo("GET");
   }
 
   @Test
@@ -94,6 +97,8 @@ public void testHandlesRedirect302s() throws Exception {
     getFetcher().loadData(Priority.LOW, callback);
     verify(callback).onDataReady(streamCaptor.capture());
     TestUtil.assertStreamOf(expected, streamCaptor.getValue());
+    assertThat(mockWebServer.takeRequest().getMethod()).isEqualTo("GET");
+    assertThat(mockWebServer.takeRequest().getMethod()).isEqualTo("GET");
   }
 
   @Test
@@ -106,9 +111,11 @@ public void testHandlesRelativeRedirects() throws Exception {
     verify(callback).onDataReady(streamCaptor.capture());
     TestUtil.assertStreamOf(expected, streamCaptor.getValue());
 
-    mockWebServer.takeRequest();
+    RecordedRequest first = mockWebServer.takeRequest();
+    assertThat(first.getMethod()).isEqualTo("GET");
     RecordedRequest second = mockWebServer.takeRequest();
     assertThat(second.getPath()).endsWith("/redirect");
+    assertThat(second.getMethod()).isEqualTo("GET");
   }
 
   @Test
@@ -126,9 +133,13 @@ public void testHandlesUpToFiveRedirects() throws Exception {
     verify(callback).onDataReady(streamCaptor.capture());
     TestUtil.assertStreamOf(expected, streamCaptor.getValue());
 
-    assertThat(mockWebServer.takeRequest().getPath()).contains(DEFAULT_PATH);
+    RecordedRequest request = mockWebServer.takeRequest();
+    assertThat(request.getPath()).contains(DEFAULT_PATH);
+    assertThat(request.getMethod()).isEqualTo("GET");
     for (int i = 0; i < numRedirects; i++) {
-      assertThat(mockWebServer.takeRequest().getPath()).contains(redirectBase + i);
+      RecordedRequest current = mockWebServer.takeRequest();
+      assertThat(current.getPath()).contains(redirectBase + i);
+      assertThat(current.getMethod()).isEqualTo("GET");
     }
   }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java b/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
index e1f331783..a3156e2d7 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
@@ -64,7 +64,8 @@ public void testListenerNotifiedJobCompleteOnOnResourceReady() {
 
     ShadowLooper.runUiThreadTasks();
 
-    verify(harness.listener).onEngineJobComplete(eq(harness.key), eq(harness.engineResource));
+    verify(harness.listener)
+        .onEngineJobComplete(eq(job), eq(harness.key), eq(harness.engineResource));
   }
 
   @Test
@@ -107,7 +108,8 @@ public void testListenerNotifiedJobCompleteOnException() {
     job.start(harness.decodeJob);
     job.onLoadFailed(new GlideException("test"));
     ShadowLooper.runUiThreadTasks();
-    verify(harness.listener).onEngineJobComplete(eq(harness.key), isNull(EngineResource.class));
+    verify(harness.listener)
+        .onEngineJobComplete(eq(job), eq(harness.key), isNull(EngineResource.class));
   }
 
   @Test
@@ -220,7 +222,8 @@ public void testDoesNotNotifyCancelledIfReceivedException() {
     job.start(harness.decodeJob);
     job.onLoadFailed(new GlideException("test"));
 
-    verify(harness.listener).onEngineJobComplete(eq(harness.key), isNull(EngineResource.class));
+    verify(harness.listener)
+        .onEngineJobComplete(eq(job), eq(harness.key), isNull(EngineResource.class));
     verify(harness.listener, never()).onEngineJobCancelled(any(EngineJob.class), any(Key.class));
   }
 
@@ -460,6 +463,7 @@ public void testSubmitsDecodeJobToUnlimitedSourceServiceWhenDecodingFromSourceOn
     final boolean isCacheable = true;
     final boolean useUnlimitedSourceGeneratorPool = false;
     final boolean useAnimationPool = false;
+    final boolean onlyRetrieveFromCache = false;
     final int numCbs = 10;
     final List<ResourceCallback> cbs = new ArrayList<>();
     final EngineJob.EngineResourceFactory factory = mock(EngineJob.EngineResourceFactory.class);
@@ -482,7 +486,13 @@ public MultiCbHarness() {
               animationService,
               listener,
               pool,
-              factory).init(key, isCacheable, useUnlimitedSourceGeneratorPool, useAnimationPool);
+              factory);
+      job.init(
+          key,
+          isCacheable,
+          useUnlimitedSourceGeneratorPool,
+          useAnimationPool,
+          onlyRetrieveFromCache);
       for (int i = 0; i < numCbs; i++) {
         cbs.add(mock(ResourceCallback.class));
       }
@@ -508,6 +518,7 @@ public MultiCbHarness() {
     boolean isCacheable = true;
     boolean useUnlimitedSourceGeneratorPool = false;
     final boolean useAnimationPool = false;
+    final boolean onlyRetrieveFromCache = false;
     final DecodeJob<Object> decodeJob = mock(DecodeJob.class);
     final Pools.Pool<EngineJob<?>> pool = new Pools.SimplePool<>(1);
     final DataSource dataSource = DataSource.DATA_DISK_CACHE;
@@ -522,8 +533,13 @@ public MultiCbHarness() {
               animationService,
               listener,
               pool,
-              factory)
-              .init(key, isCacheable, useUnlimitedSourceGeneratorPool, useAnimationPool);
+              factory);
+      result.init(
+          key,
+          isCacheable,
+          useUnlimitedSourceGeneratorPool,
+          useAnimationPool,
+          onlyRetrieveFromCache);
       result.addCallback(cb);
       return result;
     }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java b/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
index b4fd39697..928be9497 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
@@ -86,7 +86,7 @@ public void testEngineJobReceivesRemoveCallbackFromLoadStatus() {
   public void testNewRunnerIsAddedToRunnersMap() {
     harness.doLoad();
 
-    assertThat(harness.jobs).containsKey(harness.cacheKey);
+    assertThat(harness.jobs.getAll()).containsKey(harness.cacheKey);
   }
 
   @Test
@@ -259,16 +259,16 @@ public void testNullLoadStatusIsReturnedForCachedResource() {
   public void testRunnerIsRemovedFromRunnersOnEngineNotifiedJobComplete() {
     harness.doLoad();
 
-    harness.getEngine().onEngineJobComplete(harness.cacheKey, harness.resource);
+    harness.callOnEngineJobComplete();
 
-    assertThat(harness.jobs).doesNotContainKey(harness.cacheKey);
+    assertThat(harness.jobs.getAll()).doesNotContainKey(harness.cacheKey);
   }
 
   @Test
   public void testEngineIsSetAsResourceListenerOnJobComplete() {
     harness.doLoad();
 
-    harness.getEngine().onEngineJobComplete(harness.cacheKey, harness.resource);
+    harness.callOnEngineJobComplete();
 
     verify(harness.resource).setResourceListener(eq(harness.cacheKey), eq(harness.getEngine()));
   }
@@ -277,13 +277,13 @@ public void testEngineIsSetAsResourceListenerOnJobComplete() {
   public void testEngineIsNotSetAsResourceListenerIfResourceIsNullOnJobComplete() {
     harness.doLoad();
 
-    harness.getEngine().onEngineJobComplete(harness.cacheKey, null);
+    harness.getEngine().onEngineJobComplete(harness.job, harness.cacheKey, /*resource=*/ null);
   }
 
   @Test
   public void testResourceIsAddedToActiveResourcesOnEngineComplete() {
     when(harness.resource.isCacheable()).thenReturn(true);
-    harness.getEngine().onEngineJobComplete(harness.cacheKey, harness.resource);
+    harness.callOnEngineJobComplete();
 
     EngineResource<?> resource = harness.activeResources.get(harness.cacheKey);
     assertThat(harness.resource).isEqualTo(resource);
@@ -291,14 +291,14 @@ public void testResourceIsAddedToActiveResourcesOnEngineComplete() {
 
   @Test
   public void testDoesNotPutNullResourceInActiveResourcesOnEngineComplete() {
-    harness.getEngine().onEngineJobComplete(harness.cacheKey, null);
+    harness.getEngine().onEngineJobComplete(harness.job, harness.cacheKey, /*resource=*/ null);
     assertThat(harness.activeResources.get(harness.cacheKey)).isNull();
   }
 
   @Test
   public void testDoesNotPutResourceThatIsNotCacheableInActiveResourcesOnEngineComplete() {
     when(harness.resource.isCacheable()).thenReturn(false);
-    harness.getEngine().onEngineJobComplete(harness.cacheKey, harness.resource);
+    harness.callOnEngineJobComplete();
     assertThat(harness.activeResources.get(harness.cacheKey)).isNull();
   }
 
@@ -308,7 +308,7 @@ public void testRunnerIsRemovedFromRunnersOnEngineNotifiedJobCancel() {
 
     harness.getEngine().onEngineJobCancelled(harness.job, harness.cacheKey);
 
-    assertThat(harness.jobs).doesNotContainKey(harness.cacheKey);
+    assertThat(harness.jobs.getAll()).doesNotContainKey(harness.cacheKey);
   }
 
   @Test
@@ -317,7 +317,7 @@ public void testJobIsNotRemovedFromJobsIfOldJobIsCancelled() {
 
     harness.getEngine().onEngineJobCancelled(mock(EngineJob.class), harness.cacheKey);
 
-    assertEquals(harness.job, harness.jobs.get(harness.cacheKey));
+    assertEquals(harness.job, harness.jobs.get(harness.cacheKey, harness.onlyRetrieveFromCache));
   }
 
   @Test
@@ -379,7 +379,7 @@ public void testResourceIsRecycledWhenRemovedFromCache() {
   public void testJobIsPutInJobWithCacheKeyWithRelevantIds() {
     harness.doLoad();
 
-    assertThat(harness.jobs).containsEntry(harness.cacheKey, harness.job);
+    assertThat(harness.jobs.getAll()).containsEntry(harness.cacheKey, harness.job);
   }
 
   @Test
@@ -399,7 +399,8 @@ public void testFactoryIsGivenNecessaryArguments() {
         eq(harness.cacheKey),
         eq(true) /*isMemoryCacheable*/,
         eq(false) /*useUnlimitedSourceGeneratorPool*/,
-        /*useAnimationPool=*/ eq(false));
+        /*useAnimationPool=*/ eq(false),
+        /*onlyRetrieveFromCache=*/ eq(false));
   }
 
   @Test
@@ -411,7 +412,8 @@ public void testFactoryIsGivenNecessaryArgumentsWithUnlimitedPool() {
         eq(harness.cacheKey),
         eq(true) /*isMemoryCacheable*/,
         eq(true) /*useUnlimitedSourceGeneratorPool*/,
-        /*useAnimationPool=*/ eq(false));
+        /*useAnimationPool=*/ eq(false),
+        /*onlyRetrieveFromCache=*/ eq(false));
   }
 
   @Test
@@ -442,7 +444,7 @@ public void load_afterResourceIsLoadedInActiveResources_returnsFromMemoryCache()
     doAnswer(new Answer<Object>() {
       @Override
       public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-        harness.getEngine().onEngineJobComplete(harness.cacheKey, harness.resource);
+        harness.callOnEngineJobComplete();
         return null;
       }
     }).when(harness.job).start(any(DecodeJob.class));
@@ -458,7 +460,7 @@ public void load_afterResourceIsLoadedAndReleased_returnsFromMemoryCache() {
     doAnswer(new Answer<Object>() {
       @Override
       public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-        harness.getEngine().onEngineJobComplete(harness.cacheKey, harness.resource);
+        harness.callOnEngineJobComplete();
         return null;
       }
     }).when(harness.job).start(any(DecodeJob.class));
@@ -476,7 +478,7 @@ public void load_afterResourceIsGcedFromActive_returnsFromMemoryCache() {
     doAnswer(new Answer<Object>() {
       @Override
       public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-        harness.getEngine().onEngineJobComplete(harness.cacheKey, harness.resource);
+        harness.callOnEngineJobComplete();
         return null;
       }
     }).when(harness.job).start(any(DecodeJob.class));
@@ -488,13 +490,167 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
     verify(harness.cb).onResourceReady(any(Resource.class), eq(DataSource.MEMORY_CACHE));
   }
 
+  @Test
+  public void load_withOnlyRetrieveFromCache_andPreviousNormalLoad_startsNewLoad() {
+    EngineJob<?> first = harness.job;
+    harness.doLoad();
+    EngineJob<?> second = mock(EngineJob.class);
+    harness.job = second;
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+
+    verify(first).start(any(DecodeJob.class));
+    verify(second).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void load_withNormalLoad_afterPreviousRetrieveFromCache_startsNewLoad() {
+    EngineJob<?> first = harness.job;
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+    EngineJob<?> second = mock(EngineJob.class);
+    harness.job = second;
+    harness.onlyRetrieveFromCache = false;
+    harness.doLoad();
+
+    verify(first).start(any(DecodeJob.class));
+    verify(second).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void load_afterFinishedOnlyRetrieveFromCache_withPendingNormal_doesNotStartNewLoad() {
+    EngineJob<?> firstNormal = harness.job;
+    harness.doLoad();
+
+    harness.job = mock(EngineJob.class);
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+    harness.callOnEngineJobComplete();
+
+    EngineJob<?> secondNormal = mock(EngineJob.class);
+    harness.job = secondNormal;
+    harness.onlyRetrieveFromCache = false;
+    harness.doLoad();
+
+    verify(firstNormal).start(any(DecodeJob.class));
+    verify(secondNormal, never()).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void load_afterCancelledOnlyRetrieveFromCache_withPendingNormal_doesNotStartNewLoad() {
+    EngineJob<?> firstNormal = harness.job;
+    harness.doLoad();
+
+    harness.job = mock(EngineJob.class);
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+    harness.getEngine().onEngineJobCancelled(harness.job, harness.cacheKey);
+
+    EngineJob<?> secondNormal = mock(EngineJob.class);
+    harness.job = secondNormal;
+    harness.onlyRetrieveFromCache = false;
+    harness.doLoad();
+
+    verify(firstNormal).start(any(DecodeJob.class));
+    verify(secondNormal, never()).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void load_withOnlyRetrieveFromCache_withOtherRetrieveFromCachePending_doesNotStartNew() {
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+
+    EngineJob<?> second = mock(EngineJob.class);
+    harness.job = second;
+    harness.doLoad();
+
+    verify(second, never()).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void load_withOnlyRetrieveFromCache_afterPreviousFinishedOnlyFromCacheLoad_startsNew() {
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+    harness.callOnEngineJobComplete();
+
+    EngineJob<?> second = mock(EngineJob.class);
+    harness.job = second;
+    harness.doLoad();
+
+    verify(second).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void load_withOnlyRetrieveFromCache_afterPreviousCancelledOnlyFromCacheLoad_startsNew() {
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+    harness.getEngine().onEngineJobCancelled(harness.job, harness.cacheKey);
+
+    EngineJob<?> second = mock(EngineJob.class);
+    harness.job = second;
+    harness.doLoad();
+
+    verify(second).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void onEngineJobComplete_withOldJobForKey_doesNotRemoveJob() {
+    harness.doLoad();
+    harness.getEngine()
+        .onEngineJobComplete(mock(EngineJob.class), harness.cacheKey, harness.resource);
+
+    harness.job = mock(EngineJob.class);
+    harness.doLoad();
+
+    verify(harness.job, never()).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void onEngineJobCancelled_withOldJobForKey_doesNotRemoveJob() {
+    harness.doLoad();
+    harness.getEngine()
+        .onEngineJobCancelled(mock(EngineJob.class), harness.cacheKey);
+
+    harness.job = mock(EngineJob.class);
+    harness.doLoad();
+
+    verify(harness.job, never()).start(any(DecodeJob.class));
+  }
+
+
+  @Test
+  public void onEngineJobComplete_withOnlyRetrieveFromCacheAndOldJobForKey_doesNotRemoveJob() {
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+    harness.getEngine()
+        .onEngineJobComplete(mock(EngineJob.class), harness.cacheKey, harness.resource);
+
+    harness.job = mock(EngineJob.class);
+    harness.doLoad();
+
+    verify(harness.job, never()).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void onEngineJobCancelled_withOnlyRetrieveFromCacheAndOldJobForKey_doesNotRemoveJob() {
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+    harness.getEngine()
+        .onEngineJobCancelled(mock(EngineJob.class), harness.cacheKey);
+
+    harness.job = mock(EngineJob.class);
+    harness.doLoad();
+
+    verify(harness.job, never()).start(any(DecodeJob.class));
+  }
+
   private static class EngineTestHarness {
     final EngineKey cacheKey = mock(EngineKey.class);
     final EngineKeyFactory keyFactory = mock(EngineKeyFactory.class);
     ResourceCallback cb = mock(ResourceCallback.class);
     @SuppressWarnings("rawtypes")
     final EngineResource resource = mock(EngineResource.class);
-    final Map<Key, EngineJob<?>> jobs = new HashMap<>();
+    final Jobs jobs = new Jobs();
     final ActiveResources activeResources = new ActiveResources();
 
     final int width = 100;
@@ -502,7 +658,7 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
 
     final Object model = new Object();
     MemoryCache cache = mock(MemoryCache.class);
-    final EngineJob<?> job;
+    EngineJob<?> job;
     private Engine engine;
     final Engine.EngineJobFactory engineJobFactory = mock(Engine.EngineJobFactory.class);
     final Engine.DecodeJobFactory decodeJobFactory = mock(Engine.DecodeJobFactory.class);
@@ -513,7 +669,7 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
     final GlideContext glideContext = mock(GlideContext.class);
     boolean isMemoryCacheable = true;
     boolean useUnlimitedSourceGeneratorPool = false;
-    final boolean onlyRetrieveFromCache = false;
+    boolean onlyRetrieveFromCache = false;
     final boolean isScaleOnlyOrNoTransform = true;
 
     EngineTestHarness() {
@@ -522,12 +678,19 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
       when(resource.getResource()).thenReturn(mock(Resource.class));
 
       job = mock(EngineJob.class);
+    }
 
+    void callOnEngineJobComplete() {
+      getEngine().onEngineJobComplete(job, cacheKey, resource);
     }
 
+
     Engine.LoadStatus doLoad() {
-      when(engineJobFactory.build(eq(cacheKey), anyBoolean(), anyBoolean(), anyBoolean()))
+      when(
+          engineJobFactory.build(
+              eq(cacheKey), anyBoolean(), anyBoolean(), anyBoolean(), anyBoolean()))
           .thenReturn((EngineJob<Object>) job);
+      when(job.onlyRetrieveFromCache()).thenReturn(onlyRetrieveFromCache);
       return getEngine().load(glideContext,
           model,
           signature,
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java b/library/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java
index 06eef2b98..f00122d45 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java
@@ -4,6 +4,7 @@
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
+import static org.mockito.AdditionalMatchers.not;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyObject;
 import static org.mockito.Matchers.eq;
@@ -13,6 +14,8 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.util.LruCache;
 import org.junit.Before;
 import org.junit.Test;
@@ -60,14 +63,15 @@ public void testCanPutNullItemWithoutChangingSize() {
   @Test
   public void testReplacingNonNullItemWithNullItemDecreasesSize() {
     String key = getKey();
-    cache.put(key, new Object());
+    Object initialValue = new Object();
+    cache.put(key, initialValue);
     cache.put(key, null);
 
     for (int i = 0; i < SIZE; i++) {
       cache.put(getKey(), new Object());
     }
 
-    verify(listener, never()).onItemRemoved(anyObject());
+    verify(listener).onItemRemoved(initialValue);
   }
 
   @Test
@@ -86,14 +90,16 @@ public void testReplacingNullItemWIthNullItemIncreasesSize() {
   @Test
   public void testReplacingNonNullItemWithNonNullItemUpdatesSize() {
     String key = getKey();
-    cache.put(key, new Object());
+    Object initialValue = new Object();
+    cache.put(key, initialValue);
     cache.put(key, new Object());
 
-    for (int i = 0; i < SIZE; i++) {
+    for (int i = 0; i < SIZE - 1; i++) {
       cache.put(getKey(), new Object());
     }
 
-    verify(listener).onItemRemoved(anyObject());
+    verify(listener).onItemRemoved(initialValue);
+    verify(listener, never()).onItemRemoved(not(eq(initialValue)));
   }
 
   @Test
@@ -191,6 +197,34 @@ public void testCanPutSameItemMultipleTimes() {
     verify(listener, never()).onItemRemoved(anyObject());
   }
 
+  @Test
+  public void put_withSameValueTwice_doesNotEvictItems() {
+    String key = getKey();
+    Object value = new Object();
+    cache.put(key, value);
+    cache.put(key, value);
+
+    verify(listener, never()).onItemRemoved(anyObject());
+  }
+
+  @Test
+  public void put_withExistingNullValue_doesNotNotifyListener() {
+    String key = getKey();
+    cache.put(key, /*value=*/ null);
+    cache.put(key, new Object());
+
+    verify(listener, never()).onItemRemoved(anyObject());
+  }
+
+  @Test
+  public void put_withNullValue_withSizeGreaterThanMaximum_notifiesListener() {
+    String key = getKey();
+    when(listener.getSize(null)).thenReturn((int) (cache.getMaxSize() * 2));
+    cache.put(key, null);
+
+    verify(listener).onItemRemoved(anyObject());
+  }
+
   @Test
   public void testCanIncreaseSizeDynamically() {
     int sizeMultiplier = 2;
@@ -259,7 +293,7 @@ public void testDecreasesSizeWhenRemovesKey() {
     Object value = new Object();
     cache.put(key, value);
     for (int i = 0; i < SIZE - 1; i++) {
-      cache.put(key, value);
+      cache.put(getKey(), value);
     }
     cache.remove(key);
     cache.put(key, value);
@@ -340,7 +374,7 @@ private String getKey() {
     }
 
     @Override
-    protected void onItemEvicted(String key, Object item) {
+    protected void onItemEvicted(@NonNull String key, @Nullable Object item) {
       listener.onItemRemoved(item);
     }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java b/library/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
index 2c0faa285..cca4ce347 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
@@ -1,18 +1,22 @@
 package com.bumptech.glide.load.engine.cache;
 
 import static com.bumptech.glide.load.engine.cache.MemoryCache.ResourceRemovedListener;
+import static com.bumptech.glide.tests.Util.anyResource;
 import static com.bumptech.glide.tests.Util.mockResource;
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import android.annotation.TargetApi;
 import android.content.ComponentCallbacks2;
 import android.os.Build;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.util.LruCache;
@@ -24,19 +28,54 @@
 @RunWith(JUnit4.class)
 @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
 public class LruResourceCacheTest {
-  private static class TrimClearMemoryCacheHarness {
-    final LruResourceCache resourceCache = new LruResourceCache(100);
-    final Resource<?> first = mockResource();
-    final Resource<?> second = mockResource();
-    final ResourceRemovedListener listener = mock(ResourceRemovedListener.class);
 
-    public TrimClearMemoryCacheHarness() {
-      when(first.getSize()).thenReturn(50);
-      when(second.getSize()).thenReturn(50);
-      resourceCache.put(new MockKey(), first);
-      resourceCache.put(new MockKey(), second);
-      resourceCache.setResourceRemovedListener(listener);
-    }
+  @Test
+  public void put_withExistingItem_updatesSizeCorrectly() {
+    PutWithExistingEntryHarness harness = new PutWithExistingEntryHarness();
+    harness.cache.put(harness.key, harness.first);
+    harness.cache.put(harness.key, harness.second);
+
+    assertThat(harness.cache.getCurrentSize()).isEqualTo(harness.second.getSize());
+  }
+
+  @Test
+  public void put_withExistingItem_evictsExistingItem() {
+    PutWithExistingEntryHarness harness = new PutWithExistingEntryHarness();
+    harness.cache.put(harness.key, harness.first);
+    harness.cache.put(harness.key, harness.second);
+
+    verify(harness.listener).onResourceRemoved(harness.first);
+  }
+
+  @Test
+  public void get_afterPutWithExistingItem_returnsNewItem() {
+    PutWithExistingEntryHarness harness = new PutWithExistingEntryHarness();
+    harness.cache.put(harness.key, harness.first);
+    harness.cache.put(harness.key, harness.second);
+
+    assertThat(harness.cache.get(harness.key)).isEqualTo(harness.second);
+  }
+
+  @Test
+  public void onItemEvicted_withNullValue_doesNotNotifyListener() {
+    PutWithExistingEntryHarness harness = new PutWithExistingEntryHarness();
+    harness.cache.onItemEvicted(new MockKey(), null);
+    verify(harness.listener, never()).onResourceRemoved(anyResource());
+  }
+
+  @Test
+  public void clearMemory_afterPutWithExistingItem_evictsOnlyNewItem() {
+    PutWithExistingEntryHarness harness = new PutWithExistingEntryHarness();
+    harness.cache.put(harness.key, harness.first);
+    harness.cache.put(harness.key, harness.second);
+
+    verify(harness.listener).onResourceRemoved(harness.first);
+    verify(harness.listener, never()).onResourceRemoved(harness.second);
+
+    harness.cache.clearMemory();
+
+    verify(harness.listener, times(1)).onResourceRemoved(harness.first);
+    verify(harness.listener).onResourceRemoved(harness.second);
   }
 
   @Test
@@ -119,7 +158,7 @@ public void testPreventEviction() {
     cache.put(thirdKey, third);
     cache.setResourceRemovedListener(new ResourceRemovedListener() {
       @Override
-      public void onResourceRemoved(Resource<?> removed) {
+      public void onResourceRemoved(@NonNull Resource<?> removed) {
         if (removed == first) {
           cache.put(firstKey, first);
         }
@@ -149,4 +188,33 @@ public void updateDiskCacheKey(MessageDigest messageDigest) {
       messageDigest.update(toString().getBytes(CHARSET));
     }
   }
+
+  private static class PutWithExistingEntryHarness {
+    final LruResourceCache cache = new LruResourceCache(100);
+    final Resource<?> first = mockResource();
+    final Resource<?> second = mockResource();
+    final ResourceRemovedListener listener = mock(ResourceRemovedListener.class);
+    final Key key = new MockKey();
+
+    PutWithExistingEntryHarness() {
+      when(first.getSize()).thenReturn(50);
+      when(second.getSize()).thenReturn(50);
+      cache.setResourceRemovedListener(listener);
+    }
+  }
+
+  private static class TrimClearMemoryCacheHarness {
+    final LruResourceCache resourceCache = new LruResourceCache(100);
+    final Resource<?> first = mockResource();
+    final Resource<?> second = mockResource();
+    final ResourceRemovedListener listener = mock(ResourceRemovedListener.class);
+
+    TrimClearMemoryCacheHarness() {
+      when(first.getSize()).thenReturn(50);
+      when(second.getSize()).thenReturn(50);
+      resourceCache.put(new MockKey(), first);
+      resourceCache.put(new MockKey(), second);
+      resourceCache.setResourceRemovedListener(listener);
+    }
+  }
 }
