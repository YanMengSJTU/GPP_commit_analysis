diff --git a/README.md b/README.md
index cd89ab5a7..44ceb7c68 100644
--- a/README.md
+++ b/README.md
@@ -494,7 +494,10 @@ RuntimeCompat：可用进程数
   }
 ```
 ### MemorySizeCalcultor
-内存大小计算器
+内存大小计算器:
+* 位图池大小
+* 内存缓存大小
+* 数组池大小
 ```java
   public final class MemorySizeCalculator{
     private static final String TAG="MemorySizeCalculator";
@@ -510,13 +513,16 @@ RuntimeCompat：可用进程数
     }
     MemorySizeCalculator(MemorySizeCalculator.Builder builder){
       this.context=builder.context;
-      //低端设备，数组池内存分配等于高端设备一半
+      //低端设备，数组池内存分配等于高端设备一半  2MB
       arrayPoolSize=isLowMemoryDevice(builder.activityManager)?builder.arrayPoolSizeBytes/LOW_MEMORY_BYTE_ARRAY_POOL_DIVISOR:builder.arrayPoolSizeBytes;
+      //0.4f  0.33f
       int maxSize=getMaxSize(builder.activityManager,builder.maxSizeMultiplier,builder.lowMemoryMaxSizeMultiplier);
       int widthPixels=builder.screenDimensions.getWidthPixels();
       int heightPixels=builder.screenDimensions.getHeightPixels();
       int screenSize=widthPixels*heightPixels*BYTES_PER_ARGB_8888_PIXEL;
+      //4:1(4或1张全屏图片大小)
       int targetBitmapPoolSize=Math.round(screenSize*builder.bitmapPoolScreens);
+      //2(2张全屏图大小)
       int targetMemoryCacheSize=Math.round(screenSize*builder.memoryCacheScreens);
       int availableSize=maxSize-arrayPoolSize;
       if(targetMemoryCacheSize+targetBitmapPoolSize<=availableSize){
@@ -557,13 +563,194 @@ RuntimeCompat：可用进程数
     public static final class Builder{
       static final int MEMORY_CACHE_TARGET_SCREENS=2;
       /**
-      * On Android O+,we use {@link android.graphics.Bitmap.Config#HEADWARE} for all reasonably sized 
+      * On Android O+,we use {@link android.graphics.Bitmap.Config#HEADWARE} for all reasonably sized images unless we are creating thumbnails for the first time.As a result, the Bitmap pool is much less important on O than it was on previous versions.
       */
+      static final int BITMAP_POOL_TARGET_SCREENS=Build.VERSION.SDK_INT<Build.VERSION_CODES.O?4:1;
+      static final float MAX_SIZE_MULTIPLIER=0.4f;
+      static final float LOW_MEMORY_MAX_SIZE_MULTIPLIER=0.33f;
+      //4MB
+      static final int ARRAY_POOL_SIZE_BYTES=4*1024*1024;
+      final Context context;
+      ActivityManager activityManager;
+      ScreenDimensions screenDimensions;
+      float memoryCacheScreens=MEMORY_CACHE_TARGET_SCREENS;
+      float bitmapPoolScreens=BITMAP_POOL_TARGET_SCREENS;
+      float maxSizeMultiplier=MAX_SIZE_MULTIPLIER;
+      float lowMemoryMaxSizeMultiplier=LOW_MEMORY_MAX_SIZE_MULTIPLIER;
+      int arrayPoolSizeBytes=ARRAY_POOL_SIZE_BYTES;
+      
+      public Builder(Context context){
+        this.context=context;
+        activityManager=(ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE);
+        screenDimensions=new DisplayMetricsScreenDimensions(context.getResources().getDisplayMetrics());
+        //On Android O+ Bitmaps are allocated natively,ART is much more efficient at managing garbage and we rely heavily on HEADWARE Bitmaps,making Bitmap re-use much less important.
+        if(Build.VERSION.SDK_INT>=Build.VERSION_CODES.O && isLowMemoryDevice(activityManager)){
+          bitmapPoolScreens=0;
+        }
+        public Builder setMemoryCacheScreens(float memoryCacheScreens){
+          Preconditions.checkArgument(memroyCacheScreens>=0,"Memory cache screens must be greater than or equal to 0");
+          this.memoryCacheScreens=memoryCacheScreens;
+          return this;
+        }
+        public Builder setBitmapPoolScreens(float bitmapPoolScreens){
+          Preconditions.checkArgument(bitmapPoolScreens>=0,"Bitmap pool screens must be greater than or equal to 0");
+          this.bitmapPoolScreens=bitmapPoolScreens;
+          return this;
+        }
+        public Builder setMaxSizeMultiplier(float maxSizeMultiplier){
+          Preconditions.checkArgument(maxSizeMultiplier>=0&& maxSizeMultiplier<=1,"Size multiplier must be between 0 and 1");
+          this.maxSizeMultiplier = maxSizeMultiplier;
+          return this;
+        }
+        public Builder setLowMemoryMaxSizeMultiplier(float lowMemoryMaxSizeMultiplier){
+          Preconditions.checkArgument(lowMemoryMaxSizeMultiplier>=0&&lowMemoryMaxSizeMultiplier<=1);
+          this.lowMemoryMaxSizeMultiplier=lowMemoryMaxSizeMultiplier;
+          return this;
+        }
+        public Builder setArrayPoolSize(int arrayPoolSizeBytes){
+          this.arrayPoolSizeBytes=arrayPoolSizeBytes;
+          return this;
+        }
+        Builder setActivityManager(ActivityManager activityManager){
+          this.activityManager=activityManager;
+          return this;
+        }
+        Builder setScreenDimensions(ScreenDimensions screenDimensions){
+          this.screenDimensions=screenDimensions;
+          return this;
+        }
+        public MemorySizeCalculator build(){
+          return new MemorySizeCalculator(this);
+        }
+      }
+    }
+    private static final class DisplayMetricsScreenDimensions implements ScreenDimensions{
+      private final DisplayMetrics displayMetrics;
+      DisplayMetricsScreenDimensions(DisplayMetrics displayMetrics){
+        this.displayMetrics=displayMetrics;
+      }
+      @Override
+      public int getWidthPixels(){
+        return displayMetrics.widthPixels;
+      }
+      @Override
+      public int getHeightPixels(){
+        return displayMetrics.heightPixels;
+      }
     }
   }
 ```
-
-
+### DefaultConnectivityMonitorFactory
+```java
+  public class DefaultConnectivityMonitorFactory implements ConnectivityMonitorFactory{
+    private static final String TAG="ConectivityMonitor";
+    private static final String METWORK_PERMISSION="android.permission.ACCESS_NETWORK_STATE";
+    
+    @NonNull
+    @Override
+    public ConnectivityMonitor build(@NonNull Context context,@NonNull ConnectivityMonitor.ConnectivityListener listener){
+      int permissionResult =ContextCompat.checkSelfPermission(context,NETWORK_PERMISSION);
+      boolean hasPermission=permissionResult==PackageManager.PERMISSION_GRANTED;
+      return hasPermission?new DefaulConnectivityMonitor(context,listener):new NullConnectivityMonitor();
+    }
+  }
+```
+### LruBitmapPool
+```java
+  public class LruBitmapPool implements BitmapPool{
+    private static final String TAG="LruBitmapPool";
+    private static final Bitmap.Config.DEFAULT_CONFIG=Bitmap.Config.ARAG_8888;
+    private final LruPoolStrategy strategy;
+    private final Set<Bitmap.Config> allowedConfigs;
+    private final long initialMaxSize;
+    private final BitmapTracker tracker;
+    private long maxSize;
+    private long currentSize;
+    private int hits;
+    private int misses;
+    private int puts;
+    privatte int evictions;
+    LruBitmapPool(long maxSize,LruPoolStrategy strategy,Set<Bitmap.Config> allowConfigs){
+      this.initialMaxSize=maxSize;
+      this.maxSize=maxSize;
+      this.strategy=strategy;
+      this.allowedConfigs=allowedConfigs;
+      this.tracker=new NullBitmapTracker();
+    }
+    public LruBitmapPool(long maxSize){
+      this(maxSize,getDefaultStrategy(),getDefaultAllowedConfigs());
+    }
+    public LruBitmapPool(long maxSize,Set<Bitmap.Config> allowedConfigs){
+      this(maxSize,getDefaultStrategy(),allowedConfigs);
+    }
+    @Override
+    public long getMaxSize(){
+      return maxSize;
+    }
+    @Override
+    public synchronized void setSizeMultiplier(float sizeMultiplier){
+      maxSize=Math.round(initialMaxSize*sizeMultiplier);
+      evict();
+    }
+    @Override
+    public synchronized void put(Bitmap bitmap){
+      if(bitmap==null){
+        throw new NullPointerException("Bitmap must not be null");
+      }
+      if(bitmap.isRecycled()){
+        throw new IllegalStateException("Cannot pool recycled bitmap");
+      }
+      if(!bitmap.isMutable()||strategy.getSize(bitmap)>maxSize||!allowedConfigs.contains(bitmap.getConfig())){
+        bitmap.recycle();
+        return;
+      }
+      final int size=strategy.getSize(bitmap);
+      strategy.put(bitmap);
+      tracker.add(bitmap);
+      puts++;
+      currentSize+=size;
+      dump();
+      evict();
+    }
+    private void evict(){
+      trimToSize(maxSize);
+    }
+    @Override
+    @NonNull
+    public Bitmap get(int width,int height,Bitmap.Config config){
+      Bitmap result=getDirtyOrNull(width,height,config);
+      if(result!=null){
+        result.eraseColor(Color.TRANSPARENT);
+      }else{
+        result=createBitmap(width,height,config);
+      }
+      return result;
+    }
+    @NonNull
+    @Override
+    public Bitmap getDirty(int width,int height,Bitmap.Config config){
+      Bitmap result=getDirtyOrNull(width,height,config);
+      if(result==null){
+        result=createBitmap(width,height,config);
+      }
+      return result;
+    }
+    @NonNull
+    private static Bitmap createBitmap(int width,int height,@Nullable Bitmap.Config config){
+      return Bitmap.createBitmap(width,height,config!=null?config:DEFAULT_CONFIG);
+    }
+    @TargetApi(Build.VERSION_CODES.O)
+    private static void assertNotHardwareConfig(Bitmap.Config config){
+      if(Build.VERISON.SDK_INT<Build.VERSION_CODES.O){
+        return;
+      }
+      if(config==Bitmap.Config.HARDWARE){
+        throw new IllegalArgumentException("Connot create a mutalbe Bitmap with config: "+config+". Consider setting Downsample#ALLOW_HARDWARE_CONFIG to false in your RequestOptions and/or in GlideBuilder.setDefaultRequestOptions");
+      }
+    }
+    
+  }
+```
 
 
 
